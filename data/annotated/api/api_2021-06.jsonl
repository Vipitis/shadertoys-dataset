{"id": "flXXR8", "name": "profile#2", "author": "mariia_sharkovskaya", "description": "profile, using triangles", "tags": ["profile2"], "likes": 0, "viewed": 197, "published": 3, "date": "1625086896", "time_retrieved": "2024-07-30T19:13:00.965203", "image_code": "float _(float a, float b, float c){\n                  return max(a,max(b,c));\n        }\n             \n        float L(vec2 p, vec2 P0, vec2 P1){\n                float a = -(P1.y-P0.y);\n                float b = (P1.x-P0.x);\n                float d = P0.x*P1.y- P0.y*P1.x;\n                float x = p.x;\n                float y = p.y;\n                \n                 return a*x + b*y + d;\n        }\n    \n    float T(vec2 p, vec2 P0, vec2 P1, vec2 P2){\n          return _(\n                     L(p, P0, P1),\n                     L(p, P1, P2),\n                     L(p, P2, P0)\n                   );\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// digitalid Pi profile\n vec2   P[154];\n   P[0] = vec2(-0.1775,0.44359);\nP[1] = vec2(-0.14587,-0.79907 );\nP[2] = vec2(0.79965,0.39413);\nP[3] = vec2(-0.18102,0.44359);\nP[4] = vec2(0.18102,0.60742 );\nP[5] = vec2(0.79613 ,0.39722 );\nP[6] = vec2(0.93673 ,-0.51159 );\nP[7] = vec2(-0.14587 ,-0.79907);\nP[8] = vec2(-0.38137,-0.58269);\nP[9] = vec2(-0.16344,-0.19629);\nP[10] = vec2(0.93673,-0.51159);\nP[11] = vec2(0.23726,-0.31066);\nP[12] = vec2(0.23726,-0.31066);\nP[13] = vec2(-0.1775,0.44359);\nP[14] = vec2(0.23726,-0.31066);\nP[15] = vec2(-0.15993,-0.19938);\nP[16] = vec2(-0.38137,-0.013910);\nP[17] = vec2(-0.15993,-0.19938);\nP[18] = vec2(-0.17399,0.44668);\nP[19] = vec2(-0.32865,-0.48686);\nP[20] = vec2(0.23726,-0.31066);\nP[21] = vec2(0.74341,-0.92272);\nP[22] = vec2(-0.14236,-0.79598);\nP[23] = vec2(-0.30053,-0.78053);\nP[24] = vec2(-0.38137,-0.58269);\nP[25] = vec2(-0.15641,-0.434319);\nP[26] = vec2(-0.38137,-0.017002);\nP[27] = vec2(-0.17399,0.44359);\nP[28] = vec2(-0.10018,0.54560);\nP[29] = vec2(0.18102,0.60742);\nP[30] = vec2(0.42004,0.57651);\nP[31] = vec2(0.79262,0.40031);\nP[32] = vec2(0.92619,-0.038640);\nP[33] = vec2(0.93673,-0.50850);\nP[34] = vec2(0.60984,-0.59505);\nP[35] = vec2(0.61687,-0.77125);\nP[36] = vec2(0.12127,-1.0680);\nP[37] = vec2(0.61687,-0.77125);\nP[38] = vec2(0.74341,-0.919635);\nP[39] = vec2(0.50088,-0.62906);\nP[40] = vec2(0.43761,-0.87944);\nP[41] = vec2(0.0017575,-0.81762);\nP[42] = vec2(0.1283,-1.0680);\nP[43] = vec2(0.50088,-0.62906);\nP[44] = vec2(0.0052724,-0.82071);\nP[45] = vec2(0.1283,-1.0649);\nP[46] = vec2(0.73638,-0.91963);\nP[47] = vec2(0.44112,-0.88253);\nP[48] = vec2(0.1283,-1.0649);\nP[49] = vec2(0.49736,-0.63524);\nP[50] = vec2(0.0017575,-0.81762);\nP[51] = vec2(0.73989,-0.91654);\nP[52] = vec2(0.44112,-0.88253);\nP[53] = vec2(-0.14938,-0.79598);\nP[54] = vec2(-0.38137,-0.58578);\nP[55] = vec2(-0.2935,-0.78053);\nP[56] = vec2(-0.38137,-0.58578);\nP[57] = vec2(-0.1529,-0.79289);\nP[58] = vec2(-0.38137,-0.58578);\nP[59] = vec2(-0.15641,-0.43431);\nP[60] = vec2(-0.14587,-0.79907);\nP[61] = vec2( -0.15641,-0.43740);\nP[62] = vec2( -0.38137,-0.58578);\nP[63] = vec2( -0.32513,-0.48686);\nP[64] = vec2( -0.38137,-0.020093);\nP[65] = vec2( -0.28295,-0.19938);\nP[66] = vec2( -0.32513,-0.48068);\nP[67] = vec2( -0.44464,-0.29830);\nP[68] = vec2( -0.3638,-0.16847);\nP[69] = vec2( -0.32865,-0.47141);\nP[70] = vec2( -0.49385,-0.36321);\nP[71] = vec2( -0.44464,-0.29521);\nP[72] = vec2( -0.33216,-0.46832);\nP[73] = vec2( -0.48682,-0.39722);\nP[74] = vec2( -0.49033,-0.36321);\nP[75] = vec2( -0.33216,-0.47141);\nP[76] = vec2( -0.38489,-0.52087);\nP[77] = vec2( -0.3884,-0.44668);\nP[78] = vec2( -0.32865,-0.47450);\nP[79] = vec2( -0.35677,-0.54250);\nP[80] = vec2( -0.3884,-0.52087);\nP[81] = vec2( -0.33216,-0.47450);\nP[82] = vec2( -0.48682,-0.39722);\nP[83] = vec2( -0.49385,-0.36012);\nP[84] = vec2( -0.32865,-0.47450);\nP[85] = vec2( -0.48682,-0.36940);\nP[86] = vec2( -0.48682,-0.39722);\nP[87] = vec2( -0.33919,-0.46213);\nP[88] = vec2( -0.48682,-0.36631);\nP[89] = vec2( -0.34622,-0.46213);\nP[90] = vec2( -0.2232,-0.30448);\nP[91] = vec2( -0.15641,-0.43431);\nP[92] = vec2( -0.14236,-0.79907);\nP[93] = vec2( 0.93322,-0.50850);\nP[94] = vec2( 0.89455,-0.82689);\nP[95] = vec2( 0.60984,-0.59815);\nP[96] = vec2( 0.77153,-0.84853);\nP[97] = vec2( 0.89104,-0.82689);\nP[98] = vec2( 0.9297,-0.51468);\nP[99] = vec2( 0.77153,-0.84853);\nP[100] = vec2( 0.78207,-0.93818);\nP[101] = vec2( 0.89455,-0.82380);\nP[102] = vec2( 0.91213,-0.93199);\nP[103] = vec2( 0.782090,-0.93818);\nP[104] = vec2( 0.90861,-0.92890);\nP[105] = vec2( 0.77504,-0.84544);\nP[106] = vec2( 0.77153,-0.84853);\nP[107] = vec2( 0.88752,-0.82689);\nP[108] = vec2( 0.81371,-0.76198);\nP[109] = vec2( 0.77504,-0.84544);\nP[110] = vec2( 0.77153,-0.84853);\nP[111] = vec2( 0.88752,-0.82689);\nP[112] = vec2( 0.81371,-0.76198);\nP[113] = vec2( 0.77504,-0.84544);\nP[114] = vec2( 0.81371,-0.76198);\nP[115] = vec2( 0.60633,-0.59815);\nP[116] = vec2( 0.76801,-0.84544);\nP[117] = vec2( 0.9297,-0.51777);\nP[118] = vec2( 0.89455,-0.82071);\nP[119] = vec2( 0.60633,0.60124);\nP[120] = vec2( 0.50088,-0.62597);\nP[121] = vec2( -0.17399,0.44049);\nP[122] = vec2( -0.26889,0.29830);\nP[123] = vec2( -0.38137,-0.0077280);\nP[124] = vec2( -0.22671,-0.30448);\nP[125] = vec2( -0.38137,-0.52087);\nP[126] = vec2( -0.3884,-0.44977);\nP[127] = vec2( -0.34271,-0.47450);\nP[128] = vec2( -0.49033,-0.36631);\nP[129] = vec2( -0.48682,-0.39722);\nP[130] = vec2( -0.34974,-0.47450);\nP[131] = vec2( -0.38137,-0.52396);\nP[132] = vec2( -0.35677,-0.54250);\nP[133] = vec2( -0.32513,-0.48377);\nP[134] = vec2( -0.14938,-0.79289);\nP[135] = vec2( -0.38137,0.58887);\nP[136] = vec2( -0.29701,-0.52705);\nP[137] = vec2( -0.32513,-0.48377);\nP[138] = vec2( -0.16344,-0.43431);\nP[139] = vec2( -0.29701,-0.52396);\nP[140] = vec2( -0.32513,-0.48686);\nP[141] = vec2( -0.38137,-0.58269);\nP[142] = vec2( -0.30053,-0.78362);\nP[143] = vec2( -0.16696,-0.44359);\nP[144] = vec2( -0.29701,-0.53323);\nP[145] = vec2( -0.26538,-0.68470);\nP[146] = vec2( -0.30404,-0.78053);\nP[147] = vec2( -0.14587,-0.79598);\nP[148] = vec2( -0.26538,-0.69088);\nP[149] = vec2( -0.1775,-0.44977);\nP[150] = vec2( -0.2935,-0.53014);\nP[151] = vec2( -0.26889,-0.68779);\nP[152] = vec2( -0.24077,-0.62287);\nP[153] = vec2( -0.30404,-0.53323);\n    vec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n    vec2 m = 1.0 - 2.0* iMouse.xy/iResolution.xy;\n\n     float x = p.x * iResolution.y/iResolution.x;\n     float y = p.y ;\n     \n     float mx = -m.y * iResolution.y/iResolution.x;\n     float my = -m.x ;\n           \n           \n            x/=mx;\n            y/=my;\n            \n            p.x=x;\n            p.y=y;\n   \n\n      float z = 1.0e25; //infinity?\n              for(int i=0;i<150;i++)\n                z = min(z, T(p, P[i],P[i+1], P[i+3]) );\n       float f = 0.25/z;\n\n    // Time varying pixel color\n               vec3 col = vec3(1.0, 1.0, 1.0);\n               if(f > 0.0)col.g = 1.0;\n              //  if(f >= 0.0)col.g = sin(iTime/1.0);\n                   else col.r = f;\n                \n\n    // Output to screen\n                 fragColor = vec4(col,1.0);\n}\n/*\n-0.1775     \t0.44359\n-0.14587     \t-0.79907\n0.79965     \t0.39413\n-0.18102     \t0.44359\n0.18102     \t0.60742\n0.79613     \t0.39722\n0.93673     \t-0.51150\n0.93673     \t-0.51150\n-0.14587     \t-0.79907\n-0.38137     \t-0.58269\n-0.16344     \t-0.19629\n0.93673     \t-0.51159\n0.23726     \t-0.31066\n0.23726     \t-0.31066\n-0.1775     \t0.44359\n0.23726     \t-0.31066\n-0.15993     \t-0.19938\n-0.38137     \t-0.013910\n-0.15993     \t-0.19938\n-0.17399     \t0.44668\n-0.32865     \t-0.48686\n0.23726     \t-0.31066\n0.74341     \t-0.92272\n-0.14236     \t-0.79598\n-0.30053     \t-0.78053\n-0.38137     \t-0.58269\n-0.15641     \t-0.43431\n-0.38137     \t-0.017002\n-0.17399     \t0.44359\n-0.10018     \t0.54560\n0.18102     \t0.60742\n0.42004     \t0.57651\n0.79262     \t0.40031\n0.92619     \t-0.038640\n0.93673     \t-0.50850\n0.60984     \t-0.59505\n0.61687     \t-0.77125\n0.12127     \t-1.0680\n0.74341     \t-0.91963\n0.50088     \t-0.62906\n0.43761     \t-0.87944\n0.0017575     \t-0.81762\n0.1283     \t-1.0680\n0.50088     \t-0.62906\n0.0052724     \t-0.82071\n0.1283     \t-1.0649\n0.73638     \t-0.91963\n0.44112     \t-0.88253\n0.1283     \t-1.0649\n0.0017575     \t-0.81762\n0.49736     \t-0.63524\n0.73989     \t-0.91654\n0.44112     \t-0.88253\n-0.14938     \t-0.79598\n-0.38137     \t-0.58578\n-0.2935     \t-0.78053\n-0.38137     \t-0.58578\n-0.1529     \t-0.79289\n-0.38137     \t-0.58578\n-0.15641     \t-0.43431\n-0.14587     \t-0.79907\n-0.15641     \t-0.43740\n-0.38137     \t-0.58578\n-0.32513     \t-0.48686\n-0.38137     \t-0.020093\n-0.28295     \t-0.19938\n-0.32513     \t-0.48068\n-0.44464     \t-0.29830\n-0.3638     \t-0.16847\n-0.32865     \t-0.47141\n-0.49385     \t-0.36321\n-0.44464     \t-0.29521\n-0.33216     \t-0.46832\n-0.48682     \t-0.39722\n-0.49033     \t-0.36321\n-0.33216     \t-0.47141\n-0.38489     \t-0.52087\n-0.3884     \t-0.44668\n-0.32865     \t-0.47450\n-0.35677     \t-0.54250\n-0.3884     \t-0.52087\n-0.33216     \t-0.47450\n-0.48682     \t-0.39722\n-0.49385     \t-0.36012\n-0.32865     \t-0.47450\n-0.48682     \t-0.36940\n-0.48682     \t-0.39722\n-0.33919     \t-0.46213\n-0.48682     \t-0.36631\n-0.34622     \t-0.46213\n-0.2232     \t-0.30448\n-0.15641     \t-0.43431\n-0.14236     \t-0.79907\n0.93322     \t-0.50850\n0.89455     \t-0.82689\n0.60984     \t-0.59815\n0.77153     \t-0.84853\n0.89104     \t-0.82689\n0.9297     \t-0.51468\n0.77153     \t-0.84853\n0.78207     \t-0.93818\n0.89455     \t-0.82380\n0.91213     \t-0.93199\n0.78207     \t-0.93818\n0.90861     \t-0.92890\n0.77504     \t-0.84544\n0.77153     \t-0.84853\n0.88752     \t-0.82689\n0.81371     \t-0.76198\n0.77504     \t-0.84544\n0.81371     \t-0.76198\n0.60633     \t-0.59815\n0.76801     \t-0.84544\n0.9297     \t-0.51777\n0.89455     \t-0.82071\n0.60633     \t-0.60124\n0.50088     \t-0.62597\n-0.17399     \t0.44049\n-0.26889     \t0.29830\n-0.38137     \t-0.0077280\n-0.22671     \t-0.30448\n-0.38137     \t-0.52087\n-0.3884     \t-0.44977\n-0.34271     \t-0.47450\n-0.49033     \t-0.36631\n-0.48682     \t-0.39722\n-0.34974     \t-0.47450\n-0.38137     \t-0.52396\n-0.35677     \t-0.54250\n-0.32513     \t-0.48377\n-0.14938     \t-0.79289\n-0.38137     \t-0.58887\n-0.29701     \t-0.52705\n-0.32513     \t-0.48377\n-0.16344     \t-0.43431\n-0.29701     \t-0.52396\n-0.32513     \t-0.48686\n-0.38137     \t-0.58269\n-0.30053     \t-0.78362\n-0.16696     \t-0.44359\n-0.29701     \t-0.53323\n-0.26538     \t-0.68470\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXXR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 87], [110, 110, 144, 144, 399], [409, 409, 452, 452, 604], [606, 606, 663, 687, 6670]], "test": "untested"}
{"id": "stsXzn", "name": "Reflections of N-E Shockwave", "author": "pyBlob", "description": "Compared to original:\n- Does not use arrays\n- Shows all reflections\n- uses iFrame (N=2000 might be very slow)", "tags": ["dynamicalsystem", "hyperbolicgeometry"], "likes": 3, "viewed": 255, "published": 3, "date": "1625081493", "time_retrieved": "2024-07-30T19:13:01.821914", "image_code": "/*  \n\thttp://math.ucsd.edu/%7Eaterras/bigbang.htm\n\tFrom Audrey Terras' Harmonic Analysis on Symmetric Spaces and Applications, 2nd edition, p. 316.\n\tExercise 3.6.19 (Harold Stark): Computer-Generated Movie of a Non-Euclidean Shock Wave. \n\tStark created this movie on his Atari ST which is still operating.\n*/\n\nconst int N = 2000;\nconst float y_start = 5.;\nconst float y_end = 10.;\n\nconst float width_screen = 10.;\n\nconst float time_reset = 2. * log2(float(N)) + log2(y_start) + log2(y_end);\n\n// performs consecutive translations in a single step (faster, but does not show all reflections)\nconst bool merge_translations = false;\n\nvoid circle_inversion(inout vec2 z) // z -> -1/z  ( = - conj(z) / |z|^2 )\n{\n\tz.x = -z.x;\n\tz /= dot(z,z);\n}\n\nvoid horizontal_translation(inout vec2 z) // z -> z+-1\n{\n    if (merge_translations)\n        z.x = fract(z.x + 0.5) - 0.5;\n    else\n        z.x = z.x < 0. ? z.x + 1. : z.x - 1.;\n}\n\nbool invert_circle(vec2 z)\n{\n    return dot(z, z) < 1.;\n}\n\nbool translate(vec2 z)\n{\n    return abs(z.x) > 0.5;\n}\n\nvoid plot(inout vec3 C, vec3 c, vec2 z, float r)\n{\n    if (dot(z, z) < r * r)\n        C = c;\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    float time = exp2(mod(float(iFrame) / 60., time_reset)); // time flows exponentially in hyperbolic space\n    float time_inv = 1. / time;\n\n    float f = width_screen / iResolution.x;\n    vec2 st = vec2(O - vec2(iResolution.x, 0) / 2.) * f;\n    \n    vec3 color = vec3(1);\n    if(abs(abs(st.x)-0.5) < f && length(st.xy) >= 1.) // Left and Right border of fundamental domain\n        color = vec3(0);\n    else if(abs(length(st.xy)-1.) < f) // lower circle of fundamental domain\n        color = vec3(0);\n\telse if(abs(st.x) <= 0.5 && length(st.xy) >= 1.)\n        color = vec3(.95);\n\n\tfor(int j=0; j<N; ++j)\n    {\n        float jf = float(j) / float(N);\n        vec3 point_color = vec3(sin(jf*2.), jf, 1.-jf);\n\t\n\t\tvec2 h = vec2(jf-0.5, y_start);\n\t\th.y *= time_inv;\n\t\t\n        while(invert_circle(h) || translate(h)) // Applying gamma, i.e. put into fundamental domain\n        {\n            if(invert_circle(h))\n            {\n                plot(color, vec3(1,0,0), st - h, f);\n                circle_inversion(h);\n            }\n            if(translate(h))\n            {\n                plot(color, vec3(1,0,1), st - h, f);\n                horizontal_translation(h);\n            }\n        }\n        plot(color, point_color, st - h, f);\n\t}\n\n    C = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[630, 630, 705, 705, 736], [738, 738, 794, 794, 917], [919, 919, 947, 947, 976], [978, 978, 1002, 1002, 1031], [1033, 1033, 1083, 1083, 1127], [1129, 1129, 1168, 1168, 2432]], "test": "untested"}
{"id": "NtsSzr", "name": "My first name and second name", "author": "MaksymYakushev", "description": "Name and surname", "tags": ["nameandsurname"], "likes": 0, "viewed": 188, "published": 3, "date": "1625080334", "time_retrieved": "2024-07-30T19:13:02.969843", "image_code": "float Circle(vec2 uv, vec2 p, float r) \n{\n    float d = length(uv - p);\n     float c = smoothstep(r, r - 0.001, d);\n      return c;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n     uv.x *= iResolution.x / iResolution.y;\n    \n      float point = Circle(uv, vec2(-0.60, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.60, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.60, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.60, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.60, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.60, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.60, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.62, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.64, 0.30), 0.01);  // Я\n       point += Circle(uv, vec2(-0.66, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.64, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.62, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.62, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.64, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.18), 0.01);\n    \n       point += Circle(uv, vec2(-0.55, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.55, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.55, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.55, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.55, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.55, 0.28), 0.01); //К\n       point += Circle(uv, vec2(-0.55, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.53, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.51, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.49, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.53, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.51, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.49, 0.18), 0.01);\n    \n       point += Circle(uv, vec2(-0.37, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.37, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.37, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.37, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.37, 0.26), 0.01); //У\n       point += Circle(uv, vec2(-0.37, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.37, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.39, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.41, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.43, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.45, 0.30), 0.01);\n    \n       point += Circle(uv, vec2(-0.32, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.32, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.32, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.32, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.32, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.32, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.32, 0.30), 0.01); \n       point += Circle(uv, vec2(-0.30, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.30, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.28, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.28, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.24, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.24, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.22, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.22, 0.18), 0.01); //Ш\n       point += Circle(uv, vec2(-0.26, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.20, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.20, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.20, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.20, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.20, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.20, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.20, 0.30), 0.01);\n    \n       point += Circle(uv, vec2(-0.16, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.24), 0.01); //Е\n       point += Circle(uv, vec2(-0.16, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.30), 0.01); \n       point += Circle(uv, vec2(-0.16, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.14, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.12, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.10, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.14, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.12, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.10, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.14, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.12, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.10, 0.30), 0.01);\n    \n       point += Circle(uv, vec2(-0.06, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.06, 0.20), 0.01);\n       point += Circle(uv, vec2(-0.06, 0.22), 0.01);\n       point += Circle(uv, vec2(-0.06, 0.24), 0.01); //В\n       point += Circle(uv, vec2(-0.06, 0.26), 0.01);\n       point += Circle(uv, vec2(-0.06, 0.28), 0.01);\n       point += Circle(uv, vec2(-0.06, 0.30), 0.01); \n       point += Circle(uv, vec2(-0.04, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.02, 0.30), 0.01);\n       point += Circle(uv, vec2(-0.04, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.02, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.0, 0.24), 0.01);\n       point += Circle(uv, vec2(0.02, 0.24), 0.01);\n       point += Circle(uv, vec2(-0.04, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.02, 0.18), 0.01);\n       point += Circle(uv, vec2(-0.0, 0.18), 0.01);\n       point += Circle(uv, vec2(0.02, 0.18), 0.01);\n       point += Circle(uv, vec2(0.02, 0.20), 0.01);\n       point += Circle(uv, vec2(0.02, 0.22), 0.01);\n       point += Circle(uv, vec2(0.02, 0.24), 0.01);\n       point += Circle(uv, vec2(0.0, 0.26), 0.01);\n       point += Circle(uv, vec2(0.0, 0.28), 0.01);\n    \n       point += Circle(uv, vec2(-0.66, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.06), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.66, 0.10), 0.01); \n       point += Circle(uv, vec2(-0.64, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.62, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.60, 0.06), 0.01);\n       point += Circle(uv, vec2(-0.58, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.56, 0.10), 0.01);//М\n       point += Circle(uv, vec2(-0.54, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.54, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.54, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.54, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.54, 0.06), 0.01);\n       point += Circle(uv, vec2(-0.54, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.54, 0.10), 0.01);\n    \n       point += Circle(uv, vec2(-0.48, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.48, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.48, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.48, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.48, 0.06), 0.01); //А\n       point += Circle(uv, vec2(-0.48, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.46, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.44, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.42, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.46, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.44, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.42, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.40, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.40, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.40, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.40, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.40, 0.06), 0.01);\n       point += Circle(uv, vec2(-0.40, 0.08), 0.01);\n     \n       point += Circle(uv, vec2(-0.36, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.36, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.36, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.36, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.36, 0.06), 0.01); //К\n       point += Circle(uv, vec2(-0.36, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.36, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.34, 0.06), 0.01);\n       point += Circle(uv, vec2(-0.34, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.32, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.32, 0.00), 0.01);\n       point += Circle(uv, vec2(-0.30, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.30, -0.02), 0.01);\n   \n       point += Circle(uv, vec2(-0.26, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.06), 0.01); //С\n       point += Circle(uv, vec2(-0.26, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.26, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.24, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.22, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.20, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.24, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.22, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.20, -0.02), 0.01);\n    \n       point += Circle(uv, vec2(-0.16, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.06), 0.01); //И\n       point += Circle(uv, vec2(-0.16, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.16, 0.10), 0.01);\n       point += Circle(uv, vec2(-0.14, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.12, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.10, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.08, 0.06), 0.01); \n       point += Circle(uv, vec2(-0.06, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.04, -0.02), 0.01);\n       point += Circle(uv, vec2(-0.04, 0.0), 0.01);\n       point += Circle(uv, vec2(-0.04, 0.02), 0.01);\n       point += Circle(uv, vec2(-0.04, 0.04), 0.01);\n       point += Circle(uv, vec2(-0.04, 0.06), 0.01); \n       point += Circle(uv, vec2(-0.04, 0.08), 0.01);\n       point += Circle(uv, vec2(-0.04, 0.10), 0.01);\n    \n       point += Circle(uv, vec2(0.02, -0.02), 0.01);\n       point += Circle(uv, vec2(0.02, 0.0), 0.01);\n       point += Circle(uv, vec2(0.02, 0.02), 0.01);\n       point += Circle(uv, vec2(0.02, 0.04), 0.01);\n       point += Circle(uv, vec2(0.02, 0.06), 0.01);\n       point += Circle(uv, vec2(0.02, 0.08), 0.01);\n       point += Circle(uv, vec2(0.02, 0.10), 0.01); \n       point += Circle(uv, vec2(0.04, 0.10), 0.01);\n       point += Circle(uv, vec2(0.06, 0.08), 0.01);\n       point += Circle(uv, vec2(0.08, 0.06), 0.01);\n       point += Circle(uv, vec2(0.10, 0.08), 0.01);\n       point += Circle(uv, vec2(0.12, 0.10), 0.01);//М\n       point += Circle(uv, vec2(0.14, -0.02), 0.01);\n       point += Circle(uv, vec2(0.14, 0.0), 0.01);\n       point += Circle(uv, vec2(0.14, 0.02), 0.01);\n       point += Circle(uv, vec2(0.14, 0.04), 0.01);\n       point += Circle(uv, vec2(0.14, 0.06), 0.01);\n       point += Circle(uv, vec2(0.14, 0.08), 0.01);\n       point += Circle(uv, vec2(0.14, 0.10), 0.01);\n \n        fragColor = vec4(vec3(point),1.0);\n         vec3 pic = vec3(1.0, 1.0, 1.0)*point;\n          fragColor = vec4(pic, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 133], [134, 134, 189, 189, 11709]], "test": "untested"}
{"id": "sllXRn", "name": "Fork Realy simp jhylands 284", "author": "jhylands", "description": "A REALY simple sky shader. Looks like real atmospheric scattering but it is not. :D", "tags": ["sunset", "sun", "fake", "sky", "orange", "blue", "day", "scatter", "atmospheric"], "likes": 4, "viewed": 364, "published": 3, "date": "1625078334", "time_retrieved": "2024-07-30T19:13:03.837523", "image_code": "const float coeiff = 0.25;\nconst vec3 totalSkyLight = vec3(0.3, 0.5, 1.0);\n\nvec3 mie(float dist, vec3 sunL){\n    return max(exp(-pow(dist, 0.25)) * sunL - 0.4, 0.0);\n}\n\nvec3 getSky(vec2 uv){\n\t\n\tvec2 sunPos = vec2(0.5, cos(iTime * 0.3 + 3.14 * 0.564));\n    \n    float sunDistance = distance(uv, clamp(sunPos, -1.0, 1.0));\n\t\n\tfloat scatterMult = clamp(sunDistance, 0.0, 1.0);\n\tfloat sun = clamp(1.0 - smoothstep(0.01, 0.011, scatterMult), 0.0, 1.0);\n\t\n\tfloat dist = uv.y;\n\tdist = (coeiff * mix(scatterMult, 1.0, dist)) / dist;\n    \n    vec3 mieScatter = mie(sunDistance, vec3(1.0));\n\t\n\tvec3 color = dist * totalSkyLight;\n    \n    color = max(color, 0.0);\n    \n\tcolor = max(mix(pow(color, 1.0 - color),\n\tcolor / (2.0 * color + 0.5 - color),\n\tclamp(sunPos.y * 2.0, 0.0, 1.0)),0.0)\n\t+ sun + mieScatter;\n\t\n\tcolor *=  (pow(1.0 - scatterMult, 10.0) * 10.0) + 1.0;\n\t\n\tfloat underscatter = distance(sunPos.y * 0.5 + 0.5, 1.0);\n\t\n\tcolor = mix(color, vec3(0.0), clamp(underscatter, 0.0, 1.0));\n\t\n\treturn color;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec3 color = getSky(fragCoord.xy / iResolution.x);\n\t\n\tcolor = color / (2.0 * color + 0.5 - color);\n\t\n\tfragColor = vec4(color, 1.0);\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tvec3 color = getSky(fragCoord.xy / iResolution.x);\n\t\n\tcolor = color / (2.0 * color + 0.5 - color);\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllXRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 108, 108, 167], [169, 169, 190, 190, 1001], [1003, 1003, 1059, 1059, 1199], [1200, 1200, 1294, 1294, 1429]], "test": "untested"}
{"id": "ftlSzr", "name": "Simple function vizualizer", "author": "mrange", "description": "License CC0: Simple function vizualizer\nI had the need to visualize some functions so created a simple visualizer\nThought perhaps someone else could find use for it. I am sure examples\nalready exists on shadertoy but I didn't find them", "tags": ["2d", "simple"], "likes": 5, "viewed": 248, "published": 3, "date": "1625074992", "time_retrieved": "2024-07-30T19:13:04.777012", "image_code": "// -----------------------------------------------------------------------------\n// License CC0: Simple function vizualizer\n//  I had the need to visualize some functions so created a simple visualizer\n//  Thought perhaps someone else could find use for it. I am sure examples\n//  already exists on shadertoy but I didn't find them\n// -----------------------------------------------------------------------------\n\n#define ZOOM 0.5\n#define TIME 1.0*iTime\n\n// f - the function that is visualized\nfloat f(float x) {\n  return sin(x)*sin(x*sqrt(0.5));\n}\n\n// -----------------------------------------------------------------------------\n\n// From: http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// From: https://iquilezles.org/articles/distfunctions2d\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec2 df(vec2 p, float z, float aa) {\n  p /= z;\n  vec2 gp = p;\n  float m = aa*2.0;\n  float n = mod1(p.x, m);\n  float d = 1E3;\n  \n  const int reps = 3;\n\n  for (int i = -reps; i <= reps; ++i) {\n    float x0 = (n + float(i))*m + TIME*0.5;\n    float x1 = (n + float(i + 1))*m + TIME*0.5;\n  \n    float y0 = 0.5*f(2.0*x0);\n    float y1 = 0.5*f(2.0*x1);\n    \n    float dd = segment(p, vec2(-m*0.5 + m * float(i), y0), vec2(m*0.5 + m * float(i), y1))-2.0*aa/z;\n    \n    d = min(d, dd);\n  }\n  \n  gp.x += TIME*0.5;\n  mod1(gp.x, 0.5);\n  mod1(gp.y, 0.5);\n  float dgrid = min(abs(gp.x), abs(gp.y))-aa/z;\n  return vec2(d, dgrid)*z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  float aa = 2.0/iResolution.y;\n  \n  vec2 d = df(p, ZOOM, aa);\n \n  vec3 col = mix(vec3(0.05), vec3(0.1), q.y);\n  col = mix(col, vec3(0.5, 0.75, 1.0), smoothstep(-aa, aa, -d.y));\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -d.x));\n  \n  col = pow(col, vec3(1.0/2.0));\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlSzr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[455, 494, 512, 512, 548], [632, 669, 708, 708, 833], [835, 892, 931, 931, 1044], [1046, 1046, 1082, 1082, 1664], [1666, 1666, 1721, 1721, 2126]], "test": "untested"}
{"id": "NtsSzn", "name": "Сheburashka", "author": "MaksymYakushev", "description": "cheburashka", "tags": ["cheburashka"], "likes": 1, "viewed": 192, "published": 3, "date": "1625073721", "time_retrieved": "2024-07-30T19:13:05.729465", "image_code": "float Circle(vec2 uv, vec2 p, float r) \n{\n    float d = length(uv - p);\n     float c = smoothstep(r, r - 0.001, d);\n      return c;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n     uv.x *= iResolution.x / iResolution.y;\n    \n      float body = Circle(uv, vec2(0.0, 0.18), 0.17);\n       body += Circle(uv, vec2(-0.23, 0.22), 0.10);\n       body += Circle(uv, vec2(0.23, 0.22), 0.10);\n       body -= Circle(uv, vec2(-0.20, 0.22), 0.07);\n       body -= Circle(uv, vec2(0.20, 0.22), 0.07);\n       body -= Circle(uv, vec2(0.055, 0.22), 0.03);\n       body -= Circle(uv, vec2(-0.055, 0.22), 0.03);\n       body += Circle(uv, vec2(0.25, -0.07), 0.09);\n       body += Circle(uv, vec2(-0.25, -0.07), 0.09);\n       body -= Circle(uv, vec2(0.23, -0.07), 0.05);\n       body -= Circle(uv, vec2(-0.23, -0.07), 0.05);\n       body -= Circle(uv, vec2(0.30, -0.03), 0.02);\n       body -= Circle(uv, vec2(-0.30, -0.03), 0.02);\n       body -= Circle(uv, vec2(0.30, -0.07), 0.02);\n       body -= Circle(uv, vec2(-0.30, -0.07), 0.02);\n       body -= Circle(uv, vec2(0.30, -0.11), 0.02);\n       body -= Circle(uv, vec2(-0.30, -0.11), 0.02);\n       body += Circle(uv, vec2(-0.22, -0.36), 0.11);\n       body += Circle(uv, vec2(0.22, -0.36), 0.11);\n       body -= Circle(uv, vec2(-0.22, -0.39), 0.06);\n       body -= Circle(uv, vec2(0.22, -0.39), 0.06);\n       body -= Circle(uv, vec2(-0.22, -0.28), 0.02);\n       body -= Circle(uv, vec2(0.22, -0.28), 0.02);\n       body -= Circle(uv, vec2(-0.26, -0.30), 0.02);\n       body -= Circle(uv, vec2(0.26, -0.30), 0.02);\n       body -= Circle(uv, vec2(-0.30, -0.32), 0.02);\n       body -= Circle(uv, vec2(0.30, -0.32), 0.02);\n       body += Circle(uv, vec2(0.0, -0.17), 0.22);\n       body -= Circle(uv, vec2(0.0, -0.09), 0.02);\n       body -= Circle(uv, vec2(0.0, -0.17), 0.02);\n       body -= Circle(uv, vec2(0.0, -0.26), 0.02);\n   \n      float mouth = Circle(uv, vec2(0.0, 0.16), 0.08);\n       mouth -= Circle(uv, vec2(0.0, 0.21), 0.1);\n\n        body -= mouth;\n        body -= Circle(uv, vec2(0.058, 0.22), 0.03);\n        body -= Circle(uv, vec2(-0.058, 0.22), 0.03);\n \n         fragColor = vec4(vec3(body),1.0);\n          vec3 pic = vec3(1.0, 1.0, 1.0)*body;\n           fragColor = vec4(pic, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 133], [134, 134, 189, 189, 2287]], "test": "untested"}
{"id": "7tfSzr", "name": "Чебурашка Филипенко", "author": "filipenkonikita", "description": "Чебурашка", "tags": [], "likes": 0, "viewed": 179, "published": 3, "date": "1625069270", "time_retrieved": "2024-07-30T19:13:06.480457", "image_code": "    vec3 rgb(float r, float g, float b) {\n        return vec3(r / 255.0, g / 255.0, b / 255.0);\n    }\n\n    vec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n        float t = 0.0;\n        if ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n          && (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n          t = 1.0;\n        }\n        return vec4(color, t);\n    }\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 layer1 = vec4(rgb(144.0, 144.0, 144.0), 1.0);\n    vec3 color = rgb(101.0, 67.0, 33.0);\n\tvec2 uv = fragCoord.xy;\n\tvec2 center;\n     center.x= iResolution.x * 0.5;\n     center.y= iResolution.y * 0.4;\n\tfloat width = 0.25 * iResolution.x;\n\tfloat height = 0.25 * iResolution.x;\n    vec4 layer2 = rectangle(uv, center, width, height, color);\n    vec2 center2;\n     center2.x=iResolution.x*0.5;\n     center2.y=iResolution.y*0.76;\n    float width2=0.15*iResolution.x;\n    float height2=0.15*iResolution.x;\n\tvec4 layer3=rectangle(uv,center2,width2,height2,color);\n    layer2+=layer3;\n    vec2 center3;\n     center3.x=iResolution.x*0.4;\n     center3.y=iResolution.y*0.94;\n    float width3=0.05*iResolution.x;\n    float height3=0.05*iResolution.x;\n\tvec4 layer4=rectangle(uv,center3,width3,height3,color);\n    layer2+=layer4;\n    vec2 center4;\n     center4.x=iResolution.x*0.6;\n     center4.y=iResolution.y*0.94;\n    float width4=0.05*iResolution.x;\n    float height4=0.05*iResolution.x;\n\tvec4 layer5=rectangle(uv,center4,width4,height4,color);\n    layer2+=layer5;\n    vec2 center5;\n     center5.x=iResolution.x*0.6;\n     center5.y=iResolution.y*0.94;\n    float width5=0.025*iResolution.x;\n    float height5=0.025*iResolution.x;\n\tvec4 layer6=rectangle(uv,center5,width5,height5,color);\n    layer2-=layer6;\n    vec2 center6;\n     center6.x=iResolution.x*0.4;\n     center6.y=iResolution.y*0.94;\n    float width6=0.025*iResolution.x;\n    float height6=0.025*iResolution.x;\n\tvec4 layer7=rectangle(uv,center6,width6,height6,color);\n    layer2-=layer7;\n    vec2 center7;\n     center7.x=iResolution.x*0.325;\n     center7.y=iResolution.y*0.131;\n    float width7=0.1*iResolution.x;\n    float height7=0.05*iResolution.x;\n\tvec4 layer8=rectangle(uv,center7,width7,height7,color);\n    layer2+=layer8;\n    vec2 center8;\n     center8.x=iResolution.x*(0.5+0.5-0.325);\n     center8.y=iResolution.y*0.131;\n    float width8=0.1*iResolution.x;\n    float height8=0.05*iResolution.x;\n\tvec4 layer9=rectangle(uv,center8,width8,height8,color);\n    layer2+=layer9;\n    vec2 center9;\n     center9.x=iResolution.x*0.346;\n     center9.y=iResolution.y*0.5;\n    float width9=0.05*iResolution.x;\n    float height9=0.1*iResolution.x;\n\tvec4 layer10=rectangle(uv,center9,width9,height9,color);\n    layer2+=layer10;\n    vec2 center10;\n     center10.x=iResolution.x*(0.5+0.5-0.346);\n     center10.y=iResolution.y*0.5;\n    float width10=0.05*iResolution.x;\n    float height10=0.1*iResolution.x;\n\tvec4 layer11=rectangle(uv,center10,width10,height10,color);\n    layer2+=layer11;\n    vec2 center11;\n     center11.x=iResolution.x*0.5;\n     center11.y=iResolution.y*0.46;\n    float width11=0.1*iResolution.x;\n    float height11=0.15*iResolution.x;\n\tvec4 layer12=rectangle(uv,center11,width11,height11,color);\n    layer2-=layer12;\n    fragColor = mix( layer1,layer2, layer2.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfSzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 41, 41, 101], [107, 107, 181, 181, 422], [429, 429, 486, 486, 3319]], "test": "untested"}
{"id": "NtsSRn", "name": "Evolving mandelbrot", "author": "Swiiz", "description": "An evolving mandelbrot", "tags": ["mandelbrot", "complex", "evolving"], "likes": 3, "viewed": 192, "published": 3, "date": "1625065148", "time_retrieved": "2024-07-30T19:13:07.247406", "image_code": "float carg(vec2 Z)   {return   atan( (Z).y, (Z).x ) ;}\nvec2 CS(float a) {return vec2( cos(a), sin(a) ); }\nvec2 cmul(vec2 A,vec2 B) {return ( mat2( A, -(A).y, (A).x ) * (B) ) ;}  // by deMoivre formula\nvec2 pol2cart(vec2 U) { return (U).x * CS( (U).y ); }\nvec2 cpow(vec2 Z, float v) {return   pol2cart( vec2( pow(length(Z),v) , (v) * carg(Z) ) ) ;}\n\nconst vec4 colorPalette = -vec4(0,23,21,0);\nconst vec4 finalColor = vec4(.0);\nconst int hueModulus = 30;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 5.;\n    int recursion = 50, i = 0;\n    vec2 c = (fragCoord / iResolution.x - .5) * -zoom + -iMouse.xy/iResolution.xy, z = c;\n    for(; i <= recursion && length(z) <= 10. ; i++ ) z = cpow(z, iTime / 5. + 1.) + c;\n    fragColor =  i - 1 == recursion ? finalColor : .6 + .6 * cos( 6.3 *  (float((i - 1) % hueModulus) / float(hueModulus)) + colorPalette);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 54], [55, 55, 73, 73, 105], [106, 106, 132, 132, 176], [178, 201, 224, 224, 254], [255, 255, 283, 283, 347]], "test": "untested"}
{"id": "stXXzn", "name": "profile (30.06.2021)", "author": "mariia_sharkovskaya", "description": "profile by photo,using ogs.glitch.me", "tags": ["profile"], "likes": 0, "viewed": 217, "published": 3, "date": "1625059010", "time_retrieved": "2024-07-30T19:13:08.258702", "image_code": " float _(float a, float b, float c){\n                  return max(a,max(b,c));\n        }\n             \n        float L(vec2 p, vec2 P0, vec2 P1){\n                float a = (P1.y-P0.y);\n                float b = (P1.x-P0.x);\n                float d = P0.x*P1.y- P0.y*P1.x;\n                float x = p.x;\n                float y = p.y;\n                \n                 return a*x + b*y + d;\n        }\n    \n    float T(vec2 p, vec2 P0, vec2 P1, vec2 P2){\n          return _(\n                     L(p, P0, P1),\n                     L(p, P1, P2),\n                     L(p, P2, P0)\n                   );\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// digitalized Pi profile\n vec2   P[130];\n        P[0] = vec2( 0.99649,-1.0000);\n        P[1] = vec2( -0.02807,-0.97793);\n        P[2] = vec2( 0.031579,-0.88690);\n        P[3] = vec2( 0.066667,-0.84828);\n        P[4] = vec2( 0.094737,-0.82897);\n        P[5] = vec2( 0.11228,-0.81241);\n        P[6] = vec2( 0.045614,-0.68276);\n        P[7] = vec2( 0.017544,-0.64414);\n        P[8] = vec2( -0.0070175,-0.62207);\n        P[9] = vec2( -0.038596,-0.60828);\n        P[10] = vec2( -0.12982,-0.60828);\n        P[11] = vec2( -0.17895,-0.60828);\n        P[12] = vec2( -0.22807,-0.60000);\n        P[13] = vec2( -0.2807,-0.59172);\n        P[14] = vec2( -0.31228,-0.58069);\n        P[15] = vec2( -0.33684,-0.56138);\n        P[16] = vec2( -0.35439,-0.53379);\n        P[17] = vec2( -0.35439,-0.50621);\n        P[18] = vec2( -0.35439,-0.47310);\n        P[19] = vec2( -0.35439,-0.45655);\n        P[20] = vec2( -0.35439,-0.44828);\n        P[21] = vec2( -0.36842,-0.43724);\n        P[22] = vec2( -0.37544,-0.42345);\n        P[23] = vec2( -0.38246,-0.41241);\n        P[24] = vec2( -0.38246,-0.39586);\n        P[25] = vec2( -0.37895,-0.38483);\n        P[26] = vec2( -0.36842,-0.37655);\n        P[27] = vec2( -0.3614,-0.37379);\n        P[28] = vec2( -0.37544,-0.36552);\n        P[29] = vec2( -0.38246,-0.35724);\n        P[30] = vec2( -0.38596,-0.35448);\n        P[31] = vec2( -0.38596,-0.32138);\n        P[32] = vec2( -0.38596,-0.30759);\n        P[33] = vec2( -0.38947,-0.29379);\n        P[34] = vec2( -0.40351,-0.28276);\n        P[35] = vec2( -0.42807,-0.27448);\n        P[36] = vec2( -0.45965,-0.26345);\n        P[37] = vec2( -0.49123,-0.24966);\n        P[38] = vec2( -0.49825,-0.23310);\n        P[39] = vec2( -0.49825,-0.21655);\n        P[40] = vec2( -0.48772,-0.19172);\n        P[41] = vec2( -0.45263,-0.15862);\n        P[42] = vec2( -0.44211,-0.14759);\n        P[43] = vec2( -0.39649,-0.073103);\n        P[44] = vec2( -0.38596,-0.059310);\n        P[45] = vec2( -0.37544,-0.045517);\n        P[46] = vec2( -0.37193,-0.028966);\n        P[47] = vec2( -0.37193,-0.0013793);\n        P[48] = vec2( -0.37895,0.023448);\n        P[49] = vec2( -0.38947,0.059310);\n        P[50] = vec2( -0.39298,0.084138);\n        P[51] = vec2( -0.38596,0.12552);\n        P[52] = vec2( -0.3614,0.18069);\n        P[53] = vec2( -0.3193,0.28276);\n        P[54] = vec2( -0.29474,0.34897);\n        P[55] = vec2( -0.27719,0.36828);\n        P[56] = vec2( -0.27018,0.37655);\n        P[57] = vec2( -0.25263,0.38759);\n        P[58] = vec2( -0.24561,0.39586);\n        P[59] = vec2( -0.24211,0.42621);\n        P[60] = vec2( -0.24211,0.45379);\n        P[61] = vec2( -0.22456,0.49517);\n        P[62] = vec2( -0.1614,0.56414);\n        P[63] = vec2( -0.080702,0.61103);\n        P[64] = vec2( -0.031579,0.62759);\n        P[65] = vec2( 0.042105,0.63862);\n        P[66] = vec2( 0.12281,0.65517);\n        P[67] = vec2( 0.18246,0.66069);\n        P[68] = vec2( 0.22807,0.66069);\n        P[69] = vec2( 0.27719,0.64690);\n        P[70] = vec2( 0.31579,0.64414);\n        P[71] = vec2( 0.35439,0.64414);\n        P[72] = vec2( 0.44561,0.61655);\n        P[73] = vec2( 0.52281,0.60000);\n        P[74] = vec2( 0.56842,0.57241);\n        P[75] = vec2( 0.6,0.55310);\n        P[76] = vec2( 0.64211,0.54207);\n        P[77] = vec2( 0.64912,0.53655);\n        P[78] = vec2( 0.7193,0.52000);\n        P[79] = vec2( 0.78246,0.49793);\n        P[80] = vec2( 0.82456,0.47586);\n        P[81] = vec2( 0.84912,0.42897);\n        P[82] = vec2( 0.87368,0.39862);\n        P[83] = vec2( 0.86667,0.36000);\n        P[84] = vec2( 0.87018,0.34069);\n        P[85] = vec2( 0.88421,0.28276);\n        P[86] = vec2( 0.8807,0.23586);\n        P[87] = vec2( 0.89474,0.21103);\n        P[88] = vec2( 0.89825,0.18897);\n        P[89] = vec2( 0.91579,0.16966);\n        P[90] = vec2( 0.9193,0.12828);\n        P[91] = vec2( 0.93684,0.10897);\n        P[92] = vec2( 0.93684,0.10069);\n        P[93] = vec2( 0.93333,0.081379);\n        P[94] = vec2( 0.93684,0.064828);\n        P[95] = vec2( 0.94386,0.051034);\n        P[96] = vec2( 0.95088,0.023448);\n        P[97] = vec2( 0.94386,0.0068966);\n        P[98] = vec2( 0.9614,-0.023448);\n        P[99] = vec2( 0.95088,-0.062069);\n        P[100] = vec2( 0.95439,-0.095172);\n        P[101] = vec2( 0.9614,-0.12276);\n        P[102] = vec2( 0.96491,-0.15034);\n        P[103] = vec2( 0.95439,-0.16138);\n        P[104] = vec2( 0.94737,-0.17241);\n        P[105] = vec2( 0.94386,-0.19448);\n        P[106] = vec2( 0.92982,-0.22207);\n        P[107] = vec2( 0.92982,-0.24966);\n        P[108] = vec2( 0.93684,-0.27724);\n        P[109] = vec2( 0.94737,-0.30207);\n        P[110] = vec2( 0.95439,-0.33241);\n        P[111] = vec2( 0.95789,-0.34345);\n        P[112] = vec2( 0.95439,-0.36276);\n        P[113] = vec2( 0.9614,-0.38483);\n        P[114] = vec2( 0.95789,-0.40414);\n        P[115] = vec2( 0.94035,-0.42621);\n        P[116] = vec2( 0.92281,-0.45103);\n        P[117] = vec2( 0.95789,-0.47034);\n        P[118] = vec2( 0.97544,-0.47586);\n        P[119] = vec2( 0.98246,-0.50345);\n        P[120] = vec2( 0.98246,-0.52828);\n        P[121] = vec2( 0.95789,-0.54207);\n        P[122] = vec2( 0.94035,-0.55034);\n        P[123] = vec2( 0.89825,-0.59172);\n        P[124] = vec2( 0.88772,-0.64138);\n        P[125] = vec2( 0.90526,-0.64138);\n        P[126] = vec2( 0.90526,-0.68000);\n        P[127] = vec2( 0.89825,-0.68552);\n        P[128] = vec2( 0.95789,-0.78759);\n        P[129] = vec2( 0.99649,-0.99724);\n        \nvec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n    vec2 m = 1.0 - 2.0* iMouse.xy/iResolution.xy;\n\n     float x = p.x * iResolution.y/iResolution.x;\n     float y = p.y ;\n     \n     float mx = m.y * iResolution.y/iResolution.x;\n     float my = -m.x ;\n           \n            x/=mx;\n            y/=my;\n            \n            p.x=x;\n            p.y=y;\n   \n\n    float z = 1.0e25; //infinity?\n    for (int i = 0; i < 126; i++) {\n        float triangle = T(p, P[i],P[i+1], P[i+3]);\n        z = min(z, triangle);\n    }\n    float f = 40.0 / z;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    if(f > 0.0)\n    {\n        col.g = 1.0;\n    }\n    else {\n        col.r = f;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXXzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 88], [111, 111, 145, 145, 399], [409, 409, 452, 452, 604], [606, 606, 663, 689, 6834]], "test": "untested"}
{"id": "stfSRn", "name": "Smesharik lavoshnikova", "author": "Mary_Lav", "description": "nyusha", "tags": ["n"], "likes": 0, "viewed": 185, "published": 3, "date": "1625056133", "time_retrieved": "2024-07-30T19:13:09.107433", "image_code": "    float Circle(vec2 uv, vec2 position, float r, float blur) \n    {\n        float d = length(uv - position);\n        float c = smoothstep(r, r-blur, d);\n        return c;\n    }\n    \n    \n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.xy; // координаты от 0 до 1  \n    \n    \n    uv -= .5;  // центр круга теперь в центре экрана; координаты от -0.5 до 0.5\n    uv.x *= (iResolution.x / iResolution.y); \n    // голова\n    float c = Circle(uv, vec2(.0, .10), .3, .005);\n    //пятачок\n    c -= Circle(uv, vec2(.0, .1), .07, .005);\n    //ноги\n    c += Circle(uv, vec2(.1, -.2), .07, .005);\n    c += Circle(uv, vec2(-.1, -.2), .07, .005);\n    //руки\n    c += Circle(uv, vec2(.3, .03), .07, .005);\n    c += Circle(uv, vec2(-.3, .03), .07, .005);\n    //уши\n    c += Circle(uv, vec2(.1, .4), .05, .005);\n    c += Circle(uv, vec2(-.1, .4), .05, .005);\n   \n    // глаза\n    uv.y *= (iResolution.y / iResolution.x);\n    c -= Circle(uv, vec2(.1, .1), .06, .005);    \n    c -= Circle(uv, vec2(-.1, .1), .06, .005);       \n    c += Circle(uv, vec2(.1, .1), .055, .005);       \n    c += Circle(uv, vec2(-.1, .1), .055, .005); \n    c -= Circle(uv, vec2(.1, .1), .02, .005);    \n    c -= Circle(uv, vec2(-.1, .1), .02, .005); \n    \n    uv.y *= (iResolution.x / iResolution.y);\n    c -= Circle(uv, vec2(.0, .0), .02, .005);\n    //пятачок\n    uv.y *= (iResolution.y / iResolution.x);\n    c += Circle(uv, vec2(.03, .06), .01, .005);       \n    c += Circle(uv, vec2(-.03, .06), .01, .005);\n   \n    \n   \n      \n      fragColor = vec4(vec3(c), 1.0);\n    \n                \n              \n     // fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfSRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 68, 68, 177], [194, 194, 251, 251, 1749]], "test": "untested"}
{"id": "NtfXRr", "name": "correlated AA blend", "author": "FabriceNeyret2", "description": "Representing subpixel coverage as transparency for antialiasing assumes there is no correlation with background. Problem: repainting the same shape is 100% correlated: try click different locations.\nLeft: naive AA. Right: smart AA.\nTop: textured Bot: mask", "tags": ["antialiasing", "blending", "correlation"], "likes": 7, "viewed": 347, "published": 3, "date": "1625051359", "time_retrieved": "2024-07-30T19:13:10.167598", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if ( int(U.x)==int(R.x/2.) || int(U.y)==int(R.y/2.) ) { O=vec4(0,1,0,1); return; }\n    \n    U = zoom(U);\n    \n    O = sqrt( T(U) ); // to sRGB\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// texture to splat\n//#define T1(U) vec4(cos(vec3(atan((U).y-M.y, (U).x-M.x)) - vec3(0., 2., 4.)) * .5 + .5, 1)\n  #define T1(U) texture( iChannel1, .5 + .5*(M-U)/R )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n // O = iFrame > 1 ? T(U) : texture(iChannel1,U/R).grba;\n    \n    vec2  M = iMouse.xy;\n    if (length(M)<10.) M = R/2. + R/4.*cos(floor(iTime*2.)+vec2(0,11)); // auto-demo if no mouse click\n    M = zoom(M);\n    float d = smoothstep(1.5,0., length(M-U)-.03*R.y ); // disc mask\n    \n    vec4 C = U.y < R.y/2. \n       ? vec4(1)                                        // bottom: draw disc mask\n       : T1(U);                                         // top: draw textured disc\n    \n    if ( U.x < R.x/2. ) \n       O = mix(O, C, d );                               // left: naive AA blend\n    else                                                // right: smart AA blend \n       O = mix( clamp( ( O - d*C ) / (1.-d)  , 0.,1.) , C, d );\n             // trick: left = restore the background color before previous blend\n             // note that we shoud test d != 1, but clamp(Inf) = 1 \n             // also, funnily it still work when there was no prvious shape\n    // C *= d, O = clamp( O, C, C + 1.-d );   // simplifies to this (thanks iq ! )\n\n    // O = vec4( mix( clamp( ( O - O.a*C ) / (1.-O.a)  , 0.,1.) , C, d ).rgb, d); // WIP variant\n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R         iResolution.xy\n#define T(U)      texelFetch( iChannel0, ivec2(U), 0 )\n#define zoom(U) ( ( U - R/2. ) /3. + R/2. )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 187]], "test": "untested"}
{"id": "NlXXRr", "name": "cheburashka lavoshnikova", "author": "Mary_Lav", "description": "n", "tags": ["m"], "likes": 0, "viewed": 176, "published": 3, "date": "1625049724", "time_retrieved": "2024-07-30T19:13:10.962473", "image_code": "    float Circle(vec2 uv, vec2 position, float r, float blur) \n    {\n        float d = length(uv - position);\n        float c = smoothstep(r, r-blur, d);\n        return c;\n    }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\n    vec2 uv = fragCoord/iResolution.xy; // координаты от 0 до 1  \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,1,2));\n    \n    uv -= .5;  // центр круга теперь в центре экрана; координаты от -0.5 до 0.5\n    uv.x *= (iResolution.x / iResolution.y); \n    // голова\n    float c = Circle(uv, vec2(.0, .24), .20, .005);\n    // глаза\n    c -= Circle(uv, vec2(.1, .3), .06, .01);    \n    c -= Circle(uv, vec2(-.1, .3), .06, .01);       \n    c += Circle(uv, vec2(.1, .3), .040, .005);       \n    c += Circle(uv, vec2(-.1, .3), .040, .005); \n    c -= Circle(uv, vec2(.1, .3), .01, .005);    \n    c -= Circle(uv, vec2(-.1, .3), .01, .005); \n    \n    // уши \n    c += Circle(uv, vec2(.4, .27), .22, .005);\n    c += Circle(uv, vec2(-.4, .27), .22, .005);\n    // тело\n    c += Circle(uv, vec2(.0, -.10), .16, .005);\n    //руки\n    c += Circle(uv, vec2(.2, -.10), .06, .005);\n    c += Circle(uv, vec2(-.2, -.10), .06, .005);\n    //ноги\n    c += Circle(uv, vec2(.10, -.3), .07, .005);\n    c += Circle(uv, vec2(-.10, -.3), .07, .005);    \n    \n    fragColor = vec4(vec3(c), 1.0);\n    \n    //fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXXRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 68, 68, 177], [179, 179, 235, 235, 1427]], "test": "untested"}
{"id": "NtfXzn", "name": "Ten Intersecting Tetrahedra", "author": "dr2", "description": "Chiral stellation of the icosahedron - 'Compound of Five Tetrahedra' - used twice", "tags": ["tetrahedron", "symmetry", "polyhedron", "stellation"], "likes": 11, "viewed": 355, "published": 3, "date": "1625045508", "time_retrieved": "2024-07-30T19:13:11.720447", "image_code": "// \"Ten Intersecting Tetrahedra\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrTetDf (vec3 p, float d);\nfloat PrDodecDf (vec3 p, float r);\nfloat Maxv2 (vec2 p);\nmat3 VToRMat (vec3 v, float a);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir[4], ltCol[4];\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat TetFrameDf (vec3 p, float w)\n{\n  vec3 q;\n  q = p;\n  p = abs (p);\n  q = mix (q, q.yzx, step (Maxv2 (p.yz), p.x));\n  q = mix (q, q.zxy, step (Maxv2 (p.zx), p.y));\n  q = mix (q, vec3 (q.x, - q.yz).yxz, step (q.z, 0.)) - vec3 (-1., 1., 1.) / sqrt (3.);\n  return PrBox2Df (vec2 (0.5 * (q.x + q.y), q.z), vec2 (w));\n}\n\nfloat ObjDf (vec3 p)\n{\n  mat3 m;\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  m = VToRMat (vec3 (0., sin (atan (2. / (sqrt (5.) + 1.)) + vec2 (0.5 * pi, 0.))), 2. * pi / 5.);\n  // rotation matrix from \"Ico-Twirl\", where atan (1. / phi) = 0.55357435\n  q = p;\n  for (int k = 0; k < 5; k ++) {\n    d = TetFrameDf (q, 0.03);\n    DMIN (1);\n    d = PrTetDf (q, 0.27);\n    DMIN (2);\n    q = m * q;\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  return PrDodecDf (p, 0.74);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat SphHit (vec3 ro, vec3 rd, float rad)\n{\n  float b, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  return (w > 0.) ? - b - sqrt (w) : dstFar;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 sumD, sumS, col, colB, vn, roo;\n  float dstObj, dstTrObj, nDotL, sh, s;\n  roo = ro;\n  s = SphHit (ro, rd, 1.2);\n  dstObj = (s < dstFar) ? ObjRay (ro, rd) : dstFar;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vn = VaryNf (128. * ro, vn, 0.2);\n    if (idObj == 1) col4 = vec4 (0.9, 0.9, 0.9, 0.5);\n    else if (idObj == 2) col4 = vec4 (1., 1., 1., 0.2);\n    sumD = vec3 (0.);\n    sumS = vec3 (0.);\n    for (int k = VAR_ZERO; k < 4; k ++) {\n      nDotL = max (dot (vn, ltDir[k]), 0.);\n      sh = ObjSShadow (ro, ltDir[k]);\n      sumD += ltCol[k] * col4.rgb * sh * nDotL * nDotL *\n         smoothstep (0.95, 0.98, dot (normalize (3. * ltDir[k] - ro), ltDir[k]));\n      sumS += ltCol[k] * col4.a * step (0.95, sh) * pow (max (0., dot (ltDir[k],\n         reflect (rd, vn))), 32.);\n    }\n    col = 0.05 * col4.rgb + 0.95 * sumD + sumS;\n  } else {\n    col = vec3 (0.1);\n  }\n  ro = roo;\n  dstTrObj = (s < dstFar) ? TrObjRay (ro, rd) : dstFar;\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    colB = vec3 (0.);\n    for (int k = VAR_ZERO; k < 4; k ++) {\n      nDotL = max (dot (vn, ltDir[k]), 0.);\n      colB += ltCol[k] * nDotL * nDotL *\n         smoothstep (0.9, 0.95, dot (normalize (3. * ltDir[k] - ro), ltDir[k]));\n    }\n    colB = vec3 (0.05) + 0.95 * colB;\n    col = mix (col, colB, 0.05 + 0.95 * pow (1. - max (- dot (rd, vn), 0.), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, e;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.3 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -7.);\n  zmFac = 6.;\n  dstFar = 30.;\n  e = vec2 (1., -1.);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltDir[k] = normalize ((k < 2) ? ((k == 0) ? e.xxx : e.xyy) : ((k == 2) ? e.yxy : e.yyx));\n    ltDir[k].xy = Rot2D (ltDir[k].xy, 0.13 * pi * tCur);\n    ltDir[k].xz = Rot2D (ltDir[k].xz, 0.17 * pi * tCur);\n  }\n  ltCol[0] = vec3 (1., 0.2, 0.2);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (Maxv2 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrTetDf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (1., -1.) / sqrt (3.);\n  return max (max (dot (p, e.yxx), dot (p, e.xyx)), max (dot (p, e.xxy), dot (p, e.yyy))) - d;\n}\n\nfloat PrDodecDf (vec3 p, float d)\n{\n  vec3 e;\n  float s;\n  e = vec3 ((sqrt (5.) + 1.) / 2., 1., 0.) / sqrt (5.);\n  s = 0.;\n  for (int k = 0; k < 4; k ++) {\n    s = max (s, max (dot (p, e), max (dot (p, e.yzx), dot (p, e.zxy))));\n    e.x = - e.x;\n    if (k == 1) e.y = - e.y;\n  }\n  return s - d;\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2, bp, bm;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.xzy * v.yxz;\n  b2 = - cs.y * v.zyx;\n  bp = b1 + b2;\n  bm = b1 - b2;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[0][1] = bp.x;  m[1][0] = bm.x;\n  m[2][0] = bp.y;  m[0][2] = bm.y;\n  m[1][2] = bp.z;  m[2][1] = bm.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfXzn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[589, 589, 625, 625, 906], [908, 908, 930, 930, 1320], [1322, 1322, 1355, 1355, 1538], [1540, 1540, 1561, 1561, 1816], [1818, 1818, 1842, 1842, 1874], [1876, 1876, 1911, 1911, 2095], [2097, 2097, 2120, 2120, 2377], [2379, 2379, 2416, 2416, 2645], [2647, 2647, 2691, 2691, 2812], [2814, 2814, 2849, 2849, 4313], [4315, 4315, 4371, 4371, 5662], [5664, 5664, 5686, 5686, 5713], [5715, 5715, 5748, 5748, 5832], [5834, 5834, 5867, 5867, 6008], [6010, 6010, 6045, 6045, 6306], [6308, 6308, 6340, 6340, 6718], [6720, 6720, 6756, 6756, 6962], [6964, 6964, 6994, 6994, 7107], [7141, 7141, 7165, 7165, 7277], [7279, 7279, 7304, 7304, 7490], [7492, 7492, 7521, 7521, 7733], [7735, 7735, 7774, 7774, 8026]], "test": "untested"}
{"id": "slj3Dd", "name": "Arrow - distance", "author": "iq", "description": "Distance to an arrow (exact interior and exterior Euclidean distances)", "tags": ["2d", "distancefield", "sdf", "arrow"], "likes": 18, "viewed": 1101, "published": 3, "date": "1625029726", "time_retrieved": "2024-07-30T19:13:12.671903", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an arrow\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    // constant setup\n    const float k = 3.0;   // arrow head ratio\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    // pixel setup\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    // === distance (four segments) === \n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n    //----\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n    //----\n    if( p.x<w1 ) // conditional is optional\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n    //----\n    if( pz.x>0.0 ) // conditional is optional\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    // === sign === \n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 ) //if( p.x>0.0 && z>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float time = iTime*0.25;\n    vec2 a = vec2(-1.2,0.0)+vec2(0.4,0.6)*cos(time*vec2(1.1,1.3)+vec2(0.0,1.0));\n    vec2 b = vec2( 1.2,0.0)+vec2(0.4,0.6)*cos(time*vec2(1.2,1.5)+vec2(0.3,2.0));\n    float w1 = 0.1*(1.0+0.5*cos(time*3.1+2.0));\n    float w2 = w1 + 0.15;\n    float th = 0.05 + 0.05*sin(time*7.0);\n    \n    \n    // distance\n    float d = sdArrow(p, a, b, w1, w2) - th;\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-5.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdArrow(m, a, b, w1, w2) - th;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slj3Dd.jpg", "access": "api", "license": "mit", "functions": [[1233, 1323, 1387, 1409, 2425], [2427, 2427, 2484, 2520, 3540]], "test": "untested"}
{"id": "7lj3Dd", "name": "Random Circle Packing", "author": "oneshade", "description": "Randomly packing circles. What I was actually trying to make when I accidentally created the cool coral pattern ([url=https://www.shadertoy.com/view/sl2GDd]https://www.shadertoy.com/view/sl2GDd[/url]).", "tags": ["raymarching", "circles", "random", "iterative", "circlepacking"], "likes": 20, "viewed": 519, "published": 3, "date": "1625026594", "time_retrieved": "2024-07-30T19:13:13.559530", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float unit = 2.0 / iResolution.y;\n    vec4 buf = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 color = hue2rgb(buf.w) * (0.25 + 0.5 * fract(484.841 * cos(953.583 * buf.w)));\n    fragColor = vec4(color * smoothstep(unit, 0.0, buf.x), 1.0);\n    if (buf.x < 0.0) fragColor += 0.125 + 0.125 * sin(buf.x * 400.0);\n    //fragColor = vec4(0.5 + 0.5 * buf.yz, 0.0, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define load(addr) texelFetch(iChannel0, addr, 0)\n#define pixel2uv(pixel) ((pixel - 0.5 * iResolution.xy) / iResolution.y)\n#define uv2pixel(uv) (uv * iResolution.y + 0.5 * iResolution.xy)\n#define packCircle(packed, new, id) (new.x < packed.x ? vec4(new, id) : packed)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n    vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3(signed distance, gradient)\n// Buffering the distance field already lowers\n// precision so buffering an exact gradient is\n// helpful\nvec3 sdgDisk(in vec2 p, in float r) {\n    float d = length(p);\n    return vec3(d - r, p / d);\n}\n\nvoid mainImage(out vec4 data, in vec2 addr) {\n    vec2 bound = vec2(0.5 * iResolution.x / iResolution.y, 0.5);\n    vec2 uv = pixel2uv(addr);\n    data = vec4(0.0);\n\n    if (iFrame > 0) {\n        ivec2 iAddr = ivec2(addr);\n        float seed = iDate.w;\n        data = load(iAddr);\n\n        // \"Random\" starting position\n        vec2 start = pixel2uv(iResolution.xy * Hash12(seed));\n\n        // Iteratively project onto the distance field's surface\n        for (int i=0; i < 10; i++) {\n            vec3 sdg = load(ivec2(uv2pixel(start))).xyz;\n            sdg.x -= 0.01; // Slightly extra to be outside\n            start -= sdg.yz * sdg.x;\n            if (abs(sdg.x) < 0.001) break;\n        }\n\n        // Raymarch to the next surface\n        vec2 dir = load(ivec2(uv2pixel(start))).yz;\n        float t = 0.0;\n\n        // Maximum distance the ray can travel (to the edge of the screen)\n        vec2 isect = (bound * sign(dir) - start) / dir;\n        float tMax = min(isect.x, isect.y);\n\n        bool hit = false;\n        for (int i=0; i < 100; i++) {\n            vec2 p = start + dir * t;\n            float d = load(ivec2(uv2pixel(p))).x;\n            if (d < 0.001) { hit = true; break; }\n            if (t > tMax) break;\n            t += d;\n        }\n\n        if (hit) {\n            vec2 center = start + dir * min(0.5 * t, tMax);\n            float radius = load(ivec2(uv2pixel(center))).x;\n            if (radius > 0.0) data = packCircle(data, sdgDisk(uv - center, radius), sin(seed));\n        }\n    }\n\n    if (iFrame == 0 || iMouse.z > 0.0) { // Initialize with distance to boundaries\n        vec2 b = abs(uv) - bound;\n        if (b.x > b.y) data.xy = vec2(-b.x, -sign(uv.x));\n        else data.xz = vec2(-b.y, -sign(uv.y));\n        data.w = 0.0;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 194, 194, 574]], "test": "untested"}
{"id": "sl2GDd", "name": "Expanding Coral Growth", "author": "oneshade", "description": "Cool coral-like growth pattern I accidentally made while working on something completely different. Thought I'd share it.", "tags": ["coral", "growth", "happyaccident"], "likes": 21, "viewed": 435, "published": 3, "date": "1625024322", "time_retrieved": "2024-07-30T19:13:14.407263", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float unit = 2.0 / iResolution.y;\n    vec4 buf = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(buf.x > unit ? vec3(0.0) : hue2rgb(buf.w) * smoothstep(unit, 0.0, buf.x), 1.0);\n    fragColor += 0.125 + 0.125 * sin(buf.x * 400.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define load(addr) texelFetch(iChannel0, addr, 0)\n#define pixel2uv(pixel) ((pixel - 0.5 * iResolution.xy) / iResolution.y)\n#define uv2pixel(uv) (uv * iResolution.y + 0.5 * iResolution.xy)\n#define minSDG(a, b) (a.x < b.x ? a : b)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n    vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3(signed distance, gradient)\n// Buffering the distance field already lowers\n// precision so buffering an exact gradient is\n// helpful\nvec3 sdgDisk(in vec2 p, in float r) {\n    float d = length(p);\n    float sd = d - r;\n    return vec3(sd, p / d * sign(sd));\n}\n\nvoid mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(-1.0);\n    vec2 uv = pixel2uv(addr);\n    if (iFrame == 0) {\n        data.xyz = sdgDisk(uv, 0.15);\n        data.w = 0.0;\n    }\n\n    if (iFrame > 0) {\n        ivec2 iAddr = ivec2(addr);\n        float seed = iDate.w;\n        data = load(iAddr);\n\n        // \"Random\" starting position\n        vec2 start = pixel2uv(iResolution.xy * Hash12(seed));\n\n        // Project onto the SDFs surface (approximate, actual version will use iterrative)\n        vec3 sdg = load(ivec2(uv2pixel(start))).xyz;\n        sdg.x -= 0.01; // Slightly extra to be outside\n        start -= sdg.yz * sdg.x;\n\n        data.xyz = minSDG(data.xyz, sdgDisk(uv - start, 0.01));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2GDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 194, 194, 451]], "test": "untested"}
{"id": "st23Wt", "name": "Mipmap Diffusion II", "author": "oneshade", "description": "Drag the box around with the mouse to modify the potential field.", "tags": ["mipmap", "diffusion", "gpmipmap", "wos"], "likes": 13, "viewed": 223, "published": 3, "date": "1625014776", "time_retrieved": "2024-07-30T19:13:15.359716", "image_code": "// https://blog.demofox.org/2020/07/11/interpolating-data-over-arbitrary-shapes-with-laplaces-equation-and-walk-on-spheres/\n// Perhaps mipmaps could be used to accelerate it?\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    float w = length(fragColor.rgb);\n    fragColor = fragColor / w * floor(w * 10.0) * 0.1;\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(fwidth(w), 0.0, abs(mod(w + 0.05, 0.1) - 0.05)));\n\n    fragColor.rgb = sqrt(fragColor.rgb); // Approximate gamma correction\n                                         // Actually looks better for once! :)\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// SDFs\nfloat sdCircle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    float abc = ba.x * cb.y - ba.y * cb.x;\n    float abp = ba.x * pa.y - ba.y * pa.x;\n    float bcp = cb.x * pb.y - cb.y * pb.x;\n    float cap = ac.x * pc.y - ac.y * pc.x;\n\n    vec2 ae = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 be = pb - cb * clamp(dot(pb, cb) / dot(cb, cb), 0.0, 1.0);\n    vec2 ce = pc - ac * clamp(dot(pc, ac) / dot(ac, ac), 0.0, 1.0);\n\n    float tri = sqrt(min(dot(ae, ae), min(dot(be, be), dot(ce, ce))));\n    bvec3 n = lessThan(vec3(abp, bcp, cap), vec3(0.0));\n    return all(n) || all(not(n)) ? -tri : tri;\n}\n\n#define color fragColor.rgb\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy, 3.0);\n    if (iFrame == 0) fragColor = vec4(1.0);\n\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n\n    float box = sdBox(uv - (iMouse.z > 0.0 ? mouse : vec2(cos(iTime), cos(iTime) * sin(iTime) + 0.75)), vec2(0.4));\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, box));\n\n    float circle = sdCircle(uv - vec2(-1.25, -0.75), 0.4);\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, circle));\n\n    float triangle = sdTriangle(uv - vec2(1.25, -0.75), vec2(-0.5, -0.333), vec2(0.5, -0.333), vec2(0.0, 0.666));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, triangle));\n\n    uv.x = abs(uv.x) - 2.5;\n    float walls = sdBox(uv, vec2(0.1, 1.5));\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, walls));\n\n    uv.x -= 0.6;\n    uv.y = mod(uv.y + 0.5, 1.0) - 0.5;\n    float dots = sdCircle(uv, 0.1);\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, dots));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 175, 230, 230, 653]], "test": "untested"}
{"id": "NtX3D7", "name": "GaussionBlur", "author": "kunnisser", "description": "实现高斯模糊", "tags": ["gaussion"], "likes": 0, "viewed": 247, "published": 3, "date": "1625013879", "time_retrieved": "2024-07-30T19:13:16.348074", "image_code": "// 高斯模糊半径\nfloat RADIUS = 1.0;\n// 因为uv的坐标系为0-1，这里为了代入高斯模糊半径计算，需要缩放到对应的量级\nfloat size = 30000.0;\nfloat PI = 3.14159;\n\n// PDF\nfloat gaussianBlur (float sigma, float x, float y) {\n    return (exp(-pow(x, 2.0) - pow(y, 2.0)) / 2.0 * pow(sigma, 2.0)) / (2.0 * pow(sigma, 2.0) * PI); \n}\n\n// 权重乘以当前获取的像素值\nvec4 computedBlur (float gauss, vec4 inputColor) {\n        return (inputColor * gauss);\n}\n\n// 高斯卷积核计算\nvec4 blurColor (vec2 uv) {\n    // 初始色值\n    vec4 color = vec4(0.0);\n    //\n    float sum = 0.0;\n    \n    // 进行二维矩阵遍历\n    for (float x = -RADIUS; x <= RADIUS; x++) {\n        for (float y = -RADIUS; y <= RADIUS; y++) {\n            // 计算对应的纹理坐标\n            vec2 target = uv + vec2(x / size, y / size);\n            // 计算出高斯权重\n            float gauss = gaussianBlur(1.5, target.x, target.y);\n            // 获取加权后的色值并累加\n            color += computedBlur(gauss, vec4(vec3(texture(iChannel0, target).x), 1.0));\n            // 计算加权概率之和\n            sum += gauss;\n        }\n    }\n    // 这里放在循环外统一进行概率归一化处理，提高计算效率\n    color /= sum;\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = blurColor(uv);\n\n    fragColor = color;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 200, 252, 252, 356], [358, 398, 448, 448, 487], [489, 514, 540, 560, 1296], [1297, 1297, 1354, 1354, 1457]], "test": "untested"}
{"id": "slB3Dc", "name": "Floating Playstation Shapes", "author": "will7007", "description": "A hello-world-tier first shader which mimics PPSSPP's default background animation. I just eyeballed the PPSSPP default background to make this, so the shape proportions and sway duration likely aren't accurate, but you can modify them using the #defines.", "tags": ["blue", "shapes", "playstation", "sony", "ppsspp"], "likes": 8, "viewed": 445, "published": 3, "date": "1625010789", "time_retrieved": "2024-07-30T19:13:17.272602", "image_code": "// Common parameters:\n#define SHAPE_SIZE 0.06\n#define BLUR 0.001\n#define VERTICAL_TRAVEL 0.1\n#define SPEED_TRAVEL 0.6\n#define SPEED_ROTATION 1.\n#define ALPHA .7\n\n// Colors\n#define DARK_BLUE vec3(16./255.,50./255.,66./255.)\n#define LIGHT_BLUE vec3(34./255.,76./255.,114./255.)\n#define SHAPE_GRAY vec3(93./255.,119./255.,137./255.)\n\n// Only applies to the circle and square\n#define INNER_CUTOUT_SCALE 0.7\n\n// The taper-off point for the triangle to be equilateral\nconst float EQUILATERAL_HEIGHT =\n        sqrt(pow(SHAPE_SIZE,2.) - pow(SHAPE_SIZE/2.,2.))\n        - SHAPE_SIZE/2.;\n\n// NEW on Jul-24-2021: grid based rendering to improve performance\n// the old way is pretty terrible in hindsight\n#define NEW_RENDERER 1\n\n// Old renderer parameter:\n// set to an ammount similar to density 12 on the new renderer\n// so you can see the performance improvement\n// (at least I can see the difference on my 6 year old Macbook Air)\n#define SHAPE_AMOUNT 300.\n\n// New renderer parameters:\n#define DENSITY 12.\n// see the note in the main function\n#define PRESERVE_VERTICAL_TRAVEL 1\n\n// Helper functions grabbed from the internet\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233)))\n        *43758.5453);\n}\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\n\n// https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map(float value, float min1, float max1,\n        float min2, float max2) {\n    return min2 + (value - min1)*(max2 -min2)\n        /(max1 - min1);\n}\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle),-sin(angle),\n        sin(angle),cos(angle));\n}\n\n// Background gradient\nvec3 background(vec2 uv) {\n    const float GRAD_START = 0.25, GRAD_STOP = 0.95;\n    return mix(LIGHT_BLUE,DARK_BLUE,\n        smoothstep(GRAD_START,GRAD_STOP,uv.y));\n}\n\n// Solid helper shapes\nfloat box(vec2 uv, float left, float right,\n        float down, float up, float blur) {\n    return smoothstep(left,left+blur,uv.x)\n        *smoothstep(right,right-blur,uv.x)\n        *smoothstep(down,down+blur,uv.y)\n        *smoothstep(up,up-blur,uv.y);\n}\n\nfloat box(vec2 uv, float lowerBound, float upperBound,\n        float blur) {\n    return box(uv,lowerBound,upperBound,\n               lowerBound,upperBound,blur);\n}\n\nfloat triangleSolid(vec2 uv, float size, float height,\n        float blur) {\n    float sides = map(uv.y,-size/2.,height,size/2.,0.);\n    return box(uv,-sides,sides,-size/2.,size/2.,blur);    \n}\n\n// Main shapes\nfloat circle(vec2 uv, float size, float blur, float alpha) {\n    float radius = size/2.;\n    return alpha*(smoothstep(radius+blur,radius,length(uv))\n        - smoothstep(INNER_CUTOUT_SCALE*radius+blur,\n                     INNER_CUTOUT_SCALE*radius,\n                     length(uv)));\n}\n\nfloat X(vec2 uv, float size, float blur, float alpha) {\n    float lower = -size/2., upper = size/2.;\n    return alpha*(box(uv,lower,upper,lower/5.,upper/5.,blur)\n        + box(uv,lower/5.,upper/5.,lower,upper,blur)\n        - box(uv,lower/5.,upper/5.,blur));\n}\n\nfloat triangle(vec2 uv, float size, float height,\n        float blur, float alpha) {\n    vec2 innerCoord = uv*2.;\n    const float BASE_SIZE = 0.05, SCALING_FACTOR = 0.01;\n    innerCoord.y += SHAPE_SIZE/BASE_SIZE*SCALING_FACTOR;\n    return alpha*(triangleSolid(uv,size,height,blur)\n        - triangleSolid(innerCoord,size,height,blur));\n}\n\nfloat square(vec2 uv, float size, float blur, float alpha) {\n    return alpha*(box(uv,-size/2.,size/2.,blur)\n        - box(uv,-INNER_CUTOUT_SCALE*size/2.,\n              INNER_CUTOUT_SCALE*size/2.,blur));\n}\n\nvec2 sway(vec2 uv, vec2 start, float vertTravel,\n        float timeShift) {\n    return vec2(uv.x-start.x,uv.y-start.y\n                - vertTravel*sin(SPEED_TRAVEL\n                                 *iTime-timeShift));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float ASPECT_RATIO = iResolution.x/iResolution.y;\n    uv.x *= ASPECT_RATIO;\n\n    vec3 col = background(uv);\n    \n    #if NEW_RENDERER\n    uv *= DENSITY;\n    vec2 xy = fract(uv)-.5,  // point within a grid cell\n         id = floor(uv),     // the grid cell we are in\n         cid = vec2(0.);     // the id adjusted for the actual location of the cell\n    \n    /*\n    Here we see which shapes are in this cell and the surrounding\n    cells (the shapes nearby) and draw their value for this pixel.\n    Unfortunately we cannot increase the shape density\n    while maintaining the vertical travel of the shapes\n    without having shapes from far-away grid cells \"come into\"\n    our grid cell and not being being drawn since we only check\n    nearby cells for shapes.\n    This introduces clipping on the shapes which can only be fixed by\n    increasing the number of neighboring grid cells checked\n    per iteration, which unfortunately hurts performance.\n    We already need slightly more vertical grid cells with the\n    default settings because the shapes were already traveling\n    too far.\n    */\n    #if PRESERVE_VERTICAL_TRAVEL\n    // I did a quick check at density ~30 with default size\n    // with these start/end values but they aren't perfect\n    const vec2 startValue = vec2(-1.-DENSITY/30.,-2.-DENSITY/14.),\n               endValue = vec2(1.+DENSITY/60.,1.+DENSITY/10.);\n    #else\n    const vec2 startValue = vec2(-1.,-2.),\n               endValue = vec2(1.);\n    #endif\n    for(float yCell=startValue.y; yCell <= endValue.y; yCell++) {\n        for(float xCell=startValue.x; xCell <= endValue.x; xCell++) {\n            vec2 off = vec2(xCell,yCell);\n            cid = id+off;\n            vec2 origin = off+N22(cid);\n            \n            // big/random multipliers to spread out shape types\n            float shapeID = 400.*rand(cid)+2.526*cid.y;\n            \n            origin = sway(origin,vec2(0.),\n                          #if PRESERVE_VERTICAL_TRAVEL \n                          DENSITY*\n                          #endif\n                          VERTICAL_TRAVEL,shapeID);\n            \n\n            // rotate and scale the coordinate system for the shape\n            // which we previously moved vertically based on time\n            vec2 pointRotated = 1./DENSITY*(origin-xy)*rotate(sin(SPEED_ROTATION*iTime-shapeID));\n            switch(int(mod(shapeID,4.))) {\n            case 0:\n            default:\n                col = mix(col,SHAPE_GRAY,\n                          X(pointRotated,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            case 1:\n                col = mix(col,SHAPE_GRAY,\n                          circle(pointRotated,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            case 2:\n                col = mix(col,SHAPE_GRAY,\n                          triangle(pointRotated,SHAPE_SIZE,\n                                   EQUILATERAL_HEIGHT,\n                                   BLUR,ALPHA));\n                break;\n            case 3:\n                col = mix(col,SHAPE_GRAY,\n                          square(pointRotated,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            }\n        }\n    }\n    #else\n    for(float i = 0.; i < SHAPE_AMOUNT; i++) {\n        vec2 seed = vec2(i,i);\n        vec2 cord = vec2(rand(seed),rand(-.5*seed));\n        cord.x *= ASPECT_RATIO;\n        vec2 xy = sway(uv,cord,VERTICAL_TRAVEL,i);\n        switch(int(mod(i,4.))) {\n            case 0:\n                xy *= rotate(sin(SPEED_ROTATION*iTime-i));\n                col = mix(col,SHAPE_GRAY,\n                          X(xy,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            case 1:\n                col = mix(col,SHAPE_GRAY,\n                          circle(xy,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n            case 2:\n                xy *= rotate(sin(SPEED_ROTATION*iTime-i));\n                col = mix(col,SHAPE_GRAY,\n                          triangle(xy,SHAPE_SIZE,\n                                   EQUILATERAL_HEIGHT,\n                                   BLUR,ALPHA));\n                break;\n            case 3:\n            default:\n                xy *= rotate(sin(SPEED_ROTATION*iTime-i));\n                col = mix(col,SHAPE_GRAY,\n                          square(xy,SHAPE_SIZE,BLUR,ALPHA));\n                break;\n        }\n    }\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slB3Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1068, 1114, 1135, 1135, 1214], [1216, 1216, 1234, 1234, 1357], [1359, 1428, 1508, 1508, 1580], [1582, 1582, 1608, 1608, 1682], [1684, 1707, 1733, 1733, 1873], [1875, 1898, 1985, 1985, 2152], [2154, 2154, 2230, 2230, 2317], [2319, 2319, 2395, 2395, 2512], [2514, 2529, 2589, 2589, 2815], [2817, 2817, 2872, 2872, 3076], [3078, 3078, 3162, 3162, 3415], [3417, 3417, 3477, 3477, 3622], [3624, 3624, 3699, 3699, 3842]], "test": "untested"}
{"id": "7tj3Dt", "name": "Mipmap Gaussian Blur Approx.", "author": "oneshade", "description": "Approximating a gaussian blur by cascading box blurs with mipmap.", "tags": ["blur", "approximation", "mipmap", "gaussian", "limit"], "likes": 6, "viewed": 385, "published": 3, "date": "1625001725", "time_retrieved": "2024-07-30T19:13:18.060495", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy, BLUR_LEVEL);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy, BLUR_LEVEL);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BLUR_LEVEL (4.0 - 4.0 * cos(0.5 * iTime))", "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy, BLUR_LEVEL);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy, BLUR_LEVEL);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy, BLUR_LEVEL);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 133]], "test": "untested"}
{"id": "7tS3Dd", "name": "Shesharik", "author": "MaksymYakushev", "description": "smesharik\n", "tags": ["smesharik"], "likes": 2, "viewed": 212, "published": 3, "date": "1624996987", "time_retrieved": "2024-07-30T19:13:19.160554", "image_code": "float Circle(vec2 uv, vec2 p, float r)\n{\n    float d = length(uv - p);\n     float c = smoothstep(r, r - 0.001, d);\n      return c;\n} \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n     uv.x *= iResolution.x / iResolution.y;\n    \n      float body = Circle(uv, vec2(0.0, 0.18), 0.2);\n       body -= Circle(uv, vec2(0.055, 0.22), 0.03);\n       body -= Circle(uv, vec2(-0.055, 0.22), 0.03);\n       body += Circle(uv, vec2(-0.08, 0.36), 0.03);\n       body += Circle(uv, vec2(0.08, 0.36), 0.03);\n       body += Circle(uv, vec2(-0.08, 0.38), 0.03);\n       body += Circle(uv, vec2(0.08, 0.38), 0.03);\n       body += Circle(uv, vec2(-0.08, 0.39), 0.03);\n       body += Circle(uv, vec2(0.08, 0.39), 0.03);\n       body += Circle(uv, vec2(-0.11, 0.39), 0.03);\n       body += Circle(uv, vec2(0.11, 0.39), 0.03);\n       body += Circle(uv, vec2(-0.13, 0.39), 0.03);\n       body += Circle(uv, vec2(0.13, 0.39), 0.03);\n       body += Circle(uv, vec2(-0.15, 0.39), 0.03);\n       body += Circle(uv, vec2(0.15, 0.39), 0.03);\n       body += Circle(uv, vec2(-0.17, 0.39), 0.03);\n       body += Circle(uv, vec2(0.17, 0.39), 0.03);\n       body += Circle(uv, vec2(-0.19, 0.39), 0.03);\n       body += Circle(uv, vec2(0.19, 0.39), 0.03); \n       body += Circle(uv, vec2(-0.21, 0.39), 0.02);\n       body += Circle(uv, vec2(0.21, 0.39), 0.02);\n       body += Circle(uv, vec2(-0.21, 0.41), 0.02);\n       body += Circle(uv, vec2(0.21, 0.41), 0.02);\n       body += Circle(uv, vec2(-0.21, 0.43), 0.02);\n       body += Circle(uv, vec2(0.21, 0.43), 0.02);\n       body += Circle(uv, vec2(-0.21, 0.45), 0.02);\n       body += Circle(uv, vec2(0.21, 0.45), 0.02);\n       body += Circle(uv, vec2(-0.15, 0.39), 0.02);\n       body += Circle(uv, vec2(0.15, 0.39), 0.02);\n       body += Circle(uv, vec2(-0.15, 0.41), 0.02);\n       body += Circle(uv, vec2(0.15, 0.41), 0.02);\n       body += Circle(uv, vec2(-0.15, 0.43), 0.02);\n       body += Circle(uv, vec2(0.15, 0.43), 0.02);\n       body += Circle(uv, vec2(-0.15, 0.45), 0.02);\n       body += Circle(uv, vec2(0.15, 0.45), 0.02);\n       body += Circle(uv, vec2(-0.09, 0.39), 0.02);\n       body += Circle(uv, vec2(0.09, 0.39), 0.02);\n       body += Circle(uv, vec2(-0.09, 0.41), 0.02);\n       body += Circle(uv, vec2(0.09, 0.41), 0.02);\n       body += Circle(uv, vec2(-0.09, 0.43), 0.02);\n       body += Circle(uv, vec2(0.09, 0.43), 0.02);\n       body += Circle(uv, vec2(-0.09, 0.45), 0.02);\n       body += Circle(uv, vec2(0.09, 0.45), 0.02);\n       body += Circle(uv, vec2(0.20, 0.18), 0.04);\n       body += Circle(uv, vec2(-0.20, 0.18), 0.04);\n       body += Circle(uv, vec2(0.24, 0.14), 0.03);\n       body += Circle(uv, vec2(-0.24, 0.14), 0.03);\n       body += Circle(uv, vec2(0.27, 0.11), 0.02);\n       body += Circle(uv, vec2(-0.27, 0.11), 0.02);\n       body += Circle(uv, vec2(0.10, -0.01), 0.04);\n       body += Circle(uv, vec2(-0.10, -0.01), 0.04);\n       body += Circle(uv, vec2(0.10, -0.03), 0.04);\n       body += Circle(uv, vec2(-0.10, -0.03), 0.04);\n       body += Circle(uv, vec2(0.10, -0.05), 0.04);\n       body += Circle(uv, vec2(-0.10, -0.05), 0.04);\n       body += Circle(uv, vec2(0.12, -0.05), 0.04);\n       body += Circle(uv, vec2(-0.12, -0.05), 0.04);\n       body += Circle(uv, vec2(0.14, -0.05), 0.04);\n       body += Circle(uv, vec2(-0.14, -0.05), 0.04);\n       \n      float mouth = Circle(uv, vec2(0.0, 0.16), 0.08);\n       mouth -= Circle(uv, vec2(0.0, 0.21), 0.1);\n\n        body -= mouth;\n        body -= Circle(uv, vec2(0.058, 0.22), 0.03);\n        body -= Circle(uv, vec2(-0.058, 0.22), 0.03);\n \n         fragColor = vec4(vec3(body),1.0);\n    \n          vec3 pic = vec3(1.0, 1.0, 1.0)*body;\n           fragColor = vec4(pic, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3Dd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 132], [134, 134, 189, 189, 3730]], "test": "untested"}
{"id": "fl2GDd", "name": "Balthazaurus test", "author": "vonba", "description": "This is an api test", "tags": ["test"], "likes": 5, "viewed": 262, "published": 3, "date": "1624994730", "time_retrieved": "2024-07-30T19:13:19.980362", "image_code": "vec4 lookup(sampler2D src, float x, float y)\n{\n\treturn texture(src, vec2(x / iResolution.x, y / iResolution.y));\n}\n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord, float seedA, float seedB, float speed)\n{\n\tvec2 sourceToCoord = coord - raySource;\n\tfloat cosAngle = dot(normalize(sourceToCoord), rayRefDirection);\n\t\n\treturn clamp(\n\t\t(0.45 + 0.15 * sin(cosAngle * seedA + iTime * speed)) +\n\t\t(0.3 + 0.2 * cos(-cosAngle * seedB + iTime * speed)),\n\t\t0.0, 1.0) *\n\t\tclamp((iResolution.x - length(sourceToCoord)) / iResolution.x, 0.5, 1.0);\n}\n\nfloat bubbleStrength(vec2 startPos, vec2 waveOffset, float radius, float speed, vec2 coord)\n{\n\tvec2 curPos = vec2(\n\t\tmod(startPos.x + waveOffset.x * 0.5, iResolution.x + radius * 2.0) - radius,\n\t\tmod(waveOffset.y - iTime * speed, iResolution.y + radius * 2.0) - radius);\n\treturn 1.0 - smoothstep(0.0, radius, length(coord - curPos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\tvec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n\t\n\t// Calculate the lookup transformation offset for the current fragment\n\tfloat offsetX = (0.1112 * iResolution.x * cos(1.44125 * (iTime + uv.y))) + (26.77311 * iTime);\n\tfloat offsetY = (0.08447 * iResolution.y * sin(2.14331 * (iTime + uv.x)));\n\t\n\t// Use parallax transformed lookup on the texture layers\n\tvec4 tex1 = lookup(iChannel0, coord.x + offsetX, coord.y + offsetY);\n\tvec4 tex2 = lookup(iChannel1, coord.x * 2.0 + offsetX * 1.6, coord.y * 2.0 + offsetY * 1.5);\n\tvec4 tex3 = lookup(iChannel2, coord.x * 3.0 + offsetX * 1.3, coord.y * 3.0 + offsetY * 1.2);\n\tvec4 tex4 = lookup(iChannel3, coord.x * 0.5 + offsetX * 0.8, coord.y * 0.5 + offsetY * 0.9);\n\t\n\t// Set the parameters of the sun rays\n\tvec2 rayPos1 = vec2(iResolution.x * 0.1, iResolution.y * -0.4);\n\tvec2 rayRefDir1 = normalize(vec2(1.0, -0.116));\n\tfloat raySeedA1 = 36.2214;\n\tfloat raySeedB1 = 21.11349;\n\tfloat raySpeed1 = 1.5;\n\t\n\tvec2 rayPos2 = vec2(iResolution.x * 1.2, iResolution.y * -0.6);\n\tvec2 rayRefDir2 = normalize(vec2(1.0, 0.241));\n\tfloat raySeedA2 = 22.39910;\n\tfloat raySeedB2 = 18.0234;\n\tfloat raySpeed2 = 1.1;\n\t\n\t// Calculate the colour of the sun rays on the current fragment\n\tvec4 rays1 =\n\t\tvec4(1.2, 1.0, 1.0, 1.0) *\n\t\trayStrength(rayPos1, rayRefDir1, coord, raySeedA1, raySeedB1, raySpeed1);\n\t \n\tvec4 rays2 =\n\t\tvec4(1.0, 1.2, 1.0, 1.0) *\n\t\trayStrength(rayPos2, rayRefDir2, coord, raySeedA2, raySeedB2, raySpeed2);\n\t\n\t\n\t// Calculate the colours contribution of each bubble on the current fragment.\n\tfloat bubbleScale = iResolution.x / 600.0;\n\t\n\tvec4 bubble1 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(0.0, 0.0), vec2(offsetX * 0.2312, 0.0), 20.0 * bubbleScale, 60.0, coord);\n\t\n\tvec4 bubble2 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(40.0, 400.0), vec2(offsetX * -0.06871, offsetY * 0.301), 7.0 * bubbleScale, 25.0, coord);\n\t\n\tvec4 bubble3 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(300.0, 70.0), vec2(offsetX * 0.19832, offsetY * 0.1351), 14.0 * bubbleScale, 45.0, coord);\n\t\n\tvec4 bubble4 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(500.0, 280.0), vec2(offsetX * -0.0993, offsetY * -0.2654), 12.0 * bubbleScale, 32.0, coord);\n\t\n\tvec4 bubble5 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(400.0, 140.0), vec2(offsetX * 0.2231, offsetY * 0.0111), 10.0 * bubbleScale, 28.0, coord);\n\t\n\tvec4 bubble6 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(200.0, 360.0), vec2(offsetX * 0.0693, offsetY * -0.3567), 5.0 * bubbleScale, 12.0, coord);\n\t\n\tvec4 bubble7 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(0.0, 0.0), vec2(offsetX * -0.32301, offsetY * 0.2349), 16.0 * bubbleScale, 51.0, coord);\n\t\n\tvec4 bubble8 =\n\t\tvec4(1.0, 1.0, 1.0, 1.0) *\n\t\t bubbleStrength(vec2(130.0, 23.0), vec2(offsetX * 0.1393, offsetY * -0.4013), 8.0 * bubbleScale, 24.0, coord);\n\t\t\n\t\n\t// Blend all of the elements together.\n\t// This deliberately saturates the colour in places.\n\tfragColor = \n\t\ttex1 * 0.45 +\n\t\ttex2 * 0.25 +\n\t\ttex3 * 0.15 +\n\t\ttex4 * 0.1 +\n\t\trays1 * 0.5 +\n\t\trays2 * 0.4 +\n\t\tbubble1 * 0.25 +\n\t\tbubble2 * 0.1 +\n\t\tbubble3 * 0.18 +\n\t\tbubble4 * 0.13 +\n\t\tbubble5 * 0.15 +\n\t\tbubble6 * 0.05 +\n\t\tbubble7 * 0.12 +\n\t\tbubble8 * 0.11;\n\t\n\t// Uncomment this line if you want to see just the rays:\n\t//fragColor = rays1 * 0.5 + rays2 * 0.5;\n\t\n\t// Attenuate brightness towards the bottom, simulating light-loss due to depth.\n\t// Give the whole thing a blue-green tinge as well.\n\tfloat brightness = 1.0 - (coord.y / iResolution.y);\n\tfragColor.x *= 0.2 + (brightness * 0.8);\n\tfragColor.y *= 0.3 + (brightness * 0.7);\n\tfragColor.z *= 0.4 + (brightness * 0.6);\n\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2GDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 114], [116, 116, 224, 224, 554], [556, 556, 649, 649, 891], [893, 893, 950, 950, 4647]], "test": "untested"}
{"id": "Nt2GDd", "name": "Too many eyes", "author": "mrange", "description": "License CC0: Too many eyes\nContinued tweaking on KIFS fractals", "tags": ["3d", "raymarching"], "likes": 16, "viewed": 490, "published": 3, "date": "1624994629", "time_retrieved": "2024-07-30T19:13:21.007615", "image_code": "// License CC0: Too many eyes\n// Continued tweaking on KIFS fractals\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 50\n#define NORM_OFF        0.0001\n#define N(a)            normalize(vec3(sin(a), -cos(a),  0.0))\n#define SCA(x)          vec2(sin(x), cos(x))\n\nconst vec3  std_gamma  = vec3(2.2);\nconst float smoothing  = 0.125*0.25;\n\nfloat g_v = 0.0;\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\nvec3 refl(vec3 p, vec3 n) {\n  p -= n*pmin(0.0, dot(p, n), smoothing)*2.0;\n  return p;\n}\n\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat solidAngle(vec3 p, vec2 c, float ra) {\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat df(vec3 p) {\n  vec3 op = p;\n  const float zf = 2.0-0.3;\n  const vec3 n0  = N((PI-acos(1.0/3.0))/2.0);\n  const vec3 n1 = vec3(n0.x, n0.yz*ROT(2.0*PI/3.0));\n  const vec3 n2 = vec3(n0.x, n0.yz*ROT(-2.0*PI/3.0));\n\n  float a  = TIME*0.1;\n  mat2 rxy = ROT(a);\n  mat2 ryz = ROT(a*sqrt(0.5));\n  float z = 1.0;\n  \n  float d = 1E6;\n\n  const int mid = 0;\n  const int end = 4;\n  \n  float v = 0.0;\n\n  for (int i = 0; i < mid; ++i) {\n    p.xy *= rxy;\n    p.yz *= ryz;\n  //  p = -pabs(p, smoothing); \n    p = refl(p, n2);\n    p = refl(p, n0);\n    p = refl(p, n1);\n    p.x -= 0.3;\n    p *= zf;\n    z *= zf;\n  }\n\n  vec2 sca = SCA(1.3*PI/2.0);\n\n  for (int i = mid; i < end; ++i) {\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p = -pabs(p, smoothing); \n    p = refl(p, n2);\n//    p = refl(p, n0);\n    p = refl(p, n1);\n//    p.x -= 0.3+0.075*(sin(10.0*op.x-time));\n    p.x -= 0.3;\n    p *= zf;\n    z *= zf;\n    vec3 pp = p;\n    const float sz = 0.125;\n    vec2 nn = mod2(pp.yz, vec2(sz*3.0));\n    float rr = TAU*hash(nn+float(i));\n    vec3 eyedir = normalize(vec3(1.0, 0.0, 0.0));\n    eyedir.xz *= ROT(0.5*smoothstep(-0.75, 0.75, sin(rr+TIME)));\n    eyedir.xy *= ROT(0.5*smoothstep(-0.75, 0.75, sin(rr+TIME*sqrt(2.0))));\n    float d2 = dot(normalize(pp), eyedir);\n    float vv = mix(PCOS(10.0*TAU*d2-TAU*TIME), 1.0, smoothstep(1.0, 0.66, d2))*smoothstep(0.9, 0.80, d2);\n    float dd1 = length(pp) - sz*0.9;\n    float dd3 = solidAngle(-pp.zxy, sca, sz*0.9)-sz*0.1;\n    float dd = dd1;\n    dd = min(dd1, dd3);\n    vv = dd == dd3 ? 1.0 : vv;\n    dd /= z;\n    \n    float ddd = pmin(d, dd, 2.0*smoothing/z);\n    v = mix(vv, v, abs(ddd - dd)/abs(d - dd));\n    d = ddd;\n  }\n\n  g_v = v;\n\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = vec3(1.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n\n  float beat  = smoothstep(0.25, 1.0, sin(TAU*TIME*10.0/60.0));\n  float sr    = mix(0.45, 0.5, beat);\n  float sd    = sphered(ro, rd, vec4(vec3(0.0), sr), t);\n\n  vec3 gcol   = sd*mix(1.5*vec3(2.25, 0.75, 0.5), 3.5*vec3(2.0, 1.0, 0.75), beat);\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n  float ifade = 1.0-tanh_approx(1.25*ii);\n  float h     = fract(-1.0*length(pos)+0.1);\n  float s     = 0.25;\n  float v     = tanh_approx(0.4/(1.0+40.0*sd));\n  vec3 color  = hsv2rgb(vec3(h, s, v));\n  color       *= g_v;\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);\n\n  float dm  = 4.0/ll2;\n  float dif = pow(max(dot(nor,ld),0.0),2.0)*dm;  \n  float spe = pow(max(dot(refl, ld), 0.), 20.);\n  float ao  = smoothstep(0.5, 0.1 , ii);\n  float l   = mix(0.2, 1.0, dif*sha*ao);\n\n  vec3 col = l*color + 2.0*spe*sha;\n//  return vec3(ao);\n  return gcol+col*ifade;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME;\n  vec3 cam  = 1.75*vec3(1.0, 0.5, 0.0);\n  float rt  = TAU*TIME/30.0;;\n  cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);\n  cam.xz   *= ROT(sin(rt)*1.0-0.75);\n  vec3 la   = vec3(0.0);\n  vec3 dcam = normalize(la - cam);\n  vec3 ddcam= vec3(0.0);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2GDd.jpg", "access": "api", "license": "cc0-1.0", "functions": [[629, 629, 650, 650, 717], [719, 719, 747, 767, 843], [845, 898, 920, 920, 1089], [1091, 1091, 1127, 1127, 1360], [1362, 1362, 1401, 1401, 1490], [1492, 1492, 1531, 1531, 1560], [1562, 1562, 1598, 1598, 1686], [1688, 1688, 1716, 1716, 1744], [1746, 1746, 1773, 1773, 1833], [1835, 1835, 1893, 1893, 2374], [2376, 2376, 2420, 2420, 2585], [2588, 2588, 2624, 2624, 2718], [2720, 2720, 2738, 2738, 4392], [4394, 4394, 4442, 4442, 4637], [4639, 4639, 4662, 4662, 4870], [4872, 4872, 4940, 4940, 5219], [5221, 5221, 5252, 5252, 6514], [6516, 6516, 6547, 6547, 7034], [7036, 7036, 7091, 7091, 7281]], "test": "untested"}
{"id": "NljGWd", "name": "Mipmap Diffusion", "author": "oneshade", "description": "First general purpose mipmap experiment. Adjust the diffusion with the mouse (defaults when mouse is not down).", "tags": ["mipmap", "diffusion", "gpmipmap", "colortrails"], "likes": 26, "viewed": 358, "published": 3, "date": "1624990191", "time_retrieved": "2024-07-30T19:13:21.869312", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Sync iTime with the frame\n#define iTimeDelta 0.01\n#define iTime (float(iFrame) * iTimeDelta)\n\nstruct View {\n    vec2 pos;\n    mat2 ori;\n};\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec3 Hash23(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec2 Hash12(in float t) {\n\tvec3 p3 = fract(t * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nView getView(in float t) {\n    float id = floor(t), local = fract(t);\n    vec2 a = Hash12(id), b = Hash12(id + 1.0), c = Hash12(id + 2.0);\n    vec2 mid1 = 0.5 * (a + b), mid2 = 0.5 * (b + c);\n\n    vec2 pos = mix(mix(mid1, b, local), mix(b, mid2, local), local);\n    vec2 dir = normalize(mid1 * (local - 1.0) + (1.0 - 2.0 * local) * b + mid2 * local);\n\n    return View(pos, mat2(dir.y, -dir.x, dir));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float diffusion = iMouse.z > 0.0 ? mix(0.0, 3.0, iMouse.x / iResolution.x) : 1.0;\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy, diffusion);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n\n    View view = getView(iTime * 0.1);\n    uv -= view.pos * 50.0 - 25.0;\n    uv *= view.ori;\n\n    vec2 cell = round(uv);\n    uv = uv - cell;\n\n    float freq1 = Hash11(dot(cell, vec2(393.84, 673.48))) * 30.0 - 15.0;\n    float freq2 = Hash11(dot(cell, vec2(492.843, 596.395))) * 30.0 - 15.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69))) * 0.4;\n    uv -= vec2(cos(iTime * freq1 + phase), sin(iTime * freq2 + phase)) * amp;\n\n    fragColor = vec4(mix(fragColor.rgb, Hash23(cell), smoothstep(unit, 0.0, length(uv) - 0.1)), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljGWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 121]], "test": "untested"}
{"id": "7tBGDd", "name": "Day 558", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 17, "viewed": 399, "published": 3, "date": "1624984419", "time_retrieved": "2024-07-30T19:13:22.753946", "image_code": "// wonky parametric 3d surface, projected perspectively to 2d\n// rendered with 2d line sdf \n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// from iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 transformPt(vec3 p){\n    p.xz *= rot(0. + sin(iTime*0.2)*0.4);\n    p.xy *= rot(0. + sin(iTime*0.6)*0.4 + 2. + iTime*0.2);\n    p.z += 1.5 + sin(iTime + sin(iTime))*0.5;\n    \n    p.xy /= p.z*3.;\n    \n    return p;\n}\n\nconst float itersi = 40.;\nconst float itersj = 40.;\n\nconst float mul = pi*1.;\nconst vec2 stepSz = 1./vec2(itersi,itersj)*mul;\n\nvec3 getP(vec2 idx){\n    //idx.x += iTime*3.4;\n    //idx.y += iTime*0.001;\n    idx.y += idx.x*stepSz.x*(74. + sin(iTime*0.5)*50.) + iTime*2.;\n    vec3 p = vec3(sin(idx.x*sin(idx.y*0.5)) + cos(idx.y )*0.5,cos(idx.y)*1. + cos(idx.x*1. )*1.,sin(idx.y));            \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1.,1.1,1.);\n    float minZ = 10e4;\n    for(float i = 0.; i < itersi; i++){\n        for(float j = 0.; j < itersi; j++){\n            vec2 idx = vec2(i/itersi,j/itersj)*mul;\n            vec3 p = getP(idx);\n            vec3 pNi = getP(idx + vec2(1,0.)*stepSz);\n            //vec3 pNj = getP(idx + vec2(0,1.)*stepSz);\n            \n            //points[int(j + i*itersj)] = p;\n            vec3 op = p;\n            p = transformPt(p);\n            pNi = transformPt(pNi);\n            //pNj = transformPt(pNj);\n            //vec3 n = cross(pNi - p,pNj - p);\n            \n            float li = sdSegment( uv, p.xy, pNi.xy );\n            //float lj = sdSegment( uv, p.xy, pNj.xy );\n\n            //float d = dot(p.xy - uv.xy,p.xy - uv.xy);\n            float d = 10e5;\n            d = min(d,li);\n            //d = min(d,lj);\n            //bool normalCond = n.z > -0.000;\n            bool normalCond = true;\n            \n            \n            float dfac = smoothstep(fwidth(uv.y),0.,d - 0.00);\n            if(p.z > 0.)\n            col = mix(col,vec3(0),dfac*1.*smoothstep(0.2,1.,abs(op.z)));\n            //if (d < fwidth(uv.y)*0.5 && normalCond)col -= 1.;\n            \n            if(p.z < minZ && dfac > 0.1)\n                minZ = p.z;\n                //minZ = mix(minZ,p.z,dfac);\n            \n        \n        }\n    }\n                    \n    {\n        float iters = 7.;\n        for(float i = 0.; i < iters; i++){\n            for(float j = 0.; j < iters; j++){\n                for(float k = 0.; k < iters; k++){\n                    vec3 p = vec3(i/iters - 0.5 + sin(i + cos(k*20. +iTime)+ iTime)*0.0,k/iters - 0.5,j/iters - 0.5)*4.;\n                    vec3 op = p;\n                    p = transformPt(p);\n                    \n                    vec2 np = p.xy - uv.xy;\n                    np.xy *= rot(0.25*pi);\n                    np *= rot((p.x*2. + sin(p.z+iTime*1.) + iTime));\n                    //float d = length(p.xy - uv.xy) - 0.00;\n                    float d = max(min(abs(np.x),abs(np.y)) - 0.0004,length(np) - 0.01*sin(k/iters +cos(i/iters*6.)+ iTime));\n                    //if (d < fwidth(uv.y)*0.5 && normalCond)col -= 1.;\n                    if(\n                        (p.z > 0. && !(minZ < 10e4 && p.z > minZ )))\n                        col = mix(col,vec3(1.+ sin(p.x*4. + iTime*3.)*0.,0.,0.4 ) - col*1.,smoothstep(fwidth(uv.y),0.,d - 0.00));\n\n                }\n            }\n        }\n    }\n    vec2 ouv = uv;\n    float md = 0.025;\n    vec3 p = vec3(uv*1.,0);\n    //p = transformPt(p);\n            \n    p = pmod(p,md);\n    float d = min(abs(p.x),abs(p.y));\n    //d = max(d,-length(p.xy) + md*0.5);\n    //d = min(d,-abs(uv.x + uv.y) );\n    d -= 0.02*md;\n    float pxSz = fwidth(uv.y);\n    col = mix(col,vec3(0.,0.7,0.1) - col*1.,smoothstep(pxSz,0.,d - 0.00)*smoothstep(md*0.02,0.,d)*0.2);\n    \n    if(mod(iTime,3.) < 0.5 && fract(iTime/0.01) < 0.5){\n        //col = vec3(1,1.,0.7) - col;\n    }\n    \n    \n    col = pow(col,vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 211, 263, 263, 382], [384, 384, 409, 409, 602], [731, 731, 751, 805, 1009], [1011, 1011, 1068, 1068, 4136]], "test": "untested"}
{"id": "stBGWd", "name": "Смешарик Филипенко", "author": "filipenkonikita", "description": "Смешарик", "tags": ["sm"], "likes": 1, "viewed": 220, "published": 3, "date": "1624981691", "time_retrieved": "2024-07-30T19:13:23.632597", "image_code": "/*float circle2(in vec2 _st, in float _radius){\n        vec2 dist = _st-vec2(0.5);\n        return 1.-smoothstep(_radius-(_radius*0.01),\n                             _radius+(_radius*0.01),\n                             dot(dist,dist)*4.0);\n    }\n*/\n    float circle(vec2 a, vec2 point, float r, float blur)\n    {\n        float b=length(a-point);\n         float c=smoothstep(r,r-blur,b);\n        return c;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a = fragCoord.xy/iResolution.xy;\n     a-=.5;\n     a.x*=iResolution.x/iResolution.y;\n    float c=circle(a, vec2(.0,-.1), .3, .01);\n     c+=circle(a, vec2(-.3, .1), .1, .01);\n     c+=circle(a, vec2(.3, .1), .1, .01);\n     c+=circle(a, vec2(.2, -.41), .1, .01);\n     c+=circle(a, vec2(-.2, -.41), .1, .01);\n     c+=circle(a, vec2(.0, .32), .2, .01);\n     c-=circle(a, vec2(-.08, .4), .05, .01);\n     c-=circle(a, vec2(.08, .4), .05, .01);\n    vec3 color=vec3(0.);\n     color=vec3(0., 0., 1.)*c;\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 252, 311, 311, 409], [411, 411, 468, 468, 1003]], "test": "untested"}
{"id": "wdKfWm", "name": "test about face isoline", "author": "firegump", "description": "dilation method for isoline interpolate", "tags": ["isolineinterpolate"], "likes": 0, "viewed": 492, "published": 3, "date": "1624970877", "time_retrieved": "2024-07-30T19:13:24.554133", "image_code": "//#define AA\n\nvec3 AAfilter(vec2 uv)\n{\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = -1;i<2;i++)\n    {\n        for(int j = - 1; j<2 ;j++)\n        {\n            vec2 ouv = uv + vec2(i,j)/512.;\n            col += texture(iChannel2, ouv).xyz;\n        \n        }\n    \n    }\n    return col/9.0;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = texture(iChannel3,uv).xyz;\n#ifdef AA\n    c = AAfilter(uv);\n#endif\n\n    //animation\n    float sm =(sin(iTime)+1.)*.5;\n    //c = smoothstep(sm,sm+0.02,c); \n    \n\n    fragColor =fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define G true\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \t\n\n\n\t//base\n\n\tfloat c = uv.x;\n    \n    c = floor(c*4.)/4.;\n    \n    \n\n    \n    c = c+ step(uv.x,0.1) + step(0.9,uv.x);\n\n    c = min(c,1.);\n\n    //face simulate\n    \n   \tvec2 suv = 2.*(uv -0.5);\n    \n    suv.x = pow(abs(suv.x),1.1/(2.-abs(suv.y))) *sign(suv.x);\n    \n    suv = 0.5*(suv + 1.);\n    \n    float d = floor(suv.x*8.)/8.;\n\t\n    // cycle image\n    \n    float e = length(uv-0.5)*2.;\n    \n    e = floor(e*7.)/7.;\n\t//black outline\n   \tvec2 ouv = uv;\n    ouv = (ouv-0.5)*2.;\n    ouv = abs(ouv);\n    \n    float outlineS = 0.95;\n    float outline = step(ouv.x,outlineS)*step(ouv.y,outlineS);\n    \n    \n    // face----------------------------------------------------------------------------\n\tvec3 col = vec3(0.);\n    \n    float offy = \n    \n    uv.y *= 1.05;\n    uv.y -= 0.025;\n    uv.x *= 1.2;\n    uv.x -= 0.1;\n    \n    float xO = abs(uv.y - 0.5);// y =0.5 0 0.5\n    xO *= 2.;// y = 1 0 1;\n    \n   \n    xO = pow(xO,20.);//near the top bottom, lines can be closer\n   \n    uv.x = (uv.x*2.-1.);\n    float s = uv.x/abs(uv.x);\n    \n    uv.x = abs(uv.x) + xO;\n    \n    \n    uv.x *= s;\n    \n    uv.x = uv.x*0.5 + 0.5;\n    \n    \n    \n    \n    float f= floor(uv.x*13.5)/13.5;\n        \n        \n    c = f*outline;\n    \n    c = min(1.,c);\n    //face2-------------------------------------------------------------------------------\n    vec2 uvface2 = fragCoord/iResolution.xy;\n    \n    float offsetx = pow((1.-abs(uvface2.y -0.5)*2.),4.);\n    offsetx = mix(offsetx, 0., pow(2.*abs(uvface2.x-0.5),0.05)  );\n    uvface2.x += offsetx*0.2;\n    \n    float b = uvface2.y;\n    \n    b = pow(b , .4);\n    b = smoothstep(0.,1.,b);\n    \n    \n    float a = uvface2.x*2.-1.;\n    a = (pow(abs(a)/b ,2.) * sign(a))*.5 + .5;\n   \n    \n    float finalCol = a;\n    \n    \n    if(G){ \n    //Gradient line\n    float GVal = 8.;\n    finalCol = ceil(finalCol*GVal)/(GVal);}\n    \n    //cycle\n    vec2 cuv = uvface2;\n    \n    \n    float cycleSample = length(cuv - vec2(0.40,0.5));\n    float cycle = step(cycleSample,0.07);\n    \n    float cmodify = floor((1.-cycleSample)*40.)/40.;\n    \n    c = mix(finalCol ,finalCol+(cmodify-0.89)*14./8.,cycle);\n    //+(cmodify-0.89)*14./8.\n    \n    //c = cycle;\n    //c = offsetx;\n    c = min(1.,c);\n    fragColor = vec4(vec3(c,c,c),1.0);\n    \n    \n}", "buffer_a_inputs": [], "buffer_b_code": "#define MaxSteps 512.\n#define TextureSize 512.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \t\n\n\n    \n    \n    //sdf\n    float threshold = 0.0;\n    float Sample = texture(iChannel0,uv).x;\n    \n\t\n    float texelsize = 1. / TextureSize;\n\tfloat mindist = 10000000.;\n    float MaxS = 0.;\n\tfloat MinS = 0.;\n    //vec2 offsets[16] = vec2[](vec2(1.0,0.0),vec2(0.92388,0.382683),vec2(0.707107,0.707107),vec2(0.382683,0.92388),vec2(-0.0,1.0),vec2(-0.382683,0.92388),vec2(-0.707107,0.707107),vec2(-0.923879,0.382684),vec2(-1.0,0.0),vec2(-0.92388,-0.382683),vec2(-0.707107,-0.707107),vec2(-0.382684,-0.923879),vec2(-0.0,-1.0),vec2(0.382683,-0.92388),vec2(0.707107,-0.707107),vec2(0.923879,-0.382684));\n    vec2 offsets[8] = vec2[](vec2(-1,0), vec2(1,0), vec2(0,1), vec2(0,-1), vec2(-1,1), vec2(1,1), vec2(1,-1), vec2(-1,-1));\n   \tbool findMax = false;\n    float distMax = 0.;\n\tbool findMin = false;\n    float distMin = 0.;\n\tfloat c = 0.;\n    float k = 0.;\n    bool ifTop = false;\n    \n\n    \n    float cull = 0.3;\n    \n    if(abs(Sample-0.5) <  cull+200.){//cull two side\n    \t\n\t\t\n    \tfloat i = 0.;\n\t    while(i<MaxSteps)\n\t\t{\n           if(findMax&&findMin) break;//if find both the maximum and the minimum,if only find one, keep going\n           i++;\n            float j = 0.;\n            while(j<8.)\n            {\n                \n            \tvec2 cuv = uv + normalize(offsets[int(j)]) * texelsize * i;\n                if(cuv.x<0.||cuv.x>1.||cuv.y<0.||cuv.y>1.) break;//if out the uv break loop\n                \n                \n                \n                float offsetSample = texture(iChannel0,cuv).x;\n                \n                if(Sample - offsetSample > threshold && !findMin)\n                {\n                \tMinS = offsetSample;\n                \tfindMin = true;\n                    distMin =  texelsize * i;\n                    break;\n                }\n\t\t\t\telse if(Sample - offsetSample < threshold && !findMax)\n                {\n                \tMaxS = offsetSample;\n                    findMax = true;\n                    distMax =  texelsize * i;\n                    break;\n                }\n\n                \n             \n\t\t\t\n                j++;\n            }//inside loop\n        \n        \n        }//out loop\n    \n    //calculate result\n    k = distMin/(distMax + distMin);\n    //k = ifTop?1.- k:k;\n    \n    k = pow(k,1.);\n  \n    \t\n     c = Sample*k + MinS*(1.-k);\n    \t\n    \n    \n    //modify result to 0 -1\n    \n    c = abs(c - 0.5)*(0.5/cull)*sign(c - 0.5) +0.5;\n    \t\n     //c = distMax;\n    \n  }//endif\n\n   \n\t//c = k;\n   \t//comparison\n    float t = (sin(iTime)+1.)*.5;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    t = 0. + m.y;\n\tc = mix(c,Sample,step(uv.y,t));   \n    \n    //debug line\n    float d = uv.x;\n    \n    d = step(0.001,fract(d*4.)/4.);\n    \n     \n    \n     \n   \t //c= MinS;\n\t//c = Sample;\n    vec3 color = vec3(c,c,c);\n    //vec3 color = mix(vec3(1,0,0),vec3(c,c,c), d);\n    \n    \n    \n\n    fragColor =fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define AA\nvec3 AAfilter(vec2 uv)\n{\n    vec3 col = vec3(0.,0.,0.);\n    for(int i = -1;i<2;i++)\n    {\n        for(int j = - 1; j<2 ;j++)\n        {\n            vec2 ouv = uv + vec2(i,j)/512.;\n            col += texture(iChannel1, ouv).xyz;\n        \n        }\n    \n    }\n    return col/9.0;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n   vec3 c = texture(iChannel1,uv).xyz;\n#ifdef AA\n    c = AAfilter(uv);\n#endif\n\n\n    \n\n    fragColor =fragColor = vec4(c, 1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define threshold 0.4\nvec3 correctionFilter(vec2 uv)\n{\n    float c = 0.;\n    float current = 0.;\n    for(int i = -1;i<2;i++)\n    {\n        for(int j = - 1; j<2 ;j++)\n        {\n            if(i == 0 && j == 0)\n            {\n            \n                current = texture(iChannel1, uv).x;\n            }\n            vec2 ouv = uv + vec2(i,j)/512.;\n            c += texture(iChannel1, ouv).x;\n        \n        }\n    \n    }\n    \n    if( abs(current - (c/8.0))> threshold)\n    {\n        c = c/8.0;\n    }\n    else\n    {\n        c = current;\n    }\n    vec3 col = vec3(c,c,c);\n    return  col;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c = texture(iChannel1,uv).xyz;\n    \n    c = correctionFilter(uv);\n    \n\n    fragColor =fragColor = vec4(c, 1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 38, 38, 297], [298, 298, 355, 405, 661]], "test": "untested"}
{"id": "NtBGDd", "name": "Polygon Interpolation II", "author": "oneshade", "description": "Experimenting more, this time with texture mapping and visualizing UV grid lines.", "tags": ["test", "texture", "barycentric", "uvs", "polygon", "interpolation", "meanvaluecoordinates"], "likes": 18, "viewed": 296, "published": 3, "date": "1624934459", "time_retrieved": "2024-07-30T19:13:25.330058", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\n// Number of vertices\n#define N 6\n\nvoid polyLerpWeights(in vec2 p, in vec2[N] poly, out float[N] weights) {\n    float norm = 0.0;\n    for(int n = 0; n < N; n++) {\n        vec2 a = poly[(n - 1 + N) % N] - p;\n        vec2 b = poly[n] - p;\n        vec2 c = poly[(n + 1) % N] - p;\n\n        float d = length(b);\n        float ab = dot(a, b), bc = dot(b, c), ad = length(a) * d, dc = d * length(c);\n        float u = sqrt(max(0.0, (ad - ab) / (ad + ab))) * sign(a.x * b.y - a.y * b.x);\n        float v = sqrt(max(0.0, (dc - bc) / (dc + bc))) * sign(b.x * c.y - b.y * c.x);\n\n        weights[n] = (u + v) / d;\n        norm += weights[n];\n    }\n\n    for(int n = 0; n < N; n++) weights[n] /= norm;\n}\n\n// Simple point in polygon test extracted from @iq's polygon\n// distance shader: https://www.shadertoy.com/view/wdBXRW\nbool pointInPolygon(in vec2 p, in vec2[N] v) {\n    bool res = false;\n    for (int i=0, j=N - 1; i < N; j = i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n\n        // Winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 c = bvec3(p.y >= v[i].y, p.y < v[j].y, e.x * w.y > e.y * w.x);\n        if (all(c) || all(not(c))) res = !res;  \n    }\n    \n    return res;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = 0.5 * iTime;\n    vec3 color = vec3(0.0);\n\n    // Create polygon\n    float t1 = 0.5 * time, t2 = 1.25 * time, t3 = 1.5 * time;\n    float c1 = 0.4 * cos(t1), s1 = 0.4 * sin(t1);\n    float c2 = 0.4 * cos(t2), s2 = 0.4 * sin(t2);\n    float c3 = 0.4 * cos(t3), s3 = 0.4 * sin(t3);\n\n    vec2[N] poly;\n    poly[0] = vec2(1.0, 0.0);\n    poly[1] = vec2(0.5, sqrt(0.75));\n    poly[2] = vec2(-poly[1].x, poly[1].y);\n    poly[3] = vec2(-1.0, 0.0);\n    poly[4] = -poly[1];\n    poly[5] = vec2(poly[1].x, -poly[1].y);\n    vec2[N] anim = poly; // Copy original positions for animating\n\n    // Distort the vertices\n    for (int n=0; n < N; n++) {\n        float id = float(n + 3);\n        float freq = Hash11(id * 393.84) * 2.0 - 1.0;\n        float phase = Hash11(id * 183.37);\n        float amp = Hash11(id * 275.35) * 1.25;\n        float ang = iTime * freq + phase;\n        anim[n] += vec2(cos(ang), sin(ang)) * amp;\n        anim[n] *= 0.25;\n    }\n\n    // Compute interpolation weights\n    float[N] weights;\n    polyLerpWeights(uv, anim, weights);\n\n    // Interpolate texture coordinates from vertices\n    vec2 texUv = vec2(0.0);\n    for (int n=0; n < N; n++) texUv += poly[n] * weights[n];\n    color = texture(iChannel0, texUv).rgb;\n    color -= smoothstep(1.25 * fwidth(texUv.x), 0.0, abs(mod(texUv.x, 0.2) - 0.1));\n    color -= smoothstep(1.25 * fwidth(texUv.y), 0.0, abs(mod(texUv.y, 0.2) - 0.1));\n\n    // Get distance to edges\n    float d = 1000000.0;\n    for (int n=0; n < N; n++) d = min(d, sdLine(uv, anim[n], anim[(n + 1) % N]));\n\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, d));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBGDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1360, 1401, 1427, 1427, 1513], [1515, 1515, 1562, 1562, 1670]], "test": "untested"}
{"id": "NtS3Wd", "name": "Cactus fractal thing", "author": "jarble", "description": "I don't know what this thing is, but it looks very much like a cactus.", "tags": ["fractal", "cactus"], "likes": 7, "viewed": 267, "published": 3, "date": "1624926448", "time_retrieved": "2024-07-30T19:13:26.076064", "image_code": "#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.6;\n        float scale1 = 1.2;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= fract(-uv-((vec2(uv.x/scale+uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(-uv.yx/s1)*s1;\n            uv.y /= -scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3Wd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 74, 74, 795]], "test": "untested"}
{"id": "ftBGDt", "name": "Polygon Interpolation (Trigless)", "author": "oneshade", "description": "Messing with [url=https://www.shadertoy.com/view/7ljGDc]https://www.shadertoy.com/view/7ljGDc[/url]. Also eliminated all the trigonometry (not much difference on a fast GPU, maybe in other contexts though). Left side: original, right side: trigless.", "tags": ["test", "barycentric", "polygon", "interpolation", "meanvaluecoordinates", "trigless"], "likes": 18, "viewed": 315, "published": 3, "date": "1624915608", "time_retrieved": "2024-07-30T19:13:26.826059", "image_code": "// Try clicking with the mouse to see the weights interpolate it\n// back to its original position (purple is the original position,\n// green is the interpolated position, both should align)\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\n// Number of vertices\n#define N 6\n\n// Trigless version\nvoid polyLerpWeightsTrigless(in vec2 p, in vec2[N] poly, out float[N] weights) {\n    float norm = 0.0;\n    for(int n = 0; n < N; n++) {\n        vec2 a = poly[(n - 1 + N) % N] - p;\n        vec2 b = poly[n] - p;\n        vec2 c = poly[(n + 1) % N] - p;\n\n        float d = length(b);\n        float ab = dot(a, b), bc = dot(b, c), ad = length(a) * d, dc = d * length(c);\n        float u = sqrt(max(0.0, (ad - ab) / (ad + ab))) * sign(a.x * b.y - a.y * b.x);\n        float v = sqrt(max(0.0, (dc - bc) / (dc + bc))) * sign(b.x * c.y - b.y * c.x);\n\n        weights[n] = (u + v) / d;\n        norm += weights[n];\n    }\n\n    for(int n = 0; n < N; n++) weights[n] /= norm;\n}\n\n// Original (slightly modified to match the interface of the trigless one)\nfloat cr2(vec2 A, vec2 B) {\n    return A.x*B.y-A.y*B.x;\n}\n\nfloat getAngle(vec2 A, vec2 B) {\n    return atan(cr2(A, B), dot(A, B));\n}\n\nvoid polyLerpWeightsOriginal(in vec2 p, in vec2[N] poly, out float[N] weights) {\n    vec2 vi, vi_min1, vi_plus1;\n    float sumweights = 0.0;\n    float ang1, ang2;\n    float t1, t2;\n    vec2 vi_p;\n    \n    for(int i = 0; i < N; i++) {\n        vi = poly[i];\n        vi_min1 = poly[(i-1 + N) % N];\n        vi_plus1 = poly[(i+1) % N];\n        vi_p = normalize(vi-p);\n        \n        \n        //ang1 = acos(dot(normalize(vi_min1-p), vi_p));\n        //ang2 = acos(dot(normalize(vi_plus1-p), vi_p));\n        ang1 = getAngle(normalize(vi_min1-p), vi_p);\n        ang2 = getAngle(vi_p, normalize(vi_plus1-p));\n        \n        \n        t1 = tan(ang1*0.5);\n        t2 = tan(ang2*0.5);\n        weights[i] = (t1 + t2) / distance(vi, p);\n        sumweights += weights[i];\n    }\n    \n    //normalize\n    float recp = 1.0/sumweights;\n    for(int i = 0; i < N; i++) {\n        weights[i] *= recp;\n    }\n}\n\n// Simple point in polygon test extracted from @iq's polygon\n// distance shader: https://www.shadertoy.com/view/wdBXRW\nbool pointInPolygon(in vec2 p, in vec2[N] v) {\n    bool res = false;\n    for (int i=0, j=N - 1; i < N; j = i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n\n        // Winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 c = bvec3(p.y >= v[i].y, p.y < v[j].y, e.x * w.y > e.y * w.x);\n        if (all(c) || all(not(c))) res = !res;  \n    }\n    \n    return res;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = 0.5 * iTime;\n    vec3 color = vec3(1.0);\n\n    vec2[N] poly;\n    poly[0] = vec2(1.0, 0.0);\n    poly[1] = vec2(0.5, sqrt(0.75));\n    poly[2] = vec2(-0.5, poly[1].y);\n    poly[3] = vec2(-1.0, 0.0);\n    poly[4] = vec2(-0.5, -poly[1].y);\n    poly[5] = vec2(0.5, -poly[1].y);\n\n    // Distort the vertices\n    for (int n=0; n < N; n++) {\n        float id = float(n + 3);\n        float freq = Hash11(id * 393.84) * 10.0 - 5.0;\n        float phase = Hash11(id * 183.37);\n        float amp = Hash11(id * 275.35) * 2.0;\n        float ang = iTime * freq + phase;\n        poly[n] += vec2(cos(ang), sin(ang)) * amp;\n        poly[n] *= 0.25;\n    }\n\n    if (pointInPolygon(uv, poly)) {\n        // Compute interpolation weights\n        float[N] weights1, weights2;\n        polyLerpWeightsOriginal(uv, poly, weights1);\n        polyLerpWeightsTrigless(uv, poly, weights2);\n\n        // Interpolate colors from vertices\n        vec3 polyLerp = vec3(0.0);\n        float side = step(0.0, uv.x); // Which side of the screen (left: 0, right: 1)\n        for (int n=0; n < N; n++) polyLerp += hue2rgb(float(n) / float(N)) * mix(weights1[n], weights2[n], side);\n        color = polyLerp;\n    }\n\n    // Get distance to edges\n    float d = 1000000.0;\n    for (int n=0; n < N; n++) d = min(d, sdLine(uv, poly[n], poly[(n + 1) % N]));\n\n    color = mix(color, vec3(0.0), smoothstep(unit, 0.0, d));\n\n    if (iMouse.z > 0.0) {\n        // Compute weights for the mouse position\n        float[N] weights;\n        polyLerpWeightsTrigless(mouse, poly, weights);\n\n        // Exact mouse position (to test)\n        float distMouse = length(uv - mouse) - 0.015;\n        color = mix(color, vec3(0.6, 0.0, 0.8), smoothstep(unit, 0.0, distMouse));\n        color = mix(color, vec3(0.0), smoothstep(unit, 0.0, abs(distMouse))); // Outline\n\n        // Test to see if it interpolates back to its original position\n        vec2 mouseLerp = vec2(0.0);\n        for (int n=0; n < N; n++) mouseLerp += poly[n] * weights[n];\n\n        float distMouseLerp = length(uv - mouseLerp) - 0.015;\n        color = mix(color, vec3(0.0, 0.8, 0.6), smoothstep(unit, 0.0, distMouseLerp));\n        color = mix(color, vec3(0.0), smoothstep(unit, 0.0, abs(distMouseLerp))); // Outline\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBGDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1049, 1124, 1151, 1151, 1181], [1183, 1183, 1215, 1215, 1256], [2677, 2718, 2744, 2744, 2830], [2832, 2832, 2879, 2879, 2987]], "test": "untested"}
{"id": "NlB3Wt", "name": "zero car", "author": "jorge2017a1", "description": "zero car", "tags": ["zerocar"], "likes": 8, "viewed": 286, "published": 3, "date": "1624913372", "time_retrieved": "2024-07-30T19:13:27.855307", "image_code": "\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\nvec3 light_pos3;  vec3 light_color3 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\t\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    \n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist4,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist5,-1.0 ,8.0)); \n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n    \n\n    p.z=p.z-10.0;\n    p.x=p.x+5.0;\n    \n    \n    \n    p.xz= rotatev2(p.xz, radians(45.0));\n    \n          p.y=p.y-5.0;\n    vec3 porg=p;\n    \n    //base focos\n    p.x=abs(p.x)-8.0;\n    float sdl1=sdLink( p, 2.0, 1.0, 2.0 );\n        res =opU3(res, vec3(sdl1,1.0,MATERIAL_NO)); \n    \n    //focos\n    float sdc1= sdCylinderXY(p-vec3(0.0,1.5,-0.5), vec2(1.5,2.0) );\n    float sdc2= sdCylinderXY(p-vec3(0.0,-1.5,-0.5), vec2(1.5,2.0) );\n        res =opU3(res, vec3(sdc1,2.0,MATERIAL_NO)); \n        res =opU3(res, vec3(sdc2,2.0,MATERIAL_NO)); \n    \n    \n    //armadura auto\n    float sdc3a= sdCylinderXY(p-vec3(0.0,2.5,15.0), vec2(2.5,15.0) );\n    float sdc3b= sdCylinderXY(p-vec3(0.0,0.0,15.0), vec2(2.5,15.0) );\n        res =opU3(res, vec3(sdc3a,3.0,MATERIAL_NO));\n        res =opU3(res, vec3(sdc3b,3.0,MATERIAL_NO));\n    \n    \n    p=porg;\n    p.x=abs(p.x)-10.0;\n    float sdLlanta1=   sdCylinderYZ(p-vec3(0.0,-1.0,5.0),vec2(3.0,1.0) );\n    float sdLlanta1ch= sdCylinderYZ(p-vec3(0.0,-1.0,5.0),vec2(1.0,1.0) );\n    \n    float sdLlanta2=   sdCylinderYZ(p-vec3(0.0,-1.0,20.0),vec2(3.0,1.0) );\n    float sdLlanta2ch= sdCylinderYZ(p-vec3(0.0,-1.0,20.0),vec2(1.0,1.0) );\n    \n        res =opU3(res, vec3(sdLlanta1,0.0,MATERIAL_NO));\n        res =opU3(res, vec3(sdLlanta1ch,1.0,MATERIAL_NO));\n        res =opU3(res, vec3(sdLlanta2,0.0,MATERIAL_NO));\n        res =opU3(res, vec3(sdLlanta2ch,1.0,MATERIAL_NO));\n    \n    //\n    p=porg;\n    float capo =   sdRoundBox( p-vec3(0.0,0.0,5.0), vec3(5.0,3.0,5.0), 0.5 );\n    float capob =  sdRoundBox( p-vec3(0.0,0.0,4.5), vec3(3.0,2.0,5.0), 0.5 );\n    float toldo =  sdRoundBox( p-vec3(0.0,5.0,15.0), vec3(8.0,4.0,6.0), 0.5 );\n    float ventana1 =sdRoundBox( p-vec3(0.0,5.0,15.0), vec3(8.5,3.0,4.0), 0.5 );\n    \n    p.xz= rotatev2(p.xz, radians(90.0));\n    float ventana2 = sdTriPrism(p-vec3(-8.0,5.0,0.0), vec2(3.0,7.5) );\n        res =opU3(res, vec3(capo,1.0,MATERIAL_NO));\n        res =opU3(res, vec3(capob,3.0,MATERIAL_NO));\n        res =opU3(res, vec3(toldo,5.0,MATERIAL_NO));\n        res =opU3(res, vec3(ventana1,4.0,MATERIAL_NO));\n        res =opU3(res, vec3(ventana2,4.0,MATERIAL_NO));\n        \n        \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(t); break; }\n        \n        if(t>MAX_DIST)\n        { mObj.hitbln = false;    minDist = t;    break; } \n        \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n    vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n///============================================================\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ \n   \n    vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n    \n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    \n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    \n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n    \n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n            \n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    //lin = pow(lin,vec3(0.4545));\n     lin = pow (max (lin, 0.), vec3 (0.4545)); //Shane\n    return lin;\n    \n    \n}\n///============================================================\n\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    \n    return col;\n}\n\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n    \n  \n    \n}\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    \n     //if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p ;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n         \n         \n        vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    \n        col= result;\n    }\n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,\n        1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c)\n    );\n    \n    //1.055 * pow(c, vec3(1.0/2.4)) - 0.055,\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 10.0, 0.0 ); light_color2 =vec3( 1.0 ); \n    light_pos3= vec3( 0.0, 10.0, 10.0 ); light_color3 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0+5.0*abs(sin(iTime)),-25.0);\n   //ro= getMouse(ro);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlB3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 557, 557, 578], [579, 579, 611, 611, 695], [696, 696, 742, 742, 829], [830, 830, 864, 864, 926], [927, 927, 966, 966, 1061], [1062, 1062, 1101, 1101, 1196], [1197, 1197, 1236, 1236, 1331], [1334, 1399, 1433, 1433, 1531], [1532, 1532, 1566, 1566, 1658], [1659, 1659, 1693, 1693, 1785], [1786, 1826, 1860, 1860, 1957], [1960, 1960, 2014, 2014, 2116], [2118, 2118, 2154, 2154, 2237], [2239, 2279, 2304, 2304, 5214], [5216, 5267, 5291, 5291, 5479], [5482, 5482, 5531, 5531, 6220], [6222, 6326, 6362, 6362, 6567], [6568, 6639, 6663, 6663, 6918], [6919, 6973, 7009, 7009, 7256], [7377, 7377, 7404, 7404, 7421], [7423, 7423, 7459, 7459, 7551], [7552, 7552, 7598, 7598, 7743], [7745, 7745, 7819, 7819, 9476], [9543, 9577, 9657, 9657, 9789], [9833, 9881, 9909, 9909, 10104], [10108, 10159, 10206, 10206, 10947], [11002, 11002, 11095, 11095, 11441], [11444, 11444, 11475, 11475, 12047], [12049, 12098, 12124, 12124, 12298], [12300, 12300, 12358, 12358, 12410], [12412, 12461, 12518, 12518, 13140]], "test": "untested"}
{"id": "flB3Wt", "name": "Mandelbrot set zoom by swiiz", "author": "Swiiz", "description": "Mandelbrot set visualization", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 224, "published": 3, "date": "1624911206", "time_retrieved": "2024-07-30T19:13:28.604304", "image_code": "const vec4 colorPalette = -vec4(0,23,21,0);\nconst vec4 finalColor = vec4(.0);\nconst int hueModulus = 30;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = exp(-iTime/10.0)*5.0;\n    int recursion = int(iTime*iTime*8.0) + 50, i = 0;\n    vec2 c = (fragCoord / iResolution.x - 0.5) * -zoom + -iMouse.xy/iResolution.xy, z = c;\n    for(; i <= recursion && length(z) <= 2. ; i++ ) z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n    fragColor =  i - 1 == recursion ? finalColor : .6 + .6 * cos( 6.3 *  (float((i - 1) % hueModulus) / float(hueModulus)) + colorPalette);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3Wt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftSGWt", "name": "Sun Tracks", "author": "DrNoob", "description": "Inspired by this long exposure photograph by Martin Cann:\nhttps://twitter.com/MartinCann1/status/1408139994972278788", "tags": ["noise", "fbm", "oklab"], "likes": 44, "viewed": 1174, "published": 3, "date": "1624909848", "time_retrieved": "2024-07-30T19:13:29.416134", "image_code": "// Author: Thomas Stehle\n// Title: Sun Tracks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by this long exposure photograph by Martin Cann:\n// https://twitter.com/MartinCann1/status/1408139994972278788\n\n// Constants\nconst vec3 INNER = vec3(131, 118, 117) / 255.0;\nconst vec3 OUTER = vec3(  1,  34,  46) / 255.0;\nconst vec3 SUN   = vec3(224, 229, 180) / 255.0;\nconst vec3 GLOW  = vec3(247, 251, 238) / 255.0;\n\nconst int NLINES     = 100;\nconst float NLINES_F = float(NLINES);\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// 2D value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash21(i);\n    float b = hash21(i + vec2(1.0, 0.0));\n    float c = hash21(i + vec2(0.0, 1.0));\n    float d = hash21(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation (smoothstep without clamping)\n    vec2 u = f*f * (3.0 - 2.0*f);\n\n    // Mix 4 coorners\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// 2D Fractional Brownian motion based on value noise by Morgan McGuire\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vfbm(in vec2 p) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    const int NOCTAVES = 5;\n    for (int i = 0; i < NOCTAVES; ++i) {\n        v += a * vnoise(p);\n        p = rot * p * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// OKLAB-based color mixing by iq\n// https://www.shadertoy.com/view/ttcyRS\nvec3 oklab_mix( vec3 colA, vec3 colB, float h ) {\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(\n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lmsA = pow( kCONEtoLMS*colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS*colB, vec3(1.0/3.0) );\n    \n    // lerp\n    vec3 lms = mix( lmsA, lmsB, h );\n    \n    // gain in the middle (no oaklab anymore, but looks better?)\n    // lms *= 1.0+0.2*h*(1.0-h);\n    \n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\n\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec2 distort(in vec2 p) {\n    vec2 q = 0.8 * p + vec2(-0.2, 0.2);\n    float amp = -0.4;\n    float freq = 1.0 + 4.0 * q.y;\n    float phase = 0.0;\n    return vec2(q.x, q.y + amp * sin(freq * q.x + phase));\n}\n\nfloat suntracks(in vec2 p) {\n    vec2 st = vec2(p.x, p.y * NLINES_F);\n    st.y = max(st.y, 0.1 * NLINES_F);\n    st.y = min(st.y, 0.55 * NLINES_F);\n    \n    vec2 gv = vec2(st.x, fract(st.y));\n    float id = floor(st.y);\n    int idx = int(id);\n    \n    float r1 = hash(13.1 * float(idx));\n    float r2 = hash(37.3 * float(idx));\n    \n    float speed = 0.25 + 0.25 * r2;\n    \n    const float W = 0.25;\n    float d = sdOrientedBox(gv, vec2(-1.0, 0.5), vec2(2.0, 0.5), W);\n    float n = vfbm(vec2(30.0 * (gv.x + id) - speed * iTime, 0.0));\n    d += 0.25 * r2 + smoothstep(0.55, 0.65, n);\n\n    return d;\n}\n\nfloat foreground(in vec2 p) {\n    vec2 q = vec2(p.x, p.y + 0.2 * vfbm(10.0 * p));\n    const float W = 0.25;\n    return sdOrientedBox(q, vec2(-1.0, 0.0), vec2(2.0, 0.0), W);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Coordinate normalization\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    uv.x *= ar;\n\n    // Background\n    float bg = pow(10.0 * length(0.15 * uv - vec2(0.075, 0.1)), 1.5);\n    vec3 col = oklab_mix(INNER, OUTER, clamp(bg, 0.0, 1.0));\n    \n    // Foreground\n    float fgd = foreground(uv);\n    fgd = smoothstep(0.15, 0.1, fgd);\n    col = mix(col, vec3(0.05), fgd);\n    \n    // Distort\n    vec2 p = distort(uv);\n    \n    // Fade out factors\n    float fade = smoothstep(0.75, 0.25, length(p - vec2(0.5))); // Fade out to the sides\n    \n    // Sun tracks\n    float td = suntracks(p);\n    td  = smoothstep(0.5, -0.5, td) * fade;\n    td *= smoothstep(0.05, 0.2, uv.y); // Additional fade out near bottom\n    col = mix(col, SUN, clamp(td, 0.0, 1.0));\n    \n    // Gas tracks\n    float n = vfbm(2.0 * p - vec2(0.15 * iTime, 0.0));\n    n *= (1.0 - fgd);\n    col = oklab_mix(col, SUN, pow(n, 3.0));\n    \n    // Glow\n    float gl = vnoise(2.0 + sin(1.5 * iTime) * p);\n    gl  = pow(gl, 2.0) * fade;\n    gl *= smoothstep(0.7, 0.4, p.y) * smoothstep(-0.1, 0.2, p.y); // Additional fade in sun space\n    gl *= smoothstep(0.05, 0.2, uv.y); // Additional fade in screen space\n    col = mix(col, GLOW, clamp(gl, 0.0, 1.0));\n    \n    // Add animated noise\n    float r = hash31(vec3(fragCoord.xy, fract(0.001 * iTime)));\n    col.rgb += 0.1 * vec3(r - 0.5);\n    \n    // Vignetting\n    // https://www.shadertoy.com/view/lsKSWR\n    vec2 st = uv * (vec2(1.0, ar) - uv.yx);\n    float vig = st.x * st.y * 10.0;\n    col *= pow(vig, 0.2);\n    \n    // Final color\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSGWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[532, 614, 638, 638, 721], [723, 805, 830, 830, 948], [950, 974, 999, 999, 1102], [1104, 1181, 1206, 1206, 1660], [1662, 1775, 1798, 1798, 2135], [2137, 2212, 2261, 2308, 3081], [3083, 3083, 3147, 3147, 3360], [3362, 3362, 3387, 3387, 3567], [3569, 3569, 3597, 3597, 4168], [4170, 4170, 4199, 4199, 4344], [4346, 4346, 4401, 4433, 6025]], "test": "untested"}
{"id": "7t2GWc", "name": "IFS with Field of space", "author": "yasuo", "description": "IFS with Field of space", "tags": ["ifs"], "likes": 4, "viewed": 542, "published": 3, "date": "1624895212", "time_retrieved": "2024-07-30T19:13:30.255396", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n#define MATERIAL_DIFFUSE0 0\n#define MATERIAL_REFLECT 10\n\nconst float Epsilon = 1e-10;\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 combine(vec2 val1, vec2 val2, float k){\n    vec2 res1 = val1;\n    vec2 res2 = val2;\n    res1.x = smin(val2.x,val1.x,k);\n    res2.x = smin(val1.x,val2.x,k);\n    return (val1.x < val2.x)?res1:res2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                      dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                      dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n         +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                           max(p.y,max(q.z,q.x))),\n                           max(p.z,max(q.x,q.y))));\n}\n\nvec2 GetDist(vec3 p) {\n    float t = iTime*0.1;\n    \n    mat3 rot = matRotateZ(radians(-25.0)+t*2.0);\n    vec3 prevP = p*rot;\n\n    float d = 10000.0;\n    p.z = mod(p.z,5.)-2.5;\n    float maskd = sdBox(p,vec3(3.0,3.0,5.0));\n    \n    p = prevP;\n    p.z+=iTime*5.0;\n    p.xy = mod(p.xy,9.)-4.5;\n    p.z = mod(p.z,8.)-4.;\n    \n    mat3 rot2 = matRotateX(radians(-25.0)+t)*matRotateY(radians(30.0)+t);\n    \n    for(float i = 1.; i<=5.; i++){\n        p = abs(p);\n        p -= (0.5)*i;\n        p *= rot2;\n        d = min(d,sdBoundingBox(p, vec3(1.9,1.9,2.),.05));\n    }\n    \n    d = max(maskd,d);\n    p = prevP;\n    d = max(sdBox(p,vec3(5.0,5.0,19.0)),d);\n    \n    vec2 res = vec2(d, MATERIAL_REFLECT);\n        \n    vec2 model = res;\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(rd,n);\n    vec3 col = r;\n    \n    float nn = cnoise(p.xy*3.0);\n    col += nn*5.0;\n    float k = r.y*2.5+2.5;\n    col = mix(col*vec3(0.5),vec3(0.5),k);\n    return col;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 col) {\n    float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n    return vec3(dif)*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 3, -5.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    if(mod(iTime,20.0)<17.0){\n        ro.xz *= Rot(iTime*.1+1.0);\n    } else {\n        ro.xz *= Rot(radians(0.0));\n    }\n    \n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,-0.3,0), 1.5);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(0.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        \n        int mat = int(d.y);\n        if(mat == MATERIAL_DIFFUSE0){\n            col = diffuseMaterial(n,vec3(1.0));\n        } else if(mat == MATERIAL_REFLECT) {\n            col = reflectMaterial(p,rd,n);\n        }\n\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.3545) );\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2GWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[601, 690, 709, 709, 745], [746, 746, 767, 767, 804], [806, 806, 827, 827, 1904], [1906, 1906, 1947, 1947, 2038], [2040, 2040, 2084, 2084, 2242], [2244, 2244, 2275, 2275, 2362], [2364, 2364, 2389, 2389, 2408], [2409, 2409, 2456, 2456, 2829], [2831, 2831, 2853, 2853, 3577], [3579, 3579, 3624, 3624, 3884], [3886, 3886, 3910, 3910, 4111], [4113, 4113, 4160, 4160, 4350], [4352, 4352, 4394, 4394, 4589], [4591, 4591, 4631, 4631, 4714], [4716, 4716, 4773, 4773, 5741]], "test": "untested"}
{"id": "stjGWc", "name": "Basic Normal for Mat Cap", "author": "asus4", "description": "Basic Normal for Mat Cap", "tags": ["matcap"], "likes": 1, "viewed": 423, "published": 3, "date": "1624894099", "time_retrieved": "2024-07-30T19:13:31.190895", "image_code": "vec4 matcapSphere(vec2 uv)\n{\n    uv = (uv - 0.5) * 2.0;\n    vec3 n = vec3(uv, sqrt(1.0 - clamp(dot(uv, uv), 0.0, 1.0)));\n    // convert to color range\n    vec3 color = 0.5 + 0.5 * n;\n    return mix(vec4(0.5, 0.5, 1.0, 0.0), vec4(color, 1.0), smoothstep(1.01, 1.0, dot(uv, uv)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = matcapSphere(uv);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjGWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 280], [283, 283, 340, 340, 416]], "test": "untested"}
{"id": "Nt23Dc", "name": "shading with 1 random color", "author": "sympou", "description": "a simple way to get an unrealistic shading with 3 numbers input.\nsome results have a nice translucency feel :)", "tags": ["shadingpalette"], "likes": 19, "viewed": 456, "published": 3, "date": "1624885548", "time_retrieved": "2024-07-30T19:13:32.018682", "image_code": "const float gridSize = 75.;\nconst float sphereSize = 0.92;\nconst float speed = 10.;\n\n//https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 lightDir = normalize(vec3(cos(iTime)*0.25,0.5,sin(iTime)*0.25));\n    \n    //slowly panning coordinates\n    vec2 uv = (fragCoord+iTime*vec2(2.,1.)*speed)/gridSize;\n\n    //a square that contains the sphere\n    vec2 uv2 = (fract(uv)*2.-1.)/sphereSize;\n    \n    // a method to get sphere normals in orthographic projection\n    // (if d >= 1. then we are not touching the sphere)  \n    float d = dot(uv2,uv2);\n    float z = (d>=1.) ? 0. : sqrt(1.-d);\n    vec3 normals = vec3(uv2,z);\n    \n    //phong reflection model\n    float specular = pow(max(2.*z*dot(lightDir,normals) -lightDir.z, 0.0),20.)*0.25;\n    float diffuse = 0.5 + dot(normals,lightDir)*0.5;\n    \n    //here is the palette\n    vec2 seed = floor(uv);\n    vec3 rnd = hash32(seed);\n    vec3 col = min(mix(0.1/(1.-rnd),rnd.zxy,diffuse),1.);\n    //vec3 col = mix(min(0.1/(1.-rnd),1.),rnd.zxy,diffuse);\n    //vec3 col = mix(rnd*rnd*rnd,rnd.zxy,diffuse).yzx;\n    \n    //antialiasing\n    col *= min(15.*z*z,1.);\n    \n    // Output to screen\n    fragColor = vec4(col+specular,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt23Dc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 125, 146, 146, 282], [284, 284, 341, 341, 1388]], "test": "untested"}
{"id": "Nl23Dy", "name": "- Sphere Rotation -", "author": "Mihaha", "description": "...", "tags": ["2d", "3d", "sphere", "circle", "vignette", "rotation"], "likes": 1, "viewed": 251, "published": 3, "date": "1624874196", "time_retrieved": "2024-07-30T19:13:32.790618", "image_code": "/*\n\n> by MihasGames, 25.06.2021 <\n(https://mihas-games.itch.io/)\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.9);\n    float t = iTime*3.5;\n    \n    // Pixel Normalizations //\n    vec2 uv101 = fragCoord.xy/iResolution.xy,\n         uv = (uv101 - 0.5) * vec2(iResolution.x / iResolution.y, 1);\n   \n    float rotate_radius = (cos(t/7.)*0.5+0.5)*0.3 + 0.7; \n    vec2 sphere_position = vec2(sin(t)*0.55, cos(t)*0.2-0.04);\n    float sphere_size = ((cos(t)*0.5+0.5)*0.4*rotate_radius+0.6/rotate_radius)*0.45;\n    \n    if (sqrt(length( uv + sphere_position*rotate_radius )) < sphere_size) col = vec3(uv.xy/-3.+0.5, 1.);\n\n    // Vignette //\n    uv = uv101 * (1. - uv101);    \n    col *= pow(uv.x*uv.y * 25., 0.07);\n        \n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl23Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 127, 127, 785]], "test": "untested"}
{"id": "7lB3Dc", "name": "Reactive Voronoi Remastered v0.5", "author": "firebreathz", "description": "A remastered version of [url=https://www.shadertoy.com/view/Ml3GDX]Reactive Voronoi[/url]. Adds a better traversal inspired by tomkh's [url=https://www.shadertoy.com/view/4lyGDV]Voronoi Column Tracing[/url], stronger lighting, softer shadows and AO.", "tags": ["3d", "voronoi", "interactive", "reactive", "ao", "semisoftshadows"], "likes": 4, "viewed": 332, "published": 3, "date": "1624850842", "time_retrieved": "2024-07-30T19:13:33.795930", "image_code": "// Fork of \"Reactive Voronoi Remastered draf\" by firebreathz. https://shadertoy.com/view/7tS3D3\n// 2021-06-28 03:21:55\n\n// Fork of \"Reactive Voronoi Remastered\" by glk7. https://shadertoy.com/view/MtyGWK\n// 2021-06-27 21:09:21\n\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float PI = 30.1416;\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n                          dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//Derived from https://iquilezles.org/articles/voronoilines\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 1.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 1.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 80.0;\n    vec2 ml = vec2(0.0);\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = .1 + 0.1*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(r-mr,r-mr)>0.00001 ) {\n            vec2 l = normalize(r-mr);\n            float d = dot( 0.05*(mr+r), l );\n            if (md > d) { \n        \t\tmd = d;\n                ml = l;\n            }\n        }           \n    }\n\n    return vec3(md, ml);\n}\n\n\n\nvoid voronoi_s(in vec2 x, inout vec2 n,  inout vec2 f, \n                          inout vec2 mg, inout vec2 mr) {\n\n    n = floor(x);\n    f = fract(x);\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if (d < md) {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }   \n}\n\nvec3 voronoi_n(inout vec2 rd, inout vec2 n,  inout vec2 f, \n                              inout vec2 mg, inout vec2 mr) {\n    float md = 1e5;\n    vec2 mmg = mg;\n    vec2 mmr = mr;\n    vec2 ml = vec2(0.0);\n    \n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {   \n        vec2 g = mmg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n    \tvec2 l = r-mmr;\n \t\tif((dot(l, l) * dot(rd, l)) > 1e-5) {\n            float d = dot(0.5*(mmr+r), l)/dot(rd, l);\n            if (d < md) {\n                md = d;\n                mg = g;\n                mr = r;\n                ml = l;\n            }\n        }\n    }\n    \n    return vec3(md, ml);\n}\n\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, \n               out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n \n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    vec3 n1 = -(1.0 - smoothstep(0.0, 0.03, p - bmin));\n    vec3 n2 = (1.0 -  smoothstep(0.0, 0.03, bmax - p));\n    \n    return normalize(n1 + n2);\n}\n\nconst vec3 background = vec3(0.04);\nconst vec3 scmin = -vec3(1.77, 1.0, 1.77);\nconst vec3 scmax = vec3(1.77, 1.5, 1.77);\n\n\nfloat map(in vec2 p) {\n    vec2 h = exp(-(p*p*0.5));\n    return scmin.y + 0.1 + hash2(p).x * 0.5 \n        + texture(iChannel0, vec2(hash2(p).x, 0.0)).r*2.0 + h.x*h.y*0.5;\n}\n\n// From https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(vec2 p) {\n    return 1.5 *\n           pal(3.434+(hash2(p).x*0.02), vec3(0.5,0.5,0.5), \n                                        vec3(0.5,0.5,0.5),\n                                        vec3(1.0,0.7,0.4),\n                                        vec3(0.000,0.000,1.0)  );\n}\n\nfloat voronoi_ao(in float h, inout vec2 n, inout vec2 f, inout vec2 mg) {\n    float a = 0.0;\n    \n    for (int j = -1; j <= 1; ++j)\n    for (int i = -1; i <= 1; ++i) \n    {\n    \tvec2 g = mg + vec2(float(i), float(j));\n        a += max(0.0, map(n + g) - h);\n    }\n    \n    return exp(-a*0.5) + 0.2;\n    return max(0.0, 1.0 - a*0.2) + 0.2;\n}\n\nvec2 ShadowAndAmbient(in vec3 ro, in vec3 rd) {\n    vec3 p0 = vec3(0.0), p1 = vec3(0.0);\n    \n    IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1);\n    \n    if (length(ro - p1) < 0.01) return vec2(1.0);\n    \n    p0 = ro + rd*0.01;\n    vec2 dir = normalize(rd.xz);\n    float s = rd.y / length(rd.xz);\n    \n    vec2 mg = vec2(0.0), mr = vec2(0.0), n = vec2(0.0), f = vec2(0.0);\n    voronoi_s(p0.xz*2.0, n, f, mg, mr);\n    \n    float h = map(n + mg);\n    \n    float a = voronoi_ao(ro.y, n, f, mg);\n    vec3 dn = voronoi_n(dir, n, f, mg, mr);\n    \n    float rh = 0.0, prh = p0.y;\n    \n  \tfloat dmax = length(p0.xz - p1.xz);\n\tfloat mh = 1.0;\n    \n    const int steps = 20;\n    for (int i = steps; i > 0; --i) {\n        dn.x *= 0.1;\n        rh = p0.y + dn.x*s;\n       \n        if (dn.x > dmax || h > prh || h > rh) break; \n        \n        prh = rh;\n       \n        h = map(n + mg);\n        \n        mh = min(mh, 1.0*(rh-h)/(dn.x*s));\n        \n        dn = voronoi_n(dir, n, f, mg, mr);\n    }\n    \n    if (h > prh || h > rh) return vec2(0.0, a);\n    \n    return vec2(clamp(mh, 0.0, 1.0), a);\n}\n\nvec3 Shade(in vec3 p, in vec3 p0, in vec3 v, in vec3 n, in vec3 l, in vec2 c) {\n    vec3 col = color(c);\n    vec2 lc = vec2(max(0.0, dot(n,l))*0.9, 1.0);\n    \n    if (length(p - p0) < 0.01) return 1.0*col*(lc.x + lc.y)*.5;\n    \n    vec2 sa = ShadowAndAmbient(p + n*0.02, l);\n   \tlc *= sa;\n    return col*(lc.x + lc.y);\n}\n\nvec3 Render(in vec3 ro, in vec3 rd, in vec3 ld) {\n    vec3 p0 = vec3(0.0), p1 = vec3(0.0);\n    \n    if (!IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1)) return background;\n    \n    vec2 dir = normalize(rd.xz);\n    float s = rd.y / length(rd.xz);\n    \n    vec2 mg = vec2(0.0), mr = vec2(0.0), n = vec2(0.0), f = vec2(0.0);\n    voronoi_s(p0.xz*15.0, n, f, mg, mr);\n    \n    vec2 pmg = mg, pmr = mr;\n    float h = map(n + pmg);\n    \n    vec3 dn = voronoi_n(dir, n, f, mg, mr);\n    vec3 pdn = vec3(0.0, -AABoxNormal(scmin, scmax, p0).xz); \n    \n    float rh = 0.0, prh = p0.y;\n    \n  \tfloat dmax = length(p0.xz - p1.xz);\n\t\n    const int steps = 1000;\n    for (int i = steps; i > 0; --i) {\n        dn.x *= .05;\n        rh = p0.y + dn.x*s;\n        \n        if (dn.x > dmax || h > prh || h > rh) break; \n        \n        prh = rh;\n        \n        pmg = mg; pmr = mr;\n        h = map(n + pmg);\n        \n        pdn = dn;\n        dn = voronoi_n(dir, n, f, mg, mr);\n    }\n    \n    if (!(h > prh || h > rh)) return background;\n    \n    vec3 p = vec3(p0.xz + dir*pdn.x, p0.y + pdn.x*s).xzy;\n    vec3 nor = vec3(normalize(-pdn.yz), 0.0).xzy;\n    \n    if (h < prh) {\n    \tfloat dt = abs((p0.y - h)/s);\n        \n        if (dt > dmax) return background;\n        \n        p = vec3(p0.xz + dir*dt, h).xzy;\n        \n        vec3 v = voronoi(p.xz*2.0)*5.5;\n        nor = normalize(mix((vec3(normalize(v.yz), 0.0).xzy), \n                            vec3(0.0, 1.0, 0.0), smoothstep(0.0, 0.03, v.x)));\n    }\n    \n    return Shade(p, p0, rd, nor, ld, n + pmg);\n    \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, \n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, 0.0, -d);\n    \n    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));\n    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * (PI*2.0));\n    m.y = -m.y;\n    m.y = sin(m.y*0.5)*0.6 + 0.6;\n        \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    t = rotY * rotX;\n    \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    \n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(1.0, 1.0, -1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    \n    CameraOrbitRay(fragCoord, 1.0, vec3(0.0), 10.0, ro, rd, t);\n\tfragColor = vec4(pow(Render(ro, rd, LightDir(t)), vec3(0.9)), 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lB3Dc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[372, 372, 394, 425, 542], [544, 604, 631, 631, 1881], [1885, 1885, 1998, 1998, 2353], [2355, 2355, 2476, 2476, 3033], [3036, 3036, 3162, 3162, 3481], [3483, 3483, 3532, 3532, 3682], [3807, 3807, 3829, 3829, 3979], [3981, 4030, 4098, 4098, 4141], [4143, 4143, 4163, 4163, 4426], [4428, 4428, 4501, 4501, 4767], [4769, 4769, 4816, 4816, 5855], [5857, 5857, 5936, 5936, 6177], [6179, 6179, 6228, 6228, 7725], [7727, 7727, 7862, 7862, 8513], [8515, 8515, 8542, 8542, 8608], [8610, 8610, 8667, 8667, 8881]], "test": "untested"}
{"id": "slB3Ry", "name": "Cube Map [ Truchet Box ]", "author": "byt3_m3chanic", "description": "Overly complex spinning cube demo. mouseable", "tags": ["raymarching", "cubemap", "truchet", "tile"], "likes": 24, "viewed": 602, "published": 3, "date": "1624847469", "time_retrieved": "2024-07-30T19:13:34.547920", "image_code": "/** \n    Cube Map [ Truchet Box ]\n    6/27/21 @byt3_m3chanic\n    \n    playing with cube mapping on objects\n    using bmp and textures. mouseable\n    \n*/\n\nfloat offset[3] = float[]( 0.0, 1.35, 2.95 );\nfloat weight[3] = float[]( 0.2, 0.35, 0.075 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 C = texture(iChannel0, uv).rgb;\n    vec3 R = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n      R += texture(iChannel0, uv + vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n      R += texture(iChannel0, uv - vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n    }\n    \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*.32;\n    dt = smoothstep(0.82,.965,1.-dt);\n    vec3 Color = mix(R,C,dt);\n    \n    // output\n    Color=pow(Color, vec3(.4545));\n    fragColor = vec4(Color,1.);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .0001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\n//@iq\nfloat cap( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//@iq\nfloat vcap( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat modPolar(inout vec2 p, float rep) \n{\n    float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (rep/2.)) ? abs(c) : c;\n} \n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0);\nmat2 ria,gia,turn,spin;\n\nconst float sz = 3.;\nconst float hf = sz*.5;\n\nvec2 map(vec3 pos, float sg)\n{\n    vec2 res = vec2(1e5,0.);\n    pos.y+=1.25;;\n    vec3 q = pos-vec3(0,2.5,0);\n    \n    vec3 b = pos-vec3(0,1.05,0);\n    \n    q.yx*=spin;\n    q.zx*=spin;\n\n    float d1 = box(q,vec3(1.5))-.0423;\n    if(d1<res.x){\n        res = vec2(d1,2.);\n        hit=q;\n    }\n\n    b.xz=abs(abs(abs(b.xz)-12.)-6.)-3.;\n    vec3 hitb = b;\n    \n    float pillar = cap(b,.3,1.5);\n    vec3 tb =vec3(b.x,abs(b.y),b.z);\n    float pcap = box(tb-vec3(0,1.45,0),vec3(.5,.15,.5))-.005;\n        pcap=min(cap(tb-vec3(0,1.3,0),.4,.05),pcap);\n    \n    modPolar(b.xz,16.);\n    vec3 bt = b-vec3(.3,-1.1,0);\n    \n    float grv = vcap(bt,2.2,.045);\n    pillar = max(pillar,-grv);\n    pillar = min(pcap,pillar);\n\n    if(pillar<res.x)\n    {\n        res = vec2(pillar*.75,3.);\n    \thit=hitb;\n    }\n\n    float ground =pos.y+.5;\n    if(ground<res.x){\n        res = vec2(ground,1.);\n        hit=pos;\n    }\n  \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += ray.x * .85;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\n// Tri-Planar blending function. GPU Gems 3 - Ryan Geiss:\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n    //return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nfloat sface;\nvec3 getFace(int face, vec3 p)\n{\n    float cir = 0.;\n    vec2 uv;\n    \n    if(face==0) uv=p.yz;\n    if(face==1) uv=p.zx;\n    if(face==2) uv=p.xy;\n    if(face==3) uv=p.xy;\n    if(face==4) uv=p.xz;\n    if(face==5) uv=p.zy;\n    uv*=2.;\n    \n    float px = fwidth(uv.x);\n    vec2 grid_uv = fract(uv)-.5;\n    vec2 grid_id = floor(uv);\n    \n    float chk = mod(grid_id.y + grid_id.x,2.) * 2. - 1.;\n    float hs = hash21(grid_id);\n    if(hs>.5) grid_uv.x*=-1.;\n    \n    vec2 d2 = vec2(length(grid_uv-.5), length(grid_uv+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid_uv-.5) : vec2(grid_uv+.5);\n\n    float circle = length(gx)-.5;\n    float circle2 =abs(circle)-.025;\n    circle2=smoothstep(.001+px,-px,circle2);\n    circle=(chk>0.^^ hs>.5)?smoothstep(-px,.001+px,circle):smoothstep(.001+px,-px,circle);\n\n    cir= mix(cir,.0,circle);\n    cir= mix(cir,1.,circle2);\n    sface=mix(0.,1.,circle);\n    return vec3(cir);\n}\n// based on bmp mapping from\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( vec3 p, vec3 n, float bf, float per, int face)\n{\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        getFace(face, p - e.xyy), \n        getFace(face, p - e.yxy), \n        getFace(face, p - e.yyx)\n    );\n    vec3 g = vec3(0.299, 0.587, 0.114) * m; \n    g = (g - dot(getFace(face, p), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);  \n    return normalize( n + g*bf );\n}\n\nvec4 FC = vec4(0.019,0.019,0.019,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,152, 1.);\n\n    hitPoint = hit;\n    gia=ria;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(3.,8,3.);\n        vec3 lpos2 =vec3(5.,5,-5.);\n        vec3 l = normalize(lpos-p);\n        vec3 l2 = normalize(lpos2-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint;\n        vec3 cuv;\n        int face;\n        vec3 tn = n;\n        vec3 cn = n;\n        if(m==2.){\n            tn = n;\n            tn.yx*=spin;\n            tn.zx*=spin;\n            //https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n            \n            // set coords\n            if(face==0) cuv = hp.xyz;\n            if(face==1) cuv = hp.xyz;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.zyx;\n            if(face==5) cuv = hp.xyz;\n       \n            // get bump map surface\n            n=doBumpMap( cuv, n, .05, d, face);\n        }\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float diff2 = clamp(dot(n,l2),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        float shdw2 = 1.0;\n        for( float t=.01; t < 12.; )\n        {\n            float h = map(p + l2*t,0.).x;\n            if( h<MIN_DIST ) { shdw2 = 0.; break; }\n            shdw2 = min(shdw2, 16.*h/t);\n            t += h;\n            if( shdw2<MIN_DIST || t>32. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.75);\n        diff2 = mix(diff2,diff2*shdw2,.75);\n        \n        vec3 diffMix =vec3(0);\n        diffMix = diff * vec3(0.502,0.290,0.000);\n        diffMix += diff2 * vec3(0.004,0.510,0.894);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n\n        // materials\n        if(m==1.){\n            h=tex3D(iChannel1,hitPoint*.1,n).rgb;\n            C = (diffMix*h);\n            ref = vec3(clamp(.35-fresnel-(d*.01),.01,1.));\n        }\n        if(m==2.){\n            h = mix(tex3D(iChannel0,cuv*.5,tn).rgb, tex3D(iChannel1,cuv*.5,tn).rgb ,sface);\n            C = (diffMix*h)+spec;\n            ref = vec3(clamp(sface-fresnel,.01,.9));\n        }\n        if(m==3.){\n            h=clamp(tex3D(iChannel2,hitPoint*.1,tn).rrr+.5+fresnel,vec3(0),vec3(.8));//vec3(.2);\n            C = (diffMix*h);\n            ref = clamp((h-fresnel)-.5,vec3(0),vec3(1));\n        }\n        \n        C = mix(FC.rgb,C,exp(-.00015*d*d*d));\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    } else {\n        if(last) C = mix(FC.rgb,C,exp(-.000015*d*d*d));\n    }\n    C = clamp(C,vec3(0),vec3(1));\n    return vec4(C,alpha);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    float timer = T*05.*PI/180.;\n    turn = rot(timer);\n    spin = rot(T*25.*PI/180.);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,7.75);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    //mouse\n    float x = M.xy == vec2(0) ? .75: -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1. - .5) * PI;\n    if(x<-.15)x=-.15;\n    mat2 rx = rot(x);\n    mat2 ry = rot(y+timer);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    // reflection loop (@BigWings)\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 2.;\n    // 3 is pretty but slows down \n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) FC = vec4(FC.rgb,exp(-.000075*d*d*d));\n    }\n \n    C = mix(C,FC.rgb,1.-FC.w);\n    // gamma\n    C = clamp(C,vec3(0),vec3(1));\n    O = vec4(C,1.0);\n}\n\n\n", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slB3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 248, 305, 305, 899]], "test": "untested"}
{"id": "7tS3D3", "name": "Reactive Voronoi Remastered draf", "author": "firebreathz", "description": "A remastered version of [url=https://www.shadertoy.com/view/Ml3GDX]Reactive Voronoi[/url]. Adds a better traversal inspired by tomkh's [url=https://www.shadertoy.com/view/4lyGDV]Voronoi Column Tracing[/url], stronger lighting, softer shadows and AO.", "tags": ["3d", "voronoi", "interactive", "reactive", "ao", "semisoftshadows"], "likes": 2, "viewed": 298, "published": 3, "date": "1624829627", "time_retrieved": "2024-07-30T19:13:35.674907", "image_code": "// Fork of \"Reactive Voronoi Remastered\" by glk7. https://shadertoy.com/view/MtyGWK\n// 2021-06-27 21:09:21\n\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n\nconst float PI = 3.1416;\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),\n                          dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//Derived from https://iquilezles.org/articles/voronoilines\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 1.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 1.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 80.0;\n    vec2 ml = vec2(0.0);\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = .1 + 0.1*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(r-mr,r-mr)>0.00001 ) {\n            vec2 l = normalize(r-mr);\n            float d = dot( 0.05*(mr+r), l );\n            if (md > d) { \n        \t\tmd = d;\n                ml = l;\n            }\n        }           \n    }\n\n    return vec3(md, ml);\n}\n\n\n\nvoid voronoi_s(in vec2 x, inout vec2 n,  inout vec2 f, \n                          inout vec2 mg, inout vec2 mr) {\n\n    n = floor(x);\n    f = fract(x);\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if (d < md) {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }   \n}\n\nvec3 voronoi_n(inout vec2 rd, inout vec2 n,  inout vec2 f, \n                              inout vec2 mg, inout vec2 mr) {\n    float md = 1e5;\n    vec2 mmg = mg;\n    vec2 mmr = mr;\n    vec2 ml = vec2(0.0);\n    \n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {   \n        vec2 g = mmg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n    \tvec2 l = r-mmr;\n \t\tif((dot(l, l) * dot(rd, l)) > 1e-5) {\n            float d = dot(0.5*(mmr+r), l)/dot(rd, l);\n            if (d < md) {\n                md = d;\n                mg = g;\n                mr = r;\n                ml = l;\n            }\n        }\n    }\n    \n    return vec3(md, ml);\n}\n\n\nbool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, \n               out vec3 p0, out vec3 p1) \n{\n    vec3 t0 = (bmin - ro) * invrd;\n    vec3 t1 = (bmax - ro) * invrd;\n\n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(max(tmin.x, tmin.y), tmin.z);\n    float fmax = min(min(tmax.x, tmax.y), tmax.z);\n    \n    p0 = ro + rd*fmin;\n    p1 = ro + rd*fmax;\n \n    return fmax >= fmin;   \n}\n\nvec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) \n{\n    vec3 n1 = -(1.0 - smoothstep(0.0, 0.03, p - bmin));\n    vec3 n2 = (1.0 -  smoothstep(0.0, 0.03, bmax - p));\n    \n    return normalize(n1 + n2);\n}\n\nconst vec3 background = vec3(0.04);\nconst vec3 scmin = -vec3(1.77, 1.0, 1.77);\nconst vec3 scmax = vec3(1.77, 1.5, 1.77);\n\n\nfloat map(in vec2 p) {\n    vec2 h = exp(-(p*p*0.5));\n    return scmin.y + 0.1 + hash2(p).x * 0.5 \n        + texture(iChannel0, vec2(hash2(p).x, 0.0)).r*2.0 + h.x*h.y*0.5;\n}\n\n// From https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(vec2 p) {\n    return 1.5 *\n           pal(3.434+(hash2(p).x*0.02), vec3(0.5,0.5,0.5), \n                                        vec3(0.5,0.5,0.5),\n                                        vec3(1.0,0.7,0.4),\n                                        vec3(0.0,0.15,0.20)  );\n}\n\nfloat voronoi_ao(in float h, inout vec2 n, inout vec2 f, inout vec2 mg) {\n    float a = 0.0;\n    \n    for (int j = -1; j <= 1; ++j)\n    for (int i = -1; i <= 1; ++i) \n    {\n    \tvec2 g = mg + vec2(float(i), float(j));\n        a += max(0.0, map(n + g) - h);\n    }\n    \n    return exp(-a*0.5) + 0.2;\n    return max(0.0, 1.0 - a*0.2) + 0.2;\n}\n\nvec2 ShadowAndAmbient(in vec3 ro, in vec3 rd) {\n    vec3 p0 = vec3(0.0), p1 = vec3(0.0);\n    \n    IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1);\n    \n    if (length(ro - p1) < 0.01) return vec2(1.0);\n    \n    p0 = ro + rd*0.01;\n    vec2 dir = normalize(rd.xz);\n    float s = rd.y / length(rd.xz);\n    \n    vec2 mg = vec2(0.0), mr = vec2(0.0), n = vec2(0.0), f = vec2(0.0);\n    voronoi_s(p0.xz*2.0, n, f, mg, mr);\n    \n    float h = map(n + mg);\n    \n    float a = voronoi_ao(ro.y, n, f, mg);\n    vec3 dn = voronoi_n(dir, n, f, mg, mr);\n    \n    float rh = 0.0, prh = p0.y;\n    \n  \tfloat dmax = length(p0.xz - p1.xz);\n\tfloat mh = 1.0;\n    \n    const int steps = 8;\n    for (int i = steps; i > 0; --i) {\n        dn.x *= 0.01;\n        rh = p0.y + dn.x*s;\n       \n        if (dn.x > dmax || h > prh || h > rh) break; \n        \n        prh = rh;\n       \n        h = map(n + mg);\n        \n        mh = min(mh, 14.0*(rh-h)/(dn.x*s));\n        \n        dn = voronoi_n(dir, n, f, mg, mr);\n    }\n    \n    if (h > prh || h > rh) return vec2(0.0, a);\n    \n    return vec2(clamp(mh, 0.0, 1.0), a);\n}\n\nvec3 Shade(in vec3 p, in vec3 p0, in vec3 v, in vec3 n, in vec3 l, in vec2 c) {\n    vec3 col = color(c);\n    vec2 lc = vec2(max(0.0, dot(n,l))*0.9, 1.0);\n    \n    if (length(p - p0) < 0.01) return 3.0*col*(lc.x + lc.y)*0.5;\n    \n    vec2 sa = ShadowAndAmbient(p + n*0.02, l);\n   \tlc *= sa;\n    return col*(lc.x + lc.y);\n}\n\nvec3 Render(in vec3 ro, in vec3 rd, in vec3 ld) {\n    vec3 p0 = vec3(0.0), p1 = vec3(0.0);\n    \n    if (!IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1)) return background;\n    \n    vec2 dir = normalize(rd.xz);\n    float s = rd.y / length(rd.xz);\n    \n    vec2 mg = vec2(0.0), mr = vec2(0.0), n = vec2(0.0), f = vec2(0.0);\n    voronoi_s(p0.xz*8.0, n, f, mg, mr);\n    \n    vec2 pmg = mg, pmr = mr;\n    float h = map(n + pmg);\n    \n    vec3 dn = voronoi_n(dir, n, f, mg, mr);\n    vec3 pdn = vec3(0.0, -AABoxNormal(scmin, scmax, p0).xz); \n    \n    float rh = 0.0, prh = p0.y;\n    \n  \tfloat dmax = length(p0.xz - p1.xz);\n\t\n    const int steps = 1000;\n    for (int i = steps; i > 0; --i) {\n        dn.x *= 0.2;\n        rh = p0.y + dn.x*s;\n        \n        if (dn.x > dmax || h > prh || h > rh) break; \n        \n        prh = rh;\n        \n        pmg = mg; pmr = mr;\n        h = map(n + pmg);\n        \n        pdn = dn;\n        dn = voronoi_n(dir, n, f, mg, mr);\n    }\n    \n    if (!(h > prh || h > rh)) return background;\n    \n    vec3 p = vec3(p0.xz + dir*pdn.x, p0.y + pdn.x*s).xzy;\n    vec3 nor = vec3(normalize(-pdn.yz), 0.0).xzy;\n    \n    if (h < prh) {\n    \tfloat dt = abs((p0.y - h)/s);\n        \n        if (dt > dmax) return background;\n        \n        p = vec3(p0.xz + dir*dt, h).xzy;\n        \n        vec3 v = voronoi(p.xz*2.0)*0.5;\n        nor = normalize(mix((vec3(normalize(v.yz), 0.0).xzy), \n                            vec3(0.0, 1.0, 0.0), smoothstep(0.0, 0.03, v.x)));\n    }\n    \n    return Shade(p, p0, rd, nor, ld, n + pmg);\n    \n}\n\nvoid CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, \n                    out vec3 ro, out vec3 rd, out mat3 t) \n{\n    float a = 1.0/max(iResolution.x, iResolution.y);\n    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));\n \n    ro = vec3(0.0, 0.0, -d);\n    \n    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));\n    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * (PI*2.0));\n    m.y = -m.y;\n    m.y = sin(m.y*0.5)*0.6 + 0.6;\n        \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    t = rotY * rotX;\n    \n    ro = t * ro;\n    ro = c + ro;\n\n    rd = t * rd;\n    \n    rd = normalize(rd);\n}\n\nvec3 LightDir(in mat3 t) \n{\n    vec3 l = normalize(vec3(1.0, 1.0, -1.0));\n    return t * l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    mat3 t = mat3(1.0);\n    \n    CameraOrbitRay(fragCoord, 1.0, vec3(0.0), 6.0, ro, rd, t);\n\tfragColor = vec4(pow(Render(ro, rd, LightDir(t)), vec3(0.5454)), 1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3D3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[251, 251, 273, 304, 421], [423, 483, 510, 510, 1760], [1764, 1764, 1877, 1877, 2232], [2234, 2234, 2355, 2355, 2912], [2915, 2915, 3041, 3041, 3360], [3362, 3362, 3411, 3411, 3561], [3686, 3686, 3708, 3708, 3858], [3860, 3909, 3977, 3977, 4020], [4022, 4022, 4042, 4042, 4303], [4305, 4305, 4378, 4378, 4644], [4646, 4646, 4693, 4693, 5733], [5735, 5735, 5814, 5814, 6056], [6058, 6058, 6107, 6107, 7603], [7605, 7605, 7740, 7740, 8391], [8393, 8393, 8420, 8420, 8486], [8488, 8488, 8545, 8545, 8761]], "test": "untested"}
{"id": "7lBGW3", "name": "Gooey KIFS fractal", "author": "mrange", "description": "License CC0: Gooey KIFS fractal\nThis weekend has been messing with 3D KIFS fractals\nI suppose it doesn't hurt with one more KIFS fractal on shadertoy", "tags": ["3d", "kifs"], "likes": 14, "viewed": 375, "published": 3, "date": "1624821117", "time_retrieved": "2024-07-30T19:13:36.704155", "image_code": "// License CC0: Gooey KIFS fractal\n// This weekend has been messing with 3D KIFS fractals\n// I suppose it doesn't hurt with one more KIFS fractal on shadertoy\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 50\n#define NORM_OFF        0.0001\n#define N(a)            normalize(vec3(sin(a), -cos(a),  0.0))\n\nconst vec3  std_gamma  = vec3(2.2);\nconst float smoothing  = 0.125*0.5;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\nvec3 refl(vec3 p, vec3 n) {\n  p -= n*pmin(0.0, dot(p, n), smoothing)*2.0;\n  return p;\n}\n\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat df(vec3 p) {\n  const float zf = 2.0-0.3;\n  const vec3 n0  = N((PI-acos(1.0/3.0))/2.0);\n  const vec3 n1 = vec3(n0.x, n0.yz*ROT(2.0*PI/3.0));\n  const vec3 n2 = vec3(n0.x, n0.yz*ROT(-2.0*PI/3.0));\n\n  float a  = TIME*0.1;\n  mat2 rxy = ROT(a);\n  mat2 ryz = ROT(a*sqrt(0.5));\n  float z = 1.0;\n  \n  float d = 1E6;\n\n  const int mid = 2;\n  const int end = 5;\n\n  for (int i = 0; i < mid; ++i) {\n    p.xy *= rxy;\n    p.yz *= ryz;\n  //  p = -pabs(p, smoothing); \n    p = refl(p, n2);\n    p = refl(p, n0);\n    p = refl(p, n1);\n    p.x -= 0.3;\n    p *= zf;\n    z *= zf;\n  }\n\n  for (int i = mid; i < end; ++i) {\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p = -pabs(p, smoothing); \n    p = refl(p, n2);\n//    p = refl(p, n0);\n    p = refl(p, n1);\n    p.x -= 0.3;\n    p *= zf;\n    z *= zf;\n    vec3 pp = p;\n    const float sz = 0.125;\n    mod2(pp.yz, vec2(sz*3.0));\n    float dd1 = length(pp) - sz*0.9;\n    float dd2 = torus(pp.zxy, sz*vec2(1.0, 0.1));\n    float dd = dd1;\n    dd = min(dd, dd2);\n    dd /= z;\n    \n    d = pmin(d, dd, smoothing/z);\n  }\n\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = vec3(1.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n\n  float sr    = 0.35;\n  float sd    = sphered(ro, rd, vec4(vec3(0.0), sr), t);\n\n  vec3 gcol   = sd*1.5*vec3(2.0, 1.0, 0.75)*1.0;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n  float ifade = 1.0-tanh_approx(1.25*ii);\n  float h     = fract(-1.0*length(pos)+0.1);\n  float s     = 0.25;\n  float v     = tanh_approx(0.4/(1.0+40.0*sd));\n  vec3 color  = hsv2rgb(vec3(h, s, v));\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);\n\n  float dm  = 4.0/ll2;\n  float dif = pow(max(dot(nor,ld),0.0),2.0)*dm;  \n  float spe = pow(max(dot(refl, ld), 0.), 20.);\n  float ao  = smoothstep(0.5, 0.1 , ii);\n  float l   = mix(0.2, 1.0, dif*sha*ao);\n\n  vec3 col = l*color + 2.0*spe*ao*exp(-20.0*sd)*sha;\n//  return vec3(ao);\n  return gcol+col*ifade;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME;\n  vec3 cam  = 1.5*vec3(1.0, 0.5, 0.0);\n  float rt  = TAU*TIME/20.0;;\n  cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);\n  cam.xz   *= ROT(sin(rt)*1.0-0.75);\n  vec3 la   = vec3(0.0);\n  vec3 dcam = normalize(la - cam);\n  vec3 ddcam= vec3(0.0);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGW3.jpg", "access": "api", "license": "cc0-1.0", "functions": [[655, 655, 683, 703, 779], [781, 834, 856, 856, 1025], [1027, 1027, 1063, 1063, 1296], [1298, 1298, 1337, 1337, 1426], [1428, 1428, 1467, 1467, 1496], [1498, 1498, 1534, 1534, 1622], [1624, 1624, 1652, 1652, 1680], [1682, 1682, 1709, 1709, 1769], [1771, 1771, 1829, 1829, 2310], [2312, 2312, 2341, 2341, 2406], [2408, 2408, 2444, 2444, 2538], [2540, 2540, 2558, 2558, 3590], [3592, 3592, 3640, 3640, 3835], [3837, 3837, 3860, 3860, 4068], [4070, 4070, 4138, 4138, 4417], [4419, 4419, 4450, 4450, 5593], [5595, 5595, 5626, 5626, 6112], [6114, 6114, 6169, 6169, 6360]], "test": "untested"}
{"id": "flBGDc", "name": "Smile Glitch", "author": "sorunokoe", "description": "This my tutorial project", "tags": ["tutorial"], "likes": 1, "viewed": 248, "published": 3, "date": "1624817309", "time_retrieved": "2024-07-30T19:13:37.597765", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\nfloat Smile(vec2 uv, vec3 col, vec2 position) {\n    float mask = Circle(uv, position, 0.3, 0.003);\n    mask -= Circle(uv, position-vec2(-0.1, -0.08), 0.05, 0.003);\n    \n    float leftEye = Circle(uv, position-vec2(0.1, -0.07), 0.05, 0.003);\n    leftEye -= Circle(uv, position-vec2(0.1, -0.06), 0.05, 0.003);\n    col *= leftEye;\n    mask -= leftEye;\n    \n    float smile = Circle(uv, position-vec2(0,0), 0.02, 0.003);\n    smile -= Circle(uv, position-vec2(0,-0.02), 0.02, 0.003);\n    col *= smile;\n    mask -= smile;\n    return mask;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.4, 0.5, 0.5);\n    col /= 0.6 + 0.4*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 position = vec2(0,0);\n    \n    position += vec2(0.5,0.5);\n    position *= cos(iTime/uv.x)*uv.x*0.1;\n    \n    float mask = Smile(uv, col, position);\n    vec3 col2 = col*mask;\n    col -= col2;\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 136], [137, 137, 184, 184, 671], [672, 672, 727, 777, 1239]], "test": "untested"}
{"id": "NtSGDc", "name": "Refractive Accumulation", "author": "michael0884", "description": "Made some improvements to this shader. Amazing idea NuSan!", "tags": ["translucency", "laser", "live", "chromab"], "likes": 44, "viewed": 1142, "published": 3, "date": "1624813070", "time_retrieved": "2024-07-30T19:13:38.581136", "image_code": "// Coded live during livecode.demozoo.org Release Party\n// on https://www.twitch.tv/psenough\n// comments have been added after the live and code is a bit cleanner\n// original file is here: https://lezanu.fr/LiveCode/RefractiveIndex.glsl\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col=texture(iChannel0, fragCoord.xy / iResolution.xy).xyz;\n  \n     \n  \n\tfragColor = vec4(tanh(6.0*col), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define time (iTime*0.1 + 5.0)\n\n// rotation function\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\n// Box SDF\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\n// capsule SDF\nfloat caps(vec3 p, vec3 p1, vec3 p2, float s) {\n  vec3 pa=p-p1;\n  vec3 pb=p2-p1;\n  float prog=dot(pa,pb)/dot(pb,pb);\n  prog=clamp(prog, 0., 1.);\n  return length(p1+pb*prog-p)-s;\n}\n\n// to switch between the 2 scenes\nint scene = 0;\n\n// first SDF function with the refractive geometry\nfloat map(vec3 p) {\n  \n  // sphere in cube\n  vec3 p2=p;\n  float t=time*0.1;\n  p2.yz *= rot(t);\n  p2.yx *= rot(t*1.3);\n  float d4 = max(box(p2, vec3(3)),1.2-length(p));\n  \n  // KIFS with spheres and cubes\n  vec3 pb = p;\n  float d2=10000.;\n  for(float i=0.; i<3.; ++i) {\n    float t=time*0.03 + i;\n    p.yz *= rot(t+i);\n    p.yx *= rot(t*1.3);\n    d2 = min(d2, length(p) - 0.47);\n    p=abs(p);\n    p-=0.9;\n  }\n  \n  \n  float d = box(p, vec3(0.4,0.4,0.4));\n  \n  d=min(d,d2);\n  //d=d2;\n    \n  if(scene==0) d=d4;\n  //d=d4;\n  \n  return d;\n}\n\n// we will have a maximum of 10 bounces of the laser\n#define pcount 10\nvec3 points[pcount];\nint pid=1;\n\nfloat atm=0.;\n// second SDF function with both refractive geometry and the laser geometry\nfloat map2(vec3 p) {\n  \n  // get refractive geometry\n  float d = map(p);\n  \n  // loop over laser's collisions, insert it into the SDF and accumulate laser's light\n  float d2=10000.;\n  for(int i=0; i<pid-1; ++i) {\n  \n    // one capsule per laser part\n    float d3 = caps(p, points[i], points[i+1], 0.01);\n    \n    // I use the smoothstep to have more contrast between lit and unlit part of the geometry\n    atm += 0.013/(0.05+abs(d3)) * smoothstep(4.,0.3,d3);\n    \n    d2=min(d2,d3);\n  }\n  \n  \n  return min(abs(d),d2);\n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot(sin(uv*452.714+uv.yx*547.524),vec2(352.887)));  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  // change scene every 10s\n  scene = int(mod(floor(time/10.),2.));\n  \n  // first raymarching to get the laser collisions\n  vec3 s2=vec3(10,0,0);\n  vec3 r2=normalize(vec3(-1,sin(float(time))*0.1,0));\n  \n  // get a random refractive index different per pixel\n  float ior = (rnd(uv+fract(iTime*.1))-0.5);\n  //ior = (fract(gl_FragCoord.y/3.)-.5);\n  float id=ior*2.;\n  // compute index of refraction associated color \n  vec3 diff=1.3-vec3(1.+id,0.45+abs(id),1.-id);\n      \n  vec3 p2=s2;\n  points[0]=p2;\n  pid=1;\n  float side=1.;\n  for(int i=0; i<60; ++i) {\n    // we use only refractive geometry SDF\n    float d=abs(map(p2));\n    if(d<0.001) {\n      // when laser collide with something, store the collision point into the list\n      points[pid] = p2;\n      pid+=1;\n      if(pid>=pcount-1) break;\n      \n      // and we compute the refracted direction\n      vec2 off=vec2(0.01,0);\n      vec3 n2=side*normalize(d-vec3(map(p2-off.xyy), map(p2-off.yxy), map(p2-off.yyx)));\n      //r2=reflect(r2,n2);\n      vec3 r3=refract(r2,n2,1.-side*(0.3 + 0.1*ior));\n      if(dot(r3,r3)<0.5) r3=reflect(r2,n2);\n      r2=r3;\n      side=-side;\n      d=0.1;\n    }\n    if(d>100.0) break;\n    p2+=r2*d;\n  }\n  points[pid]=p2+r2*1000.;\n  ++pid;\n  \n  // second raymarching, what we will see on screen\n  vec3 s=vec3(0,0,-10);\n  vec3 r=normalize(vec3(uv, 1));\n  \n  // dithering noise to eliminate some banding\n  float mumu = mix(rnd(-uv+fract(float(iFrame)*.1)),1.,0.9);\n  vec3 p=s;\n  float side2=1.;\n  for(int i=0; i<90; ++i) {\n    float d=abs(map2(p));\n    if(d<0.001) {\n      // collision, compute refracted direction\n      // we use same per-pixel color and index of refraction than laser's raymarch\n      // it's not 100% correct but hey, it looks good\n      vec2 off=vec2(0.01,0);\n      vec3 n=side2*normalize(d-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n      vec3 r3=refract(r,n,1.-side2*(0.3 + 0.1*ior));\n      if(dot(r3,r3)<0.5) r3=reflect(r,n);\n      r=r3;\n      \n      side2=-side2;\n      d=0.1;\n      //break;\n    }\n    if(d>100.0) break;\n    p+=r*d*mumu;\n  }\n    \n  vec3 col=vec3(0);\n  col += diff*atm;\n  \n  /*\n  // original shader was doing gamma here but in shadertoy we can do it in post-effect and it's better\n  col=smoothstep(0.01,0.9,col);\n  col=pow(col, vec3(0.4545));\n  */\n  \n  // use previous frame to have a feedback effect and try to reduce the noise a bit\n  vec4 prev=texture(iChannel0, fragCoord.xy / iResolution.xy);\n  prev.w*=0.98;\n  // you can try putting 0.95 instead for lot less noise but also more blurry image\n  vec4 col1 = vec4(prev.xyz*prev.w, prev.w) + vec4(col,1.0);\n  fragColor = vec4(col1.xyz/col1.w, col1.w);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSGDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 295, 295, 418]], "test": "untested"}
{"id": "NlS3Wc", "name": "Brmlab logo", "author": "lanikjo", "description": "logo of prague hackerspace brmlab", "tags": ["logo"], "likes": 1, "viewed": 234, "published": 3, "date": "1624810415", "time_retrieved": "2024-07-30T19:13:39.747019", "image_code": "//\n// GLSL Brmlab logo\n// Copyright (c) 2021 Jovan Lanik\n//\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nfloat doCircle(vec2 uv, float x, float y, float size) {\n    return floor(length(uv+vec2(x, y)) - size + 0.988);\n}\n\nfloat doRing(vec2 uv, float x, float y, float size, float thicc) {\n    float ring = length(uv+vec2(x, y)) - size;\n    ring = abs(ring) * thicc;\n    ring = floor(ring);\n    return ring;\n}\n\nfloat doBrm(vec2 uv, float x, float y, float size) {\n    float ringSize = 0.425;\n    float detailThicc = 80.0;\n\n    uv += vec2(x, y);\n    uv *= size;\n    \n    float ring = doRing(uv, 0.0, 0.0, ringSize, 40.0);\n    \n    float small = doRing(uv, 0.0, 0.0, ringSize - 0.1, detailThicc);\n    \n    small = max(small, 1.0 - doCircle(uv, 0.0, -0.33, 0.07));\n    small = min(small, doRing(uv, 0.0, -0.33, 0.07, detailThicc));\n    \n    small = max(small, 1.0 - doCircle(uv, 0.25, 0.21, 0.07));\n    small = min(small, doRing(uv, 0.25, 0.21, 0.07, detailThicc));\n    \n    small = max(small, 1.0 - doCircle(uv, -0.25, 0.21, 0.07));\n    small = min(small, doRing(uv, -0.25, 0.21, 0.07, detailThicc));\n    \n    small = max(small, doCircle(uv, 0.0, 0.0, ringSize - 0.1));\n    \n    vec2 boxV = uv * 1.0;\n    boxV = abs(boxV) * 1.0;\n    boxV -= 0.04;\n    boxV.x -= 0.04;\n    boxV = abs(boxV) * 80.0;\n    boxV = floor(boxV);\n    boxV.x = max(boxV.x, floor(abs(uv.y)*19.0));\n    boxV.y = max(boxV.y, floor(abs(uv.x)*12.0));\n    float box = min(boxV.x, boxV.y);\n \n    float put = min(ring, small);\n    put = min(put, box);\n    put = min(put, doRing(uv, 0.0, -0.16, 0.035, detailThicc));\n    put = min(put, doRing(uv, 0.15, -0.16, 0.035, detailThicc));\n    put = min(put, doRing(uv, -0.15, -0.16, 0.035, detailThicc));\n    \n    put = min(put, doRing(uv, 0.20, 0.05, 0.035, detailThicc));\n    put = min(put, doRing(uv, -0.20, 0.05, 0.035, detailThicc));\n    \n    put = min(put, doRing(uv, 0.08, 0.20, 0.035, detailThicc));\n    put = min(put, doRing(uv, -0.08, 0.20, 0.035, detailThicc));\n    \n    return put;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float var = (sin(iTime*20.0)+1.0)*0.01 + 1.0;\n    \n    float put = doBrm(uv, 0.0, 0.0, var);\n    \n    put = 1.0 - put;\n    fragColor = vec4(put, put, put, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3Wc.jpg", "access": "api", "license": "mit", "functions": [[1134, 1134, 1189, 1189, 1247], [1249, 1249, 1315, 1315, 1435], [1437, 1437, 1489, 1489, 3025], [3027, 3027, 3084, 3084, 3347]], "test": "untested"}
{"id": "sl23DV", "name": "Random sunday fractal", "author": "mrange", "description": "License CC0: Random sunday fractal\nResult after a bit of random coding on sunday\n", "tags": ["2d", "fractal"], "likes": 14, "viewed": 372, "published": 3, "date": "1624790667", "time_retrieved": "2024-07-30T19:13:40.727398", "image_code": "// License CC0: Random sunday fractal\n// Result after a bit of random coding on sunday\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n#define DOT2(x)         dot(x, x)\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat g_cd = 0.0;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat boxf(vec3 p, vec3 b, float e) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat df(vec3 p) {\n  float d = 1E6;\n  vec3 op = p;\n\n  const float zf = 2.0-0.1;\n  const vec3 nz = normalize(vec3(1.0, .0, -1.0));\n  const vec3 ny = normalize(vec3(1.0, -1., 0.0));\n  float z = 1.0;\n  const float rsm = 0.125*0.25;\n  float a = 124.7+TIME*TAU/173.0; \n  mat2 rxy = ROT(a);\n  mat2 ryz = ROT(a*sqrt(0.5));\n  \n  float off = 0.8; \n  vec3 cp = vec3(0.55, 0.5, 0.45);\n  float cd = 1E6;\n\n  const int mid   = 0; \n  const int upper = 7; \n  for (int i = 0; i < mid; ++i) {\n    cd = min(cd, length(p-cp));\n    z *= zf;\n    p *= zf;\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p  = pabs(p, rsm);\n    p -= nz*pmin(0.0, dot(p, nz), rsm)*2.0;\n    p -= ny*pmin(0.0, dot(p, ny), rsm)*2.0;\n\n    p -= vec3(off/zf, 0.0, 0.0);\n  }\n\n\n  for (int i = mid; i < upper; ++i) {\n    cd = min(cd, length(p-cp));\n    vec3 pp = p;\n    float dd4 = torus(pp.zxy, 0.5*vec2(1.0, 0.2));\n    float dd5 = boxf(pp, vec3(0.2), 0.00)-0.025;\n    float dd  = dd5;\n    dd = min(dd5, dd4);\n    dd  /= z;\n    \n    z *= zf;\n    p *= zf;\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p  = pabs(p, rsm);\n    p -= nz*pmin(0.0, dot(p, nz), rsm)*2.0;\n    p -= ny*pmin(0.0, dot(p, ny), rsm)*2.0;\n\n    p -= vec3(off/zf, 0.0, 0.0);\n    d = pmax(d, -(dd-0.1/z), 0.05/z);\n    \n    d = min(d, dd);\n  }\n\n  g_cd = cd;\n  return d;\n}\n\nfloat df(vec2 p) {\n  vec3 p3 = vec3(p, mix(0.0, 1.0, PCOS(TAU*TIME/331.0)));\n  p3.xz *= ROT(TAU*TIME/127.0);\n  p3.yz *= ROT(TAU*TIME/231.0);\n  const float z = 0.25;\n  p3 *= z;\n  return df(p3)/z;\n}\n\nfloat hf(vec2 p) {\n  float d = df(p);\n  float aa = 0.0125;\n  return -0.025*smoothstep(-aa, aa, -d);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = hf(p + e.xy) - hf(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = hf(p + e.yx) - hf(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p, vec2 q) {\n  vec2 ppp = p;\n  const float s = 1.0;\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = hf(p);\n  float cd   = g_cd;\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, mix(-3.0, -10.0, PCOS(TIME+PI*p.x)), 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  const vec3 lcol1 = sqrt(vec3(1.25, 1.35, 2.0).zxy*0.15);\n  const vec3 lcol2 = vec3(2.0, 1.55, 1.25).zyx*0.85;\n  vec3 lpow1 = 0.15*lcol1/DOT2(ld1);\n  vec3 lpow2 = 0.25*lcol2/DOT2(ld2);\n  vec3 dm = vec3(1.0)*tanh_approx(-h*50.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*pow(diff1, 4.0)*lpow1;\n  col += dm*pow(diff2, 4.0)*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, 40.0)*lcol1;\n  col += rm*pow(ref2, 40.0)*lcol2;\n  \n  float hue  = fract(0.85-0.5*PI*cd);\n  float sat  = clamp(0.85*PCOS(10.0*cd), 0.0, 1.0);\n  float vue  = 1.0-1.0*PCOS(8.0*cd);\n  vec3 hsv   = vec3(hue, sat, vue);\n  vec3 color = (1.0*hsv2rgb(hsv));\n\n  return p.x > 0.0 ? color : col ;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = color(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl23DV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[422, 422, 450, 470, 546], [548, 601, 623, 623, 792], [794, 794, 830, 830, 1063], [1065, 1065, 1092, 1092, 1179], [1181, 1181, 1212, 1212, 1277], [1280, 1280, 1317, 1317, 1599], [1601, 1601, 1640, 1640, 1729], [1731, 1731, 1770, 1770, 1799], [1801, 1801, 1837, 1837, 1925], [1927, 1927, 1955, 1955, 1983], [1985, 1985, 2003, 2003, 3253], [3255, 3255, 3273, 3273, 3451], [3453, 3453, 3471, 3471, 3554], [3556, 3556, 3577, 3577, 3767], [3769, 3769, 3797, 3797, 5197], [5199, 5199, 5254, 5254, 5441]], "test": "untested"}
{"id": "7lj3DV", "name": "livecode.demozoo launch, eimink", "author": "eimink", "description": "Version of shader done during livecode.demozoo launch party jamming. FFT and motion blur are not same as in the jam version.", "tags": ["sdf"], "likes": 4, "viewed": 296, "published": 3, "date": "1624789773", "time_retrieved": "2024-07-30T19:13:41.619013", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//HI EVERYONE!\n\n// Mercury SDF <3 - https://mercury.sexy/hg_sdf/\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0, 1)\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n#define M1 1.0\n#define M2 2.0\n#define M3 3.0\n\nvec3 glow = vec3(0);\n\nstruct SceneResult\n{\n  float d;\n  float cid;\n  float mid;\n};\n\nstruct MarchResult\n{\n  vec3 position;\n  vec3 normal;\n  SceneResult sres;\n};\n\nfloat ffts;\nfloat ffti = 0.;\nfloat time;\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// base from iq\nSceneResult opU(SceneResult d1, SceneResult d2)\n{\n    if (d1.d < d2.d)\n    {\n        return d1;\n    }\n    return d2;\n   // return (d1.d < d2.d) ? d1 : d2;\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nSceneResult scene(vec3 p) {\n  SceneResult r;\n  rot(p.xy,ffti*20.);\n  vec3 pp = abs(p);\n  for (int i = 0; i < 2; ++i)\n  {\n    pp = abs(pp) - vec3(4.,4.,5.);\n    rot(pp.xy,(time+20.*ffts)*.1);\n    rot(pp.yz,time*.1);\n  }\n  float c = pModPolar(pp.xz,5.);\n  pp -= vec3(5,0,0);\n  rot(pp.xz,ffti*2.);\n   \n  vec3 ppp = p;\n  float cc = pModPolar(ppp.xz,5.);\n  ppp -= vec3(5.,cc*3.,0.);\n  rot(ppp.yz,PI);\n  rot(ppp.xz, -time);\n  rot(ppp.xy,ffti*.20);\n    \n  SceneResult box;\n  box.d = sdBox(pp,vec3(2.,1.+ffts*20.,1))+noise(pp);\n  box.cid = c;\n  box.mid = M1;\n  \n  SceneResult tp;\n  tp.d = sdTriPrism(ppp,vec2(1.5+ffts*20.,.2));\n  tp.mid = M2;\n\n  vec3 pppp = abs(p);\n  for (int i = 0; i < 4; ++i)\n  {\n    pppp = abs(pppp) - vec3(3.,6.,9.);\n    rot(pp.xy, (time+texelFetch( iChannel0, ivec2(pp.x,0), 0 ).x));\n    //rot(pp.xy, (time+texture( texFFT, pp.x ).r*1));\n    rot(pp.yz, time*0.1);\n  }\n  \n  SceneResult tp2;\n  tp2.d = sdTriPrism(pppp,vec2(2.5+ffts*10.,.4));\n  tp2.mid = M3;\n\n  r = opU(opU(box,tp),tp2);\n  \n  glow += vec3(.8,.4,.2)*0.01/(0.01+abs(tp.d));\n  glow += vec3(.9,.2,.6)*0.01/(0.9+abs(box.d));\n  glow += vec3(.2,.4,.8)*0.01/(0.2+abs(tp2.d));\n  \n  return r;\n}\n\nvec3 calcNormal (in vec3 pos)\n{\n  vec2 e = vec2(0.0001,0.0);\n  return normalize(vec3(scene(pos+e.xyy).d-scene(pos-e.xyy).d,\n                        scene(pos+e.yxy).d-scene(pos-e.yxy).d,\n                        scene(pos+e.yyx).d-scene(pos-e.yyx).d));\n}\n\nMarchResult raymarch(in vec3 ro, in vec3 rd)\n{\n  vec3 p = ro+rd;\n  float s = .0;\n  float id = M1;\n  float t = 0.;\n  SceneResult d;\n  for (int i = 0; i < 100; ++i){\n    d = scene(p);\n    t += d.d;\n    p += rd*d.d;\n    s = float(i);\n    if (d.d < 0.01 || t > 100.) {\n      break;\n    }\n  }\n  MarchResult res;\n  res.position = p;\n  res.normal = calcNormal(p);\n  res.sres = d;\n  res.sres.d = t;\n  return res;\n}\n\nvec3 shade(MarchResult mr, vec3 rd, vec3 ld)\n{\n  float l = max(dot(mr.normal,ld),.0);\n  float a = max(dot(reflect(ld,mr.normal),rd),.0);\n  float s = pow(a,10.);\n  \n  float m = mod(mr.sres.cid,8.);\n  \n  vec3 col = vec3(.8,.4,.2);\n  if (mr.sres.mid == M1){\n    if (m < 1.)\n      col = vec3(.2,.6,.9);\n    else if (m < 2.)\n      col = vec3(.9,.6,.2)*.1;\n    else\n      col = vec3(.9,.2,.6)*.1;\n  }\n  else if (mr.sres.mid == M2)\n  {\n    col = vec3(.8,.2,.4);\n  }\n  else {\n    col = vec3(1.,.5,.5)*.25;\n  }\n  return l * col * .5 + s * (col * vec3(1.1,1.2,1.2))*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = iTime;\n  ffts = texelFetch( iChannel0, ivec2(85,.25), 0).x*.05; \n  ffti = iTime*.05+abs(texelFetch( iChannel0, ivec2(.1,.25), 0).x)*.01; \n  \n  vec3 cp = vec3(sin(10.*ffti)+10.,5.+sin(ffti),cos(20.*ffti)+20.);\n  vec3 ct = vec3(0);\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 q = -1.0+2.0*uv;\n  q.x *= iResolution.x/iResolution.y;\n  \n  vec3 cf = normalize(ct-cp);\n  vec3 cr = normalize(cross(vec3(0,1,0),cf));\n  vec3 cu = normalize(cross(cf,cr));\n  vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(90.0)));\n  vec3 ld = -rd;  \n  \n  \n  vec3 col = vec3(0);\n  \n  MarchResult m = raymarch(cp,rd);\n  if (m.sres.d < 100.)\n  {\n    col = shade(m,rd,ld);\n  }\n  \n  col += glow * .3;\n  fragColor = vec4(col,1.);\n  \n  \n}", "buffer_a_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufB = texelFetch(iChannel1,ivec2(fragCoord),0);\n    vec4 bufA = texelFetch(iChannel0,ivec2(fragCoord),0);\n    vec3 col;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n      // Hi rimina! Using your code here!\n  \n  /*vec4 pcol = vec4(0.0);\n  vec2 puv = vec2(20./iResolution.x, 20./iResolution.y);\n  vec4 mults = vec4(0.1531, 0.11245, 0.0918, 0.051);\n  pcol = texelFetch(iChannel1, ivec2(uv),0) * 0.1633;\n  pcol += texelFetch(iChannel1, ivec2(uv),0) * 0.1633;\n  for (int i = 0; i < 4; ++i)\n  {\n    pcol += texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * mults[i] +\n            texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * mults[i] +\n            texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * mults[i] +\n            texelFetch(iChannel1, ivec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x),0) * mults[i];\n  }\n  col += pcol.rgb;\n  col *= 0.35;\n  \n  col = mix(col, bufA.rgb,.5);//texelFetch(iChannel0, ivec2(uv),0).rgb,.5);\n  \n  col = smoothstep(-.1, 1., col);\n  \n  vec4 bufC = vec4(col,1);*/\n  \n  fragColor = mix(bufB,bufA,0.05);\n  //fragColor = bufC;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3DV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 117]], "test": "untested"}
{"id": "stjGDV", "name": "Subaru Impreza", "author": "DrLuke", "description": "My entry from the livecode.demozoo.org release party shader jam!\n\n", "tags": ["feedback", "livecoding", "jam", "livecode", "shaderjam"], "likes": 6, "viewed": 358, "published": 3, "date": "1624787248", "time_retrieved": "2024-07-30T19:13:42.419872", "image_code": "// This work is licensed under the Creative Commons Attribution 4.0 International License.\n// To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/\n//\n// TL;DR: Do whatever you want, just credit me as \"Vj Pyree\"!\n\n// v v v v v v v v v v v v v v v v v v\n//\n// ENABLE SOUND ON BUFFER A\n// FOR AUDIO REACTIVITY\n//\n// ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define BG vec3(0.9,0.05,0.3)\n#define PI 3.14159\n\nmat3 rot3(vec3 axis, float angle) { // 3D rotation along axis\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n\t\toc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n\t);\n}\n\nmat2 rot2(float angle) {  // 2D rotation\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat2(\n\t\tc, -s,\n\t\ts, c\n\t);\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 o;\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    o = c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n  return o;\n}\n\nvec4 sdCappedCylinder( vec3 p, float h, float r )\n{\n  //p = p.xzy;\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  vec3 c = vec3(p.x/h, p.y/r, p.z/h);\n  return vec4(min(max(d.x,d.y),0.0) + length(max(d,0.0)), c);\n}\n\nfloat sdTri( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvec3 shading(vec3 c)\n{\n  float mask = step(0.9, length(c.xz));\n  \n  // Topside\n  vec2 pe = c.xz;\n  pe.x = abs(pe.x);\n  #define EYEELLIPSE 0.4\n  pe.y *= EYEELLIPSE;\n  vec2 eyepos = vec2(0.3, 0.4*EYEELLIPSE);\n  float ffti = texture(iChannel1, vec2(0.3, 0.)).x*0.03;\n  float topmask = 1.-smoothstep(0.14+ffti, 0.15+ffti, length(pe-eyepos));\n  \n  float mouthangle = 0.55;\n  \n  float arg = atan(c.x, c.z);\n  float argfft = pow(texture(iChannel1, vec2(abs(arg)*0.3, 0.)).x*0.01, 0.5);\n  float ends = (1.-step(PI*(mouthangle+0.02), abs(arg)))*0.05;\n  float circle = step(0.65-ends-argfft, length(c.xz)) - step(0.75+ends+argfft, length(c.xz));\n  topmask = max(topmask, circle*step(PI*mouthangle, abs(arg)));\n  \n  mask = max(mask, topmask* step(0., +c.y));\n  \n  // Bottomside\n  vec2 pt = c.xz * vec2(-1.,1.) / (-ffti*40. +  .2);\n  arg = mod(atan(pt.x, pt.y)+(4.5/3.*PI), 2.*PI);\n  pt *= rot2(floor(arg/(PI*2./3.))*(PI*2./3.)-(0./3.*PI));\n  float botmask = (1.-smoothstep(-0.15, -0.14, sdTri(pt))) * smoothstep(-0.15, -0.14, sdTri(pt-vec2(0.,-sqrt(3.)*0.5)) );\n  \n  mask = max(mask, botmask* step(0., -c.y));\n  \n  \n  return vec3(mix(BG, vec3(0), mask));\n}\n\nvec4 dist(vec3 p)\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.xy.x, gl_FragCoord.y / iResolution.xy.y); // Regular UV\n  vec4 prevp = texture(iChannel0, uv);\n  // In the orginal bonzo shader I used an integrated FFT here to make it a bit more sound reactive\n  float ffti = 0.;//texture(texFFTIntegrated, vec2(0.3, 0.)).x; \n  mat3 rot1 = rot3(vec3(sin(iTime*0.0124*sqrt(3.) + uv.y*2.), 1, cos(iTime*0.24576*sqrt(2.))), iTime+uv.x*10. + ffti*0.4 + length(prevp*0.1));\n  mat3 rot2 = rot3(vec3(0,1,0), iTime*sqrt(2.)*0.1) * rot3(vec3(1,0,0), iTime*0.8 + ffti);\n  float mixfac = smoothstep(-0.1, 0.1, sin(iTime*0.2));\n  mat3 rot = (rot1 * (1.0 - mixfac)) + (rot2 * mixfac);\n  vec4 d = sdCappedCylinder(p*rot-vec3(0,0,0), 0.2, 0.03);\n  return d;\n}\n\nvec4 rm(vec3 ro, vec3 rd)\n{\n  float d = 0.;\n  vec3 c = vec3(0);\n  for(int i=0;i<100;i++)\n  {\n    vec3 p = ro + rd*d;\n    d += dist(p).x;\n    c = dist(p).yzw;\n    if(d>100.||d<0.01){break;}\n  }\n  return vec4(d, c);\n}\n\nfloat rm2(vec3 ro, vec3 rd)\n{\n  float d = 0.;\n  for(int i=0;i<15;i++)\n  {\n    vec3 p = ro + rd*d;\n    d += dist(p).x;\n    if(d>100.||d<0.01){break;}\n  }\n  return d;\n}\n\nvec2 uvcenterscale(vec2 uv, float scale) {\n  return (uv - 0.5) * scale + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(gl_FragCoord.x / iResolution.xy.x, gl_FragCoord.y / iResolution.xy.y); // Regular UV\n  vec2 uvc = uv - vec2(0.5);  // UV with origin in screen center\n  vec2 uv11 = uvc*2.; // Centered UV but going from -1 to 1 from edge to edge\n  vec2 uvca = uvc * vec2(iResolution.xy.x/iResolution.xy.y, 1); // Centered uv with aspect ratio compensation\n  vec2 uv11a = uv11 * vec2(iResolution.xy.x/iResolution.xy.y, 1); // Centered uv11 with aspect ratio compensation\n  \n  vec3 ro = vec3(0,sin(iTime*0.)*0.2,1); // Ray Origin/Camera\n  vec3 rd = normalize(vec3(uvca.x,uvca.y,-1.5)); // Ray Direction\n  \n  vec4 r = rm(ro,rd);  // Raymarching\n  float d = r.x;  // Distance field\n  vec3 c = r.yzw;  // Local coordinates on cylinder\n  \n  vec4 fft = texture(iChannel1, vec2(0.05, 0.));\n  float ffti = pow(fft.x, 0.5);\n  \n  // In the orginal bonzo shader I used an integrated FFT here to make it a bit more sound reactive\n  float ffts = -iTime*0.2;//texture(texFFTIntegrated, vec2(0.3, 0.)).x;\n  \n  vec4 prevp = texture(iChannel0, uv);\n  \n  vec4 prev = texture(iChannel0, uvcenterscale(uv, 0.99 - ffti*0.01) - (prevp.rb*rot2(atan(uv11.y, uv11.x)+PI*ffts))*0.003);\n  \n  vec3 cylcol = shading(c);\n  \n  float pillmask = step(10., d);\n  float pillmask_expanded = step(10., rm2(ro,rd));\n  \n  vec3 bgcol = mix(vec3(hsv2rgb(vec3(length(uv11*10.) + iTime*3., 0.7, 0.8))), BG, pillmask_expanded);\n  bgcol = mix(bgcol, prev.rgb, 0.99 * pillmask_expanded);\n  \n  \n  \n\tfragColor = vec4(mix(cylcol, bgcol, step(10., d)), 1.);\n  \n  //fragColor = vec4(pillmask, pillmask_expanded,ffti,0.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27695, "src": "https://soundcloud.com/raveselekts/a1-tommy-holohan-subaru", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjGDV.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[381, 381, 438, 488, 595]], "test": "untested"}
{"id": "7l2GWV", "name": "livecode.demozoo release party", "author": "z0rg", "description": "Yeah !", "tags": ["dnb", "demozoo"], "likes": 6, "viewed": 400, "published": 3, "date": "1624782438", "time_retrieved": "2024-07-30T19:13:43.343403", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).xyz,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define sat(a) clamp(a, 0.,1.)\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c,-s,s,c);}\n\nfloat _cir(vec2 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat _sph(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nvec3 getCam(vec2 uv, vec3 rd)\n{\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+(r*uv.x+u*uv.y)*5.*(.8+.5*sin(iTime)));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  //l = abs(l)-s*.25;\n return max(l.x, max(l.y, l.z)); \n}\n#define FFT(a) sat(texture(iChannel0, vec2(a, 0.)).x+.5)\n\nvec2 map(vec3 p)\n{\n  vec2 acc= vec2(1000.,-1.);\n  \n  float a = atan(p.y,p.x)+iTime;\n  acc = _min(acc,vec2(_sph(p, .5+.01*sin(a*5.)), 0.)); \n  p.xy *= r2d(.5);\n  for (int i = 0; i < 15; ++i)\n  {\n    float r = 2.5;\n    float fi = float(i);\n    float orbit = fi+iTime*.5;\n    vec3 pos = p + vec3(sin(orbit),0.,cos(orbit))*mix(1.5,2.5,sat(sin(fi*5.)*.5+.5));\n    pos.xy *= r2d(fi+iTime);\n    pos.xz *= r2d(fi+iTime*(1.+fi*.1));\n    vec2 cube = vec2(_cube(pos, vec3(mix(0.025,0.1, sat(sin(fi*10.)*.5+.5)))),1.);\n    acc = _min(acc, cube);\n  }\n  \n  vec3 p2 = p;\n  vec3 rep = vec3(2.);\n  vec3 idx = floor(p2+rep*.5)/rep;\n  p2 = mod(p2+rep*.5, rep)-rep*.5;\n  p2.x += sin(idx.y*10.+iTime);\n  float beat = .3;\n  acc = _min(acc, vec2(_sph(p2, .1*mod(iTime, beat)/beat),2.));\n  \n  return acc;\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  vec3 p = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    vec2 res = map(p);\n    if (res.x < 0.01)\n      return vec3(res.x, distance(ro, p), res.y);\n    \n    vec3 rgb = mix(vec3(1.,.5,.25).zyx, vec3(1.,.5,.25), sat(sin(length(p)*5.+iTime)));\n    rgb *= 1.-sat(_sph(p, 15.)*100.);\n    \n    accCol += 0.1*rgb*(1.-sat(res.x/1.15));\n    p+= rd*res.x;\n  }\n  return vec3(-1.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col = vec3(.1,.15,.3);\n  col += vec3(.5,.3,.2)*(1.-sat(_cir((uv+vec2(.25))*3., .2))); \n  col += vec3(.5,.3,.2)*(1.-sat(_cir((uv+vec2(.25,-.25))*3., .2))); \n  col += vec3(.5,.3,.2).zxy*(1.-sat(_cir((uv+vec2(-.25,-.25))*2., .3)));\n  \n  col *= sat(length(uv*2.)+.5);\n  float rad = 5.0+sin(iTime*16.)*sat(sin(iTime*.1)*20.);\n  float t = iTime*.25;\n  vec3 ro = vec3(sin(t)*rad,-2.,cos(t)*rad);\n  vec3 ta = vec3(0.,0.,5.*sin(iTime*.25));\n  vec3 rd = normalize(ta-ro);\n  ro.xz *= r2d(sin(iTime));\n  \n  rd = getCam(uv, rd);\n  \n  rd.xz *= r2d(sin(iTime));\n  accCol = vec3(0.);\n  vec3 res = trace(ro, rd, 64);\n  if (res.y > 0.)\n  {\n      vec3 p = ro+rd*res.y;\n      vec3 n = getNorm(p, res.x);\n      col = n*.5+.5;\n      vec3 lpos = vec3(5.,-5.,1.);\n      vec3 ldir = lpos-p;\n      vec3 h = normalize(rd+ldir);\n      col = vec3(.1,.15,.3);\n\n      float stp = 0.1;\n    float dt = dot(h, n);\n    dt = floor(dt/stp)*stp;\n      col += vec3(.5,.3,.2)*pow(sat(dt),1.);\n  }\n    col += accCol;\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n  vec3 col = rdr(uv);\n  col = pow(col, vec3(2.45));\n  col = mix(col, texture(iChannel1, fragCoord.xy/iResolution.xy).xyz,.85*sat(sin(uv.y*40.+iTime)+.75));\n  col = mix(col, col.zxy, sat(sin(uv.x*10.+iTime)));\n\n  col = mix(col, col.xxx, 1.-sat((sin(uv.y*10.+iTime)+.75)*400.));\n  col *= pow(FFT(.2),.15);\n\tfragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27696, "src": "https://soundcloud.com/1985music1985/alix-perez-slink", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2GWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 152]], "test": "untested"}
{"id": "st23DK", "name": "[Livecode RP Jam] Apericube", "author": "totetmatt", "description": "AU SAUMON, MON PRÉFÉRÉ ! \nAs usual, slightly different looking compare to Bonzo version.  Couldn't integrate Blackle technique for better repetition sdf.\nAnyway was a great evening thanks everybody ! ", "tags": ["cube", "jam", "livecode"], "likes": 15, "viewed": 485, "published": 3, "date": "1624780144", "time_retrieved": "2024-07-30T19:13:44.471387", "image_code": "/*\n  /!\\ SOUND REACTIVE                             /!\\\n  /!\\ IF MUSIC DOESNT START, JUST PAUSE AND PLAY /!\\\n  \n  Concept heavily inspired by Shader from Anat @ Cookie Demoparty 2019  \n  https://livecode.demozoo.org/performers/3848.html\n  \n\n  Also massive influence from United Force & Digital Dynamite / Rainbow Clash. \n  Thanks folks ! Golden Path makes me arrive here today :D  \n  \n  \n*/\n#define fGlobalTime iTime\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    \n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat diam(vec3 p,float s){\n   p = abs(p);\n   return (p.x+p.y+p.z-s)*0.57735027;\n}\n//http://glslsandbox.com/e#48230.4\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n//http://mercury.sexy/hg_sdf/\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nvec2 iid ;\n\nvec2 sdf(vec3 p){\n  vec3 pppp=p;\n  vec3 ppp = p;\n  \np.z +=mod(fGlobalTime ,10000.);\n  vec2 h;\n  p.xy*=rot(p.z*.01);\n  p.y = -abs(p.y);\n  p.x +=fGlobalTime*10.;\n  p.y +=5.;\n  vec3 pp = p;\n  vec2 id = pMod2(pp.xz,vec2(3.));\n  iid = id;\n  float tt = texture(iChannel1,fract(vec2((abs(id.y)/10.+abs(id.x)/3.)*.5))*.8).r*1.;\n  tt =sqrt(tt);\n  float dd = hash21(id);\n  h.x = box(pp,vec3(1.,1.+sqrt(dd)*2.,1.));\n  h.y = 1.-tt;\n  \n  vec2 t;\n  t.x = dot(p,vec3(0.,1.,0.));\n  t.y = 2.;\n  h = t.x < h.x ? t:h;\n  \n  t.x = diam(pp+vec3(.0,-2.,.0),.5+dd);\n  t.y = 2.;\n  h = t.x < h.x ? t:h;\n  \n    float scale = 2.-texture(iChannel1,vec2(.33)).r*1.;\n   pppp*=scale;\n   pppp.xz *=rot(fGlobalTime);\n     pppp.xy *=rot(fGlobalTime);\n   t.x = (1./scale)*mix(box(pppp,vec3(.5)) ,diam(pppp,1.) ,1.5);\n   t.y = 3.;\n   h = t.x < h.x ? t:h;\n  \n  return h;\n }\n#define q(s) s*sdf(p+s).x\n vec2 nv=vec2(-.01,.01);\n vec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.0,.3,.7)));}\n\nbool inside=false;\nfloat IOR =1.45;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    \tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n \n  vec3 ro=vec3(0.,0.,-5.);\n\n  vec3 rt = vec3(sin(fGlobalTime)*2.,0.,(cos(fGlobalTime)*.5+.5)*2.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = cross(z,vec3(0.,-1.,0.));\n  vec3 y = cross(z,x);\n  vec3 rd=normalize(mat3(x,y,z)*vec3(uv,1.));\n   \n  //rd=normalize(vec3(uv,1.));\n  //rd = \n  vec3 rp=ro;\n  vec3 light= vec3(1.,2.,-3.);\t\n\n\tvec3 col = vec3(.0);\n  float i=0.;\n  vec3 acc = vec3(0.);\n  for(i=0.;i<=100.;i++){\n      vec2 d = sdf(rp);\n      rp += rd*d.x;\n    \n    if(d.y <= .19){\n          \n           acc += pal(d.y*33.5)*exp(.05*-abs(d.x))/40.;\n       d.x = max(.001,abs(d.x));\n    }\n      if(d.x <=0.001){\n          vec3 n = norm(rp);\n          if(d.y <= 1.){\n       \n            col = vec3(.001)*max(0.,dot(light-rp,n));\n            \n          break;\n          } else if(d.y ==2.){\n              //rd = reflect(rd,n+texture(texNoise,texture(iChannel1,vec2(.3)).r*0+rp.xz*.1).r);\n              rd = reflect(rd,n+texture(iChannel1,vec2(.3)).r*2.);\n              rp+=rd*.01;\n          }else if (d.y==4.)\n          {\n            \n              col = vec3(1.)*max(0.,dot(normalize(light-rp),n));\n            \n          } else if (d.y == 3.){\n             col +=vec3(.1,.2,.1)/3.;\n              if(!inside){\n               \n                rd = refract(rd,n,1./IOR);\n                rp-=0.005*n;\n                inside = true;\n            } else {\n                n = -n;\n                vec3 _rd = refract(rd,n,IOR);\n                if(dot(_rd,_rd)==0.){\n                    rd = reflect(rd,n);\n                    rp+=0.002*n;\n                    \n                } else {\n                 \n                    rd = _rd;\n                    rp -= 0.005*n;\n                    inside=false;\n                  \n                }\n            }\n          }\n      }\n  }\n  col +=acc*1.5;\n\n\t//col*=1.5;\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(.75)),1.);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27691, "src": "https://soundcloud.com/subsquaremusic/subsquare-broken-lug00ber", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 436, 436, 483], [484, 484, 509, 509, 605], [606, 606, 633, 633, 688], [689, 724, 746, 746, 846], [847, 877, 914, 914, 1005], [1019, 1019, 1036, 1036, 1854], [1907, 1907, 1925, 1925, 1984], [1985, 1985, 2003, 2003, 2049], [2088, 2088, 2145, 2145, 4153]], "test": "untested"}
{"id": "7t23DK", "name": "Livecode demozoo jam", "author": "jeyko", "description": "potatetote", "tags": ["design", "opart"], "likes": 13, "viewed": 377, "published": 3, "date": "1624778966", "time_retrieved": "2024-07-30T19:13:45.366993", "image_code": "#define pmod(p,a) mod(p,a) - 0.5*a\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n#define iTime (iTime + 5.)\nfloat sdBox(vec2 p, vec2 s){p = abs(p) - s; return max(p.y,p.x);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float pxSz = fwidth(uv.y);\n\n    {\n        // block\n        vec2 p = uv;\n        float liters = 1.;\n        for(float i = 0.; i < liters; i++){\n            vec2 md = vec2(0.3,0.1);\n            vec2 p = uv + vec2(iTime*0.1,0.);\n            vec2 id = floor(p/md);\n            p = pmod(p,md);\n            id += 50.;\n            float r = fract(sin(id.x*10.*cos(id.y*4.) + sin(id.x)*sin(id.y)*16.)*200.);\n            if(r < 0.04){\n                \n                col = vec3(1,0.1,0.1)*0.;\n        \n                \n            }\n            //col = mix(col,1.-col,smoothstep(pxSz,0.,d));\n        }\n    }    \n    {\n        // dots\n        vec2 p = uv;\n        float liters = 1.;\n        for(float i = 0.; i < liters; i++){\n            vec2 md = vec2(0.3,0.1);\n            vec2 p = uv + vec2(iTime*0.1,0.);\n            vec2 id = floor(p/md);\n            p = pmod(p,md);\n            id += 50.;\n            float r = fract(sin(id.x*10.*cos(id.y*4.) + sin(id.x)*sin(id.y)*16.)*200.);\n            if(r < 0.06){\n                id = floor(p/md.y*16.);\n                \n                if(mod(id.x + mod(id.y,2.),2.) == 1.)\n                    col = vec3(1,0.1,0.1)*0.;\n        \n                \n            }\n            //col = mix(col,1.-col,smoothstep(pxSz,0.,d));\n        }\n    }\n    \n    {\n        // lines\n        vec2 p = uv;\n        float liters = 1.;\n        for(float i = 0.; i < liters; i++){\n            vec2 md = vec2(0.3,0.1);\n            vec2 p = uv + vec2(iTime*0.1,0.);\n            vec2 id = floor(p/md);\n            p = pmod(p,md);\n            float r = fract(sin(id.x*10.*cos(id.y*4.) + sin(id.x)*sin(id.y)*16.)*200.);\n            if(r < 0.04){\n                p = abs(p);\n                //p *= rot(0.25*pi);\n                float sz = md.x/16.;\n                p = pmod(p,sz);\n                p *= rot(0.25*pi + iTime);\n                \n                float d = sdBox(p, vec2(sz*0.5,0.));\n                \n                col = mix(col,vec3(1,0.1,0.1)*1.,smoothstep(pxSz,0.,d));\n        \n                \n            }\n            //col = mix(col,1.-col,smoothstep(pxSz,0.,d));\n        }\n    }\n    \n    {\n        vec2 p = uv;\n        float liters = 145.;\n        for(float i = 0.; i < liters; i++){\n            float md = 0.5 + 0.4*sin(i*2.5);\n            md*=1.4;\n            vec2 p = uv + vec2(sin(i) + iTime*(1.+sin(i*5.)*0.8)*0.1, 1.*sin(i*3.4)*0.5);;\n            float id = floor(p.x/md);\n            p.x = pmod(p.x,md);\n            \n            p.x += sin(id + iTime)*md*0.6;\n            float d = abs(p.x) - 0.03;\n            d = max(d,abs(p.y) - 0.001);\n            col = mix(col,vec3(1,0.6,0.5)-col*1.,smoothstep(pxSz,0.,d));\n        }\n    }\n    {\n        vec2 p = uv;\n        float liters = 72.;\n        for(float i = 0.; i < liters; i++){\n        \n            float lt = (iTime*(1. + sin(i) ) + sin(iTime + i*20.)*0.5)*0.1;\n            vec2 p = uv + vec2(mod(\n                lt\n                ,1.)*3. - 1.5,cos(i*16.)*0.7);\n            float d = sdBox(p,vec2(0.1,0.1));\n            \n            p *= rot(0.25*pi);\n            p.x = pmod(p.x,0.01);\n            d = max(d,abs(p.x) - 0.001);\n            col = mix(col,vec3(1,0.6,0.5)-col*1.,smoothstep(pxSz,0.,d));\n        \n        }    \n    }\n    {\n        vec2 p = uv;\n        float liters = 42.;\n        for(float i = 0.; i < liters; i++){\n        \n            float lt = (iTime*(1. + sin(i) ) + sin(iTime + i*210.)*0.5)*0.1;\n            vec2 p = uv + vec2(mod(\n                lt\n                ,1.)*3. - 1.5,cos(i*16.)*0.7);\n            float d = length(p) - 0.2;\n            \n            p = pmod(p,0.015);\n            d = max(d,length(p) - 0.000);\n            col = mix(col,vec3(0.,0.6,0.5)-col*1.,smoothstep(pxSz,0.,d));\n        \n        }    \n    }\n    \n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t23DK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 161, 161, 198], [200, 200, 257, 257, 4154]], "test": "untested"}
{"id": "7ljGDK", "name": "Three Link IK Robot Arm", "author": "oneshade", "description": "Solving for the inverse kinematics of a three link robot arm. Its not much different from the inverse kinematics of a two link arm except one angle must be *arbitrary* (*as long as it makes the rest of the system valid).", "tags": ["ik", "robot", "inversekinematics", "arm", "threelink"], "likes": 16, "viewed": 220, "published": 3, "date": "1624772995", "time_retrieved": "2024-07-30T19:13:46.238662", "image_code": "// All fixed! :)\n\n// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Constants (used in solving)\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdRing(in vec2 p, in vec2 o, in float r, in float t) {\n    return abs(length(p - o) - r) - t;\n}\n\n// In: r1: float(radius 1), r2: float(radius 2), p: vec2(position of circle 2)\n// Out: vec2(intersect angle 1, intersect angle 2)\n// Return: bool(intersecting)\nbool circleCircle(in float r1, in float r2, in vec2 p, out vec2 angles) {\n    float sqDist = dot(p, p);\n\n    float mid = atan(p.y, p.x);\n    float offs = (sqDist + r1 * r1 - r2 * r2) / (2.0 * r1 * sqrt(sqDist));\n    if (abs(offs) > 1.0) return false; // Not intersecting\n    offs = acos(offs);\n\n    angles = vec2(mid - offs, mid + offs);\n    return true;\n}\n\n// In: a: vec2(origin), b: vec2(target), l1: float(link 1 length), l2: float(link 2 length)\n// Out: vec4(left handed angles, right handed angles)\n// Return: int(number of solutions)\nint ikTwoLinkAngles(in vec2 a, in vec2 b, in float l1, in float l2, out vec4 angles) {\n    vec2 ba = b - a, t;\n    if (!circleCircle(l1, l2, ba, t)) return 0; // Solve with circle-circle intersection\n    angles.xy = vec2(t.x, atan(ba.y - sin(t.x) * l1, ba.x - cos(t.x) * l1)); // Deduce second angle\n    angles.zw = vec2(t.y, atan(ba.y - sin(t.y) * l1, ba.x - cos(t.y) * l1)); // Deduce second angle\n    return 2;\n}\n\n// Out: vec4(lower bound 1, upper bound 1, lower bound 2, upper bound 2)\n// Return: int(number of boundaries)\n// Once a valid solution is chosen, the remainder can be solved with 2 link kinematics\n// Interestingly similar to factoring polynomials eh? Except easier :D\nint ikThreeLinkSolutionBounds(in vec2 a, in vec2 b, in float l1, in float l2, in float l3, out vec4 bounds) {\n    float outer = abs(l3 + l2), inner = abs(l3 - l2);\n    vec2 ba = b - a;\n    int count = 0;\n\n    float dist = length(ba);\n    if (dist < outer - l1 && (dist < l1 - inner || dist > l1 + inner)) { // All angles are solutions\n        bounds.xy = vec2(0.0, TAU);\n        return 1;\n    }\n\n    if (circleCircle(l1, outer, ba, bounds.xy)) count++; // Outer bound of solution set\n    if (circleCircle(l1, inner, ba, bounds.zw)) { // Inner bound of solution set\n        if (count == 0) bounds.xy = vec2(bounds.w, bounds.z + TAU); // Change the interpolation direction\n        else bounds = bounds.xzwy; // Sort\n        count++;\n    }\n\n    return count;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0, 0.5);\n\n    vec2 a = vec2(0.0); // Origin\n    vec2 b = mouse; // Target\n\n    // Link lengths\n    float l1 = 1.5;\n    float l2 = 0.8;\n    float l3 = 0.5;\n\n    vec4 foo;\n    if (ikThreeLinkSolutionBounds(a, uv, l1, l2, l3, foo) > 0) color.gb = vec2(0.75);\n\n    // Bound calculation\n    float R2inner = abs(l3 - l2); // Inner bound of last two links\n    float R2outer = l3 + l2; // Outer bound of last two links\n\n    float R3inner = l1 < R2inner ? abs(l1 - R2inner) : max(0.0, l1 - R2outer); // Inner bound of all three links\n    float R3outer = l1 + R2outer; // Outer bound of all three links\n\n    drawSDF(abs(sdDisk(uv, a, R3inner)), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(sdDisk(uv, a, R3outer)), vec3(1.0, 0.0, 0.0));\n\n    // Diagrams\n    float inner = abs(l3 - l2), outer = abs(l3 + l2);\n    float radius = 0.5 * (inner + outer), thickness = 0.5 * (outer - inner);\n    drawSDF(sdRing(uv, b, radius, thickness), vec3(0.2, 0.8, 0.5)); // Fill\n    drawSDF(abs(sdRing(uv, b, radius, thickness)), vec3(0.0)); // Outline\n    drawSDF(abs(sdDisk(uv, a, l1)) - 0.01, vec3(1.0, 0.5, 0.0));\n\n    // Boundary angles are crossings with the boundaries of the two final links\n    vec2 anglesInner, anglesOuter;\n    vec2 ba = b - a;\n\n    if (circleCircle(l1, inner, ba, anglesInner)) {\n        vec2 c1 = a + vec2(cos(anglesInner.x), sin(anglesInner.x)) * l1;\n        vec2 c2 = a + vec2(cos(anglesInner.y), sin(anglesInner.y)) * l1;\n        drawSDF(sdDisk(uv, c1, 0.05), vec3(0.2, 0.5, 0.8)); // Fill\n        drawSDF(abs(sdDisk(uv, c1, 0.05)), vec3(0.0)); // Outline\n        drawSDF(sdDisk(uv, c2, 0.05), vec3(0.8, 0.2, 0.5)); // Fill\n        drawSDF(abs(sdDisk(uv, c2, 0.05)), vec3(0.0)); // Outline\n    }\n\n    if (circleCircle(l1, outer, ba, anglesOuter)) {\n        vec2 c1 = a + vec2(cos(anglesOuter.x), sin(anglesOuter.x)) * l1;\n        vec2 c2 = a + vec2(cos(anglesOuter.y), sin(anglesOuter.y)) * l1;\n        drawSDF(sdDisk(uv, c1, 0.05), vec3(0.2, 0.5, 0.8)); // Fill\n        drawSDF(abs(sdDisk(uv, c1, 0.05)), vec3(0.0)); // Outline\n        drawSDF(sdDisk(uv, c2, 0.05), vec3(0.8, 0.2, 0.5)); // Fill\n        drawSDF(abs(sdDisk(uv, c2, 0.05)), vec3(0.0)); // Outline\n    }\n\n    // Compute angles\n    vec4 bounds;\n    int numBounds = ikThreeLinkSolutionBounds(a, b, l1, l2, l3, bounds);\n    if (numBounds > 0) {\n        float transition = mix(1e-4, 1.0 - 1e-4, 0.5 + 0.5 * sin(iTime)); // Precision safety\n\n        float minAngle = bounds.x, maxAngle = bounds.y;\n        float angleOfChoice = mix(minAngle, maxAngle, transition); // Choose *arbitrary* angle\n\n        vec4 otherAngles;\n        vec2 p = a + vec2(cos(angleOfChoice), sin(angleOfChoice)) * l1;\n        int numSolutions = ikTwoLinkAngles(p, b, l2, l3, otherAngles);\n        if (numSolutions > 0) {\n            vec3 angles = vec3(angleOfChoice, otherAngles.xy);\n\n            // Joint positions\n            vec2 v1 = a;\n            vec2 v2 = v1 + vec2(cos(angles.x), sin(angles.x)) * l1;\n            vec2 v3 = v2 + vec2(cos(angles.y), sin(angles.y)) * l2;\n            vec2 v4 = v3 + vec2(cos(angles.z), sin(angles.z)) * l3;\n\n            // More diagrams\n            drawSDF(abs(sdDisk(uv, v2, l2)) - 0.01, vec3(0.0, 0.4, 0.4));\n            drawSDF(abs(sdDisk(uv, v4, l3)) - 0.01, vec3(0.0, 0.4, 0.4));\n\n            vec2 otherPos = v2 - reflect(v3 - v2, normalize(v4 - v2));\n            drawSDF(sdDisk(uv, otherPos, 0.05), vec3(0.75)); // Fill\n            drawSDF(abs(sdDisk(uv, otherPos, 0.05)), vec3(0.0)); // Outline\n\n            // Links\n            drawSDF(sdLine(uv, v1, v2, 0.05), vec3(0.0));\n            drawSDF(sdLine(uv, v2, v3, 0.05), vec3(0.0));\n            drawSDF(sdLine(uv, v3, v4, 0.05), vec3(0.0));\n\n            // Joints\n            drawSDF(sdDisk(uv, v1, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v2, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v3, 0.08), vec3(0.5));\n            drawSDF(sdDisk(uv, v4, 0.08), vec3(0.5));\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 203, 251, 251, 283], [285, 285, 344, 344, 456], [458, 458, 518, 518, 559], [561, 721, 794, 794, 1077], [1079, 1261, 1347, 1347, 1676], [1678, 1946, 2055, 2055, 2703], [2705, 2705, 2760, 2779, 7056]], "test": "untested"}
{"id": "sl23WK", "name": "Surface Normals!", "author": "vchavauty", "description": "We take a normal defined on a path I in R^2 and extend it to the entire plane! The code might be shit! I can probably merge both buffers but I'm lazy.", "tags": ["2d", "light", "normal"], "likes": 6, "viewed": 312, "published": 3, "date": "1624771749", "time_retrieved": "2024-07-30T19:13:47.123297", "image_code": "// Given a path I: [0, 1] -> R^n, and a function defined on \n// this path f: [0, 1] -> R^n ->R^m\n// Consider then the extension\n// F: R^n -> R^m defined by\n// F(x) = C * integral_{i in I} f(i) / (dist(X - I(i))) d I(i) \n// C being a normalizing constant, usually the length of the path I in R^n.\n// Then F is a continuous extension of f in the entire space!\n//\n// We are going to extend the normal map.\n// If we have the circle S1 = {x : |x| = 1}, then for each point in S1, it's normal is itself\n// That is: N(x) = x for every point x in S1. \n// On the other hand, for a square, the normal of a point x is (+1, 0), (-1, 0), (0, +1) or (0, -1)\n// depending on which side of the square the point is.\n// Regardless, we have a normal N defined on this path.\n// We are going to extend this normal onto the entire plane and then light using common techniques!\n\nvec4 GetLight(vec2 uv) // Calculates the light of a point given it's normal\n{\n    vec3 ligdir = normalize(vec3(cos(iTime), sin(iTime), -0.4 + 0.4*sin(iTime*0.5))); //Direction of the Light\n    \n    vec2 tex = float(uv.x <= 1.0) *\n                    texture(iChannel0, uv - vec2(0.0, 1.0)).xy + float(!(uv.x <= 1.0))*\n                    texture(iChannel1, uv - vec2(1.0, 1.0)).xy;\n    \n    vec3 normal = normalize(2.0*vec3(tex, 0.0) - 1.0); //Convert RGB Coordinates back into Normal vectors\n    \n    float intensity = dot(ligdir, normal); //Light it\n    \n    vec4 Color = normalize(vec4(1.0, 0.0, 0.5, 0.0));\n    vec4 BColor = vec4(0.0, 0.0, 0.2, 0.0);\n    \n    return intensity*Color + (1.0-intensity)*BColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*fragCoord/iResolution.xy;\n    fragColor = float(uv.y <= 1.0) * \n        (uv.x <= 1.0 ? texture(iChannel0, uv) : texture(iChannel1, uv - vec2(1.0, 0.0))) +  float(!(uv.y <= 1.0)) *// uv.y <= 1.0\n        GetLight(uv); // 1.0 <= uv.y <= 2.0\n    \n    float border = 0.005;\n    float condition = float(((uv.x <= 1.0 + border && uv.x >= 1.0 - border) || (uv.y <= 1.0 + border && uv.y >= 1.0 - border)));\n    fragColor = condition *\n                    vec4(0.0) + (1.0 - condition) *fragColor;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This buffer gets the normal UV map of a circle\n\n#define PI 3.14159265359\n\nvec2 Normal(vec2 pos) //Calculates the normal of a point in the S1 circunference\n{\n    return normalize(pos); // The normal of the S1 circunference is the identity\n}\nvec2 integral(vec2 pos)\n{\n    float interval = 0.01; //Interval of the ingral\n    vec2 sum = vec2(0.0, 0.0); //Value we are going to return\n    \n    for(float alpha = 0.0; alpha < 2.0*PI; alpha += interval)\n    {\n        vec2 circlepos = 0.7*vec2(cos(alpha), sin(alpha)); // Position of the circle given angle alpha\n        vec2 val = (1.0/(max(length(circlepos - pos), 0.001))) * Normal(circlepos); // Normal of point Circlepos multiplied by the weight it has on position pos.\n        sum = sum + interval * val;\n    }\n    return (1.0/(4.0*PI))*sum; // We normalize it by the length of the path, which is precisely the perimeter of S1. That is, 2PI\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv = uv * vec2(iResolution.x / iResolution.y, 1.0); //Corrects Distortion caused by screen\n    \n    vec2 i = integral(uv); // Gets the extension of the identity of function of the circunference to the entire space\n    fragColor = vec4(0.5) + 0.5*vec4(i.xy, 1.0, 0.0); //Convert normal vector to standard RGB representation.\n\n       \n    \n}", "buffer_a_inputs": [], "buffer_b_code": "// This buffers get the normal UV map of a square\n\nvec2 Normal(vec2 pos) //Calculates the normal of a point in the 2D Square\n{\n    return float(pos.y >= 0.5) * vec2(0.0, 1.0) + float(!(pos.y >= 0.5))*(\n               float(pos.y <= -0.5) * vec2(0.0, -1.0) + float(!(pos.y <= -0.5)) * (\n                   float(pos.x >= 0.5) * vec2(1.0, 0.0) + float(!(pos.x >= 0.5))*\n                       vec2(-1.0, 0.0) ));\n}\nvec2 integral(vec2 pos)\n{\n    float interval = 0.01; //Interval of the integral\n    vec2 sum = vec2(0.0, 0.0); \n    \n    for(float alpha = 0.0; alpha < 4.0; alpha += interval)\n    {\n        vec2 squareposition = float(alpha <= 1.0) * vec2(0.5, -0.5 + alpha) + float(!(alpha <= 1.0)) *(\n                                float(alpha <= 2.0) * vec2(0.5 - (alpha - 1.0) , 0.5) + float(!(alpha <= 2.0))*(\n                                  float(alpha <= 3.0) * vec2(-0.5, 0.5 - (alpha - 2.0)) + float(!(alpha <= 3.0))*\n                                    vec2(-0.5 + (alpha - 3.0), -0.5)));\n        \n        vec2 val = (1.0/(max(length(squareposition - pos), 0.001))) * Normal(squareposition); // Normal of point Square multiplied by the weight it has on position pos.\n        \n        sum = sum + interval * val;\n    }\n    return (1.0/(2.0*4.0))*sum; // Normalization of path length\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv - 1.0;\n    uv = uv * vec2(iResolution.x / iResolution.y, 1.0); //Corrects Distortion caused by screen\n    \n    vec2 i = integral(uv); // Gets the extension of the identity of function of the circunference to the entire space\n    fragColor = vec4(0.5) + 0.5*vec4(i.xy, 1.0, 0.0); //Convert normal vector to standard RGB representation.\n\n       \n    \n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl23WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[856, 856, 933, 933, 1570], [1572, 1572, 1629, 1679, 2187]], "test": "untested"}
{"id": "st23WR", "name": "Candy Gum Drops", "author": "Tater", "description": "cleaner version of what I made during demozoo.livecode release shader jam. ", "tags": ["waves", "sss", "raymarch", "water"], "likes": 22, "viewed": 533, "published": 3, "date": "1624766506", "time_retrieved": "2024-07-30T19:13:47.986988", "image_code": "#define STEPS 128.0\n#define MDIST 225.0\n#define pi 3.1415965\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x) - (x)*0.5)\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat smin(float a,float b, float k){ \n    float h=max(0.,k-abs(a-b));\n    return min(a,b)-h*h*.25/k;\n}\n\n//iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat sat(float a) {return clamp(a,0.0,1.0);}\n\nfloat anim(){\n    //return 0.0;\n    return sat(sin(iTime*0.3)*2.5-1.0);\n}\nfloat rand(vec2 a){\n    return fract(sin(dot(a,vec2(43.234,21.4343)))*94544.3434343)-0.5;\n}\nfloat ssRemap (float t,float s1, float s2, float c){\n    return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)+s1*t;  \n}\nfloat ball(vec3 p, float t){\n    //Ball\n    float scl = 100.0+anim()*50.0; \n    vec3 po = p;\n    p.y+=(fract(t)*scl-0.5*scl);\n    float a = length(p)-1.0-anim();\n    return a;\n\n}\nfloat wave(vec3 p, float t){\n    float dist = length(p.xz)-mod(t+0.5,1.0)*55.0+0.5;\n    dist = min(dist,0.0);\n    float wave = 1.*sin(dist)*exp(-abs(length(dist*0.2)));\n    wave*=max(0.0,1.0-fract(t+0.5)*2.0);\n    return wave;\n}\nvec2 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    \n    float t = iTime*0.25;\n    \n    vec3 po2 = p;\n    p.y= ssRemap(p.y*0.7,-0.2,0.6,.3);\n\n    p.y=mix(po2.y,p.y,sat(anim()));\n    vec3 po = p;\n    \n    float balls = 10.0;\n    float wav = 0.0;\n    for(float i = 0.0; i<balls; i++){\n        p = po2;\n        \n        t+=1.0/balls;\n        \n        float mag = 15.0;\n        p.x+=rand(vec2(floor(t),i))*mag;\n        p.z+=rand(vec2(floor(t),i*1.5))*mag; \n\n        //a.x = smin(a.x,ball(p,t),1.0); \n        \n        b = vec2(ball(p,t),i+3.0);\n        \n        a=(a.x<b.x)?a:b;\n        \n        wav+=wave(p,t)*1.5;\n    }\n        \n    t=iTime*4.5;\n    p=po;\n    wav+=sin(p.z*0.8+t)*0.1+sin(p.x*0.8+t)*0.1;\n    wav+=sin(p.z*0.3-t)*0.2+sin(p.x*0.2-t*2.0)*0.2;\n    \n    b.x = p.y+wav;\n    b.y = 2.0;\n    a.x=smin(a.x,p.y+wav,0.4);\n    \n    a=(a.x<b.x)?a:b;\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,15,-30);\n    ro.y+=sin(iTime)*3.0;\n\n    ro.xz*=rot(iTime*0.2);\n\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*1.0+uv.x*r+uv.y*cross(f,r));\n    \n    vec3 p = ro;\n    float dO, shad;\n    vec2 d;\n    \n    for(float i =0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x*0.8;\n        \n        if((d.x)<0.01){\n            shad = i/STEPS;\n            break;\n        }\n        if(dO>MDIST){\n            dO=MDIST;\n            p = ro+rd*dO;\n            d.y=0.0;\n            break;\n        }\n        shad = 1.0;\n    }\n    vec3 n = norm(p);\n    //vec3 ld = vec3(1,1,1);\n    vec3 ld=normalize(vec3(1,1.3,2));\n    vec3 h = normalize(ld - rd);\n    float spec = pow(max(dot(n, h),0.), 20.);\n    shad = 1.0-shad;\n    \n    col = vec3(shad);\n\n    float sss=0.;\n\n    //sss stolen from nusan\n    for(float i=1.; i<20.; ++i){\n        float dist = i*2.;\n        sss += smoothstep(0.,1.,map(p+ld*dist).x/dist);\n    }\n \n    vec3 al;\n    if(d.y==2.0)al = vec3(0.220,0.741,1.000);\n    if(d.y>2.0)al = 1.4*pal(d.y/10.0, vec3(0.5),vec3(0.5),vec3(1),vec3(0,0.33,0.66) );\n   \n    \n    \n    //I'm sorry for butchering these lighting equations, I have no idea what I am doing\n    col = shad*vec3(sss)*al;\n    col+=spec*0.3;\n\n    \n    //Sky\n    p.y-=5.0;\n        \n    vec3 sky = mix(vec3(0.012,0.471,0.647),vec3(0.145,0.118,0.522),clamp(p.y*0.05,0.0,1.0));\n    \n    col = mix(col,clamp(sky*3.0,0.0,2.0),dO/MDIST);\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 177, 177, 236], [237, 237, 274, 274, 340], [342, 355, 422, 422, 465], [466, 466, 486, 486, 511], [513, 513, 526, 544, 586], [587, 587, 606, 606, 678], [679, 679, 731, 731, 801], [802, 802, 830, 841, 980], [981, 981, 1009, 1009, 1209], [1210, 1210, 1227, 1227, 2093], [2094, 2094, 2112, 2112, 2239], [2241, 2241, 2298, 2298, 3941]], "test": "untested"}
{"id": "ftj3WV", "name": "go hard", "author": "sp4ghet", "description": "At shader jam for the release of livecode.demozoo.org\nhttps://twitter.com/psenough/status/1408454513111994371\n\nHappy birthday M4tt", "tags": ["jam"], "likes": 17, "viewed": 501, "published": 3, "date": "1624748163", "time_retrieved": "2024-07-30T19:13:48.894561", "image_code": "#define backbuffer iChannel1\n#define fft iChannel0\n#define ffts iChannel0\n#define bass texture(ffts, vec2(.001)).r\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pt = uv - .5;\n    vec2 ar = vec2(iResolution.y / iResolution.x, 1);\n    pt /= ar;\n\n    int n = int(100.*pow(bass,5.)) + 1;\n    vec3 c = vec3(0.);\n    \n    for(int i=0; i<n; i++){\n        pt *= .99;\n        pt -= .001 * bass * vec2(1.,0.) * r2d(TAU*20.*bass);\n        uv = (pt*ar) + .5;\n        \n        c += texture(backbuffer, uv).aaa;\n    }\n    c /= float(n);\n\n\n    c = c / (1. + c);\n    float lum = dot(c.rgb, vec3(.2126, .7152, .0722));\n    float shad = smoothstep(.4, .01, lum);\n    float high = smoothstep(.3, 1., lum);\n    c = c * shad * vec3(.4, 1., 1.5) + c * (1.-shad*high) + c*high*vec3(.99,.6,.8);\n    fragColor = vec4(c,1.0);\n}\n  ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27684, "src": "https://soundcloud.com/yoxtellar/210317-wrld-is-mine-yox-vip-mastering", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "\n\nvec4 map(vec3 q){\n  vec4 d = vec4(1000, 0,0,0);\n  vec3 p = q;  \n   \n  float ns = random(vec3(p.xz * .1,0));\n  ns += random(vec3(p.xz * .1 + ns, 0)) * .2;\n  p.y += ns;\n  p.y += .5;\n  float pl = p.y;\n  chmin(d, vec4(pl, 0,0,0));\n  \n  p = q;\n  float beat = time * 175. / 60.;\n  float t = 0.5 + 0.5 * cos(PI * exp(-3. * fract(.5*beat)));\n  float x = length(p.xz) - 1.;\n  float y = p.y;\n  float th = atan(y,x);\n  float ph = atan(p.z, p.x);\n  float r = length(vec2(x,y)) - 2.25;\n  p = vec3(r,th,ph);\n  p.y += p.z*(1. + t);\n  p.y = mod(p.y, .2) - .1;\n  \n  p.r = abs(p.r) - 2.;\n  \n  float tr = box(p, vec3(.05, .05, PI));\n  chmin(d, vec4(tr,0,0,0));\n  \n  p = q;\n  t = 0.5 + 0.5 * cos(PI * exp(-3. * fract(.5*beat + .5)));\n  float sc = .3;\n  float fr = 10000.;\n  for(int i=0; i<5; i++){\n      p *= r3d(PI * (.15 + t), normalize(vec3(-1, 1, 0)));\n      fr = min(fr, octahedron(p, sc));\n      p = abs(p);\n      sc *= .43;\n      p -= sc*1.5;\n  }\n  chmin(d, vec4(fr, 0,0,0));\n  \n  \n  return d;\n}\n\nvec3 normal(vec3 p, vec2 e){\n  return normalize(vec3(\n    e.xyy * map(p + e.xyy).x +\n    e.yxy * map(p + e.yxy).x +\n    e.yyx * map(p + e.yyx).x +\n    e.xxx * map(p + e.xxx).x\n  ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tvec2 pt = uv - 0.5;\n    vec2 ar = vec2(iResolution.y / iResolution.x, 1);\n\tpt /= ar;\n  \n\tvec3 c = vec3(0);\n  \n  vec3 ro = vec3(1.,1.,-1.5);\n  vec3 fo = vec3(1,0,0);\n  vec3 rov = normalize(fo-ro);\n  vec3 cu = normalize(cross(rov,up));\n  vec3 cv = cross(cu,rov);\n  vec3 rd = mat3(cu,cv,rov) * normalize(vec3(pt, 1));\n  \n  float t = 0., precis = 0.;\n  vec3 p = ro;\n  vec4 d;\n  for(int i=0; i<128; i++){\n      p = ro + rd*t;\n      d = map(p);\n      t += d.x * .5;\n      precis = t * .001;\n      if(abs(d.x) < precis || t > 20.){\n        break;\n      }\n  }\n  \n  vec3 lpos = vec3(1, 4, .5);\n  if(abs(d.x) < precis){\n    vec3 l = normalize(lpos - p);\n    vec3 n = normal(p, vec2(precis, -precis));\n    \n    float ao = 0.;\n    for(float i=1.; i<=10.; i++){\n      ao += map(p + n*i*.1).x / (i*.1);\n    }\n    ao /= 10.;\n    \n    c = vec3(ao) * max(dot(n,l), .1);\n  }\n  \n  \n  float v = dot(c.rgb, vec3(.2126, .7152, .0722));\n  float beat = time * 175. / 60.;\n  float tm = 0.5 + 0.5 * cos(PI * exp(-4. * fract(beat)));\n  vec2 st = pt;\n  float s = rectSDF(st, vec2(1, 2))*.3 - .25;\n  st *= r2d(PI*.5*tm);\n  s = max(s, -crossSDF(st, 1.)+.075);\n  s = step(s, 0.);\n  st = abs(pt);\n  s *= step(0., sin(PI*.5 + 100.*(st.x + st.y) - TAU*tm));\n  v = mix(v, 0., s);\n  \n  v *= 1.5 - length(pt);\n  \n  fragColor = vec4(v);\n}", "buffer_a_inputs": [], "common_code": "#define time iTime\n\n\n#define saturate(x) clamp((x), 0, 1)\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\n\nconst vec3 up = vec3(0,1,0);\n\n\n\nmat2 r2d(float t){\n  float c = cos(t), s = sin(t);\n  return mat2(c,s,-s,c);\n}\n\nmat3 r3d(float angle, vec3 axis){\n      vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}\n\n\nfloat random(vec3 p){\n    float noise = 0.;\n\n    vec3 seed = vec3(-4. ,-2.,0.5);\n\n    float amp = 1.;\n    float gain = 0.5;\n    float lacunarity = 1.4;\n\n    float warp = 1.3;\n    float warpTrk = .7;\n    float warpTrkGain = 1.5;\n\n    mat3 rotMatrix = r3d(.3, seed);\n\n    for(int i = 0; i < 5; i++){\n        p += sin(p.zxy*warpTrk)*warp;\n        noise += sin(dot(cos(p.yzx), sin(p.zxy)))*amp;\n\n        p *= rotMatrix;\n        p *= lacunarity;\n\n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n\n    return noise*.5;\n}\n\nvoid chmin(inout vec4 a, vec4 b){\n    a = a.x < b.x ? a : b;\n}\n\nfloat box(vec3 p, vec3 b){\n  p = abs(p) - b;\n  return min(0., max(p.x, max(p.y, p.z))) + length(max(p,0.));\n}\n\nfloat octahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    // iq's original version\n  \tvec3 q;\n    if( r.x < 0.0 ) {q = p.xyz;}\n    else if( r.y < 0.0 ){ q = p.yzx;}\n    else if( r.z < 0.0 ){ q = p.zxy;}\n    else {return m*0.57735027;}\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\nfloat rectSDF(vec2 st, vec2 size){\n  return max(abs(st).x * size.x, abs(st).y * size.y);\n}\n\nfloat crossSDF(vec2 st, float s){\n  vec2 size = vec2(.25, s);\n  return min(rectSDF(st, size.xy),\n    rectSDF(st, size.yx));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftj3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 224, 914]], "test": "untested"}
{"id": "ft2GWV", "name": "Tater @ livecode Release Jam", "author": "Tater", "description": "It turned out not so good but I had a lot of fun, I will probably fix it up and make a pretty version later. \nhttps://livecode.demozoo.org/\nhttps://www.twitch.tv/psenough", "tags": ["raymarch", "jam", "livecode", "demozoo"], "likes": 6, "viewed": 275, "published": 3, "date": "1624747675", "time_retrieved": "2024-07-30T19:13:49.696417", "image_code": "#define STEPS 250.0\n#define MDIST 550.0\n#define pi 3.1415926\n\n#define pmod(p,x) (mod(p,x) - (x)*0.5)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat smin(float a, float b, float k){\n  float h = max(0.0,k-abs(a-b));\n  return min(a,b)-h*h*0.25/k;\n}\nfloat anim(){\n  return sin(iTime); \n}\nfloat rand(vec2 a){\n  return fract(sin(dot(a,vec2(43.234,21.4343)))*94544.3434343)-0.5;\n}\nfloat ssRemap(float t, float s1, float s2, float c){\n  return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)*s1*t;\n}\nfloat wave(vec3 p, float t){\n  float dist = length(p.xz)-fract(t+0.5)*50.0;\n  dist = min(dist,0.0);\n  float wave = sin(dist)*exp(-abs(length(dist*0.2)));\n  wave*=max(0.,1.0-fract(t-0.5)*2.0);\n  return wave;\n}\nfloat ball(vec3 p, float t){\n  float mag = 80.0;\n  p.y += (fract(t)-0.5)*mag;\n  float a = length(p)-3.0;\n  return a;\n}\n\nvec2 map(vec3 p){\n  vec3 po = p;\n  \n  float t= mod(iTime,300.0)*0.6;\n  vec2 a = vec2(1);\n  vec2 b = vec2(2);\n  \n  //Bending\n  p.y = pmod(p.y,60.0);\n  \n  float th = atan(p.x,p.z)/(2.0*pi)+0.5;\n  th*=300.0;\n  float r = length(p.xz)-60.0;\n  p.x = r;\n  //p.z = th;\n  p.xy*=rot(sin(t));\n  //p.xy*=rot(p.z*0.01*sin(t));\n  p.xy = abs(p.xy)-5.0;\n  p.xy*=rot(-pi/4.0);\n  p.y=mix(p.y,ssRemap(p.y,0.01,0.4,0.3),0.5+0.5*anim());\n  \n  vec3 po2 = p;\n  float count = 6.0;\n  float wav =0.0;\n  for(float i =0.0; i < count; i++){\n    p = po2;\n    t+=1.0/count;\n    float mag = 10.0;\n    p.x+=rand(vec2(floor(t),i))*mag;\n    p.z+=(rand(vec2(floor(t),i*1.5)))*mag*30.0;\n    a.x = smin(a.x,ball(p,t),0.5);\n    wav +=wave(p,t)*1.5;\n  }\n  p = po2;\n  t = mod(iTime,300.0)*4.0;\n  wav+=sin(p.z+t)*0.1+sin(p.x+t)*0.1;\n  wav+=sin(p.z*0.5-t)*0.2+sin(p.x*0.5-t)*0.2;\n  \n  //a.x = ball(p,t);\n  b.x = p.y-wav;\n  \n  \n  a=(a.x<b.x)?a:b;\n  \n  return a;\n}\n\nvec3 norm(vec3 p){\n  vec2 e = vec2(0.01,0);\n  return normalize(map(p).x-vec3(\n  map(p-e.xyy).x,\n  map(p-e.yxy).x,\n  map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n  float t= mod(iTime,300.0);\n  vec3 col = vec3(0.1);\n  vec3 ro = vec3(0,70,-150);\n  \n  float drop = 0.0;\n  drop = 0.0;\n  ro.y-=drop;\n  \n  //ro.z*=sin(t);\n  //ro.y += sin(t)*20.0;\n  ro.xz*=rot(t*0.3);\n  vec3 lk = vec3(0,0,0);\n  \n  lk.y-=drop;\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = f*1.0+uv.x*r+uv.y*cross(f,r);\n  \n  vec3 p = ro;\n  float dO, shad;\n  vec2 d;\n  \n  for(float i = 0.0; i<STEPS; i++){\n    p = ro+rd*dO;\n    d = map(p);\n    dO+=d.x*0.9;\n    \n    if(abs(d).x<0.01){\n      shad = i/STEPS;\n      break;\n    }\n    if(dO>MDIST){\n      dO = MDIST;\n      p = ro+rd*dO;\n      d.y=0.0;\n      break;\n    }\n  }\n  shad = 1.0-shad;\n  vec3 n = norm(p);\n  vec3 ld = normalize(vec3(1,1,0));\n  vec3 h = normalize(ld - rd);\n  float spec = pow(max(dot(n,h),0.0),20.0);\n  \n  vec3 al = vec3(0);\n  if(d.y==1.0) al = vec3(0,0.8,0.2);\n  if(d.y==2.0) al = vec3(0,0,0.9)*1.5;\n  p.y-=5.0;\n  vec3 back = mix(vec3(0.1,0.1,0.5),vec3(0.0,0.4,0.6),clamp(p.y*0.05,0.0,1.0))*0.9;\n  //back = vec3(0);\n  \n  col = shad*al;\n  col+=spec*0.5;\n  \n  col = mix(col,back*2.0,(dO/MDIST));\n\n  fragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 191, 191, 256], [257, 257, 270, 270, 294], [295, 295, 314, 314, 384], [385, 385, 437, 437, 503], [504, 504, 532, 532, 712], [713, 713, 741, 741, 831], [833, 833, 850, 850, 1752], [1754, 1754, 1772, 1772, 1889], [1891, 1891, 1948, 1948, 3138]], "test": "untested"}
{"id": "ftjGWV", "name": "anticore 26/06 shader jam", "author": "anticore", "description": "for livecode.demozoo.org party", "tags": ["raymarching", "shader", "jam"], "likes": 13, "viewed": 405, "published": 3, "date": "1624747537", "time_retrieved": "2024-07-30T19:13:50.612966", "image_code": "\nvec3 cam(vec3 ro, vec3 rd, vec2 uv) {\n  vec3 f = normalize(rd - ro);\n  vec3 l = normalize(cross(vec3(0,1,0), f));\n  vec3 u = normalize(cross(f, l));\n  \n  return normalize(f + l * uv.x + u * uv.y);\n}\n\nfloat ni(float a){\n    //return texture(texFFTIntegrated, a).x;\n    return iTime;\n}\n\n\nvoid mo(inout vec2 p,vec2 d){p = abs(p)-d;if(p.y>p.x)p=p.yx;}\nvec3 rep(vec3 p, vec3 c) { return mod(p + .5 * c, c) - .5 * c; }\nvec3 repl(vec3 p,vec3 c,vec3 l){return p-c*clamp(round(p/c),-l,l);}\nmat2 rot(float t) { return mat2(cos(t), sin(t), -sin(t), cos(t)); }\nfloat sdBox(vec3 p, vec3 b) { vec3 q = abs(p) - b; return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.); }\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdPlane(vec3 p, vec3 n, float h) { return dot(p,n) + h; }\nfloat rnd(float p) { p = fract(p * .131); p *= p + 333.33; return fract(2. * p * p); }\nfloat dirlight(vec3 n, vec3 ld) {\n  ld = normalize(ld);\n  return clamp(max(dot(n, ld), 0.), 0., 1.);\n }\nfloat spec(vec3 p, vec3 n, vec3 ld, float k) {\n    ld = normalize(ld);\n    vec3 r = reflect(-ld, n);\n    vec3 v = normalize(-p);\n    return pow(max(dot(r,n), 0.), k);\n}\nvec3 palette(float t) {\n    vec3 a= vec3(1);\n    vec3 b= vec3(1);\n    vec3 c = vec3(2);\n    vec3 d = vec3(0,.1, .2);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 ground(vec3 p) {\n    float plane = sdPlane(p, vec3(0,1,0), 0.);\n    float cracks = texture(iChannel0, p.xz * 0.05).r;\n    float crack = 0.28;\n  \n    return vec2(\n    plane + texture(iChannel1, p.xz * .7).r * 0.03\n      + texture(iChannel0, p.zx * 0.1).r * 1.\n      + texture(iChannel0, p.xz * 0.01).r * 4.,\n      \n       cracks > crack && cracks < crack + 0.01 ? 4 : 0\n    );\n}\n\n\nfloat bid;\nfloat tunnel(vec3 p) {\n    vec3 bp = p;\n    bp.xy *= rot(bp.z * 0.1);\n    mo(bp.xy, vec2(0.5));\n    mo(bp.zy, vec2(0.5));\n    bid = rnd(round(p.z + 0.5) * 120.);\n    float b = sdBox(rep(bp + vec3(-1.5, 0, 0), vec3(0, 0, 2)), vec3(0.1, 1.5, 0.1));\n    return b;\n}\n\n\nfloat sid;\nvec2 sphrs(vec3 p) {\n  p = p + vec3(0,0,-iTime - 7.);\n  p.xz *= rot(iTime);\n  p.yz *= rot(iTime);\n  sid = rnd(round(p.x - 0.75) * 10. + round(p.y - 0.75) * 20. +  round(p.z - 0.75) * 10.);\n  p = repl(p, vec3(.5), vec3(2));\n  float s = sdSphere(p + vec3(sin(iTime * 10. + p.x / 10.) * 0.05), .2 - abs(sin(sid * 60. + iTime)) * .15);\n  return vec2(s, fract(sid + iTime) < 0.9 ? 2 : 3);\n}\n\nvec2 map(vec3 p) {\n    float m = 999.;\n    float mm = 0.;\n    \n    vec2 g = ground(p);\n    if (g.x < m) { m = g.x; mm = g.y; }\n    \n    float t = tunnel(p);\n    if (t < m) { m = t; mm = 1.; }\n    \n    vec2 s = sphrs(p);\n    if (s.x < m) { m = s.x; mm = s.y; }\n    \n    return vec2(m, mm);\n}\nvec3 norm(vec3 p) {\n    float E = 0.01; vec2 k = vec2(1, -1);\n    \n    return normalize(\n      k.xyy * map(p + k.xyy * E).x +\n      k.yyx * map(p + k.yyx * E).x +\n      k.yxy * map(p + k.yxy * E).x +\n      k.xxx * map(p + k.xxx * E).x \n    );\n}\n\nvec3 bg(vec2 uv) {\n    float h = uv.y;\n    float n = texture(iChannel0, vec2(uv.x, uv.y - iTime * 0.05)).x;\n    float s = texture(iChannel0, uv * 6. + vec2(sin(iTime) + iTime, cos(iTime))).x > 0.45 ? 1. : 0.;\n  \n    return vec3(n * h*2. * palette(uv.y / 2.1));\n}\n\n\nvec3 ld = vec3(0, 30, 10);\nvec4 tr(vec3 ro, vec3 rd, vec2 uv) {\n    float td = 1.;\n    vec2 h;\n    vec4 c = vec4(0);\n    vec4 g = vec4(0);\n    int bnc = 0;\n    float en = 1.;\n  \n    for (int i = 0; i < 1000; i++) {\n        vec3 ip = ro + rd * td;\n        h = map(ip);\n        td += h.x * 0.3;\n      \n        if (h.y == 1.) {\n            g += vec4(palette(bid * (ni(0.15) * 1. + iTime / 2.)) * exp(-h.x * 10.) * .07, 1.);\n        }\n        \n        if (h.y == 3.) {\n          g += vec4(palette(sid / 10.) * exp(-h.x * 10.) * .07, 1.);\n        }\n        if (h.y == 4.) {\n          g += vec4(palette(0.63 + sin(ip.x / 10. + iTime * 0.2)) * exp(-h.x * 10.) * (.5 + abs(sin(ip.x + ip.z + iTime)) * .5), 1.);\n        }\n       \n      \n        if (h.x < 0.01) {\n          vec3 inorm = norm(ip);\n          \n          if (h.y == 0.) {\n              c += vec4(dirlight(inorm, ld) * palette(ip.y * 0.2 + 0.45) * en * 0.7 + spec(ip, inorm, ld, 20.), 1.) * en;\n           }\n           \n           if (h.y == 1.) {\n                c += vec4(palette(bid * (ni(0.15) * 1. + iTime / 2.)) * en, 1.);\n           }\n           \n           if (h.y == 2.) {\n             c += vec4(0.2) * en;\n             ro = ip;\n             rd = reflect(rd, inorm);\n             td = .1;\n             bnc += 1;\n             en = max(en - .7, 0.);\n           }\n           \n           if (h.y == 3.) {\n               c += vec4(palette(sid / 10.) * en, 1.);\n            }\n            \n            if (h.y == 4.) {\n                c += vec4(0.9);\n            }\n        }\n        \n        if (td > 200.) {\n            return vec4(bg(uv) + vec3(g) * exp(-td * 0.05), td/1000.);\n        }\n      \n        if (c.a >= 1. || bnc > 1 || en < 0. || td > 1000.) break;\n    }\n    \n    return vec4((vec3(c) + vec3(g)) * exp(-td * 0.05), td/1000.);\n}\n\n/*\nvoid main(void)\n{\n\tvec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n  vec2 uvv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n\tvec3 ro = vec3(fract(t / 10) > 0.5 ? 10 : 0, 0, t);\n  vec3 rd = cam(ro, vec3(0,0,t + 10), uv);\n  out_color = tr(ro, rd, uv);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec2 uvv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n\tvec3 ro = vec3(fract(iTime / 10.) > 0.5 ? 10. : 0., 0., iTime);\n      vec3 rd = cam(ro, vec3(0,0,iTime + 10.), uv);\n    fragColor = tr(ro, rd, uv);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjGWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 38, 199], [201, 201, 219, 264, 284], [287, 287, 316, 316, 348], [349, 349, 375, 375, 413], [414, 414, 446, 446, 481], [482, 482, 501, 501, 549], [550, 550, 579, 579, 664], [665, 665, 698, 698, 722], [723, 723, 763, 763, 786], [787, 787, 807, 807, 873], [874, 874, 907, 907, 977], [978, 978, 1024, 1024, 1146], [1147, 1147, 1170, 1170, 1312], [1314, 1314, 1335, 1335, 1696], [1710, 1710, 1732, 1732, 1972], [1986, 1986, 2006, 2006, 2371], [2373, 2373, 2391, 2391, 2663], [2664, 2664, 2683, 2683, 2908], [2910, 2910, 2928, 2928, 3172], [3202, 3202, 3238, 3238, 4970], [5287, 5287, 5344, 5394, 5689]], "test": "untested"}
{"id": "fl23DK", "name": "Streeeam", "author": "butadiene", "description": "raymarching", "tags": ["raymarching"], "likes": 9, "viewed": 423, "published": 3, "date": "1624747310", "time_retrieved": "2024-07-30T19:13:51.643212", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n \n    vec3 col = texture(iChannel0,uv).xyz;\n    \n    \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define time iTime \nfloat bpm = 175.;\nfloat PI = acos(-1.);\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n  }\n\nvec2 pmod(vec2 p,float n){\n  float np = PI*2.0/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p)*vec2(cos(r),sin(r));\n  }\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n  }\n \nfloat kaku(vec3 p,float s){\n  p.y = abs(p.y);\n  p.y -= 0.07*s;\n  p.yz *= rot(PI*0.25);\n  return box(p,s*vec3(0.05,0.08,0.2));\n  }\n \nfloat kakuring(vec3 p,float r,float k){\n  p.xz *= rot(k);\n  float sc = 1.0;\n  \n  p.xz = pmod(p.xz,28.);\n  p.x -= r;\n  return kaku(p,r*0.5);\n  }\n float rand(vec2 st){\n   return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43578.543123);\n   }\n float ease(float t,float k){\n   return 0.5+0.5*cos(PI*exp(-k*t));\n   }\n   vec3 noi1 = vec3(0);\n   float texint = 0.0;\n  void noi_ipt(){\n    float es = 0.0;\n    float kt =floor(time/12.+es);\n    float s1 = rand(vec2(kt,0.));\n    float s2 = rand(vec2(kt,.5));\n    float s3 = rand(vec2(kt,.7));\n    noi1 = vec3(s1,s2,s3);\n    }\n  \n vec4 circring(vec3 p,float ss){\n   vec3 sp = p;\n   vec3 ecp = vec3(0.5,0.2,0.8);\n   vec3 idlist = vec3(0.,2.,4.);\n   if(ss<1.2){\n     ecp = vec3(0.2,0.8,0.2);\n     idlist = vec3(1.,3.,5.);\n     }\n   float id =  idlist.x;\n    vec3 scol = vec3(0.7);\n     if(length(p)<1.2){\n       scol += vec3(ecp.x,ecp.y,ecp.z);\n       }else if(length(p)<2.2){\n         scol += vec3(ecp.z,ecp.x,ecp.y);\n         id = idlist.y;\n         }else{\n           scol += vec3(ecp.y,ecp.z,ecp.x);\n           id = idlist.z;\n           }\n     \n     const int iterate =2;\n     float kp = 1.;\n     \n     float scale = 1.0;\n     for(int i = 0;i<iterate;i++){\n       \n       kp *= 0.4;\n       p.y = abs(p.y)-0.1*kp;\n       float sc = 2./clamp(dot(p,p),2.,8.);\n       p *= sc;\n       scale *= sc;\n       \n       p = p-kp*vec3(0.7,2.,0.7);\n       p.zy *= rot(0.2);\n       }\n     float dectime = 2.0;\n     float ssc = clamp(0.1*mod(time,12.)-id/24.,0.,1.);\n       ssc = -ease(ssc,4.);\n       \n      float d = kakuring(p,1.,4.*ssc*PI-0.3*(6.0-id)*0.2*time)/scale;\n       vec3 col =scol;\n       return vec4(col*exp(-8.0*d)*(.15+0.5*(clamp(1.2/length(sp),0.3,1.0)-0.3)-sin(ssc*PI)),d);\n       \n   } \nvec4 dist(vec3 p){\nfloat s = 1.;\n  vec4 rsd = circring(p,1.);\n  p.xy *= rot(0.5*PI);\n  vec4 rsd2  = circring(p,2.);\n  rsd.w = min(rsd.w,rsd2.w);\n  vec3 col = vec3(1.)*(rsd.xyz+rsd2.xyz);\n  return vec4(col,rsd.w); \n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n noi_ipt();\n\tvec2 uv = vec2(fragCoord.x / iResolution.x,fragCoord.y / iResolution.y);\n\n  vec2 p = 2.*(uv-0.5);\n\n  p.y *= iResolution.y/iResolution.x;\n    p *= rot(2.0*PI*rand(vec2(floor(time/12.),0.4)));\n  float rsc = 1.2;\n  float kt = time*0.2;\n  vec3 ro = vec3(rsc*cos(kt),0.7,rsc*sin(kt));\n  vec3 ta = vec3(0);\n  vec3 cdir = normalize(ta-ro);\n  vec3 side = cross(cdir,vec3(0,1,0));\n  vec3 up = cross(side,cdir);\n  vec3 rd = normalize(p.x*side+p.y*up+0.25*cdir);\n  \n  float d,t = 0.1;\n  \n  vec3 ac = vec3(0.);\n  float esp = 0.0001;\n  for(int i = 0;i<86;i++){\n    vec4 rsd = dist(ro+rd*t);\n    d = rsd.w;\n    t += 0.3*d;\n    ac += rsd.xyz;\n    \n    if(d<esp)break;\n   }\n  vec3 col = ac*0.03;\n  \ncol *= 0.6;\n\n   col = pow(clamp(col,vec3(0),vec3(1)),vec3(1.4));\n vec3 bcol = texture(iChannel0,uv).xyz;\n col = mix(col,bcol,0.5);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl23DK.jpg", "access": "api", "license": "mit", "functions": [[115, 115, 172, 172, 305]], "test": "untested"}
{"id": "ft23DK", "name": "That Thing Under Abstraction", "author": "blackle", "description": "made for livecode.demozoo.org Release Party in bonzomatic in roughly 1 hour.", "tags": ["bonzomatic", "liveshader", "livecode"], "likes": 28, "viewed": 553, "published": 3, "date": "1624747025", "time_retrieved": "2024-07-30T19:13:52.506902", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+cross(ax,p)*sin(ro);\n}\n\nfloat comp(vec3 p) {\n  p = asin(sin(p*8.)*.99)/8.;\n  return dot(p,normalize(vec3(3,2,1)));\n}\n\nfloat d1,d2,d3;\nfloat stuff(vec3 p) {\n  d1 = comp(erot(p, normalize(vec3(1,2,3)), .7)+.3);\n  d2 = comp(erot(p, normalize(vec3(1,3,2)), 1.6)+.6);\n  d3 = comp(erot(p, normalize(vec3(3,-2,1)), .4)+.8);\n  return (d1+d2+d3)/2.5;\n}\n\nfloat ball;\nfloat scene(vec3 p) {\n  vec3 p3 = p;\n  p3.xy = asin(sin(p3.xy*3.))/3.;\n  ball = length(p3)-.5+sin(iTime*9.+length(sin(p)))*.02;\n  p3.xy = asin(sin(p3.xy*8.))/8.;\n  ball = min(ball, length(p3)-.2+sin(iTime*13.)*.01);\n  //ball += length(sin(p*100)/800);\n  ball += length(sin(p*20.)/50.);\n  ball += length(cos(p*10.)/80.);\n  ball += length(sin(erot(p,normalize(vec3(2,3,4)),2.4)*150.)/700.);\n  //ball += length(sin(erot(p,normalize(vec3(3,1,-4)),1.4)*200)/800);\n  return min(stuff(p) + p.z*.1, ball);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat bps = 32./10.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  float rr = .9;\n  vec4 past = texture(iChannel0,uv + sin(mat2(cos(rr),-sin(rr),sin(rr),cos(rr))*uv*30.+cos(uv))*.001);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float bar = floor(iTime*bps);\n  float lastbigbar = floor((iTime-iTimeDelta)*bps/4.);\n  float bigbar = floor(iTime*bps/4.);\n  float res = iTime - bigbar;\n  if (lastbigbar != bigbar) past.w = .15;\n\n\tvec3 cam = normalize(vec3(3.+sin(bigbar) + cos(res)*.3,uv));\n  vec3 init = vec3(-3,0,0);\n  \n  bool camtype1 = sin(bigbar*3.) < 0.;\n  bool camtype2 = cos(bigbar*7.) < 0.;\n  bool camtype3 = sin(bigbar*9.) < 0.;\n  bool camtype4 = sin(bigbar*2.) < 0.;\n  \n  float zrot = camtype1 ? 0. : iTime*.1;\n  float yrot = .5;\n  cam = erot(cam,vec3(0,1,0),yrot);\n  init = erot(init,vec3(0,1,0),yrot);\n  cam = erot(cam,vec3(0,0,1),zrot);\n  init = erot(init,vec3(0,0,1),zrot);\n  init.z += 1.;\n  float sgn = camtype3 ? -1. : 1.;\n  if (camtype1) init.x += sgn*mod(iTime,100.)*.2;\n  if (camtype2) init.y += sgn*mod(iTime,100.)*.2;\n  \n  vec3 p = init;\n  bool hit = false;\n  float atten = 1.;\n  float dist;\n  for (int i = 0; i < 100; i++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-7;\n    p += cam*dist;\n    \n    if (hit) {\n      if (abs(sin(d1*40.))<.2 && dist != ball) {\n        vec3 n = norm(p);\n        \n        float fres = 1.-abs(dot(cam,n))*.98;\n        cam = reflect(cam,n);\n        atten *= fres;\n        p += n*.01;\n        hit = false;\n      } else {\n        break;\n      }\n    }\n    if (distance(p,init)>10.)break;\n  }\n  \n  bool isball = ball == dist;\n  float fog = smoothstep(1.,10.,distance(p,init));\n  float sd1 = d1;\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float ao = smoothstep(-.1,.1,scene(p+n*.3));\n  float fact = length(sin(r*3.)*.5+.5)/sqrt(3.)*ao;\n  float diff = length(sin(n*3.)*.5+.5)/sqrt(3.)*ao;\n  float fres = 1.-abs(dot(cam,n))*.98;\n  float spec = (pow(fact,8.)*4.+fact*.2)*fres;\n  vec3 diffcol = isball ? (camtype4? vec3 (.5,.01,.1) :vec3 (.2,.01,.2) ): vec3(0);\n  vec3 col = diff*diffcol + spec;\n  col = mix(col, vec3(0.01), fog);\n  fragColor.xyz = (hit ? col : vec3(0.01))*atten + vec3(0.02,0.01,.04);\n  float pre = length(fragColor.xyz);\n  pre = mix(pre, past.w,.98);\n  float vig = 1.-dot(uv,uv)*.5;\n  fragColor += pre;\n  fragColor = sqrt(smoothstep(0.,1.4,fragColor))*vig;\n  mat3 desat = mat3(vec3(.1),vec3(.1),vec3(.1))+mat3(.7);\n  mat3 sat = inverse(desat);\n  fragColor.xyz *= sat;\n  fragColor.xyz *= sat;\n  fragColor.a = pre;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft23DK.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 251, 251, 334]], "test": "untested"}
{"id": "fl23WK", "name": "Random saturday shader", "author": "mrange", "description": "License CC0: Random saturday shader\nResult after a bit of random coding on saturday afternoon\n", "tags": ["3d", "raymarching"], "likes": 19, "viewed": 372, "published": 3, "date": "1624738306", "time_retrieved": "2024-07-30T19:13:53.359622", "image_code": "// License CC0: Random saturday shader\n// Result after a bit of random coding on saturday afternoon\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)         (0.5+0.5*cos(x))\n\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 50\n#define NORM_OFF        0.0001\n\nconst vec3  std_gamma  = vec3(2.2);\nconst float smoothing  = 0.043;\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat boxf(vec3 p, vec3 b, float e) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\nvec3 refl(vec3 p, vec3 n) {\n  p -= n*pmin(0.0, dot(p, n), smoothing)*2.0;\n  return p;\n}\n\nfloat sphered(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer/sph.w;\n    vec3  rc = (ro - sph.xyz)/sph.w;\n  \n    float b = dot(rd,rc);\n    float c = dot(rc,rc) - 1.0;\n    float h = b*b - c;\n    if( h<0.0 ) return 0.0;\n    h = sqrt( h );\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if( t2<0.0 || t1>ndbuffer ) return 0.0;\n    t1 = max( t1, 0.0 );\n    t2 = min( t2, ndbuffer );\n\n    float i1 = -(c*t1 + b*t1*t1 + t1*t1*t1/3.0);\n    float i2 = -(c*t2 + b*t2*t2 + t2*t2*t2/3.0);\n    return (i2-i1)*(3.0/4.0);\n}\n\nfloat df(vec3 p) {\n  const float zf = 2.5;\n  const int mid  = 1;\n  const int end  = 3;\n  const vec3 n0  = normalize(vec3(-1.0,  1.0,  1.0));\n  const vec3 n1  = normalize(vec3( 1.0, -1.0,  1.0));\n  const vec3 n2  = normalize(vec3( 1.0,  1.0, -1.0));\n  const vec3 off = normalize(vec3(1.0, 1.0, 1.0)); \n\n  float d = 1E6;\n  float z = 1.0;\n  vec3  cp = off;\n  \n  for (int i = 0; i < mid; ++i) {\n    p = pabs(p, smoothing);\n    p = refl(p, n0);\n    p = refl(p, n1);\n    p = refl(p, n2);\n    p -= off*0.33;\n    p *= zf;\n    z *= zf;\n  }\n\n  for (int i = mid; i < end; ++i) {\n    p = pabs(p, smoothing);\n    p = refl(p, n0);\n    p = refl(p, n1);\n    p = refl(p, n2);\n    p -= off*0.24;\n    p *= zf;\n    z *= zf;\n\n    vec3 pp = p;\n    float dd0 = boxf(pp, 0.1*vec3(1.0), 0.0125)-0.0125;\n    float dd1 = length(pp)- 0.075;\n    float dd = dd0;\n    dd = min(dd, dd1);\n    dd /= z;\n    d = min(d, dd);\n  }\n\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = vec3(1.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n\n  float sr    = 0.4;\n  float sd    = sphered(ro, rd, vec4(vec3(0.0), sr), t);\n\n  vec3 gcol   = sd*1.5*vec3(2.0, 1.0, 0.75)*1.0;\n\n  if (t >= MAX_RAY_LENGTH) {\n    return gcol;\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n  float ifade = 1.0-tanh_approx(1.25*ii);\n  float h     = fract(-1.0*length(pos)+0.1);\n  float s     = 0.25;\n  float v     = tanh_approx(0.4/(1.0+40.0*sd));\n  vec3 color  = hsv2rgb(vec3(h, s, v));\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);\n\n  float dm  = 4.0/ll2;\n  float dif = pow(max(dot(nor,ld),0.0),2.0)*dm;  \n  float spe = pow(max(dot(refl, ld), 0.), 20.);\n  float ao  = smoothstep(0.5, 0.1 , ii);\n  float l   = mix(0.2, 1.0, dif*sha*ao);\n\n  vec3 col = l*color + 2.0*spe*ao*exp(-20.0*sd)*sha;\n//  return vec3(ao);\n  return gcol+col*ifade;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME;\n  vec3 cam  = 1.2*vec3(1.0, 0.5, 0.0);\n  float rt  = TAU*TIME/20.0;;\n  cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);\n  cam.xz   *= ROT(sin(rt)*1.0-0.75);\n  vec3 la   = vec3(0.0);\n  vec3 dcam = normalize(la - cam);\n  vec3 ddcam= vec3(0.0);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl23WK.jpg", "access": "api", "license": "cc0-1.0", "functions": [[529, 529, 557, 577, 653], [655, 708, 730, 730, 899], [901, 901, 937, 937, 1170], [1172, 1172, 1209, 1209, 1491], [1493, 1493, 1532, 1532, 1621], [1623, 1623, 1662, 1662, 1691], [1693, 1693, 1729, 1729, 1817], [1819, 1819, 1847, 1847, 1875], [1877, 1877, 1904, 1904, 1964], [1966, 1966, 2024, 2024, 2505], [2507, 2507, 2525, 2525, 3414], [3416, 3416, 3464, 3464, 3659], [3661, 3661, 3684, 3684, 3892], [3894, 3894, 3962, 3962, 4241], [4243, 4243, 4274, 4274, 5416], [5418, 5418, 5449, 5449, 5935], [5937, 5937, 5992, 5992, 6183]], "test": "untested"}
{"id": "flS3zt", "name": "Github like planet", "author": "z0rg", "description": "I love the planet that appears on the github's front page so I decided to do mine :).\nWill proabably make it as a Windows terminal background at some point.", "tags": ["planet", "github"], "likes": 16, "viewed": 598, "published": 3, "date": "1624731090", "time_retrieved": "2024-07-30T19:13:54.112610", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nfloat _sph(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000., -1.);\n    \n    \n    return vec2(_sph(p, 1.), 0.);\n}\n\nvec3 accLight;\n\nvec3 lPos = vec3(5.,-5.,5.);\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.0001)\n            return vec3(res.x, distance(p, ro), res.y);\n        vec3 h = normalize(rd+(lPos-p));\n        accLight += vec3(1.)*(1.-sat(res.x/.5))*.1*sat(sat(dot(normalize(p),h))+.3);//*sat(dot(normalize(p), rd));\n        p+= rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    \n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n    accLight = vec3(0.);\n    vec3 col = vec3(0.078,0.063,0.137);\n    \n    col = mix(col, vec3(0.239,0.216,0.565), 1.-sat((length(uv-vec2(.3))-.1)*3.));\n    col = mix(col, vec3(0.239,0.216,0.565), 1.-sat((length(uv-vec2(-.3,.3))-.1)*3.));\n    col = mix(col, vec3(0.408,0.216,0.565), 1.-sat((length(uv-vec2(.3,-.3))-.1)*3.));\n    col += sat(length(uv*.75))*sat(pow(texture(iChannel1, uv*4.).x,20.)*5.*2500./iResolution.x)*texture(iChannel1, uv*5.+vec2(iTime*.25, 0.)).x;\n   \n    float rad = 5.;\n    float t = 1.5+0.*iTime*.25;\n    vec3 ro = vec3(sin(t)*rad,-3.,cos(t)*rad);\n    vec3 ta = vec3(0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    float depth = -1.0f;\n    // Might be good to use raytracing here, may be way lighter\n    vec3 res = trace(ro, rd, 50);\n    if (res.y > 0.)\n    {\n        depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        //col = n*.5+.5;\n        // If you look carefully and move the camera you'll notice \n        // that I don't account for seamless transition as originally \n        // I used a custom texture that does it pretty well\n        // You know shadertoy custom texture...\n        vec2 coords = vec2(atan(p.x, p.z)+iTime*.25, acos(p.y))*vec2(1./(PI*2.),1./(PI))-vec2(0.,PI);\n        \n       // float earth = 1.-texture(iChannel0, coords)-).x;\n        vec2 deform = vec2(1., 2.);\n        vec2 rep = deform*.003;\n        vec2 id = floor((coords+rep*.5)/rep);\n\n        vec2 mapcoord = mod(coords+rep*.5,rep)-rep*.5;\n        \n        float earth2 = 1.-texture(iChannel0, id*rep*.5).x;\n        earth2 = sat(pow(earth2, 10.)*10.);\n        vec3 h = normalize(rd+(lPos-p));\n        float NdH =dot(n,h);\n        vec3 rgb = vec3(0.239,0.216,0.565)*sat(sat(NdH)+.2);\n        \n        col = rgb;\n        if (earth2 > 0.01)\n        col = mix(rgb, vec3(0.843,0.643,0.918), 1.-sat(_cir(mapcoord/deform,sat(earth2)*.0005)*4000.));\n        \n        col += 2.*vec3(0.239,0.216,0.565)*(1.-sat(-dot(rd, n)*1.5))*sat(sat(NdH*1.)+.25);\n        col += vec3(0.408,0.216,0.565)*(1.-sat(-dot(rd, n)*3.5));\n    }\n    else\n        col += mix(vec3(0.239,0.216,0.565)*.1, vec3(0.408,0.216,0.565), 1.)*accLight;\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    vec2 off = vec2(1., -1.)/(iResolution.x*3.);\n    if (true) // Not so cheap antialiasing\n    {\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3zt.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[451, 451, 480, 480, 506], [508, 508, 537, 537, 563], [564, 564, 582, 582, 662], [710, 710, 751, 751, 1129], [1131, 1131, 1162, 1162, 1298], [1300, 1300, 1331, 1331, 1448], [1450, 1450, 1469, 1469, 3673], [3675, 3675, 3732, 3732, 4139]], "test": "untested"}
{"id": "slSGDV", "name": "twisting log spiral", "author": "morisil", "description": "I generalized some previous sketches", "tags": ["spiral", "polar"], "likes": 5, "viewed": 311, "published": 3, "date": "1624720586", "time_retrieved": "2024-07-30T19:13:55.203692", "image_code": "const float LOG_SCALE_MAX = 50.;\nconst float LOG_SCALE_PERIOD = .4;\nconst float ANGLE_SCALE = 20.;\nconst float ROTATION_SPEED = 30.;\n\n#define wave(x) (sin(x) + 1.) / 2.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    float dist = length(st);\n    float angle = atan(st.x, st.y);\n    float logDist = log(dist);\n    float logScale = sin(iTime * LOG_SCALE_PERIOD) * LOG_SCALE_MAX;\n    float luma = wave(\n        logDist * logScale + angle * ANGLE_SCALE - iTime * ROTATION_SPEED\n    );\n    fragColor = vec4(vec3(luma), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSGDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 225, 225, 633]], "test": "untested"}
{"id": "slS3WV", "name": "Polyhedron series ", "author": "gaz", "description": "3d", "tags": ["sdf", "polyhedron"], "likes": 10, "viewed": 349, "published": 3, "date": "1624718226", "time_retrieved": "2024-07-30T19:13:56.189058", "image_code": "#define PI (atan(1.)*4.)\n\nvoid rot(inout vec3 p,vec3 a,float t)\n{\n\ta=normalize(a);\n\tp=mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a);\n}\n\n// https://www.shadertoy.com/view/MsKGzw\nvec3 fold(vec3 p, float t)\n{\n    vec3 n=vec3(-.5,-cos(PI/t),0);\n    n.z=sqrt(1.-dot(n,n));         // normalize\n    for(float i=0.; i<t; i++){\n        p.xy=abs(p.xy);\n        p-=2.*min(0.,dot(p,n))*n;\n    }\n    return p;\n}\n\nfloat map(vec3 p)\n{\n\trot(p,vec3(cos(iTime*.3),sin(iTime*.5),.5*sin(iTime*.2)),iTime*.7);\n    float t = float[](3.,4.,5.)[int(fract(iTime/8.)*3.)];\n    p = fold(p,t);\n    p.z-=1.;\n    vec3 n=vec3(-.5,-cos(PI/t),0);\n    n.z=sqrt(1.-dot(n,n));         // normalize\n    return float[](\n            dot(p, normalize(vec3(n.z,0,-n.x))),\n            dot(p, normalize(vec3(0,n.z,-n.y))),\n            length(p.xz)-.1,\n            length(p.yz)-.1\n        )[int(fract(iTime/2.5)*4.)];\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    return vec3(.7,.5,.3)+cos(p*2.)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,-5);\n    vec3 rd = normalize(vec3(uv,3));\n    vec3 col= vec3(0);\n\tconst float maxd=50.;\n    float t=march(ro,rd,0.,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,5,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.1,1.);\n        col*=max(dif,0.);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.8;\n        col*=max(.5+.5*n.y,.1);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.8,.6,.2)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n    }\n    col=pow(col,vec3(1./2.2));\n    fragColor.xyz=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slS3WV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 65, 65, 131], [133, 174, 202, 202, 396], [875, 875, 900, 900, 1043], [1045, 1045, 1099, 1099, 1264], [1266, 1266, 1288, 1288, 1333], [1335, 1335, 1392, 1392, 2204]], "test": "untested"}
{"id": "7lSGDK", "name": "photon powder flame", "author": "xenn", "description": "Hallucinatory shapes.\n\nCheck mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 21, "viewed": 565, "published": 3, "date": "1624702028", "time_retrieved": "2024-07-30T19:13:57.501548", "image_code": "// Fork of \"photon powder flame\" by xenn. https://shadertoy.com/view/7ljGzK\n// 2021-06-26 10:06:10\n\n        // Fork of \"not sure, too confused ?\n// 2021-06-21 18:40:35\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float seperation = 0.01;\n    float sinWave = sin(iTime) * seperation;\n    float cosWave = cos(iTime) * seperation;\n    \n    vec2 clockwise = vec2(sinWave, cosWave);\n    vec2 anticlockwise = vec2(-sinWave, cosWave);\n    float speed = 1.0;\n    \n    vec2 offsetRed = clockwise;\n\tvec2 offsetGreen = anticlockwise;\n\tvec2 offsetBlue = vec2(1,1) * cosWave;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 red = texture(iChannel0, uv-offsetRed);\n    vec4 green = texture(iChannel0, uv-offsetGreen);\n    vec4 blue = texture(iChannel0, uv-offsetBlue);\n    \n\tfragColor = vec4(red.r, green.g, blue.b, 1.0);\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// by @paulofalcao\n//\n// Fun with some feedbacks :)\n\nvec3 subImg(in vec2 fragCoord, float xs,float ys, float zs){\n    vec2 xy=fragCoord.xy/iResolution.xy;\n    xy-=0.5;\n    xy+=vec2(sin(iTime*xs)*0.1,cos(iTime*ys)*0.1);//move\n    xy*=(1.1+sin(iTime*zs)*0.1);//scale\n    xy+=0.5;\n    return texture(iChannel0,xy).xyz;\n}\n\nvec3 drawCircle(in vec2 xy){\n    float l=length(xy);\n    return ( l>.233 || l<.184 ) ? vec3(0) : vec3(sin(l*128.0)*.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n  fragColor = (texture(iChannel0,uv)-texture(iChannel1,uv)/1.0);\n\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .99;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .0033;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .35;\nconst float iBlobEdgeSmoothing        = .05;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .28;\nconst float iBlob2Radius              = .54;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .047;\nconst float iBlob2ColorPulseShift     = .0125;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float seperation = 0.01;\n    float sinWave = sin(iTime) * seperation;\n    float cosWave = cos(iTime) * seperation;\n    \n    vec2 clockwise = vec2(sinWave, cosWave);\n    vec2 anticlockwise = vec2(-sinWave, cosWave);\n    float speed = 1.0;\n    \n    vec2 offsetRed = clockwise;\n\tvec2 offsetGreen = anticlockwise;\n\tvec2 offsetBlue = vec2(1,1) * cosWave;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 red = texture(iChannel0, uv-offsetRed);\n    vec4 green = texture(iChannel0, uv-offsetGreen);\n    vec4 blue = texture(iChannel0, uv-offsetBlue);\n    \n\tfragColor = vec4(red.r, green.g, blue.b, 1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 226, 226, 840]], "test": "untested"}
{"id": "flSGDK", "name": "Procedural 3D Voronoi noise", "author": "Zyphery", "description": "A procedural generation of Voronoi noise.\n\neval generates 2 values\nx: distance of uv to point (without the square root)\ny: hash value of closest point (the z calculated in rehash3())\n\nthe y can be used in rehash3() to generate a random color", "tags": ["voronoi", "proceduralnoise"], "likes": 7, "viewed": 1038, "published": 3, "date": "1624679763", "time_retrieved": "2024-07-30T19:13:58.337314", "image_code": "float hash(float x) { return fract(x + 1.3215 * 1.8152); }\n\nfloat hash3(vec3 a) { return fract((hash(a.z * 42.8883) + hash(a.y * 36.9125) + hash(a.x * 65.4321)) * 291.1257); }\n\nvec3 rehash3(float x) { return vec3(hash(((x + 0.5283) * 59.3829) * 274.3487), hash(((x + 0.8192) * 83.6621) * 345.3871), hash(((x + 0.2157f) * 36.6521f) * 458.3971f)); }\n\nfloat sqr(float x) {return x*x;}\nfloat fastdist(vec3 a, vec3 b) { return sqr(b.x - a.x) + sqr(b.y - a.y) + sqr(b.z - a.z); }\n\nvec2 eval(float x, float y, float z) {\n    vec4 p[27];\n    for (int _x = -1; _x < 2; _x++) for (int _y = -1; _y < 2; _y++) for(int _z = -1; _z < 2; _z++) {\n        vec3 _p = vec3(floor(x), floor(y), floor(z)) + vec3(_x, _y, _z);\n        float h = hash3(_p);\n        p[(_x + 1) + ((_y + 1) * 3) + ((_z + 1) * 3 * 3)] = vec4((rehash3(h) + _p).xyz, h);\n    }\n    float m = 9999.9999, w = 0.0;\n    for (int i = 0; i < 27; i++) {\n        float d = fastdist(vec3(x, y, z), p[i].xyz);\n        if(d < m) { m = d; w = p[i].w; }\n    }\n    return vec2(m, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y * 5.0;\n    \n    vec2 n = eval(uv.x, uv.y, iTime);\n    vec3 col = (1.0 - sqrt(n.x)) * rehash3(n.y);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSGDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 58], [60, 60, 81, 81, 175], [177, 177, 200, 200, 347], [349, 349, 369, 369, 381], [382, 382, 414, 414, 473], [475, 475, 513, 513, 1024], [1026, 1026, 1083, 1083, 1256]], "test": "untested"}
{"id": "ftBGDK", "name": "Oil Spill Vortices", "author": "doodlestein", "description": "Just playing around", "tags": ["oil"], "likes": 9, "viewed": 243, "published": 3, "date": "1624679665", "time_retrieved": "2024-07-30T19:13:59.249874", "image_code": "// Original credit to Benoit Marini - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define NUM_LAYERS 3.\n#define ITER 25\n\nvec4 tex(vec3 p)\n{\n    float t = iTime+78.;\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*tan(t*.1),0,0,.14*tan(t*.23));\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);   \n    float t= iTime* .3;\n    \n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\n    {\n        float d = fract(i+t); // depth\n        float s = mix(25.,.25,d); // scale\n        float f = d * smoothstep(1.,.9,d); //fade\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\n    }\n    \n    col/=NUM_LAYERS;\n    col*=vec3(2,1.,2.);\n   \tcol=pow(col,vec3(.5 ));  \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBGDK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[170, 170, 188, 188, 408], [410, 410, 467, 467, 925]], "test": "untested"}
{"id": "NtB3WK", "name": "Circuit waves", "author": "jarble", "description": "It's psychedelic!", "tags": ["fractal", "wave", "sea", "bubble"], "likes": 9, "viewed": 419, "published": 3, "date": "1624675345", "time_retrieved": "2024-07-30T19:14:00.197340", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.27;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/8.)/4.0;\n    //uv.y -= s1/scale1;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= (uv.yx+vec2(uv.x/scale+uv.y/scale,uv.y/scale1+uv.x/scale1)/scale)/scale1;\n            uv.x *= -scale1;\n            uv = fract(uv/scale+s1)*scale;\n            uv.y /= scale1;\n        }\n        col[2] = (uv.y-uv.x);\n        col = (abs(col-col_prev.yzx))/1.25;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3WK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 741]], "test": "untested"}
{"id": "flBGWK", "name": "FAST feature detector", "author": "Cewein", "description": "Features from Accelerated Segment Test demo to show it can run in real time, there is no non-maxima supression.", "tags": ["fast", "edge", "computervision", "corner", "detector"], "likes": 6, "viewed": 403, "published": 3, "date": "1624672356", "time_retrieved": "2024-07-30T19:14:01.301389", "image_code": "//sensibility of the FAST detector\nfloat eps = .03;\nfloat n = 11.0;\n\n//circle need to perform POI detection\nvec2 circle[16] = vec2[](vec2(0.0,3.0),\n            vec2(-1.0,3.0),\n            vec2(-2.0,2.0),\n            vec2(-3.0,1.0),\n            vec2(-3.0,0.0),\n            vec2(-3.0,-1.0),\n            vec2(-2.0,-2.0),\n            vec2(-1.0,-3.0),\n            vec2(0.0,-3.0),\n            vec2(1.0,-3.0),\n            vec2(-2.0,2.0),\n            vec2(-1.0,3.0),\n            vec2(0.0,3.0),\n            vec2(1.0,3.0),\n            vec2(2.0,2.0),\n            vec2(1.0,3.0)\n           );\n           \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvStep = vec2(1.0)/iResolution.xy;\n    \n    float pixelColor = texture(iChannel0,uv).x;\n    \n    float poiVal = 0.0;\n            \n    //fast bail out if nothing found in the four corner\n    for(int i = 0; i < 16; i+=4)\n    {\n        if(abs(texture(iChannel0,uv + circle[i]*uvStep).x - pixelColor) >= eps)\n            poiVal += 1.0;\n        \n    }\n    if( poiVal < 3.0)\n    {\n        fragColor = vec4(texture(iChannel0,uv));\n        return;\n    }\n\n    //reset counter and add total for NMS\n    poiVal = 0.0;\n\n    //check in a cirlce of raduis 3 around the pixel\n    for(int i = 0; i < 16; i++)\n    {\n        if (abs(texture(iChannel0,uv + circle[i]*uvStep).x - pixelColor) >= eps)\n            poiVal += 1.0;\n        else\n        {\n            if(poiVal >= n) continue;\n            poiVal = 0.0;\n        }\n    }\n\n\n    if(poiVal >= n)\n        fragColor = vec4(vec3(1.0,0.0,0.0),1.0);\n    else\n        fragColor = vec4(texture(iChannel0,uv));\n     \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float toGrayscale(vec3 rgb)\n{\n    return dot(rgb,vec3(0.2989, 0.5870, 0.1140));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n    fragColor = vec4(toGrayscale(col));\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[593, 593, 650, 650, 1646]], "test": "untested"}
{"id": "7t2GDy", "name": "Simple animated glow", "author": "999pingGG", "description": "Just a little effect I made for a friend. Works best for neon colors drawings with black background. Would work awesome with HDR displays.", "tags": ["postprocess", "kernel"], "likes": 2, "viewed": 417, "published": 3, "date": "1624661196", "time_retrieved": "2024-07-30T19:14:02.213949", "image_code": "// IMPORTANT: Load a custom image using instructions here: https://www.shadertoy.com/view/lsGGDd\n// In a nutshell: Press F12 to open browser devtools, select Console tab, paste this:\n//\n// gShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/3d1ixs1jnkmkdwg/o5.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n//\n// Change the image URL for any other you want (not every URL works), press ENTER, done.\n\n#define SPEED 4.\n#define GLOW_INTENSITY 10.\n\nfloat sin01(float value) {\n  return (sin(value) + 1.) * .5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n\n  vec3 color = vec3(texture(iChannel0, uv));\n  vec3 bloom = color * sin01(iTime * SPEED) * GLOW_INTENSITY;\n\n  fragColor = vec4(color + bloom, 1.);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2GDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[543, 543, 569, 569, 604], [606, 606, 661, 661, 849]], "test": "untested"}
{"id": "sljGDy", "name": "Rotational symmetry - no trig", "author": "been_jamming", "description": "It's possible to implement rotational symmetry without any trigonometric functions with a binary search on the axes. For any n, if you write n in binary, then it requires the number of digits of n plus the number of 1s minus 1 conditional assignments.", "tags": ["2d", "distancefield", "sdf", "circle", "distance"], "likes": 3, "viewed": 395, "published": 3, "date": "1624659976", "time_retrieved": "2024-07-30T19:14:02.969927", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a disk\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n//Shift points on one side of an axis\nvec2 fold(vec2 p, vec2 axis, mat2 rotation){\n    return dot(p, axis) > 0.0 ? rotation*p : p;\n}\n\n//Shift a point into the first quadrant (different than abs, but same in this context)\nvec2 fold4(vec2 p){\n    p = p.y < 0.0 ? -p : p;\n    p = p.x < 0.0 ? vec2(p.y, -p.x) : p;\n    \n    return p;\n}\n\nvec2 fold12(vec2 p){\n    //It's better to fold everything into the first quadrant first assuming\n    //the number of slices is divisible by 4\n    p = fold4(p);\n    //Then the first quadrant is split into 3\n    p = fold(p, vec2(-0.8660254, 0.5), mat2(0.5, -0.8660254, 0.8660254, 0.5));\n    p = fold(p, vec2(-0.5, 0.8660254), mat2(0.8660254, -0.5, 0.5, 0.8660254));\n    return p;\n}\n\nfloat sdCircle( in vec2 p) \n{\n    p = fold12(p);\n    return length(p - vec2(0.965926, 0.258819)*0.75) - 0.15;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdCircle(p);\n    \n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdCircle(m);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljGDy.jpg", "access": "api", "license": "mit", "functions": [[1238, 1276, 1320, 1320, 1370], [1372, 1459, 1478, 1478, 1568], [1570, 1570, 1590, 1711, 1949], [1951, 1951, 1980, 1980, 2062], [2065, 2065, 2122, 2122, 2739]], "test": "untested"}
{"id": "7tjGDy", "name": "Fork Fork Polar 2.6", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 2, "viewed": 289, "published": 3, "date": "1624658873", "time_retrieved": "2024-07-30T19:14:03.788738", "image_code": "// Fork of \"Fork Fork Polar \" by firebreathz. https://shadertoy.com/view/stj3Rw\n// 2021-06-25 22:06:44\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 18:25:29\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 1000\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(1.000,1.000,1.000))) * 10.)*20.0-10.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    uv.x-=0.01;\n    uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 5.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.099;\n    band += 0.001;\n    \n    s = texture( iChannel0, vec2(band,.3) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 5;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.251,0.000,0.502);\n    colors[1] = vec3(0.251,0.000,0.502);\n    colors[2] = vec3(0.251,0.000,0.251);\n    colors[3] = vec3(1.000,1.000,1.000);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.25;\n    for(int i = 2; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*1.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.00001,.00009,f);\n    col *= smoothstep(0.000000001,0.000000009,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(1.0,-0.5);\n\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,100.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,100.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,100.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.x+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.x+eps.x));\n\n    ref /= 100.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(2.5,1.51));\n    vec3 cs2 = drawBands(vec2(100.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*100.0-10.0))*10.5*smoothstep(1.75,-10.05,length(p*10.0-1.0));\n    vec3 plColBg = vec3(10.92)*smoothstep(1.0,0.0,length(p*80.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(100.5,10.65,10.0-uv.y);\n    \n    col += clamp(pl*(100.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(1000.125,10.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*10.0/2200026.0;\n    col += dither;\n    \n\tfragColor = vec4(col,0.0);\n}", "image_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 334, 334, 405], [407, 407, 449, 449, 508], [510, 510, 535, 535, 2096], [2098, 2098, 2155, 2155, 3444]], "test": "untested"}
{"id": "fljGzd", "name": "Rainbow Flares", "author": "GrantD", "description": "Slightly Tweaked Shader to get a softer and more even effect of rainbow flares with less noise\n\nAll credit goes to the original author ~> benoitM on Shadertoy \n\nOriginal Shader Source - https://www.shadertoy.com/view/WtjyzR", "tags": ["rainbow"], "likes": 24, "viewed": 663, "published": 3, "date": "1624649198", "time_retrieved": "2024-07-30T19:14:04.671378", "image_code": "//ALL CREDIT GOES TO benoitM ON SHADERTOY - https://www.shadertoy.com/view/WtjyzR\n\n#define NUM_LAYERS 7.\n#define ITER 15\n\nvec4 tex(vec3 p)\n{\n    float t = iTime+78.;\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);   \n    float t= iTime* .1;\n    \n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\n    {\n        float d = fract(i+t); // depth\n        float s = mix(5.,.5,d); // scale\n        float f = d * smoothstep(1.,.9,d); //fade\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\n    }\n    \n    col/=NUM_LAYERS;\n    col*=vec3(1.5,0.75,2.25);\n   \tcol=pow(col,vec3(.5 ));  \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 140, 140, 360], [362, 362, 419, 419, 881]], "test": "untested"}
{"id": "7tj3DG", "name": "Randon friday fractal", "author": "mrange", "description": "License CC0: Random friday fractal\nResult after a bit of random coding on friday afternoon\n", "tags": ["3d", "raymarching"], "likes": 13, "viewed": 325, "published": 3, "date": "1624645212", "time_retrieved": "2024-07-30T19:14:05.466253", "image_code": "// License CC0: Random friday fractal\n// Result after a bit of random coding on friday afternoon\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 50\n#define NORM_OFF        0.0001\n\nconst vec3 std_gamma        = vec3(2.2);\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\n\nfloat df(vec3 p) {\n  float d = 1E6;\n\n  const float zf = 2.;\n  const vec3 nz = normalize(vec3(1.0, .0, -1.0));\n  const vec3 ny = normalize(vec3(1.0, -1., 0.0));\n  float z = 1.0;\n  const float rsm = 0.125*0.25;\n  const float a = 128.25; \n  const mat2 rxy = ROT(a);\n  const mat2 ryz = ROT(a*sqrt(0.5));\n  \n  for (int i = 0; i < 7; ++i) {\n    vec3 pp0 = p;\n    vec3 pp1 = p;\n    float dd0 = box(pp0, vec3(0.25))-0.01;\n    float dd1 = length(pp1)-0.3;\n    float dd  = dd0;\n    dd =  pmax(dd, -dd1, 0.05);\n    dd = min(dd, length(pp0)- 0.25);\n    dd  /= z;\n    \n    z *= zf;\n    p *= zf;\n    p.xy *= rxy;\n    p.yz *= ryz;\n    p  = pabs(p, rsm);\n    p -= nz*pmin(0.0, dot(p, nz), rsm)*2.0;\n    p -= ny*pmin(0.0, dot(p, ny), rsm)*2.0;\n\n    p -= vec3(0.85/zf, 0.0, 0.0);\n    d = pmax(d, -(dd-0.1/z), 0.05/z);\n    \n    if(i > 2)\n    d = min(d, dd);\n  \n  }\n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = vec3(1.0);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  float t     = rayMarch(ro, rd, iter);\n  if (t >= MAX_RAY_LENGTH) {\n    return vec3(0.0);\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n  float ii    = float(iter)/float(MAX_RAY_MARCHES);\n\n  float ifade= 1.0-tanh_approx(1.25*ii);\n  vec3 hsv   = vec3(1.25-t*0.5, mix(0.25, 1.0, ii), 1.0);\n  vec3 color = hsv2rgb(hsv);\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.01, 10.0);\n\n  float dm  = 5.0/ll2;\n  float dif = max(dot(nor,ld),0.0)*(dm+0.05);  \n  float spe = pow(max(dot(refl, ld), 0.), 20.);\n  float ao  = smoothstep(0.5, 0.1 , ii);\n  float l   = mix(0.2, 1.0, dif*sha*ao);\n\n  vec3 col = l*color + 2.0*spe*ao*sha;\n\n  return col*ifade;\n//  return vec3(ao);\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME;\n  vec3 cam  = vec3(1.0, 0.5, 0.0);\n  float rt  = TAU*TIME/20.0;;\n  cam.xy   *= ROT(sin(rt*sqrt(0.5))*0.5+0.0);\n  cam.xz   *= ROT(sin(rt)*1.0-0.75);\n  vec3 la   = vec3(0.0);\n  vec3 dcam = normalize(la - cam);\n  vec3 ddcam= vec3(0.0);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3DG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[458, 458, 486, 506, 582], [584, 637, 659, 659, 828], [830, 830, 866, 866, 1099], [1101, 1101, 1128, 1128, 1215], [1217, 1217, 1256, 1256, 1345], [1347, 1347, 1386, 1386, 1415], [1417, 1417, 1453, 1453, 1541], [1543, 1543, 1571, 1571, 1599], [1602, 1602, 1620, 1620, 2461], [2463, 2463, 2511, 2511, 2706], [2708, 2708, 2731, 2731, 2939], [2941, 2941, 3009, 3009, 3288], [3290, 3290, 3321, 3321, 4250], [4252, 4252, 4283, 4283, 4765], [4767, 4767, 4822, 4822, 5012]], "test": "untested"}
{"id": "7lS3WG", "name": "Bezier Splitting Hull Points", "author": "Yusef28", "description": "A Cubic Bezier Splitting Segment Visualization\nMouse Enabled using the X axis\nFrom Pomax Chapter 11. https://pomax.github.io/bezierinfo/\nAll the new stuff is in main\nThe first and second half of the split are flipped. I haven't figured out why yet.\n\n", "tags": ["bezier", "cubic", "casteljau", "splitting", "beziersplitting"], "likes": 4, "viewed": 224, "published": 3, "date": "1624643218", "time_retrieved": "2024-07-30T19:14:06.373826", "image_code": "\n\n//updated: Got rid of the original draw segment function since\n//it's already here: https://www.shadertoy.com/view/fljGR3\n\n//I'm learning this stuff from ----> https://pomax.github.io/bezierinfo/\n\n#define numSegments 20.\n#define showSeg\n\n//black and light blue\n#define bgCol   vec3(20.)/255.\n#define lineCol vec3(133, 10.,10.)/255.\n#define segCol vec3(202.)/255.\n#define circleCol vec3(133, 10.,10.)/255.\n#define segCircleCol vec3(100.)/255.\n#define magikCol vec3(142,142,246)/255.\n\n\n/*\n//Cappacino pallet\n#define bgCol   vec3(60, 47, 47)/255.*0.5\n#define leftLineCol vec3(68, 66,133)/255.\n#define lineCol vec3(133, 68, 66)/255.\n#define segCol vec3(225, 244, 230)/255.\n#define circleCol vec3(255, 244, 230)/255.\n#define segCircleCol vec3(255, 244, 230)/255.\n#define magikCol vec3(60, 47, 47)/255.\n*/\n\n#define segThickness 0.002\n#define segRingRadius 0.003\n#define pointRingRadius 0.01\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor, float thick){\n\n    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));\n    float dist = distToLine(A, B, p);\n    dist = 1.0-smoothstep(0., fwidth(dist), dist - thick);\n    return mix(col, lineColor, dist);\n}\n\n\n\n//shorten version thx iapafo\n//original version with notes is here:https://www.shadertoy.com/view/fljGR3\n//but then I went and added a matrix version to it\nvec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){\n    vec2 g, prev = p4;\n    float dt = 1./numSegments;  \n    \n    for(float t = dt; t <= 1.+dt; t+=dt){   \n    \n    \n        //Matrix Representation\n        vec4 T = vec4(1, t, t*t, t*t*t);\n        \n        //nice looking upper triangular matrix there. \n        \n        mat4 M = mat4(1,0,0,0, \n                     -3,3,0,0, \n                      3,-6,3,0, \n                     -1,3,-3,1);\n                     \n        //I wonder what's gonna happen...             \n        vec4 Px = vec4(p4.x,p3.x,p2.x,p1.x);\n        vec4 Py = vec4(p4.y,p3.y,p2.y,p1.y);\n        \n        //in glsl vector  * vector is component wise so to get the scalar product we need to use dot\n        //when the time comes! After the initial M*T (or P*M apparently?)\n        g.x = dot(M*T,Px); // is the same as dot(P*M,T)\n        g.y = dot(Py*M,T); //I flipped them for y just to show there is no difference\n        \n        \n        //or\n        //Mix functions, much smaller\n        //g = mix(p3,p2,t);\n        //g = mix(mix(mix(p4,p3,t), g, t), \n        //            mix(g, mix(p2,p1,t), t), t);\n        \n        \n        //or \n        //Binomial\n        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);\n        \n        col = drawLine(prev,g,p,col,segCol,segThickness);\n        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);\n        prev = g;\n    }\n    return col;\n}\n\n\n//draw the hull of a bezsier part\nvec3 drawHull(float t, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec2 uv, vec3 col){\n\n//all of this must happen for each new hull\n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    vec2 dLinePoint3 = p3*t + (1.0-t)*p4;\n    \n    vec2 ddPoint1 = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    vec2 ddPoint2 = dLinePoint2*t + (1.0-t)*dLinePoint3;\n    \n    vec2 dddPoint = ddPoint1*t + (1.0-t)*ddPoint2;\n    \n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)/4.);\n    \n\n    col = drawLine(p1,p2,uv,col,lineCol*0.5,0.004);\n    col = drawLine(p2,p3,uv,col,lineCol*0.5,0.004);\n    col = drawLine(p3,p4,uv,col,lineCol*0.5,0.004);\n    col = drawLine(dLinePoint1,dLinePoint2,uv,col,lineCol*0.7,0.004);\n    col = drawLine(dLinePoint2,dLinePoint3,uv,col,lineCol*0.7,0.004);\n    col = drawLine(ddPoint1,ddPoint2,uv,col,lineCol,0.004);\n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p4, col, lineCol);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint3, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint2, col, circleCol);\n        \n    return col;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n   \n    float xOff =0.4, yOff=1.2, zOff=2.6, wOff=3.;\n    float eps = 1./min(iResolution.x, iResolution.y);\n    \n    \n    //Original Bezier\n    vec2 p1 = vec2(-0.6, -0.3) + vec2(sin(iTime/2.+xOff),cos(iTime/2.+xOff))/5.;\n    vec2 p2 = vec2(-0.5, 0.3) + vec2(sin(iTime+yOff),cos(iTime+yOff))/10.;\n    vec2 p3 = vec2(0.5, 0.3) + vec2(sin(iTime+zOff),cos(iTime+zOff))/7.;\n    vec2 p4 = vec2(0.1, -0.2) + vec2(sin(iTime/2.+wOff),cos(iTime/2.+wOff))/2.;\n    \n    \n    //All the possible split values for only one split (0. to 1 )\n    float splitPoint = fract(iTime)/numSegments;\n    \n    //an animated t so we see all the values and how the hull moves\n    float t = sin(iTime/2.)*0.5+0.5;\n    \n    vec3 col = bgCol;\n    \n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)/4.);\n    \n    \n    //Determining the Hull points of the first half of the bezier Curve\n    //Matrix Representation\n    \n    //the cubic function\n    vec4 T = vec4(1, t, t*t, t*t*t);\n        \n    //cooefficient matrix\n    //nice looking upper triangular matrix there. \n    mat4 M = mat4(1,0,0,0, \n                  -3,3,0,0, \n                  3,-6,3,0, \n                  -1,3,-3,1);\n                     \n    //I wonder what's gonna happen...             \n    vec4 px = vec4(p4.x,p3.x,p2.x,p1.x);\n    vec4 py = vec4(p4.y,p3.y,p2.y,p1.y);\n        \n    mat4 Mi = inverse(M);\n    \n    float z = 0.5+sin(iTime)*0.3;\n    \n    if(iMouse.z > 0.0){\n        z = 1.0-iMouse.x/iResolution.x;\n    }\n    //the Z matrix that comes from going only from 0 to z instead of 0 to 1\n    mat4 Z = mat4(1.,0.,0.,0.,\n                  0.,z,0.,0.,\n                  0.,0.,z*z,0.,\n                  0.,0.,0.,z*z*z);\n   \n   //B(t) = vt*Z*M*vp = vt*M*Mi*Z*M*vp \n   //Q = Mi*Z*M   so...\n   //B(t) = vt*M*Q*vp \n   //and the matrix form of a bezier curve is vt*M*vp \n   //so we jsut do vt*M*[Q*vp] and [Q*vp] are the new coordinates!\n   \n   vec4 vpx = px*(M*Z*Mi);\n   vec4 vpy = py*(M*Z*Mi);\n   \n   vec2 pp1 = vec2(vpx.r,vpy.r);\n   vec2 pp2 = vec2(vpx.g,vpy.g);\n   vec2 pp3 = vec2(vpx.b,vpy.b);\n   vec2 pp4 = vec2(vpx.a,vpy.a);\n  \n        \n    col = drawHull(t,pp1,pp2,pp3,pp4,uv,col);\n    col = drawSegments(uv, pp1, pp2, pp3, pp4, col);\n    \n    \n    //\n    //Repeat all of that but with the Zprimg matrix that descibes the other half\n    \n    // T prime is [1, (z+(1-z)*t), (z+(1-z)*t)*(z+(1-z)*t), (z+(1-z)*t)*(z+(1-z)*t)*(z+(1-z)*t))]\n    \n    //that because:\n    //ok this is a bezier function with two variables\n    //z is an offset, t is an input that will varie from 0 to 1 sa usual \n    //but it's contrained between z and 1\n    // z +(1-z)*t the percentage of t = z + the percentage of t that \n    // for example, with z = 0.5 and t = 0.2: (0.5 + (1 - 0.5)*0.2 = 0.6\n    //basically the prportion is thesame but it is scaled to the room beyond z\n    //AND offset by z. Pretty cool.\n    //Then this happends for every t term in the curve with the matching order(exponent)\n   \n   \n    //now we take z out of t and give it it's own matrix by expanding every component\n    //and using the terms as matrix entries and the order determins the row,\n    //just like in the first Z matrix\n    \n    //and the exansion follows basically all the patterns from 1, to linear to quadratic to cubic\n    \n    // 1, =                              1,0,0,0\n    \n    // z+(1-z))=                         z, (1-z), 0, 0\n    \n    // z+(1-z))(z+(1-z))=                z*z, 2*z*(1-z), (1-z)*(1-z), 0\n    \n    // z+(1-z))*(z+(1-z))*(z+(1-z))) =   z*z*z, 3*z*(1-z)*(1-z), 3*(1-z)*z*z, (1-z)*(1-z)*(1-z)\n    \n    mat4 Zprime = mat4(1.,  z,        z*z,             z*z*z,\n                       0.,  (1.-z),   2.*z*(1.-z),       3.*z*z*(1.-z),\n                       0.,   0.,      (1.-z)*(1.-z),   3.*z*(1.-z)*(1.-z),\n                       0.,   0.,      0.,              (1.-z)*(1.-z)*(1.-z));\n\n    //the order of every column in this matrix is critical\n    //it needs to be exactly as it would come out of an expansion from the binomial\n    \n    //Awesome, now calculate the points for the first half(should be second?)\n    \n    vpx = px*(M*Zprime*Mi);\n    vpy = py*(M*Zprime*Mi);\n   \n    pp1 = vec2(vpx.r,vpy.r);\n    pp2 = vec2(vpx.g,vpy.g);\n    pp3 = vec2(vpx.b,vpy.b);\n    pp4 = vec2(vpx.a,vpy.a);\n  \n        \n    col = drawHull(t,pp1,pp2,pp3,pp4,uv,col);\n    col = drawSegments(uv, pp1, pp2, pp3, pp4, col);\n    \n    //col = drawSegments(uv, p1, p2, p3, p4, col);\n    col = drawRing(0.02+(0.01+sin(iTime*4.)*0.01), 0.003, uv, pp1, col, magik_farber);\n    \n    col = pow(col, vec3(0.75));\n    //vignett from ApoorvalJ https://www.shadertoy.com/view/4lSXDm\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig*1.1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lS3WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[888, 888, 929, 929, 1131], [1133, 1133, 1220, 1220, 1452], [1454, 1454, 1531, 1602, 1739], [1743, 1899, 1971, 1971, 3377], [3380, 3414, 3492, 3537, 4891], [4894, 4894, 4951, 5001, 9969]], "test": "untested"}
{"id": "NtSGWG", "name": "Arbitrary space-time ray tracer", "author": "michael0884", "description": "Using a hamiltonian based integrator to compute geodesics in arbitrary metrics.\nBasically the initial mode is a kerr black hole in looped space.\nYou can chage the params of the BH and/or switch to a warp drive metric(need to restart the sim to find it)\n", "tags": ["camera"], "likes": 25, "viewed": 11309, "published": 3, "date": "1624639878", "time_retrieved": "2024-07-30T19:14:07.305336", "image_code": "// Fork of \"Schwarzschild black hole\" by michael0884. https://shadertoy.com/view/ftBGWm\n// 2021-06-21 11:20:36\n\nvec3 saturate(vec3 c)\n{\n    return tanh(pow(c,vec3(0.55)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(saturate(acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force =175.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = normalize(vec3(1,2,0))*16.1;\n        ca = aa2q( normalize(vec3(1,0,0.)), PI*3.0/4.0);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.5\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\n\nmat4 diag(vec4 a)\n{\n    return \n    mat4(a.x,0,0,0,\n         0,a.y,0,0,\n         0,0,a.z,0,\n         0,0,0,a.w);\n}\n\n//optimized inverse of symmetric matrix\nmat4 inverse_sym(mat4 m) {\n\tfloat n11 = m[0][0], n12 = m[1][0], n13 = m[2][0], n14 = m[3][0];\n\tfloat n22 = m[1][1], n23 = m[2][1], n24 = m[3][1];\n\tfloat n33 = m[2][2], n34 = m[3][2];\n\tfloat n44 = m[3][3];\n\n\tfloat t11 = 2.0 * n23 * n34 * n24 - n24 * n33 * n24 - n22 * n34 * n34 - n23 * n23 * n44 + n22 * n33 * n44;\n\tfloat t12 = n14 * n33 * n24 - n13 * n34 * n24 - n14 * n23 * n34 + n12 * n34 * n34 + n13 * n23 * n44 - n12 * n33 * n44;\n\tfloat t13 = n13 * n24 * n24 - n14 * n23 * n24 + n14 * n22 * n34 - n12 * n24 * n34 - n13 * n22 * n44 + n12 * n23 * n44;\n\tfloat t14 = n14 * n23 * n23 - n13 * n24 * n23 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\tfloat det = n11 * t11 + n12 * t12 + n13 * t13 + n14 * t14;\n\tfloat idet = 1.0f / det;\n\n\tmat4 ret;\n\n\tret[0][0] = t11 * idet;\n\tret[0][1] = (n24 * n33 * n14 - n23 * n34 * n14 - n24 * n13 * n34 + n12 * n34 * n34 + n23 * n13 * n44 - n12 * n33 * n44) * idet;\n\tret[0][2] = (n22 * n34 * n14 - n24 * n23 * n14 + n24 * n13 * n24 - n12 * n34 * n24 - n22 * n13 * n44 + n12 * n23 * n44) * idet;\n\tret[0][3] = (n23 * n23 * n14 - n22 * n33 * n14 - n23 * n13 * n24 + n12 * n33 * n24 + n22 * n13 * n34 - n12 * n23 * n34) * idet;\n\n\tret[1][0] = ret[0][1];\n\tret[1][1] = (2.0 * n13 * n34 * n14 - n14 * n33 * n14 - n11 * n34 * n34 - n13 * n13 * n44 + n11 * n33 * n44) * idet;\n\tret[1][2] = (n14 * n23 * n14 - n12 * n34 * n14 - n14 * n13 * n24 + n11 * n34 * n24 + n12 * n13 * n44 - n11 * n23 * n44) * idet;\n\tret[1][3] = (n12 * n33 * n14 - n13 * n23 * n14 + n13 * n13 * n24 - n11 * n33 * n24 - n12 * n13 * n34 + n11 * n23 * n34) * idet;\n\n\tret[2][0] = ret[0][2];\n\tret[2][1] = ret[1][2];\n    ret[2][2] = (2.0 * n12 * n24 * n14 - n14 * n22 * n14 - n11 * n24 * n24 - n12 * n12 * n44 + n11 * n22 * n44) * idet;\n\tret[2][3] = (n13 * n22 * n14 - n12 * n23 * n14 - n13 * n12 * n24 + n11 * n23 * n24 + n12 * n12 * n34 - n11 * n22 * n34) * idet;\n\n\tret[3][0] = ret[0][3];\n\tret[3][1] = ret[1][3];\n\tret[3][2] = ret[2][3];\n\tret[3][3] = (2.0 * n12 * n23 * n13 - n13 * n22 * n13 - n11 * n23 * n23 - n12 * n12 * n33 + n11 * n22 * n33) * idet;\n\n\treturn ret;\n}\n\nfloat sphIntersect(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0)\n        return 1e10;\n    return -b - sqrt(h);\n}\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n\nconst float PI2 = 6.2831853071;\n\n// Valid from 1000 to 40000 K (and additionally 0 for pure full white)\nvec3 colorTemperatureToRGB(const in float temperature){\n  // Values from: http://blenderartists.org/forum/showthread.php?270332-OSL-Goodness&p=2268693&viewfull=1#post2268693   \n  mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\n\t                                      vec3(0.0, 1669.5803561666639, 2575.2827530017594),\n\t                                      vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \n\t \t\t\t\t\t\t\t\t mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\n   \t                                      vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\n\t                                      vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), vec3(1.0), smoothstep(1000.0, 0.0, temperature));\n}\n\n", "buffer_b_code": "#define SPP 1\n\nconst float cdist = 120.0;\n\n//#define RK4\n//#define WARP_DRIVE\n//#define LOOPED_SPACE\n\nconst float eps = 0.005;\nconst vec2 dq = vec2(0, eps);\nfloat dt = 0.03;\n\n//kerr params\nfloat a = -0.;\nfloat m = 1.0;\nfloat Q = 0.0;\n\n//warp params\nfloat R = 1.0, sig = 35.0; \nfloat v = 1.1;\n\n//enter metric here\nmat4 G(vec4 q)\n{\n#ifdef WARP_DRIVE\n    //Alcubierre metric  \n    float x = v*q.x;\n    float r = sqrt(sqr(q.y - x) + q.z*q.z + q.w*q.w);\n    float f = 0.5*(tanh(sig*(r + R)) - tanh(sig*(r - R)))/tanh(sig*R);\n    float gtt = v*v*f*f - 1.0;\n    float gxt = -v*f;\n    \n    return mat4(gtt, gxt,  0,  0,\n                gxt,   1,  0,  0,\n                  0,   0,  1,  0,\n                  0,   0,  0,  1);\n#else\n    //Kerr metric in Kerr-Schild coordinates \n    vec3 p = q.yzw;\n    float rho = dot(p,p) - a*a;\n    float r2 = 0.5*(rho + sqrt(rho*rho + 4.0*a*a*p.z*p.z));\n    float r = sqrt(r2);\n    vec4 k = vec4(1, (r*p.x + a*p.y)/(r2 + a*a), (r*p.y - a*p.x)/(r2 + a*a), p.z/r);\n    float f = smoothstep(cdist*0.5, 0.0, r)*r2*(2.0*m*r - Q*Q)/(r2*r2 + a*a*p.z*p.z);\n    return f*mat4(k.x*k, k.y*k, k.z*k, k.w*k)+diag(vec4(-1,1,1,1));    \n#endif\n    \n}\n\n//variable timestep in space-time and stop condition\nbool variDT(vec4 P, vec4 q)\n{\n#ifdef WARP_DRIVE\n    //Alcubierre metric  \n    float x = v*q.x;\n    float r = sqrt(sqr(q.y - x) + q.z*q.z + q.w*q.w);\n    dt = mix(0.03, 10.0, pow(max(r - R, 0.0)/cdist,1.));\n#else\n    //Kerr metric in Kerr-Schild coordinates \n    vec3 p = q.yzw;\n    float rho = dot(p,p) - a*a;\n    float r2 = 0.5*(rho + sqrt(rho*rho + 4.0*a*a*p.z*p.z));\n    float r = sqrt(r2);\n    dt = mix(0.03, 10.0, pow(max(r - 1.0, 0.0)/cdist,1.));\n    if(r < 1. && a <= 1.0 || length(P) > 45.0) return true;\n#endif\n\n    if(length(q.yzw) > cdist) return true;\n    return false;\n}\n\n//lagrangian\nfloat L(vec4 qt, mat4 g)\n{\n    return dot(g*qt,qt);\n}\n\nfloat L(vec4 qt, vec4 q)\n{\n    mat4 g = G(q);\n    return L(qt, g);\n}\n\n//vector to momentum at point q\nvec4 Vec2P(vec3 v, vec3 x)\n{\n    return 2.0*G(vec4(0.0, x))*vec4(1.0, v); \n}\n\nvec4 P2Vec(vec4 p, vec4 q)\n{\n    return inverse_sym(G(q))*p;\n}\n\nfloat H(vec4 p, mat4 ginv)\n{\n    //general geodesic hamiltonian\n    return dot(ginv*p,p);\n}\n\nfloat H(vec4 p, vec4 q)\n{\n    mat4 g = G(q);\n    mat4 ginv = inverse_sym(g);//slow\n    return H(p, ginv);\n}\n\n//get left side of the equation system\nvoid dH(vec4 p, vec4 q, out vec4 dHdq, out vec4 dHdp)\n{\n    mat4 g = G(q);\n    mat4 ginv = inverse_sym(g);//slow\n    \n    dHdp = 2.0*vec4(dot(ginv[0], p), dot(ginv[1], p), dot(ginv[2], p), dot(ginv[3], p));\n    dHdq = (vec4(H(p, q + dq.yxxx),H(p, q + dq.xyxx),H(p, q + dq.xxyx),H(p, q + dq.xxxy)) - H(p, ginv))/eps; \n}\n\n\n//state of a space-time ray is in mat2x4\n\n//step\nmat2x4 dhstep(in mat2x4 s, float dt)\n{\n    vec4 p = s[0], q = s[1];\n    \n    mat4 g = G(q);\n    mat4 ginv = inverse_sym(g);//slow\n    vec4 qt = ginv*p;\n    \n    vec4 dHdq = -(vec4(L(qt,q+dq.yxxx),L(qt,q+dq.xyxx),L(qt,q+dq.xxyx),L(qt,q+dq.xxxy))-L(qt, g))/eps; \n    \n    mat2x4 dqp;\n    dqp[0] = -dHdq*dt;\n#ifndef RK4\n   // p += dqp[0];\n#endif\n    dqp[1] = 2.0*ginv*p*dt;\n    \n    return dqp;\n}\n\n//Hamilton's equations simple integration step\nvoid hstep(inout vec4 p, inout vec4 q)\n{    \n    float dt1 = clamp(1. / length(p),0.1,4.0);\n    \n    mat2x4 state = mat2x4(p, q); \n    \n    mat2x4 dqp = dhstep(state, dt1*dt);\n    \n    state += dqp;\n    \n    p = state[0];\n    q = state[1];\n}\n\n\n//runge kutta 4th order integration scheme\nvoid hstepRK4(inout vec4 p, inout vec4 q)\n{    \n    float dt1 = dt*clamp(1. / length(p),0.1,4.0);\n    \n    mat2x4 state = mat2x4(p, q); \n\n    mat2x4 k1 = dhstep(state, dt1);\n    mat2x4 k2 = dhstep(state + 0.5*k1, dt1);\n    mat2x4 k3 = dhstep(state + 0.5*k2, dt1);\n    mat2x4 k4 = dhstep(state + k3, dt1);\n    \n    state += (k1 + 2.0*k2 + 2.0*k3 + k4)/6.0;\n\n    p = state[0];\n    q = state[1];\n}\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    vec2 apert_cent = -0.*uv;\n    \n    vec2 ap = aperture();\n    \n    if(!(distance(ap, apert_cent) < 1.0)) return false;\n    \n    float apd = length(ap);\n    \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1];\n    \n    ro = get(CamP).xyz + aperture_size*daperture;\n  \n    float focus =2.5 + 0.8*pow(apd,5.0);\n\n   \n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    \n    return true;\n}\n\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += nrand2(0.5, vec2(0.));\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    vec3 fcol = vec3(0.0);\n    \n    float t0 = sphIntersect(cp, rd, vec4(0,0,0,cdist));\n    if(t0 > 0.0 && t0 < 1e10) cp += rd*t0;\n    \n    vec4 Q = vec4(0., cp + 0.*rd*rand());\n    vec4 P = normalize(Vec2P(rd, Q.yzw));\n    \n    float p0 = P.x;\n    \n    int j = 0; \n        \n    for(int i = 0; i <128; i++)\n    {\n    #ifdef RK4\n        hstepRK4(P, Q);\n    #else\n        hstep(P, Q);\n    #endif\n    \n    #ifdef LOOPED_SPACE\n        Q.yzw = mod(Q.yzw + vec3(50.0), vec3(100.0)) - vec3(50.0);\n    #endif\n        if(variDT(P,Q)) break;\n    }\n    \n    vec4 qt = P2Vec(P,Q);\n    rd = normalize(qt.yzw);\n    \n    float p1 = P.x;\n    float redshift = p0/p1; \n    \n    if(length(Q.yzw) > 3.0)\n        fcol = 3.0*pow(texture(iChannel1, rd).xyz,vec3(2.0)) * \n        pow(colorTemperatureToRGB(6700.0*redshift), vec3(10.0))*redshift;\n    \n    return vec4(fcol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    a = 1.0;\n    m = 1.0;\n    Q = 0.0;//(0.5*sin(iTime)+0.5);\n    sig = 15.;//*(0.5*sin(iTime)+0.5);\n    //prev \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy)*0.1;\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSGWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 135, 135, 173], [175, 175, 232, 232, 347]], "test": "untested"}
{"id": "Nl2GWy", "name": "Spherical Shell with Slits (3)", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/Nt2GWy[/url]\nantialiased + ray-traced + golfed variant of \"Spherical Shell with Slits\" by Kamoshika. [url]https://shadertoy.com/view/Nt2GWG[/url]", "tags": ["raymarching", "sphere", "short"], "likes": 11, "viewed": 285, "published": 3, "date": "1624629631", "time_retrieved": "2024-07-30T19:14:08.135118", "image_code": "// variant of https://shadertoy.com/view/Nt2GWy\n// antialiased + ray-traced + golfed variant of \"Spherical Shell with Slits\" by Kamoshika. https://shadertoy.com/view/Nt2GWG\n\n\n                                      // distance to strips + AA blending\n#define S(s) P = vec3(0, 0, 5) + ( s sqrt(r) - b ) * D,                    \\\n             a = acos(P.y/2.) - sign(P.z)* acos(P.x/length(P.zx)) - iTime, \\\n             d = sin(a/.1),   d =  1.- d/fwidth(d),                        \\\n             O += ( clamp(1.+ s abs(d-1.),0.,1.) -O ) * clamp( d, 0.,1. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3  P = iResolution,\n          D =  normalize( vec3( ( u+u - P.xy ) / P.y, -2 ) );\n    float b = 5.*D.z, r = b*b-21., a,d;\n    O-=O;\n    r > 0. ? S( ), // *(1.+P.z/3.),   // back sphere  \n             S(-)                     // front sphere\n           : O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2GWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Nt2GWy", "name": "Spherical Shell with Slits (AA+g", "author": "FabriceNeyret2", "description": "antialiased + ray-traced + golfed variant of \"Spherical Shell with Slits\" by Kamoshika. [url]https://shadertoy.com/view/Nt2GWG[/url]", "tags": ["raymarching", "sphere", "short"], "likes": 10, "viewed": 354, "published": 3, "date": "1624628529", "time_retrieved": "2024-07-30T19:14:08.894088", "image_code": "// antialiased + ray-traced + golfed variant of \"Spherical Shell with Slits\" by Kamoshika. https://shadertoy.com/view/Nt2GWG\n// 2021-06-25 13:38:48   ( 703 chars )\n\n                                      // distance to strips + AA blending\n#define S(s,C) P = vec3(0, 0, 5) + ( s sqrt(r) - b ) * D,                    \\\n               a = acos(P.y/2.) - sign(P.z)* acos(P.x/length(P.zx)) - iTime, \\\n               d = sin(a/.1),                                                \\\n               O = mix(O, C, clamp( 1.- d/fwidth(d), 0.,1. ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec3 P = iResolution,\n         D =  normalize( vec3( ( u+u - P.xy ) / min(P.x, P.y), -2 ) );\n\n    float b = 5.*D.z, r = b*b-21., a,d;\n    O-=O;\n    if (r < 0.) return;                                                  // out of sphere     \n    S( , ( .5 +  .7* cos( a  + vec4(0,23,21,0)  ) ) * (.5+P.z*P.z/4.) ); // back sphere\n    S(-,  vec4(P.z*P.z/2.) );                                            // front sphere\n}\n\n\n\n\n\n\n\n/* // --- 404 chars\n\n           // distance to strips\n#define S  a = acos(P.y/2.) -sign(P.z)* acos(P.x/length(P.zx)) - iTime, \\\n           d = sin(a/.1) \n           \n#define A  clamp( 1.- (d-3e-5)/fwidth(d), 0.,1.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    vec3 P = vec3(0, 0, 5),\n         D =  normalize( vec3( ( u+u - R) / min(R.x, R.y), -2 ) );\n\n    float b = 5.*D.z, r = b*b-21., a,d;\n    O-=O;\n    if (r < 0.) return;                // out of sphere\n    \n    r = sqrt(r);\n    P += ( r - b ) * D; S;             // intersection on back sphere\n    O += ( .5 +  .7* cos( a  + vec4(0,23,21,0)  ) )  * A * (.5+P.z*P.z/4.);\n\n    P -= 2.*r * D; S;                  // intersection on front sphere\n    O = mix(O, vec4(P.z*P.z/2.), A );   \n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2GWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tS3Dy", "name": "polyhedron Frame", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 13, "viewed": 442, "published": 3, "date": "1624610223", "time_retrieved": "2024-07-30T19:14:09.771741", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,n=vec3(-.5,-.707,.5),\n    d=normalize(vec3((C-.5*r.xy),r.y));  \n    for(float i=0.,e,g=0.;\n        ++i<99.;\n        O.xyz+=mix(vec3(1),H(length(p)*.5+iTime*3.),.7)*.05*exp(-.03*i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=10.;\n        p=R(p,normalize(vec3(-1,-2,2)),iTime*.5);\n        for(int j=0;j<4;j++)\n            p.xy=abs(p.xy),\n            p-=2.*min(0.,dot(p,n))*n;\n        p.z=fract(log(p.z)-iTime*.5)-.5;\n        g+=e=abs(min(length(p.yz),length(p.xz))-.03)+.001;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 664]], "test": "untested"}
{"id": "7tBGDy", "name": "XOR Towers Explorer - 265 chars", "author": "GregRostami", "description": "Another variation of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]\nUse the mouse to fly around this endless fractal cityscape.\nI really don't know how this shader animates without ANY time variables!?", "tags": ["3d", "fractal", "xor", "short", "2tc"], "likes": 6, "viewed": 368, "published": 3, "date": "1624608238", "time_retrieved": "2024-07-30T19:14:10.629448", "image_code": "// 265 chars - Thanks to Fabrice Neyret this shader is a LOT smaller!\nvoid mainImage(out vec4 o, vec2 u)\n{ \n  ivec4 b = ivec4(o -= o);\n  u = 2.*(u+u-R)/R.y;\n  \n  for (; (b.x^b.y^b.z)%99 > b.z-8 ; )\n    b = ivec4(u * o.a + T, o+=.1 ); \n    \n  o = o/70. - .02*vec4(b%3);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27675, "src": "https://soundcloud.com/sanya89/jean-michel-jarre-04-en-attendant-cousteau", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "void mainImage( out vec4 o,vec2 u )\n{ o.xy =  abs(T + iMouse.xy / R - .5); }", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T texture(iChannel0,u).xy//\n#define R iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 70, 106, 106, 270]], "test": "untested"}
{"id": "7lSGDy", "name": "Spiral tentacles", "author": "gormonboza", "description": "Polar coordinates", "tags": ["polar"], "likes": 8, "viewed": 368, "published": 3, "date": "1624607889", "time_retrieved": "2024-07-30T19:14:11.382435", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = vec4(.0);\n\n\tvec2 res = iResolution.xy;\n\n\n\t//------ create polar coordinates -----\n\n\tvec2 nUV = (uv - .5) * res / res.y * 1.3;\n\n\tvec2 V = normalize(nUV);\n\n\tvec2 refV = vec2(1., 0.);\n\n\tfloat cosA = dot(refV, V);\n\n\tfloat alpha = acos(cosA);\n\n\talpha = alpha * step(.0, nUV.y) + (radians(360.) - alpha) * step(nUV.y, .0); // full 2PI circle\n\n\t//--------------------------------------\n\n\tfloat alphaP = alpha + length(nUV) * 16. / exp(length(nUV));\n\n\tfloat edge = cos(alphaP * 5. + iTime * 3.);\n\n\tedge += 1.;\n\n\tedge /= 2.;\n\n\tedge *= length(nUV) * exp(length(nUV) / 3.);\n\n\tvec3 rainbow;\n\n\trainbow.r = (sin(alphaP - edge * 20. - iTime * 10. + radians(360.) * 0. / 360.) + 1.) / 2.;\n\trainbow.g = (sin(alphaP - edge * 20. - iTime * 10. + radians(360.) * 120. / 360.) + 1.) / 2.;\n\trainbow.b = (sin(alphaP - edge * 20. - iTime * 10. + radians(360.) *240. / 360.) + 1.) / 2.;\n\n\n\n\tcolor.rgb = rainbow * edge;\n\n\tcolor.a = 1.;\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1125]], "test": "untested"}
{"id": "7tSGDy", "name": "Spiral tunnel", "author": "gormonboza", "description": "Polar coordinates", "tags": ["polar"], "likes": 9, "viewed": 307, "published": 3, "date": "1624607398", "time_retrieved": "2024-07-30T19:14:12.717865", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 color = vec4(.0);\n\n\tvec2 res = iResolution.xy;\n\n\n\t//------ create polar coordinates -----\n\n\tvec2 nUV = (uv - .5) * res / res.y;\n\n\tvec2 V = normalize(nUV);\n\n\tvec2 refV = vec2(1., 0.);\n\n\tfloat cosA = dot(refV, V);\n\n\tfloat alpha = acos(cosA);\n\n\talpha = alpha * step(.0, nUV.y) + (radians(360.) - alpha) * step(nUV.y, .0); // full 2PI circle\n\n\t//--------------------------------------\n\n\tfloat alphaP = alpha * 2. + length(nUV) * 7. * (1. + sin(iTime / 3.) * .4);\n\tfloat alphaM = alpha * 3. - length(nUV) * 5. * (1. + cos(iTime / 4.) * .5);\n\n\tfloat edge = cos(alphaP * 3. - iTime * 7.) * sin(alphaM * 3. + iTime * 5.);\n\n\tedge += 1.;\n\n\tedge /= 1.;\n\n\tedge *= length(nUV)  + .1;\n\n\tvec3 rainbow;\n\n\trainbow.r = (sin(iTime / 2. + edge * 16. + radians(360.) * 0. / 360.) + 1.) / 2.;\n\trainbow.g = (sin(iTime / 3. + edge * 16. + radians(360.) * 120. / 360.) + 1.) / 2.;\n\trainbow.b = (sin(iTime / 4. + edge * 16. + radians(360.) * 240. / 360.) + 1.) / 2.;\n\n\tcolor.rgb = rainbow * edge;\n\n\tcolor.a = 1.;\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1145]], "test": "untested"}
{"id": "slS3WG", "name": "Morphing discs", "author": "jarble", "description": "These discs morph in a shutter-like pattern.", "tags": ["fractal", "metal", "shiny", "iridescent"], "likes": 3, "viewed": 222, "published": 3, "date": "1624583825", "time_retrieved": "2024-07-30T19:14:13.804958", "image_code": "#define ITERS 12\nconst float scale = -1.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/9.0;\n    float s1 = (uv.y+iTime/2.)/8.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv.y /= scale;\n            uv = (uv+vec2(s1+uv.x-uv.y)/scale);\n            //uv.y -= col.x/16.;\n            uv.x *= -scale;\n            \n            uv = fract(uv.yx);\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/1.75;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slS3WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 101, 101, 692]], "test": "untested"}
{"id": "7tS3WG", "name": "Glowing confetti", "author": "jarble", "description": "A shower of brightly-colored objects.", "tags": ["fractal", "confetti"], "likes": 3, "viewed": 275, "published": 3, "date": "1624582433", "time_retrieved": "2024-07-30T19:14:14.635736", "image_code": "#define ITERS 12\nconst float scale = -1.3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/9.0;\n    float s1 = (uv.y*4.+iTime)/32.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv.y /= scale;\n            uv = (uv+vec2(s1-uv.x+uv.y)/scale);\n            //uv.y -= col.x/16.;\n            uv.x *= -scale*1.01;\n            \n            uv = fract(uv.yx);\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/1.75;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3WG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 101, 101, 698]], "test": "untested"}
{"id": "flS3Dy", "name": "Limacon Intersection 2D II", "author": "oneshade", "description": "Even more generalized version of my limacon intersector. Except now its not technically a limacon.\nI've changed my mind about the formulation, anyway I'd rather not reformulate it :D", "tags": ["intersection", "trigonometric", "quartic", "trochoid", "generalized", "limacon", "uglycode"], "likes": 15, "viewed": 180, "published": 3, "date": "1624574613", "time_retrieved": "2024-07-30T19:14:15.596169", "image_code": "// Convenience struct\nstruct Hit4 {\n    int nHit;\n    vec2[4] pHit;\n};\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sqLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    vec2 toProj = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return dot(toProj, toProj);\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n// Parametric equation\nvec2 posLimacon(in float t, in float alpha, in float beta) {\n    float t2 = 2.0 * t;\n    return vec2(cos(t2) + alpha * cos(t),\n                sin(t2) +  beta * sin(t));\n}\n\n// Intersection\nint solveReducedQuartic(in float b, in float c, in float d, in float e, inout vec4 roots) {\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d -   0.5 * b * c + 0.125 * bb * b;\n    float r = e -  0.25 * b * d +         bb * c / 16.0 - 3.0 * bb * bb / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = (ra * ra / 4.5 - rb) * ru + rc;\n\n    float lambda;\n    float sp = sqrt(3.0 / abs(rp)), k = 1.5 * rq * sp / rp;\n    if (rp * rp * rp + 6.75 * rq * rq > 0.0) {\n        if (rp < 0.0) lambda = cosh(acosh(abs(k)) / 3.0) * sign(rq);\n        else lambda = sinh(asinh(k) / 3.0);\n        lambda /= -sp;\n    }\n\n    else lambda = cos(acos(k) / 3.0) / sp;\n    lambda = 2.0 * lambda - ru;\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\nHit4 iLimacon(in vec2 ro, in vec2 rd, in float alpha, in float beta) {\n    Hit4 isect = Hit4(0, vec2[4](vec2(0.0), vec2(0.0), vec2(0.0), vec2(0.0)));\n\n    vec2 uv = normalize(rd);\n    float y = ro.x * uv.y - ro.y * uv.x; // Rotate ray so its parallel and we can solve for y only\n                                         // instead of a trigonometric system (trig was meant for geometry! not algebra)\n\n    float u = 0.5 * atan(rd.y, rd.x); // Translation in x to reduce\n    float s = length(vec2(beta, alpha) * uv); // Amplitude of cosine (\"s\" for scale)\n    float o = atan(beta * uv.x, alpha * uv.y) + u; // Offset of cosine\n    float sso = s * sin(o);\n\n    float b = sso;\n    float c = 0.25 * s * s - 1.0;\n    float d = -sso - 0.5 * y * s * cos(o);\n    float e = 0.25 * (y * y - sso * sso);\n\n    vec4 roots;\n    isect.nHit = solveReducedQuartic(b, c, d, e, roots);\n    for (int n=0; n < isect.nHit; n++) {\n        float t = acos(roots[n]); // Undo change of variable to cos(x)\n\n        // \"Manually\" select sign because acos() gives abs(cosineRoot)\n        // (asin() is even more irrational, it sometimes gives sineRoot or π-sineRoot)\n        t *= sign(abs(s * cos(t + o) - sin(2.0 * t) - y) - abs(s * cos(t - o) + sin(2.0 * t) - y));\n        t -= u; // Undo change of variable to t+u\n\n        float t2 = 2.0 * t;\n        isect.pHit[n] = vec2(cos(t2) + alpha * cos(t), -sin(t2) - beta * sin(t));\n    }\n\n    return isect;\n}\n\n// Animation\nvec2 Hash12(in float t) {\n\tvec3 p3 = fract(t * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec4 getRay(in float t) {\n    float id = floor(t), local = fract(t);\n    vec2 a = Hash12(id), b = Hash12(id + 1.0), c = Hash12(id + 2.0);\n    vec2 mid1 = 0.5 * (a + b), mid2 = 0.5 * (b + c);\n\n    float tInv = 1.0 - local;\n    vec2 pos = mid1 * tInv * tInv + 2.0 * b * tInv * local + mid2 * local * local;\n    vec2 dir = normalize(mid1 * (local - 1.0) + (1.0 - 2.0 * local) * b + mid2 * local);\n\n    return vec4(pos, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 8.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float animTime = 0.5 * iTime;\n    float alpha = 2.5 * sin(animTime);\n    float beta = 2.5 * cos(animTime);\n\n    // Because this is my favorite shape it makes :)\n    float trefoilTransition = 0.5 + 0.5 * sin(0.1 * iTime);\n    alpha = mix(alpha, -1.35, trefoilTransition);\n    beta = mix(beta, 1.35, trefoilTransition);\n\n    vec4 ray = getRay(iTime * 0.25);\n    vec2 ro = ray.xy * 8.0 - 4.0, rd = ray.zw;\n    if (iMouse.z > 0.0) ro = mouse.zw, rd = mouse.xy - mouse.zw;\n\n    // Draw limacon\n    float limacon = 1e20;\n    vec2 prev = posLimacon(-3.14, alpha, beta);\n    float tStep = 0.1;\n    for (float t=tStep - 3.14; t < 3.14 + tStep; t += tStep) {\n        vec2 cur = posLimacon(t, alpha, beta);\n        limacon = min(limacon, sqLine(uv, prev, cur));\n        prev = cur;\n    }\n\n    drawSDF(sqrt(limacon) * 0.5 - 0.015, vec3(0.0, 0.0, 1.0));\n\n    // Draw ray\n    drawSDF(sdInfLine(uv * 0.5, ro * 0.5, (ro + rd) * 0.5) - 0.001, vec3(1.0, 0.8, 0.0));\n    drawSDF(sdVectorArrow((uv - ro) * 0.5, rd * 0.5), vec3(1.0));\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iLimacon(ro, rd, alpha, beta);\n    for (int n=0; n < hit.nHit; n++) {\n        drawSDF(length(uv - hit.pHit[n]) - 0.1, vec3(1.0, 0.0, 0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 182, 236, 236, 512], [514, 514, 561, 561, 700], [702, 702, 747, 747, 815], [817, 817, 867, 867, 936], [938, 938, 981, 981, 1169], [1171, 1194, 1254, 1254, 1365], [1367, 1383, 1474, 1666, 3239], [3241, 3241, 3311, 3311, 4666], [4668, 4681, 4706, 4706, 4835], [4837, 4837, 4862, 4862, 5260], [5262, 5262, 5317, 5317, 6839]], "test": "untested"}
{"id": "ftS3Dy", "name": "Fissures", "author": "jarble", "description": "A metallic morphing fractal.", "tags": ["fractal", "metal", "shiny", "iridescent"], "likes": 2, "viewed": 241, "published": 3, "date": "1624573083", "time_retrieved": "2024-07-30T19:14:16.543635", "image_code": "#define ITERS 12\nconst float scale = .95;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/16.)/8.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv = fract(uv.yx);\n            uv = (uv+vec2(s1-uv.x+uv.y)/scale);\n            //uv.x = scale;\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/1.75;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3Dy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 100, 100, 607]], "test": "untested"}
{"id": "NlBGDy", "name": "click on the screen", "author": "pema99", "description": "epic", "tags": ["stuff"], "likes": 0, "viewed": 156, "published": 3, "date": "1624572053", "time_retrieved": "2024-07-30T19:14:17.388377", "image_code": "// sdf for a box\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n// sdf for sphere\nfloat sdSphere(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n// main sdf\nfloat map(vec2 p)\n{\n    return sdBox(p, vec2(0.4, 0.3));\n}\n\n// get normal/gradient of sdf\nvec2 normal(vec2 p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec2(map(p+h.xy) - map(p-h.xy),\n                           map(p+h.yx) - map(p-h.yx) ) );\n}\n\n// line distance function\nfloat sdLine( vec2 p, vec2 a, vec2 b )\n{\n    vec2 v = a, w = b;\n    float l2 = pow(distance(w, v), 2.);\n    if(l2 == 0.0) return distance(p, v);\n    float t = clamp(dot(p - v, w - v) / l2, 0., 1.);\n    vec2 j = v + t * (w - v);\n    return distance(p, j);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get uv, mouse pos\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // visualize box sdf and isolines\n\tfloat d = map(p);\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    // get gradient (normal) at mouse position\n    vec2 norm = normal(mouse);\n    \n    // find circle centroid, show sphere\n    float radius = 0.1;\n    vec2 center = mouse - norm * (map(mouse) - radius);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02, abs(sdSphere(p - center, radius))) );\n    \n    // visualize gradient as line\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02, sdLine(p, mouse, mouse + norm*0.5)) );\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 17, 46, 46, 130], [132, 150, 183, 183, 209], [211, 223, 242, 242, 281], [283, 313, 334, 334, 533], [535, 561, 601, 601, 817], [819, 819, 876, 901, 1731]], "test": "untested"}
{"id": "NlSGDy", "name": "Fast Sphere", "author": "lambmeow", "description": "Attempted to create a sphere with the smallest amount of code possible\n", "tags": ["3d", "fast", "sphere"], "likes": 2, "viewed": 224, "published": 3, "date": "1624568514", "time_retrieved": "2024-07-30T19:14:18.290963", "image_code": "void mainImage(out vec4 c, vec2 u){\n    c -= c;\n    //typing the resolution will give you a free char!\n    vec2 r = vec2(90), n = (u + u - r)/ r.y;\n    float b = 1.-length(n);\n    c.r = smoothstep(.4,.41,b) * (n.x + n.y) + b;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSGDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 227]], "test": "untested"}
{"id": "st2GRd", "name": "Icosahedron frame", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 31, "viewed": 849, "published": 3, "date": "1624542856", "time_retrieved": "2024-07-30T19:14:19.184574", "image_code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution,n=vec3(-.5,-.809,.309),\n    d=normalize(vec3((C-.5*r.xy)/r.y,1));  \n    for(float i=0.,e,g=0.;\n        ++i<99.;\n        O.xyz+=mix(vec3(1),H(dot(p,p)*.5),.7)*.05*exp(-.05*i*i*e)\n    )\n    {\n        p=g*d;\n        p.z-=10.;\n        p=R(p,normalize(vec3(1,2,2)),iTime*.5);\n        for(int j=0;j<5;j++)\n            p.xy=abs(p.xy),\n            p-=2.*min(0.,dot(p,n))*n;\n        p.z=fract(log(p.z)-iTime*.5)-.5;\n        g+=e=length(p.yz)-.01;\n        // Dodecahedron Frame\n        //g+=e=length(p.xz)-.01;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2GRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 142, 142, 691]], "test": "untested"}
{"id": "7lj3Rt", "name": "Blinn Specular Model w/ RayMarch", "author": "muio", "description": "A bare-bones implementation of blinn specular model (which is based on phong's shading model) using ray-marching and SDFs.", "tags": ["raymarching", "sdf", "blinn"], "likes": 1, "viewed": 247, "published": 3, "date": "1624540385", "time_retrieved": "2024-07-30T19:14:19.935566", "image_code": "/// Possible things one could add to this:\n/// * Rays should attenuate the further away they get from the camera.\n\n\n// Based on what I read from: https://paroj.github.io/gltut/Illumination/Tut11%20BlinnPhong%20Model.html\n\n//  Apparently, Blinn's model needs material.alpha to be higher than Phong's model\n// to create the same effect. I concluded this by comparing this with the one which\n// this shader is forked from\n\n// Colors should be in standard rgb format: 0. < rgb < 1.\n\n#define MAX_MARCH_STEPS (1<<7)\n#define MAX_MARCH_DIST 100.\n#define SURF_DIST_MARCH .01\n#define EULER_APPROX_OFFSET .003\n\nstruct Sphere {\n    vec3 o;\n    float r;\n};\n\nstruct PhongMaterial {\n    vec3 albedo;\n    float ks, kd, ka, alpha;\n};\n\nstruct PointLight {\n    vec3 pos;\n    vec3 col;\n};\n\n\nconst Sphere s = Sphere(vec3(0, 1, 6), 1.);\nconst PointLight light = PointLight(vec3(0, 5, 6),\n                                    vec3(1.000,0.878,0.878));\nconst PhongMaterial sphereMaterial = PhongMaterial(vec3(0.9,.3,0.94), \n                                                   .33, .64, .3, 64.);\nconst PhongMaterial globalMaterial = PhongMaterial(vec3(.4, .9, 1.), \n                                                   .1, .7, .2, 8.);\nconst PhongMaterial mats[2] = PhongMaterial[](globalMaterial, \n                                              sphereMaterial);\n                                                   \nconst vec3 rayOrigin = vec3(0, 1, 1);\n\n\n\nfloat SphereSDF(in vec3 p, in Sphere s) {\n    return length(p - s.o) - s.r;\n}\n\nfloat SceneSDF(out int hitObject, in vec3 p) { // sdf for the scene.\n    float sphereDist = SphereSDF(p, s);\n    float planeDist = p.y; // ground\n    \n    float d = min(planeDist, sphereDist);\n    hitObject = sphereDist == d ? 1 : 0;\n    return d;\n}\n\nfloat RayMarch(out int hitObject, in vec3 ro, in vec3 rd) {\n    float dO = 0.; // Distance I've marched from origin\n\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = SceneSDF(hitObject, p);\n        dO += dS;  // Safe distance to march with\n        if (dO > MAX_MARCH_DIST || // Far-plane clipping\n            dS < SURF_DIST_MARCH)  // Did we hit anything?\n            break;\n    }\n\n    return dO;\n}\n\n/*\nvec3 GetNormalEulerTwoSided(in vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    int _;\n    \n    vec3 left = vec3(SceneSDF(_, p),\n                     SceneSDF(_, p - e.yxy),\n                     SceneSDF(_, p - e.yyx)),\n        right = vec3(SceneSDF(_, p + e.xyy),\n                     SceneSDF(_, p + e.yxy),\n                     SceneSDF(_, p + e.yyx));\n        \n    vec3 n = normalize(-left + right);\n    return n;\n}\n*/\n\nvec3 GetNormalEulerOneSided(in vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    int _;\n    vec3 center = vec3(SceneSDF(_, p)),\n          right = vec3(SceneSDF(_, p + e.xyy),\n                       SceneSDF(_, p + e.yxy),\n                       SceneSDF(_, p + e.yyx));\n        \n    vec3 n = normalize(right - center);\n    return n;\n}\n\n#define GetNormal GetNormalEulerOneSided\n//#define GetNormal GetNormalEulerTwoSided\n\n\n/*\n  p  -> position of point to shade\n  ro -> ray origin (position of the camera)\n*/\nvec3 PhongIllumination(in vec3 p, in vec3 ro, in int hitObject) {\n    vec3 lightPosOffset = vec3(sin(2. * iTime), 0, cos(2. * iTime)) * 3.;\n    vec3 lightPos = light.pos + lightPosOffset;\n    // PhongMaterial mat = (hitObject == 1) ? sphereMaterial : globalMaterial; // bugs are great!\n    \n    vec3 l = normalize(lightPos - p); // light vector\n    vec3 n = GetNormal(p); // get normal of p\n    vec3 r = reflect(l, n);\n    vec3 v = normalize(ro - p);\n    \n    vec3 h = normalize(l + v); // the `half-angle` vector\n    \n    float dif  = clamp(dot(l, n), 0., 1.);\n    float spec = clamp(dot(h, n), 0., 1.);  // also called `blinn term`\n    \n    // shadow stuff\n    vec3 pOffset = n * SURF_DIST_MARCH * 1.2; // move the point above a little\n    int _;\n    float d = RayMarch(_, p + pOffset, l);\n    if (d < length(lightPos - p)) { // If true then we've shaded a point on some object before, \n                                    // so shade the currnet point as shodow.\n        dif *= .3; // no half-shadow because the light source is a point.    \n        spec = 0.; // shadows don't have specular component, I think.\n    }\n    \n    // Acutal Phong stuff\n    vec3 ambientDiffuse = light.col * mats[hitObject].albedo;\n    vec3 light1DiffuseComponent = dif * light.col;\n    vec3 light1SpecularComponent = vec3(pow(spec, mats[hitObject].alpha));\n    \n    vec3 col = mats[hitObject].ka * ambientDiffuse + \n               mats[hitObject].kd * light1DiffuseComponent + \n               mats[hitObject].ks * light1SpecularComponent;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5 ) / iResolution.y; // center around origin\n    \n    // simplest camera\n    vec3 ro = rayOrigin;\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    \n    \n    // RayMarching stuff\n    int object;\n    float d = RayMarch(object, ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 col = PhongIllumination(p, ro, object);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1427, 1427, 1468, 1468, 1504], [1506, 1506, 1552, 1574, 1755], [1757, 1757, 1816, 1816, 2204], [2690, 2690, 2730, 2779, 3080], [3168, 3253, 3318, 3318, 4796], [4798, 4798, 4855, 4855, 5243]], "test": "untested"}
{"id": "NlB3Rc", "name": "Faceted Torus Rendering", "author": "Shane", "description": "A faceted 2D twisted torus rendered in a cheap pseudo sketch style.", "tags": ["2d", "torus", "sketch", "draw", "isometric", "polar", "quad"], "likes": 52, "viewed": 956, "published": 3, "date": "1624534211", "time_retrieved": "2024-07-30T19:14:20.867076", "image_code": "/*\n\n    Faceted Torus Rendering\n    -----------------------\n    \n    There are countless hand drawn geometric images online, and a lot of \n    tutorials showing people how to draw them. Most involve multiple \n    simplistic repetitive steps and measurements, which make their \n    construction well suited to a computer.\n    \n    The downside is that computers do such a good job that the results tend \n    to look too flawless, which means some of the artistry gets lost in \n    translation. Ironically, we then have to complicate things to put the \n    flaws back in. In this case, I've done that via a basic post-processing\n    algorithm. It works, but there are better ones out there. Flockaroo has \n    some great examples of various rendering styles for anyone interested.\n    \n    This particular geometric rendering is a faceted twisted torus and is \n    simple to produce. In fact, anyone with basic geometric knowledge can do \n    it easily: Start off with an n-gon (the default is an octagon), then \n    render some radial quad strips for each side using basic vector addition \n    and trigonometry. How one goes about it is up to the individidual, but \n    you can check to see how I've done it below.\n    \n    Obviously, this is a 2D rendering of a 3D object, but it's possible to\n    render a 3D version in the same style, which I plan to put together in \n    due course. I'll leave the short version to the code golfers. :)\n    \n \n \n    \n    Other 2D polygon-based sketch examples:\n    \n    \n    // Very watchable, and with virtually no code. \n    Cube Circle Sketch - Shane\n    https://www.shadertoy.com/view/3dtBWX\n    \n\n*/\n\n// Background: Plain: 0, Sunset: 1, Light blue: 2.\n#define BACKGROUND 0\n\n// Sketch only.\n//#define SKETCH\n\n// Offset scribbled edges.\n//#define OFFSET_EDGES\n\n// Vertices.\n//#define VERTICES\n\n// Face center marking.\n//#define FACE_CENTER\n\n// Light panels... Yeah, it's a bit much, but I had to try. :)\n//#define PANELS\n\n// Rotate the torus about the XY plane.\n//#define ROTATE\n\n// N-gon degree. The default is octagonal, but numbers 4 to about 16\n// work well enough.\n#define N 8\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling and translation.\n    float gSc = 1.;// + sin(iTime/3.)*.25;\n    \n    // Smoothing factor.\n    float sf = gSc/iRes;\n    \n    // Scaling, translation, etc.\n    vec2 p = uv*gSc; \n    \n    // Coordinate perturbation. There's small rigid one to enhance the hand-drawn look, and\n    // a larger animated one to wave the paper around a bit.\n    vec2 offs = vec2(fbm(p*16.), fbm(p*16. + .35));\n    vec2 offs2 = vec2(fbm(p*1. + iTime/4.), fbm(p*1. + .5 + iTime/4.));\n    const float oFct = .007;\n    const float oFct2 = .04;\n    p -= (offs - .5)*oFct;\n    p -= (offs2 - .5)*oFct2;\n    \n    \n    \n    // Set the background to something neutral.\n    float lgt = dot(rot2(-3.14159/6.)*uv, vec2(.5)) + .5;\n    #if BACKGROUND == 0\n    vec3 col = mix(vec3(.6, .55, .45), vec3(.9, .85, .8), lgt);\n    #elif BACKGROUND == 1\n    vec3 col = mix(vec3(.7, .2, .3), vec3(1, .7, .3), lgt);\n    col = mix(col, col.yzx, .15);\n    #else\n    vec3 col = vec3(.65, .85, 1)*mix(.8, 1.2, lgt);\n    #endif\n\n    \n    // Edge width. \n    const float ew = .00165;  \n   \n    // N-Gon degree.\n    const float fN = float(N);\n   \n    // Center to vertex vector.\n    vec2 vi = vec2(-.15, 0); \n    \n    // Quad side length vector, used to construct the faces.\n    vec2 sL = vec2(0, abs(vi.x*sin(6.2831/fN/2.)*2.));\n    \n     \n    // Whole object, hit polygon and line distance fields.\n    float obj = 1e5, polyMin = 1e5, line = 1e5;\n    \n    // Offset edges.\n    float edge = 1e5;\n    \n    // The object vertices.\n    #ifdef ROTATE\n    vec2 q = rot2(iTime/8.)*p;\n    #else\n    vec2 q = p;\n    #endif\n    \n    // Hit quad vertices.\n    vec2[4] pV;\n    // Hit quad ID.\n    vec2 id;\n    \n    \n    // Quad circular strip for this edge.\n    for(int i = min(0, iFrame); i<N; i++){\n\n        // First quad for this particular edge.\n        vec2[4] vR;\n        \n        vR[0] = rot2(-6.2831/fN*float(i) + 3.14159/fN)*vi; \n        vR[1] = vR[0]+ rot2(3.14159/fN)*sL;\n        vR[2] = vR[1] + sL; \n        vR[3] = vR[0] + sL;\n            \n        // Edging out quad by quad in a circular fashion.\n        for(int j = 0; j<N - 1; j++){\n        \n            // Quad value.\n            float qud = quad(q, vR);\n            \n            // The combined quads, or the whole object.\n            obj = min(obj, qud);\n            if(qud<polyMin){\n            \n               // Update the minimum quad distance.\n               polyMin = qud;\n               \n               // Quad ID.\n               id = vec2(i, j);\n               \n               // Hit vertices.\n               pV = vR;\n              \n            }\n        \n           \n            // Drawing the helper grid lines.\n            //if(j%2==0) line = min(line, abs(length(q) - length(vR[2])));\n            vec2  nrm = normalize(vR[2] - vR[3]);\n            if(j%2==0) line = min(line, sdLine(q, vR[2] - nrm, vR[3] + nrm));\n            //nrm = normalize(vR[0] - vR[1]);\n            //if(j%4==2) line = min(line, sdLine(q, vR[0] - nrm, vR[1] + nrm)); \n            \n            // Offset edges, if chosen.\n            #ifdef OFFSET_EDGES\n            // Offset polygon edges.\n            for(int l = 0; l<3; l++){\n                for(int k = 0; k<4; k++){\n                    float a = 1./float(l + 1);\n                    vec2 pk = pV[k];\n                    vec2 pk1 = pV[(k + 1)%4];\n                    \n                    vec2 offs1 = (vec2(hash21(pk + .45*a), hash21(pk + .73*a)) - .5);\n                    vec2 offs2 = (vec2(hash21(pk1 + .29*a), hash21(pk1 + .87*a)) - .5);\n                    vec2 pA = pk - offs1*.0125;\n                    vec2 pB = pk1 - offs2*.0125;\n                    vec2 nm = normalize(pB - pA);\n                    edge = min(edge, sdLine(q, pA - nm*.01, pB + nm*.01));\n\n                }\n            }\n            #endif\n            \n            // Produce the vertices for the next quad in the strip. As you can see, \n            // each quad starts with the last vertices from the prevous quad, and the \n            // new end vertices are created by adding a rotated side edge. \n            vR[0] = vR[3];\n            vR[1] = vR[2];\n            vR[2] = vR[1] + rot2(-3.14159/fN*float(j+1))*sL;\n            vR[3] = vR[0] + rot2(-3.14159/fN*float(j+1))*sL;            \n           \n        }\n \n        // Rotate the side length vector to the right position for the next inner vertex.\n        sL = rot2(-6.283/fN)*sL; \n       \n        // Fake break to counter unrolling and slow compile times.\n        if(length(sL)>1e5) break;\n        \n    }\n    \n    \n    \n    \n    // Coloring and shading, based on polygon ID (side band number, or position within the band).\n    //float hlfN = float((N - 1)/2);\n    //float fi = float(N/2) + 1. - id.x;\n    //float sh = mod(fi, float(N/2))/float(hlfN)*.5 + .5;\n    \n    float rt = 0.;\n    #ifdef ROTATE\n    rt = iTime/8.;\n    #endif\n    float sh = sin((float(N) - id.x)*6.2831/fN*1.3 - rt)*.25 + .75;\n    sh *= id.y/(fN - 2.)*.5 + .5;\n \n    // Polygon color.\n    vec3 polyCol = (.55 + .45*cos(-6.2831*sh/3.5 + vec3(0, 1, 2) + 2.2))*1.5;//vec3(sh, sh*sh, sh*sh*sh)*1.5;\n    //vec3 polyCol = col*vec3(sh*.9 + .1)*1.35;\n    //polyCol = mix(polyCol.zyx, polyCol.yxz, .85);\n    polyCol = mix(polyCol, polyCol.yzx, .05);\n    //polyCol = mix(polyCol.yxz, polyCol.zyx, .95);\n    \n    \n    /*\n    // Holes.\n    polyMin = abs(polyMin + ew*6.) - ew*6.;\n    polyMin = abs(polyMin + ew*6.) - ew*6.;\n    obj = max(obj, polyMin);\n    */\n    \n   \n    // Object drop shadow and outside edges.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*24.*iRes/450., obj))*.35);\n    col = mix(col, polyCol/32., (1. - smoothstep(0., sf, obj - ew*3.))*.85);\n     \n    \n  \n\n    #ifdef OFFSET_EDGES\n    col = mix(col, polyCol, (1. - smoothstep(0., sf, polyMin)));\n    #else\n    col = mix(col, polyCol/3., (1. - smoothstep(0., sf, polyMin)));\n    col = mix(col, polyCol, (1. - smoothstep(0., sf, polyMin + ew*2.)));\n    /*\n    // More decorated faces... I wasn't feeling it. :)\n    col = mix(col, polyCol/8., (1. - smoothstep(0., sf, polyMin)));\n    col = mix(col, mix(min(polyCol*2., 1.5), vec3(1), .35), (1. - smoothstep(0., sf, polyMin + ew*3.)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, polyMin + ew*6.)));\n    col = mix(col, polyCol, (1. - smoothstep(0., sf, polyMin + ew*8.)));\n    */\n    #endif\n    \n    #ifdef PANELS\n    // Lit face windows.\n    col = mix(col, polyCol*2., (1. - smoothstep(0., sf*12., polyMin + ew*28.)));\n    col = mix(col, polyCol/2., (1. - smoothstep(0., sf, abs(polyMin + ew*12.) - ew)));\n    col = mix(col, polyCol/2., (1. - smoothstep(0., sf, abs(polyMin + ew*22.) - ew)));\n    #endif\n    \n    /*\n    // Triangulate. Interesting, but a bit of depth is lost somehow.\n    float line2 = 1e5;\n    if(length(pV[0] - pV[2])<length(pV[1] - pV[3])) line2 = min(line2, sdLine(q, pV[0], pV[2]));\n    else line2 = min(line2, sdLine(q, pV[1], pV[3]));\n    line2 -= ew*.67;\n    col = mix(col, polyCol/32., (1. - smoothstep(0., sf, line2)));\n    */\n    \n    #ifdef VERTICES\n    // Render vertex points.\n    float vert = min(length(q - pV[0]), length(q - pV[1]));\n    vert = min(vert, min(length(q - pV[2]), length(q - pV[3])));\n    vert -= ew*5.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert)));\n    col = mix(col, polyCol.xzy*.7, (1. - smoothstep(0., sf*2., vert + ew*4.)));\n    #endif\n\n    \n    #ifdef FACE_CENTER\n    // Face center points.\n    vec2 cntr = (pV[0] + pV[1] + pV[2] + pV[3])/4.;\n    float cVert = length(q - cntr) - ew*4.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, cVert)));\n    col = mix(col, polyCol.xzy*.7, (1. - smoothstep(0., sf*2., cVert + ew*3.)));\n    #endif\n    \n    #ifndef ROTATE\n    #ifndef SKETCH\n    // Fake construction lines when the object isn't rotating.\n    line -= ew;\n    line = max(line, obj - .4);\n    float alpha = mix(.15, .15, 1. - smoothstep(0., sf*2., obj));\n    col = mix(col, polyCol/32., (1. - smoothstep(0., sf, line))*alpha);\n    #endif\n    #endif\n    \n    #ifdef OFFSET_EDGES\n    col = mix(col, polyCol/3., 1. - smoothstep(0., sf, edge - ew/3.));\n    #endif\n    \n    // Just a cheap way to seperate the foreground object coordinates from\n    // those in the background.\n    p = mix(p, q, 1. - smoothstep(0., sf*2., obj));\n     \n     \n    // Subtle pencil overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 qq = p*8.;//*gSc;\n    //vec2 qq = p*8.;\n    #ifdef SKETCH\n    int drkLns = 1;\n    #else\n    int drkLns = 0;\n    #endif\n    vec3 colP = pencil(col, qq*iRes/450., drkLns);\n    #ifdef SKETCH\n    // Just the pencil sketch. The last factor ranges from zero to one and \n    // determines the sketchiness of the rendering... Pun intended. :D\n    col = colP;\n    //col = mix(dot(col, vec3(.299, .587, .114))*vec3(1), colP, .6);\n    #else\n    col = mix(col, 1. - exp(-(col*2.)*(colP + .15)), .85); \n    #endif\n    //col = mix(col, colP, .85);\n    //col = mix(min(col, colP), max(col, colP), .35); \n   \n \n\n    // Cheap paper grain... Also barely worth the effort. :)\n    vec2 pp = p;//floor(q*1024.);\n    vec3 rn3 = vec3(hash21(pp), hash21(pp + 2.37), hash21(pp + 4.83));\n    vec3 pg = .9 + (rn3.xyz*.35 + rn3.xxx*.65)*.2;\n    col *= min(pg, 1.); \n \n\n\n\n    // Rough gamma correction and output to screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "// UTILITY FUNCTIONS -- These are just worker functions. All the logic is contained\n// within the \"Image\" tab.\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589))*43758.5453); \n}\n\n\n// IQ's line distace formula. \nfloat sdLine(in vec2 p, in vec2 a, in vec2 b){\n\n\tp -= a, b -= a;\n\treturn length(p - b*clamp(dot(p, b)/dot(b, b), 0., 1.));\n}\n\n// Entirely based on IQ's signed distance to a 2D triangle. I've expanded it \n// to work with convex quads and generalized it a bit, but I doubt it would \n// translate to speed. It would be easy to generalize to convex polyons though.\nfloat quad(in vec2 p, in vec2[4] v){\n\n    // Lines between successive vertex points.\n    vec2[4] e = vec2[4](v[1] - v[0], v[2] - v[1], v[3] - v[2], v[0] - v[3]);\n    \n    // Winding related sign.\n    float s = sign(e[0].x*e[3].y - e[0].y*e[3].x);\n    \n    vec2 d = vec2(1e5);\n    \n    for(int i = 0; i<4; i++){\n        \n        // Minimum point to line calculations.\n        vec2 vi = p - v[i];\n        vec2 qi = vi - e[i]*clamp(dot(vi, e[i])/dot(e[i], e[i]), 0., 1.);\n        d = min(d, vec2(dot(qi, qi), s*(vi.x*e[i].y - vi.y*e[i].x)));\n    }\n\n    // Quad distance.\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p *= p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p, int drkLns){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix similar, but rotated, layers on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/4.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Repeat the process with a few extra rotated layers.\n    q *= rot2(3.14159/3.); q += 1.5;\n    float ns2 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    q *= rot2(-3.14159/5.2); q += 3.;\n    float ns3 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    q *= rot2(3.14159/3.7); q += 6.;\n    float ns4 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Compare it to the underlying grey scale value.\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    const float contrast = 1.;\n    if(drkLns==0){\n        // Same, but with contrast.\n        ns = (.5 + (gr - (max(max(ns, ns2), max(ns3, ns4))))*contrast); \n    }\n    else {\n        // Different contrast.\n        ns = smoothstep(0., 1., .5 + (gr - max(max(ns, ns2), max(ns3, ns4)))); \n    }\n    // \n    // Return the pencil sketch value.\n    return vec3(clamp(ns, 0., 1.));\n    \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlB3Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7t2GRt", "name": "Level map exploration", "author": "kosua20", "description": "This is a small experiment in rendering isolines. After posting a first hacky version, I've stumbled upon https://www.shadertoy.com/view/Ms2XWc (posted by iapafoto the same day :)) referencing IQ's article on the topic of smooth isoline rendering.", "tags": ["2d", "lines", "map", "isolines", "level"], "likes": 9, "viewed": 400, "published": 3, "date": "1624530950", "time_retrieved": "2024-07-30T19:14:21.616073", "image_code": "\n#define HAS_DERIV\n\n#define BACKGROUND_INTENSITY 0.0\n#define THEME_COLOR vec3(0.670,0.513,0.007 )\n\n// Perlin\nfloat cnoise(vec3 P);\n\n// Wrapper (not really needed)\nfloat delta(float v, float fallback){\n#ifndef HAS_DERIV\n    return fallback;\n#else\n    return 2.0 * length(vec2(dFdx(v), dFdy(v)));\n#endif\n}\n\n// https://iquilezles.org/articles/distance\nfloat smoothLine(float val, float scale, float thickness, float fallback){\n    // Compute gradient using continuous val.\n    float deltaVal = delta(val, fallback);\n    // Line frequency.\n    float scaledVal = mod(val, scale);\n    float finalVal = abs(scaledVal) / max(deltaVal, 0.001) - thickness;\n    return 1.0 - smoothstep(0.1, 0.9, finalVal);\n}\n\nvec3 evaluate(vec2 ndc, float time, float ratio){\n    // Colors.\n    vec3 themeColor = THEME_COLOR;\n    vec3 backgroundColor = vec3(BACKGROUND_INTENSITY);\n    vec3 foregroundColor = vec3(1.0 - BACKGROUND_INTENSITY);\n\n    // Scaled UVs.\n    vec2 rawUV = 0.5 * ndc + 0.5;\n    vec2 ratioUV = 0.5 * vec2(ratio, 1.0) * ndc + 0.5;\n    vec2 gridUV = ratioUV + 0.5;\n\n    // Isolines landscape.\n    float noise = cnoise(vec3(3.0 * ratioUV, 0.000025 * time));\n    float mainLevelLine = smoothLine(noise, 0.4, 0.8, 0.015);\n    float secondLevelLine = smoothLine(noise, 0.1, 0.1, 0.01);\n    float intensityLines = max(mainLevelLine, secondLevelLine);\n\n    // Add a regular grid.\n    float gridXLine = smoothLine(gridUV.x, 0.35, 0.5, 0.005);\n    float gridYLine = smoothLine(gridUV.y, 0.35, 0.5, 0.005);\n    float intensityGrid = max(gridYLine, gridXLine);\n\n    // Extra point at random location.\n    // (could use proper disk SDF instead of a thick line circle)\n    float motionTime = 0.0001 * time;\n    float nx = cnoise(-vec3(8.2, 9.4, motionTime));\n    float ny = cnoise(-vec3(87.8, 13.1, motionTime));\n    vec2 position = 0.5 * 1.75 * vec2(nx, ny) + 0.5;\n    float dist = length(ratioUV - position);\n    float intensityPoint = smoothLine(dist, 10000.0 /* cheat, no repetition needed */, 4.0, 0.005);\n\n    // Combine everything.\n    float themeColorIntensity = max(intensityLines, intensityGrid);\n    float foregroundColorIntensity = intensityPoint;\n\n    vec3 color = mix(backgroundColor, themeColor, themeColorIntensity);\n    color = mix(color, foregroundColor, foregroundColorIntensity);\n\n    // Vignetting.\n    float attenuation = smoothstep(0.6, 1.0, length(rawUV - 0.5)*2.0);\n    return mix(color, backgroundColor, attenuation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert shadertoy inputs to my framework inputs.\n    vec2 ndc = 2.0 * fragCoord/iResolution.xy - 1.0;\n    float time = iTime * 1000.0f;\n    float ratio = iResolution.x/iResolution.y;\n   \n    fragColor.rgb = evaluate(ndc, time, ratio);\n    fragColor.a = 1.0;\n}\n\n// Perlin noise: Copyright (C) 2011-2016 by Stefan Gustavson \n// Licence: https://github.com/stegu/webgl-noise/blob/master/LICENSE\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x){ return mod289(((x*34.0)+1.0)*x); }\n\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat cnoise(vec3 P);\n// Classic Perlin noise\nfloat cnoise(vec3 P) {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2GRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[132, 163, 200, 200, 303], [305, 349, 423, 469, 697], [699, 699, 748, 763, 2425], [2427, 2427, 2484, 2540, 2751], [2753, 2884, 2905, 2905, 2952], [2954, 2954, 2975, 2975, 3022], [3024, 3024, 3045, 3045, 3080], [3082, 3082, 3110, 3110, 3160], [3162, 3162, 3181, 3181, 3219], [3243, 3267, 3289, 3289, 5701]], "test": "untested"}
{"id": "fl23Rt", "name": "Patterned Spiral", "author": "scry", "description": "it just keeps going and going", "tags": ["2d", "fractal", "spiral", "atan", "kifs"], "likes": 4, "viewed": 269, "published": 3, "date": "1624506981", "time_retrieved": "2024-07-30T19:14:22.368063", "image_code": "#define iTime iTime*0.1\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = uv;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    //tv -= 0.5;\n    //tv = vec2((length(tv)), atan(tv.x,tv.y));\n    //tv.y = abs(tv.y+iTime*0.02);\n    //tv *= r2d(iTime*0.91);\n    //tv = vec2(tv.x*sin(tv.y),tv.x*cos(tv.y));\n    //tv += 0.5;\n    //tv = abs(tv-0.5)+0.5;\n    //vec3 bak = texture(texture1,tv).rgb;\n    uv -= 0.5;\n    uv.x *= ar;\n    //uv *= 0.2;\n    //uv += 0.5;\n    uv *= 1.;\n    float ac = length(uv);\n    float udt = iTime*0.2;\n    vec2 uvd = uv/mix(vec2(sin(udt),cos(udt*0.9238)*9.)*0.5,vec2(1.,0.5),1.-ac);\n    //uv = mix(uvd,uv,sin(iTime*0.1+1.)*0.5+0.5);\n    //uv *= (1.-ac)*(1.-ac);\n    //uv *= vec2(sin(udt),cos(udt*0.9238)*4.)*0.2;\n    //uv *= r2d(ac*2.+iTime*0.5);\n    //uv.x *= 0.1;\n    float c = length(uv);\n    float lc = log(c)*0.093;\n    //uv *= 20.1;\n    float scrolltime = iTime*0.;\n    float zoomtime = iTime*0.9;\n    //scrolltime += sin(lc*9+iTime*1)*0.1;\n    //uv /= c;\n    //uv.x += iTime;\n    tv -= 0.5;\n    tv *= 1.+lc*0.09;\n    tv += 0.5;\n    //vec3 bakd = texture(texture1,tv).rgb;\n    vec2 cuv = vec2(lc,atan(uv.x,uv.y)/6.27831853071);\n    //uv.x *= 0.9;\n    //uv = mix(uv,cuv,sin(iTime)*0.5+0.5);\n    //uv *= 0.1;\n    //cuv.x *= 0.1;\n    uv = cuv;\n    //uv *= 0.5;\n    \n    uv.x *= 1.;\n    uv.y *= 1.;\n    vec2 uvb = uv;\n    //uv *= 0.1;\n    uv.x -= zoomtime*0.2;\n    //uv.x *= 1.7;\n    vec2 uvc = uv+0.5;\n    //uv.y /= 6.28318;\n    uv = fract(uv-0.5);\n    //uv.x += iTime;\n    //uvc = fract(uvc-0.5);\n    //uv = vec2(lc,atan(uv.x,uv.y));\n    //uv.x *= 0.4;\n    vec3 col = vec3(0.);\n    float ct = 20.;\n    //uv *= r2d(lc);\n    float b = 0.;\n    //uv *= 0.6;\n    vec2 rud = uv;\n    uv *= r2d(1./ct);\n    uvc *= r2d(1./ct);\n    uvb *= r2d(1./ct);\n    //uv *= 0.3;\n    //uv.x *= 0.03;\n    //uv *= r2d((3.141/180.)*(90/ct));\n    vec2 uvf = floor(uv*ct)/ct;\n    vec2 fr = fract(rud);\n    //uvc.x += .9;\n    float uvxf = floor(uvc.x*ct)/ct;\n    float uvtf = floor(uvc.x*ct);\n    float sy = uvxf;\n    sy -= ((uvc.y)/ct);\n    //uvtf = uvxf;\n    //uvtf -= sin(((uvc.y)/ct)*iTime);\n    float dist = (sin(c*8.+iTime*23.)*0.004);\n    //sy += sin(sy*0.0002)*iTime;\n    //sy += sin(floor(uvc.x*ct))*iTime*0.5;\n    //sy -= sin(uvxf/3.14159)*iTime;\n    //sy += dist*(dist+lc*2);\n    //sy += sin(uvxf*4.14+iTime*0.1);\n    //sy += sin(uvtf*iTime*0.01)*iTime*0.51;\n    //sy = ((fract(sy*400.)/400.)-(0.5/40))+sy;\n    //sy -= 0.5/40;\n    //sy = abs(fract(sy))-0.55;\n    //sy += sin(floor(uvc.x*ct)*62.9+2)*iTime*0.3;\n    sy += sin(sy*0.5)*1.;\n    sy *= 01.25;\n    //sy += sin(uvc.x*02.2)*0.01;\n    //sy += sin(iTime*0.5)*2.;\n    //sy *= r2d(iTime);\n    //sy = sin(sy*4)*40;\n    sy -= scrolltime*0.05;\n    //sy += iTime*c*0.00002;\n    //sy *= c;\n    //sy += (rud.y-0.5);\n    //sy -= (-rud.y-iTime)/ct;\n    //sy = fract(sy);\n    //sy *= 2;\n    vec2 uvs = fract(vec2((uvc.x)*20.,sy));\n    //uvs.y *= 0.5;\n    //uvs.y += sin(uvc.x*0.03);\n    uvs.y = abs(uvs.y-0.5)+0.5;\n    uvs.y *= ct*ct;\n    \n    //uvs.x *= 1./ct;\n    //uvs.y = abs(uvs.y)-1.;\n    //sy += (-rud.y)/ct;\n    //sy = rud.y;\n    //uvf -= uv.y*0.05;\n    //uvf *= 0.9;\n    //uvf += ((rud.y)/ct);\n    //uvf += abs((rud.y)/ct);\n    //b *= 0.;\n    //b = (rud.y);\n    //b = 1.-smoothstep(0.,0.02,abs(uvs.x-0.5)-0.4);\n    b = 1.-smoothstep(0.,0.06,abs(uvs.x-0.5)-0.1);\n    vec2 uvg = uvs;\n    //uvg.x += 0.3;\n    //uvg.y += 2.;\n    uvg.y += sin(sin(sin(uvg.x*3.141)+uvg.y*0.004)*3.)*0.2;\n    //uvg.x = abs(uvg.x);\n    //uvg.x *= 2.2;\n    uvg.y *= 01.5;\n    //uvg.x *= (sin(sin(uvs.y*0.01)*2.)*0.5+1.)*3.;\n    uvg = fract(uvg);\n    //uvg.x *= 2.;\n    uvg = abs(uvg-0.5);\n    //uvg *= 3.;\n    //uvg.y += c;\n    uvs.y *= 0.2;\n    //uvg.x *= 1*sin(uvs.y*0.1);\n    uvg -= 0.5*sin(uvs.y*0.01);\n    uvg *= r2d(uvs.y*sin(uvs.y*0.00101+0.)*2.);\n    uvg = abs(uvg)-0.2;\n    uvg *= r2d(uvs.y*cos(uvs.y*0.001)*0.1);\n    uvg = abs(uvg)-0.2;\n    uvg *= sin(uvs.y*0.01)*0.5+0.8;\n    uvg *= r2d(uvs.y*sin(uvs.y*0.0001)*1.);\n    for (int i=0;i<5;i++) {\n        uvg *= r2d(uvs.y*cos(uvs.y*0.001)*0.1);\n        uvg = abs(uvg)-0.2;\n    }\n    uvg += 0.5;\n    //uvg.x += lc;\n    b *= smoothstep(0.02,0.04,abs(uvg.x-0.5));\n    float bh = smoothstep(1.,0.0,abs(uvg.x-.5));;\n    //b *= smoothstep(0.02,0.01,abs(uvg.x-0.5));\n    //uvs *= 10.;\n    \n    //col.rg = sin(uvs);\n    col = vec3(b);\n    //col = sin(col);\n    col = rgb2hsv(col);\n    //col = hsv2rgb(vec3((uvs.y*0.02)+bh*10+iTime*0.1,1.,(sin(uvs.y*0.1)*0.3+0.7)*col.b));\n    //col = hsv2rgb(vec3((uvs.y*0.02)+bh*10+iTime*0.1,1.,(sin(uvs.y*0.1)*0.3+0.7)*col.b));\n    \n    col = hsv2rgb(vec3((uvs.y*0.02)+bh*10.+iTime*0.1,1.,((sin(uvs.y*sin(uvs.x*02.2+0.6)*.15+4.5)*.5+0.5)*0.5+0.5)*b));\n    //col = hsv2rgb(vec3((uvs.y*0.02)+bh*10+iTime*0.1,1.,(sin(uvs.y*0.1)*0.3+0.7)*col.b));\n    //bak = mix(bak,bakd,0.08);\n    \n    //if (b < 0.95) {\n        //col = bak*0.997;\n        //col \n        //col = fract(col+0.01);\n        //col = mix(col,bak,01.4);\n    //}\n    //col = mix(col,bak,0.6*(1.-((lc+1)*.15)));\n    //col = mix(vec3(b),col,0.4);\n    //col.rg = sin(uvs*30);\n    //col = vec3(sin(uvs.y)+sin(uvs.x));\n    //col.rg = sin(uvs*6+iTime*2);\n    //col.b = sin((uv.x+uv.y)*9*4);\n    //col.rg = vec2(sin(vec2(uvc.x,uvx.y)/2));\n    //col.rg = uv;\n    //col.rg = uv*0.2;\n    //col.b = sy+iTime*0.5;\n    //col.b = sin(sy*0.7);\n    //col.b = sy;\n    //col.r = rud.y;\n    //col.b = sin(sy*220)*0.3+sin(sy);\n    //col = vec3(abs(uvc.y-0.5));\n    //col.b = sin(col.b*2000)+sin(col.b*4.);\n    //col.b = sin(col.b+iTime);\n    //col.b = sin(col.b*3.14)*0.5+0.5;\n    //col.b = sin(col.b*62.9+1.)+sin(col.b*2+iTime)*0.5;\n    //col = vec3(sin(uv.x*20));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl23Rt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 92], [94, 231, 253, 253, 584], [589, 648, 670, 670, 839], [842, 842, 897, 897, 6544]], "test": "untested"}
{"id": "sl2GRc", "name": "Raytracer - Reflections", "author": "SpinningCube", "description": "Added reflections to the raytracer base. Removed fog because it was broken. Also added metals.", "tags": ["raytracing", "reflection", "bounce", "fresnel"], "likes": 16, "viewed": 520, "published": 3, "date": "1624499475", "time_retrieved": "2024-07-30T19:14:23.120052", "image_code": "// Filmic tonemapping curve by milesWaugh\n\nconst float epsilon = 0.001;\nconst float focalLength = 1.;\nconst float renderDist = 850.;\nconst float pi = 3.141592653589793;\nconst int bounces = 5;\n\nvec3 camera;\nfloat nearestDist;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfRoughness;\nint surfType; /* 0=dielectric 1=metallic */\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = 1.*vec3(.3, 0.4, 0.7);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nvec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius ) {\n    vec3 offset = pos - rayOrigin;\n    float dot1 = dot(offset, rayDir);\n    float dot2 = dot(offset, offset);\n    if (dot1 < 0.) {\n        return vec4(-1., 0, 0, 0);\n    }\n    if (dot2 - dot1 * dot1 < radius * radius) {\n        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));\n        return vec4(dot1 - near, (rayOrigin + (rayDir * (dot1 - near))) - pos);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0.)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvoid addIntersector( vec4 surface, vec3 col, float roughness, int type /* 0=dielectric, 1=metallic */) {\n    float dist = surface.x;\n    if ( dist < nearestDist && dist > 0. ) {\n        nearestDist = dist;\n        if (updateMat) {\n        \tsurfCol = col;\n            surfRoughness = roughness*roughness;\n            surfNormal = normalize(surface.yzw);\n            surfType = type;\n        }\n    }\n}\n\nfloat scene( vec3 rayOrigin, vec3 rayDir)\n{\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    addIntersector( Sphere( rayOrigin, rayDir, vec3(0, 0, 18), 1.), vec3(0.4,.2, 0.01), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(3, 1, 22), 2.), vec3(0.05,0.1, 0.6), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(-5, 5, 90), 6.), vec3(0.35,0.35, 1.), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 7, 100), 8.), vec3(.7,0.05, 0.05), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(15, 3, 80), 4.), vec3(.85,0.8, 0.05), .1, 1);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(-3, 3, 60), 4.), vec3(.02,0.3, 0.07), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(1, 1, 55), 2.), vec3(.7,0.7, 0.1), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 2, 50), 3.), vec3(.03,0.05, 0.3), .1, 0);\n    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1.), vec3(0.1, 0.3, 0.1), .1, 0);\n    \n    return nearestDist;\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    \n    nearestDist = renderDist;\n        \n    scene(start, rayDir);\n        \n    if ( nearestDist < renderDist ) {\n        return vec4(1., rayDir * nearestDist + start);\n    }\n    else {\n        return vec4(0., rayDir * nearestDist + start);\n    }\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, vec3(-10, 50, 20), 2.5, surfNormal);\n    //directionalLight( ray, rayDir, normalize(vec3(-2,2,-1)), surfNormal, 1., 0. );\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    //return color;\n    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 rayOrigin, vec3 surfNormal, float f) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    /*\n    float fog = clamp(length(ray - rayOrigin)/(renderDist), 0., 1.);\n    fog = fog*fog*fog;\n    //fog = fog*fog;\n    fog = smoothstep(0., 1., fog);\n    */\n    \n    vec3 finalCol = vec3(0.);\n    \n    if (surfType == 0) {\n        finalCol = mix(surfCol * (diffuse + ambient), vec3(specular), f);\n    }\n    else if (surfType == 1) {\n        finalCol = mix(surfCol * specular, vec3(specular), f);\n    }\n    \n    finalCol = finalCol;\n    \n    return finalCol;\n}\n\nvec3 renderFromRay(vec3 rayDir, vec3 rayOrigin) {\n    vec3 contribution = vec3(1.0);\n    vec3 combinedCol;\n    float totalDepth = 0.;\n    float foga;\n    for (int i = 0; i < bounces; i++) {\n        vec4 rayData = shootRay( rayDir, rayOrigin, renderDist, true );\n\n        if (rayData.x == 1.) {\n            totalDepth += distance(rayData.yzw, rayOrigin);\n            float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n            combinedCol += contribution * lighting(rayData.yzw, rayDir, rayOrigin, surfNormal, f);\n            if (surfType == 0) {\n                contribution *= f;\n            }\n            else if (surfType == 1) {\n                contribution *= mix(surfCol, vec3(1.), vec3(f));\n            }\n            \n            rayDir = reflect(rayDir, surfNormal);\n            rayOrigin = rayData.yzw + epsilon * surfNormal;\n        }\n        else {\n            combinedCol += contribution * ambient;\n            break;\n        }\n    }\n    return combinedCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cosTime = cos(iTime/2.);\n    cosTime = 6.*-cosTime+6.;\n    camera = vec3(.5*cosTime, .6*cosTime+0.3, 5.*cosTime-5.);\n    //camera = vec3(0,0,0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec3 col = renderFromRay(rayDir, camera);\n    \n    // Output to screen, filmic tonemapping, and gamma correction.\n    fragColor = vec4(pow(filmic(col),vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2GRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[424, 424, 467, 467, 510], [522, 522, 590, 590, 999], [1001, 1001, 1069, 1069, 1279], [1281, 1281, 1385, 1385, 1680], [1682, 1682, 1725, 1725, 2745], [2747, 2747, 2828, 2828, 3112], [3114, 3114, 3158, 3158, 3271], [3273, 3273, 3385, 3385, 3774], [3776, 3776, 3867, 3867, 4011], [4013, 4013, 4071, 4071, 4224], [4226, 4286, 4311, 4331, 4388], [4390, 4390, 4465, 4465, 4606], [4608, 4608, 4688, 4688, 5236], [5238, 5238, 5287, 5287, 6221], [6223, 6223, 6280, 6280, 6789]], "test": "untested"}
{"id": "ftjGRt", "name": "Shimmering rainbow bubbles", "author": "jarble", "description": "These bubbles rise like balloons.", "tags": ["fractal", "wave", "sea", "bubble"], "likes": 4, "viewed": 265, "published": 3, "date": "1624499142", "time_retrieved": "2024-07-30T19:14:24.276959", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.38;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/4.)/4.0;\n    uv.y -= s1;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= (uv.yx+vec2(uv.x/scale+uv.y/scale1,-uv.y/scale+uv.x/scale1)/scale)/scale1;\n            uv *= -scale1;\n            uv = fract((uv.yx+s1)/scale1);\n            //uv.y /= -scale1;\n        }\n        col[2] = (uv.y-uv.x);\n        col = (abs(col-col_prev.yzx))/1.125;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjGRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 735]], "test": "untested"}
{"id": "7t23z3", "name": "Music Maker v1 (GPU Music)", "author": "Plento", "description": "The goal of this is to create a compact music arranger that can be re-used to make all kinds of fun shadertoy music.", "tags": ["2d", "sound", "gpusound"], "likes": 13, "viewed": 493, "published": 3, "date": "1624488394", "time_retrieved": "2024-07-30T19:14:25.269305", "image_code": "/*\n    Cole Peterson \n    \n    WIP\n    \n    - The goal of this is to create a compact music arranger that can be re-used\n    to make all kinds of fun shadertoy music.\n    \n    - Create patterns that can be looped and arranged.\n    \n    - Working on a simpler, more intuitive way to play notes.\n\n*/\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 col = vec3(0);\n    \n    uv += iTime*.031;\n    \n    vec2 id = floor(uv*110.)*.03;\n    vec2 id2 = floor(uv*20.);\n    \n    vec3 tex = texture(iChannel0, id).xyz;\n    \n    col = tex;\n    \n    if(cos(id2.x*10. + id2.y*8. + iTime) > 0.)\n        col = mix(col.rrr, col, .5+.5*cos(length(uv)*4. - iTime));\n    \n    col *= (1.-step(.44, abs(uv2.y)));\n    f = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n\n// Constants\nconst float pi = 3.1415;\nconst float BPM = 175.0;\n\n\nconst float pitchWheel = 4.0;\n\nconst float swing = -0.4;\n\n\n// noise\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Metronome sound\nfloat blip(float t, float hz, float k){\n    return (1. - exp(-t*40.)) * sin(pi*2.*hz*t) * exp(-t * k);\n}\n\n\n\n// A beat\nfloat b(float t){\n    return mod(t, 60. / BPM);\n}\n\n\n\n// Various durations of time\nfloat bar_l = 240. / BPM; // Bar\nfloat beat_l = 60. / BPM; // beat\nfloat half_l = 30. / BPM; // half beat\nfloat quarter_l = 15. / BPM; // quarter beat\n\n\n// Get the correct time for a note based on its time offset\n// q = note start time (bar, beat, half beat, quarter beat)\n// nBeats = number of beats in pattern\n// t = time\nfloat noteTime(vec4 q, float nBeats, float t){\n    float start = t - (bar_l*q.x + beat_l*q.y + half_l*q.z + quarter_l*q.w);\n    return mod(max(start, 0.), nBeats*60. / BPM);\n}\n\n\n// Loop a pattern\n// q = pattern start time (bar, beat, half beat, quarter beat)\n// loop = number of times to loop pattern\n// nb = number of beats in pattern\n// t = time\nfloat seq(vec4 q, float loop, float nb, float t){\n    float start = (bar_l*q.x + beat_l*q.y + half_l*q.z + quarter_l*q.w);\n    float dur = nb*loop*60. / BPM;\n    \n    if(t > start && t < start + dur)\n        return t - start;\n    else\n        return 0.;\n}\n\n\n\n\n// Distortions\nfloat dist1(float s, float d){\n \treturn clamp(d * s, -1., 1.);   \n}\nvec2 dist2(vec2 s, float d){\n \treturn clamp(d * s, vec2(-1.0), vec2(1.0));   \n}\n\n\n\n// Attack and decay from exponential and sqrt funcs\nfloat env(float t, float atk, float rel){\n    return (1. - exp(-t*atk)) * exp(-t*rel);\n}\n\n// Linear envelope thing\n// t = time\n// p = (attack, sustain, release)\nfloat envelope(float t, vec3 p){\n    float a = t / p.x;\n    float b = (p.y + p.x + p.z - t);\n    return max(min(min(a, 1.), b), 0.);\n}\n\n\n\n// Note stuff\nconst float baseFreq = 110.0; // A1\nconst float d12thRootOf2 = pow(2.0, 1.0 / 12.0);\n\n// Return the note's frequency\nfloat n(float k){\n    return baseFreq * pow(d12thRootOf2, k + pitchWheel);\n}\n\n\n\n// Waveforms\nfloat sine(float t, float hz){\n    return sin(hz*t*pi*2.);\n}\n\nfloat triangle(float t, float hz){\n    return (2. / pi) * asin(sin(2.*pi*t*hz));\n}\n\nfloat tri(float t, float hz){\n    return (2. / pi) * asin(sin(2.*pi*t*hz));\n}\n\nfloat sqr(float t, float hz){\n    return sign(sin(2.*pi*t*hz)) * 0.5;\n}\n\nfloat saw(float t, float hz){\n    return 2.*mod(pi*.5*(hz*t) / pi, 1.) - 1.;\n}\n\n// Stereo versions\nvec2 sqr_2(float t, float nt, float sep){\n    return vec2(sqr(t, n(nt)), sqr(t, n(nt) + sep));\n}\n\nvec2 tri_2(float t, float nt, float sep){\n    return vec2(tri(t, n(nt)), tri(t, n(nt) + sep));\n}\n\nvec2 sine_2(float t, float nt, float sep){\n    return vec2(sine(t, n(nt)), sine(t, n(nt) + sep));\n}\n\nvec2 saw_2(float t, float nt, float sep){\n    return vec2(saw(t, n(nt)), saw(t, n(nt) + sep));\n}\n\n\n\n\n// Chords\nvec2 minor_tri(float t, float nt, float sep){\n    vec2 ms = vec2(0);\n    \n    ms += .5*tri_2(t, nt - 12., sep);\n    \n    ms += tri_2(t, nt, sep);\n    ms += tri_2(t, nt + 3., sep);\n    ms += tri_2(t, nt + 7., sep);\n    \n    return ms / 4.;\n}\n\nvec2 major_tri(float t, float nt, float sep){\n    vec2 ms = vec2(0);\n    \n    ms += .1*tri_2(t, nt - 12., sep);\n    \n    ms += tri_2(t, nt, sep);\n    ms += tri_2(t, nt + 4., sep);\n    ms += tri_2(t, nt + 7., sep);\n    \n    return ms / 4.;\n}\n\n\n\n\n\n\n\n\n// Synths\n\n\n// Major triad thingy\nvec2 synth_2(float k, float dur, vec4 q, float nBeats, float t){\n    vec2 ms = vec2(0);\n    float t0 = noteTime(q, nBeats, t);\n\n    ms += major_tri(t0, k, 0.75);\n    \n    return ms * smoothstep(0.0, .05, t0) * smoothstep(2.0, .0, t0);\n    \n}\n\n\n// lead saw / triangle thingy\nvec2 synth_5(float k, float dur, vec4 q, float nBeats, float t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    float t0 = noteTime(q, nBeats, t);\n\n    ms += tri_2(t0, k, 6.);\n    ms += .2*saw_2(t0, k + 12., 6.);\n    \n    return ms * smoothstep(0.0, .1, t0) * smoothstep(dur + .25, dur, t0);\n    \n}\n\n// Saw lead \nvec2 synth_6(float k, float dur,float oct, vec4 q, float nBeats, float t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    float t0 = noteTime(q, nBeats, t);\n\n    ms += saw_2(t0, k + 24., 2.);\n    //ms += .35*saw_2(t0, k + 12., 3.);\n    \n    //return ms * smoothstep(0.0, .1, t0) * smoothstep(1.8, 0., t0);\n    return ms * smoothstep(0.0, .2, t0) * smoothstep(dur + .25, dur, t0);\n    \n}\n\n// Subby bass \nvec2 synth_3(float k, float dur, vec4 q, float nBeats, float t){\n    vec2 ms = vec2(0);\n    dur = (dur * 60.) / BPM;\n    \n    float t0 = noteTime(q, nBeats, t);\n    \n    ms += .2*tri_2(t0, k, 0.4);\n    ms += sine_2(t0, k - 12., 0.);\n    \n    return ms * smoothstep(0.0, .01, t0) * smoothstep(dur + .01, dur, t0);\n    //return ms * smoothstep(0.0, .4, t0) * smoothstep(2.2, .0, t0);\n}\n\n\n\n\n// Drums\nvec2 snare(vec4 q, float nBeats, float t){\n    float t0 = noteTime(q, nBeats, t);\n\n    vec2 s = exp(-t0*16.) * hash22(iSampleRate * vec2(t0, t0*1.423)) * 2.0 - 1.0; \n    s = dist2(s, 1.13) * .85;\n    s += 1.3*dist1(exp(-t0*24.) * sine(t0, 200.), 4.0);\n    s += .1*dist1(exp(-t0*24.) * sine(t0, 150.), 3.0);\n    return s * 0.25;\n}\n\n\nvec2 kick(vec4 q, float nBeats, float t){\n    float t0 = noteTime(q, nBeats, t);\n    \n    vec2 s = vec2(0);\n    s += 1.5*dist2(exp(-t0*22.) * vec2(sine(t0, 72.)), 4.7);\n    s += 4. * exp(-t0*15.) * vec2(sine(t0, 70.));\n    return s * .15;\n}\n\nvec2 hat(vec4 q, float nBeats, float t){\n    float t0 = noteTime(q, nBeats, t);\n    \n    vec2 s = envelope(t0, vec3(.1, .01, .01)) * hash22(iSampleRate * vec2(t, t*1.423)) * 2.0 - 1.0; \n    \n    //s = dist2(s, 1.1) * .85;\n    return s * 0.4;\n}\n", "sound_code": "\n\n/*\n    Cole Peterson\n    \n    WIP\n    \n    - The goal of this is to create a compact music arranger that can be re-used\n    to make all kinds of fun shadertoy music.\n    \n    - Create patterns that can be looped and arranged.\n    \n    - Working on a simpler, more intuitive way to play notes and arrange patterns.\n\n*/\n\n// t = time\n// nb = Number of beats in this pattern\nvec2 pattern_chords_1(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    // play note 15 for 4 beats on the first bar. vec4(bar, beat, half beat, quarter beat)\n    ms += synth_2(15., 4., vec4(0., 0., 0., 0.), nb, t);\n    \n    // play note 10 for 4 beats on the second bar... ect.\n    ms += synth_2(10., 4., vec4(1., 0., 0., 0.), nb, t);\n    \n    ms += synth_2(13., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_2(8., 4., vec4(3., 0., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\nvec2 pattern_lead_1(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_5(15. + 12., 4., vec4(0., 0., 0., 0.), nb, t);\n    ms += synth_5(17. + 12., 4., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_5(13. + 12., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_5(15. + 12., 4., vec4(3., 0., 0., 0.), nb, t);\n    \n    ms += synth_5(15. + 12., 4., vec4(4., 0., 0., 0.), nb, t);\n    ms += synth_5(17. + 12., 4., vec4(5., 0., 0., 0.), nb, t);\n    ms += synth_5(20. + 12., 4., vec4(6., 0., 0., 0.), nb, t);\n    ms += synth_5(19. + 12., 4., vec4(7., 0., 0., 0.), nb, t);\n     \n    return ms;\n}\n\n\nvec2 pattern_lead_2(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_6(15., 2., 1., vec4(0., 2., 0., 0.), nb, t);\n    ms += synth_6(14., 4., 1., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_6(13., 4., 1., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_6(15., 2., 1., vec4(3., 0., 0., 0.), nb, t);\n    ms += synth_6(7., 2., 1., vec4(3., 2., 0., 0.), nb, t);\n    ms += synth_6(10., 4., 1., vec4(4., 0., 0., 0.), nb, t);\n    ms += synth_6(12., 4., 1., vec4(5., 0., 0., 0.), nb, t);\n    ms += synth_6(8., 4., 1., vec4(6., 0., 0., 0.), nb, t);\n    ms += synth_6(7., 4., 1., vec4(7., 0., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\nvec2 pattern_bass_1(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += synth_3(3., 4., vec4(0., 0., 0., 0.), nb, t);\n    ms += synth_3(-2., 4., vec4(1., 0., 0., 0.), nb, t);\n    ms += synth_3(1., 4., vec4(2., 0., 0., 0.), nb, t);\n    ms += synth_3(-4., 4., vec4(3., 0., 0., 0.), nb, t);\n     \n    return ms;\n}\n\n\nvec2 pattern_drums_hat(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += hat(vec4(0., 0., 0., 0.), nb, t);\n    ms += hat(vec4(0., 1., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 1., 1., 1.0 + swing), nb, t);\n    ms += hat(vec4(0., 2., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 3., 0., 0.0), nb, t);\n    ms += hat(vec4(0., 3., 1., 1.0 + swing), nb, t);\n    \n    return ms;\n}\n\nvec2 pattern_drums_kick(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += kick(vec4(0., 0., 0., 0.), nb, t);\n    ms += kick(vec4(0., 0., 3., 1. + swing), nb, t);\n    ms += kick(vec4(0., 3., 0., 0.), nb, t);\n    \n    return ms;\n}\n\nvec2 pattern_drums_snare(float t, float nb){\n    vec2 ms = vec2(0);\n    \n    ms += snare(vec4(0., 2., 0., 0.), nb, t);\n    ms += snare(vec4(0., 6., 0., 0.), nb, t);\n    \n    return ms;\n}\n\n\n\n\n\n// Arrange song\nvec2 snd(float t){\n    vec2 ms = vec2(0);\n    \n    ms += .3*pattern_chords_1(seq(vec4(0., 0., 0., 0.), 32., 16., t), 16.);\n    \n    ms += .35*pattern_bass_1(seq(vec4(4., 0., 0., 0.), 32., 16., t), 16.);\n    \n    ms += .0544*pattern_lead_1(seq(vec4(8., 0., 0., 0.), 32., 32., t), 32.);\n    \n    ms += .036*pattern_lead_2(seq(vec4(24., 0., 0., 0.), 16., 16., t), 32.);\n    \n    \n    ms += .5*pattern_drums_hat(seq(vec4(4., 0., 0., 0.), 32., 16., t), 4.);\n    ms += .7*pattern_drums_kick(seq(vec4(4., 0., 0., 0.), 32., 16., t), 8.);\n    ms += .5*pattern_drums_snare(seq(vec4(4., 0., 0., 0.), 32., 16., t), 8.);\n    \n    return ms * .5;\n}\n\nvec2 mainSound( int samp, float time ){\n    vec2 ms = snd(time);\n    \n    float vol = min(time*.6, 1.);\n    \n    \n    //ms += blip(b(time), 825., 60.) * .4;\n    return ms * vol;\n}", "sound_inputs": [], "buffer_a_code": "\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    uv *= 1. + cos(iTime*3.)*.04;\n    \n    float sun = smoothstep(.3, .305, length(uv));\n    sun *= smoothstep(.3, .36, (.5 + .5*cos(cos(iTime-length(uv)*20.)+atan(uv.y / uv.x) * 30.)));\n    \n    vec3 col = .3 + .4*cos(vec3(.6, 6., 1.)*length(uv*2.)+iTime+vec3(2., 2.2, 1.))* (1.-abs(uv.y));\n    col = mix(.5 + .3*cos(vec3(.6, 2., 4.)*length(uv*4.)-iTime), col, sun);\n    \n\n    \n    f = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t23z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 345, 345, 464], [466, 466, 506, 506, 951]], "test": "untested"}
{"id": "7lBGRd", "name": "Bubbles of Chaos", "author": "jarble", "description": "The bubbles grow and shrink as they float through the waves.", "tags": ["fractal", "wave", "sea", "bubble"], "likes": 6, "viewed": 321, "published": 3, "date": "1624480932", "time_retrieved": "2024-07-30T19:14:26.132996", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.38;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/4.)/4.0;\n    //uv.y -= s1/scale1;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= (uv.yx+vec2(uv.x/scale+uv.y/scale1,-uv.y/scale+uv.x/scale1)/scale)/scale1;\n            uv.x *= scale1;\n            uv = fract(uv+s1);\n            uv.y /= -scale1;\n        }\n        col[2] = (uv.y-uv.x);\n        col = (abs(col-col_prev.yzx))/1.5;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 729]], "test": "untested"}
{"id": "sl2GR3", "name": "basic pt direct light 32", "author": "MinimilisticBits", "description": "sdfsdg", "tags": ["sdfg"], "likes": 7, "viewed": 292, "published": 3, "date": "1624472211", "time_retrieved": "2024-07-30T19:14:27.355727", "image_code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 c = texture(iChannel0, uv).xyzw;\n    vec3 col = c.xyz;\n    if(texture(iChannel1, vec2(0.99)).x > 0.5){\n        col/=(c.w+1.);\n    }\n    col = vec3(1.)-exp(-1.*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.3,0.3)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.1);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEY_A 65.0\n#define KEY_W 87.0\n#define KEY_S 83.0\n#define KEY_D 68.0\n\n#define KEY_C 67.0\n\n\nconst float pi = 3.14159;\nvec2 rot(vec2 a, float c){\nc = c * pi/180.;\nfloat l = length(a);\na/=l;\nfloat ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\nang += c;\nreturn vec2(l*cos(ang), l*sin(ang));\n}\n\n//NOT MY CODE////////////////////\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel0, uv).r;\n\n        return key > 0.0;\n}\n////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).xyz;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n    //vec3 d = texture(iChannel1, vec2(40.,0.)/iResolution.xy).xyz;\n    //vec3 p = vec3(0.);\n    //vec3 d;\n    //d = normalize(vec3(uv.x, 1., uv.y));\n    vec3 d = vec3(0.,-1.,0.);\n    vec3 side = vec3(1.,0.,0.);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    d.yz = rot(d.yz, -mouse.y*130.);\n    d.xy = rot(d.xy, mouse.x*180.);\n    side.xy = rot(side.xy, mouse.x*180.);\n    //vec3 prevcol = col;\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n    if(fragCoord.x < 0.05*iResolution.x && prev_state.x < 0.5){\n        if(isPressed(KEY_W)){\n            col-=d*0.1;\n        }\n        if(isPressed(KEY_S)){\n            col+=d*0.1;\n        }\n        if(isPressed(KEY_A)){\n            col-=side*0.1;\n        }\n        if(isPressed(KEY_D)){\n            col+=side*0.1;\n        }\n    }\n    \n    if(fragCoord.x > iResolution.x*0.5 && fragCoord.x < iResolution.x*0.6 && prev_state.x < 0.5){\n        col = vec3(-mouse.y*90., mouse.x*180., 0.);\n    }\n    \n    if(fragCoord.x > 0.95*iResolution.x){\n        if(isPressed(KEY_C)){\n            col = (col.x > 0.5)?vec3(0.):vec3(1.);\n        }\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*const float pi = 3.14159;\nvec2 rot(vec2 a, float c){\n    c = c * pi/180.;\n    float l = length(a);\n    a/=l;\n    float ang = (a.y < 0.)?2.*pi - acos(a.x):acos(a.x);\n    ang += c;\n    return vec2(cos(ang),sin(ang))*l;\n}*/\n\n//As suggested by LilBensson: NOT MY CODE\nvec2 rot(vec2 a, float c){\n    c = -c * 3.14159/180.;\n    float co = cos(c);\n    float si = sin(c);\n    return a * mat2x2(co, si, -si, co);\n}\n////////////////////\n\nfloat box(vec3 p, vec3 s){\n    vec3 a = abs(p)-s;\n    return max(max(a.x,a.y),a.z);\n}\nfloat escape;\n\n\nvec3 pal(float t, vec3 a, vec3 b){\nreturn 0.5+0.5*cos(2.*3.14159*t*a + b);\n}\n\n/////////////////////////////////\n\nvec3 fold(vec3 p0){\nvec3 p = p0;\n//if(abs(p.x) > 1.)p.x = 1.0-p.x;\n//if(abs(p.y) > 1.)p.y = 1.0-p.y;\n//if(abs(p.z) > 1.)p.z = 1.0-p.z;\nif(length(p) > 1.)return p;\np = mod(p,2.)-1.;\n\nreturn p;\n}\n\n\n//NOT MY CODE///////////////\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n///////////////////////////\n\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n  float fixed_radius2 = 10.9;\n  float min_radius2 = 1.1;\n  float r2 = dot(z, z);\n  if(r2 < min_radius2) {\n    float temp = (fixed_radius2 / min_radius2);\n    z *= temp; dz *= temp;\n  }else if(r2 < fixed_radius2) {\n    float temp = (fixed_radius2 / r2);\n    z *= temp; dz *= temp;\n  }\n}\nvoid box_fold(inout vec3 z, inout float dz) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nvoid box_fold(inout vec3 z) {\n  float folding_limit = 1.0;\n  z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\nfloat escape2;\n\nfloat jb(vec3 p){\n    float s=3., e;\n    s*=e=3./min(dot(p,p),50.);\n    p=abs(p)*e;\n    escape2 = 0.;\n    for(int i=0;i++<12;){\n        p=vec3(2,4,2)-abs(p-vec3(4,4,2)),\n            s*=e=8./min(dot(p,p),9.),\n            p=abs(p)*e;\n            escape2 += exp(-0.2*dot(p,p));\n            }\n    return min(length(p.xz)-.1,p.y)/s;\n}\nfloat fractal_de46(vec3 p){\n    float s = 2.;\n    float e = 0.;\n    escape = 0.;\n    for(int j=0;++j<7;){\n        p.xz=abs(p.xz)-2.3,\n        p.z>p.x?p=p.zyx:p,\n        p.z=1.5-abs(p.z-1.3+sin(p.z)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.x=3.-abs(p.x-5.+sin(p.x*3.)*.2),\n        p.y>p.x?p=p.yxz:p,\n        p.y=.9-abs(p.y-.4),\n        e=12.*clamp(.3/min(dot(p,p),1.),.0,1.)+\n        2.*clamp(.1/min(dot(p,p),1.),.0,1.),\n        p=e*p-vec3(7,1,1),\n        s*=e;\n        escape+=exp(-0.2*dot(p,p));\n        }\n    return length(p)/s;\n}\nfloat fractal_de51(vec3 p){\n    for(int j=0;++j<8;)\n        p.z-=.3,\n        p.xz=abs(p.xz),\n        p.xz=(p.z>p.x)?p.zx:p.xz,\n        p.xy=(p.y>p.x)?p.yx:p.xy,\n        p.z=1.-abs(p.z-1.),\n        p=p*3.-vec3(10,4,2);\n\n    return length(p)/6e3-.001;\n}\n\nfloat fractal_de15(vec3 p){\n    p=abs(p)-1.2;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    if(p.x<p.y)p.xy=p.yx;\nescape2 = 0.;\n    float s=1.;\n    for(int i=0;i<6;i++)\n    {\n      p=abs(p);\n      float r=2./clamp(dot(p,p),.1,1.);\n      s*=r;\n      p*=r;\n      p-=vec3(.6,.6,3.5);\n              escape2+=exp(-0.2*dot(p,p));\n\n    }\n    float a=1.5;\n    p-=clamp(p,-a,a);\n    return length(p)/s;\n}\n\nfloat rota = 96.;\nfloat rotb = 180.;\nvec3 lig = normalize(vec3(0.6,-0.9,0.9));\n\n\n\nfloat dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob){\n    /*c = vec3(0.3,0.7,0.8);\n    a2 = 0.1;\n    prob = 0.9;\n    l = 0.;\n    \n        vec3 pos = vec3(1.1,-0.3,1.4)-p;\n                float aa22 = jb((pos)/1.)*1.;\n                \n    float plane = p.z - 1.;\n    \n    float final = max(aa22, box(p, vec3(5.)));\n\n    vec3 color = vec3(0.5,0.5,0.8);\n  \n       if(final == aa22){a2 = 0.1;prob=0.9;c=pal(escape, vec3(0.9), vec3(0.9,0.6,0.2));\n       l=escape*0.006;}\n     */\n     \n     c = vec3(0.9,0.8,0.6);\n    a2 = 10.;\n    prob = 0.;\n    l = 0.;\n    //float a = box(vec3(0.,4.,-5.)-p, vec3(10.,10.,0.2));\n    //float b = box(vec3(0.,4.,5.)-p, vec3(10.,10.,0.2));\n    //float c1 = box(vec3(7.,4.,0.)-p, vec3(0.2,10.,10.));\n    //float c2 = box(vec3(-7.,4.,0.)-p, vec3(0.2,10.,10.));\n    //float c3 = box(vec3(0.,9.,0.)-p, vec3(10.,0.2,10.));\n    float b2 = box(vec3(-5.,-59.5,15.)-p, vec3(22.,0.00000000000004,22.));\n    float aa2 = fractal_de51((vec3(-20.0,28.0,13.0)-p)/10.)*10.;\n    vec3 pos = (vec3(-15.0,-2.7,-3.0)-p);\n    pos.yz = rot(pos.yz, 90.);\n    float aa3 = max(jb(pos/10.)*10., box(p, vec3(25.)));\n    float aa = fractal_de46((vec3(-5.0,25.0,13.0)-p)/10.)*10.;\n\n    //float final = min(min(min(min(min(min(b2, a),b),c1),c2),c3),aa);\n    float final = min(min(aa,aa2),aa3);\n    if(final == b2)l = 3.;\n    //if(final == c1)c = vec3(0.9,0.1,0.1);\n    //if(final == c2)c = vec3(0.1,0.9,0.1);\n    if(final == aa||final == aa2){a2 = 0.4;prob=0.1;c=pal(escape*2., vec3(0.9,0.9,0.9),vec3(0.9,0.6,0.4));}\n    if(final == aa3){l=escape2*0.006;a2 = 0.1;prob=0.8;c=pal(escape2, vec3(0.9,0.9,0.9),vec3(0.4,0.6,0.9));}\n\n    //return final;\n     \n    return final;\n}\n\nvec3 anglephong(float a,vec3 n, inout uint r){\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float t = pow(r2, 2./(1.+a));\n    float x = cos(2.*3.14159*r1)*sqrt(1.-t);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-t);\n    float z = sqrt(t);\n//same explanation as above:\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat denn = 0.01;\nbool trac(inout vec3 p, vec3 d, inout float dd, inout float l,\ninout vec3 c, inout float a, inout float prob, inout uint r, inout float k){\n    for(int i = 0; i < 380; i++){\n        dd = dis(p,l,c,a,prob);\n        if(dd<0.01)return true;\n        if(rndf(r) < denn){\n           d = anglephong(1000., d, r);\n        }\n        k+=exp(-dd*20.);\n        p+=d*dd;\n    }\n    return false;\n}\n\nvec3 norm(vec3 p, float dd){\n    vec3 c;\n    float l,a,prob;\n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.01, p.yz),l,c,a,prob) - dis(vec3(p.x-0.01, p.yz),l,c,a,prob),\n            dis(vec3(p.x, p.y+0.01, p.z),l,c,a,prob) - dis(vec3(p.x, p.y-0.01, p.z),l,c,a,prob),\n            dis(vec3(p.x, p.y,p.z+0.01),l,c,a,prob) - dis(vec3(p.x, p.y,p.z-0.01),l,c,a,prob)\n        )\n    );\n}\n\nfloat noise(vec3 uv){\n//uv += 1000.;\n//numbers so large that looks like random noise\n    return fract(sin(uv.x*23. + uv.y*345. + uv.z *200.)*534432.*cos(uv.y*203. + uv.z*353.));\n}\n\n\n\nvec3 angledircos(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));\n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nvec3 angledircos2(vec3 n, inout uint r){\n//2 random numbers between 0 and 1\n    float r1 = rndf(r);\n    float r2 = rndf(r);\n    float theta = acos(sqrt(r2));\n    float phi = 2.*3.14159*r1;\n    float x = cos(phi)*sin(theta);\n    float y = sin(phi)*sin(theta);\n    float z = cos(theta);\n    \n    //float x = cos(2.*3.14159*r1)*sqrt(1.-r2);\n    //float y = sin(2.*3.14159*r1)*sqrt(1.-r2);\n    //float z = sqrt(r2);\n    vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n    vec3 N = n;\n    vec3 T = normalize(cross(N,W));  \n    vec3 B = cross(T,N);\n    return normalize(x*T + y*B + z*N);\n}\n\nfloat powerh(float a, float pdf1, float b, float pdf2){\n    pdf1*=a;\n    pdf2*=b;\n    return (pdf1*pdf1)/(pdf1*pdf1 + pdf2*pdf2);\n\n}\n\nfloat remap(float v, float l0, float h0, float ln, float hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nvec3 remap(vec3 v, vec3 l0, vec3 h0, vec3 ln, vec3 hn){\nreturn ln + ((v-l0)*(hn-ln))/(h0-l0);\n}\nfloat random3d(vec3 p){\nreturn fract(sin(p.x*214. + p.y*241. + p.z*123.)*100. + cos(p.x*42. + p.y*41.2+p.z*32.)*10.);\n}\n\nfloat worley3d(vec3 p){\nvec3 f = floor(p);\n\nfloat ll = 999.;\nfor(int i = 0; i < 27; i++){\nvec3 coords = vec3(float(i%3)-1., mod(float(i/3)-1., 3.), float(i/9)-1.);\nvec3 col = f+coords;\nvec3 curr = vec3(random3d(col), random3d(col+2.), random3d(col+4.))-0.5;\nfloat len = length((col+curr)-p);\nll = min(ll, len);\n}\nreturn ll;\n\n}\nfloat hash(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise222( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbmss(vec3 p)\n{\n    float scale = 0.1;\n    float threshold = 0.3;\n    float sum = 0.;\n        p += vec3(5., 0., 0.);\n        for(int i = 1; i <= 8; i++)\n        {\n            sum += noise222(p * scale * pow(2., float(i))) / pow(1.7, float(i));\n        }\n        return max(sum - threshold, 0.);\n}\nfloat fbm(vec3 p, vec3 cam){\n//p.yz = rot(p.yz, iTime*0.3);\n//float a = texture(iChannel0, p).x*0.5 +texture(iChannel0, p*2.).y*0.25+\n//texture(iChannel0, p*4.).z*0.125+texture(iChannel0, p*8.).x*0.0625;\n//float a = texture(iChannel0, p).x*0.9;\n\nfloat b = fbmss(p*232.);\n\nfloat Srb = clamp(remap((cam.z-6500.)/2000., 0., 0.07, 0., 1.),0.,1.);\n//a *= clamp(abs(length(p)-6500.)*0.00013, 0.0, 1.);\n//a -= clamp((p.z)*0.4,0., 1.);\n//a = max(a,0.);\n//vec3 pos = vec3(0.,0.,6500.)-p;\n//pos.xz = rot(pos.xz, iTime*200.);\n//float cap = box(pos, vec3(100.,500.,100.));\n//cap = capsule(pos, vec3(0.,-2000., 6500.), vec3(0.,2000.,6500.), 100.);\n//cap = abs(cap)+0.01;\n//float density = exp(-cap*0.00002);\nreturn clamp(((Srb)*b*clamp((cam.z-6500.)*0.44,0.,1.)),0.,1.);\n}\n\n\n//float PM(float cost, float g){\n//float a = 3./(8.*3.14159);\n//float b = ((1.0-g*g)*(1.0+cost*cost))/((2.0+g*g)*pow(1.0+g*g-2.*g*cost, 3./2.));\n//return a*b;\n//}\n//my own code as well, just can't find the math\nvec3 boreyleigh(float costheta, vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat a = 1.0+costheta*costheta;\nfloat v = 3.14159*3.14159*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave*0.000000000002))*a;\n}\n\nvec3 boreyleighconstant(vec3 wave){\nfloat n = 1.00029;\nfloat N = 1.504;\nfloat v = 8.*pow(3.14159, 3.)*pow(n*n-1., 2.);\nreturn (v/(3.*N*wave*wave*wave*wave));\n}\n\nvec3 bommie(float costheta, vec3 wave){\nfloat T = 3.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn 0.434*C*((4.*3.14159*3.14159)/(wave*wave))*0.5*Bm;\n}\nvec3 bommieconstant(vec3 wave){\nfloat T = 3.;\nfloat C = (0.6544*T-0.6510);\nvec3 Bm = 0.434*C*3.14159*((4.*3.14159*3.14159)/(wave*wave))*0.67;\nreturn Bm;\n}\n\nfloat PM(float cost, float g){\nfloat a = 3./(8.*3.14159);\nfloat b = (1.0-g*g)*(1.0+cost*cost);\nfloat c = (2.0+g*g)*pow(1.0+g*g-2.*g*cost, 3./2.);\nreturn a*(b/c);\n}\n\nfloat PR(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\nvec3 reyleighapprox(vec3 wave, float cost, float h){\nfloat n = 1.00029;\nfloat d = 1432.1;\nfloat a = (1.0+cost*cost)/(2.0*h*h);\nvec3 b = pow(2.*3.14159/wave,vec3(4.));\nfloat c = pow((n*n-1.0)/(n*n+2.),2.);\nfloat d2 = pow(d/2.,6.);\nreturn a*b*c*d2;\n}\n\nvec4 clouds2(vec3 p, vec3 d, vec3 lig){\nvec3 waves = vec3(0.00000519673, 0.0000121427, 0.0000296453);\n\nfloat transmission = 1.0;\nvec3 Ex = vec3(1.0);\n\nfloat phase = PM(max(dot(d,lig),0.), 0.76);\n\nvec3 wavelengths = vec3(680., 550., 440.);\n\nvec2 t = vec2(0.);\nvec3 energy = vec3(1.);//0000296453\nvec3 rayleighcoefficients = vec3(0.00000519673, 0.0000121427, 0.0000296453);\nvec3 T = vec3(0.);\nfloat reyleighH = 8500.;\nfloat MieH = 1200.;\n\nvec3 accumulateLight = vec3(0.);\nvec3 accumulateLightMie = vec3(0.);\nvec3 accumother = vec3(0.);\n//if(intersect(p, vec3(0.,0.,0.), 8500.0, d, t)){\n//col = vec3(t.x);\nvec3 ccc = p;\nvec3 cam = p;\nvec3 fin = p+d*t.y;\nvec3 div = vec3(fin-cam) / 40.;\nvec3 precomputed = ((vec3(5.8,13.5,33.1)))*exp(-6.);\nvec3 precomputed2 = vec3(0.210)*exp(-5.);\nfloat mm = length(cam-fin);\nvec3 energyLoss = exp(-rayleighcoefficients*mm);\nfloat Is = 3.;\nvec3 Ip = vec3(0.);\nvec3 accum = vec3(0.);\nfloat accum11 = 0.;\nfloat minus = 0.32;\nfloat mult = 0.00002;\n\nfloat zz = max(dot(vec3(0.,0.,1.),lig),0.);\n/////////////\nvec3 br = boreyleighconstant(wavelengths.zyx*0.0005);\nvec3 bm = bommieconstant(wavelengths*0.024);\n\n////////////\nfloat pm = PM(max(dot(vec3(0.,0.,1.),lig),0.), 0.76)*5.;\nfloat pr = PR(max(dot(vec3(0.,0.,1.),lig),0.))*2.;\nfloat pm2 = PM(max(dot(d,lig),0.), 0.76)*7.;\nfloat pr2 = PR(max(dot(d,lig),0.))*4.;\nfloat keepdensity = 0.;\n\nfor(int i = 0; i < 180; i++){\n//accum += ph(length(cam), reyleighH)*length(div);\nfloat density = max(fbm(cam*mult, cam)-minus-abs(cam.z-6500.)*0.00044, 0. );\n//max(fbm(cam*mult, cam)-minus-abs(cam.z-8400.)*0.00194, 0. );\ndensity = smoothstep(0.,1.,density);\ndensity = clamp(density, 0., 1.);\nkeepdensity += density;\nif(density > 0.01 && length(cam-ccc)>200.){\naccum += density*2.1;\n//accum11 += ph(length(cam)-6500., MieH)*length(div);\n\nvec3 accum2 = vec3(0.);\n//float accum3 = 0.;\n//energy = energy*(1.0-rayleighcoefficients);\n        vec3 cam2 = cam;\n        \n        for(int k = 0; k < 10; k++){\n            float density2 = max(fbm(cam2*mult, cam2)-minus-abs(cam2.z-6500.)*0.00044,0.);\n            //+ max(fbm(cam2*mult, cam2)-minus-abs(cam2.z-8400.)*0.00194,0.) ;\n            density2 = smoothstep(0.,1.,density2);\ndensity2 = clamp(density2, 0., 1.);\n\n            //accum2 += ph(length(cam2), reyleighH)*length(div2);\n            accum2 += density2*7.1;\n            //accum3 += ph(length(cam2)-6500., MieH)*length(div2);\n            cam2 += lig*30.1;\n\n        }\n\n\n//accumulateLightMie += exp(-br*accum2)\n//*length(div)*transmission*density*length(div);\n\nEx = Ex*exp(-accum*2.3);\ntransmission*= 1.0-density;\ntransmission *= 0.99;\n//accumulateLightMie += exp(-br*accum2)*90.*\n//transmission*density;\n//accumulateLight += density*Ex*(\n//(1.0-exp(-accum2*bm*10.1))*exp(-accum2*bm*10.1)*pr2\n//+(1.0-exp(-accum2*bm*125.))*pm2*exp(-accum2*bm*15.)\n//+ exp(-accum2*bm*10.1)*mix(vec3(0.1,0.07,0.02)*333., vec3(1.), smoothstep(0.,1.,zz))*0.1\n//)\n //   ;\naccumulateLight += density*max(Ex,0.03)*((1.0-exp(-3.4*bm.zyx*accum2))*exp(-3.4*bm*accum2)*1.0\n+exp(-0.1*bm*accum2)*2.1 + \nexp(-.6*accum2*(1.0-zz*0.9)) +pm2*exp(-accum2*5.1)*mix(bm.zyx*3., vec3(1.), zz)\n\n)*1.0;//*mix(bm.zyx*2.,vec3(1.),zz);\n    \naccumulateLight += density*max(Ex,0.03)*(bm.zyx\n    *exp(-0.01*waves*accum2)*0.01 + br.zyx*exp(-0.01*bm.zyx*accum2)*92.)*.02*\n    reyleighapprox(wavelengths.zyx*5.9, max(dot(d,lig),0.), accum2.x)*5.0*0.5;\n\n}\n\ncam += d*(90.6-30.*noise(cam));\n//if(length(cam)>7500.){break;}\n}\n\nreturn vec4(accumulateLight*2.0, transmission);\n\n}\n\nvec3 F(vec3 A, vec3 B, vec3 C, vec3 D, vec3 E, float cost, float y){\nreturn (1.0+A*exp(B/cost))*(1.0+C*exp(D*y) + E*cos(y)*cos(y));\n}\n\nfloat intersect(vec3 p, vec3 d, vec4 sphere){\nvec3 cam = p;\nfor(int i = 0; i < 80; i++){\nfloat dist = -(length(sphere.xyz-p)-sphere.w);\nif(dist < 0.01){\nreturn length(p-cam);\n}\np += d*dist;\n}\nreturn 0.;\n}\nfloat RayleighPhase(float cost){\nreturn (3./(16.*3.14159))*(1.0+cost*cost);\n}\nvec3 skyp2(vec3 p, vec3 d, vec3 lig){\n\nfloat l = intersect(p, d, vec4(0., 0.,0.,8500.));\nvec3 div = ((p+d*l)-p)/40.;\nvec3 wavelengths = vec3(680., 580., 440.);\nfloat accum = 0.;\nvec3 energy = vec3(0.);\nvec3 waves = vec3(0.00000519673, 0.0000121427, 0.0000296453);\n\nfor(int i = 0; i < 40; i++){\naccum += exp(-(length(p)-3500.)/8500.)*length(div);\n\nfloat accum2 = 0.;\nvec3 cam = p;\n\nfloat l2 = intersect(p, lig, vec4(0.,0.,0.,8500.));\nvec3 div2 = ((cam+lig*l2)-cam);\nfloat CP = length(div2);\n\ndiv2 /= 40.;\nif(length(p)-6500. > 0.05){\nif(l2 > 0. ){\n//accum2 += exp(-length());\n    for(int k = 0; k < 40; k++){\n        accum2 += exp(-(length(p)-3500.)/8500.)*length(div2);\n        \n        cam += div2;\n    }\n    \n    //energy += S(wavelengths, max(dot(d,lig),0.), length(p)-6500.);\n    \n    //energy += reyleighapprox(wavelengths*0.0000004, max(dot(d,lig),0.), length(p));\n}\n\nenergy += exp(-waves*89.*accum)\n    *exp(-waves*4.*accum2)*length(div)*\n    reyleighapprox(wavelengths*0.067, max(dot(d,lig),0.), length(p))\n    *RayleighPhase(max(dot(d,lig),-1.));\n}\np+=div;\n}\nvec3 final = energy*0.11+exp(-acos(max(dot(d,lig),0.))*50.);\nvec4 c = clouds2(vec3(0.,0.,5200.),d,lig);\nfinal = final*c.w + c.xyz;\nreturn final;\n}\n\nvec3 skyp3(vec3 d, vec3 lig){\nfloat cost = max(dot(lig, vec3(0.,0.,1.)),0.);\nfloat thetaS = acos(cost);\nfloat cosp = max(dot(d, vec3(0.,0.,1.)),0.);\nfloat thetaP = acos(cosp);\nfloat y = acos(max(dot(d,lig),0.));\nfloat ycos = cos(y);\n\nfloat T = 2.;\n\nfloat Yz = (4.0453*T-4.9710)*tan((4./9. - T/120.)*(3.14159-2.*thetaS))-0.2155*T+2.4192;\n\nfloat tt = thetaS*thetaS;\nfloat ttt =  thetaS*thetaS*thetaS;\nvec3 xA = vec3(0.00166*ttt-0.00375*tt+0.00209*thetaS,\n-0.02903*ttt + 0.06377*tt - 0.03202*thetaS + 0.00394,\n0.11693*ttt - 0.21196*tt + 0.06052*thetaS + 0.25886\n);\nfloat xz = xA.x*T*T + xA.y*T + xA.z;\n\nvec3 yA = vec3(0.00275*ttt-0.00610*tt+0.00317*thetaS,\n-0.04214*ttt + 0.08970*tt - 0.04153*thetaS + 0.00516,\n0.15346*ttt - 0.26756*tt + 0.06670*thetaS + 0.26688\n);\nfloat yz = yA.x*T*T + yA.y*T + yA.z;\n\nvec3 A = vec3(0.1787*T-1.4630, -0.0193*T-0.2592, -0.0167*T-0.2608);\nvec3 B = vec3(-0.3554*T+0.4275, -0.0665*T+0.0008, -0.0950*T+0.0092);\nvec3 C = vec3(-0.0227*T+5.3251, -0.0004*T+0.2125, -0.0079*T+0.2102);\nvec3 D = vec3(0.1206*T-2.5771, -0.0641*T-0.8989, -0.0441*T-1.6537);\nvec3 E = vec3(-0.0670*T+0.3703, -0.0033*T+0.0452, -0.0109*T+0.0529);\n\nvec3 Ff = F(A,B,C,D,E,cosp, y);\nvec3 Ff2 = F(A,B,C,D,E,cos(0.), thetaS);\n//return Ff2;\nfloat Y = (Yz*Ff.x)/Ff2.x;\nfloat x = (xz*Ff.y)/Ff2.y;\nfloat ys = (yz*Ff.z)/Ff2.z;\n\nvec3 XYZ = vec3((x*Y)/ys, Y, (((1.0-x-ys)*Y)/ys)).xyz;\nvec3 RGB = vec3(3.2404542*XYZ.x - 1.5371385*XYZ.y - 0.4985314*XYZ.z,\n-0.9692660*XYZ.x + 1.8760108*XYZ.y + 0.0415560*XYZ.z,\n0.0556434*XYZ.x - 0.2040259*XYZ.y + 1.0572252*XYZ.z\n);\nvec3 final = RGB.xyz*0.03;\nvec4 c = clouds2(vec3(0.,0.,5200.),d,lig);\nfinal = final*c.w + c.xyz;\nreturn final;\n}\n\nfloat beckmann_D2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,4.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.001);\n}\n\nfloat beckmann_pdf2(vec3 m, vec3 n, float a){\nfloat cost = max(dot(n,m),0.);\nfloat a1 = 1./(3.14159*a*a*pow(cost,3.));\nfloat b1 = exp((cost*cost - 1.)/(a*a*cost*cost));\nreturn max(a1*b1,0.0001);\n}\n\nvec3 beckmann_S(vec3 n, inout uint r, float a){\n        float r1 = rndf(r);\n        float r2 = rndf(r);\n    \n        float theta = atan(sqrt(-a*a*log(1.-r1)));\n        //float theta = acos(sqrt((1.-r1)/(r1*(a*a-1.)+1.) ));\n        float phi = 2.*3.14159*r2;\n        \n        float x = cos(phi)*sin(theta);\n        float y = sin(phi)*sin(theta);\n        float z = cos(theta); \n         \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\n\nfloat beckmann_pdf(vec3 m, vec3 n, float a){\nfloat angle = acos(max(dot(m,n),0.));\nfloat a1 = 1./(3.14159*a*a*pow(max(dot(m,n),0.),3.)); // should be the pdf over a solid angle\nfloat b1 = exp(-((tan(angle)*tan(angle))/(a*a)));\nreturn max(a1*b1,0.0001);\n}\n\nfloat ggx_G(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat g1 = (2.*max(dot(n,h),0.)*max(dot(n,-wi),0.))/max(dot(-wi,h),0.);\nfloat g2 = (2.*max(dot(n,h),0.)*max(dot(n,l),0.))/max(dot(-wi,h),0.);\nfloat G = min(1.,min(g1,g2));\nreturn G;\n}\n\nfloat ggx_G2(vec3 h, vec3 n, vec3 wi, vec3 l, float a){\nfloat top = 2.*max(dot(n,-wi),0.);\nfloat bottom = max(dot(n,-wi),0.)+sqrt(a*a + (1.-a*a)*pow(max(dot(n,-wi),0.),2.));\nreturn top/bottom;\n}\n\nvec3 ggx_F(vec3 Fo, float cost){\nreturn Fo + (1.-Fo)*pow(1.-cost,5.);\n}\n\nvec3 sampleSun(vec3 n, inout uint r, float theta){\n        float diff = 1.-cos(theta);\n        float z = cos(theta) + rndf(r)*diff;\n        float angle = rndf(r)*3.14159*2.;\n        float radius = sqrt(1. - z*z);\n        float x = cos(angle) * radius;\n        float y = sin(angle) * radius;\n        \n        vec3 W = (abs(n.x)>0.99)?vec3(0.,1.,0.):vec3(1.,0.,0.);\n        vec3 N = n;\n        vec3 T = normalize(cross(N,W));\n        vec3 B = cross(T,N);\n        return normalize(x*T + y*B + z*N);\n}\nvec3 lerp(vec3 a, vec3 b, float t){\nreturn a + (b-a)*t;\n}\nfloat lerp(float a, float b, float t){\nreturn a + (b-a)*t;\n}\nvec3 renderpixel(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 p2 = p;\n    vec3 d2 = d;\n    float dd;\n    vec3 prevp = p;\n    vec3 tt = vec3(1.);\n    float l = 0.;\n    vec3 c = vec3(0.9);\n    float a = 0.;\n    float probability=0.;\n    const int bounces = 36;\n    float ll = 0.;\n    float k = 0.;\n    for(int i = 0; i < bounces; i++){\n        if(trac(p,d,dd,l,c,a,probability,r,k)){\n            vec3 n = norm(p-d*0.01,dd);\n            p+=n*0.03;\n            vec3 wi = d;\n            //float a = 100000.;\n//explained above\nfloat rough = a;\nrough = rough*rough;\n            d = angledircos(n,r);\n        if(i == 0)ll=length(p-prevp);\n            float number = rndf(r);\n            //float probability = 0.9;\n            if(number < probability){\n               d = beckmann_S(reflect(wi,n), r, rough);\n            }\n//\n            bool bo = (int(fragCoord.x)/64 + int(fragCoord.y)/64)%2==0;\n           //bo = true;\n          //bo = fragCoord.x < iResolution.x*0.5;\n            if(l>0.01){\n                col += tt*c;\n                break;\n            }\n            //vec3(0.,4.,4.)-p, vec3(1.,1.\n            //vec3(0.,-4.,0.)-p, vec3(8.,0.00000000000004,8.))\n            vec3 lpos = vec3(-5.,-59.5,15.);\n            float area = 44.*44.;\n            float r1 = rndf(r)*2.0-1.0;\n            float r2 = rndf(r)*2.0-1.0;\n\n            lpos.x += r1*22.;\n            lpos.z += r2*22.;\n            vec3 ldir = lpos-p;\n            float dist2 = length(lpos-p)*length(lpos-p);\n           \n           ////////////////////////////\n           float theta = 0.1;\n           vec3 lightdir = sampleSun(lig, r, theta);\n           /////////////////////////////\n\n\n            ldir = normalize(lightdir);\n            \n            vec3 brdf = c/3.14159 ;\n            //float rough = 1.;\n\n            //Oren-Nayar model\n           /* float A = 1.0-0.5*((rough*rough)/(rough*rough+0.33));\n            float B = 0.45*((rough*rough)/(rough*rough+0.09));\n            float thetai = acos(max(dot(d,n),0.));\n            float thetar = acos(max(dot(-wi, n),0.));\n            float aa = max(thetai,thetar);\n            float bb = min(thetai, thetar);\n            //float phii = acos(max(dot(vec3(-1.,0.,0.), ),0.));\n            */\n            //brdf = c/3.14159*(A+(B*max(0., dot(d,-wi))*sin(aa)*tan(bb)));\n            \n            float hemipdf = max(dot(d,n),0.)/3.14159;\n            hemipdf = max(hemipdf, 0.0000000000000001);\n        \n            vec3 brdf2 = c/3.14159 ;\n            float hemipdf2 = max(dot(d,n),0.)/3.14159;\n            hemipdf2 = max(hemipdf2, 0.0000000000000001);\n            vec3 h = normalize(d+ -wi);\n            vec3 h2 = normalize(ldir+-wi);\n             float D;\n           D=beckmann_D2(reflect(wi,n), d, rough);\n           \n               float G = ggx_G2(h,n,wi,d,rough);//cook torrance based geometry term\n           vec3 F = ggx_F(c, max(dot(-wi, n), 0.));//schlicks approx to the fresnel term\n           vec3 specular = (D*G*F)/max(4.*max(dot(-wi,n),0.)*max(dot(d,n),0.6),0.0001);\n        \n        \n        float D2; \n   D2 = beckmann_D2(reflect(ldir,n), wi, rough);\n  \n   float G2 =ggx_G2(h2,n,wi,ldir,rough);\n   vec3 F2 = ggx_F(c, dot(-wi, h2));\n   vec3 specular2 = (D2*G2*F2)/max(4.*dot(-wi,n)*dot(ldir,n),0.0001);\n   \n   \n   \n               \n        \n            //if(number < probability){\n                brdf = lerp(brdf,specular,probability);\n                hemipdf = lerp(hemipdf,beckmann_pdf2(reflect(wi,n),d,rough), probability);\n                hemipdf = max(0.000000001, hemipdf);\n\n                brdf2 = lerp(brdf2,specular2,probability);\n                hemipdf2 = lerp(hemipdf2,beckmann_pdf2(reflect(ldir,n),wi,rough),probability);\n                \n                hemipdf2 = max(hemipdf2,0.00000001);\n            //}\n            \n                                           brdf *=  (1.0+2.*probability*max(dot(d,n),0.));\n                                brdf2 *=  (1.0+2.*probability*max(dot(d,n),0.));\n\n            \n            vec3 L = vec3(0.9,0.7,0.5)*4.;\n            \n           vec3 curr = p;\n            float l2;\n            float a2,prob2;\n            float k2;\n            //vec3 lightdir = anglephong(100000., lig, r);\n            //theta - 0, pi/2\n            float height = cos(theta);\n            float ar = 2.*3.14159*(1.0-height);\n            if(!trac(curr, lightdir,dd,l2,c,a2,prob2,r,k2) && dot(ldir,n)>0.){\n                //if(i==0)tt *= brdf*(max(dot(d,n),0.00001)/hemipdf);\n                float brpdf = max(dot(ldir, n),0.)/3.14159;\n                brpdf = max(brpdf, 0.00000001);\n                //if(number < probability){\n                    brpdf = lerp(brpdf,hemipdf2,probability);\n                //}\n                float pdf = 1./ar;\n                float weight = powerh(1., pdf, 1., brpdf);\n                col += tt*brdf2*L*weight*dot(ldir,n);\n                //break;\n            }\n            \n           //MIS\n           float an = acos(dot(d,lig));\n           if((an) <= theta){\n               curr = p;\n               if(!trac(curr, d,dd,l2,c,a2,prob2,r,k2)){\n                   float heightbrdf = cos(an);\n                   float arbrdf = 2.*3.14159*(1.-heightbrdf);\n                   float pdf = 1./arbrdf;\n                   float weight = powerh(1.,hemipdf,1.,pdf);\n                   col += tt*brdf*weight*L*max(dot(d,n),0.)/hemipdf;\n                   break;\n               }\n           }\n            \n            /*if(bo){\n               if(i == 0 && l > 0.01){\n                   col+=tt*l;\n                   break;\n               }\n               if(l > 0.01){\n                   break;\n               }\n           \n               float l2;\n               vec3 lpp = p;\n               float a2,prob2;\n               if(trac(lpp,ldir,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(lpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n                   if(l2>0.01 && i < bounces-1 && dot(ln, -ldir) > 0.0 && dot(n, ldir) > 0.0){\n                  \n                       float pdf = dist2/(max(dot(ln, -ldir),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       float brpdf = max(dot(ldir, n),0.)/3.14159;\n                       brpdf = max(brpdf, 0.00000001);\n                       if(number < probability){\n                           brpdf = hemipdf2;\n                       }\n                       //power heuristics as explained above, on the high specular parts,\n                       //the weight will return a number closer to 0, so that the direct light sampling\n                       //wouldn't sample in an area where it's useless \n                       float weight = powerh(1., pdf, 1., brpdf);\n                       col += (tt*brdf2*l2*weight)*(max(dot(n, ldir),0.000001)/pdf);\n                   }\n               }\n           \n           //brdf sampling for mis \n               vec3 bpp = p;\n               if(trac(bpp,d,dd,l2,c,a2,prob2)){\n                   vec3 ln = vec3(0.,1.,0.);\n                   if(bpp.y < lpos.y)ln = vec3(0.,-1.,0.);\n        \n                   if(l2>0.01 ){\n                   \n                       float dist3 = length(bpp-p)*length(bpp-p);\n                       float pdf = dist3/(max(dot(ln, -d),0.0)*area);\n                       pdf = max(pdf, 0.01);\n                       //float hemipdf = max(dot(d,n),0.)/3.14159;\n                       //hemipdf = max(hemipdf, 0.00000001);\n                       float weight = powerh(1., hemipdf, 1., pdf);\n                       col += (tt*brdf*weight*l2)*(max(dot(d,n),0.000001)/hemipdf);\n                   }\n               }\n            }*/        \n            tt *= brdf*(max(dot(d,n),0.)/hemipdf);\n            \n            if(i > 3){\n                float t_max = max(tt.x, max(tt.y, tt.z));\n                if(rndf(r) > t_max){\n                    break;\n                }\n                tt *= 1./t_max;\n            }\n\n           /*if(i == 0){\n             //   col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;\n                    }\n                }\n                col += accum*vec3(0.9,0.6,0.4)*0.6;\n            }else{\n                                //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\n            }*/\n        }else{\n        float k2;\n        //  col += pow(k/120.,2.)*vec3(0.3,0.7,0.8)*1.4;\nif(i==0)ll=length(p-prevp);\n/*           if(i == 0){\n                const int samples = 5;\n                vec3 dir = normalize(p-prevp);\n                float m = length(p-prevp)/float(samples);\n                float accum = 0.;\n                vec3 curr = prevp;\n                float l2;\n                float a2,prob2;\n                vec3 lightdir = anglephong(1000., lig, r);\n                for(int kk = 0; kk < samples; kk++){\n                    curr += dir*m*rndf(r);\n                    vec3 ppp = curr;\n                    if(!trac(ppp, lig,dd,l2,c,a2,prob2,r,k2)){\n                        accum += 0.1;;\n                    }\n                }\n                col += accum*vec3(0.9,0.6,0.4)*0.6;\n            }*/\n            if(i==0){\n                col += tt*skyp2(vec3(0.,0.,7000.),d, lig)*0.5;\n            }else{\n                col += tt*skyp2(vec3(0.,0.,7000.),d, lig)*0.9;\n            }\n            //col += tt*texture(iChannel1,d.xzy).xyz;\n            break;\n        }\n    }\n    \n    /*vec3 glow;\n    float l2,a2,prob2;\n    vec3 c2;\n    for(int i = 0; i < 40; i++){\n        float dist2 = abs(dis2(p2))+0.001;\n        p2 += d2*dist2;\n        if(dis(p2,l2,c2,a2,prob2) < 0.01)break;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*pal(escape, vec3(0.9,0.9,0.9),vec3(0.4,0.4,0.9));\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }*/\n    //col += glow*0.0*vec3(0.4,0.7,0.8)*texture(iChannel1, (p.xz-p.y)*0.9).x;\n    //col += 1./(1.+exp(-2.*(ll*0.2-2.)))*vec3(0.2,0.2,0.2)*0.5;\n    return col;\n}\nvec3 get_color(vec3 p, vec3 d, vec2 frag){\n    vec3 prevp = p;\n    vec3 p2 = p;\n    vec3 d2 = d;\n    vec3 prevp2 = p2;\n    bool hit_obj = false;\n    vec3 ligc = vec3(0.9,0.8,0.4);\n    vec3 col = vec3(0.);\n    float k = 0.;\n    vec3 glow = vec3(0.);\n    float l = 0.;\n    vec3 c = vec3(0.);\n    float a = 0.;\n    float prob = 0.;\n    bool ref = false;\n    for(int i = 0; i < 80; i++){\n    //dis(p,l,c,a,prob);\n    //float dis(vec3 p, inout float l, inout vec3 c, inout float a2, inout float prob){\n\n        float dist2 = abs(dis(p2,l,c,a,prob))+0.001;\n        p2 += d2*dist2;\n        //0.5, 0.5, 0.5\t\t0.5, 0.5, 0.5\t1.0, 1.0, 1.0\t0.00, 0.10, 0.20\n        glow += vec3(exp(-dist2*200.)*0.001,\n        exp(-dist2*300.)*0.001,\n        exp(-dist2*400.)*0.001\n        )*c;\n        //glow += 0.05/(0.004 + dist2*dist2)*palette(length(p2+iTime*0.4), vec3(0.5), vec3(0.5), vec3(1.), vec3(0.,0.1,0.2));\n    }\n    col = glow*12.;\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////\n    vec3 prev_state = texture(iChannel1, vec2(0.99)).xyz;\n\n    int tiles = 4;\n    int samples = 100;\n    vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/samples)%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(prev_state.x > 0.5){\n        if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n        if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\n    }\n    int jk = iFrame%samples;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 diff = ((1.)/iResolution.xy);\n   // uv *= 0.5;\n    //uv.x += 0.1;\n    uv = uv * 2.0 - 1.0;\n    float r1 = rndf(r)*2.0-1.0;\n    float r2 = rndf(r)*2.0-1.0;\n    uv += diff*(vec2(r1,r2))*1.;\n\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n  \n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n   // d.xz = rot(d.xz, 30.);\n    \n    \n    vec3 p = texture(iChannel1, vec2(0.)).xyz;\n    \n    vec3 rotations = texture(iChannel1, vec2(0.55)).xyz;\n    //d.xz = rot(d.xz,90.);\n    //d.yz = rot(d.yz,rota);\n    float rota = 0.;\n    float rotb = 0.;\n    rota = rotations.x;\n    rotb = rotations.y;\n    d.yz = rot(d.yz,rota);\n    d.xy = rot(d.xy, rotb);\n    vec3 col = vec3(0.);\n    if(prev_state.x > 0.5){\n        \n        float focaldist = 2.3;\n        float radius = 0.001;\n\n        vec3 camdirection = vec3(0.,1.,0.);\n        camdirection.yz = rot(camdirection.yz, rota);\n        camdirection.xy = rot(camdirection.xy, rotb);\n        vec3 sidex = vec3(1.,0.,0.);\n        vec3 sidey = vec3(0.,0.,1.);\n       // sidex.yz = rot2(sidex.yz,rota);\n        //sidex.xz = rot(sidex.xz, -20.);\n       // sidex.yz = rot(sidex.yz,rota);\n        sidex.xy = rot(sidex.xy,rotb);\n    //    sidex.yz = rot(sidex.yz,rota);\n\n        //sidey.xz = rot(sidey.xz,-20.);\n        sidey.yz = rot(sidey.yz,rota);\n        sidey.xy = rot(sidey.xy,rotb);\n    \n        float ang = rndf(r)*2.0*3.14159;\n        float dist = min(length((vec2(0.0,-0.4)-uv)*0.2),1.);\n        float scale = sqrt(rndf(r))*radius;\n       //vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\n       //vec2 aa = normalize(vec2(0.,1.));\n        vec2 offset = vec2(cos(ang), sin(ang))*scale;\n        //if(offset.x > offset.y)offset.xy=offset.yx;\n        //offset.x+=-1.;\n    \n       //offset*=radius;\n       //NOT MY CODE////////////////////////\n        vec3 focuspoint = p + ((d*focaldist) / dot(d,camdirection)); //these will lie on the focal plane\n        /////////////////////////////////////\n       // vec3 dd = vec3(uv.x,1.,uv.y);\n       // dd.yz = rot(dd.yz, rota);\n       // dd.xy = rot(dd.xy, rotb);\n       //vec3 focuspoint = p+(dd*focaldist);\n        //p.xz += offset;\n\n        p = p + sidex*offset.x;\n        p = p + sidey*offset.y;\n\n        d = normalize(focuspoint - p);\n    \n    \n        col = renderpixel(p,d, r, fragCoord);\n        col = clamp(col, 0., 1.);\n        //col = tonemap_uchimura2(col);\n        //col = pow(col, vec3(1.6))*1.8;\n        //col = pow(col, vec3(1./2.2));\n\n        if(jk != 0){\n            col += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n        }\n    }else{\n        col = get_color(p,d,fragCoord.xy);\n    }\n    // Output to screen\n    fragColor = vec4(col,float(jk));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2GR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 36, 59, 59, 213], [251, 251, 308, 308, 894]], "test": "untested"}
{"id": "NtS3zd", "name": "Colored and ordered dithering", "author": "Felipe_Rodrigues", "description": "a simple RGB ordered dithering, based on a 3 color gradient, and a palette filter", "tags": ["colored", "dithering", "ordered"], "likes": 9, "viewed": 393, "published": 3, "date": "1624466474", "time_retrieved": "2024-07-30T19:14:28.177530", "image_code": "float GradientColorQuantity =3.;\nfloat noisePercent = 0.2;\n\nvec3 BeforeColorPalette[] = vec3[](\n    vec3(0.102, 0.11, 0.173),\n    vec3(0.36,0.15,0.36),\n    vec3(0.69,0.24,0.33),\n    vec3(0.94,0.49,0.34),\n    \n    vec3(1.0,0.8,0.46),\n    vec3(0.65,0.94,0.44),\n    vec3(0.22,0.72,0.39),\n    vec3(0.15,0.44,0.47),\n    \n    vec3(0.16,0.21,0.44),\n    vec3(0.23,0.36,0.79),\n    vec3(0.25,0.65,0.96),\n    vec3(0.45,0.94,0.97),\n    \n    vec3(0.96,0.96,0.96),\n    vec3(0.58,0.69,0.76),\n    vec3(0.34,0.42,0.53),\n    vec3(0.2,0.24,0.34)\n);  \n\nvec3 AfterColorPalette[] = vec3[](\n    vec3(0.102, 0.11, 0.173),\n    vec3(0.36,0.15,0.36),\n    vec3(0.69,0.24,0.33),\n    vec3(0.94,0.49,0.34),\n    \n    vec3(1.0,0.8,0.46),\n    vec3(0.65,0.94,0.44),\n    vec3(0.22,0.72,0.39),\n    vec3(0.15,0.44,0.47),\n    \n    vec3(0.16,0.21,0.44),\n    vec3(0.23,0.36,0.79),\n    vec3(0.25,0.65,0.96),\n    vec3(0.45,0.94,0.97),\n    \n    vec3(0.96,0.96,0.96),\n    vec3(0.58,0.69,0.76),\n    vec3(0.34,0.42,0.53),\n    vec3(0.2,0.24,0.34)\n    \n);\n\nfloat GetNoise(vec2 uv){\n    return fract(sin(uv.x+1000.0*uv.y+iTime*20.0)*10000.0)*noisePercent;    \n}\n\nfloat Get(float pixelPosition){\n    return(mod(pixelPosition,GradientColorQuantity)/GradientColorQuantity);\n}\n\nfloat GetR(float pixelPosition)\n{\n    return Get(pixelPosition + GradientColorQuantity*1./3.);\n}\n\nfloat GetG(float pixelPosition)\n{\n    return Get(pixelPosition + GradientColorQuantity*2./3.);\n}\n\nfloat GetB(float pixelPosition)\n{\n    return Get(pixelPosition + GradientColorQuantity*3./3.);\n}\n\nvec3 GetNearstColorPalette(vec3 currentColor,vec3 colorPalette[16]){\n    float nearstDistance = 10000.0;\n    vec3 nearstColor;\n    for(int i ; i<colorPalette.length() ; i++){\n       vec3 newColor = colorPalette[i];\n       float newDistance = distance(currentColor,newColor);\n       if(newDistance<=nearstDistance){\n           nearstColor = newColor;\n           nearstDistance = newDistance; \n       } \n    }\n    return nearstColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //default uv and aspectRatio\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x/iResolution.y;\n\n\n    //grayscale gradient\n    float x = Get(fragCoord.x);\n    float y = Get(fragCoord.y);\n    //float value = (x+y)/2.0;  // simple average\n    //float value = x*y; // subtrative\n    //float value = x+y; // aditive\n    float value = ((x+y)/2.0+(x*y)/2.0);\n    fragColor = vec4(value);\n   \n   \n    //pixel color sample\n    vec3 imageColor = texture(iChannel0,uv).rgb;    \n    \n    vec3 paletteColor = GetNearstColorPalette(imageColor,BeforeColorPalette);\n    //calculate a gradient x and y\n    vec3 stepEgdeX = vec3(GetR(fragCoord.x),GetG(fragCoord.x),GetB(fragCoord.x));\n    vec3 stepEgdeY = vec3(GetR(fragCoord.y),GetG(fragCoord.y),GetB(fragCoord.y));\n    \n    // mix both gradiant \n    //vec3 valueEdge = (stepEgdeX + stepEgdeY)/2.0; // simple average\n    //vec3 valueEdge = (stepEgdeX * stepEgdeY); // subtrative\n    //vec3 valueEdge = (stepEgdeX + stepEgdeY); // aditive\n    \n    vec3 valueEdge = ((stepEgdeX + stepEgdeY) + (stepEgdeX * stepEgdeY))/2.; // simple average of (subtractive and aditive)\n    \n    // dithering on the gradient\n    vec3 newColor = step(valueEdge+GetNoise(uv),paletteColor); \n    \n    \n    vec3 afterColor = GetNearstColorPalette(newColor,AfterColorPalette); \n    \n    fragColor = vec4(afterColor,1.0); // debug after palette effect\n    \n    //fragColor = vec4(newColor,1.0);      // debug the dithering\n    \n    //fragColor = vec4(imageColor,1.0);  // debug the image\n\n    //fragColor = vec4(valueEdge,1.0);   // debug the gradient \n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3zd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1008, 1008, 1032, 1032, 1111], [1113, 1113, 1144, 1144, 1222], [1224, 1224, 1257, 1257, 1320], [1322, 1322, 1355, 1355, 1418], [1420, 1420, 1453, 1453, 1516], [1518, 1518, 1586, 1586, 1951], [1953, 1953, 2010, 2043, 3603]], "test": "untested"}
{"id": "flBGzd", "name": "coverage of uniform vs blue poin", "author": "FabriceNeyret2", "description": "random L² points distribution.   Mouse to seed. \nLeft: Uniform ( i.e. Poisson, i.e.  white noise )\nRight: ~blue ( here, jittered grid ).\nCoverage is better, i.e. variance lower,  for the ~blue distribution.   try r = 2.", "tags": ["poisson", "stats", "pointsdistribution"], "likes": 9, "viewed": 315, "published": 3, "date": "1624465862", "time_retrieved": "2024-07-30T19:14:28.928522", "image_code": "int   L = 10;  // LxL point distribution. left: Uniform right: Blue\nfloat r = 1.;  // kernel radius \n\n#define hash(i)    fract(sin( iMouse.xy + float(i) * vec2(12.9898, 78.233) ) * 43758.5453)// hash 1→2\n#define Pu(i)    ( hash(i) * vec2(-a,a) - vec2(0,1) )                   // uniform distrib\n#define Pb(i)    ( vec2(i%L,i/L)/l  * a - vec2(0,1) + hash(i)/l )       // ~blue distrib \n#define Ks(P)      smoothstep(2.*r/l, 0., length(P-U) ) / (r*r)           // splat kernel\n#define Kc(P)      smoothstep(3./R.y, 0., abs(length(P-U)-1./l) )         // circle kernel \n//#define Kc(P)    smoothstep(3./R.y, 0., abs(mod(length(P-U),.4/l)-.2/l) )*.02/length(P-U) // sin kernel  \n#define  K(P)    ( mod(iTime,4.) < 2. ? Ks(P) : Kc(P) )                 // kernel\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n    float l = float(L), a = R.x/R.y; \n\n    O = vec4(0);\n    if (U.x<0.)\n        for(int i=0; i<L*L; i++)\n            O += K(Pu(i));\n    else\n        for(int i=0; i<L*L; i++)\n            O += K(Pb(i));\n            \n    O*=.5;    // to better see superimposition\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[760, 760, 798, 798, 1123]], "test": "untested"}
{"id": "7l2GR3", "name": "Proud / Pride Shader", "author": "byt3_m3chanic", "description": "Come for the Pride / Stay for the Dance Music.\nMoar typography stuff - slowly building out a full character set however needs optimization. ", "tags": ["raymarching", "typography", "pride"], "likes": 7, "viewed": 347, "published": 3, "date": "1624448074", "time_retrieved": "2024-07-30T19:14:29.688491", "image_code": "// 🌈 PROUD/PRIDE\n// \n// Being seen is important. / giving others hope that\n// they can succeed and be more / together we're all stronger.\n//\n// technical - typography created from sdf shapes and extruded.\n// using some simple linear stepping functions to time the \n// motion and morphing of words.\n//\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    40.\n#define MIN_DIST    .001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n\nfloat box(vec3 p, vec3 b, in vec4 r )\n{   r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\tvec3 d = abs(p) - b+vec3(r.x,0,0);\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box( in vec2 p, in vec2 b, in vec4 r ){\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nmat2 r22;\n// Letters from 2D to 3D extruded SDF's\nfloat getP(vec2 uv)\n{\n    float letp = box(uv-vec2(0,.1),vec2(.15),vec4(.15,.15,.00,0));\n    letp=abs(letp)-.05;\n    letp=min(box(uv+vec2(.15, .0),vec2(.05,.3)),letp);\n    return letp;\n}\nfloat getR(vec2 uv)\n{\n    float letr = box(uv-vec2(0,.1),vec2(.15),vec4(.15,.15,.00,0));\n    letr=abs(letr)-.05;\n    letr=min(box(uv+vec2(.15,.0),vec2(.05,.3)),letr);\n    vec2 uu = uv+vec2(-.1, .175);\n    uu.xy*=r22;\n    letr=min(box(uu,vec2(.05,.175)),letr);\n    letr=max(letr, -box(uv+vec2(-.1, .37),vec2(.17,.06)) ); \n    return letr;\n}\nfloat getI(vec2 uv)\n{\n    uv.y=abs(uv.y);\n    float leti = box(uv,vec2(.05,.3));\n    leti = min(box(uv-vec2(.0, .25),vec2(.20,.05)),leti);\n    return leti;\n}\nfloat getD(vec2 uv)\n{\n    float letd = box(uv,vec2(.145,.25),vec4(.125,.125,.00,0));\n    letd=abs(letd)-.05;\n    letd=min(box(uv+vec2(.145, .0),vec2(.05,.3)),letd);\n    return letd;\n}\nfloat getE(vec2 uv)\n{\n    uv.y=abs(uv.y);\n    float lete = box(uv+vec2(.15,0),vec2(.05,.3));\n    lete = min(box(uv+vec2(.05, .0),vec2(.125,.05)),lete);\n    lete = min(box(uv-vec2(.02, .25),vec2(.175,.05)),lete);\n    return lete;\n}\nfloat getO(vec2 uv)\n{\n    float leto = box(uv,vec2(.145,.25),vec4(.125));\n    leto=abs(leto)-.05;\n    return leto;\n}\nfloat getQ(vec2 uv)\n{\n    float letq = box(uv,vec2(.145,.25),vec4(.125));\n    letq=abs(letq)-.05;\n    vec2 uu = uv+vec2(-.1, .175);\n    uu.xy*=r22;\n    letq=min(box(uu,vec2(.05,.175)),letq);\n    letq=max(letq, -box(uv+vec2(-.1, .37),vec2(.17,.06)) ); \n    return letq;\n}\nfloat getU(vec2 uv)\n{\n    float letu = box(uv-vec2(0,.1),vec2(.145,.35),vec4(0,.125,.00,.125));\n    letu=abs(letu)-.05;\n    letu=min(box(uv-vec2(.145, .0),vec2(.05,.3)),letu);\n    letu = max(letu, -box(uv-vec2(.0, .8),vec2(.5,.5)) );\n    return letu;\n}\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec3 hitPoint,hit;\nfloat tmod=0.,time=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,ga6=0.;\nconst float sz = 3.;\nconst float hf = sz*.5;\n\nvec2 map (vec3 pos) {\n\tvec2 res = vec2(100.,-1.);\n\n    vec3 q = pos;\n    vec3 p = pos;\n    \n    float pr = 1e5;\n    float pd = 1e5;\n    for(int i=0;i<5;i++)\n    {\n\n        vec3 p2 = p+vec3(0,.3,0);\n        vec3 p1 = p-vec3(0,.8,0);\n        \n        mat2 g1 = rot(ga2*PI2);\n        mat2 g2 = rot(ga1*PI2);\n        mat2 g0 = rot(ga3*PI2);\n        mat2 g4 = rot(ga4*PI2);\n        \n        float oft = .2*sin(T+float(i)+ga3*PI);\n        p1.xz*=g1;\n        p1.yz*=g2;\n                \n        p2.xz*=g1;\n        p2.yz*=g2;\n        \n        float toutline,loutline,tz,tx;\n        if(i==0) { \n        vec3 tmq = p1+vec3(1.2,oft,0);\n        vec3 tmx = p2+vec3(1.2,-oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getQ(tmq.xy); \n        toutline=getP(tmx.xy); \n        }\n        if(i==1) {\n        vec3 tmq = p1+vec3(.6,oft,0);\n        vec3 tmx = p2+vec3(.6,-oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getU(tmq.xy);\n        toutline=getR(tmx.xy);\n        }\n        if(i==2) {\n        vec3 tmq = p1-vec3(.0,-oft,0);\n        vec3 tmx = p2-vec3(.0,oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getE(tmq.xy);\n        toutline=mix(getO(tmx.xy),getI(tmx.xy),ga5);\n        }\n        if(i==3) {\n        vec3 tmq = p1-vec3(.6,-oft,0);\n        vec3 tmx = p2-vec3(.6,oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getE(tmq.xy);\n        toutline=mix(getU(tmx.xy),getD(tmx.xy),ga5);\n        }\n        if(i==4) {\n        vec3 tmq = p1-vec3(1.2,-oft,0);\n        vec3 tmx = p2-vec3(1.2,oft,0);\n        tmq.xz*=g4;\n        tmx.xz*=g0;\n        tx=tmq.z;\n        tz=tmx.z;\n        loutline=getR(tmq.xy);\n        toutline=mix(getD(tmx.xy),getE(tmx.xy),ga5);\n        }\n        \n        pr = min(opx(abs(toutline)-.015,tz,.075),pr);\n        pr = min(opx(abs(loutline)-.015,tx,.075),pr);\n    \n    }\n  \n    if(pr<res.x){\n        res = vec2(pr,2.);\n    \thit=p;\n    } \n\n    float wall = q.z+1.75;\n    if(wall<res.x) {\n        hit=vec3(1.-q.x,q.yz);\n        res = vec2(wall,4.);\n    }\n    return res;\n}\n\n// Tetrahedron technique @Shane\nvec3 normal(vec3 p, float t)\n{\n    const vec2 h = vec2(1.,-1.)*.5773;\n    vec3 n = vec3(0);\n    vec3[4] e4 = vec3[4](h.xyy, h.yyx, h.yxy, h.xxx);\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\t    n += e4[i]*map(p + e4[i]*t*MIN_DIST).x;\n        if(n.x>1e8) break; // Fake non-existing conditional break.\n    }\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += ray.x*.9;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,150, 1.);\n\n    hitPoint = hit;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(0,4,12);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .8, fresnel);\n\n        ga5=1.-ga5;\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; )\n        {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        ga5=1.-ga5;\n        diff = mix(diff,diff*shdw,.75);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n\n        // materials and reflections\n        if(m==2.) {\n            vec3 mp = hitPoint*.5;\n            vec3 clr = hsv2rgb(vec3(hitPoint.x*.175,1.,.5));\n            C+=spec+(vec3(.9)*diff);\n            C=mix(C,hsv2rgb(vec3(fresnel,1.,.5)),fresnel);\n            ref = clr-fresnel;\n        }\n\n        if(m==4.) {\n\n            hitPoint.x-=T*1.5;\n            hitPoint.y+=.4*sin(T*1.4+hitPoint.x*1.3);\n            vec2 uv =hitPoint.xy*.5;    \n            float px = fwidth(uv.x);\n            vec2 grid_uv = fract(uv)-.5;\n            vec2 grid_id = floor(uv);\n\n            float chk = mod(grid_id.y + grid_id.x,2.) * 2. - 1.;\n            float hs = hash21(grid_id);\n            if(hs>.5) grid_uv.x*=-1.;\n\n            vec2 d2 = vec2(length(grid_uv-.5), length(grid_uv+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid_uv-.5) : vec2(grid_uv+.5);\n\n            float circle = length(gx)-.5;\n            float circle2 =abs(abs(circle)-.05)-.025;\n            circle2=smoothstep(-px,.001+px,circle2);\n            circle=(chk>0.^^ hs>.5)?smoothstep(-px,.001+px,circle):smoothstep(.001+px,-px,circle);\n            circle= min(circle2,circle);\n            vec3 fl = hsv2rgb(vec3(.09+hitPoint.y*.16,1.,.5));\n            h =mix(vec3(.9),fl, circle);\n            ref = vec3(1.-circle)-fresnel;\n            C+=spec+((h*diff)*.4);\n            \n        }\n\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        ga5=1.-ga5;\n    } \n\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n\n    r22=rot(0.38397243543);\n    time = T;\n    tmod = mod(time, 14.);\n    float t1 = lsp(2.0, 4.0, tmod);\n    float t2 = lsp(6.0, 10.0, tmod);\n    \n    float t3 = lsp(6.0, 8.0, tmod);\n    float t4 = lsp(8.0, 10.0, tmod);\n    \n    float t7 = lsp(0.6, 4.0, tmod);\n    float t8 = lsp(10., 12., tmod);\n\n    float t9 = lsp(3.0, 4.0, tmod);\n    float t0 = lsp(8.0, 9.0, tmod);\n    \n    ga1 = (t1-t2);\n    ga2 = (t3-t4);\n    ga3 = (t1-t3);\n    ga4 = (t7-t8);\n    ga5 = (t9-t0);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,.25,2.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    mat2 ry = rot(.15*sin(time*.03));\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 2.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n    // gamma\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n", "image_inputs": [{"id": 27655, "src": "https://soundcloud.com/replay-48063375/erasure-chains-of-love-combo-mix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2GR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[468, 468, 489, 489, 544], [545, 545, 563, 563, 608], [609, 609, 628, 628, 660], [661, 661, 705, 705, 760], [762, 762, 801, 801, 959], [960, 960, 994, 994, 1074], [1075, 1075, 1120, 1120, 1277], [1288, 1328, 1349, 1349, 1514], [1515, 1515, 1536, 1536, 1854], [1855, 1855, 1876, 1876, 2012], [2013, 2013, 2034, 2034, 2196], [2197, 2197, 2218, 2218, 2427], [2428, 2428, 2449, 2449, 2544], [2545, 2545, 2566, 2566, 2815], [2816, 2816, 2837, 2837, 3068], [3069, 3069, 3118, 3118, 3214], [3346, 3346, 3367, 3367, 5532], [5906, 5906, 5961, 5961, 6179], [6181, 6198, 6225, 6225, 6351], [8912, 8912, 8953, 8953, 9947]], "test": "untested"}
{"id": "NtSGzt", "name": "Flaming Asteroids", "author": "dr2", "description": "Another quiet day on the moon", "tags": ["fire", "moon", "astronomy", "asteroid"], "likes": 11, "viewed": 299, "published": 3, "date": "1624445073", "time_retrieved": "2024-07-30T19:14:31.194463", "image_code": "// \"Flaming Asteroids\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Not sure about the scientific accuracy... (flame idea from nimitz's \"Re-entry\")\n\nfloat PrSphDf (vec3 p, float r);\nfloat VPoly (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Maxv3 (vec3 p);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3f (float p);\nvec3 Hashv3v3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2e (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 astCs;\nvec3 astPos, aRand, sunDir;\nfloat dstFar, tCur, flRad, flLen, grndScl;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 ObjRot (vec3 p)\n{\n  p.xy = Rot2Cs (p.xy, astCs.xy);\n  p.zy = Rot2Cs (p.zy, astCs.zw);\n  return p;\n}\n\nvec3 ObjRotT (vec3 p)\n{\n  p.zy = Rot2Cs (p.zy, astCs.zw * vec2 (1., -1.));\n  p.xy = Rot2Cs (p.xy, astCs.xy * vec2 (1., -1.));\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{ // (from \"Dynamic Space Rocks\")\n  float d;\n  p -= astPos;\n  d = PrSphDf (p, 0.8);\n  if (d < 0.2) {\n    p = ObjRot (p);\n    d -= 0.15 * VPoly ((2. + 0.3 * aRand.z) * p);\n  }\n  return 0.7 * d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 CapsHit (vec3 ro, vec3 rd, float cRad, float cLen)\n{\n  float dIn, dOut, d, a, b, bs, w, s, ws, roz;\n  dIn = dstFar;\n  dOut = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cRad * cRad);\n  if (w > 0. && a > 0.) {\n    ws = sqrt (w);\n    d = - (b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (d > 0. && abs (s) < cLen) dIn = d;\n    else {\n      roz = ro.z;\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) {\n        d = - bs - sqrt (w);\n        if (d > 0.) dIn = d;\n      }\n      ro.z = roz;\n    }\n  }\n  if (dIn < dstFar) {\n    d = (- b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (abs (s) < cLen) dOut = d;\n    else {\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) dOut = - bs + sqrt (w);\n    }\n  }\n  return vec2 (dIn, dOut);\n}\n\nfloat FlmDens (vec3 p)\n{ // (from \"Energy Temple\")\n  float c;\n  c = max (0., 1.3 * BumpFbm3 (0.2 * vec3 (p.xy / flRad, 0.35 * p.z + 2.5 * tCur)) - 0.3 +\n     0.4 * smoothstep (-0.5 * flRad, 0.1 * flRad, p.z));\n  return c * (1. - smoothstep (-0.3 * flRad, 0., length (vec3 (p.xy,\n     p.z - clamp (p.z, - 2. * flLen, 0.))) - flRad * (1. + 0.8 * p.z / (2. * flLen)))) *\n     smoothstep (0., flRad, p.z + 2. * flLen);\n}\n\nvec3 FlmCol (vec3 ro, vec3 rd, vec2 dCyl2, float dstObj)\n{\n  vec4 col4;\n  vec3 q, c;\n  float s, ds, f, fn, r;\n  const float sMax = 50.;\n  ds = min (2. * flRad, dCyl2.y - dCyl2.x) / sMax;\n  s = dCyl2.x;\n  ro.z -= flLen;\n  q = ro + s * rd;\n  r = length (q.xy) / flRad;\n  q.xy = Rot2D (q.xy, 0.8 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n  fn = FlmDens (q);\n  col4 = vec4 (0.);\n  for (float j = float (VAR_ZERO); j < sMax; j ++) {\n    f = fn;\n    s += ds;\n    q = ro + (s + ds * Hashfv3 (16. * rd)) * rd;\n    r = length (q.xy) / flRad;\n    q.xy = Rot2D (q.xy, 0.8 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n    fn = FlmDens (q);\n    c = mix (mix (vec3 (1., 0.3, 0.1), vec3 (1., 1., 0.2), clamp ((0.3 / ds) * (f - fn), 0., 1.)),\n       vec3 (0.9, 0.8, 0.3), smoothstep (-0.5 * flRad, 0.2 * flRad, q.z)) *\n       (1. - smoothstep (-0.1, 0.1, s - dstObj));\n    col4 = col4 + (1. - col4.a) * vec4 (c, 1.) * f / sMax;\n    if (s > dstObj || col4.a > 1.) break;\n  }\n  return clamp (col4.rgb, 0., 1.);\n}\n\nfloat GrndDf (vec3 p)\n{  // (from \"Mars Copter\")\n  vec3 q;\n  float d, h, a, r, s, f;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    s = sqrt (r) / (2. * pi);\n    f = 32.;\n    h = 2.5 * s * mix (Fbm2e (f * vec2 (s, a + 1.)), Fbm2e (f * vec2 (s, a)), a);\n    d = max (r - 20., q.y - mix (s, h, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r));\n  }\n  return grndScl * d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl) \n{ // (from \"Star Globe\")\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ErCol (vec3 rd)\n{ // (from \"Moon Flight\")\n  vec3 erDir, col, vn;\n  float erRad, bs, ts;\n  erDir = normalize (vec3 (1., 0.1, 0.1));\n  erRad = 0.03;\n  col = vec3 (0.);\n  bs = dot (rd, erDir);\n  ts = bs * bs - 1. + erRad * erRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - erDir) / erRad);\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (1., 1., 0.95),\n         smoothstep (0.2, 0.8, Fbm2 (6. * vn.yz + 7.1))) * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n    }\n  }\n  return col;\n}\n\nvec3 GrndCol (vec3 ro, vec3 vn)\n{\n  vec3 col;\n  col = vec3 (0.9, 0.7, 0.4) * (0.7 + 0.3 * Fbm2 (ro.xz));\n  if (ro.y > -0.1) {\n    col = mix (col, 0.8 * col, smoothstep (0.2, 0.7, 1. - vn.y));\n    col = mix (col, 1.1 * col, smoothstep (0.6, 0.9, ro.y / grndScl +\n       0.2 * sin (32. * atan (ro.z, - ro.x))));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 roo, rdo, col, stCol, c, vn;\n  vec2 dCyl2, vf;\n  float dstObj, dstGrnd, tPos, tCyc, astDir;\n  tCyc = 15.;\n  tPos = mod (tCur, tCyc);\n  roo = ro;\n  rdo = rd;\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    col = GrndCol (ro, vn);\n    vn = GrndNf (ro);\n    vf = vec2 (0.5, 4. - 2. * smoothstep (0.7, 0.9, dstGrnd / (3. * grndScl)));\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.));\n    col *= 0.6 + 0.4 * smoothstep (1., 4., abs (abs (tPos - 0.5 * tCyc) - 0.5 * tCyc));\n  } else {\n    flRad = 1.2;\n    flLen = 30.;\n    aRand = Hashv3f (floor (tCur / tCyc) + 1.);\n    astPos = vec3 (0., 15., 10. * (tPos - 0.5 * tCyc));\n    astDir = (-0.35 + 0.7 * aRand.x + step (0.5, aRand.y)) * pi;\n    astCs = vec4 (sin ((0.3 + 0.1 * aRand.x) * pi * tPos + vec2 (0.5 * pi, 0.)),\n       sin ((0.2 + 0.1 * aRand.y) * pi * tPos + vec2 (0.5 * pi, 0.)));\n    roo.xz = Rot2D (roo.xz, astDir);\n    rd.xz = Rot2D (rd.xz, astDir);\n    ro = roo;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < min (dstGrnd, dstFar)) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vn = ObjRotT (VaryNf (16. * ObjRot (ro), vn, 8.));\n      col = vec3 (1., 0.3, 0.) * (0.3 + 0.7 * abs (vn.z));\n    } else col = vec3 (0.);\n    ro = roo;\n    ro -= astPos - vec3 (0., 0., flLen + 0.1 * flRad);\n    dCyl2 = CapsHit (ro, rd, flRad, flLen);\n    if (dCyl2.x < dstFar) {\n      c = 3. * FlmCol (ro, rd, dCyl2, dstObj);\n      if (dstObj < dstFar) col = mix (0.7 * col, c, step (0.5 * length (col), length (c)));\n      else col += c;\n      col *= smoothstep (0., 0.5, abs (abs (tPos - 0.5 * tCyc) - 0.5 * tCyc));\n    }\n    stCol = ErCol (rdo);\n    if (length (stCol) < 0.03) stCol += StarPat (rdo, 12.);\n    col = mix (col, stCol, step (Maxv3 (col), 0.4 * Maxv3 (stCol)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.5 * pi;\n  el = 0.05 * pi;\n  if (mPtr.z > 0.) az += 0.4 * pi * mPtr.x;\n  vuMat = StdVuMat (el, az);\n  grndScl = 50.;\n  ro = vuMat * vec3 (0., 0.2, -0.5) * grndScl;\n  zmFac = 3.;\n  dstFar = 10. * grndScl;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (0., 1., -1.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, a, g, w;\n  ip = floor (p);\n  fp = fract (p);\n  a = vec3 (4.);\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        g = vec3 (gx, gy, gz);\n        w = g + 0.7 * Hashv3v3 (ip + g) - fp;\n        a.z = dot (w, w);\n        if (a.z < a.x) a.xy = a.zx;\n        else a.y = min (a.z, a.y);\n      }\n    }\n  }\n  return sqrt (a.y - a.x);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{ // (variation of triangular noise in \"Misty Flight\", adapted from nimitz's \"Oblivion\")\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 1.;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2e (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.96875);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSGzt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[755, 755, 777, 777, 859], [861, 861, 884, 884, 1000], [1002, 1002, 1024, 1056, 1217], [1219, 1219, 1252, 1252, 1435], [1437, 1437, 1458, 1458, 1713], [1715, 1715, 1772, 1772, 2647], [2649, 2649, 2673, 2699, 3065], [3067, 3067, 3125, 3125, 4076], [4078, 4078, 4101, 4126, 4521], [4523, 4523, 4557, 4557, 5047], [5049, 5049, 5071, 5071, 5327], [5329, 5329, 5365, 5388, 5841], [5843, 5843, 5865, 5889, 6370], [6372, 6372, 6405, 6405, 6701], [6703, 6703, 6738, 6738, 8604], [8606, 8606, 8662, 8662, 9278], [9280, 9280, 9313, 9313, 9340], [9342, 9342, 9364, 9364, 9794], [9796, 9796, 9818, 9818, 9856], [9858, 9858, 9894, 9894, 10100], [10102, 10102, 10132, 10132, 10245], [10247, 10247, 10278, 10278, 10342], [10344, 10344, 10370, 10370, 10432], [10434, 10434, 10459, 10459, 10521], [10523, 10523, 10548, 10635, 10898], [10932, 10932, 10956, 10956, 11021], [11023, 11023, 11047, 11047, 11159], [11161, 11161, 11185, 11185, 11245], [11247, 11247, 11271, 11271, 11389], [11391, 11391, 11415, 11415, 11558], [11560, 11560, 11585, 11585, 11771], [11773, 11773, 11798, 11798, 12023], [12025, 12025, 12046, 12046, 12201], [12203, 12203, 12225, 12225, 12381], [12383, 12383, 12404, 12404, 12559], [12561, 12561, 12590, 12590, 12802], [12804, 12804, 12843, 12843, 13100]], "test": "untested"}
{"id": "flSGRt", "name": "Procedural Voronoi noise", "author": "Zyphery", "description": "A procedural generation of Voronoi noise.\n\neval generates 2 values\nx: distance of uv to point (without the square root)\ny: hash value of closest point (the z calculated in rehash3())\n\nthe y can be used in rehash3() to generate a random color", "tags": ["voronoi", "proceduralnoise"], "likes": 1, "viewed": 122, "published": 3, "date": "1624438100", "time_retrieved": "2024-07-30T19:14:32.229695", "image_code": "float hash(float x) {\n    return fract(x + 7.3215f * 1.8152f);\n}\n\nfloat hash2(vec2 a) {\n    return fract((hash(a.y * 67.6417f) + hash(a.x * 54.3815f)) * 347.1158f);\n}\n\nfloat sqr(float x) {return x*x;}\nfloat fastdist(vec2 a, vec2 b) {\n    return sqr(b.x - a.x) + sqr(b.y - a.y);\n}\n\nvec3 rehash3(float x) {\n    return vec3(fract((x + 0.583f * 59.3829f) * 394.3485f), fract((x + 0.892f * 83.6621f) * 145.3871f), fract((x + 0.763f * 47.9397f) * 957.9732f));\n}\n\n// x : distance (w/o sqrt) / y : hash\nvec2 eval(float x, float y, int seed) {\n    vec3 p[9];\n    for (int _x = -1; _x < 2; _x++) for (int _y = -1; _y < 2; _y++) {\n        vec2 _p = vec2(floor(x), floor(y)) + vec2(_x, _y);\n        float h = hash2(_p + float(seed));\n        p[_x + 1 + (_y + 1) * 3] = rehash3(h + float(seed)) + vec3(_p,0);\n    }\n    float m = 999999.9999f, z = 0.0f;\n    for (int i = 0; i < 9; i++) {\n        float d = fastdist(vec2(x, y), p[i].xy);\n        if (d < m) { m = d; z = p[i].z; }\n    }\n    return vec2(m, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y * 5.0;\n    \n    vec2 n = eval(uv.x,uv.y,0);\n    vec3 col = (1.0 - sqrt(n.x)) * rehash3(n.y);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSGRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 64], [66, 66, 87, 87, 166], [168, 168, 188, 188, 200], [201, 201, 233, 233, 279], [281, 281, 304, 304, 455], [457, 495, 534, 534, 995], [997, 997, 1054, 1104, 1271]], "test": "untested"}
{"id": "fl23Rc", "name": "Curtains Transition", "author": "turboplay", "description": "Inspired from https://www.shadertoy.com/view/3ds3Df\nConverted as transition\nChange line 40 for color and 29,36 step for curtain size.", "tags": ["cinema", "kino"], "likes": 4, "viewed": 355, "published": 3, "date": "1624427637", "time_retrieved": "2024-07-30T19:14:33.006618", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //UV MAP\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //CURTAIN MOVEMENT\n\tfloat p = (sin((iTime * 1.3f) + ((uv.x + uv.y))) + 1.f) / 2.f; \n    \n    float trs_time = mod(iTime/4.,1.0f);\n    float x_step = 0.12f * trs_time;\n    float y_step = 0.01f * trs_time;\n    float curtain_step = 0.001f  + trs_time*0.11f;\n    float mix_step = trs_time;\n    \n    //DRAW SIDE CURTAINS\n    if(uv.x - (p * 0.08f) < (0.50 - trs_time) || uv.x + (p * 0.08f) > (trs_time + 0.50))\n    {\n        //CURTAIN COLOR\n        float w = 0.f;   \n        \n        //CHECK DIRECTION/SIDE\n        if(uv.x > 0.5f)\n    \t{\n            //RIGHT\n    \t\tuv.x = ((uv.x) + (p * x_step));\n    \t\tuv.y = ((uv.y) + (p * y_step));\n        \tw = mod(1.f - uv.x, curtain_step) * 30.f;\n    \t}\n    \telse      \n    \t{\n            //LEFT\n    \t\tuv.x = ((uv.x) - (p * x_step));\n    \t\tuv.y = ((uv.y) - (p * y_step));\n        \tw = mod(uv.x , curtain_step) * 30.f;\n    \t}\n        \n        //SET COLOR\n        vec4 col = vec4(w,w, w,1.);  \n        \n    \tfragColor = mix(texture(iChannel0,uv),col,mix_step);\n       \treturn;\n    }\n    \n    //ADD MOVIE OFFSET\n  //  uv.y += sin(24.1f * iTime) * 0.001f;\n    \n \n        fragColor = texture(iChannel1,uv);\n        \n        return;\n    \n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl23Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 72, 1287]], "test": "untested"}
{"id": "fdlGzH", "name": "Raytracer - Base", "author": "SpinningCube", "description": "Converted my raymarching code into raytracing code.\n\nAdded fresnel, ggx, and gamma correction.\n\nLacking multiple bounces, I'll make that later", "tags": ["raytracing", "fresnel"], "likes": 5, "viewed": 258, "published": 3, "date": "1624424212", "time_retrieved": "2024-07-30T19:14:33.890256", "image_code": "// Filmic tonemapping curve by milesWaugh\n\nconst float epsilon = 0.001;\nconst float focalLength = 1.;\nconst float renderDist = 85.;\nconst float pi = 3.141592653589793;\n\nvec3 camera;\nfloat nearestDist;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfRoughness;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = 1.*vec3(.2, 0.4, 0.6);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nvec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius ) {\n    vec3 offset = pos - rayOrigin;\n    float dot1 = dot(offset, rayDir);\n    float dot2 = dot(offset, offset);\n    if (dot1 < 0.) {\n        return vec4(-1., 0, 0, 0);\n    }\n    if (dot2 - dot1 * dot1 < radius * radius) {\n        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));\n        return vec4(dot1 - near, (rayOrigin + (rayDir * (dot1 - near))) - pos);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0.)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvoid addIntersector( vec4 surface, vec3 col, float roughness ) {\n    float dist = surface.x;\n    if ( dist < nearestDist && dist > 0. ) {\n        nearestDist = dist;\n        if (updateMat) {\n        \tsurfCol = col;\n            surfRoughness = roughness*roughness;\n            surfNormal = normalize(surface.yzw);\n        }\n    }\n}\n\nfloat scene( vec3 rayOrigin, vec3 rayDir)\n{\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    addIntersector( Sphere( rayOrigin, rayDir, vec3(0, 0, 6), 1.), vec3(0.4,.2, 0.01), .1 );\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(3, 1, 22), 2.), vec3(0.1,0.2, 0.8), .1 );\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 7, 100), 8.), vec3(.5,0.03, 0.01), .1 );\n    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1.), vec3(0.1, 0.3, 0.1), 0.1 );\n    \n    return nearestDist;\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    \n    nearestDist = renderDist;\n        \n    scene(start, rayDir);\n        \n    if ( nearestDist < renderDist ) {\n        return vec4(1., rayDir * nearestDist + start);\n    }\n    else {\n        return vec4(0., rayDir * nearestDist + start);\n    }\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, vec3(-10, 50, 20), 1., surfNormal);\n    //directionalLight( ray, rayDir, normalize(vec3(-2,2,-1)), surfNormal, 1., 0. );\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    //return color;\n    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    float fog = clamp(length(ray - camera)/(renderDist), 0., 1.);\n    fog = fog*fog*fog;\n    //fog = fog*fog;\n    fog = smoothstep(0., 1., fog);\n    \n    vec3 finalCol = mix(surfCol * (diffuse + ambient), specular + ambient, fresnel(1.5, surfRoughness, surfNormal, -rayDir));\n    finalCol = mix(finalCol, ambient, fog);\n    \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cosTime = cos(iTime/5.);\n    cosTime = 6.*-cosTime+6.;\n    camera = vec3(.5*cosTime, .6*cosTime+0.3, 5.*cosTime-5.);\n    //camera = vec3(0,0,0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    vec3 col;\n    \n    if (rayData.x == 1.) {\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = ambient;\n    }\n\n    // Output to screen, filmic tonemapping, and gamma correction.\n    fragColor = vec4(pow(filmic(col),vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdlGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 399, 399, 442], [454, 454, 522, 522, 931], [933, 933, 1001, 1001, 1211], [1213, 1213, 1277, 1277, 1543], [1545, 1545, 1588, 1588, 2112], [2114, 2114, 2195, 2195, 2479], [2481, 2481, 2525, 2525, 2638], [2640, 2640, 2752, 2752, 3141], [3143, 3143, 3234, 3234, 3378], [3380, 3380, 3438, 3438, 3590], [3592, 3652, 3677, 3697, 3754], [3756, 3756, 3831, 3831, 3972], [3974, 3974, 4029, 4029, 4466], [4468, 4468, 4525, 4525, 5202]], "test": "untested"}
{"id": "st2GRc", "name": "Bismuth crystals 3", "author": "jarble", "description": "These patterns remind me of bismuth crystals.", "tags": ["fractal", "spiral", "bismuth"], "likes": 5, "viewed": 355, "published": 3, "date": "1624424020", "time_retrieved": "2024-07-30T19:14:34.719040", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.15;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    float s1 = (uv.y+iTime/2.)/4.0;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= (-uv-vec2(uv.x/scale+uv.y/scale1,uv.y/scale+uv.x/scale1)/scale)/scale1;\n            uv.x *= -scale1;\n            uv = fract(uv.yx-s1);\n            uv.y /= scale1;\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/1.8;\n\t}\n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2GRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 704]], "test": "untested"}
{"id": "7lj3z3", "name": "Audio \"V\"isualizer", "author": "lambmeow", "description": "Puts the \"V\" in visualizer. \nI experimented a lot with this one, hope you enjoy it!\nRIP soundcloud\n", "tags": ["fft", "sdf", "music", "visualizer"], "likes": 7, "viewed": 315, "published": 3, "date": "1624417623", "time_retrieved": "2024-07-30T19:14:35.679473", "image_code": "\n\n//blur + tone pass\n\n\nvec3 tone(vec3 x)\n{\n    return smoothstep(.1,.9, x) + x * 0.15;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //set the scale of the blur based on the position of the screen\n    float scale = length(uv - 0.5),steps = 30.;\n\n    //store the blur color\n    vec3 blur = vec3(0);\n    \n    //used to create blur effect by offseting texture coordinates\n    vec2 offset = vec2(0);\n    \n    for(float i = 0.; i < steps; i++)\n    {\n        //decrease blur each step done\n        scale *= 0.77;\n        \n        //add blur to thextrue\n        blur += texture(iChannel0, uv+offset).rgb;\n        \n        //add to the offset\n        offset -= normalize((2.* fragCoord -iResolution.xy)/iResolution.y) * scale/steps;\n        \n    }\n    \n    //normalize blur colors\n    blur= (blur/(steps));\n    \n    //add tone to the blur\n    vec3 color = tone(blur);\n    \n    //print to screen\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//get music fft data and create a ripple effect for the raymarching pass\n\n#define MUSIC_THICK 0.01 // thickness of the new sound data\n#define MUSIC_DAMP 0.98  // speed of fade out for the sound data\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n   \n   //get music data just this frame\n    float music = texture(iChannel0, vec2(uv.x, MUSIC_THICK)).r * step(uv.y, MUSIC_THICK);\n    \n    //shift prev frame data to make space for the new music data\n    vec4 prevFrame = texture(iChannel1, vec2(uv.x, uv.y - 0.01)) * step(MUSIC_THICK, uv.y);\n    \n    //apply current music data to pass\n    fragColor = prevFrame * MUSIC_DAMP + vec4(music);\n}", "buffer_a_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//raymarch pass\n\n//#define SHOW_MUSIC_DATA //show the raw music data texture \n\nmat3 raymat(vec3 ro, vec3 ta, float r)\n{\n    vec3 ww = normalize(ta -ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(r), cos(r), 0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    return mat3(uu, vv, ww);\n}\n\nvec4 map( vec3 o )\n{\n    float z = o.z;\n    \n    //loop we move away from the camera in a forward direction\n    o.z = mod(o.z, 100.);\n    \n    //get the texture coordinates to apply the music pass\n    vec2 texUV = (abs(vec2(o.x, o.z)) + 20.)/200.;\n    \n    //current music pass\n    float musicVal =  texture(iChannel0, texUV).r;\n    \n    //set the color\n    vec3 color = vec3(dot(texUV,texUV*2.), musicVal, 1.-o.z/200.) * 2. * musicVal * .75;\n    \n    //send the distance and \n    return vec4(color, o.y - musicVal * 50. - cos(o.z*0.15 + iTime));\n}\n\nvec4 raycast(vec3 ro, vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 200; i++)\n    {\n        vec4 t = map(ro + rd * dist);\n        \n        if(t.w < 0.01)\n            return t;\n        \n        dist += t.w;\n        \n        if(dist > 1000.)\n            return vec4(0.);\n    }\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) /iResolution.y;\n   \n   //create relfection on the x axis\n    uv.x = abs(uv.x - uv.x/2.); \n    \n    vec3 eye = vec3(0,40,-30);\n    \n    vec3 r = normalize(raymat(eye, vec3(0, 30, 50), 30.) * vec3(uv, 2.));\n    \n    //get color\n    vec4 val = raycast(eye, r);\n    \n\n    // Output to screen\n#ifdef SHOW_MUSIC_DATA\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n#else\n    fragColor = val;\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lj3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 88], [90, 90, 145, 145, 984]], "test": "untested"}
{"id": "7tj3z3", "name": "Spinning fractal spirals 2", "author": "jarble", "description": "These spirals spin in galaxy-like patterns.", "tags": ["fractal", "spiral", "galaxy", "spin"], "likes": 6, "viewed": 250, "published": 3, "date": "1624415920", "time_retrieved": "2024-07-30T19:14:36.525211", "image_code": "//golfed version by FabriceNeyret2\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n         U = ( R/20. -.5*U ) / R.y;\n\n    float s = .5, t = 1./1.27,\n          S = 1./t + mod( iTime/16.*t, 2.);\n    O-=O;          \n    for( int N=12, i, c=0; \n         c++ < N; \n         O = ( vec4(O.rg,abs(U.y-U)) + O.gbra ) / 2.125\n       )        \n        for( i=0; i++ < N; )       \n            U = -fract( ( U.yx + U*mat2(s,s,t,t ) * s  ) * t * vec2(-S,1./S) );       \n \n    O *= 3.;    \n}\n\n/*\n//original by jarble\n\n#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.27;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = -(fragCoord.yx*10.0-iResolution.yx)/iResolution.y/20.0;\n    //uv.y += (iTime)/25.0;\n    float s1 = (iTime)/16.;\n    float spin = scale1+fract(s1/scale1/2.)*2.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= -(-uv-((vec2(uv.x/scale+uv.y/scale,uv.y/scale1+uv.x/scale1)/(scale))))/scale1;\n            uv.x *= -spin;\n            //uv = (uv);\n            uv.y /= spin;\n            uv = -fract(uv.yx);\n            //uv /= 1.01;\n        }\n        col[2] = abs((uv.y)-(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3z3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 73, 73, 498]], "test": "untested"}
{"id": "7t23R3", "name": "Spinning fractal spirals", "author": "jarble", "description": "These spirals spin in galaxy-like patterns.", "tags": ["fractal", "spiral", "galaxy", "spin"], "likes": 4, "viewed": 268, "published": 3, "date": "1624410973", "time_retrieved": "2024-07-30T19:14:37.382917", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = -(fragCoord.yx*10.0-iResolution.yx)/iResolution.y/20.0;\n    //uv.y += (iTime)/25.0;\n    float s1 = (iTime)/16.;\n    float spin = scale1+fract(s1/scale1/2.)*2.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            \n            uv= -(-uv-((vec2(uv.x/scale+uv.y/scale1,uv.y/scale+uv.x/scale1)/(scale))))/scale1;\n            uv.x *= -spin;\n            uv = (uv);\n            uv.y /= spin;\n            uv = fract(uv.yx);\n            //uv /= 1.01;\n        }\n        col[2] = abs(uv.y-uv.x);\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t23R3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 844]], "test": "untested"}
{"id": "ft23Rc", "name": "Simple Blur Sampling", "author": "SpinningCube", "description": "Made in around 5 minutes to get more familiar with GLSL. Every pixel just averages a square of pixels around it, which results in noticable artifacts.", "tags": ["2d", "blur"], "likes": 5, "viewed": 472, "published": 3, "date": "1624391845", "time_retrieved": "2024-07-30T19:14:38.512896", "image_code": "vec4 sampleAvg(int size, int resdiv, vec2 uv) {\n    \n    vec4 sum = vec4(0.);\n    int iter = 0;\n    \n    for (int y = -size/2; y <= size/2; y += resdiv) {\n        for (int x = -size/2; x <= size/2; x += resdiv) {\n            sum += texture(iChannel0, uv + vec2(x, y)/iResolution.xy);\n            iter++; // figures out how many things get added\n        }\n    }\n    \n    return sum / vec4(iter);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = sampleAvg(int(50. * (sin(3. * iTime) + 1.)), 5, uv);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft23Rc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 396], [398, 398, 455, 505, 687]], "test": "untested"}
{"id": "sdS3zV", "name": "- change of basis -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["sdf", "sphere"], "likes": 3, "viewed": 232, "published": 3, "date": "1624387057", "time_retrieved": "2024-07-30T19:14:39.507237", "image_code": "#define EPS 0.001\n#define MAX_DIST 20.\n\nvec3 rotateY(vec3 pos, float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat3(c,  0, -s,\n                0,  1,  0,\n                s,  0,  c) * pos;\n}\n\nvec3 changeOfBasis(vec3 pos, vec3 origin){\n    vec3 zAxis = -origin;\n    vec3 xAxis = normalize(rotateY(vec3(origin.x, 0, origin.z), 3.14 / 2.));\n    vec3 yAxis = cross(xAxis, zAxis);\n\t\n    return transpose(mat3(xAxis, yAxis, zAxis)) * pos;\n}\n\nfloat sdBox(vec3 pos) {\n    vec3 d = abs(pos) - 0.8;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat sdSphere(vec3 pos) {\n\treturn length(pos) - 1.;   \n}\n\nvec3 calcBoxPos() {\n    float y = 1. - 4. * abs(round(iTime / 12.) - iTime / 12.);\n    vec3 origin = vec3(sin(iTime / 0.3), y, cos(iTime / 0.3));\n    origin.xz *= cos(y * 3.14 / 2.);\n    return origin;\n}\n\nfloat calcDist(vec3 pos) {\n    vec3 origin = calcBoxPos();\n \t\n    float dBox = sdBox(changeOfBasis(1.5 * (pos + 3. * -origin), origin)) / 2. - 0.05;\n    float dSphere = sdSphere(0.35 * pos);\n\n    float morphK = 4.;\n    return -log(exp(-morphK * dSphere) + exp(-morphK * dBox)) / morphK;\n}\n\nfloat rayMarch(vec3 rayO, vec3 rayD) {\n    float distFromO = 0.;\n    for (int i = 0; i < 100; ++i) {\n\t    float dS = calcDist(rayO + rayD * distFromO);\n        distFromO += dS;\n        if (dS < EPS || distFromO > MAX_DIST) break;\n    }\n    \n    return distFromO;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float d = calcDist(pos);\n\treturn normalize(vec3(d - calcDist(pos - vec3(EPS, 0,  0 )),\n\t\t\t\t\t  \t  d - calcDist(pos - vec3( 0, EPS, 0 )),\n\t\t\t\t\t   \t  d - calcDist(pos - vec3( 0,  0, EPS))));\n}\n\nvec3 calcLight(vec3 fragPos, vec3 lightPos, vec3 lightCol, vec3 camDir) {    \n\tvec3 normal = calcNormal(fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    vec3 ambient = vec3(0.1);\n    vec3 diffuse = vec3(max(dot(normal, lightDir), 0.0));\n    vec3 specular = vec3(0.15 * pow(max(dot(-camDir, reflect(-lightDir, normal)), 0.), 16.));\n    \n    return lightCol * (ambient + diffuse + specular);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    \n    vec3 camPos = vec3(0, 0, -10);\n\tvec3 camDir = normalize(vec3(xy, 1.));\n    \n    float dist = rayMarch(camPos, camDir);\n    \n    vec3 col = vec3(0.7, 0.6, 0.6);\n    \n    if (dist < MAX_DIST) { \n        col = calcLight(camPos + dist * camDir, \n                        vec3(5, 0, -15), \n                        vec3(0.9, 0.6, 0.6), \n                        camDir);\n    } \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 1.0 - uv.yx;\n    col *=  vec3(pow(uv.x * uv.y * 15., 0.1)); \n    \n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdS3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 73, 73, 207], [209, 209, 251, 251, 451], [453, 453, 476, 476, 572], [574, 574, 600, 600, 631], [633, 633, 652, 652, 836], [838, 838, 864, 864, 1126], [1128, 1128, 1166, 1166, 1392], [1394, 1394, 1421, 1421, 1615], [1617, 1617, 1690, 1690, 2029], [2031, 2031, 2086, 2086, 2709]], "test": "untested"}
{"id": "fl2GR3", "name": "Almost Quadcentric Coordinates", "author": "oneshade", "description": "Trying to find an alternative to inverse bilinear interpolation. This method doesn't quite work but the goal is to get unique weights that sum to 1 and also map correctly to the expected quad shape which inverse bilinear doesn't always do.", "tags": ["barycentric", "lerp", "interpolation", "quad"], "likes": 5, "viewed": 208, "published": 3, "date": "1624380861", "time_retrieved": "2024-07-30T19:14:40.347990", "image_code": "// Drawing utilities\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nvec4 weightsInQuad(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    vec2 pa = p - a, pb = p - b, pc = p - c, pd = p - d;\n    vec2 ba = b - a, cb = c - b, dc = d - c, da = d - a;\n    vec2 ca = c - a;\n\n    // Total quad area (sum of two triangles forming the quad)\n    float T = (abs(ba.x * ca.y - ba.y * ca.x) + abs(dc.x * ca.y - dc.y * ca.x)) * 0.5;\n\n    float A = abs(ba.x * pa.y - ba.y * pa.x) * 0.5; // Area of triangle ABP\n    float B = abs(cb.x * pb.y - cb.y * pb.x) * 0.5; // Area of triangle BCP\n    float C = abs(dc.x * pc.y - dc.y * pc.x) * 0.5; // Area of triangle CDP\n    float D = abs(da.x * pa.y - da.y * pa.x) * 0.5; // Area of triangle DAP\n\n    // Since there aren't unique triangles opposite each vertex\n    // I made the observation that the barycentric coordinate was\n    // also 1-(A+B)/T where A and B were triangles connected to the\n    // vertex so this might apply to a quad too. Summing this up for\n    // each vertex results in 2 instead of 1 though so I then scaled\n    // each of the weights by 1/2\n    float wa = (1.0 - (D + A) / T);\n    float wb = (1.0 - (A + B) / T);\n    //float wc = (1.0 - (B + C) / T);\n    //float wd = (1.0 - (C + D) / T);\n\n    return vec4(wa, wb, 1.0 - wa, 1.0 - wb) * 0.5; // Change suggested by @Yusef28\n}\n\nvec3 tex(in vec2 uv) {\n    return vec3(0.5 + 0.5 * mod(dot(floor(uv * 8.0), vec2(1.0)), 2.0), 0.0, 0.0);\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.5);\n\n    vec2 a = vec2(-1.0, 1.0) + vec2(cos(iTime), sin(iTime)) * 0.5;\n    vec2 b = vec2(-1.0, -1.0) + vec2(sin(3.0 * iTime), cos(3.0 * iTime)) * 0.2;\n    vec2 c = vec2(1.0, -1.0) + vec2(cos(2.0 * iTime), sin(2.0 * iTime)) * 0.5;\n    vec2 d = vec2(1.0, 1.0) + vec2(sin(iTime), cos(iTime)) * 0.2;\n\n    vec4 t = weightsInQuad(uv, a, b, c, d);\n    color = tex(vec2(0.0, 0.0) * t.x + vec2(0.0, 1.0) * t.y + vec2(1.0, 1.0) * t.z + vec2(1.0, 0.0) * t.w);\n\n    draw(sdLine(uv, a, b, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, b, c, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, c, d, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, d, a, 0.005), vec3(1.0, 0.8, 0.0));\n\n    draw(sdDisc(uv, a, 0.05), vec3(1.0));\n    draw(sdDisc(uv, b, 0.05), vec3(1.0));\n    draw(sdDisc(uv, c, 0.05), vec3(1.0));\n    draw(sdDisc(uv, d, 0.05), vec3(1.0));\n\n    fragColor += vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord);\n    render(fragColor, fragCoord + vec2(0.5, 0.0));\n    render(fragColor, fragCoord + vec2(0.5, 0.5));\n    render(fragColor, fragCoord + 0.5);\n    fragColor /= 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2GR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 97, 145, 145, 177], [179, 179, 238, 238, 350], [352, 352, 427, 427, 1623], [1625, 1625, 1647, 1647, 1731], [1733, 1733, 1787, 1787, 2803], [2805, 2805, 2860, 2860, 3087]], "test": "untested"}
{"id": "stSGRG", "name": "Geocentric", "author": "icylavah", "description": "Planet with sun and moon\nRendered: https://twitter.com/icylavah/status/1407367524967010304", "tags": ["planet"], "likes": 3, "viewed": 375, "published": 3, "date": "1624377513", "time_retrieved": "2024-07-30T19:14:41.154833", "image_code": "#define AA (8)\n\n#define PI (3.14159265359)\n#define TAU (PI * 2.0)\n\nfloat moonRadius = 0.1;\nfloat moonLitRadius = 0.11;\nvoid sampleMoon(vec2 pos, inout vec3 color) {\n    vec2 point = vec2(cos(fract(iTime / 16.0) * TAU), sin(fract(iTime / 16.0) * TAU)) * 0.8;\n    if(length(pos - point) < moonRadius) {\n        float offset = sqrt(moonLitRadius * moonLitRadius - moonRadius * moonRadius);\n        vec2 lit = point - vec2(cos(fract(iTime / 16.0) * TAU), sin(fract(iTime / 16.0) * TAU)) * offset;\n        if(length(pos - lit) < moonLitRadius) color = vec3(0.7, 0.9, 0.95);\n        else color = vec3(0.2, 0.5, 0.6);\n    }\n}\n\nfloat sunRadius = 0.15;\nvoid sampleSun(vec2 pos, inout vec3 color) {\n    vec2 point = vec2(cos(fract(iTime / 16.0 + 0.5) * TAU), sin(fract(iTime / 16.0 + 0.5) * TAU)) * 0.8;\n    if(length(pos - point) < sunRadius) {\n        color = vec3(0.9, 0.85, 0.6);\n    }\n}\n\nfloat planetRadius = 0.4;\nfloat planetLitRadius = 0.42;\nvoid samplePlanet(vec2 pos, inout vec3 color) {\n    vec2 point = vec2(0.0, 0.0);\n    if(length(pos - point) < planetRadius) {\n        float offset = sqrt(planetLitRadius * planetLitRadius - planetRadius * planetRadius);\n        vec2 lit = point - vec2(cos(fract(iTime / 16.0) * TAU), sin(fract(iTime / 16.0) * TAU)) * offset;\n        if(length(pos - lit) < planetLitRadius) color = vec3(0.3, 0.7, 0.45);\n        else color = vec3(0.10, 0.4, 0.35);\n    }\n}\n\nstruct Outline {\n    vec2 pos;\n    float r;\n    vec3 color;\n    float width;\n};\n\nvoid outline(vec2 pos, Outline ol, inout vec3 color) {\n    if(abs(length(pos - ol.pos) - ol.r) <= ol.width / 2.0) color = ol.color;\n}\n\nvec3 samplePoint(vec2 pos) {\n    vec3 color = vec3(0.015);\n    \n    if(length(pos) < 1.1) {\n        color = vec3(0.05, 0.08, 0.1);\n    }\n    outline(pos, Outline(vec2(0.0, 0.0), 1.2, vec3(0.05, 0.08, 0.1), 0.055), color);\n    outline(pos, Outline(vec2(0.0, 0.0), 1.3, vec3(0.05, 0.08, 0.1), 0.03), color);\n    outline(pos, Outline(vec2(0.0, 0.0), 1.37, vec3(0.05, 0.08, 0.1), 0.015), color);\n    samplePlanet(pos, color);\n    sampleMoon(pos, color);\n    sampleSun(pos, color);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center is 0, 0\n    vec2 pos = (fragCoord - iResolution.xy / 2.0) * 2.0 / iResolution.y * vec2(1, -1);\n    \n    // Supersampling\n    vec3 color = vec3(0.0);\n    for(int y = 0; y < AA; y++) {\n        for(int x = 0; x < AA; x++) {\n            vec2 subpos = pos + vec2(\n                float(x + 1) / float(AA + 1) * 2.0 - 1.0,\n                float(y + 1) / float(AA + 1) * 2.0 - 1.0\n            ) / iResolution.y;\n            color += samplePoint(subpos * 1.0);\n        }\n    }\n    \n    fragColor = vec4(color / float(AA * AA), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 164, 164, 618], [644, 644, 688, 688, 881], [939, 939, 986, 986, 1394], [1477, 1477, 1531, 1531, 1610], [1612, 1612, 1640, 1640, 2113], [2115, 2115, 2172, 2194, 2713]], "test": "untested"}
{"id": "7l23zK", "name": "Hydrogen - Orbits", "author": "weasel", "description": "Hydrogen orbits. Implicit surface shows surface with probability density = const. Meant to see the shapes, not quantitative. m=0 Shapes are cut open. Use mouse to select a shape from a grid with n growing from the bottom.", "tags": ["3d", "raymarching", "physics"], "likes": 18, "viewed": 380, "published": 3, "date": "1624368925", "time_retrieved": "2024-07-30T19:14:42.018523", "image_code": "#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(max(1.0-x*x, 1e-7), float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n// associated laguerre polynomial L_s^k(x) with k > 0, s >= 0\nfloat laguerre_poly(float x, int s, int k) {\n    if (s <= 0)\n        return 1.0;\n    float lp1 = 1.0;\n    float lp2 = 1.0 - x + float(k);\n    for (int n = 1; n < s; n++) {\n        float lp = ((float(2*n + k + 1) - x) * lp2 - float(n+k)*lp1)/float(n+1);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2;\n}\n\n// radius dependent term of the 1/r potential eigenstates in atomic units\nfloat radius_term(float r, int n, int l) {\n    float a0 = 1.0; // atomic radius\n    float rr = r / a0;\n    float n2 = 2.0 / float(n) / a0;\n    float n3 = n2 * n2 * n2;\n    float p1 = sqrt(n3 * fac2(n, l) * float(n-l)/float(n));\n    float p2 = exp(-rr/float(n));\n    float p3 = pow(n2*r, float(l));\n    float p4 = laguerre_poly(n2*r, n-l-1, 2*l+1);\n    return p1 * p2 * p3 * p4;\n}\n\nvec2 hydrogen(vec3 pos, int n, int l, int m) {\n    float r = length(pos);\n    float sin_theta = length(pos.xy);\n    float phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float theta = atan(sin_theta, pos.z);//atan(sin_theta, pos.z);\n    \n    return sphere_harm(theta, phi, l, m) * radius_term(r, n, l);\n}\n\n/*** Now the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\n#define SELECT_GRID 7.0\nvoid get_nlm(out int n, out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t;\n    \n    bool selection = false;\n    if (mouse.x + mouse.y > 0.0) {// && iMouse.z > 0.5) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        //t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        t = cell.x;\n        n = cell.y + 1;\n        selection = t < n*(n+1)/2 || iMouse.z > 0.5;\n    }\n    if (!selection) {\n        /*vec2 coord = fragCoord;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        cell.x += 0;\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);*/\n        t = int(iTime*0.5);\n        \n        if (t == 0)\n            n = 1;\n        else {\n            float x = float(t);\n            // see https://en.wikipedia.org/wiki/Tetrahedral_number\n            n = int(ceil(pow(3.*x+sqrt(9.*x*x-1./27.), 1./3.) + pow(3.*x-sqrt(9.*x*x-1./27.), 1./3.) - 0.995));\n        }\n        t -= ((n*(n-1)*(2*n-1))/6+(n*(n-1))/2)/2;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = t - int(floor(0.5*float(l + l*l)));\n}\n\nfloat spos(float x, float s) {\n    return 0.5*(x*x/(s+abs(x))+x+s);\n}\nfloat smax(float a, float b, float s) {\n    return a+spos(b-a,s);\n}\n\n#define SURFACE_LEVEL 0.3\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    int n, m, l;\n    get_nlm(n, l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    vec2 off = cexp(vec2(0, iTime));\n    \n    vec2 H = hydrogen(pos*float(n*n+1)*1.5, n, l, m);\n    if (m != 0) H = cmul(H, off);\n    \n    H *= float((l+1)*l+n*n)*sqrt(float(n)); // visual rescaling\n    \n    float crit2 = 0.3*(length(pos)+0.05);\n    \n    color = H.x > 0. ? vec3(1.0,0.6,0.15) : vec3(0.2,0.4,0.5);\n    //color = vec3(max(vec3(0.02),(sin(float(n) + vec3(0., 2.1, 4.2)))));\n    float d = (SURFACE_LEVEL - abs(H.x))*crit2;\n    if (m == 0)\n        return smax(d, 0.707*(pos.x+pos.y), 0.02);\n    return d;\n    \n    float arg = atan(H.x, H.y);\n    color = vec3(max(vec3(0.02),(sin(arg + vec3(0., 2.1, 4.2)))));\n    return (0.20 - length(H))*crit2;\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = color.rgb;\n\n    float occ = clamp(length(cp)*0.7, 0.2, 0.5);//min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = -pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/3.0;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l23zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 122, 140, 140, 236], [238, 258, 277, 277, 374], [376, 413, 439, 439, 649], [651, 674, 693, 693, 741], [743, 769, 796, 796, 861], [863, 886, 905, 905, 931], [933, 967, 987, 987, 1001], [1002, 1002, 1021, 1021, 1040], [1042, 1077, 1121, 1121, 1598], [1600, 1632, 1688, 1688, 1866], [2237, 2311, 2353, 2353, 2690], [2692, 2692, 2738, 2738, 3002], [3033, 3033, 3070, 3070, 3133], [3159, 3159, 3225, 3225, 4354], [4356, 4356, 4386, 4386, 4425], [4426, 4426, 4465, 4465, 4493], [4521, 4521, 4583, 4583, 5330], [5332, 5332, 5405, 5405, 5817], [5819, 5819, 5879, 5945, 6414], [6514, 6514, 6576, 6576, 7850], [7852, 7852, 7907, 7907, 9451]], "test": "untested"}
{"id": "NtBGz3", "name": "Galaxy waves", "author": "jarble", "description": "These galaxy-waves are mesmerizing.", "tags": ["fractal", "wave", "spiral", "galaxy"], "likes": 6, "viewed": 299, "published": 3, "date": "1624329210", "time_retrieved": "2024-07-30T19:14:43.056747", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.275;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    //uv.y += (iTime)/25.0;\n    float s1 = scale1*scale+uv.y+iTime/4.0;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= -fract(-uv-((vec2(uv.x/scale1-uv.y/scale1,uv.y/scale-uv.x/scale)/(scale))))/scale1;\n            uv.x *= -scale1;\n            uv = fract(uv.yx/s1)*s1;\n            uv.y /= scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 127, 127, 776]], "test": "untested"}
{"id": "NlSGz3", "name": "Noise Columns", "author": "Chidebe", "description": "It's my first noise shader.", "tags": ["noise"], "likes": 3, "viewed": 206, "published": 3, "date": "1624327475", "time_retrieved": "2024-07-30T19:14:43.997233", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 0.5f;\n\n    float NoiseVal = fract(sin(dot(fragCoord * 2.0f, vec2(12.2929, 78.293))) + 39389.0f);\n    \n    //vec3 col = vec3(NoiseVal);\n    // Output to screen\n    float G = 0.1f/clamp( sin( iTime * uv.x ), 0.001f, 1.0f );\n    \n    vec3 col = vec3(fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453) * sin(iTime  + uv.y),\n        fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453) * G,\n            fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453) * sin(sin(iTime) + .5f * NoiseVal * uv.x));\n    //col = vec3(  );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSGz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 711]], "test": "untested"}
{"id": "NlBGR3", "name": "Double-exponent 2D curve", "author": "heyx3", "description": "Use the mouse X and Y to change the two curve parameters.\n\nThis curve is based around a simple exponential curve, \"y=pow(x, a)\". I wanted to have a different exponent at each end, so I started playing with curves like \"y=pow(x, lerp(a, b, x))\".", "tags": ["curve", "interpolation"], "likes": 1, "viewed": 262, "published": 3, "date": "1624317444", "time_retrieved": "2024-07-30T19:14:44.857931", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mUV = iMouse.xy / iResolution.xy;\n    \n    //Pick the two exponents based on the mouse coordinates.\n    vec2 exponents = mix(vec2(0.11111), vec2(5.0),\n                         //Apply a curve so the small values are more spread out:\n                         pow(mUV, vec2(2.0)));\n    \n    //Calculate the curve.\n    float graphY = pow(uv.x, mix(exponents.x, exponents.y, uv.x));\n    \n    //Color the area under the curve black.\n    fragColor = vec4(vec3(step(graphY, uv.y)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 587]], "test": "untested"}
{"id": "NtBGR3", "name": "Pearl waves", "author": "jarble", "description": "These patterns remind me of ocean waves.", "tags": ["fractal", "wave", "spiral", "ocean"], "likes": 9, "viewed": 403, "published": 3, "date": "1624316694", "time_retrieved": "2024-07-30T19:14:45.653803", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.15;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = -(fragCoord.yx*10.0-iResolution.yx)/iResolution.y/15.0;\n    //uv.y += (iTime)/25.0;\n    float s1 = (iTime/4.-uv.x)/4.;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= -fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= -scale1;\n            uv = fract(-uv.yx)+fract(uv/(8.)+s1);\n            uv.y /= scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBGR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 783]], "test": "untested"}
{"id": "7ljGRV", "name": "Voronoi Experiments", "author": "muio", "description": "idk\nI followed @The_ArtOfCode 's tutorial on Voronoi.", "tags": ["2d", "voronoi"], "likes": 1, "viewed": 208, "published": 3, "date": "1624309551", "time_retrieved": "2024-07-30T19:14:46.403798", "image_code": "vec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 456.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float t = iTime * .3;\n    float minDist = 1.;\n    \n    uv *= 6.;\n    vec2 grid_uv = fract(uv) - .5;  // .5 <= uv <= .5 for each grid cell\n    vec2 grid_id = floor(uv);\n    vec2 cell_id;\n    \n    for (int i = -1; i <= 1; i += 1) {\n        for (int j = -1; j <= 1; j += 1) {\n            vec2 grid_offset = vec2(i, j);\n            \n            vec2 n = N22(grid_id + grid_offset);\n            vec2 position = grid_offset + sin(n * t) * .5;\n            \n            vec2 diff = grid_uv - position;\n            float l2_dist = length(diff);\n            float l1_dist = abs(diff.x) + abs(diff.y);\n            \n            // float dist = l1_dist;\n            // float dist = l2_dist;\n            float dist = clamp(-l1_dist * .7 + l2_dist * 1.5, 0., 1.);\n            if (dist < minDist) {\n                minDist = dist;\n                cell_id = grid_id + grid_offset; // id of closest point to current pixel\n            }\n        }\n    }\n    \n    vec3 col = clamp(vec3(minDist) * .3 + .5 * vec3(abs(cell_id.yxx)/5.), 0., 1.);\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 152], [154, 154, 211, 211, 1339]], "test": "untested"}
{"id": "sl23RV", "name": "iChannel texture - 003", "author": "catafest", "description": "In the last tutorial, I add a sphere distortion and sphere distortion with movement.\nToday I use iChannel2 to get input from the keyboard and use this input to move with an offset.\nThe source code is not perfect ...", "tags": ["texture", "sphere", "keyboard", "ichannel"], "likes": 1, "viewed": 477, "published": 3, "date": "1624308112", "time_retrieved": "2024-07-30T19:14:47.360241", "image_code": "#define PI 3.1415926\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float speed = 100.0;\n\n\nvec2 Keyboard(vec2 offset) {\n\n    float velocity = 0.1; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n \n    vec2 left = texelFetch(iChannel2, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel2, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel2, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel2, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    offset += (left + up + right + down) * velocity;\n\n    return offset;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // get poins \n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    // set surface formula\n    vec3 v = vec3(p.x, p.y, sqrt(1.0 - p.x * p.x - p.y * p.y));\n    // create normals \n    vec3 n = normalize(v);\n    \n    // https://en.wikipedia.org/wiki/Distortion_(optics)\n    vec2 sphere_distortion = vec2(atan(n.z, n.x) / PI,0.00000001 * p.y);\n    \n    // color is vec4 dimension\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    \n    //color = texture(iChannel3);\n    vec2 offset = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = Keyboard(offset);\n\n \n    \n    if (uv.x > 0.0 && uv.x < 0.5)\n    {\n   \t\t//color = texture(iChannel0, vec2(1.0 - (uv.x/0.5),uv.y/0.5)+ sphere_distortion);\n        // with movement iTime\n        color = texture(iChannel0, \n        vec2(\n        (iTime * 1.0 - (uv.x/0.5))  +  offset.x,\n        (uv.y/0.5)+offset.y\n        ) + sphere_distortion);\n    } \n    else if (uv.x > 0.5 && uv.x < 1.0) \n    { \n        //color = texture(iChannel1, vec2((uv.x/0.5),uv.y)+ sphere_distortion);\n        // with movement iTime\n        color = texture(iChannel0, \n        vec2(\n        (iTime -(uv.x/0.5))+ offset.x,\n        (uv.y)+offset.y\n        ) + sphere_distortion - 0.076);\n        \n    } \n\n    fragColor = vec4(color);\n    \n \n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl23RV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 184, 184, 683], [686, 686, 743, 743, 2144]], "test": "untested"}
{"id": "7ljGzK", "name": "photon powder paint", "author": "xenn", "description": "Hallucinatory shapes.\n\nCheck mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 34, "viewed": 572, "published": 3, "date": "1624300956", "time_retrieved": "2024-07-30T19:14:48.588956", "image_code": "// Fork of Jeyko, 2021-06-17 https://www.shadertoy.com/user/jeyko\n// \"maybe mention that this forked from my shader?\n// It just keeps the website sorted.\"\n\n// Jeyko has heaps of intrigueing and fascinating code vignettes, you should check them all out!\n// 2021-06-09 02:00:41\n\n// and it has been further forked with the following and possibly one each per buffer channel.\n// Though, each buffer also may change in the future too. So, No promises. No threats.\n\n// ahem \n// also created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(10.0*cos(iTime/3.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.478975+(0.1*cos(iTime/4.3))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec)+vec4(col);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// @christinacoffin\n// 2015-05-07: 1st version, need to optim and do some proper AA\n\nvec3 JuliaFractal(vec2 c, vec2 c2, float animparam, float anim2 ) {\t\n\tvec2 z = c;\n    \n\tfloat ci = 0.0;\n\tfloat mean = 0.0;\n    \n\tfor(int i = 0;i < 64; i++)\n    {\n\t\tvec2 a = vec2(z.x,abs(z.y));\n\t\t\n        float b = atan(a.y*(0.99+animparam*9.0), a.x+.110765432+animparam);\n\t\t\n        if(b > 0.0) b -= 6.303431307+(animparam*3.1513);\n\t\t\n        z = vec2(log(length(a*(0.98899-(animparam*2.70*anim2)))),b) + c2;\n\n        if (i>0) mean+=length(z/a*b);\n\n        mean+=a.x-(b*77.0/length(a*b));\n\n        mean = clamp(mean, 111.0, 99999.0);\n\t}\n    \n\tmean/=131.21;\n\tci =  1.0 - fract(log2(.5*log2(mean/(0.57891895-abs(animparam*141.0)))));\n\n\treturn vec3( .5+.5*cos(6.*ci+0.0),.5+.75*cos(6.*ci + 0.14),.5+.5*cos(6.*ci +0.7) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float animWings = 0.004 * cos(iTime*0.5);\n    float animFlap = 0.011 * sin(iTime*1.0);    \n    float timeVal = 56.48-20.1601;\n\tvec2 uv = fragCoord.xy - iResolution.xy*.5;\n\tuv /= iResolution.x*1.5113*abs(sin(timeVal));\n    uv.y -= animWings*5.0; \n\tvec2 tuv = uv*125.0;\n\tfloat rot=3.141592654*0.5;\n  \n\tuv.x = tuv.x*cos(rot)-tuv.y*sin(rot);\n\tuv.y =1.05* tuv.x*sin(rot)+tuv.y*cos(rot);\n\tfloat juliax = tan(timeVal) * 0.011 + 0.02/(fragCoord.y*0.19531*(1.0-animFlap));\n\tfloat juliay = cos(timeVal * 0.213) * (0.022+animFlap) + 5.66752-(juliax*1.5101);//+(fragCoord.y*0.0001);// or 5.7\n    \n \n    float tapU = (1.0/ float(iResolution.x))*25.5;//*cos(animFlap);\n    float tapV = (1.0/ float(iResolution.y))*25.5;//*cos(animFlap);\n    \n  \n\tfragColor = vec4( JuliaFractal(uv+vec2(0.0,0.0), vec2(juliax, juliay), animWings, animFlap ) ,1.0);\n    \n    fragColor += vec4( JuliaFractal(uv+vec2(tapU,tapV), vec2(juliax, juliay), animWings, animFlap ) ,1.0);\n//    fragColor += vec4( JuliaFractal(uv+vec2(tapU,-tapV), vec2(juliax, juliay), animWings, animFlap ) ,1.0);\n//    fragColor += vec4( JuliaFractal(uv+vec2(-tapU,tapV), vec2(juliax, juliay), animWings, animFlap ) ,1.0);\n    fragColor += vec4( JuliaFractal(uv+vec2(-tapU,-tapV), vec2(juliax, juliay), animWings, animFlap ) ,1.0);  \n    fragColor *= 0.3333;\n    \n    fragColor.xyz = fragColor.zyx;\n\tfragColor.xyz = vec3(1)-fragColor.xyz;\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .99;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .001;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .35;\nconst float iBlobEdgeSmoothing        = .04;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 40.;\nconst float iBlob1ColorPulseSpeed     = .28;\nconst float iBlob2Radius              = .54;\nconst float iBlob2PowFactor           = 40.;\nconst float iBlob2ColorPulseSpeed     = .047;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Fork of \"spirit aura\" by xenn. https://shadertoy.com/view/7lSGzR\n// 2021-06-09 02:00:41\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),400.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel1, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGzK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[610, 610, 633, 633, 681], [687, 687, 722, 722, 861], [863, 863, 920, 920, 2010]], "test": "untested"}
{"id": "ft23RK", "name": "tetrahedral truchet gears", "author": "flockaroo", "description": "...meanwhile inside an alien wrist-watch", "tags": ["gears", "truchet", "tetrahedron", "octahedron"], "likes": 39, "viewed": 1053, "published": 3, "date": "1624276972", "time_retrieved": "2024-07-30T19:14:49.576316", "image_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// tetrahedral truchet gears\n// ...actually its sheared cubes divided into 2 tetrahedrons and one octahedron\n\n// i've seen others use this \"tetrahedral\" symmetry before...\n// here 2 wonderful examples (most likely not a complete list):\n//   Shane - Simplex Truchet Tubing - https://www.shadertoy.com/view/XsffWj\n//   mattz - rainbow spaghetti      - https://www.shadertoy.com/view/lsjGRV\n\n// the freedom of symmetry is a bit more limited here when matching gears from cell to cell,\n// and i think one can find more complext tilted gear-configurations, but at some point my brain did hurt, so i left it at that ;-)\n\n#ifndef Res\n#define Res (iResolution.xy)\n#endif\n\n#define BLUR_SAMP 4\n\n// ...some blurring of borders\n\nvoid mainImageS( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv0=fragCoord/iResolution.xy;\n    #ifdef BORDER_LOD_SPEEDUP\n    vec2 uv1=uv0-.25;\n    vec2 uv2=uv0*.5+vec2(.5,0);\n    vec2 fact2=smoothstep(.24,.25,abs(uv0-.5));\n    fragColor=mix(texture(iChannel1,uv1),texture(iChannel1,uv2),max(fact2.x,fact2.y));\n    fragColor*=1.-2.*dot(uv0-.5,uv0-.5);\n    fragColor.w=1.;\n    #else\n    fragColor=texture(iChannel1,uv0);\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    int NumSamp=BLUR_SAMP;\n    vec2 delta=(fragCoord-.5*iResolution.xy)*.02;\n    for(int i=0;i<NumSamp;i++){\n        vec4 c;\n        float fi=float(i)/float(NumSamp-1)-.5;\n        if(NumSamp==1) fi=0.;\n        mainImageS(c,fragCoord+delta*fi*.75);\n        fragColor+=c*(1.+vec4(1,0,-1,0)*fi*3.);\n    }\n    fragColor/=float(NumSamp);\n    fragColor.w=1.;\n}\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// tetrahedral truchet gears\n\n// only center region will be rendered in full res + some border blur added (for better performance)\n#define BORDER_LOD_SPEEDUP\n\n// quaternion helpers\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define PIH 1.57079632679\n\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n#define Def_cross(a,b) vec3( (a).y*(b).z-(a).z*(b).y, (a).z*(b).x-(a).x*(b).z, (a).x*(b).y-(a).y*(b).x )\n#define Def_dot(a,b) ((a).x*(b).x+(a).y*(b).y+(a).z*(b).z)\n#define Def_multQuat(a,b) (vec4(Def_cross((a).xyz,(b).xyz) + (a).xyz*(b).w + (b).xyz*(a).w, (a).w*(b).w - Def_dot((a).xyz,(b).xyz)))\n#define Def_AxAng2Quat(ax,ang) (vec4(normalize(ax),1)*sin(vec2((ang)*.5)+vec2(0,PI2*.25)).xxxy)\n\n#define Q_X_45 vec4(0.38268343237,0,0,0.92387953251)\n#define Q_Y_45 vec4(0,0.38268343237,0,0.92387953251)\n#define Q_Z_45 vec4(0,0,0.38268343237,0.92387953251)\n#define Q_X_90 vec4(0.70710678119,0,0,0.70710678119)\n#define Q_Y_90 vec4(0,0.70710678119,0,0.70710678119)\n#define Q_Z_90 vec4(0,0,0.70710678119,0.70710678119)\n\n", "buffer_a_code": "// created by florian berger (flockaroo) - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// tetrahedral truchet gears\n\n// use this in windows - otherwise might not compile (angle doesnt like if's)\n#define AVOID_IFS\n#ifdef _WINDOWS_\n#define AVOID_IFS\n#endif\n\n#define GEAR_ANIM\n#define VIEWER_ANIM\n//#define CELL_COLORS\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#ifndef Res\n#define Res (iResolution.xy)\n#endif\n\nfloat CamDist = 1.;\nfloat CamShake = 1.;\n\n#define ViewerDist (CamDist)\n\n#define tanFOVh (1.6)\n\nvoid getCamQuatAndPos(out vec4 camQuat, out vec3 camPos)\n{\n    vec2 ang=vec2(iMouse.y/iResolution.y*12.8,iMouse.x/iResolution.x*12.8);\n    vec3 coffs=vec3(0);\n    vec4 r=sin(vec4(.7,1,1.3,1.7)*iTime*.5);\n    if(iMouse.x<.5) { \n        ang=vec2(-1.57+sin(iTime*.1-1.0)*-1.,-sin(iTime*.07-1.)*3.);\n        coffs=vec3(iTime*.2,0,0);\n    }\n    vec4 q=vec4(0,0,0,1);\n    // calc rotation quaternion for scene rotation\n    q=multQuat(q,axAng2Quat(vec3(1,0,0), ang.x));\n    q=multQuat(q,axAng2Quat(vec3(0,0,1), ang.y));\n    q=normalize(q+.01*r*CamShake);\n    camQuat = inverseQuat(q);\n    camPos = transformVecByQuat(vec3(0,0,ViewerDist+r.z*.025*CamShake),camQuat)+coffs;\n}\n\nvoid apply_trafo_r(inout vec3 pos, float transl)\n{\n    vec3 cp; vec4 cq;\n    getCamQuatAndPos(cq,cp);\n    pos=transformVecByQuat(pos,cq)+cp*transl;\n}\n\nvoid apply_trafo_r(inout vec3 pos) { apply_trafo_r(pos,1.0); }\n\nvoid apply_frustum_r(inout vec3 pos, inout vec3 dir, vec2 fragCoord)\n{\n    dir=normalize(vec3((fragCoord-.5*iResolution.xy)/iResolution.x*2.,-1./tanFOVh));\n    apply_trafo_r(dir,0.);\n}\n\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(vec3(p.xy-normalize(p.xy)*R,p.z))-r;\n}\n\n// iq's exponantial smooth-min funcs\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat smax(float a, float b, float k) { return -smin(-a,-b,k); }\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax_(float a, float b, float k) { return -smin_(-a,-b,k); }\n\nfloat tri(float x) { return 1.-4.*abs(fract(x*0.159154943092+.25)-.5); }\n\nfloat tooth(float x) {\n    //return clamp(sin(x)*1.1,-1.,1.);\n    return clamp(tri(x)*1.4,-1.,1.);\n}\n\n// iq's box-funcs\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat distGear(vec3 p, float R, int numTeeth)\n{\n    float w=.2*R;\n    float lp=length(p);\n    float lpxy=length(p.xy);\n    float d=10000.;\n    float ang=atan(p.y,p.x);\n    d=abs(p.z)-w*1.2/*+lpxy/R*w*.0*/;\n    vec3 p2=p;\n    float a=-.5*PI/float(numTeeth); // 1/4 of tooth angle\n    vec2 cs=cos(a-vec2(0,PI2*.25));\n    p2.xy=mat2(cs.x,cs.y,-cs.y,cs.x)*p.xy;\n    p2.xy=abs(p2.xy);\n    if(p2.x>p2.y) p2.xy=p2.yx;\n    \n    // --- spokes ---\n    // edge cut\n    //float d2=abs(p.z)-R*.05;\n    //d2=smax(d2,-sdRect(abs(p2.xy)-vec2(.55)*R,vec2(.25*R))+.22*R,.05*R);\n    //d2=smin(d2,.28*R+.2*abs(p.z)-abs(.45*R-lpxy),.05*R);\n    //d=max(d,d2);\n    // rect profile\n    d=max(d,.28*R+.2*abs(p.z)-abs(.45*R-lpxy));\n    d=smin(d,smax(abs(p2.x),abs(p2.z)*1.7,.006)-.09*R+.02*p2.y,.0035);\n    // rotated rect profile\n    //d=max(d,.28*R+.2*abs(p.z)-abs(.45*R-lpxy));\n    //d=smin(d,abs(p2.x)+abs(p2.z)-.07*R,.0035);\n    \n    // --- teeth\n    // ...by tooth func\n    //d=max(d,length(p+vec3(p.xy/lpxy,0)*.1*R*tooth(ang*float(numTeeth)))-R);\n    // ...by doing actual tooth (gives better distance field to avoid overstepping)\n    float dang=a*2.; // 1/2 of tooth angle  (alternatingly with pos/neg flank)\n    float tidx=floor((ang+.5*dang)/dang);\n    float flank=mod(tidx,2.)*2.-1.;\n    float ang0=(tidx)*dang; // center angle of tooth flank\n    vec2 cs0=cos(ang0-vec2(0,PI2*.25));\n    float Rfl=R*1.;\n    float d2=length(p.xyz-vec3((cs0*(R*sqrt(2.)-Rfl)+flank*cs0.yx*vec2(-1,1)*Rfl)*sqrt(.5),0.))-Rfl;\n    d2=min(d2,lp-R*.9);\n    d2=max(d2,lp-R*1.1);\n    d=max(d,d2);\n    return d;\n}\n\n// iq's line distance\nfloat distLine( vec3 p, vec3 a, vec3 b )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\n\nfloat SideLength = 1.;\n\n#ifndef GEAR_ANIM\nuniform float GearAng;\n#else\n#define GearAng (.25*PI2*sin(iTime*PI2/3.)*1.)\n#endif\n\n// put num gears into -ang/2..ang/2 (first and last gear only half)\nfloat distGearsAng(vec3 p, float R, float r, float ang, int num, float axang, float YOff, float soff)\n{\n    float GearR=SideLength*.09;\n    float ph0=atan(GearR/R);\n    float ph1=(ang-ph0-ph0)/float(num-2)/2.;\n    float pang=atan(p.y,p.x);\n    float ang2=-ang*.5;\n    float ang1=ang2;\n    int i;\n    for(i=min(iFrame,0);i<num;i++) {\n        if(pang>=ang2) {\n            ang1=ang2;\n            if      (i==num-2) ang2=ang*.5;\n            else if (i==0)     ang2+=ph0+ph1;\n            else               ang2+=ph1+ph1;\n        }\n        if(pang<ang2) {\n            break;\n        }\n    }\n    float s=float(i%2)*2.-1.;\n    float rg1=((i==0)    ?GearR:R*tan(ph1))*.95;\n    float rg2=((i==num-2)?GearR:R*tan(ph1))*.95;\n    float d=10000.;\n    vec3 pg;\n\n    float raild=GearR*.5;\n    \n    int numTeeth=12;\n    \n    int n1,n2;\n    float axang1,axang2;\n    float gearAng1,gearAng2;\n    gearAng1=gearAng2=GearAng;\n    axang1=axang2=axang;\n    vec4 axq=axAng2Quat(vec3(0,1,0),axang2);\n    n1=n2=numTeeth;\n    \n    float zo,gao;\n    pg=transformVecByQuat(p, axAng2Quat(vec3(0,0,1),-ang1));\n    zo=sin((ang1-ang*.5)/ang*PI2)*GearR*YOff;\n    pg.z+=zo*soff;\n    gao=(ang1+ang*.5)/ang*PI2*GearR*YOff*.5/rg1;\n    pg.x-=R;\n    pg=transformVecByQuat(pg,axq);\n    d=min(d,max(length(pg.xy)-.01*R,abs(pg.z)-raild));\n    pg=transformVecByQuat(pg,axAng2Quat(vec3(0,0,1),(gearAng1+gao)*s));\n    d=min(d,distGear(pg,rg1,n1));\n    \n    pg=transformVecByQuat(p, axAng2Quat(vec3(0,0,1),-ang2));\n    zo=sin((ang2-ang*.5)/ang*PI2)*GearR*YOff;\n    pg.z+=zo*soff;\n    gao=(ang2+ang*.5)/ang*PI2*GearR*YOff*.5/rg2;\n    pg.x-=R;\n    pg=transformVecByQuat(pg,axq);\n    d=min(d,max(length(pg.xy)-.01*R,abs(pg.z)-raild));\n    //d=min(d,distLine(pg,vec3(0,0,-raild),vec3(0,0,raild))-.01*R);\n    pg=transformVecByQuat(pg,axAng2Quat(vec3(0,0,1),(gearAng2+gao)*-s));\n    d=min(d,distGear(pg,rg2,n2));\n    \n    //vec2 rail=cos(axang-vec2(0,PI*.5))*raild;\n    //d=min(d,distTorus(p-vec3(0,0,1)*rail.x,R-rail.y,.01*R));\n    //d=min(d,distTorus(p+vec3(0,0,1)*rail.x,R+rail.y,.01*R));\n    //...is this faster than 2 the toruses above ?!\n    vec2 cs=cos(-axang-vec2(0,PI*.5));\n    vec2 p2=mat2(cs,cs.yx*vec2(-1,1))*vec2(length(p.xy)-R,p.z);\n    p2.y=abs(p2.y);\n    d=min(d,length(p2-vec2(0,raild))-.01*R);\n    return d;\n}\n\nfloat Thick;\n\nfloat AxAng;\n\n#define T1 1\n#define T2 2\n#define O1 3\n#define O2 4\n#define O3 5\n\nint mtl=0;\n\n\nfloat distOctCell(vec3 p, float axAng, int dtnum) \n{\n    float ZOff=0., soff=-1.;\n    float s=1.;\n    if (p.x-p.y<0.) s=-1.;\n    if(abs(p.y)>abs(p.x)) { \n        p.xy=p.yx*vec2(1,-1); \n        if(mtl==O2) { p.y*=-1.; soff*=-1.; }\n        if(mtl==O3) p.z*=-1.;\n        if(mtl==O1) p.z*=-1.;\n    }\n    if(p.x<0.) { \n        if(mtl==O2) { p.z*=1.; soff*=-1.; }\n        if(mtl==O3) p.z*=-1.;\n        if(mtl==O1) p.z*=-1.;\n    }\n    p.x=-abs(p.x);\n    float d=1000.;\n    float R=SideLength/2./sqrt(3.);\n    float r=Thick*SideLength;\n    float d2;\n    float x0=SideLength*.5;\n    \n    if(mtl==O2) { ZOff=.0792; }\n    \n    d2=distGearsAng((p-vec3(-x0,0,0)).xzy*vec3(1,-1,1),R,r,atan(sqrt(2.))*2.,5+dtnum,axAng*s,ZOff,soff);\n    d=min(d,d2);\n    return d;\n}\n\n\nfloat distTetrCell(vec3 p) \n{\n    if(p.x<.0) { p.yz=p.zy*vec2(1,-1); }\n    p.x=abs(p.x)*-1.;\n    float d=1000.;\n    float R=SideLength/2./sqrt(3.);\n    float r=Thick*SideLength;\n    float d2;\n    float x0=SideLength*(.5/sqrt(2.));\n    \n    d2=distGearsAng((p-vec3(-x0,0,0)).xyz,R,r,atan(sqrt(.5))*2.,3,PI*.5,0.,1.); d=min(d,d2);\n    return d;\n}\n\nfloat distLine(vec3 p, vec3 t)\n{\n    return length(p-dot(p,t)/dot(t,t)*t);\n}\n\n\nvec4 getRand(ivec3 v)\n{\n    return texelFetch(iChannel0,(v.xy+ivec2(7,17)*v.z)%256,0);\n}\n\nfloat PosCos=0.;\n\nconst vec4 qzp45=Q_Z_45;\nconst vec4 qxp45=Q_X_45;\nconst vec4 qxm45=-Q_X_45*vec4(1,1,1,-1);\nconst vec4 qyp90=Def_multQuat(Q_Z_45,Q_Y_90);\nconst vec4 qxp90=Def_multQuat(Q_Z_45,Q_X_90);\n\n#define sel2(x1, x2, f)    ( mix(x1,x2,step(1.,f)) )\n#define sel3(x1, x2, x3, f) ( sel2(sel2(x1,x2,f),x3,f-1.) )\n\nfloat distTruch(vec3 p)\n{\n    p += PosCos*SideLength * ( cos(p.zxy*1.7/SideLength+0.*iTime) - .1*sin(p.zxy*1.7/SideLength*10.+0.*iTime) );\n    mat3 m=mat3( 0,1,1, 1,0,1, 1,1,0 )*SideLength/sqrt(2.);\n    vec4 q;\n    vec3 v=inverse(m)*p;\n    vec3 v0=floor(v);\n    v-=v0;\n    vec3 pc=m*(v0+.5);\n    \n    float d=10000.;\n    float ro=sqrt(2.)/4.*SideLength;\n    float d2;\n    p-=pc;\n    vec4 r=getRand(ivec3(v0));\n    \n    #ifndef AVOID_IFS\n       // this is more overlookable, but...\n       // ...windows wont compile this (guess angle is not coping with the many if's)\n       \n       //lower tetrahedron\n       if      (v.x+v.y+v.z<1.) { q=qxm45; mtl=T1; d2=distTetrCell(transformVecByQuat(p+ro,q)); }\n       //upper tetrahedron\n       else if (v.x+v.y+v.z>2.) { q=qxp45; mtl=T2; d2=distTetrCell(transformVecByQuat(p-ro,q)); }\n       //center octahedron\n       else if (r.x>.66)        { q=qxp90; mtl=O1; d2=distOctCell (transformVecByQuat(p,q),PI/6.,0);  }\n       else if (r.x>.33)        { q=qyp90; mtl=O2; d2=distOctCell (transformVecByQuat(p,q),PI*.5,-1); }\n       else                     { q=qzp45; mtl=O3; d2=distOctCell (transformVecByQuat(p,q),PI/6.,0);  }\n       d=d2;\n       \n    #else\n       \n       float region=floor(v.x+v.y+v.z);  // 0->tetra1, 1->octahedron, 2->tetra2\n       \n       mtl=(r.x<.333)?O2:((r.x<.666)?O1:O3);\n       mtl=(region==0.)?T1:((region==2.)?T2:mtl);\n   \n       d=(region==1.)?\n            distOctCell (transformVecByQuat(p,sel3(qyp90,qxp90,qzp45,r.x*3.)),PI/sel2(2.,6.,r.x*3.),(r.x<.333)?-1:0):\n            distTetrCell(transformVecByQuat(p-ro*(region-1.),mix(qxm45,qxp45,region*.5)));\n       \n    #endif\n\n    //#define PRISM_CELLS\n    #ifdef PRISM_CELLS\n    vec3 p0;\n    p0=m*floor(v0+v+.5);\n    d=min(d,distLine(p-p0,m*vec3(1,0,0))-.003);\n    d=min(d,distLine(p-p0,m*vec3(0,1,0))-.003);\n    d=min(d,distLine(p-p0,m*vec3(0,0,1))-.003);\n    #endif\n    return d;\n}\n\nfloat dist(vec3 p)\n{\n    float d=distTruch(p);\n    return d;\n}\n\nvec3 getGradF(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nvec3 getGrad_(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps*.5,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-dist(p-d.xyy),dist(p+d.yxy)-dist(p-d.yxy),dist(p+d.yyx)-dist(p-d.yyx))/eps; \n}\n\n// suggestion from Shane - windows compile improvements\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getGrad(in vec3 p, float eps) {\n\t\n    vec2 e = vec2(eps*.5, 0);\n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = dist(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\nvoid march(inout vec3 pos, vec3 dir)\n{\n    float eps=.0001;\n    float dsum=0.;\n    for(int i=min(0,iFrame);i<120;i++)\n    {\n        float d=dist(pos)*.66;\n        pos+=dir*d;\n        dsum+=d;\n        if (d<eps*dsum*5. || dsum>10.0) break;\n        if(i>1000) break; // Fake break. (not sure if necessary)\n    }\n}\n\n#ifndef RandTex \n#define RandTex iChannel0\n#endif\n\nvec4 myenv(vec3 pos, vec3 dir, float period)\n{\n    vec4 r=vec4(0);\n    float sc=.2*period;\n    int num=8;\n    for(int i=min(0,iFrame);i<num;i++) { r+=texture(RandTex,dir.xy/dir.z*sc+iTime*.003*step(0.,dir.z)); sc*=.5; }\n    r/=float(num);\n    vec3 col=mix(vec3(.6,.7,.8)+.6*r.y,r.zwx*vec3(.5,.3,0),1.-smoothstep(-.3,.3,dir.z));\n    return vec4(col,1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef BORDER_LOD_SPEEDUP\n    if(fragCoord.y>Res.y*.5) { discard; return; }\n    vec2 uv2=fragCoord/Res*2.-vec2(1,0);\n    if(max(abs(uv2-.5).x,abs(uv2-.5).y)<.24) { discard; return; }\n    fragCoord=(fragCoord.x<Res.x*.5)?fragCoord+.25*Res:(fragCoord-vec2(.5*Res.x,0))*2.;\n    #endif\n    \n    vec3 light=normalize(vec3(0,0,1));\n    vec3 pos,dir;\n    pos=vec3(0);\n    apply_trafo_r(pos);\n    apply_frustum_r(pos,dir,fragCoord);\n    \n    vec3 pos0=pos;\n    \n    march(pos,dir);\n    \n    vec3 pos1=pos;\n    \n    vec3 n=normalize(getGrad(pos,.001));\n    //vec3 c0=vec3(1,.85,.77)+.0;\n    vec3 c0=vec3(1);\n    //vec3 c0=vec3(1,.86,.8);\n    \n    #ifdef CELL_COLORS\n       // tetrahedra configurations red, orange\n       if (mtl==T1) c0=vec3(1,.5,0)*.4+.6;\n       if (mtl==T2) c0=vec3(1,0,0)*.4+.6;\n       // octahedra configurations green, blue, magenta\n       if (mtl==O1) c0=vec3(.5,1,.5)*.4+.6;\n       if (mtl==O2) c0=vec3(.5,.5,1)*.4+.6;\n       if (mtl==O3) c0=vec3(1,0,1)*.4+.6;\n    #endif\n    \n    vec4 r=texelFetch(iChannel0,ivec2(fragCoord)%256,0);\n    \n    #if 1\n    float ao=1.;\n    //ao*=clamp(dist(pos+n/ 10.)* 10.,0.,1.);\n    //ao*=clamp(dist(pos+n/ 20.)* 20.,0.,1.);\n    float sc=SideLength*.003;\n    vec3 na=normalize(n)+.12*(r.xyz-.5);\n    float f=.7;\n    /*ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n    ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);*/\n    // suggestion from Shane - windows compile improvements\n    // Looping the unrolled AO statements. \n    for(int i=min(0, iFrame);i<8;i++){\n       ao*=clamp(dist(pos+na*sc)/sc,0.,1.)*(1.-f)+f; sc*=2.; f=pow(f,.9);\n       if(ao>1e8) break; // Fake break.\n    }\n    ao=ao*.7+.3;\n    #else\n    float ao=1.;\n    float sc=SideLength*.3,scmin=SideLength*.01;\n    vec3 na=normalize(getGrad(pos,scmin*.2))+.12*(r.xyz-.5);\n    float df=dist(pos+na*scmin*.2)/(scmin*.2);\n    for(int i=min(0,iFrame);i<30;i++)\n    {\n        //na=normalize(getGrad(pos,sc*.2));\n        //df=dist(pos+n*sc*.01)/(sc*.01);\n        float ao2=clamp(dist(pos+na*sc)/(sc/df),0.,1.);\n        ao*=mix(ao2,1.,\n        //1.-sqrt(sc)*.2\n        .85\n        );\n        sc*=.7;\n        if(sc<scmin) break;\n    }\n    #endif\n    \n    vec3 lightCol=vec3(.97,1.03,1);\n    \n    fragColor.xyz=c0;\n    fragColor.xyz*=(n*.03+.97);\n    fragColor.xyz*=(clamp(dot(n,light),0.,1.)*.4+.6);\n    fragColor.xyz*=ao;\n    vec3 R=reflect(normalize(pos1-pos0),n);\n    fragColor.xyz=fragColor.xyz*.85+.3*clamp(dot(R,light),0.,1.)*lightCol*c0;\n    //fragColor.xyz=fragColor.xyz*.7+.3*myenv(vec3 (0), R, .1).xyz;\n    vec3 dp=pos-pos0;\n    vec3 dpn=normalize(dp);\n    fragColor.xyz=mix(fragColor.xyz,mix(vec3(-.0,.05,.0),lightCol,clamp(dot(dp,light)/5.+.1,0.,1.))+dpn*.03,1.-exp(-length(pos-pos0)/5.));\n    fragColor.xyz*=fragColor.xyz+.2;\n    \n    fragColor.w=length(dp);\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft23RK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[853, 853, 911, 911, 1291], [1293, 1293, 1350, 1350, 1728]], "test": "untested"}
{"id": "Nlj3RK", "name": "line block", "author": "HanShaoqiu", "description": "post processing", "tags": ["glitchart"], "likes": 9, "viewed": 499, "published": 3, "date": "1624272177", "time_retrieved": "2024-07-30T19:14:50.698316", "image_code": "float randomNoise(vec2 c)\n{\n\treturn fract(sin(dot(c.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat trunc(float x, float num_levels)\n{\n\treturn floor(x * num_levels) / num_levels;\n}\n\nvec2 trunc(vec2 x, vec2 num_levels)\n{\n\treturn floor(x * num_levels) / num_levels;\n}\n\nvec3 rgb2yuv(vec3 rgb)\n{\n\tvec3 yuv;\n\tyuv.x = dot(rgb, vec3(0.299, 0.587, 0.114));\n\tyuv.y = dot(rgb, vec3(-0.14713, -0.28886, 0.436));\n\tyuv.z = dot(rgb, vec3(0.615, -0.51499, -0.10001));\n\treturn yuv;\n}\n\nvec3 yuv2rgb(vec3 yuv)\n{\n\tvec3 rgb;\n\trgb.r = yuv.x + yuv.z * 1.13983;\n\trgb.g = yuv.x + dot(vec2(-0.39465, -0.58060), yuv.yz);\n\trgb.b = yuv.x + yuv.y * 2.03211;\n\treturn rgb;\n}\n\n#define _Frequency 1.0\n#define _TimeX 1.0\n#define _Amount 0.45\n#define _Offset 2.35\n#define _LinesWidth 1.0\n#define _Alpha 1.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n\t\tfloat TimeX = _TimeX*iTime*0.5;\n\t\tfloat strength = 0.0;\n\t\t//strength = 10.0;\n\t\tstrength = 0.5 + 0.5 * cos(TimeX * _Frequency);\n\t\t\n\t\tTimeX *= strength; \n\t\t\n\t\t//\t[1] 生成随机强度梯度线条\n\t\tfloat truncTime = trunc(TimeX, 4.0);\n\t\tfloat uv_trunc = randomNoise(trunc(uv.yy, vec2(8, 8)) + 100.0 * truncTime);\n\t\tfloat uv_randomTrunc = 6.0 * trunc(TimeX, 24.0 * uv_trunc);\n\t\t\n\t\t// [2] 生成随机非均匀宽度线条\n\t\tfloat blockLine_random = 0.5 * randomNoise(trunc(uv.yy + uv_randomTrunc, vec2(8.0 * _LinesWidth, 8.0 * _LinesWidth)));\n\t\tblockLine_random += 0.5 * randomNoise(trunc(uv.yy + uv_randomTrunc, vec2(7, 7)));\n\t\tblockLine_random = blockLine_random * 2.0 - 1.0;\n\t\tblockLine_random = sign(blockLine_random) * clamp((abs(blockLine_random) - _Amount) / (0.4),0.0,1.0);\n\t\tblockLine_random = mix(0.0, blockLine_random, _Offset);\n\t\t\n\t\t\n\t\t// [3] 生成源色调的blockLine Glitch\n\t\tvec2 uv_blockLine = uv;\n\t\tuv_blockLine = clamp(uv_blockLine + vec2(0.1 * blockLine_random, 0.0),0.0,1.0);\n\t\tvec4 blockLineColor = texture(iChannel0, abs(uv_blockLine));\n\t\t\n\t\t// [4] 将RGB转到YUV空间，并做色调偏移\n\t\t// RGB -> YUV\n\t\tvec3 blockLineColor_yuv = rgb2yuv(blockLineColor.rgb);\n\t\t// adjust Chrominance | 色度\n\t\tblockLineColor_yuv.y /= 1.0 - 3.0 * abs(blockLine_random) * clamp(0.5 - blockLine_random,0.0,1.0);\n\t\t// adjust Chroma | 浓度\n\t\tblockLineColor_yuv.z += 0.125 * blockLine_random * clamp(blockLine_random - 0.5,0.0,1.0);\n\t\tvec3 blockLineColor_rgb = yuv2rgb(blockLineColor_yuv);\n\t\n\t\n\t// [5] 与源场景图进行混合\n\tvec4 sceneColor = texture(iChannel0, uv);\n    // Output to screen\n    fragColor = mix(sceneColor, vec4(blockLineColor_rgb, blockLineColor.a), _Alpha);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlj3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 96], [98, 98, 138, 138, 184], [186, 186, 223, 223, 269], [271, 271, 295, 295, 471], [473, 473, 497, 497, 647], [776, 776, 833, 883, 2619]], "test": "untested"}
{"id": "flj3RK", "name": "rgb split v2", "author": "HanShaoqiu", "description": "v2", "tags": ["split"], "likes": 2, "viewed": 316, "published": 3, "date": "1624271272", "time_retrieved": "2024-07-30T19:14:51.446316", "image_code": "// noise function\nfloat randomNoise(float x, float y)\n{\n    return fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat _Indensity = 0.01;\nfloat _Amplitude = 1.5;\nfloat _Amount = 0.3;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float splitAmout = (1.0 + sin(iTime * 6.0)) * 0.5;\n    splitAmout *= 1.0 + sin(iTime * 16.0) * 0.5;\n    splitAmout *= 1.0 + sin(iTime * 19.0) * 0.5;\n    splitAmout *= 1.0 + sin(iTime * 27.0) * 0.5;\n    splitAmout = pow(splitAmout, _Amplitude);\n    splitAmout *= (0.05 * _Amount);\n\n    vec3 finalColor;\n    finalColor.r = texture(iChannel0, vec2(uv.x + splitAmout, uv.y)).r;\n    finalColor.g = texture(iChannel0, uv).g;\n    finalColor.b = texture(iChannel0, vec2(uv.x - splitAmout, uv.y)).b;\n\n    finalColor *= (1.0 - splitAmout * 0.5);\n    \n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flj3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 55, 55, 133], [205, 205, 262, 312, 962]], "test": "untested"}
{"id": "Ntj3RK", "name": "rgb split - Glitch Art", "author": "HanShaoqiu", "description": "postprocessing", "tags": ["glitchart"], "likes": 5, "viewed": 679, "published": 3, "date": "1624270784", "time_retrieved": "2024-07-30T19:14:52.285074", "image_code": "// noise function\nfloat randomNoise(float x, float y)\n{\n    return fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat _Indensity = 0.01; \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float splitAmount = _Indensity * randomNoise(iTime, 2.0);\n    // rgb split\n    vec4 ColorR = texture(iChannel0, vec2(uv.x + splitAmount, uv.y));\n    vec4 ColorG = texture(iChannel0, uv);\n    vec4 ColorB = texture(iChannel0, vec2(uv.x - splitAmount, uv.y));\n    \n    // Output to screen\n    fragColor = vec4(ColorR.r, ColorG.g, ColorB.b,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntj3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 55, 55, 133], [161, 161, 218, 268, 661]], "test": "untested"}
{"id": "slS3zV", "name": "Inside Out, Outside In", "author": "lumic", "description": "Turning a gear inside out and then outside in.\nThe SDF is not correct, but it looks cool ;)", "tags": ["2d", "sdf", "complex", "inversion", "gear"], "likes": 3, "viewed": 231, "published": 3, "date": "1624265140", "time_retrieved": "2024-07-30T19:14:53.071969", "image_code": "#define RINNER 0.62\n#define ROUTER 0.65\n#define REPITITION 32.0\n\nconst float PI = 3.14159265359;\nconst float TWOPI = 6.28318530718;\n\nvec2 complexPow(vec2 z, float n) {\n    float r = length(z);\n    float angle = atan(z.y, z.x);\n    return pow(r, n) * vec2(cos(n * angle), sin(n * angle));\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdModulatedCircle(vec2 p, float radius)\n{\n    float repeat = REPITITION;\n\n    // Circle is centered at origin, convert to polar coordinates\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    \n    float bump = smoothstep(0.25, 1.25, cos(angle * repeat + iTime) + 1.0) * 0.125;\n\n    return r - (radius + bump);\n}\n\nfloat sdSubtract(float d1, float d2 ) {\n    return max(-d1,d2);\n}\n\nfloat sdCombine( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nfloat gear(vec2 p) {\n\tfloat d1 = sdCircle(p, RINNER);\n\tfloat d2 = sdModulatedCircle(p, ROUTER);\n    \n    return sdSubtract(d1, d2);\n}\n\nfloat ring(vec2 p) {\n\tfloat d1 = sdCircle(p, RINNER - 0.1);\n    return abs(d1) - 0.15;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized/centered pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float zoom  = 4.0;\n    vec2 p = uv * zoom;\n\n    // Animate complex inversion\n    float t = iTime * 0.25;\n    float inv1 = -(clamp(mod(t, 2.0), 0.0, 1.0) - 0.5) * 2.0;\n    float inv2 = -(clamp(mod(t, 2.0) - 1.0, 0.0, 1.0) - 0.5)  * 2.0;\n    float rotation = (1.0 - step(mod(t, 2.0), 1.0)) * PI;\n    \n    p = rotate2d(rotation) * p;\n    p = complexPow(complexPow(p, inv1), inv2);\n\n    float d = gear(p);\n    d = sdCombine(d, ring(p));\n    \n    // SDF Coloring based on https://www.shadertoy.com/view/3ltSW2\n    \n    float sgn = sign(d);\n    \n    //col = col - sgn * vec3(0.1,0.4,0.7);\n    //col *= 1.0 - exp(-20.0 * abs(d));\n\t//col *= 0.8 + 0.2 * smoothstep(0.0, 2.0, cos(50.0*d) + 1.0);\n\t//col = mix( col, vec3(1.0), 1.0-smoothstep(0.008,0.02,abs(d)) );\n    \n    if (sgn > 0.0) {\n        col *= 1. - smoothstep(d, 0.85, 1.0);\n    }\n    \n    col += smoothstep(d, 0.55, 1.0);\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slS3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 167, 167, 289], [291, 291, 318, 318, 400], [402, 402, 435, 435, 463], [465, 465, 512, 512, 793], [795, 795, 834, 834, 860], [862, 862, 901, 901, 926], [928, 928, 948, 948, 1061], [1063, 1063, 1083, 1083, 1151], [1153, 1153, 1210, 1269, 2335]], "test": "untested"}
{"id": "sdBSWc", "name": "Smoothstep Integral", "author": "iq", "description": "The integral of smoothstep is a useful way to smoothly ramping up a stationary object into constant motion. More info: [url]https://iquilezles.org/articles/smoothstepintegral[/url]", "tags": ["2d", "smoothstep", "integral", "butterfly"], "likes": 108, "viewed": 2982, "published": 3, "date": "1624252804", "time_retrieved": "2024-07-30T19:14:53.925687", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// The left butterfly implements a naive and wrong way to\n// transition a stationary object into constant motion. The\n// butterfly to the right implements the integral of the\n// smoothstep() function in order to smoohtly transition\n// between the two states.\n//\n// More information here:\n//\n// https://iquilezles.org/articles/smoothstepintegral\n\n\n\n// Incorrect EaseInOut/Smoothstep velocity\nfloat position_bad( float t, in float T )\n{\n    return smoothstep(0.0,T,t)*t;\n    //return (t<T) ? (t*t*t)/(T*T*T)*(3.0*T-2.0*t) : t;\n}\n\n// Correct integral of EaseInOut/Smoothstep\nfloat position_good( float t, in float T )\n{\n    if( t>=T ) return t - 0.5*T;\n    float f = t/T;\n    return f*f*f*(T-t*0.5);\n}\n\n\n// =======================================\n\nvec3 trackMin( in vec3 v, in float d )\n{\n         if( d<v.x ) v=vec3(d,v.x,v.y); \n    else if( d<v.y ) v=vec3(v.x,d,v.y);\n    else if( d<v.z ) v=vec3(v.x,v.y,d);\n    return v;\n}\n\nvec4 butterfly( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    p.y *= 0.9;\n    vec4 col = vec4(0.0);\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    \n    if( p.y<0.0 )\n    {\n        float f = 0.6 + 0.01*sin( 24.0*a );\n        float w = 1.1*a-0.8;\n        f *= sin(w)*sin(w);\n\n        float th = f + 0.001;\n        float th2 = th;\n        \n        vec3 wcol = mix( vec3(210,119,40)/255.0, \n                         vec3(232,79,12)/255.0, smoothstep( 0.0, 0.7, r ) );\n        wcol *= 1.5;\n\n        wcol *= 1.0+0.1*sin(17.0*p.x+vec3(0,0,4))*sin(23.0*p.y+vec3(0,0,4));\n\n        vec2 q = p;\n        q.xy += 0.02*sin(q.yx*12.0);\n        q.y = min(q.y,0.0);\n        vec3 v = vec3(10);\n        v = trackMin(v,length(q-vec2(0.29,-0.20)));\n        v = trackMin(v,length(q-vec2(0.10,-0.30)));\n        v = trackMin(v,length(q-vec2(0.20,-0.26)));\n        v = trackMin(v,length(q-vec2(0.28,-0.29)));\n        v = trackMin(v,length(q-vec2(0.34,-0.27)));\n        v = trackMin(v,length(q-vec2(0.38,-0.24)));\n        v = trackMin(v,length(q-vec2(0.39,-0.20)));\n        v = trackMin(v,length(q-vec2(0.38,-0.15)));\n        v = trackMin(v,length(q-vec2(0.35,-0.08)));\n\n        v.yz -= v.x;\n        float g = 1.25*v.y*v.z/max(v.y+v.z,0.001);\n        wcol *= smoothstep(0.0,0.01,g);\n        th -= 0.05*(1.0-smoothstep(0.0,0.05,g))-0.02;\n\n        wcol *= smoothstep(0.02,0.03,(th-r)*th);\n\n        q = vec2( mod(a,0.1)-0.05, (r-th+0.025)*3.1415*0.5 );\n        float d = length( q )-0.015;\n        wcol = mix( wcol, vec3(1,1,1), 1.0-smoothstep( 0.0, 0.005,d) );\n        \n        wcol *= smoothstep(0.01,0.03,length(p-vec2(0.235,-0.2)));\n        \n        d = r-(th+th2)*0.5;\n        col = vec4(wcol,smoothstep( 0.0,2.0*fwidth(d),-d) );\n    }\n    \n    if( a<2.2 )\n    {\n        float f = 0.65 + 0.015*sin( 24.0*a );\n        float w = a*(3.1416/2.356);\n        float th = f*sin(w)*sin(w) + 0.001;\n        float th2 = th;\n        th += 0.25*exp2( -50.0*(w-1.4)*(w-1.4) );\n            \n        vec3 wcol = mix( vec3(0.7,0.5,0.2), \n                         vec3(0.8,0.2,0.0), smoothstep( 0.0, 1.0, r ) );\n        wcol *= 1.4;\n        wcol *= 1.0+0.1*sin(13.0*p.x+vec3(0,0,4))*sin(19.0*p.y+vec3(0,0,4));\n\n        vec3 v = vec3(10);\n        v = trackMin(v,length(p-vec2(0.25,0.2)));\n        v = trackMin(v,length(p-vec2(0.35,0.0)));\n        v = trackMin(v,length(p-vec2(0.4,0.1)));\n        v = trackMin(v,length(p-vec2(0.45,0.2)));\n        v = trackMin(v,length(p-vec2(0.45,0.3)));\n\n        v.yz -= v.x;\n        float g = 2.0*v.y*v.z/max(v.y+v.z,0.001);\n        wcol *= smoothstep(0.0,0.02,g);\n        th2 -= 0.05*(1.0-smoothstep(0.0,0.05,g));\n\n        float isblack = smoothstep(0.02,0.03,(th2-r)*th2);\n\n        vec2 q = vec2( mod(a,0.1)-0.05, (r-th+0.025)*3.1415*0.5 );\n        float d = length( q )-0.015;\n        float ww = 1.0-smoothstep( 0.0, 0.01,d);\n        \n        if( r>th2 )\n        {\n        vec2 q = fract(p*18.0)-0.5;\n        vec2 iq = floor(p*18.0);\n        float id= iq.x*111.0+iq.y*13.0;\n        q += 0.25*sin(id*vec2(15,17)+vec2(0,2));\n        float r = 1.0+0.75*sin(id*431.0);\n        ww = max( ww, 1.0-smoothstep(0.0,0.01,length(q)-0.2*r));\n        }\n        \n        wcol = mix( wcol, vec3(ww), 1.0-isblack );\n        \n        d = r-th;\n        \n        float al = smoothstep( 0.0,2.0*fwidth(d),-d);\n        col.xyz = mix( col.xyz, wcol, al );\n        col.w = 1.0 - (1.0-col.w)*(1.0-al);\n    }\n    \n    return col;\n}\n\nint hash( ivec2 z )\n{\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    return (n*(n*n*15731+789221)+1376312589)>>16;\n}\n\n#if HW_PERFORMANCE==0\nconst int AA = 2;\n#else\nconst int AA = 4;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stime = mod( iTime, 6.0 );\n    \n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        \n        p *= 1.6;\n        //p.y += 0.5;\n\n        float di = float( hash(ivec2(fragCoord)*AA+ivec2(i,j))&255 )/255.0;\n        float time = stime + ((float(j*AA+i)+di)/float(AA*AA))*(0.5/30.0) - 0.5*0.5/30.0;\n        \n        time += 0.07*sin( p.y );\n        \n        float wing = (p.x<0.0)?position_bad(time, 2.0):\n                               position_good(time, 2.0);\n        \n        if( p.x>0.0 ) p.x=p.x-1.4;\n        else          p.x=p.x+1.4;\n\n       \n        float an = 1.55*(0.5-0.5*cos(2.0*6.283185*wing));\n        vec2  pl = vec2(sign(p.x)*sin(an),-cos(an));\n\n        vec3 ro = vec3(0.0,0.085,2.1);\n        vec3 rd = vec3(p,-3.0);\n        vec3 pos = ro - rd*dot(ro.xz,pl)/dot(rd.xz,pl);\n        vec2 q = vec2( length(pos.xz), pos.y );\n\n        vec4 tmp = butterfly( q );\n        tmp = clamp(tmp,0.0,1.0);\n        tmp.xyz *= 0.1+0.9*mix(1.0,abs(q.y)*0.5+min(q.x*2.0,1.0),pl.x*pl.x);\n        tmp.xyz *= clamp(0.25+0.75*(pl.x-pl.y+1.0),0.0,1.0);\n        \n        \n        col += mix( vec3(0.5), tmp.xyz, tmp.w );\n    }\n    col /= float(AA*AA);\n\n    vec2 q = fragCoord/iResolution.xy;\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSWc.jpg", "access": "api", "license": "mit", "functions": [[1428, 1471, 1514, 1514, 1606], [1608, 1652, 1696, 1696, 1778], [1825, 1825, 1865, 1865, 2002], [2004, 2004, 2033, 2033, 5410], [5412, 5412, 5433, 5433, 5531]], "test": "untested"}
{"id": "stBGRV", "name": "Bismuth crystals 2", "author": "jarble", "description": "These patterns reminds me of bismuth crystals.", "tags": ["fractal", "spiral", "bismuth"], "likes": 9, "viewed": 317, "published": 3, "date": "1624249406", "time_retrieved": "2024-07-30T19:14:54.782396", "image_code": "#define ITERS 12\nconst float scale = 2.;\nconst float scale1 = 1.15;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    //uv.y += (iTime)/25.0;\n    float s1 = scale1*scale+uv.y+iTime/4.0;\n    for(int c=0;c<ITERS;c++){\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv= -fract(-uv-((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            uv.x *= -scale1;\n            uv = fract(uv.yx/s1)*s1;\n            uv.y /= scale1;\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 126, 126, 775]], "test": "untested"}
{"id": "7tBGzK", "name": "Cubic Equation Solver II", "author": "oneshade", "description": "Inspired by @TinyTexel's super cool and easy to understand construction for solving a cubic partially using an inverse smoothstep (a highly specialized cubic inverse).\n[url=https://www.shadertoy.com/view/3sBcDh]https://www.shadertoy.com/view/3sBcDh[/url]", "tags": ["math", "solver", "cubic", "equation", "inversesmoothstep"], "likes": 10, "viewed": 154, "published": 3, "date": "1624242454", "time_retrieved": "2024-07-30T19:14:55.544359", "image_code": "/*\nThis turned out pretty clean, simple, and understandable! Also it never evaluates\nmore than four typically expensive functions (e.g. trig, square roots, etc.)\nwhich is one up on my other cubic solvers.\n\nI also added handling for when p=0 which simply blows up the whole thing but I'm not\nchecking for degenerate cubic equations (please don't solve linear equations\nwith this, ok? ;))\n*/\n\n// Special cube root to fix GLSL's negative pow() bug\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float u = b / (3.0 * a);\n\n    // Depress to x^3 + px + q by substituting x-b/3a\n    // This can be found by substituting x+u and solving for u so that the x^2\n    // term gets eliminated (then of course dividing by the leading coefficient)\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n\n    // Everything blows up when p=0 so give this case special treatment\n    if (abs(p) < 1e-9) { roots.x = cbrt(-q) - u; return 1; }\n\n    // In the case of one root, this construction does not work\n    float h = 0.25 * q * q + p * p * p / 27.0;\n    if (h > 0.0) { // Check depressed cubic discriminant\n        h = sqrt(h);\n        float o = -0.5 * q;\n        roots.x = cbrt(o - h) + cbrt(o + h) - u; // Cardano's formula (see https://en.wikipedia.org/wiki/Cubic_equation)\n        return 1;\n    }\n\n    // Solve by mapping an inverse smoothstep between the critical points\n    // I found a whole lot simplified right out so now it probably looks rather obfuscated\n    float m = sqrt(-p / 3.0);\n    roots.x = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    // Factor out the root to solve for the rest as a quadratic\n    h = sqrt(-3.0 * roots.x * roots.x - 4.0 * p);\n    roots.yz = 0.5 * vec2(h - roots.x, -h - roots.x);\n    roots -= u; // Undo the change in variable\n\n    return 3;\n}\n\n/* Without comments (for size comparison, giant solvers are no fun to tote around)\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float u = b / (3.0 * a);\n\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n\n    if (abs(p) < 1e-9) { roots.x = cbrt(-q) - u; return 1; }\n    float h = 0.25 * q * q + p * p * p / 27.0;\n    if (h > 0.0) {\n        h = sqrt(h);\n        float o = -0.5 * q;\n        roots.x = cbrt(o - h) + cbrt(o + h) - u;\n        return 1;\n    }\n\n    float m = sqrt(-p / 3.0);\n    roots.x = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    h = sqrt(-3.0 * roots.x * roots.x - 4.0 * p);\n    roots.yz = 0.5 * vec2(h - roots.x, -h - roots.x);\n    roots -= u;\n\n    return 3;\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Animated coefficients\n    float a = sin(iTime) * 2.0;\n    float b = sin(iTime) * 5.0;\n    float c = cos(iTime * 0.75);\n    float d = sin(iTime * 0.5);\n\n    float f = a * uv.x * uv.x * uv.x + b * uv.x * uv.x + c * uv.x + d;\n    float g = 3.0 * a * uv.x * uv.x + 2.0 * b * uv.x + c; // Derivative for distance estimate\n    float cubic = abs(uv.y - f) / sqrt(1.0 + g * g); // Distance estimate\n\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(uv.y))); // X axis\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, cubic)); // Cubic function\n\n    // Solve for the roots of the derivative (a quadratic)\n    // to get the extrema\n    float da = 3.0 * a;\n    float db = 2.0 * b;\n    float dc = c;\n\n    float discr = db * db - 4.0 * da * dc;\n    vec2 ex1 = vec2(0.0), ex2 = vec2(0.0);\n    if (discr > 0.0) {\n        discr = sqrt(discr);\n        da *= 2.0;\n\n        // Extrema 1\n        ex1 = vec2((-db + discr) / da, 0.0);\n        ex1.y = ((a * ex1.x + b) * ex1.x + c) * ex1.x + d;\n\n        // Extrema 2\n        ex2 = vec2((-db - discr) / da, 0.0);\n        ex2.y = ((a * ex2.x + b) * ex2.x + c) * ex2.x + d;\n\n        // Draw the segment between the extrema where the inverse smoothstep\n        // gets fitted\n        if (min(ex1.x, ex2.x) < uv.x && uv.x < max(ex1.x, ex2.x)) {\n            color = mix(color, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, cubic - 0.025));\n        }\n\n        // Draw the extrema\n        color = mix(color, vec3(1.0, 0.0, 1.0), smoothstep(unit, 0.0, length(uv - ex1) - 0.05));\n        color = mix(color, vec3(1.0, 0.0, 1.0), smoothstep(unit, 0.0, length(uv - ex2) - 0.05));\n    }\n\n    // Draw roots\n    vec3 roots;\n    int nroots = solveCubic(a, b, c, d, roots);\n    for (int n=0; n < nroots; n++) {\n        vec3 rootColor = vec3(1.0);\n        if (n == 0 && sign(ex1.y) != sign(ex2.y)) rootColor.rb = vec2(0.0); // Draw inverse smoothstepped root in green\n        color = mix(color, rootColor, smoothstep(unit, 0.0, length(uv - vec2(roots[n], 0.0)) - 0.05));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 445, 469, 469, 512], [513, 513, 593, 593, 1914], [2752, 2752, 2807, 2807, 5010]], "test": "untested"}
{"id": "flB3zV", "name": "3D Distance Function Visualizer", "author": "01000001", "description": "A handy tool\n\nReplace the return value at line 194 with your own distance function to see it visualized\n\nThis is my first attempt at 3D in shadertoy, so the camera is distorted since I used polar coordinates rather than figuring out how to do it properly.", "tags": ["raymarching", "tool"], "likes": 6, "viewed": 213, "published": 3, "date": "1624233457", "time_retrieved": "2024-07-30T19:14:56.295351", "image_code": "//Input Variables\nconst float pi = 3.14159;\nfloat minDistance = 0.0001;\nfloat cameraFarPlane = 200.0;\nvec3 cameraCoords = vec3(0, 0, -15.0);\nconst float maxSteps = 255.0;\nfloat fieldOfView = 45.0;\nfloat mouseSensitivity = 1.0;\n\nconst float glow = 1.0;\nconst float light = 0.7;\nvec3 glowColor = vec3(0.0, 0.6, 1.0);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n#define SHOW_MANDELBULB false\n\nstruct vec5 {\n    vec4 a;\n    float v;   \n};\n\nvec3 debugCol( float v )\n{\n    return vec3(v, v, v);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat mengerSpongeDF(int n, vec3 pos) { //by recursively digging a box\n\tfloat x=pos.x, y=pos.y, z=pos.z;\n\tx=x*0.5+0.5;y=y*0.5+0.5;z=z*0.5+0.5; //center it by changing position and scale\n\n\tfloat xx=abs(x-0.5)-0.5, yy=abs(y-0.5)-0.5, zz=abs(z-0.5)-0.5;\n\tfloat d1=max(xx,max(yy,zz)); //distance to the box\n\tfloat d=d1; //current computed distance\n\tfloat p=1.0;\n\tfor (int i=1; i<=n; ++i) {\n\t\tfloat xa = mod(3.0*x*p,3.0);\n\t\tfloat ya = mod(3.0*y*p,3.0);\n\t\tfloat za = mod(3.0*z*p,3.0);\n\t\tp*=3.0;\n\n\t\t//we can also translate/rotate (xa,ya,za) without affecting the DE estimate\n\n\t\tfloat xx=0.5-abs(xa-1.5), yy=0.5-abs(ya-1.5), zz=0.5-abs(za-1.5);\n\t\td1=min(max(xx,zz),min(max(xx,yy),max(yy,zz))) / p; //distance inside the 3 axis-aligned square tubes\n\n\t\td=max(d,d1); //intersection\n\t}\n\t//return d*2.0; //the distance estimate. The *2 is because of the scaling we did at the beginning of the function\n\treturn d;\n}\n\nfloat boxDF( vec3 p, vec3 b, vec3 s, vec3 o )\n{\n  vec3 q = s + abs(p - o) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat boxFrameDF( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sphereDF(vec3 spherePos, float radius, vec3 point)\n{\n    return length(point - spherePos) - radius;\n}\n\nfloat torusDF( vec3 p, vec2 t, vec3 o )\n{\n  p -= o;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat octahedronDF( vec3 p, float s, vec3 o )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d2, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float size = 2.5;\n    return boxFrameDF( q , vec3(size, size, size), 0.025);\n}\n\nfloat sdf_blend(float d1, float d2, float a)\n{\n    return a * d1 + (1.0 - a) * d2;\n}\n\nmat3x3 rotationAlign( const vec3 d, const vec3 z )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0f/(1.0f+c);\n\n    return mat3x3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<4; i++ )\n    {\n#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m*m;\n        float m4 = m2*m2;\n\t\tdz = 8.0*sqrt(m4*m2*m)*dz + 1.0;\n\n        float x = w.x; float x2 = x*x; float x4 = x2*x2;\n        float y = w.y; float y2 = y*y; float y4 = y2*y2;\n        float z = w.z; float z2 = z*z; float z4 = z2*z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;\n        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;\n        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;\n#else\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      \n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n#endif        \n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nfloat yourDistanceFunctionHere( vec3 p )\n{\n    mat3x3 matrix = rotationAlign(vec3(0, 1, 0), normalize(vec3(sin(iTime), cos(iTime), cos(iTime))));\n    float minDist = cameraFarPlane;\n    minDist = min(minDist, mengerSpongeDF(5, (p*0.5 - vec3(0, 1, -4))*matrix));\n    /*float t = 0.3;\n    minDist = min(minDist, \n    \n        (1.0-t)*(boxDF((p-vec3(0, 3, -4))*matrix, vec3(2), vec3(0), vec3(0, 0, 0))-2.0)\n        + (length(p-vec3(0, 3, -4))-5.0)*t\n    \n    );*/\n\n    if (SHOW_MANDELBULB)\n    {\n        vec4 o;\n        p*=0.2;\n        minDist = min(minDist,  map((p-vec3(-2, 0.5, -5))*matrix, o));\n    }\n    \n    return minDist;\n    //sphereDF(vec3(sin(iTime*0.2)*10.0, 2, 0.0+cos(iTime*0.2)*10.0), (sin(iTime)+1.0)*2.5, p);\n}\n\nvec2 DF(vec3 point)\n{\n    float minDist = cameraFarPlane;\n    \n    float distance1 = yourDistanceFunctionHere(point);\n    minDist = min(minDist, distance1);\n    minDist = min(minDist, point.y +  3.0);\n    \n    \n    \n    //final  = smin(partial, distance3, 3.0);\n\n    \n    return vec2(minDist, distance1);\n}\n\n//*\nfloat evaluateLight( vec3 origin)\n{\n    return (1.0+cos(DF(origin).y-pi/2.0))/2.0;\n    //return sin(DF(origin).y);\n\n}//*/\n\n\nvec5 depth( vec3 origin, vec3 direction )\n{\n    float depth = 0.0;\n    float light = 0.0;\n    float iterations = 0.0;\n    vec2 closestPoint = vec2(cameraFarPlane, 0);\n    \n    \n    vec3 b = direction/length(direction);//b = normalized direction\n    vec3 p = origin; //point or direction vector times depth\n    \n    float d = cameraFarPlane; //Distance\n    \n    float didCollide = 1.0;\n    \n    for(float i=0.;i<maxSteps;i++)\n    {\n        p = origin + (b*depth);\n        d = DF(p).x;\n        \n        iterations++;\n        \n        if (d < closestPoint.x) closestPoint.x = d;\n        \n        if (d < minDistance || depth > cameraFarPlane)\n        {\n            if ((d > minDistance))\n            {\n                didCollide = 0.0;\n            }\n            \n            break;\n        }\n        \n        depth += d;\n\n    }\n    \n    if (depth < cameraFarPlane)\n    {\n        light = evaluateLight(p);\n    }\n    \n    \n    depth /= cameraFarPlane;\n    \n    \n    return vec5(vec4(depth, light, iterations/maxSteps, closestPoint.x), didCollide);\n}\n\nvec2 circle( vec2 centrePos, float radius, float deg)\n{\n  float x = centrePos.x + radius * cos(deg * pi / 180.0);\n  float y = centrePos.y + radius * sin(deg * pi / 180.0);\n  return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.z>0.?(iMouse.xy/iResolution.xy) * 2.0 - 1.0:vec2(0);\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= mouseSensitivity*fieldOfView;    \n    \n\n    vec2 dirY = circle(vec2(0, 0), 1.0, mouse.y + uv.y *fieldOfView);\n    vec2 dirXY = circle(vec2(0, 0), dirY.x, mouse.x*5.0 + uv.x*fieldOfView);\n    vec3 dirV = vec3(dirXY.y, dirY.y, dirXY.x);//Polar Coordinate Spherical Projection \n    //I know this introduces distortion but I came up with this technique right when I was getting into shaders\n    //so I'm rather fond of it and decided to keep it :)\n\n    \n    vec4 pixelInfo =depth(cameraCoords, dirV).a;\n    \n    vec3 lightCol = /*debugCol(0.0);*/lightColor * pixelInfo.y * light;\n    vec3 glowCol = glowColor * pixelInfo.z * glow;\n    vec3 col = lightCol + glowCol;\n\n    \n    fragColor = vec4(col.xyz, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3zV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 432, 458, 458, 486], [488, 488, 529, 529, 615], [617, 617, 656, 687, 1518], [1520, 1520, 1567, 1567, 1662], [1664, 1664, 1709, 1709, 1991], [1993, 1993, 2051, 2051, 2100], [2102, 2102, 2143, 2143, 2218], [2220, 2220, 2267, 2267, 2547], [2549, 2549, 2586, 2586, 2607], [2609, 2609, 2652, 2652, 2674], [2676, 2676, 2720, 2720, 2741], [2743, 2743, 2795, 2795, 2894], [2896, 2896, 2954, 2954, 3054], [3056, 3056, 3115, 3115, 3214], [3216, 3216, 3252, 3252, 3370], [3372, 3372, 3418, 3418, 3456], [3458, 3458, 3510, 3510, 3826], [3828, 3874, 3917, 3917, 5391], [5393, 5393, 5435, 5435, 6117], [6119, 6119, 6140, 6140, 6425], [6427, 6431, 6466, 6466, 6548], [6555, 6555, 6598, 6598, 7599], [7601, 7601, 7656, 7656, 7795], [7797, 7797, 7854, 7904, 8844]], "test": "untested"}
{"id": "stjGzy", "name": "average vs relaxation ", "author": "FabriceNeyret2", "description": "red: average of the x last random values. ( requires storing full historic )\ngreen:  relaxation with innovation coef 1000^-(x/R.x) ( stores only 1 value )\n\nshow also max values.", "tags": ["hash", "rand", "relaxation", "statistics"], "likes": 7, "viewed": 290, "published": 3, "date": "1624222568", "time_retrieved": "2024-07-30T19:14:57.052327", "image_code": "// variant of https://shadertoy.com/view/NtS3zy\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.r = float( T(vec2(U.x, 8))*R.y > U.y ); // display curve in row  8\n    O.g = .7*float( T(vec2(U.x,16))*R.y > U.y ); // display curve in row 16\n    O.b = 0.;\n    \n    if ( abs(U.y-T(vec2(U.x,24))*R.y) <1. ) O.r += .5;  // display max\n    if ( abs(U.y-T(vec2(U.x,32))*R.y)< 1. ) O.g += .5;\n\nif ( int(U.y) == int(R.y)/2 ) O.r+O.g > 1. ? O-- : O++; // y=0 axis\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define hash(p)  fract(sin( (p)* 78.233 ) * 43758.5453 )\n\nfloat M(float l) { // average of stored random values #0..#int(l)\n    float s = 0.;\n    for( float i=0.; i < l; i++ )\n        s += T(vec2(i,0));\n    return s/ceil(l);\n}\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.x =   U.x == .5   ? hash(iTime)       // row 0: history of random values\n          : U.y ==   .5 ? T(U-vec2(1,0))    //     compute first, then scroll\n          : U.y ==  8.5 ? M(U.x)            // row 8: average values #0..x\n       // : U.y == 16.5 ? mix(T(U-vec2(1,0)),T(U),.5 )  // row 16: relaxation with previous value\n          : U.y == 16.5 ? mix(T(U),T(0), pow(1000.,-(U/R).x ) ) \n       // : U.y == 16.5 ? mix(T(U),T(0), 1.-(U/R).x )   \n       // : U.y == 16.5 ? mix(T(U),T(0), exp(-U.x/57. ) )\n          : U.y == 24.5 ? max(T(U),T(vec2(U.x, 8)) )\n          : U.y == 32.5 ? max(T(U),T(vec2(U.x,16)) )      \n          : 0.;                            //     NB: step 8 for better parallelism\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0).x\n#define R    iResolution.xy", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 452]], "test": "untested"}
{"id": "flB3zK", "name": "LookingGlass: Danger Noodle", "author": "xjorma", "description": "Original shader form BigWings\nShader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["raymarching", "tutorial", "glass", "snake", "animal", "looking", "jungle", "bigwings", "lookingglass", "viper"], "likes": 1, "viewed": 474, "published": 3, "date": "1624216719", "time_retrieved": "2024-07-30T19:14:58.102519", "image_code": "// \"Danger Noodle\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// Ever since I did a snake scale effect as one of my first ShaderToys\n// I have been wanting to do a snake, so here it is.\n//\n// Watch full screen with sound!\n\n#define MAX_STEPS 200\n#define MAX_DIST 60.\n#define SURF_DIST .01\n\n#define CAM_MOVE 0.\n\n#define S smoothstep\n\n#define MAT_TONGUE 1.\n#define MAT_HEAD 2.\n#define MAT_BODY 3.\n#define MAT_EYE 4.\n\n// From Dave Hoskins\nvec2 Hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.1031, 324.1030));\n    p += dot(p, p+33.33);\n    return fract(p.x*p.y);\n}\n\nfloat sabs(float x,float k) {\n    float a = (.5/k)*x*x+k*.5;\n    float b = abs(x);\n    return b<k ? a : b;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec4 s) {\n\tfloat t = dot(s.xyz-ro, rd);\n    vec3 p = ro + rd * t;\n    \n    float y = length(s.xyz-p);\n    \n    vec2 o = vec2(MAX_DIST,MAX_DIST);\n    \n    if(y<s.w) {\n    \tfloat x = sqrt(s.w*s.w-y*y);\n        o.x = t-x;\n        o.y = t+x;\n    }\n    \n    return o;\n}\n\n// From IQ\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n\treturn smin(a, b, -k);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdSph(vec3 p, vec3 pos, vec3 squash, float r) {\n    squash = 1./squash;\n\tp = (p-pos)*squash;\n    return (length(p)-r)/max(squash.x, max(squash.y, squash.z));\n}\n\n\nvec4 Scales(vec2 uv, float overlap, float skew, float point, float blur) {\n    \n    vec2 gv = fract(uv*5.)-.5;\n    vec2 id = floor(uv*5.);\n    \n    float m = 0.;\n    \n    gv.y = sabs(gv.y,point);\n    \n    float w = .5+overlap;\n    vec2 p1 = (gv+vec2(overlap,-gv.x*skew))*vec2(1,1.8);\n    float a1 = atan(p1.x-w, p1.y);\n    \n    float waveAmp = .02;\n    float waves = 10.;\n    float w1 = sin(a1*waves);\n    float s1 = S(w, w*blur, length(p1)+w1*waveAmp);\n    s1 +=  w1*.1*s1;\n    s1 *= mix(1., .5-gv.x, overlap*2.);\n    \n    gv.x -= 1.;\n    vec2 p2 = (gv+vec2(overlap,-gv.x*skew))*vec2(1,1.8);\n    float a2 = atan(p2.x-w, p2.y);\n    float w2 = sin(a2*waves);\n    float s2 = S(w, w*blur, length(p2)+w2*waveAmp);\n    s2 += w2*.1*s2;\n    \n    s2 *= mix(1., .5-gv.x, overlap*2.);\n    \n    if(s1>s2) {\n    \tm += s1;\n        m -= dot(p1,p1);\n    } else {\n        m += s2;\n        m -= dot(p2,p2);\n        id.x += 1.;\n    }\n\n    return vec4(1.-m, 0., id);\n}\n\nvec4 ScaleTex(vec2 uv, float overlap, float skew, float point, float blur) {\n\n    uv *= 2.;\n    vec4 s1 = Scales(uv, overlap, skew, point, blur);\n    vec4 s2 = Scales(uv+.1, overlap, skew, point, blur);\n    s2.zw -= .5;\n    \n    return s1.x<s2.x ? s1 : s2;\n}\n\n\nvec3 sdBody(vec3 p) {\n    float t = iTime*.3;\n    float neckFade = S(3., 10., p.z);\n   \n    p.x += sin(p.z*.15-t)*neckFade*4.;\n    p.y += sin(p.z*.1-t)*neckFade;\n    \n    vec2 st = vec2(atan(p.x, p.y), p.z);\n    \n    float body = length(p.xy)-(.86+S(2., 15., p.z)*.6-p.z*.01);\n    body = max(.8-p.z, body);   \n    \n    vec4 scales = vec4(0);\n    if(body<.1) {\n        vec2 uv = vec2(-st.y*.25, st.x/6.2832+.5);\n        float a = sin(st.x+1.57)*.5+.5;\n        float fade = a;\n        a = S(.1, .4, a);\n\n        uv.y = 1.-abs(uv.y*2.-1.);\n        uv.y *= (uv.y-.2)*.4;\n        scales = ScaleTex(uv*1.3, .3*a, .3*a, .01, .8);\n        body += scales.x*.02*(fade+.2);\n    }\n    \n    body += S(-.4, -.9, p.y)*.2;\t// flatten bottom\n    return vec3(body, scales.zw);\n}\n\nfloat GetHeadScales(vec3 p, vec3 eye, vec3 mouth, float md) {    \n    float t = iTime;\n  \n    float jitter = .5;\n    jitter *= S(.1, .3, abs(md));\n    jitter *= S(1.2, .5, p.z);\n    \n    p.z += .5;\n    p.z *= .5;\n    \n    p.yz *= Rot(.6);\n    float y = atan(p.y, p.x);\n    vec2 gv = vec2(p.z*5., y*3.);\n\n    vec2 id = floor(gv);\n    \n    gv = fract(gv)-.5;\n    \n    float d=MAX_DIST;\n    for(float y=-1.; y<=1.; y++) {\n        for(float x=-1.; x<=1.; x++) {\n            vec2 offs = vec2(x, y);\n\n            vec2 n = Hash22(id+offs);\n            vec2 p = offs+sin(n*6.2831)*jitter;\n            p -= gv;\n            \n            float cd = dot(p,p);\n            if(cd<d) d = cd;\n        }\n    }\n    \n    d += sin(d*20.)*.02;    \n    d *= S(.0, .5, length(p.xy)-.1);\n    return d*.06;\n}\n\nfloat sdHead(vec3 p) {    \n    p.x = abs(p.x*.9);\n    float d = sdSph(p, vec3(0,-.05,.154), vec3(1,1,1.986),1.14); \n    d = smax(d, length(p-vec3(0,7.89,.38))-8.7, .2);\n    d = smax(d, length(p-vec3(0,-7.71,1.37))-8.7, .15); // top\n    \n    d = smax(d, 8.85-length(p-vec3(9.16,-1.0,-3.51)), .2);\t// cheeks\n    \n    vec3 ep = p-vec3(.54,.265,-.82);\n    float eye = length(ep)-.35;\n    float brows = S(.1, .8, p.y-(p.z+.9)*.5);\n    brows *= brows*brows;\n    brows *= S(.3, -.2, eye);\n   \td -= brows*.5;\n    d += S(.1, -.2, eye)*.1;\n    \n    vec2 mp = p.yz-vec2(3.76+S(-.71, -.14, p.z)*(p.z+.5)*.2, -.71); \n    float mouth = length(mp)-4.24;\n    d += S(.03,.0,abs(mouth))*S(.59,.0, p.z)*.03;\n    \n   \td += GetHeadScales(p, ep, mp.xyy, mouth);\n    \n    d = min(d, eye);\n    \n    float nostril = length(p.zy-vec2(-1.9-p.x*p.x, .15))-.05;\n    d = smax(d, -nostril,.05);\n    return d;\n}\n\nfloat sdTongue(vec3 p) {\n\tfloat t = iTime*3.;\n   \n    float inOut = S(.7, .8, sin(t*.5));\n    \n    if(p.z>-2.||inOut==0.) return MAX_DIST;\t\t// early out\n    \n    float zigzag = (abs(fract(t*2.)-.5)-.25)*4.; // flicker\n    float tl = 2.5;\t// length\n    \n    p+=vec3(0,0.27,2);\n    p.z *= -1.;\n    float z = p.z;\n    p.yz *= Rot(z*.4*zigzag);\n    p.z -= inOut*tl;\n    \n    float width = S(0., -1., p.z);\n    float fork = 1.-width;\n    \n    float r = mix(.05, .02, fork);\n\t\n    p.x = sabs(p.x, .05*width*width);\n    p.x -= r+.01;\n    p.x -= fork*.2*inOut;\n\n    return length(p-vec3(0,0,clamp(p.z, -tl, 0.)))-r;\n}\n\nfloat GetDist(vec3 P) {\n    \n    vec3 p = P;\n    p.xz *= Rot(sin(iTime*.3)*.1*S(1., 0., p.z));\n    float d = sdTongue(p)*.7;\n    d = min(d, sdHead(p));\n    d = smin(d, sdBody(P).x, .13);\n    \n    return d;\n}\n\nvec3 GetMat(vec3 p) {    \n    float d = MAX_DIST;\n    \n    float tongue = sdTongue(p)*.7;\n    float head = sdHead(p);\n    vec3 body = sdBody(p);\n    \n    float closest = min(tongue, min(head, body.x));\n    if(closest == tongue) {\n        return vec3(MAT_TONGUE, 0, 0);\n    } else if(closest==head) {\n        p.x = abs(p.x*.9);\n        vec3 ep = p-vec3(.54,.265,-.82);\n        float eye = length(ep)-.35;\n        if(eye<SURF_DIST)\n        \treturn vec3(MAT_EYE, ep.yz);\n        else\n            return vec3(MAT_BODY, 0, 0);\n            \n    }else if(closest==body.x) {\n        return vec3(MAT_BODY, body.yz);\n    }\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n// From Nimitz\nvec4 GetNormalAndCurvature(in vec3 p, float eps) {\n    vec2 e = vec2(-1., 1.)*eps;   \n    float t1 = GetDist(p + e.yxx), t2 = GetDist(p + e.xxy);\n    float t3 = GetDist(p + e.xyx), t4 = GetDist(p + e.yyy);\n\n    float c = .25/e.y*(t1 + t2 + t3 + t4 - 4.0*GetDist(p));\n    vec3 n = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    \n    return vec4(n, c);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvec4 Material(vec3 ro, vec3 rd, float d) {\n    vec3 p = ro + rd * d;\n    vec4 n = GetNormalAndCurvature(p, mix(.01, .03, S(8., 20., d)));\n\n    p.xz *= Rot(sin(iTime*.3)*.1*S(1., 0., p.z));\n    vec3 mat = GetMat(p);\n    \n    vec3 col = vec3(n.y*.5+.5);  \t// diffuse\n\tcol *= 1.-max(0., .3-n.w);\t\t// curvature shadow\n    \n    vec3 h = normalize(-rd + vec3(1,1,1));\n    float spe = pow(clamp(dot(h, n.xyz), 0.0, 1.0), 32.0);\n\t\n    vec3 ref = reflect(rd, n.xyz);\n    vec3 r = texture(iChannel0, ref).rgb;\n    \n    if(mat.x==MAT_EYE) {\n        vec2 sph = RaySphere(\n            vec3(abs(p.x*.9),p.yz), \n            vec3(-abs(rd.x), rd.yz), \n            vec4(.3,.265,-.82, .52)\n        );\n\n        vec3 sp = p+rd*sph.x;\n        mat.yz = sp.yz-vec2(.265,-.82)+.05;\n\n        float t = iTime*.2;\n        vec2 p1 = sin(floor(t)*vec2(20., 31.));\n        vec2 p2 = sin(floor(t+1.)*vec2(20., 31.));\n        p1 = mix(p1, p2, S(.45, .5, fract(t)));\n        mat.yz += p1*vec2(.01, .03)*1.;\n        float a = atan(mat.y, mat.z);\n\n        float d = abs(mat.z)+mat.y*mat.y;\n        col *= vec3(1,1,.1);\n        col += S(.1, .0, length(mat.yz*vec2(1,2))-.1)*.1;\n        \n        float z = S(.7, 1., rd.z*rd.z)*.05;\n        col *= S(.02-z, .03+z, d);\n        \n        vec3 gp = vec3(a, mat.yz)*20.;\n        float gyroid = (abs(dot(sin(gp), cos(gp.zxy))));\n        col *= 1.+gyroid*.1;\n        \n        col += r*r*r*.3;\n        col += pow(spe, 6.);\n    } else if(mat.x==MAT_BODY) {\n        float x = mat.y;\n        float y = mat.z;\n        float wave = S(2., 0., abs(y-2.+sin(x*.5)*1.));\n        wave *= S(2., 3., p.z);\n        \n        float t = iTime*.3;\n        float neckFade = S(3., 10., p.z);\n        p.y += sin(p.z*.1-t)*neckFade;\n        \n        vec3 baseCol = mix(vec3(1., 1., .2), vec3(.3, .8, .1), S(-.55, -.1, p.y));\n        col *= mix(baseCol, vec3(.2,.4,.2)*.5, wave);\n        col += spe*pow(1.-abs(n.w), 5.)*.3;\n        \n        r = texture(iChannel1, ref).rgb;\n        col += r*r*.05;\n    } else if(mat.x==MAT_TONGUE) {\n    \tcol *= vec3(.4, .1, .2);\n        col += pow(min(1., spe*5.), 5.);\n    }\n    \n    return vec4(col, 1);\n}\n\nvec3 Render(vec2 uv, vec2 m, float t, vec3 _ro, vec3 _rd)\n{\n    vec3 ro = vec3(0, 0, -3)*(8.+sin(t*.2)*2.*CAM_MOVE);\n    ro.yz *= Rot(-m.y*3.14+sin(t*.03)*CAM_MOVE*.2);\n    ro.xz *= Rot(-m.x*6.2831*2.+sin(t*.05)*CAM_MOVE);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0,sin(t*.11)), 6.);\n    \n    ro = _ro;\n    rd = _rd;\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 col = vec3(0);\n    \n    vec2 env = RaySphere(ro, rd, vec4(0,0,0,20));\n    \n    if(d<MAX_DIST) {\n        vec4 snake = Material(ro, rd, d);\n    \tsnake.rgb *= S(14., 8., d);\n        col = mix(col, snake.rgb, snake.a);\n    } else {\n    \tcol = (rd.y*.5+.5)*vec3(.4, 1.,.2);\n        col *= texture(iChannel0, rd).rgb;\n        col *= 1.-S(.8, 1., rd.z);\n        \n        if(env.y>0.)\t// vines behind\n            col *= S(0., 1.1, sdGyroid(ro + env.y*rd, .4, .1, .0))*.5+.5;\n    }\n    \n    if(env.x>0.)\t// vines in front\n        col *= S(0., .25, sdGyroid(ro + env.x*rd, .25, .1, .0));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;    \n    if(m.x<-.49 && m.y<-.49) m*=0.;\n    \n    vec3 col = Render(uv, m, iTime, _ro, _rd);\n    \n    col *= 1.5;\t\t\t\t\t\t// exposure adjustment\n    col = pow(col, vec3(.4545));\t// gamma correction\n    col *= 1.-dot(uv,uv)*.3;\t\t// vignette\n\n    fragColor = vec4(col,1.0);\n}\n\n#define QAA\t2                                     \n\nconst float\tsideAngle       = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 4.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 8.0; \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize / aspectRatio,0);\n\t\n\t//vec4\tcolor = vec4( vec3(valueId), 1 );\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n    dirRay.z = -dirRay.z;\n\tmainImage( color, fract * iResolution.xy, screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 21528, "src": "https://soundcloud.com/extasis_demencial/jungle-sounds", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}, {"id": 21529, "src": "https://soundcloud.com/liam-seagrave/pandemic-prologue-slow-strings-suspense-music-original-horror-piano-composition", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3zK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[622, 643, 664, 664, 797], [799, 799, 821, 821, 916], [918, 918, 947, 947, 1026], [1028, 1028, 1070, 1070, 1325], [1327, 1338, 1379, 1379, 1470], [1472, 1472, 1511, 1511, 1537], [1539, 1539, 1558, 1558, 1634], [1636, 1636, 1702, 1702, 1781], [1783, 1783, 1836, 1836, 1948], [1951, 1951, 2025, 2025, 2900], [2902, 2902, 2978, 2978, 3160], [3163, 3163, 3184, 3184, 3923], [3925, 3925, 3986, 3986, 4708], [4710, 4710, 4732, 4732, 5589], [5591, 5591, 5615, 5615, 6200], [6202, 6202, 6225, 6225, 6409], [6411, 6411, 6432, 6432, 7025], [7028, 7028, 7062, 7062, 7273], [7275, 7290, 7340, 7340, 7653], [7655, 7655, 7705, 7705, 7896], [7899, 7899, 7941, 7941, 10021], [10023, 10023, 10082, 10082, 10994], [10997, 10997, 11080, 11080, 11465], [11778, 11778, 11834, 11834, 12603]], "test": "untested"}
{"id": "NtB3zK", "name": "LookingGlass: Cloudy SpikeBall", "author": "xjorma", "description": "Original shader from Duke\nShader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["volume", "tutorial", "cloud", "pouet", "glass", "ball", "looking", "lookingglass"], "likes": 0, "viewed": 244, "published": 3, "date": "1624216685", "time_retrieved": "2024-07-30T19:14:59.121794", "image_code": "// port from http://glslsandbox.com/e#1802.0 with some modifications\n//--------------\n// Posted by las\n// http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\n#define SCATTERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(3., 2., 1.)/3.)*6.-3.)-1.), 0., 1.), s)*v\n\n\n/* original noise\nfloat pn(vec3 p) {\n   vec3 i = floor(p);\n   vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n   vec3 f = cos((p-i)*pi)*(-.5) + .5;\n   a = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n   a.xy = mix(a.xz, a.yw, f.y);\n   return mix(a.x, a.y, f.z);\n}\n*/\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\n//vec3 n1 = vec3(1.000,0.000,0.000);\n//vec3 n2 = vec3(0.000,1.000,0.000);\n//vec3 n3 = vec3(0.000,0.000,1.000);\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\nvec3 n8 = vec3(0.000,0.357,0.934);\nvec3 n9 = vec3(0.000,-0.357,0.934);\nvec3 n10 = vec3(0.934,0.000,0.357);\nvec3 n11 = vec3(-0.934,0.000,0.357);\nvec3 n12 = vec3(0.357,0.934,0.000);\nvec3 n13 = vec3(-0.357,0.934,0.000);\nvec3 n14 = vec3(0.000,0.851,0.526);\nvec3 n15 = vec3(0.000,-0.851,0.526);\nvec3 n16 = vec3(0.526,0.000,0.851);\nvec3 n17 = vec3(-0.526,0.000,0.851);\nvec3 n18 = vec3(0.851,0.526,0.000);\nvec3 n19 = vec3(-0.851,0.526,0.000);\n\nfloat spikeball(vec3 p) {\n   vec3 q=p;\n   p = normalize(p);\n   vec4 b = max(max(max(\n      abs(vec4(dot(p,n16), dot(p,n17),dot(p, n18), dot(p,n19))),\n      abs(vec4(dot(p,n12), dot(p,n13), dot(p, n14), dot(p,n15)))),\n      abs(vec4(dot(p,n8), dot(p,n9), dot(p, n10), dot(p,n11)))),\n      abs(vec4(dot(p,n4), dot(p,n5), dot(p, n6), dot(p,n7))));\n   b.xy = max(b.xy, b.zw);\n   b.x = pow(max(b.x, b.y), 140.);\n   return length(q)-2.5*pow(1.5,b.x*(1.-mix(.3, 1., sin(iTime*2.)*.5+.5)*b.x));\n}\n\nfloat f(vec3 p) {\n   p.z += 6.;\n   R(p.xy, iTime);\n   R(p.xz, iTime);\n   return spikeball(p) + fpn(p*50.+iTime*15.) * 0.45;\n}\n\n/*\nvec3 g(vec3 p) {\n   vec2 e = vec2(.0001, .0);\n   return normalize(vec3(f(p+e.xyy) - f(p-e.xyy),f(p+e.yxy) - f(p-e.yxy),f(p+e.yyx) - f(p-e.yyx)));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, vec3 _ro, vec3 _rd)\n{  \n   // p: position on the ray\n   // d: direction of the ray\n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((fragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   d = normalize(d); \n   \n   p = _ro;\n   d = _rd;\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0., td=0.;\n   float w=0.;\n   \n   // total color\n   vec3 tc = vec3(0.);\n   \n   // i: 0 <= i <= 1.\n   // r: length of the ray\n   // l: distance function\n   float r=0., l=0., b=0.;\n\n   // rm loop\n   for (float i=0.; (i<1.); i+=1./64.) {\n\t   if(!((i<1.) && (l>=0.001*r) && (r < 50.)&& (td < .95)))\n\t\t   break;\n      // evaluate distance function\n      l = f(p) * 0.5;\n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      const float h = .05;\n      ld = (h - l) * step(l, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w; // * hsv(w, 1., 1.); // * hsv(w*3.-0.5, 1.-w*20., 1.); \n      td += w;\n       \n      td += 1./200.;\n      \n      // enforce minimum stepsize\n      l = max(l, 0.03);\n      \n      // step forward\n      p += l*d;\n      r += l;\n   }  \n    \n   #ifdef SCATTERING\n   // simple scattering approximation\n   tc *= 1. / exp( ld * 0.4 ) * 1.25;\n   #endif\n      \n   fragColor = vec4(tc, 1.0); //vec4(tc.x+td*2., ld*3., 0, tc.x);\n}\n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 8.0;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 6.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n\tmainImage( color, fract*(iResolution.xy), screenPos - vec3(0, 0, 6) - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3zK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 659, 682, 682, 900], [903, 903, 922, 922, 985], [1678, 1678, 1703, 1703, 2166], [2168, 2168, 2185, 2185, 2293], [2450, 2450, 2526, 2587, 3887], [4142, 4142, 4198, 4198, 4912]], "test": "untested"}
{"id": "flB3RK", "name": "LookingGlass: Tutorial VR Done", "author": "xjorma", "description": "Shader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["tutorial", "glass", "looking", "lookingglass"], "likes": 0, "viewed": 266, "published": 3, "date": "1624207640", "time_retrieved": "2024-07-30T19:14:59.952573", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n//#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_DIST\t\t150.\nconst float PI = radians(180.);\n\n\n\nfloat map(vec3 p)\n{\n\treturn length(p) - 1.0;\n}\n\n\n\nfloat rayMarch(in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 40; i++)\n  {\n    float h = map(ro + rd * t);\n    t += h;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.2 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float t = rayMarch(ro, rd, 0.);\n    vec3\tcol = vec3(0);\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);   \n        col = texture(iChannel0, reflect(rd, n)).rgb;\n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro + vec3(0, 0, 9), rd), 1);\n}\n\n\n// Comment the original mainImage\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI * 0.3;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - PI / 2.;\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        tot += Render(ro ,rd);\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n*/\n\n#define QAA\t2                                     \n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize = 2.0;\nconst float\taspectRatio = 0.75;\nconst vec3  VROffset = vec3(0, 0, 9);\n\n// Standard\n\nfloat quiltColumns\t=\t8.;\nfloat quiltRows\t\t=\t6.;\n\n// Hires\n\n//float quiltColumns\t=\t5;\n//float quiltRows\t\t=\t9;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4\taccColor = vec4(0.);\n    for( int m = 0; m < QAA; m++ )\n    for( int n = 0; n < QAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m), float(n)) / float(QAA) - 0.5) / iResolution.xy                                                                                 ;\n\t\t\n\t\tvec2\tcoord = (fragCoord / iResolution.xy  + o) * vec2(quiltColumns,quiltRows);\n\t\tvec2\tfract = fract(coord);\n\t\tvec2\tfloor = floor(coord);\n\t\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\t\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\t\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\t\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\t\n\t\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\t\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\t\tvec3\tdir = normalize(screenPos - camPos);\n\t\tvec4\tcolor;\n\t\tmainVR(color, fragCoord, camPos - VROffset, dir);\n\t\taccColor += clamp(color, 0.0, 1.0);\n\t}\n\tfragColor = accColor / float(QAA*QAA);\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3RK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[245, 245, 264, 264, 291], [295, 295, 350, 350, 515], [1072, 1072, 1127, 1127, 1223], [1226, 1226, 1263, 1263, 1493], [1495, 1495, 1537, 1537, 1701], [1703, 1703, 1781, 1781, 1840], [3329, 3329, 3386, 3386, 4423]], "test": "untested"}
{"id": "NlS3RK", "name": "Radio Signal kinda", "author": "ashishkarn", "description": "First shader using sin cos functions.", "tags": ["first"], "likes": 0, "viewed": 223, "published": 3, "date": "1624206002", "time_retrieved": "2024-07-30T19:15:01.342855", "image_code": "float plot(float pct, vec2 st){\n    float buffer;\n    //buffer=0.08;\n    float sinB=cos(iTime/10.)*2000.0;\n    buffer=sin(sinB*(st.x+iTime))/5.0;\n    return smoothstep(pct-buffer,pct,st.y)-smoothstep(pct,pct+buffer,st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    \n    vec3 green = vec3(0.,1.0,0.);\n\n    float y=0.5;\n    \n    vec3 color = green*plot(y,st);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3RK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 282, 332, 529]], "test": "untested"}
{"id": "NsGyD3", "name": "Parabola Segment- distance L-inf", "author": "iq", "description": "Distance to an segment of a parabola, in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url].", "tags": ["2d", "distancefield", "sdf", "parabola", "linf"], "likes": 7, "viewed": 470, "published": 3, "date": "1624197814", "time_retrieved": "2024-07-30T19:15:02.221506", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a parabolic segment in the L-infinity metric space.\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\nfloat sdParabola( in vec2 pos, in float wi, in float he )\n{\n    pos.x = abs(pos.x);\n    \n    float a = pos.x-pos.y-wi;\n    float b = pos.y-pos.x-he;\n\n    if( a>0.0 ) return max(abs(pos.x-wi),abs(pos.y));\n    if( b>0.0 ) return max(abs(pos.y-he),    pos.x );\n\n    return pos.x + (wi-sqrt(wi*wi-4.0*he*b)) * 0.5*wi/he;\n}\n\n/*\n// infinite parabola (not a segment)\nfloat sdParabola( in vec2 pos, in float wi, in float he )\n{\n    pos.x = abs(pos.x);\n    float b = pos.y-pos.x-he;\n    if( b>0.0 ) return max(abs(pos.y-he), pos.x );\n    return pos.x + (wi-sqrt(wi*wi-4.0*he*b))*0.5*wi/he;\n}*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    // animate\n    float t = iTime/2.0;\n\tfloat w = 0.7+0.69*sin(iTime*0.61+0.0);\n    float h = 0.4+0.35*sin(iTime*0.53+2.0);\n    if( iMouse.x<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,1));\n    \n    // sdf\n    float d = sdParabola( p, w, h );\n    \n    \n    // colorize\n    //vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n    vec3 col = vec3(1.0,0.9,1.0) + vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(160.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    //if( iMouse.z>0.001 )\n    {\n    d = sdParabola(m, w, h );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n    }\n\n    // width and height\n    d = length(p-vec2(0.0,h))-0.02;\n    d = min(d, length(p-vec2(w,0.0))-0.02);\n    col = mix( col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0,0.01,d) );\n    \n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGyD3.jpg", "access": "api", "license": "mit", "functions": [[1247, 1247, 1306, 1306, 1565], [1834, 1834, 1889, 1889, 3010]], "test": "untested"}
{"id": "st2GRy", "name": "大龙猫 - Quicky#056", "author": "totetmatt", "description": "Quciky", "tags": ["quicky"], "likes": 11, "viewed": 324, "published": 3, "date": "1624191541", "time_retrieved": "2024-07-30T19:15:03.062258", "image_code": "#define fGlobalTime iTime\nfloat box(vec2 p,vec2 b){\n    vec2 q = abs(p) -b;\n    return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n}\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat sdCross( in vec3 p ) // From IQ \n{\n  float da = box(p.xy,vec2(.1));\n  float db = box(p.yz,vec2(0.1));\n  float dc = box(p.zx,vec2(0.1));\n  return min(da,min(db,dc));\n}\nfloat diam(vec3 p,float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*sqrt(1./3.);\n  }\nvec2 sdf(vec3 p){\n  //p.xy*=rot(fGlobalTime);\n  vec3 pp=p;\n    vec2 h;\n    \n  // p.x +=.2;\n    for(float i=0.;i<=3.;i++){\n        p = abs(p)-2.8655;\n      //p*=1.05;\n        p.xz*=rot(-.785);\n         p.xy = p.x < p.y ? p.yx:p.xy;\n    }      \n    h.x = min(diam(p,3.),sdCross(p));\n    p= abs(p)-.8;\n    p = asin(sin(p));\n    h.x = max(-(length(p)-1.1),h.x);\n    h.y= fract(p.z) >.25 ? 1.:3.;\n    \n    vec2 t;\n    t.x = diam(pp,1.4);\n    t.y = 2.;\n    h = t.x < h.x ? t:h;\n    return h;\n}\n#define q(s) s*sdf(p+s).x\nvec2 nv=vec2(-.001,.001);\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\nvec3 col = vec3(.1);\n  \n  vec3 ro=vec3(sin(fGlobalTime*.1)*3.5,0.75,cos(fGlobalTime*.1)*3.5);\n\t\n  vec3 rt = vec3(0.+sin(fGlobalTime)*.1,0.+cos(fGlobalTime)*.1,0.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = cross(z,vec3(0.,-1.,0.));\n  vec3 y = cross(z,x);\n  \n  \n  vec3 rd=normalize(mat3(x,y,z)*vec3(uv,1.+sin(fGlobalTime*.1)*.4));\n  vec3 rp = ro;\n  vec3 light = vec3(1.,2.,-3.);\n  \n  float i;\n  const float c=69.;\n  vec3 acc = vec3(0.);\n  float rdp=0.;\n  for(i=0.;i<=c;i++){\n      vec2 d = sdf(rp);\n    \n      if(d.y ==1.) {\n        vec2 vv= vec2(atan(rp.x,rp.z),rp.y);\n        acc += vec3(1.1,.5,.3)*(exp(2.*-abs(d.x))/(10.1+19.*fract(fGlobalTime+texture(iChannel0,vv*.001).r\n)));\n        \n         \n      }\n       if(d.y ==3.) {\n        vec2 vv= vec2(atan(rp.x,rp.z),rp.y);\n        acc += vec3(.1,1.5,1.3)*(exp(2.*-abs(d.x))/(40.1+19.*fract(fGlobalTime+texture(iChannel0,vv*.001).r\n)));\n        \n         d.x = max(.002,abs(d.x));\n      }\n     rp+=rd*d.x;\n      rdp+=d.x;\n      if(d.x <=.001 || rdp>=15.){\n        if(d.y==2.){\n            vec3 n = norm(rp);\n          float fre = pow((1.+dot(rd, n)), 2.);\n            rd = reflect(rd,n+texture(iChannel0,rp.xy*.1+vec2(fGlobalTime*.001)).r);\n            rp+=n*0.002;\n           col +=vec3(.0,.1,.50)*.5+fre*vec3(.3,.5,0.1);\n         \n          }\n        else break;\n        }\n    \n  }\n\n  col +=acc;\n\n    fragColor = vec4(sqrt(col)*col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2GRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 51, 51, 134], [136, 136, 154, 154, 201], [202, 202, 242, 242, 374], [375, 375, 402, 402, 458], [459, 459, 476, 504, 946], [999, 999, 1017, 1017, 1076], [1077, 1077, 1134, 1184, 2634]], "test": "untested"}
{"id": "st23RG", "name": "Pixel perfect outline ( MIPmap )", "author": "FabriceNeyret2", "description": "MIPmap variant of https://shadertoy.com/view/7ljGWD : precomputing mask, drawing isoval 0.5 .\n( LOD0 contour not antialiased ).\nNot sure why LOD8 is aliased: precision loss ?\nBTW builtin MIPmap of non-power-of-2 is very wrong, especially on Windows.", "tags": ["pixel", "outline", "gpmipmap"], "likes": 16, "viewed": 690, "published": 3, "date": "1624176466", "time_retrieved": "2024-07-30T19:15:03.927944", "image_code": "// MIPmap variant of https://shadertoy.com/view/7ljGWD\n// LOD variant of \"Pixel perfect outline\" by portponky. https://shadertoy.com/view/7tj3Wh\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O -= O; \n    for(float l=0.,c; l<8.; l++) {\n        c = T(U,l).a;\n        if (c<.5) O += .15* vec4(0, .58, .88, 1);\n        O += (1.-O) * max( 1.-abs(c-.5)/fwidth(c), 0.);\n     // O = mix(O, vec4(1), () ); // simplified above\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = T(U,0.);\n    O.a = step( .1, length(  O - vec4(.05, .64, .15, 1) ) ); // a := mask \n    // ( we might antialias LOD0 using a loop as in original version )\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U,l) textureLod( iChannel0, (U)/iResolution.xy, l )", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 185, 185, 423]], "test": "untested"}
{"id": "stj3RG", "name": "GLSL bug #31", "author": "FabriceNeyret2", "description": "on OpenGL(Ubuntu) / nVIDIA / chrome, the top and bottom differs alot:\ni-i/2 not equals i/2\nindeed, in the context, - (i-i/2.) is compiled as +(i-i/2.)", "tags": ["glsl", "bug"], "likes": 1, "viewed": 307, "published": 3, "date": "1624173822", "time_retrieved": "2024-07-30T19:15:04.810584", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    \n    O = vec4(0); \n    \n    for( float i = 1.; i < 15.; i++ )\n        if (U.y > .5 ) O +=   .01 /  sin( U.x*i - (i-i/2.) );\n     // if (U.y > .5 ) O +=   .01 /  sin( U.x*i + (i-i/2.) ); // indeed, does this !\n        else           O +=   .01 /  sin( U.x*i - ( i/2. ) );\n        \n        // but ok for 2*i-i vs i , for shorter loop, \n        // and for simpler expr. replacing sin by abs shows bug too.\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stj3RG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 472]], "test": "untested"}
{"id": "7tS3DW", "name": "Path-Traced Black Hole", "author": "Zi7ar21", "description": "This would not have been possible without epic michael0884's help! DaniilMaks, a user on the SpaceEngine Discord gave invaluable color management help.", "tags": ["pathtrace", "pathtracing", "pathtracer", "blackhole", "tracing", "traced", "tracer", "optics", "trace", "path", "hole", "optic", "black", "bh", "pathtraced"], "likes": 44, "viewed": 1712, "published": 3, "date": "1624168616", "time_retrieved": "2024-07-30T19:15:05.746084", "image_code": "// ####### Path-Traced Black Hole #######\n// Made by Jacob Bingham (Zi7ar21) on June 19th, 2021\n// Happy Juneteenth :)\n\n// Last Updated on September 11th, 2021 at 20:30 Mountain Standard Time\n// (I realized I made a mistake and was using density instead of absorbance when determining if a ray should bounce, oops! Fixed.)\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/7tS3DW\n\n/* I wanted to know how to Ray-March a black hole, I initially used Newtonian gravity (1/r^2) as the force acting on the ray,\nbut michael0884 showed me that there is a better way of doing it and so I ~~stole~~ borrowed that. He sent a link to a cool\narticle which I think he used. Check it out at: https://rantonels.github.io/starless/. This Shader features:\n- Parameters (on Shadertoy, go to Common)\n- Ray-Marched Black Hole Simulation\n- Volumetric Accretion Disk (the stuff orbiting the Black Hole)\n- HDR and Tonemapped Image Preview\n- Monte-Carlo Bloom\n- XYZ Color Management Stuff\n- OpenEXR Export (on Shadertoy, go to Buffer B)\n- Some fixes and visual improvements from michael0884\n- idk what else to advertize, I really like how this turned out\n*/\n\n/*\nTodo:\n- Redshift/Blueshift (eh there isn't really a way to do this accurately without going to spectral rendering)\n- Kerr metric Stuff (lmao funny joke, if I can't add Redshift/Blueshift then there is no chance of this being added)\n- idk tell me what I should do\n*/\n\n// \"License\":\n// You are free to use this code, even commercially, as long as you keep comments in the source with credits to snippets that aren't mine.\n// e.g. PCG Random: https://www.pcg-random.org/\n// Of course, you must also still respect whatever licenses they use. We are programmers, not lawyers! :)\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Pyscho\n// https://www.shadertoy.com/user/Dumb_Psycho\n\n// Render Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Image Export Buffer\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = tonemap(color);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### Preprocessor #####\n\n/*\n//\n#if __VERSION__ < 300\n#error This shader requires GLSL 300 ES to run!\n#endif\n*/\n\n// Build Flags\n//#pragma optimize(on)\n//#pragma debug(off)\n\n// ##### Parameters #####\n\n// Exposure\n#define exposure 1.0\n\n// Image Gamma\n// unused by the default tonemap, uncomment one of the other one to use this\n//#define gamma 2.2\n\n// Camera Field of View\n#define camfov 1.0\n\n#define dt 0.05\n#define blackholeRadius 0.5\n#define maxSteps 65536U\n#define maxDist 4.0\n#define maxBounces 8U\n\n// Camera Sensor Size (for DoF, unused by default, uncomment it in Buffer A)\n//#define sensorSize 0.035\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### Shortcuts #####\n\n// Traditional Input Names (Shadertoy Only)\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffer\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// ##### Additional Maths #####\n\n// Rotate a 2-Component Vector\nvec2 rotate2(vec2 vec, float rot)\n{\n    float s = sin(rot), c = cos(rot);\n    return vec2(vec.x*c-vec.y*s, vec.x*s+vec.y*c);\n}\n\n// Dot Product\n// For optimizations involving comparing length, for example:\n// min(length(vector0), length(vector1))\n// This can be simplified and save 1 sqrt computation by changing it to:\n// sqrt(min(dotp(vector0), dotp(vector1)))\n\nfloat dotp(vec2 vec)\n{\n    return dot(vec, vec);\n}\n\nfloat dotp(vec3 vec)\n{\n    return dot(vec, vec);\n}\n\nfloat dotp(vec4 vec)\n{\n    return dot(vec, vec);\n}\n\n// ##### Color Management #####\n\n/*\n// https://www.color.org/chardata/rgb/sRGB.pdf\nconst mat3 XYZ2sRGB = mat3(\n 3.2406255, -1.5372080, -0.4986286,\n-0.9689307,  1.8757561,  0.0415175,\n 0.0557101, -0.2040211,  1.0569959);\n*/\n/*\n// https://www.shadertoy.com/view/4s3cRr\nconst mat3 XYZ2sRGB = mat3(\n 3.2404542, -1.5371385, -0.4985314,\n-0.9692660,  1.8760108,  0.0415560,\n 0.0556434, -0.2040259,  1.0572252);\n*/\n/*\n// https://www.shadertoy.com/view/tsKczy\nconst mat3 XYZ2sRGB = mat3(\n 3.2409699419, -1.5373831776, -0.4986107603,\n-0.9692436363,  1.8759675015,  0.0415550574,\n 0.0556300797, -0.2039769589,  1.0569715142);\n*/\n\n// Every XYZ to sRGB matrix I find is slightly different, so here is a rounded off one:\nconst mat3 XYZ2sRGB = mat3(\n 3.240, -1.537, -0.499,\n-0.969,  1.876,  0.042,\n 0.056, -0.204,  1.057);\n\n// Convert XYZ to sRGB\nvec3 XYZtoRGB(vec3 XYZ)\n{\n    return XYZ*XYZ2sRGB;\n}\n\n// idk what to cite, here are some shaders that all use this:\n// https://www.shadertoy.com/view/tsKczy\n// https://www.shadertoy.com/view/MslSDl\n// https://www.shadertoy.com/view/MttyzB\nvec3 blackbodyXYZ(float t)\n{\n    // https://en.wikipedia.org/wiki/Planckian_locus\n    float u = (0.860117757+1.54118254E-4*t+1.28641212E-7*t*t)/(1.0+8.42420235E-4*t+7.08145163E-7*t*t);\n    float v = (0.317398726+4.22806245E-5*t+4.20481691E-8*t*t)/(1.0-2.89741816E-5*t+1.61456053E-7*t*t);\n\n    // https://en.wikipedia.org/wiki/CIE_1960_color_space\n    // https://en.wikipedia.org/wiki/XYZ_color_space\n\n    // Hippitty Hoppity through magic convert the planckian locus to some weird Color space linked to XYZ\n    vec2 xyy = vec2(3.0*u, 2.0*v)/(2.0*u-8.0*v+4.0);\n\n    // And then convert from the shart color space to XYZ and fart it out\n    return vec3(xyy.x/xyy.y, 1.0, (1.0-xyy.x-xyy.y)/xyy.y);\n}\n\n// Sh*tty HDR Tonemap(tm)\nvec3 tonemap(vec3 color)\n{\n    // Tonemap (fits colors to 0.0-1.0)\n    color = 1.0-exp(-color*exposure);\n\n    // sRGB Color Component Transfer: https://www.color.org/chardata/rgb/sRGB.pdf\n    color  = vec3(\n    color.r > 0.0031308 ? (pow(color.r, 1.0/2.4)*1.055)-0.055 : color.r*12.92,\n    color.g > 0.0031308 ? (pow(color.g, 1.0/2.4)*1.055)-0.055 : color.g*12.92,\n    color.b > 0.0031308 ? (pow(color.b, 1.0/2.4)*1.055)-0.055 : color.b*12.92);\n\n    return clamp(color, 0.0, 1.0);\n}\n\n/*\n// HDR Tonemapping Function (Basically Reinhard with Gamma-Correction)\nvec3 tonemap(vec3 color)\n{\n    // Clamp Values Less Than 0.0\n    color = max(color, 0.0);\n\n    // Image Gamma\n    const vec3 imageGamma = vec3(1.0/gamma);\n\n    // Reinhard and Gamma-Correction\n    color = pow(color/(color+1.0), imageGamma);\n    //color = pow(tanh(color), imageGamma);\n\n    // Return Tone-Mapped Color\n    return clamp(color, 0.0, 1.0);\n}\n*/\n\n// ##### Random Number Generation #####\n\n// Hash44 Hash without Sine: https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec3 pos, float t)\n{\n    vec4 p4 = vec4(pos, t);\n    p4  = fract(p4*vec4(0.1031, 0.1030, 0.0973, 0.1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// PCG Random: https://www.pcg-random.org/\nuint hash(uint x)\n{\n    uint state = x*0x2C9277B5U+0xAC564B05U;\n    uint word  = ((state >> ((state >> 28U) + 4U)) ^ state) * 0x108EF2D9U;\n    return (word >> 22U) ^ word;\n}\n\n//\nuint ns;\n#define initializeRNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n\n//\nfloat rand()\n{\n    ns = hash(ns);\n    return float(ns)/float(0xFFFFFFFFU);\n}\n\n// Random Vectors\nvec2 rand2(){return vec2(rand (), rand());}\nvec3 rand3(){return vec3(rand2(), rand());}\nvec4 rand4(){return vec4(rand3(), rand());}\n//vec5 rand5(){return vec5(rand4(), rand());} // GLSL Sus Imposter Confirmed!? The truth is out there...\n\n// See michael0884's usage of PCG Random\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n\n// Normalized Random Vectors\n// A point is equally probable to land at every point inside the volume of a sphere at the mean with a radius of sigma\nvec2 nrand2(float sigma, vec2 mean)\n{\n    vec2 z = rand2();\n    return mean+sigma*sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w));\n}\n\n// Uniform Random Vectors\n// A point is equally probable to land at every point on the surface of a sphere with a radius of 1.0\nvec3 urand3()\n{\n    vec2 z = rand2();\n    vec2 r = vec2(2.0*pi*z.x, acos(2.0*z.y-1.0));\n    vec2 s = sin(r), c = cos(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}", "buffer_a_code": "// ##### Rendering #####\n\n// Noise (from Hash)\nfloat noise(vec3 pos, uint octave)\n{\n    // Octave\n    float t = float(octave);\n\n    // Store the Fractional Part of the Coordinate, for Interpolation later\n    vec3 f = fract(pos);\n\n    // Floor-ify the Position (so the hash gets nice whole numbers)\n    pos = floor(pos);\n\n    // Sample\n    float t0 = hash44(vec3(0.0, 0.0, 0.0)+pos, t).x;\n    float t1 = hash44(vec3(1.0, 0.0, 0.0)+pos, t).x;\n    float t2 = hash44(vec3(0.0, 1.0, 0.0)+pos, t).x;\n    float t3 = hash44(vec3(1.0, 1.0, 0.0)+pos, t).x;\n    float t4 = hash44(vec3(0.0, 0.0, 1.0)+pos, t).x;\n    float t5 = hash44(vec3(1.0, 0.0, 1.0)+pos, t).x;\n    float t6 = hash44(vec3(0.0, 1.0, 1.0)+pos, t).x;\n    float t7 = hash44(vec3(1.0, 1.0, 1.0)+pos, t).x;\n\n    // Return Interpolated Value\n    return mix(mix(mix(t0, t1, f.x), mix(t2, t3, f.x), f.y), mix(mix(t4, t5, f.x), mix(t6, t7, f.x), f.y), f.z);\n}\n\n// Fractal Brownian Motion (FBM) Noise\nfloat fbm(vec3 pos)\n{\n    // Set-Up Variables\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n\n    for(uint i = 0U; i < 8U; i++)\n    {\n        value += noise(pos*scale, 10U*i)*atten;\n        //value += (length(function(pos*scale*2.0))*0.3)*atten;\n        scale *= 2.2;\n        atten *= 0.5;\n    }\n\n    return value;\n}\n\n// Basically copied and pasted from michael0884\n// https://rantonels.github.io/starless/\nvec3 gravitationalForce(vec3 pos)\n{\n    vec3 r = pos/blackholeRadius;\n    float R = length(r);\n    return -4.0*1.5*r/pow(R, 5.0);\n}\n\n// Color Shift Function Reference from SE Ship Engine Shader\n/*\n*/\n\n/*\n// Approximation of Redshift/Blueshift\nvec3 shiftColor(vec3 color, float t)\n{\n    color = t > 0.0 ?\n    vec3(\n    mix(color.r, 0.0    , clamp(t, 0.0, 1.0)),\n    mix(color.g, color.r, clamp(t, 0.0, 1.0)),\n    mix(color.b, color.g, clamp(t, 0.0, 1.0))) :\n    vec3(\n    mix(color.r, color.g, clamp(-t, 0.0, 1.0)),\n    mix(color.g, color.b, clamp(-t, 0.0, 1.0)),\n    mix(color.b, 0.0    , clamp(-t, 0.0, 1.0)));\n\n    return color;\n}\n*/\n\n//\nfloat getDensity(in vec3 pos, out vec3 volumeColor, out vec3 emission)\n{\n    // Set-Up Variables\n    volumeColor = vec3(0.20, 0.15, 0.10);\n    emission = vec3(0.0);\n\n    // Bounds (increases performance by skipping sampling noise where it isn't needed)\n    if(dotp(pos.xz) > 8.0 || abs(pos.y) > 0.3)\n    {\n        return 0.0;\n    }\n\n    // Accretion Disk \n    vec3 gasColor = blackbodyXYZ(2300.0);\n    gasColor = XYZtoRGB(gasColor);\n    gasColor = clamp(gasColor/max(max(gasColor.x, gasColor.y), gasColor.z), 0.0, 1.0);\n\n    // Noise\n    float volumeNoise = fbm(vec3(rotate2(pos.xz, pos.y+length(pos.xz)*2.0), pos.y).xzy*20.0);\n\n    // Emission\n    emission = gasColor*128.0*max(volumeNoise-length(vec3(0.2, 8.0, 0.2)*pos), 0.0)/((dotp(pos*0.5)*dotp(pos*0.5))+0.05);\n\n    // Return Density\n    return max(volumeNoise-length(vec3(0.12, 7.5, 0.12)*pos), 0.0)*128.0;\n}\n\n// Color of the Sky\nvec3 skyColor(vec3 dir)\n{\n    // Pure Black Void\n    return vec3(0.0);\n}\n\n// Path-Tracing\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    vec3 raypos = ro+(rand()*rd*dt);\n    vec3 velocity = rd;\n    vec3 attenuation = vec3(1.0);\n    vec3 radiance = vec3(0.0);\n    vec3 volumeColor = vec3(1.0);\n    vec3 volumeEmission = vec3(0.0);\n    uint bounces = 0U;\n\n    // Ray-Marching\n    for(uint i = 0U; i < maxSteps; i++)\n    {\n        // Check if we reached the bounce limit\n        if(bounces > maxBounces)\n        {\n            break;\n        }\n\n        //if(length(raypos) > maxDist)\n        if(dotp(raypos) > maxDist*maxDist)\n        {\n            radiance += attenuation*skyColor(normalize(velocity));\n            return radiance;\n        }\n\n        // Get the Volume at the Ray Position\n        float density = getDensity(raypos, volumeColor, volumeEmission);\n\n        // Compute the Absorbance of the Volume\n        float absorbance = exp(-1.0*density*dt);\n\n        // Emission\n        radiance += attenuation*volumeEmission*dt;\n\n        // Determine if the Ray will Bounce\n        if(absorbance < rand())\n        {\n            // Compute the Direction of the Ray\n            velocity = reflect(velocity, urand3());\n            //velocity = reflect(normalize(velocity), urand3())*length(velocity);\n\n            // Absorbed Light\n            attenuation = clamp(attenuation*volumeColor, 0.0, 1.0);\n\n            // Increment the Bounces Counter\n            bounces++;\n        }\n\n        // Compute the Gravitational Force Acting on the Ray\n        vec3 g = gravitationalForce(raypos);\n\n        // Apply the Gravitational Force\n        velocity += g*dt;\n\n        // Redshift/Blueshift?\n        //radiance = shiftColor(radiance, raypos);\n\n        // March the Ray Forward\n        raypos += velocity*dt;\n\n        //if(length(raypos) < blackholeRadius)\n        if(dotp(raypos) < blackholeRadius*blackholeRadius)\n        {\n            return radiance;\n        }\n    }\n\n    // Return Expired Sample\n    return vec3(-1.0);\n}\n\n// Monte-Carlo Dithering/Anti-Aliasing\nvec2 dither(vec2 pos)\n{\n    return nrand2(0.5, pos);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Progressive Rendering\n    fragColor = frame != 0 ? texel0 : vec4(0.0);\n\n    // Initialize the Random Number Generator\n    initializeRNG;\n\n    // Bloom\n    float t = rand();\n    if(t < 0.25)\n    {\n        // Large Bloom\n        float r2 = rand();\n        fragCoord += nrand2(32.0*r2*r2*r2, vec2(0.0));\n    }\n    else if(t < 0.5)\n    {\n        // Microbloom\n        fragCoord += nrand2(4.0, vec2(0.0));\n    }\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(dither(fragCoord.xy)-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Position of the Camera\n    vec3 cameraPosition = vec3(0.0, 0.2, -3.5);\n    //vec3 cameraPosition = vec3(0.0, 0.4, -3.0);\n\n    // No DoF\n    vec3 ro = cameraPosition;\n    // Crappy Depth of Field (more infinitely far objects in focus)\n    //vec3 ro = cameraPosition+vec3(rand2()*sensorSize, 0.0);\n\n    // Standard Rotation Matrix\n    //mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\n    // Slight Angle\n    mat3 rotmat = mat3(\n    1.0,-0.2, 0.0,\n    0.2, 1.0, 0.1,\n    0.0,-0.1, 1.0);\n\n    // Normalize the Rotation Matrix\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n\n    // Compute the Ray Direction\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Sample\n    vec3 color = radiance(ro, rd);\n\n    // Output the Rendered Sample\n    fragColor += !any(lessThan(color, vec3(0.0))) && !any(isinf(color)) && !any(isnan(color)) ? vec4(color, 1.0) : vec4(0.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### Image Export #####\n// On Shadertoy you can export an OpenEXR image, just press the image-icon button on the bottom right of the editor.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Progressive Rendering Buffer\n    vec4 texel = texel0;\n\n    // Compute and Output the Final Color\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3DW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2007, 2025, 2080, 2115, 2265]], "test": "untested"}
{"id": "7lBGRR", "name": "Cyclic noise 3d", "author": "michael0884", "description": "just a camera controller with quaternions\nalso a fractal planet as a demo", "tags": ["camera"], "likes": 22, "viewed": 511, "published": 3, "date": "1624156427", "time_retrieved": "2024-07-30T19:15:06.676595", "image_code": "// Fork of \"Imperfect optical system\" by michael0884. https://shadertoy.com/view/NlXGDX\n// 2021-06-08 21:46:15\n\nvec3 saturate(vec3 c)\n{\n    return tanh(pow(c,vec3(1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(saturate(acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 0.2;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = normalize(vec3(1))*1.01;\n        ca = aa2q( normalize(vec3(0,1,-0.3)), 1.17);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.001) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.5\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\n// basic parameters\nfloat R = 0.915;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.01;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n// Rayleigh extinction coefficients, \n// calculated for a nitrogen gas (polarizability 1.82e-30)\n// with temp 290 K, press 101300 Pa, wavelengths 655 (R), 540 (G) and 425 (B) nm,\n// and a scale of 1 unit = 6400 km (earth radius).\nvec3 beta =4.*vec3( 38.05, 82.36, 214.65 );\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n// a small absobtion in the orange band is added\n// to simulate the effect of ozone\nvec3 absorb = vec3( 0.75, 0.85, 1. );\t\t\t\n\n// devrived values\nfloat LN2 = 0.693147181;\nfloat H50;\nvec3 beta50;\nfloat invH50;\nfloat X50;\n\nvoid init()\n{\n   H50 = H * LN2;\n   beta50 = beta * LN2;\n   invH50 = 1. / H50;\n   X50 = R / H50;\n}\n// --------------------------------------------------------\n\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(1e10); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// --------------------------------------------------------\n\nfloat chapman( float X, float h, float coschi )\n{\n\t// this is the approximate Chapman function,\n\t// corrected for transitive consistency \n\n\tfloat c = sqrt( X + h );    \n    \n\tif( coschi >= 0. )\n\t{\t\n \t\treturn c / ( c * coschi + 1. ) * exp2( -h );\n\t}\n\telse\n\t{\n\t\tfloat x0 = sqrt( 1. - coschi * coschi ) * ( X + h );\n\t\tfloat c0 = sqrt( x0 );    \n\t\treturn 2. * c0 * exp2( X - x0 ) - c / ( 1. - c * coschi ) * exp2( -h );\n\t}\n}\n\n// --------------------------------------------------------\n\nvec3 transmittance( vec3 r, vec3 viewdir )\n{\n\t// a quick function to get the transmittance\n\t// looking from point r into infinity\n\n\tfloat rsq = dot(r,r);\n\tfloat invrl = inversesqrt( rsq );\n\tfloat len = rsq * invrl;\n\tfloat x = len * invH50;\n\tfloat h = x - X50;\n\tfloat coschi = dot( r, viewdir ) * invrl;\n\t\n\treturn beta50 * H50 * chapman( X50, h, coschi ) ;\n}\n\nfloat density(vec3 r)\n{\n\tfloat rsq = dot(r,r);\n\tfloat invrl = inversesqrt( rsq );\n\tfloat len = rsq * invrl;\n\tfloat x = len * invH50;\n\tfloat h = x - X50;\n    return exp2(-h);\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\nfloat scatterAnisotropy(vec3 ri, vec3 ro)\n{\n    return mix(1.0, 4.*PI*HenyeyGreenstein(0.5, dot(ri, ro)), 0.33) + HenyeyGreenstein(0.9995, dot(ri, ro));\n}\n\nvec3 scatter(vec3 r, vec3 rd, vec3 ld)\n{\n    return beta50*scatterAnisotropy(rd, ld)*density(r);\n}\n\nvec4 atmo(vec3 r, vec3 rd, float td)\n{\n    float inv = sign(dot(rd,normalize(r)));\n    float hit = 1.0;\n   \n    vec3 depth = inv*(transmittance(r, rd*inv) - transmittance(r + rd*td, rd*inv));\n    \n    return vec4(exp2(-max(depth, 0.0)), hit);\n}\n\nconst float samp = 16.0;\n\n//atmosphere illuminated by a sun\nvec3 atmo2(vec3 r, vec3 rd, float d, out vec3 vis, out vec3 inc)\n{\n    vec2 si0 = sphIntersect(r, rd, vec3(0), R + H*10.0);\n    \n    //range between the start of the atmosphere and end/surface\n    vec2 range = vec2(max(si0.x,0.0), min(si0.y, d));\n    float dr = range.y - range.x;\n    vec3 L = vec3(0.0);\n    float dx = 1.0/samp;\n    for(float t = 0.0; t <= 1.0; t+=dx)\n    {\n        float td = mix(range.x, range.y, t);\n        vec3 p = r + rd*td;\n        vec3 shadow = exp2(-transmittance(p, light));\n        vec4 cam = atmo(r, rd, td);\n        inc = shadow;\n        vec3 scattering = scatter(p, rd, light)*inc;\n        vis = cam.xyz;\n        L += vis*scattering*dx;\n    }\n    \n    return light_bright*L*dr;\n}\n", "buffer_b_code": "#define SPP 1\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n#define pi 3.14159265\n#define iterations 13\n\nvec3 function(vec3 x){\n    vec3 ca = vec3(0.722,0.918,1.000)*cos(x.xxx)+vec3(1.000,0.902,0.859)*cos(x.yyy);\n    vec3 cb = vec3(0.898,1.000,0.922)*cos(x.zzz*1.5);\n    return ca*cb-cb;\n}\n\nmat2 ROT(float ang)\n{\n    return mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n}\n\n#define SCALE 1.4\n#define SHIFT vec3(2.3, -5.2, 1.0)\n\nvec3 fractal(vec3 x){\n    x *= pi;\n    vec3 v = vec3(0.0);\n    float d = length(x);\n    x*=16.0;\n    float a = 1.5;\n    mat2 rmZ = SCALE*ROT(0.9);\n    mat2 rmX = SCALE*ROT(0.46);\n    for (int i = 0; i < iterations; i++){\n        vec3 F =function(x); \n        v += a*F;\n        x.xy = rmZ*x.xy;\n        x += 0.6*(F + F.zxy);\n        x.yz = rmX*x.yz;\n        x += SHIFT;\n        a /= 1.05;\n    }\n    return 50.*v*v*exp(-1000.*max(d - 3.0, 0.0));\n}\n\nvec2 map( in vec3 p )\n{\n    return vec2(length(fractal(p)),0.0);\n}\n\nvec3 normal(vec3 p) \n{\n    const float dx = 0.0012;\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  normalize(k.xyy*map(p + k.xyy*dx).x +\n                      k.yyx*map(p + k.yyx*dx).x +\n                      k.yxy*map(p + k.yxy*dx).x +\n                      k.xxx*map(p + k.xxx*dx).x + 0.0001);\n}\n\nbool trace(inout vec4 ro, vec3 rd)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float de = abs(map(ro.xyz).x); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de - 2.0*step(de, md)*md); \n        if(de < md) return true;\n        if(ro.w > MAX_DIST) return false;\n    }\n    return true;\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*pow2( pow2(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\nconst float aperture_size = 0.;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    vec2 apert_cent = -0.*uv;\n    \n    vec2 ap = aperture();\n    \n    if(!(distance(ap, apert_cent) < 1.0)) return false;\n    \n    float apd = length(ap);\n    \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1];\n    \n    ro = get(CamP).xyz + aperture_size*daperture;\n  \n    float focus =2.5 + 0.8*pow(apd,5.0);\n\n   \n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += rand2();\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    vec4 ro = vec4(cp,0.0);\n    vec3 fcol = vec3(0.0);\n    vec3 op = vec3(0.0);\n    \n    const float dt0 = 0.001;\n    ro += vec4(rd,1.0)*dt0*rand();\n    for(int i = 0; i < 96; i++)\n    {\n        vec3 d = fractal(ro.xyz);\n         \n        float dt = dt0 + 0.02*ro.w;\n        ro += vec4(rd,1.0)*dt;\n        op += d*dt;\n        \n        vec3 shadow = exp2(-transmittance(ro.xyz, light));\n        vec4 cam = atmo(cp, rd, ro.w);\n        vec3 inc = shadow;\n        vec3 scattering = (d + scatter(ro.xyz, rd, light))*inc;\n        vec3 vis = cam.xyz*exp(-op);\n        fcol += vis*scattering*dt;\n    }\n\n    return vec4(fcol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    init();\n   \n    //prev \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = vec4(0.0);\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 135, 135, 172], [174, 174, 231, 231, 346]], "test": "untested"}
{"id": "NtSGzy", "name": "Distance to Weighted Bezier", "author": "oneshade", "description": "Distance to a weighted \"rational\" quadratic bezier which is pretty much a parametrized conic (unweighted quadratic beziers form parabolas, a special case). It requires solving a quartic equation.", "tags": ["2d", "sdf", "distance", "quartic", "quadraticbezier", "weighted", "rationalbezier"], "likes": 12, "viewed": 700, "published": 3, "date": "1624113845", "time_retrieved": "2024-07-30T19:15:07.533304", "image_code": "/*\nDistance to a weighted \"rational\" quadratic bezier which\nis pretty much a parametrized conic (unweighted quadratic beziers\nform parabolas, a special case). It requires solving a quartic equation.\n\nI didn't know about this generalization until I saw this shader\nalso showing the distance to a rational bezier by @kajbostrom:\nhttps://www.shadertoy.com/view/stjGRh\n\nI learned a bit more about them from demofox's webpage: http://demofox.org/bezquadrational.html\nI'm working on simplifying and trying to increase the precision currently.\n\nBtw, the calculations turned out to have lots of patterns!\nDesmos graph of the workthrough: https://www.desmos.com/calculator/d68abzjzi9\n\nPython implementation: https://replit.com/@hathnoname/Euclidean-Distance-to-Weighted-Quadratic-Bezier#main.py\n*/\n\n// a, b, c: vec3(x, y, weight)\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nfloat sdWeightedBezier(in vec2 p, in vec3 a, in vec3 b, in vec3 c) {\n    // Weighted vertex positions\n    vec2 wa = a.xy * a.z, wb = b.xy * b.z, wc = c.xy * c.z;\n\n    // Conversion to power basis makes it less messy\n    vec2 p2 = wa - 2.0 * wb + wc, p1 = 2.0 * (wb - wa), p0 = wa;\n    float w2 = a.z - 2.0 * b.z + c.z, w1 = 2.0 * (b.z - a.z), w0 = a.z;\n\n    // Reused calculations\n    float  pp0 = dot(p,  p0),  pp1 = dot(p,  p1),  pp2 = dot(p,  p2);\n    float p0p0 = dot(p0, p0), p1p1 = dot(p1, p1), p2p2 = dot(p2, p2);\n    float p0p1 = dot(p0, p1), p0p2 = dot(p0, p2), p1p2 = dot(p1, p2);\n\n    float w0w0 = w0 * w0, w1w1 = w1 * w1, w2w2 = w2 * w2;\n    float w0w1 = w0 * w1, w0w2 = w0 * w2, w1w2 = w1 * w2;\n\n    // Quartic coefficients (t4*t^4 + t3*t^3 + t2*t^2 + t1*t + t0)\n    float t4 = w1 * p2p2 - w2 * p1p2 + w2w2 * pp1 - w1w2 * pp2;\n    float t3 = 2.0 * (w0 * p2p2 - w2 * p0p2  + w2w2 * pp0 - w0w2 * pp2) + w1w2 * pp1 - w1w1 * pp2 + w1 * p1p2 - w2 * p1p1;\n    float t2 = 3.0 * (w0 * p1p2 - w2 * p0p1) + 2.0 * (w1w2 * pp0 - w0w1 * pp2) + w0w2 * pp1 - w0w1 * pp2 + w1w2 * pp0 - w0w2 * pp1;\n    float t1 = 2.0 * (w0 * p0p2 - w2 * p0p0  + w0w2 * pp0 - w0w0 * pp2) + w1w1 * pp0 - w0w1 * pp1 + w0 * p1p1 - w1 * p0p1;\n    float t0 = w0 * p0p1 - w1 * p0p0 + w0w1 * pp0 - w0w0 * pp1;\n\n    // Solve and minimize\n    float d = min(dot2(p - a.xy), dot2(p - c.xy)); // Minimize at the boundaries (bezier end points)\n\n    t3 /= t4; t2 /= t4; t1 /= t4; t0 /= t4; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to t^4 + pt^2 + qt + r by substituting t-b/4a\n    // This can be found by substituting t+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float t3t3 = t3 * t3;\n    float dp = (8.0 * t2 - 3.0 * t3t3) / 8.0;\n    float dq = (8.0 * t1 - 4.0 * t2 * t3 + t3t3 * t3) / 8.0;\n    float dr = (256.0 * t0 - 64.0 * t1 * t3 + 16.0 * t2 * t3t3 - 3.0 * t3t3 * t3t3) / 256.0;\n\n    // Solve for a root to (x^2)^3 + 2p(x^2)^2 + (p^2 - 4r)(x^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * dp;\n    float rb =  dp * dp - 4.0 * dr;\n    float rc = -dq * dq;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    float x = sqrt(lambda); // Because we solved for x^2 but want x\n    float alpha = 2.0 * dq / x, beta = lambda + ra;\n\n    float u = 0.25 * t3;\n    x *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +x - u;\n        vec2 t = vec2(h + z, h - z);\n        if (t.x > 0.0 && t.x < 1.0) d = min(d, dot2(p - ((p2 * t.x + p1) * t.x + p0) / ((w2 * t.x + w1) * t.x + w0)));\n        if (t.y > 0.0 && t.y < 1.0) d = min(d, dot2(p - ((p2 * t.y + p1) * t.y + p0) / ((w2 * t.y + w1) * t.y + w0)));\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -x - u;\n        vec2 t = vec2(h + w, h - w);\n        if (t.x > 0.0 && t.x < 1.0) d = min(d, dot2(p - ((p2 * t.x + p1) * t.x + p0) / ((w2 * t.x + w1) * t.x + w0)));\n        if (t.y > 0.0 && t.y < 1.0) d = min(d, dot2(p - ((p2 * t.y + p1) * t.y + p0) / ((w2 * t.y + w1) * t.y + w0)));\n    }\n\n    return sqrt(d);\n}\n\n// Parametric definition of a rational quadratic bezier\n// I prefer to call it \"weighted\"\nvec2 weightedBezier(in vec3 a, in vec3 b, in vec3 c, in float t) {\n    a.xy *= a.z, b.xy *= b.z, c.xy *= c.z;\n    return mix(mix(a.xy, b.xy, t), mix(b.xy, c.xy, t), t) /\n           mix(mix(a.z, b.z, t), mix(b.z, c.z, t), t);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Control points with weights\n    float r = 0.5 * iTime;\n    vec2 anim = 0.1 * vec2(cos(r), sin(r));\n    vec3 a = vec3(-0.3 + anim.y, -0.2 + anim.x, 0.5);\n    vec3 b = vec3(0.2 * cos(iTime), 0.2 + 0.2 * sin(iTime), mix(-0.3, 3.0, 0.5 + 0.5 * cos(iTime)));//0.7 + cos(2.5 * iTime));\n    vec3 c = vec3(0.3 + anim.x, -0.2 + anim.y, 1.5);\n\n    // Set middle control point to the mouse position\n    // on mouse down\n    if (iMouse.z > 0.0) b.xy = mouse;\n\n    float dist = sdWeightedBezier(uv, a, b, c);\n\n    // Trying a slightly different style\n    vec3 color = vec3(0.0);\n    color += (0.6 + 0.4 * sin(dist * 300.0)) * vec3(1.0, 0.5, 0.6);\n    color *= clamp(pow(3.0 * dist, 0.4), 0.0, 1.0);\n\n    // Hull\n    drawSDF(sdLine(uv, a.xy, b.xy) - 0.002, vec3(0.0, 0.0, 1.0));\n    drawSDF(sdLine(uv, b.xy, c.xy) - 0.002, vec3(0.0, 0.0, 1.0));\n\n    // Curve\n    drawSDF(dist - 0.003, vec3(1.0));\n\n    // Testing\n    //vec2 prev = a.xy;\n    //float tStep = 0.01;\n    //for (float t=0.0; t < 1.0; t += tStep) {\n    //    vec2 cur = weightedBezier(a, b, c, t);\n    //    drawSDF(sdLine(uv, prev, cur) - 0.003, vec3(0.0, 1.0, 0.0));\n    //    prev = cur;\n    //}\n\n    // Draw control points\n    drawSDF(length(uv - a.xy) - 0.013, vec3(1.0, 1.0, 0.0));\n    drawSDF(length(uv - b.xy) - 0.013, vec3(1.0, 0.0, 0.0));\n    drawSDF(length(uv - c.xy) - 0.013, vec3(1.0, 1.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "/* Backup (I'm paranoid about making mistakes ;))\n// Quartic solver I made here: https://www.shadertoy.com/view/fsB3Wt\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d - 0.5 * b * c + 0.125 * bb * b;\n    float r = e - 0.25 * b * d + bb * c / 16.0 - 3.0 * bb * bb / 256.0;\n    int n = 0;\n\n    // Solve for an arbitary root to x^3 + 2px^2 + (p^2 - 4r)x - q^2\n    // I really want to use my simpler solver but it has worse precision :(\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    // Solve two quadratic equations factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * b;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        roots.xy = (vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs;\n        n += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 others = (vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs;\n        if (n > 0) roots.zw = others;\n        else roots.xy = others;\n        n += 2;\n    }\n\n    return n;\n}\n\n// a, b, c: vec3(x, y, weight)\nfloat sdWeightedBezier(in vec2 p, in vec3 a, in vec3 b, in vec3 c) {\n    // Weighted vertex positions\n    vec2 wa = a.xy * a.z, wb = b.xy * b.z, wc = c.xy * c.z;\n\n    // Conversion to power basis makes it less messy\n    vec2 p2 = wa - 2.0 * wb + wc, p1 = 2.0 * (wb - wa), p0 = wa;\n    float w2 = a.z - 2.0 * b.z + c.z, w1 = 2.0 * (b.z - a.z), w0 = a.z;\n\n    // Reused calculations\n    float  pp0 = dot(p,  p0),  pp1 = dot(p,  p1),  pp2 = dot(p,  p2);\n    float p0p0 = dot(p0, p0), p1p1 = dot(p1, p1), p2p2 = dot(p2, p2);\n    float p0p1 = dot(p0, p1), p0p2 = dot(p0, p2), p1p2 = dot(p1, p2);\n\n    float w0w0 = w0 * w0, w1w1 = w1 * w1, w2w2 = w2 * w2;\n    float w0w1 = w0 * w1, w0w2 = w0 * w2, w1w2 = w1 * w2;\n\n    // Quartic coefficients (t4*t^4 + t3*t^3 + t2*t^2 + t1*t + t0)\n    float t4 = w1 * p2p2 - w2 * p1p2 + w2w2 * pp1 - w1w2 * pp2;\n    float t3 = 2.0 * (w0 * p2p2 - w2 * p0p2  + w2w2 * pp0 - w0w2 * pp2) + w1w2 * pp1 - w1w1 * pp2 + w1 * p1p2 - w2 * p1p1;\n    float t2 = 3.0 * (w0 * p1p2 - w2 * p0p1) + 2.0 * (w1w2 * pp0 - w0w1 * pp2) + w0w2 * pp1 - w0w1 * pp2 + w1w2 * pp0 - w0w2 * pp1;\n    float t1 = 2.0 * (w0 * p0p2 - w2 * p0p0  + w0w2 * pp0 - w0w0 * pp2) + w1w1 * pp0 - w0w1 * pp1 + w0 * p1p1 - w1 * p0p1;\n    float t0 = w0 * p0p1 - w1 * p0p0 + w0w1 * pp0 - w0w0 * pp1;\n\n    // Solve\n    vec4 roots;\n    int nroots = solveQuartic(t4, t3, t2, t1, t0, roots);\n\n    // Minimize distance (todo: avoid checking unecessary roots)\n    vec2 ta = p - a.xy, tc = p - c.xy;\n    float d = min(dot(ta, ta), dot(tc, tc));\n    for (int n=0; n < nroots; n++) {\n         float t = roots[n];\n         if (t > 0.0 && t < 1.0) {\n             vec2 to = p - ((p2 * t + p1) * t + p0) / ((w2 * t + w1) * t + w0);\n             d = min(d, dot(to, to));\n         }\n    }\n\n    return sqrt(d);\n}\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSGzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[790, 821, 844, 844, 864], [865, 865, 889, 889, 932], [933, 933, 1001, 1034, 4735], [4737, 4827, 4893, 4893, 5053], [5055, 5055, 5102, 5102, 5210], [5292, 5292, 5347, 5347, 6934]], "test": "untested"}
{"id": "Nlj3Dm", "name": "Jelly Character", "author": "propagant", "description": "Raymarched jelly/bloby character. Another practice shader and just for fun...", "tags": ["raymarching", "cartoon", "character", "toon"], "likes": 5, "viewed": 329, "published": 3, "date": "1624102488", "time_retrieved": "2024-07-30T19:15:08.284296", "image_code": "//Raymarched random jelly character by Matej Vanco, 2021\n\n#define ITER 64\n#define MAXD 64.0\n#define SURD 0.005\n#define BGC vec3(0.45,0.24,0.1) * 4.\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define noise(p, a, s, d) cos(-p * a + iTime * s) * d;\n\n\nstruct ray\n{\n    vec3 o,d;\n    float l;\n};\n\n//Iq's smooth opu\nvec4 opu(vec4 a, vec4 b, float s)\n{\n    float k = s;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, d1, h ) - k*h*(1.0-h));\n}\n\n//Iq's smooth ops\nvec4 ops(vec4 a, vec4 b, float s)\n{\n    float k = s;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, -d1, h ) + k*h*(1.0-h));\n}\n\n//Full geometry generation\nvec4 geo(vec3 p)\n{\n    p.x += noise(p.x, 39.,6.0,0.003);\n    p.y = p.y + sin(iTime * 1.5) * 0.05;\n    vec3 objCenter = vec3(0.,0.,1.0);\n    //---head\n    vec3 headCenter = objCenter + vec3(0.,0.32,-0.03);\n    vec4 s0 = vec4(vec3(.45,.34,.1), length(p - headCenter) - 0.1);\n    //mouth\n    vec4 b0 = vec4(vec3(.45,.14,.1)*0.5, length(max(abs(vec3(p.xy * rot(25.), p.z) - headCenter - vec3(0.15, -.03, -.1)) - vec3(0.12,cos(iTime * 1.5) * 0.015,.08),0.0))-0.02);\n    vec4 s0b0 = ops(b0,s0,0.05);\n\n    //---body\n    //center\n    vec4 b1 = vec4(vec3(.45,.26,.1), length(max(abs(p - objCenter - vec3(0., .0, .0)) - vec3(0.15,.2,.1),0.0))-0.01);\n    //r-l subtracted curves\n    vec4 b2 = vec4(vec3(-0.2), length(max(abs(vec3(abs(p.x),p.yz) - objCenter - vec3(0.6, -0.3, 0.0)) - vec3(0.2,.2,.1),0.0))-0.25);\n    vec4 b1b2 = ops(b2,b1,0.15) + noise(p.y, -38.,8.0,0.001);\n    //lHand\n    vec4 b3 = vec4(vec3(.45,.34,.1), length(max(abs(vec3(p.xy * rot(-35.),p.z) - objCenter - vec3(-0.215, .01, -.02)) - vec3(0.001,.1,.001),0.0))-0.05);\n    vec4 b4 = vec4(vec3(.45,.29,.1)*0.9, length(max(abs(vec3(p.xy * rot(-94.1),p.z) - objCenter - vec3(0.25, -.12, -.02)) - vec3(0.001,.07,.001),0.0))-0.03);\n    //rHand\n    vec4 b5 = vec4(vec3(.45,.34,.1), length(max(abs(vec3(p.xy * rot(-30.7),p.z) - objCenter - vec3(-0.24, -.08, -.02)) - vec3(0.001,.1,.001),0.0))-0.05);\n    vec4 b6 = vec4(vec3(.45,.29,.1)*0.9, length(max(abs(vec3(p.xy * rot(30.5),p.z) - objCenter - vec3(-0.18, .1, -.04)) - vec3(0.001,.07,.001),0.0))-0.03);\n    \n    //---legs\n    vec4 b7 = vec4(mix(vec3(.85,.54,.0), vec3(0.25,0.14,0.1), smoothstep(p.x+0.1 ,-0.25,0.01)), length(max(abs(p - objCenter - vec3(0.06, -.38, .0)) - vec3(0.015,.05,.05),0.0))-0.005) + \n    noise(p.y, -38.8,12.5,0.008);\n    vec4 b8 = vec4(vec3(.85,.1,.1)*2., length(max(abs(p - objCenter - vec3(-0.06, -.38, .0)) - vec3(0.015,.05,.05),0.0))-0.005) + \n    noise(p.y, -32.8,12.5,0.008);\n    \n    //---body joints\n    vec4 Lhand = opu(b4,b3,.05);\n    vec4 Rhand = opu(b5,b6,.05);\n    vec4 legs = opu(b7,b8,0.2);\n    \n    //---body connection\n    vec4 hands = opu(Rhand,Lhand,.05);\n    vec4 body = opu(b1b2,hands,.05);\n    vec4 full = opu(body, legs,.2);\n    \n    return opu(s0b0,full,0.05);\n}\n\n//Normals generation\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001,0.);//slight offset\n    float c = geo(p).w;\n    return normalize(c - vec3(geo(p - o.xyy).w, geo(p - o.yxy).w, geo(p - o.yyx).w));\n}\n\n//Simples lighting + BlinnPhong specs\nfloat light(vec3 p)\n{\n    vec3 LP = vec3(0.2,0.5,0.5);\n    vec3 lp = normalize(LP - p);\n    vec3 n = normal(p);\n    \n    float l = clamp(dot(n,lp),0.25,1.);\n    float s = pow(max(dot(n,lp),0.),80.)*3.0;\n    \n    return pow(l + s,0.25);\n}\n\n//Raymarching core\nvec4 march(ray r)\n{\n    vec3 c = vec3(0.);\n    for(int i = 0; i < ITER; i++)\n    { \n        if(r.l > MAXD ) \n        {\n            c = BGC * 2.;\n            break;\n        }\n        vec3 p = r.o + r.d * r.l;\n        vec4 g = geo(p);\n        if(g.w < SURD) \n        {\n            c = g.rgb * 2.5;\n            break;\n        }\n        r.l += g.w;\n    }\n    return vec4(c, r.l);\n}\n\n//Output img\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    ray r = ray(vec3(0.),vec3(uv,1.0),0.);\n    vec4 m = march(r);\n    vec3 p = r.o + r.d * m.w;\n    vec3 col = vec3(m.rgb) * light(p);\n\n    fragColor = vec4(col,1.0) + 0.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlj3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 322, 357, 357, 538], [540, 558, 593, 593, 775], [777, 804, 822, 822, 3021], [3023, 3044, 3065, 3065, 3221], [3223, 3261, 3282, 3282, 3498], [3500, 3519, 3538, 3538, 3896], [3898, 3911, 3968, 3968, 4214]], "test": "untested"}
{"id": "7lBGzG", "name": "iChannel texture - 002", "author": "catafest", "description": "In the last example: https://www.shadertoy.com/view/NlBGWD I created a surface with a texture by IChannel inputs.\nNow, I add a sphere distortion and sphere distortion with movement.", "tags": ["texture", "sphere", "ichannel"], "likes": 1, "viewed": 451, "published": 3, "date": "1624101203", "time_retrieved": "2024-07-30T19:15:09.045262", "image_code": "#define PI 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // get poins \n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    // set surface formula\n    vec3 v = vec3(p.x, p.y, sqrt(1.0 - p.x * p.x - p.y * p.y));\n    // create normals \n    vec3 n = normalize(v);\n    \n    // https://en.wikipedia.org/wiki/Distortion_(optics)\n    vec2 sphere_distortion = vec2(atan(n.z, n.x) / PI,0.00000001 * p.y);\n\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    \n    \n    if (uv.x > 0.0 && uv.x < 0.5)\n    {\n   \t\t//color = texture(iChannel0, vec2(1.0 - (uv.x/0.5),uv.y/0.5)+ sphere_distortion);\n        // with movement iTime\n        color = texture(iChannel0, vec2(iTime * 1.0 - (uv.x/0.5),uv.y/0.5)+ sphere_distortion);\n    } \n    else if (uv.x > 0.5 && uv.x < 1.0) \n    { \n        //color = texture(iChannel1, vec2((uv.x/0.5),uv.y)+ sphere_distortion);\n        // with movement iTime\n        color = texture(iChannel0, vec2(iTime -(uv.x/0.5),uv.y)+ sphere_distortion);\n        \n    } \n\tfragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 1076]], "test": "untested"}
{"id": "7tBGRG", "name": "大龙猫 - Quicky#055", "author": "totetmatt", "description": "Acheivement : Knowing orbital camera :) ", "tags": ["quicky"], "likes": 4, "viewed": 245, "published": 3, "date": "1624097428", "time_retrieved": "2024-07-30T19:15:09.936878", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,fragCoord/iResolution.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec3 p,vec3 b){\n    vec3 q=  abs(p)-b;\n     return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n  }\n  float diam(vec3 p,float s){\n     p = abs(p);\n     return (p.x+p.y+p.z-s)/sqrt(1./3.);    \n   }\nvec2 sdf(vec3 p){\n  vec3 pp = p;\n  vec2 h;\n  p.x = abs(p.x)-1.5;\n  p.zy *=rot(p.x*.785*.1);\n\n  pp.xy *=rot(pp.z*.01);\n  \n  p= abs(p)-.5-pow(fract(fGlobalTime*2.),2.)*2.;\n  for(float i=0.;i<4.;i++){\n    p = abs(p)-.2;\n    p.xz*=rot(.785*i);\n    }\n  h.x = box(p,vec3(1.));\n  h.x = abs(h.x)-.05;\n  h.x = .8*max(h.x,dot(p,vec3(0.,1.,-0.+sin(floor(fGlobalTime*8.+p.z*.785)))-.1));\n  h.x = min(h.x,diam(pp,2.1));\n  h.y =1.;\n    \n  vec2 t;\n    pp.y = abs(pp.y);\n    t.x= dot(pp,normalize(vec3(.0,-1.,0.)))+5.+texture(iChannel1,pp.xz*.005+fGlobalTime*.1).r*2.;\n    t.y =2.;\n    h = t.x < h.x ? t:h;\n  return h;\n}\n#define q(s) s*sdf(p+s).x\nvec2 nv=vec2(-.01,.01);\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.0,.4,.6)));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\nvec2 puv = uv;\n  \n  vec3 ro=vec3(0.+sin(fGlobalTime)*10.,sin(fGlobalTime)*5.,+cos(fGlobalTime)*8.);\n  vec3 rt = vec3(0.,0.+sin(fGlobalTime*.4)*1.,0.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = cross(z,vec3(0.,1.,0.));\n  vec3 y = cross(z,x);\n  \n  \n  \n  vec3 rd=normalize(vec3(uv,1.));\n  rd = normalize(mat3(x,y,z)*vec3(uv,1.));\n  vec3 rp=ro;\n  vec3 light= vec3(1.,2.,-3.);\n  float i=0.;\n  vec3 col = vec3(.1);\n\tvec3 acc = vec3(0.);\n  for(i=0.;i<=69.;i++){\n      vec2 d= sdf(rp);\n    if(d.y == 1.){\n    acc +=vec3(1.)*exp(fract(fGlobalTime*4.)*50.*-abs(d.x))/9.;\n      d.x = max(0.05,abs(d.x));\n    }\n      rp+=d.x*rd;\n      if(d.x<=0.001){\n        vec3 n = norm(rp);\n        col = vec3(1.,1.0,1.0)*max(0.,dot(normalize(light-rp),n));\n           break;\n        }\n  }\n  puv *=1.+sin(fGlobalTime)*.1;\n  puv = (puv* vec2(iResolution.y / iResolution.x, 1))+.5;\n  vec4 pcol = texture(iChannel0,puv);\n  col = mix(col,pcol.rgb*pal(pcol.a+floor(fGlobalTime*4.)/4.),pcol.a);\n  col+=acc; \n\n \n    fragColor  = vec4(col,i/(69.*1.2));\n    \n    \n    \n}", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 82, 151]], "test": "untested"}
{"id": "flS3zy", "name": "cloud in a bubble", "author": "bloodnok", "description": "experimenting with atmospheric scattering.", "tags": ["raytracing", "cloud", "atmosphere"], "likes": 21, "viewed": 807, "published": 3, "date": "1624096718", "time_retrieved": "2024-07-30T19:15:10.981086", "image_code": "#define PI 3.1415927\n/*\n\t@geofftnz\n\n\tforking someone's raytraced sphere in order to do some material testing.\n    atmospheric scattering attempt.\n    \n    Basic idea:\n    Ray traced sphere, ray march through interior.\n    Accumulate Mie+Rayleigh scattering\n    Accumulate air and cloud density.\n    At each point on the primary ray march, do a secondary ray march towards the light source to calculate amount of light reaching point.\n    \n    Full of bugs & fudge factors.\n\n*/\n// atmospheric scattering specifics\n\n// Rayleigh absorbtion constant. Controls how different frequencies are scattered. Makes the sky blue.\nvec3 Kr = vec3(0.1287, 0.2698, 0.7216);\n\n// Mie scattering\nfloat miePhase = 0.9;\nfloat mieAmount = 0.01;\n\n// Rayleigh scattering\nfloat ralPhase = -0.01;\nfloat rayleighAmount = 0.9;  // how blue is your sky?\n\nfloat absorbCoeff = 0.7;  // how much the air absorbs light.\nfloat cloudScatter = 20.0;  // amount of omni-directional scatter off clouds.\nfloat cloudAbsorbFactor = 20.0;  // attenuation by clouds.\nfloat cloudMie = 100.0; // amount of Mie scattering by clouds\n\nfloat airDensityBase = 0.2;\n\nvec3 lightcol = vec3(10.0,9.0,8.0);\n\nvec4 sph1 = vec4 (0.0,0.0,0.0,1.0);\n\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n// credit: iq/rgba\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(in vec3 x)\n{\n\tfloat i = 1.0;\n\t\n\tfloat n = noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n\tn+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n\n\treturn n;\n}\n\n//------------------------------------------------------------------------------\n// Colour space transform\n//------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Academy_Color_Encoding_System#Converting_ACES2065-1_RGB_values_to_CIE_XYZ_values\nvec3 RGBtoXYZ(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(0.9525523959,0.3439664498,0.0),\n        \tvec3(0,0.7281660966,0.0),\n        \tvec3(0.0000936786,-0.0721325464,1.0088251844)\n        );\n    return x * col;\n}\n\nvec3 XYZtoRGB(vec3 col)\n{\n    const mat3 x = mat3(\n        \tvec3(1.0498110175,-0.4959030231,0.0),\n        \tvec3(0.0,1.3733130458,0.0),\n        \tvec3(-0.0000974845,0.0982400361,0.9912520182)\n        );\n    return x * col;\n}\n\n\n//============================================================\n// credit: demofox https://www.shadertoy.com/view/4tyXDR\n#define OBJECT_REFLECTIVITY 0.0 // How reflective the object is. regardless of fresnel.\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return 1.0;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n    // adjust reflect multiplier for object reflectivity\n    ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n    return ret;\n}\n\n\n\nfloat pointRayDistance(vec3 ro, vec3 rd, vec3 p)\n{\n\tvec3 u = p-ro;\n\tfloat cosvu = dot(rd,u);\n\tif (cosvu<0.0) return length(p-ro);\n\tvec3 puv = rd * (cosvu / length(rd));\n\tvec3 qq = ro + puv;\n\treturn length(p-qq);\n}\n\n// intersection through participating media (like atmospheres)\nstruct iMediaIntersection\n{\n    float tnear;   // first intersection\n    float tfar;    // last intersection\n    uint mnear;    // material first hit (atmosphere?)\n    uint mfar;     // material on second hit (atmosphere or ground)\n    vec3 nor;      // normal at first intersection\n};\n\n\n// intersect ray ro+rd with sphere sph, calculates both entry and exit points.\niMediaIntersection mSphere(in vec3 ro, in vec3 rd, in vec4 sph){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.tfar = -1.0;\n    res.mnear = 0u;\n    res.mfar = 0u;\n    \n    // sphere intersection\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n    \n\tif (h >= 0.0)\n    {\n        float hsqrt = sqrt(h);\n        res.tnear = (-b - hsqrt) / 2.0;\n        res.mnear = 1u;  // atmospheric hit\n        \n        res.nor = normalize(ro + rd * res.tnear - sph.xyz);\n        \n        res.tfar = (-b + hsqrt)/2.0;\n        res.mfar = 1u;  // atmospheric exit\n    }\n\n    return res;\n}\n\n\n\nfloat iSphere (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b - sqrt(h))/2.0;\n\treturn t;\n}\n\nfloat iSphere2 (in vec3 ro, in vec3 rd, in vec4 sph){\n\t//a sphere centered at the origin has eq: |xyz| = r\n\t//meaning, |xyz|^2 = r^2, meaning <xyz,xyz> = r^2\n\t// now, xyz = ro + t*rd, therefore |ro|^2 + t^2 + 2<ro,rd>t - r^2 = 0\n\t// which is a quadratic equation. so\n\tfloat r = sph.w; //radius\n\tvec3 oc = ro - sph.xyz; //origin = position sphere\n\tfloat b = 2.0*dot(oc,rd);\n\tfloat c = dot(oc,oc)-r*r;\n\tfloat h = b*b - 4.0*c;\n\tif (h <0.0) return -1.0;\n\tfloat t = (-b + sqrt(h))/2.0;\n\treturn t;\n}\n\nvec3 nSphere (in vec3 pos, in vec4 sph){\n\treturn (pos - sph.xyz) / sph.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd){\n\t//eq. of a plane, y=0 = ro.y + t*rd.y\n\treturn -ro.y/rd.y;\n}\n\nvec3 nPlane( in vec3 pos){\n\treturn vec3(0.0,1.0,0.0);\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT){\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere (ro, rd, sph1); //intersect with sphere\n\tfloat tpla = iPlane (ro,rd); //intersect with plane\n\tif (tsph > 0.0){\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\tif (tpla > 0.0 && tpla < resT){\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t}\n\treturn id;\n}\n\n\niMediaIntersection mediaIntersect( in vec3 ro, in vec3 rd){\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.mnear = 0u;\n    res.tfar = -1.0;\n    res.mfar = 0u;\n    \n    iMediaIntersection res2 = mSphere(ro,rd,sph1);\n    res = res2;\n    \n    return res;\n}\n\n\n// mie/rayleigh phase - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\n// sensible g: mie:0.97, ral:-0.01\nfloat phase(float alpha, float g){\n    float gg = g*g;\n    float a = 3.0*(1.0-gg);\n    float b = 2.0*(2.0+gg);\n    float c = 1.0+alpha*alpha;\n    float d = pow(1.0+gg-2.0*g*alpha, 1.5);\n    return (a/b)*(c/d);\n}\n\n// exponential absorbtion - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\nvec3 absorb(float dist, vec3 col, float f)\n{\n    vec3 c = col;    \n    c *= (vec3(1.0) - pow(Kr, vec3(f / max(dist,0.0000000001))));\n    //c *= (vec3(1.0) - pow(vec3(0.05,0.7,0.9), vec3(f / max(dist*0.5,0.0000000001))));\n    //c *= (vec3(1.0) - pow(vec3(0.01,0.85,0.9), vec3(f / max(dist*0.1,0.0000000001))));\n    return c;\n}\n\nfloat cloudAbsorb(float cloud)\n{\n    return exp(-cloud * cloudAbsorbFactor);\n}\n\nfloat airDens(vec3 pos){\n    \n    //return 5.0 * exp(-7.0 * alt) * (1.0-alt);  // last factor is lies, but makes sure we end at 0.0 at edge of atmosphere\n    return airDensityBase;\n}\n\n// calculate cloud density\nfloat cloud(vec3 pos){\n\n    vec3 pos2 = pos - sph1.xyz;\n    float density = 1.0-smoothstep(0.2,0.9,dot(pos2,pos2));\n\n    pos += vec3(17.3,6.9,0.19) * iTime * 0.002;\n    \n    //return smoothstep(0.8,1.2,fbm(pos*2.0))*max(0.0,fbm(pos*2.0)-1.0);\n    return max(0.0,(fbm(pos*2.3)* density)-0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    Kr = RGBtoXYZ(Kr);\n\n\tvec3 light = normalize( vec3(0.5,1.0,0.5));\n\t//uv are the pixel coordinates, from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec2 p = fragCoord.xy/iResolution.xy;\n\tp = -1.0 + 2.0*p;\n\tp.x *= iResolution.x/iResolution.y;\n\n\n    vec3 mse = iMouse.xyz;\n    if (mse.z <= 0.0){  // default view\n        mse.x = iResolution.x * 0.5;\n        mse.y = iResolution.y * 0.5;\n    }\n\n    // turn mouse into spherical coords\n\tvec2 nMouse = (mse.xy / iResolution.xy)* PI;\n\tfloat th = nMouse.y; \n\tfloat ph = -nMouse.x * 2.0;\n    \n   \n\n\t//vec3 ro = vec3(0.0,1.1,2.0); //camera position\n    vec3 ro;\n    float camdist = 2.0;\n\tro.x = sin(th) * cos(ph) * camdist;\n\tro.z = sin(th) * sin(ph) * camdist;\n\tro.y = cos(th) * camdist;\n\n\n\tvec3 lookAt = sph1.xyz;\n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(vec3(0,1,0), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd0 = normalize(front*1.5 + left*p.x + up*p.y); // rect vector\n\n    /*\n\tlight.x = sin(th) * cos(ph);\n\tlight.z = sin(th) * sin(ph);\n\tlight.y = -cos(th);\n\tlight = normalize(light);\n    */\n    light = normalize(vec3(1.0,1.0,1.0));\n\t\n    iMediaIntersection hit = mediaIntersect(ro,rd0);\n\n\tvec3 col = vec3(0.0);\n    float airDensity = 0.0;\n    float cloudDensity = 0.0;\n    float cloudAttenuation = 1.0;\n    \n\t\n\tif (hit.tnear > 0.0){\n    \n    \n\t\tvec3 pos = ro + hit.tnear*rd0;\t//hit position\n        \n        // calculate new ray direction based on refraction\n        vec3 rd = refract(rd0,hit.nor,1.0/1.05);\n        col = texture(iChannel0,rd).rgb * 0.25;\n    \n        if (hit.mnear == 1u){  // atmospheric hit\n        \n            // setup scattering            \n            float mie = phase(dot(rd,light),miePhase) * mieAmount; // relative amount of Mie scattering.\n            float rayleigh = phase(dot(rd,light),ralPhase) * rayleighAmount; // relative amount of Rayleigh scattering.\n                \n            // step through atmosphere, cast rays to lightsource to determine shadow.\n            float litDensity = 0.0;\n            float dt = (hit.tfar - hit.tnear) * 0.04;\n            float hh = hash(iTime + dot(rd+ro,vec3(12.65898,37.3516781,17.651651)));  // add a little noise to the start of the ray traversal so smooth out banding.\n            \n            vec3 mieAccum = vec3(0.0);\n            vec3 rayleighAccum = vec3(0.0);\n            vec3 cloudAccum = vec3(0.0); // scatter from clouds\n            vec3 totalInflux = vec3(0.0);\n            \n            // raymarch through sphere:\n            // - calculate cumulative absorption\n            // - calculate influx at each point\n            //   - raymarch towards sun & repeat above process.\n            \n            for(float t = hit.tnear + hh * 0.01; t<hit.tfar-0.00001; t+=dt){\n            \n                vec3 apos = ro + rd * t;  // position along atmosphere ray\n                \n                float stepCloudDensity = cloud(apos) * dt;\n                cloudDensity += stepCloudDensity; // total cloud density along path\n                                \n                float stepDensity = airDens(apos) * dt;  // calculates amount of air for this step\n                \n                airDensity += stepDensity;  // total air density from viewer to point\n                \n                //vec3 influx = lightcol;  // incoming light (todo: calculate this)\n                vec3 influx = vec3(0.0);\n                \n                // do another raycast towards the sun\n                float tsun = iSphere2(apos, light, sph1); // cast ray to sun, intersect with inner edge of sphere\n                float dtl = tsun * 0.1; // keep it rather chunky, don't want to bog down\n                float airToSun = 0.0;\n                float cloudToSun = 0.0;\n                float hh2 = hash(iTime + dot(apos,vec3(12.65898,37.3516781,17.651651)));\n\n                for (float tl = hh2 * 0.1; tl < tsun; tl += dtl){\n                    \n                    vec3 spos = apos + light * tl;\n                    cloudToSun += cloud(spos) * dtl;  // acumulate cloud density\n                    airToSun += airDens(spos) * dtl;\n                }\n                \n                influx = absorb(airToSun,lightcol,absorbCoeff) * cloudAbsorb(cloudToSun); \n                \n                cloudAttenuation = cloudAbsorb(cloudDensity); //1.0 / (1.0 + cloudDensity * cloudAbsorb);\n                \n                rayleighAccum += absorb(airDensity,influx * Kr * rayleigh * stepDensity,absorbCoeff) * cloudAttenuation;\n                \n                // mie from air + cloud\n                \n                //mieAccum += absorb(airDensity,influx * (cloudScatter*dt+mie) * stepCloudDensity,absorbCoeff) * cloudAttenuation;  // original              \n                //mieAccum += absorb(airDensity,influx * mie * ((cloudScatter*dt) + stepCloudDensity),absorbCoeff) * cloudAttenuation;  // broken?\n                mieAccum += absorb(airDensity,influx * (mie * (stepDensity + stepCloudDensity*cloudMie) + (cloudScatter*stepCloudDensity)),absorbCoeff) * cloudAttenuation;\n            }\n        \n            \n            col += mieAccum;\n            col += rayleighAccum;\n            \n            // sun disc\n            float mie_eye = phase(dot(rd,light),0.9995) * 0.001; // relative amount of Mie scattering.\n            col += absorb(airDensity,lightcol,absorbCoeff) * mie_eye * cloudAttenuation;\n            \n            // add some fresnel reflection\n            vec3 refl = reflect(rd,hit.nor);\n            float reflAmount = FresnelReflectAmount(1.0,1.5,hit.nor,rd);\n            col = col * (1.0-reflAmount) + texture(iChannel1,refl).rgb * reflAmount;\n            \n\n        }\n\n\t}else{\n        col = texture(iChannel0,rd0).rgb;\n        col += lightcol * phase(dot(rd0,light),0.9995) * 0.001; // relative amount of Mie scattering.\n\t}\n\n\n    // fake some sun glow (bloom / mie scattering in eye?)\n    //float mie_eye = phase(dot(rd0,light),0.9995) * 0.001; // relative amount of Mie scattering.\n    //col += absorb(airDensity,lightcol,absorbCoeff) * mie_eye * cloudAttenuation;\n    \n\n\n// reinhardt HDR tonemapping\n\tfloat whitelevel = 5.0;\n\tcol = (col  * (vec3(1.0) + (col / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + col);\t\n\n// ACES to RGB\n    col = XYZtoRGB(col);\n\n// gamma\t\n\tcol = pow(col,vec3(1.0/2.0));\n\n\t\n\tfragColor = vec4(col,1.0);\n\t\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1192, 1192, 1212, 1212, 1284], [1286, 1286, 1306, 1306, 1386], [1388, 1407, 1430, 1430, 1469], [1472, 1491, 1517, 1517, 1919], [1922, 1922, 1944, 1944, 2183], [2374, 2488, 2513, 2513, 2707], [2709, 2709, 2734, 2734, 2931], [3142, 3142, 3219, 3247, 3757], [3761, 3761, 3811, 3811, 3974], [4327, 4406, 4470, 4470, 5095], [5099, 5099, 5151, 5364, 5591], [5593, 5593, 5646, 5859, 6086], [6088, 6088, 6128, 6128, 6163], [6165, 6165, 6202, 6241, 6263], [6265, 6265, 6291, 6291, 6320], [6323, 6323, 6380, 6380, 6654], [6657, 6657, 6716, 6716, 6922], [6925, 7069, 7103, 7103, 7280], [7282, 7395, 7439, 7439, 7720], [7722, 7722, 7754, 7754, 7800], [7802, 7802, 7826, 7955, 7984], [7986, 8013, 8035, 8035, 8306], [8308, 8308, 8365, 8365, 14672]], "test": "untested"}
{"id": "NtS3zy", "name": "average of x last random values", "author": "FabriceNeyret2", "description": "average of the x last random values.", "tags": ["hash", "rand", "statistics"], "likes": 10, "viewed": 252, "published": 3, "date": "1624094094", "time_retrieved": "2024-07-30T19:15:11.903619", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    O = vec4( T(vec2(U.x,8)) > U.y/R.y ); // display curve in row 8\n    \n    if ( int(U.y) == int(R.y)/2 ) O = vec4(O.r>0., 0, O.r<1., 0); // y=0 axis\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define hash(p)  fract(sin( (p)* 78.233 ) * 43758.5453 )\n\nfloat M(float l) { // average of stored random values #0..#int(l)\n    float s = 0.;\n    for( float i=0.; i < l; i++ )\n        s += T(vec2(i,0));\n    return s/ceil(l);\n}\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.x = U.y == .5\n          ? U.x == .5   ? hash(iTime)     // row 0: history of random values\n                        : T(U-vec2(1,0))  //     compute first, then scroll\n          : U.y == 8.5  ? M(U.x)          // row 8: average values #0..x\n                        : 0.;             //     NB: 8 for better parallelism\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0).x", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3zy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 220]], "test": "untested"}
{"id": "NtB3Ry", "name": "Vornoi CELLS", "author": "Sp3cim4n", "description": "vornoi distribution", "tags": ["noise", "vornoi"], "likes": 2, "viewed": 237, "published": 3, "date": "1624082758", "time_retrieved": "2024-07-30T19:15:12.775289", "image_code": "\n#define SEED_FIXED 39.3\n#define SEED_ANIMATED floor(iTime + 39.0)\n#define SEED SEED_ANIMATED\n\n#define POINT_COUNT 50\n#define VISUALIZE_POINT true\n#define VERY_LARGE_NUMBER 999999999.\n\n\n\n\n\nfloat fit01(float val, float a, float b)\n{\n    return a+val*(b-a);\n}\n\nvec2 fit01(vec2 val, float a, float b)\n{\n    return vec2(fit01(val.x,a,b), fit01(val.y,a,b));\n}\n\n\n\n\n\n//bad rng..\nfloat r11(float seed)\n{\n    return fract(sin(499.0*seed + 199.0)*5869.0);\n}\n\nvec2 r12(float seed)\n{\n    float x = fract(sin(509.0*seed)*197.0);\n    float y = fract(sin(487.0*seed + 991.0)*991.0);\n    return vec2(x,y);\n}\n\nvec3 r13(float seed)\n{   \n    float x = fract(sin(277.0*seed)*613.0);\n    float y = fract(sin(97.0*seed + 607.0)*394.0);\n    float z = fract(sin(349.0*seed + 431.0)*124.0);\n    return vec3(x,y,z);\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    //initialize points\n    vec2 points[POINT_COUNT];\n    for(int i=0; i<POINT_COUNT; i++)\n    {\n        float aspect = iResolution.x/iResolution.y;\n        points[i] = r12(float(i) * SEED);\n        points[i].x = fit01(points[i].x, -aspect,aspect);\n        points[i].y = fit01(points[i].y, -1.0,1.0);\n    }\n    \n    //find closest point\n    float closestPointDistance = VERY_LARGE_NUMBER;\n    int closestPointIndex = 0;\n    for(int i=0; i<POINT_COUNT; i++)\n    {\n        vec2 pPos = points[i];\n        float d = length(pPos - uv);\n        if(d < closestPointDistance)\n        {\n            closestPointDistance = d;\n            closestPointIndex = i;\n        }\n    }\n    \n    //random color for each cell\n    vec3 col = r13(float(closestPointIndex) * SEED);\n\n    if(VISUALIZE_POINT)\n    {\n        float pointVisualize = 0.;\n        for(int i=0; i<POINT_COUNT; i++)\n        {\n            vec2 pPos = points[i];\n            float d = length(pPos - uv);\n            pointVisualize += smoothstep(0.01,0.009, d);\n        }\n        col *= (1.0-pointVisualize);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 189, 231, 231, 257], [259, 259, 299, 299, 354], [360, 372, 395, 395, 447], [449, 449, 471, 471, 591], [593, 593, 615, 615, 791], [797, 797, 852, 852, 2021]], "test": "untested"}
{"id": "NlS3Ry", "name": "Redstone", "author": "been_jamming", "description": "I really like redstone!", "tags": ["3d", "minecraft"], "likes": 21, "viewed": 532, "published": 3, "date": "1624081884", "time_retrieved": "2024-07-30T19:15:13.704803", "image_code": "struct face{\n    vec3 p;\n    vec3 side0;\n    vec3 side1;\n};\n\nstruct ray{\n\tvec3 p;\n\tvec3 vec;\n};\n\nvec4 create_orientation(vec3 axis, float angle){\n\tfloat len;\n\tvec4 outvec;\n\t\n\tlen = length(axis);\n\taxis *= sin(angle)/len;\n\toutvec.yzw = axis;\n\toutvec.x = cos(angle);\n\t\n\treturn outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n\treturn vec4(orientation.x, -orientation.yzw);\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n\tvec4 outvec;\n\t\n    outvec.x = dot(a, b.xyzw*vec4(1.0, -1.0, -1.0, -1.0));\n    outvec.y = dot(a, b.yxwz*vec4(1.0, 1.0, 1.0, -1.0));\n    outvec.z = dot(a, b.zwxy*vec4(1.0, -1.0, 1.0, 1.0));\n    outvec.w = dot(a, b.wzyx*vec4(1.0, 1.0, -1.0, 1.0));\n    \n    return outvec;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n\tvec4 v;\n\t\n\tv.x = 0.0;\n\tv.yzw = p.xyz;\n\treturn compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\nvoid ray_face_intersect(face f, ray r, out float t, out vec2 face_coords, out vec3 intersect_pos){\n    vec3 normal_vec;\n    \n    normal_vec = cross(f.side0, f.side1);\n    t = dot(f.p - r.p, normal_vec)/dot(r.vec, normal_vec);\n    intersect_pos = r.vec*t + r.p;\n    face_coords.x = dot(intersect_pos - f.p, f.side0)/(dot(f.side0, f.side0));\n    face_coords.y = dot(intersect_pos - f.p, f.side1)/(dot(f.side1, f.side1));\n}\n\nfloat hash(const float n){\n    return fract(cos(2.0734*n)*sin(n*1.1234512)*12111.312);\n}\n\n//The number of rectangular faces in the scene\n#define NUM_FACES 51\n\n//For each face, I have defined a corner of the face and two vectors for the sides of the face\nconst face faces[NUM_FACES] = face[NUM_FACES](\n    //The smooth stone block\n    face(vec3(0.0625, 0.0625, -0.0001), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(-0.0001, 0.0625, 0.0625), vec3(0.0, 0.0, 0.875), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(1.0001, 0.0625, 0.0625), vec3(0.0, 0.0, 0.875), vec3(0.0, 0.875, 0.0)),\n    face(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(0.0625, 0.0625, 1.0001), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.875, 0.0)),\n    face(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)),\n    face(vec3(0.0625, 1.0001, 0.0625), vec3(0.875, 0.0, 0.0), vec3(0.0, 0.0, 0.875)),\n    face(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0)),\n    \n    //The grass ground\n    //This is just a plane that lies a the bottom of the scene\n    face(vec3(50.0, 0.0, 50.0), vec3(-100.0, 0.0, 0.0), vec3(0.0, 0.0, -100.0)),\n    \n    //The wood on the redstone torch\n    face(vec3(0.4375, 0.125, 0.0001), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.4375, 0.125, 0.0001), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.5625, 0.125, 0.0001), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.5, -0.5)),\n    face(vec3(0.4375, 0.25, 0.1251), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.5, -0.5)),\n    \n    //The redstone on the redstone torch\n    face(vec3(0.4375, 0.625, -0.4999), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.625, -0.4999), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.5627, 0.625, -0.4999), vec3(0.0, 0.125, 0.125), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.75, -0.3749), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, -0.125)),\n    face(vec3(0.4375, 0.75, -0.6249), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.125, 0.125)),\n    \n    //The redstone dust!\n    face(vec3(-1.25, 0.0001, 0.5625), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, -0.125)),\n    face(vec3(-1.25, 0.0001, 0.625), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, -0.0625)),\n    face(vec3(-1.25, 0.0001, 0.375), vec3(1.25, 0.0, 0.0), vec3(0.0, 0.0, 0.0625)),\n    \n    //The redstone repeater\n    face(vec3(-1, 0, -1), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0, 0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0, -1), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(0, 0, -1), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.125, 0.0)),\n    face(vec3(-1, 0.125, -1), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0)),\n    \n    //The wood on the repeater\n    face(vec3(-0.875, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.75, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.875, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.125, -0.4375), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    \n    //The redstone on the repeater\n    face(vec3(-0.875, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.75, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.875, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.3125, -0.4375), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.875, 0.4375, -0.5625), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    face(vec3(-0.625, 0.1256, -0.5625), vec3(0.5, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    //The wood on the repeater\n    face(vec3(-0.25, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.125, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.25, 0.125, -0.5625), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.125, -0.4375), vec3(0.0, 0.1875, 0.0), vec3(0.125, 0.0, 0.0)),\n    \n    //The redstone on the repeater\n    face(vec3(-0.25, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.125, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.0, 0.0, 0.125)),\n    face(vec3(-0.25, 0.3125, -0.5625), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.3125, -0.4375), vec3(0.0, 0.125, 0.0), vec3(0.125, 0.0, 0.0)),\n    face(vec3(-0.25, 0.4375, -0.5625), vec3(0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.125)),\n    \n    //More redstone dust\n    face(vec3(-1.25, 0.0001, 0.75), vec3(-0.5, 0.0, 0.0), vec3(0.0, 0.0, -0.5)),\n    face(vec3(-1.25, 0.0001, -0.25), vec3(-0.5, 0.0, 0.0), vec3(0.0, 0.0, -0.5)),\n    face(vec3(-1.4375, 0.0001, -0.25), vec3(-0.125, 0.0, 0.0), vec3(0.0, 0.0, 0.5)),\n    face(vec3(-1.25, 0.0001, -0.4375), vec3(0.25, 0.0, 0.0), vec3(0.0, 0.0, -0.125))\n);\n\n//Each face gets a default color\nvec3 face_colors[NUM_FACES] = vec3[NUM_FACES](\n    //The smooth stone block\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.5, 0.5, 0.5),\n    \n    //The grass ground\n    vec3(0.2, 0.4, 0.05),\n    \n    //The wood on the redstone torch\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the redstone torch\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //The redstone dust\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //The redstone repeater\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.7, 0.7, 0.7),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    vec3(0.4, 0.0, 0.0),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    \n    //More redstone dust\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0),\n    vec3(0.4, 0.0, 0.0)\n);\n\n//Since I can't store the actual textures in the shader, I instead resort to adding the\n//\"roughness\" that you see in Minecraft's textures to try to make it look like the same\n//textures. I compensate by adding more faces when I need more detail\nconst vec3 material_variation[NUM_FACES] = vec3[NUM_FACES](\n    //The smooth stone block\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    vec3(0.15, 0.15, 0.15),\n    \n    //The grass ground\n    vec3(0.2, 0.2, 0.2),\n    \n    //The wood on the redstone torch should only vary in \"brown-ness\"\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.25, 0.14, 0.0),\n    \n    //The redstone on the redstone torch\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //The redstone dust\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    \n    //The redstone repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    vec3(0.0, 0.0, 0.0),\n    \n    //The wood on the repeater\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    vec3(0.24, 0.14, 0.0),\n    \n    //The redstone on the repeater\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    vec3(0.2, 0.2, 0.2),\n    \n    //More redstone dust\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0)\n);\n\n//This stores how many \"mc pixels\" across each face is\n//This will determine the resolution of the material variation\nconst vec2 texture_dims[NUM_FACES] = vec2[NUM_FACES](\n    //The smooth stone block\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    vec2(16.0, 16.0),\n    \n    //The grass ground\n    vec2(1600.0, 1600.0),\n    \n    //The wood on the redstone torch\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(2.0, 8.0),\n    \n    //The redstone on the redstone torch\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    //The redstone dust\n    vec2(20.0, 2.0),\n    vec2(20.0, 1.0),\n    vec2(20.0, 1.0),\n    \n    //The redstone repeater\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 2.0),\n    vec2(16.0, 16.0),\n    \n    //The wood on the redstone repeater\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    \n    //The redstone on the repeater\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    vec2(1.0, 1.0),\n    \n    //The wood on the redstone repeater\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    vec2(3.0, 2.0),\n    \n    //The redstone on the repeater\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0),\n    \n    //More redstone dust\n    vec2(8.0, 8.0),\n    vec2(8.0, 8.0),\n    vec2(2.0, 8.0),\n    vec2(4.0, 2.0)\n);\n\n//This stores which materials are transparent to light\nconst bool material_transparent[NUM_FACES] = bool[NUM_FACES](\n    //The smooth stone block is not transparent\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    false,\n    \n    //The grass is not transparent\n    false,\n    \n    //The wood on the redstone is not transparent\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the redstone torch is transparent (so we can put the light source inside)\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone dust\n    true,\n    true,\n    true,\n    \n    //The redstone repeater\n    false,\n    false,\n    false,\n    false,\n    false,\n    \n    //The wood on the redstone repeater\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the repeater\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    true,\n    \n    //The wood on the redstone repeater\n    true,\n    true,\n    true,\n    true,\n    \n    //The redstone on the repeater\n    true,\n    true,\n    true,\n    true,\n    true,\n    \n    //More redstone dust\n    true,\n    true,\n    true,\n    true\n);\n\n//The chance that a pixel of the block will be transparent\n//This is pretty much only for redstone dust (I might use this for particle effects later though)\nconst float material_pixel_invisible_chance[NUM_FACES] = float[NUM_FACES](\n    //The smooth stone block is not transparent\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The grass is not transparent\n    0.0,\n    \n    //The wood on the redstone is not transparent\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the redstone torch is transparent (so we can put the light source inside)\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone dust\n    0.5,\n    0.8,\n    0.8,\n    \n    //The redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The wood on the redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    0.0,\n    \n    //The wood on the redstone repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //The redstone on the repeater\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    \n    //More redstone dust\n    0.5,\n    0.5,\n    0.6,\n    0.5\n);\n\n//The number of light sources\n#define NUM_LIGHT_SOURCES 4\n\n//This stores the different light source colors\nvec3 light_source_color[NUM_LIGHT_SOURCES] = vec3[NUM_LIGHT_SOURCES](\n    vec3(0.25, 0.03125, 0.03125),\n    vec3(2.0, 4.0, 4.0),\n    vec3(0.1, 0.0125, 0.0125),\n    vec3(0.1, 0.0125, 0.0125)\n);\n\n//This stores each light source position\nvec3 light_source_position[NUM_LIGHT_SOURCES] = vec3[NUM_LIGHT_SOURCES](\n    vec3(0.5, 0.775, -0.5),\n    vec3(-2.0, 4.0, 4.0),\n    vec3(-0.8125, 0.375, -0.5),\n    vec3(-0.1875, 0.375, -0.5)\n);\n\n//This stores whether each light source is active\nbool light_source_active[NUM_LIGHT_SOURCES] = bool[NUM_LIGHT_SOURCES](\n    true, true, true, true\n);\n\nray get_camera_ray(vec2 pixel){\n\tfloat least_side;\n\t\n\tpixel -= vec2(0.5);\n\tleast_side = min(iResolution.x, iResolution.y);\n\treturn ray(vec3(0), vec3(pixel.x*iResolution.x/least_side, pixel.y*iResolution.y/least_side, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 camera_orientation;\n    vec3 camera_position;\n    vec4 look_down;\n    ray camera_ray;\n    face f;\n    int face_num;\n    int texture_id;\n    vec3 intersect_pos;\n    vec2 face_coords;\n    float intersect_time;\n    float best_dist = 25.0;\n    vec3 face_pos;\n    vec3 face_color;\n    vec3 face_normal;\n    int face_intersect;\n    ray shadow_ray;\n    vec3 current_color;\n    vec3 emission;\n    int light_id;\n    float pix_x;\n    float pix_y;\n    vec2 texture_dim;\n        \n    camera_orientation = create_orientation(vec3(0.0, 1.0, 0.0), iTime/5.0 + 0.125);\n    look_down = create_orientation(vec3(1.0, 0.0, 0.0), 0.3);\n    camera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n    camera_ray.vec = apply_orientation(camera_ray.vec, look_down);\n    camera_ray.vec = apply_orientation(camera_ray.vec, camera_orientation);\n    camera_ray.p = apply_orientation(vec3(-0.25, 1.75, -2.875), camera_orientation);\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    for(face_num = 0; face_num < NUM_FACES; face_num++){\n        f = faces[face_num];\n        ray_face_intersect(f, camera_ray, intersect_time, face_coords, intersect_pos);\n        if(intersect_time > 0.0 && length(intersect_pos - camera_ray.p) < best_dist && face_coords.x > 0.0 && face_coords.x < 1.0 && face_coords.y > 0.0 && face_coords.y < 1.0){\n            texture_dim = texture_dims[face_num];\n            pix_x = floor(face_coords.x*texture_dim.x);\n            pix_y = floor(face_coords.y*texture_dim.y);\n            if(material_pixel_invisible_chance[face_num] > hash((pix_x + 4.0 + 2.0*float(face_num))*(pix_y + 1.0 + float(face_num))))\n                continue;\n            best_dist = length(intersect_pos - camera_ray.p);\n            face_pos = intersect_pos;\n            face_color = face_colors[face_num] + material_variation[face_num]*hash(pix_x + 16.0*pix_y);\n            face_intersect = face_num;\n            face_normal = normalize(cross(f.side0, f.side1));\n        }\n    }\n    \n    if(best_dist != 25.0){\n        current_color = vec3(1.0/dot(face_pos - camera_ray.p, face_pos - camera_ray.p))*face_color;\n        light_source_active[0] = mod(iTime, 1.0) < 0.5;\n        light_source_active[2] = mod(iTime - 0.4, 1.0) < 0.5;\n        light_source_active[3] = mod(iTime - 0.4, 1.0) < 0.5;\n        if(mod(iTime, 1.0) < 0.5 && face_intersect >= 15 && face_intersect <= 19)\n            current_color += 2.0*face_color;\n        if(mod(iTime - 0.4, 1.0) < 0.5 && ((face_intersect >= 32 && face_intersect <= 36) || (face_intersect >= 20 && face_intersect <= 22) || face_intersect >= 42))\n            current_color += 2.0*face_color;\n        for(light_id = 0; light_id < NUM_LIGHT_SOURCES; light_id++){\n            if(!light_source_active[light_id])\n                continue;\n            if(light_id == 0 && face_intersect >= 15 && face_intersect <= 19)\n                continue;\n            if(light_id == 2 && face_intersect >= 32 && face_intersect <= 36)\n                continue;\n            if(light_id == 3 && face_intersect >= 42 && face_intersect <= 46)\n                continue;\n            shadow_ray = ray(face_pos, light_source_position[light_id] - face_pos);\n            for(face_num = 0; face_num < NUM_FACES; face_num++){\n                if(material_transparent[face_num] || face_num == face_intersect)\n                    continue;\n                f = faces[face_num];\n                ray_face_intersect(f, shadow_ray, intersect_time, face_coords, intersect_pos);\n                if(intersect_time > 0.0 && intersect_time < 1.0 && face_coords.x > 0.0 && face_coords.x < 1.0 && face_coords.y > 0.0 && face_coords.y < 1.0)\n                    break;\n            }\n            if(face_num == NUM_FACES)\n                current_color += light_source_color[light_id]*vec3(abs(dot(face_normal, shadow_ray.vec))/(length(shadow_ray.vec)*dot(shadow_ray.vec, shadow_ray.vec)))*face_color;\n        }\n        fragColor = vec4(current_color, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 145, 145, 283], [285, 285, 328, 328, 377], [379, 379, 420, 420, 692], [694, 694, 733, 733, 858], [860, 860, 958, 958, 1280], [1282, 1282, 1308, 1308, 1370], [14826, 14826, 14857, 14857, 15051], [15053, 15053, 15107, 15107, 19073]], "test": "untested"}
{"id": "Nlj3Wm", "name": "Dice part IV - [bmp/cube map]", "author": "byt3_m3chanic", "description": "Learning cube/bmp mapping surfaces, mapping/finding cube face from @Shane's comments and code. ", "tags": ["raymarching", "cube", "cubemap", "bumpmap"], "likes": 9, "viewed": 423, "published": 3, "date": "1624065994", "time_retrieved": "2024-07-30T19:15:14.460782", "image_code": "/**\n     _____     __     ______     ______   \n    /\\  __-.  /\\ \\   /\\  ___\\   /\\  ___\\  \n    \\ \\ \\/\\ \\ \\ \\ \\  \\ \\ \\____  \\ \\  __\\    \n     \\ \\____-  \\ \\_\\  \\ \\_____\\  \\ \\_____\\ \n      \\/____/   \\/_/   \\/_____/   \\/_____/   \n                                             \n                                             \n    I got schooled by @Shane on my last shader - I was using geometry\n    to create the dots on the dice objects in the map loop. It works but\n    gets heavy fast from the opertations and marching loop calls.\n\n    I originaly tried to figuring out the surface to cube map thing, thinking\n    drawing would be easier, but quickly I failed from lack of math skills. \n\n    However Shane's comment had the basic formula I had wrong. With\n    some research and understanding of his very cool 'Dice' shader I was able\n    to rework my original code to use this method. I feel that I have almost \n    learned how it all works!\n\n    06/18/2021 @byt3_m3chanic\n    \n    /////////////////////////////////////////////////////////////////////////\n    \n    // Reflection loop based off @BigWings tutorial.\n    // https://youtu.be/beNDx5Cvt7M\n    \n    // Bits and pieces - most folks here prob know this stuff.    \n    // http://web.cs.wpi.edu/~emmanuel/courses/cs4731/A14/slides/lecture21.pdf\n    \n    // @Shane's very cool moving dice shader\n    // https://www.shadertoy.com/view/3sVBDd\n\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    75.\n#define MIN_DIST    .001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n//@iq\nfloat cap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat g_hs,s_hs;\nmat2 turn,ria,gia;\n\nvec2 map(vec3 pos, float sg)\n{\n    pos.y-=2.25;\n\n    vec2 res = vec2(1e5,0.);\n    vec3 q = pos-vec3(0.,.75,0.);\n\n    float amount = 16.;\n    //@Shane polar rep\n    float a = atan(q.z, q.x);\n    float ia = floor(a/6.2831853*amount);\n    ia = (ia + .5)/amount*6.2831853;\n    //id cell and wave function\n    float id = -mod(ia,.0);\n    float cy = sin( id*4. + (iTime * .5) * PI) * .95;\n\n    mat2 rxa = rot(ia);\n    q.xz *= rxa;\n    q.xy -= vec2(7.75,-cy);\n  \n    float hs = hash21(vec2(id,3.34));\n    int pk = int(floor(hs*10.));\n\n    //dice rotation\n    vec3 dp = q;\n    dp.yx*=turn;\n    dp.zx*=turn;\n\n    float d1 = box(dp,vec3(.425))-.15;\n    if(d1<res.x)\n    {\n        res = vec2(d1,2.);\n        hit=dp;\n        g_hs=hs;\n        ria=rxa;\n    }\n\n    float bse = cap(pos-vec3(-2.5, .0,-3) ,2.,2.5);\n    bse=min(length( pos-vec3( 2.2,-.4, 3))-2.,bse);\n    if(bse<res.x)\n    {\n        res=vec2(bse,3.);\n    \thit=pos;\n    }\n    \n    float flr = pos.y+2.5;\n    if(flr<res.x)\n    {\n        res=vec2(flr,1.);\n    \thit=pos;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32 ? ray.x*.5 : ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\n// https://learnopengl.com/Advanced-Lighting/Gamma-Correction\nvec3 decodeSRGB(vec3 screenRGB) { return pow(screenRGB, vec3(2.2)); }\n\n// Tri-Planar blending function. GPU Gems 3 - Ryan Geiss:\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n    //return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec3 getDiceFace(int face, vec3 p)\n{\n    float cir = 0.;\n    if(face==0) {\n        cir = length(abs(p.yz)-.25);\n    }\n    if(face==1) {\n        cir = length(p.zx);\n        cir = min(length(abs(p.zx)-.25),cir);\n    }\n    if(face==2) {\n        cir = length(p.xy-vec2(.25,.25));\n        cir = min(length(p.xy+vec2(.25,.25)),cir);\n    }\n    if(face==3) {\n        cir = length(p.xy-vec2(.25,.25));\n        cir = min(length(p.xy+vec2(.25,.25)),cir);\n        cir = min(length(abs(p.xy)-.25),cir);\n    }\n    if(face==4) {\n        cir = length(abs(p.xz)-.25);\n        cir = min(length(vec2(abs(p.x)-.25,p.z)),cir);\n    }\n    if(face==5) {\n        cir = length(p.zy);\n    }\n\n    cir=smoothstep(.095,.0,cir);\n    \n    return vec3(1.-cir);\n}\n// based on bmp mapping from\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( vec3 p, vec3 n, float bf, float per, int face){\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        getDiceFace(face, p - e.xyy), \n        getDiceFace(face, p - e.yxy), \n        getDiceFace(face, p - e.yyx)\n    );\n    // Converting to greyscale.\n    vec3 g = vec3(0.299, 0.587, 0.114) * m; \n    g = (g - dot(getDiceFace(face, p), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);  \n    // return offset normal\n    return normalize( n + g*bf );\n}\nvec4 FC = vec4(0.322,0.443,0.459,0.);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,164, 1.);\n\n    hitPoint = hit;\n    s_hs=g_hs;\n    gia=ria;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(10,10,-5);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint;\n        vec3 cuv;\n        int face;\n        vec3 tn = n;\n        if(m==2.){\n            \n            tn = n;\n            tn.xz*=gia;\n\n            tn.yx*=turn;\n            tn.zx*=turn;\n            //https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n            \n            // set coords\n            if(face==0) cuv = hp.xyz;\n            if(face==1) cuv = hp.xyz;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.zyx;\n            if(face==5) cuv = hp.xyz;\n       \n            // get bump map surface\n            n=doBumpMap( cuv, n, 1., d, face);\n        }\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n        \n        //soft shadows\n        float shdw = 1.0;\n        for( float t=.01; t < 22.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h * .95;\n            if( shdw<MIN_DIST || t>64. ) break;\n        }\n        // get diff + shadows\n        diff = mix(diff,diff*shdw,1.-fresnel);\n        // spec\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n        \n        // materials and reflections\n        if(m==1.){\n            vec2 f = fract(hitPoint.xz*.15)-.5;\n            if(f.x*f.y>0.){\n                h=decodeSRGB(texture(iChannel0,f*2.).rgb);\n                ref = clamp(h-fresnel,vec3(0),vec3(1));\n            }else{\n                h= vec3(0.467,0.718,0.753);\n                ref = (h*.2)-fresnel;\n            }\n            C = (diff*h)+ min(spec,shdw);\n        }\n        if(m==2.){\n            // get dice face texture\n            h = tex3D(iChannel0,cuv,tn).rgb;\n            ref = h-fresnel;\n            C = (diff*h);\n        }\n        if(m==3.){\n            ref = vec3(.8)-fresnel;\n            C = (diff*h)+ min(spec,shdw);\n        }\n        \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    \n    } else {\n        C = FC.rgb;\n        ref=vec3(.35);\n    }\n\n    C = mix(FC.rgb,C,  exp(-.000025*d*d*d));     \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    turn = rot(T*55.*PI/180.);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,14.);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    //mouse\n    float x = M.xy == vec2(0) ? .5 : .5-(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n    if(x<-.005)x=-.005;\n    mat2 rx = rot(x);\n    mat2 ry = rot(y+T*5.*PI/180.);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 3.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00002*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    // gamma\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlj3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1561, 1561, 1582, 1582, 1637], [1638, 1638, 1656, 1656, 1701], [1703, 1703, 1722, 1722, 1754], [1755, 1755, 1782, 1782, 1861], [1862, 1868, 1907, 1907, 2014], [2088, 2088, 2118, 2118, 3132], [3134, 3134, 3164, 3164, 3415], [3417, 3417, 3472, 3472, 3709], [3711, 3773, 3806, 3806, 3842], [3844, 3902, 3949, 3949, 4203], [4205, 4205, 4241, 4241, 4934], [4935, 5005, 5068, 5068, 5483], [5522, 5522, 5616, 5616, 8471], [8473, 8473, 8514, 8514, 9444]], "test": "untested"}
{"id": "NljGRD", "name": "Transparent Raymarching", "author": "paz7", "description": "My unfinished attempt at #TechnicallyAChallange themed as Stained Glass", "tags": ["raymarching"], "likes": 8, "viewed": 538, "published": 3, "date": "1624050894", "time_retrieved": "2024-07-30T19:15:15.212771", "image_code": "#define maxRaymarchIterations 700\n#define minimumDistance .005\n#define minimumTransparentDistance .005\n#define maximumDistance 200.\n\n\nvec3 LightPos(){\n\treturn vec3(sin(iTime)*2.,2,cos(iTime)*2.+8.);\n}\n\nfloat GetDist(vec3 p){\n    //box\n    vec3 bp = p;\n    bp -= vec3(1.2,.5,9.);\t\t// translation\n    bp.xz *= Rot(iTime);\t\t// rotation\n    float box = sdBox(bp, vec3(.75));\n    \n    //sphere\n    vec3 sp = p;\n    sp -= vec3(-1.2,.5,9.);\n    float sphere = sdSphere(sp,0.75);\n    \n    //ground\n    vec3 gp = p;\n    gp -= vec3(0,-1.,0);\n    float ground = sdBox(gp,vec3(20,.1,20));\n    \n    float d = min(box,ground);\n    d = min(d,sphere);\n    \n    return d;\n}\n\nfloat GetTransparentDist(vec3 p){\n    vec3 bp = p;\n    bp -= vec3(0.,.5,7);\t\t// translation\n    bp.xz *= Rot(iTime*0.6431);\t\t// rotation\n    float box = sdBox(bp, vec3(1.1,1.1,0.1));\n    return box;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return  normalize(n);\n}\n\nfloat Lighting(vec3 p){    \n    vec3 l = normalize(LightPos()-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);\n    return dif;\n}\n\nvec3 TransGetNormal(vec3 p){\n    float d = GetTransparentDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetTransparentDist(p-e.xyy),\n        GetTransparentDist(p-e.yxy),\n        GetTransparentDist(p-e.yyx));\n    \n    return  normalize(n);\n}\n\nfloat TransLighting(vec3 p){    \n    vec3 l = normalize(LightPos()-p);\n    vec3 n = TransGetNormal(p);\n    float dif = abs(dot(n,l));\n    return dif;\n}\n\nvec2 ShadowMarch(vec3 ro, vec3 rd){\n\tfloat d = 0.;\n    float mind = maximumDistance;    \n    int i = 0; \n    float ds = 0.;\n    for(;;i++){\n    \tvec3 p = ro+rd*d;\n        ds = GetDist(p);\n        if(ds<mind) mind = ds;\n        if(ds<minimumDistance){\n            break;}\n        if(d>maximumDistance) break;\n        if(i>maxRaymarchIterations) break;  \n            d+=ds;\n    }\n    return vec2(d,mind);\n}\n\nvec2 TransShadowMarch(vec3 ro, vec3 rd){\n\tfloat d = 0.;\n    float mind = maximumDistance;    \n    int i = 0; \n    float ds = 0.;\n    for(;;i++){\n    \tvec3 p = ro+rd*d;\n        ds = GetTransparentDist(p);\n        if(ds<mind) mind = ds;\n        if(ds<minimumDistance){\n            break;}\n        if(d>maximumDistance) break;\n        if(i>maxRaymarchIterations) break;  \n        d+=ds;\n    }\n    return vec2(d,mind);\n}\n\nvec3 SoftShadowsTrans(vec3 p,float k){\n    vec4 transCol = vec4(.9,0,0,.15);\n\n    vec3 dir = normalize(LightPos()-p);\n    vec3 n = GetNormal(p);\n    vec3 col = vec3(1,1,1);\n    vec3 transcol = vec3(1,1,1);\n    \n    vec3 ro = p + n * minimumDistance * 2.;\n    vec3 rd = dir;\n    int i = 0;\n    float d = 0.;\n    for(;;i++){\n       vec3 rp = ro+rd*d;\n       float ds = GetDist(rp);\n       float tds = GetTransparentDist(rp);\n       \n       if(tds < minimumTransparentDistance){//inside transparent\n           tds = minimumTransparentDistance;\n           transcol.rgb -= minimumTransparentDistance*(1.-transCol.rgb)*(transCol.a)*15.;\n       }\n       if(ds < minimumDistance){//inside solid\n           col = vec3(0,0,0);\n           break;\n       }\n       if(i>maxRaymarchIterations) {\n           col = vec3(0,1,0);\n           break;\n       }\n       if(d > maximumDistance) break;\n       \n       d += min(ds,tds);\n    }\n    transcol = clamp(transcol,vec3(0,0,0),vec3(1,1,1));\n    float alpha = (transcol.r+transcol.g+transcol.b)/3.;\n    vec3 final = 1.-col + 1.-transcol;\n    \n    return 1.-final;\n}\n\nvec3 SoftShadows(vec3 p,float k){\n\tvec3 l = normalize(LightPos()-p);\n    vec3 n = GetNormal(p);\n    float dif = 1.;\n    float sh = 1.;\n    float tsh = 1.;\n    vec2 d = ShadowMarch(p+n*minimumDistance*10.,l);\n    vec2 td = TransShadowMarch(p+n*minimumDistance*10.,l);\n    vec4 transCol = vec4(.9,0,0,iMouse.x/iResolution.x);\n\n    if(d.x<length(LightPos()-p)) sh = 0.;\n    \n    sh = min(sh,k*d.y/minimumDistance);\n    tsh = min(tsh,k*td.y/minimumTransparentDistance);   \n    \n    vec3 finalShadow = vec3(sh);\n    \n    return finalShadow;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd){// x = distance y = closest distance z = iterations\n\tfloat d = 0.;\n    float mind = maximumDistance;    \n    vec3 rayC = vec3(0,0,0);\n    vec4 transCol = vec4(.9,0,0,.15);\n    vec4 trans = vec4(0,0,0,1);\n    float transL = 1.;\n    int i = 0;\n    bool inside = false;\n    float alpha = 0.;\n    float ds = 0.;\n    for(;;i++){\n    \tvec3 p = ro+rd*d;\n        ds = GetDist(p);\n        float tds = GetTransparentDist(p);        \n        if(ds<minimumDistance){\n            rayC += Lighting(p);\n            break;}\n        if(d>maximumDistance) break;\n        if(i>maxRaymarchIterations) break;\n        if(tds<minimumTransparentDistance && inside == false){\n            transL = TransLighting(p);\n        }\n        if(tds<minimumTransparentDistance){\n            inside = true;\n            alpha -= transCol.a*tds;\n            tds=minimumTransparentDistance;\n        }else{\n            inside = false;            \n        }\n        if(ds<tds)\n            d+=ds;\n        else\n            d+=tds;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec3 shadows = SoftShadowsTrans(p,1.);\n    \n    trans.rgb = transCol.rgb;\n    alpha = clamp(alpha,0.,1.);\n    //trans.a = alpha;\n    rayC*=shadows;\n    vec3 finalCol = rayC * (1.-alpha) + trans.rgb * alpha;\n    \n    return vec4(finalCol,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1) + vec3(0,-.15,0));\n    \n    vec4 r = RayMarch(ro,rd);//0-1\n\n    vec3 point = ro+rd*r.w;\n    \n    vec3 col = r.rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//SDFs\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdPlane(vec3 p,float y){\n    return abs(p.y-y);\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\n//transformations\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 150, 150, 200], [202, 202, 224, 234, 656], [658, 658, 691, 691, 858], [860, 860, 883, 883, 1075], [1077, 1077, 1100, 1100, 1226], [1228, 1228, 1256, 1256, 1492], [1494, 1494, 1522, 1522, 1645], [1647, 1647, 1682, 1682, 2051], [2053, 2053, 2093, 2093, 2469], [2471, 2471, 2509, 2509, 3565], [3567, 3567, 3600, 3600, 4104], [4106, 4106, 4138, 4189, 5405], [5407, 5407, 5464, 5464, 5751]], "test": "untested"}
{"id": "stj3Wm", "name": "raw materials 2", "author": "elenzil", "description": "why not.", "tags": ["mixing"], "likes": 7, "viewed": 249, "published": 3, "date": "1624049547", "time_retrieved": "2024-07-30T19:15:15.981715", "image_code": "M(0.321)\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M(1.0)\n", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define UV   (XY/iResolution.xy)\n\n#define M(tFac)                                                                        \\\nvoid mainImage( out vec4 RGBA, in vec2 XY )                                            \\\n{                                                                                      \\\n    RGBA = mixTheThings(UV, iTime * tFac, iChannel0, iChannel1, iChannel2, iChannel3); \\\n}\n\nfloat us(float t) { return sin(t) * 0.5 + 0.5; }\n\nmat2 rot2(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvec4 mixTheThings(in vec2 uv, in float t, in sampler2D s0, in sampler2D s1, in sampler2D s2, in sampler2D s3) {\n    \n    uv -= 0.5;\n    uv *= rot2(t);\n    uv += 0.5;\n\n    vec2 pq = fract(uv * 2.0);\n    \n    pq -= 0.5;\n    pq *= rot2(t * -1.5);\n    pq += 0.5;\n    \n    vec4 c;\n    if (uv.x < 0.5) {\n        if (uv.y < 0.5) {\n            c = texture(s0, pq, 0.0);\n        }\n        else {\n            c = texture(s1, pq, 0.0);\n        }\n    }\n    else\n    {\n        if (uv.y < 0.5) {\n            c = texture(s2, pq, 0.0);\n        }\n        else {\n            c = texture(s3, pq, 0.0);\n        }\n    }\n    \n    c *= smoothstep(1.0, 0.95, 2.0 * length(pq - 0.5));\n    \n    return c;\n}\n\n", "buffer_b_code": "M(0.91)\n", "buffer_b_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "M(0.876)\n", "buffer_c_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "M(0.783)\n", "buffer_d_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stj3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "flB3D1", "name": "Sunnish", "author": "miczac", "description": "Made for audiovisual piece: https://youtu.be/pDuluYkmgU4\nRays are made with rope function I created. Fire, reflection and particles. Thanks to NR4 for the help with the analytical sphere: transparency without too much ray marching :). ", "tags": ["reflection", "sun", "fire", "particles", "spline", "rope", "tansparency"], "likes": 6, "viewed": 446, "published": 3, "date": "1624049494", "time_retrieved": "2024-07-30T19:15:16.928186", "image_code": "float particles;\nfloat glow;\n\n\nfloat noise(vec3 x) // iq's 3D noise\n{\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel1, (uv + 0.5)/256.0, -100.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\n\nvec2 mapRope(vec3 p, bool reflection)\n{\n    vec2 res = vec2(1000.,-1.);\n    \n    for(int id = 0; id < NUM_OBJECTS;id++)\n    {\n        vec4 rope_data = texelFetch(POSITION_TRAIL,ivec2(1,id),0);\n        vec3 rope_head = rope_data.xyz;\n        float dist_head = clamp(0.,1.,length(rope_head-p));\n        vec4  rope = Rope(p,id,POSITION_TRAIL);\n        vec3  motion_dir = rope.xyz;\n        vec3  position_front =  vec3(0);\t\n        float envelope = rope_data.w;\n        vec3  position_back = normalize(-motion_dir)*ROPE_LENGTH*(.2*tri(envelope*envelope)+0.8);\n        float capsule = sdCapsule(p-rope_head, position_back,position_front, CAP_RADIUS);\n        res.y = res.x < capsule ? res.y :  float(id);\n        res.x = min(res.x, capsule);\n        vec4 rope_tail = texelFetch(POSITION_TRAIL,ivec2(ROPE_POINTS,id),0);\n\n        if(reflection)\n        {\n            //add glowinbg particles\n            float b=cos(p.z*.5); \n            vec3 pp = p;\n            pp += texture(iChannel0,abs(p.xz*0.01)).xyz*0.5;\n            float particle =max(length(cos(pp*1.75+vec3(b,b*.5,cos(pp.x)))),abs(pp.x+pp.y+pp.z)-10.1); //make particles as 0 radius spheres, using cos of original op position and animated up  wish dance bop offset\n            particles+=0.4/(0.1+particle*particle*particle*100.);\n        }\n        glow += 0.1/(0.1+capsule*capsule*10.);\n    }\n    return vec2(res.x*RAY_MARCH_CORRECTION,res.y);\n}\n\n\nvec4 fire(vec3 p, float id)\n{    \n    vec4 data = texelFetch(POSITION_TRAIL,ivec2(1,id),0);\n    vec3 pos = data.xyz;\n    float env = data.w;\n    float density = fbm(5.0*(env*1.5)*(p-pos));\n    float rad = pow(length(p-pos),.5);\n    density -= 0.1 + rad* (0.5 - 0.5 *0.2) ;\n    density = clamp(density, 0.0, 1.0);\n    density *= (1.1 - smoothstep(0.2, 1., rad));\n    vec3 col = getColor(rad,density);\n    density *= smoothstep(0.1,0.4,dot(col,col));\n    return vec4(col, density);\n}\n\nvec4 fill_fire(vec3 ro, vec3 rd, vec2 obj)\n{\n    vec4 data = texelFetch(POSITION_TRAIL,ivec2(1,obj.y),0);\n    vec3 pos = data.xyz;\n    float env = tri(data.w*data.w);\n    vec3 p = ro + rd * obj.x; \n    vec4 color = vec4(0);\n    vec3 position_rope = vec3(0);\n    for (int i=0; i<NUM_SMOKE_STEPS; i++)\n    {\n        if (color.a > 0.99 || color.a > 0.) continue;\n        //if (length(p) > 1.1) continue;\n        vec4 d = fire(p, obj.y);\n        //float dist_from_head = clamp(length(p-pos),0.,1.);\n        d.rgb *= d.a;\n        color += d * (10. - color.a);\n        p += rd * MIN_DIST;\n    }\n\n    float d = length(p-pos);\n    color *= 1.1/(0.1+d*d*d*10.);\n    return color;\n}\n\n\nvec2 intersectRope(vec3 ro, vec3 rd, bool reflection)\n{\n    float dist = 0.01;\n    float id = -1.;\n    for(int i = 0; i < 128; i++)\n    {\n        vec3 p = ro + rd*dist;\n        vec2 hit = mapRope(p,reflection);\n        id = hit.y;\n        if( dist > 20. || abs(hit.x) < 0.01) break;\n        dist += hit.x;\n    }\n    return vec2(dist, id);\n}\n\n\nvec3 normalRope(vec3 p)\n{\n    vec2 e = vec2(1.0,-1.0)*0.00025773;\n    return normalize( e.xyy*mapRope( p + e.xyy, false).x + \n\t\t\t\t\t  e.yyx*mapRope( p + e.yyx, false).x + \n\t\t\t\t\t  e.yxy*mapRope( p + e.yxy, false).x + \n\t\t\t\t\t  e.xxx*mapRope( p + e.xxx, false).x );\n}\n\n\n\nvec3 normal_fire(vec3 p, float id)\n{\n    vec2 e = vec2(1.0,-1.0)*0.0025773;\n    return normalize( e.xyy*fire( p + e.xyy, id).w + \n\t\t\t\t\t  e.yyx*fire (p + e.yyx, id).w + \n\t\t\t\t\t  e.yxy*fire( p + e.yxy, id).w + \n\t\t\t\t\t  e.xxx*fire( p + e.xxx, id).w );\n}\n\nvec3 normalSphere(vec3 x)\n{\n    float s = length(x)-CENTER_SPH_RAD,\n        dx = 5.e-4;\n    return normalize(vec3(\n        length(x+dx*c.xyy)-CENTER_SPH_RAD, \n        length(x+dx*c.yxy)-CENTER_SPH_RAD, \n        length(x+dx*c.yyx)-CENTER_SPH_RAD\n    )-s);\n}\n\nmat3 camera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 f = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 r = normalize( cross(f,cp) );\n\tvec3 u =          ( cross(r,f) );\n    return mat3( r, u, f );\n}\n\nvec3 renderCol(vec2 hit, vec3 ro, vec3 rd, bool reflection)\n{\n    vec3 lig_pos = vec3(0,1,0);\n    vec3 col = vec3(0);\n    vec3 p = ro +rd*hit.x;\n\n    vec4 smoke = fill_fire(ro,rd,hit);\n    col = max(smoke.xyz,vec3(0));\n    if(dot(col,col) < 0.001) return vec3(0);\n    float id =  hit.y;\n    vec3 norm_fire = normal_fire(p, id);\n    float diff = dot(norm_fire, -lig_pos)*0.5+0.5;\n    col *= diff;\n    col = max(col*1.,vec3(0));\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 col =vec3(0);\n    bool reflection = false;\n    vec2 sph = asphere(ro, rd, CENTER_SPH_RAD);\n    vec2 rope = intersectRope(ro,rd,reflection);\n    float dist_front = sph.x;\n    float dist_back = sph.y;\n    vec2 front, back;\n    vec3 ro_front, ro_back, rd_front, rd_back, norm_front, norm_back;\n    if(sph.x < 15. && sph.y < 30.)\n    {\n        vec3 p_front = ro+rd*dist_front;\n        norm_front = normalSphere(p_front);\n        ro_front = p_front;\n        vec3 ref_front = reflect(rd,norm_front);\n        rd_front = ref_front;\n        reflection = true;\n        front = intersectRope(ro_front,rd_front,reflection);\n        col +=texture(iChannel2,rd_front).xyz*0.045;\n        col += max(vec3(0),renderCol(front, ro_front, rd_front, reflection)*0.5);\n\n        vec3 p_back = ro+rd*dist_back;\n        norm_back = normalSphere(p_back);\n        ro_back = p_back;\n        vec3 ref_back = reflect(rd,norm_back);\n        rd_back = ref_back;\n        back = intersectRope(ro_back,rd_front,reflection);\n        vec3 col_back = max(vec3(0),renderCol(back, ro_back, rd_back, reflection))*0.3;\n        col_back +=texture(iChannel2,rd_back).xyz*0.025;\n        col_back = mix(vec3(0),col_back,0.4);\n        col += col_back;\n    }else\n    {\n        col =texture(iChannel2,rd).xyz*0.14;   \n    }\n    float dist_min = min(dist_front,dist_back);\n    float atten = reflection ? 0.5  : 1.;\n    vec3 col_rope = rope.y < fNUM_OBJECTS ? renderCol(rope, ro, rd, reflection)*atten : vec3(0);\n    col = mix(col,col_rope,0.1);    \n    vec3 cubem = texture(iChannel2,rd).xyz;\n    if(reflection) col += cubem*0.4;\n    float pglow = pow(glow,.5);\n    col += vec3(particles*pglow*.31/(fNUM_OBJECTS*0.3))*vec3(0.5, 0.4, 0.1);\n    return max(col,vec3(0));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y*2.;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    float an = 0.5*iTime - TAU*(m.x-0.5);\n\tvec3 ro = vec3(2.0*sin(an),2.5*cos(0.4*an),2.0*cos(an));\n    vec3 lookat = vec3(0.0,0.0,0.0);\n    mat3 cam = camera(ro, lookat,0.);\n    vec3 rd = cam*vec3(uv,1. );\n    vec3 col = vec3(0);\n    col = render(ro,rd);\n    col = pow(clamp(col,0.,1.), vec3(0.45));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//flames are distributed on a sphere in a grid\n//#define LO_PERF\n#ifdef LO_PERF\n#define SPHERE_GRID vec2(1,2)\n#else\n#define SPHERE_GRID vec2(3,3)\n#endif\nconst int NUM_OBJECTS =  int(SPHERE_GRID.x*SPHERE_GRID.y);\nconst float fNUM_OBJECTS = float(NUM_OBJECTS);\n#define PI 3.14159\n#define TAU 6.28359\n#define MIN_DIST 0.001\n#define MAX_DIST 10.\n#define NUM_SMOKE_STEPS 10\n#define ROPE_POINTS 32\n#define ROPE_LENGTH 0.6\nconst float fROPE_POINTS = float(ROPE_POINTS);\n#define POSITION_TRAIL iChannel0\n#define CAP_RADIUS 0.08\n#define RAY_MARCH_CORRECTION 0.7\n#define FLAMES_DIST 1.\n#define CENTER_SPH_RAD 0.8\n\n\nfloat hash( float n )\n{\n    return fract(sin(n+2910.)*43758.5453123);\n}\n\n//Blackle's erot function\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat envelope(int obj, float time)\n{\n   float  freq = hash(float(obj)*20.);\n   \n   return 1.-fract(freq*time);   \n}\n\nfloat slide(float cur, float tar, float slu, float sld)\n{\n    //slide up or slide down\n    float del = (tar>cur) ?  slu : sld;\n \tcur += (tar - cur) * del;\n    return    cur;\n}\n\nvec3 pos_on_sphere(float phi, float theta, float radius)\n{\n//assumes both phi and theta are 0<>1\n        phi *= 2.;\n        phi -= 1.;\n        phi *= 3.14159;\n        theta *= 6.28359; \n        float coth = cos(theta), \n              sith = sin(theta), \n              coph = cos(phi),\n              siph = sin(phi);\n        float x = radius*coph*coth,\n              y = radius*coph*sith,\n              z = radius*siph;\n       \n       return vec3(x,y,z);\n}\n\n\nfloat tri(float x)\n{\n    return min(fract(x) * 2., 2. - 2. * fract(x));\n}\n\nvec3 getColor(float r, float d)\n{\n    vec3 c = mix(vec3(0.9), vec3(0.5, 0.4, 0.1), d);\n    \n\tc *= mix(vec3(1.0, 0.4, 0.0), vec3(0.5), r );\n    \n\treturn c * 4.0;\n}\n\n//IQ \nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n \n  return length( pa - ba*h ) - r*sqrt(h);\n}\n// Analytical sphere distance.\n// Thanks Nr4 for this!\n//https://shadertoy.com/view/Wlj3z1\nconst vec3 c = vec3(1.,0.,-1.);\nconst float f = 1.e4;\nvec2 asphere(vec3 x, vec3 dir, float R)\n{\n    float a = dot(dir,dir),\n        b = 2.*dot(x,dir),\n        cc = dot(x,x)-R*R,\n        dis = b*b-4.*a*cc;\n    if(dis<0.) return vec2(f);\n    vec2 dd = (c.xz*sqrt(dis)-b)/2./a;\n    return vec2(min(dd.x, dd.y), max(dd.x, dd.y));\n}\n\n\n\n//spline interpolation function to connect points across tentacle \n//from : http://sol.gfxile.net/interpolation/\nvec3 catmullrom(float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3)\n{\n\treturn 0.5 * (\n\t\t\t\t(2. * p1) +\n\t\t\t\t(-p0 + p2) * t +\n\t\t\t\t(2. * p0 - 5. * p1 + 4. * p2 - p3) * t * t +\n\t\t\t\t(-p0 + 3. * p1 - 3. * p2 + p3) * t * t * t\n\t\t\t\t);\n}\n\n//this is probably the most relevant function in this shader: it allows for smooth interpolation\n//between points in a sdf (e.g. capsule), it gets its points from a row of pixels stored and \n//continuisly updating in buffer B. For this  to work the object needs to be moving, if slightly, at all times\nvec4 Rope(vec3 p, int id, in sampler2D text)\n{\n    vec3  rope_head   = texelFetch(text, ivec2(1, id ), 0).xyz;//position data is stored starting from pix(1,id)\n    vec3  rope_tail   = texelFetch(text, ivec2(ROPE_POINTS-1, id ), 0).xyz;\n    float speed       = 1.+(length(rope_head - rope_tail))*.3;//TWEAK\n\n    //since the distance from the beginning of the rope changes based on object speed\n    //attentuate this undesired effect\n    float center_dist = clamp(length(p-rope_head),0.,1.)/speed;\n\n    //pick previous position based on how distant p is from the current position\n    int   point_coo    = int(floor(center_dist*(fROPE_POINTS-3.)));\n    float interp_index = fract(center_dist*(fROPE_POINTS-3.));\n    vec3  rope_point_0 = texelFetch(text, ivec2(point_coo+0, id ), 0).xyz;\n    vec3  rope_point_1 = texelFetch(text, ivec2(point_coo+1, id ), 0).xyz;\n    vec3  rope_point_2 = texelFetch(text, ivec2(point_coo+2, id ), 0).xyz;\n    vec3  rope_point_3 = texelFetch(text, ivec2(point_coo+3, id ), 0).xyz;\n    vec3  point_ahead  = catmullrom(interp_index, rope_point_0, rope_point_1, rope_point_2, rope_point_3);\n    vec3  point_behind = catmullrom(interp_index-0.051, rope_point_0, rope_point_1, rope_point_2, rope_point_3);\n    vec3  motion_dir    = point_behind -point_ahead  ;\t\n\n    return vec4(motion_dir, center_dist);\n}\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 iCoo = ivec2(fragCoord);\n    if(any(greaterThan(iCoo,ivec2(ROPE_POINTS,NUM_OBJECTS)))) discard;\n    if(iCoo.x == 0)\n    {\n        float new_ramp     = envelope(iCoo.y, iTime);\n        vec4  prev_data    = iFrame < 1 ? vec4(0,0.5, 0.6, 1.) : texelFetch(iChannel0,iCoo,0);\n        float prev_env     = prev_data.x, \n              prev_ramp    = prev_data.y;\n        bool trigger = new_ramp > prev_ramp;\n        float env = prev_env;\n        if(trigger) env = 1.; \n        else {env = slide(env, 0., 1.,1./20.);}\n        fragColor = vec4(env, new_ramp, 0,0);\n     }else if (iCoo.x == 1)\n     {\n         vec2 id = vec2(mod(fragCoord.y,SPHERE_GRID.x)/SPHERE_GRID.x,\n                        floor(fragCoord.y/SPHERE_GRID.x));\n         vec2 sect = vec2(1)/SPHERE_GRID;\n         float off = iCoo.y == 0 || iCoo.y == NUM_OBJECTS-1 ? 0. : sect.y*0.25;\n         float phi = off+sect.y*id.y;\n         float theta =id.x;\n         vec3 pos = pos_on_sphere(phi,theta,FLAMES_DIST);\n         float env = texelFetch(iChannel0,ivec2(0,iCoo.y),0).x;\n         pos *= (1.01-tri(env)*0.04);//add motion toward sphere\n         vec3 pt = cross(pos,vec3(0,1,0)*0.05)+pos;\n         vec3 pt_rot = erot(pt,pos,env*TAU);\n         fragColor = vec4(pt_rot,env);\n     }else\n     {\n         fragColor.xyz = texelFetch(iChannel0,iCoo-ivec2(1,0),0).xyz+texelFetch(iChannel0,ivec2(1,iCoo.y),0).xyz*(float(ROPE_POINTS-iCoo.x)/fROPE_POINTS*0.1);\n     }\n    \n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 69, 69, 291], [293, 293, 312, 312, 482], [485, 485, 524, 524, 1885], [1888, 1888, 1917, 1917, 2369], [2371, 2371, 2415, 2415, 3043], [3046, 3046, 3101, 3101, 3386], [3389, 3389, 3414, 3414, 3651], [3655, 3655, 3691, 3691, 3903], [3905, 3905, 3932, 3932, 4161], [4163, 4163, 4212, 4212, 4380], [4382, 4382, 4443, 4443, 4826], [4828, 4828, 4859, 4859, 6589], [6591, 6591, 6648, 6648, 7120]], "test": "untested"}
{"id": "7t2GWm", "name": "Path traced cornell v1.0", "author": "Danimtz", "description": "Simple GPU pathtracing. Generated rays used emmitance of object as light sources. Doenst currently sample lights at each bounce.", "tags": ["cornellbox", "pathtracing"], "likes": 1, "viewed": 259, "published": 3, "date": "1624049030", "time_retrieved": "2024-07-30T19:15:17.680174", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(0.0);\n    // Time varying pixel color\n    if(iFrame>0)\n    {\n        col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n        col /= float(iFrame);\n    }\n    \n    // Output to screen\n    col *= 2.5; \n    fragColor = vec4(pow(col, vec3(0.4545)),1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define SURF_DIST 0.0001\n\n#define OBJ1 1.0\n#define OBJ2 2.0\n#define LIGHT_ID 3.0\n#define RIGHT_WALL 4.0\n#define LEFT_WALL 5.0\n\n\n\nfloat sdBox( vec3 p, vec3 r )\n{\n  vec3 q = abs(p) - r;\n  return length(max(q,0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec2 minSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x<sdf2.x ? sdf1 : sdf2;\n}\n\n\nvec2 rot_point(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(a.x * c - a.y * s, a.x * s + a.y * c);\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453);\n}\n\n//http://www.amietia.com/lambertnotangent.html\nvec3 getBRDFray(vec3 n, float seed)\n{\n    float u = hash(78.233 + seed);\n    float v = hash(10.873 + seed);\n\n    float theta = 6.283185 * v; //2pi*v\n    u = 2.0*u - 1.0;\n    vec3 sph_point = vec3(sqrt(1.0 - u*u) * vec2(cos(theta), sin(theta)), u);\n\n    return normalize(n + sph_point);\n}\n\nvec2 map(vec3 p) //cornell box map\n{\n    vec2 cur_sdf = vec2(1e10, 1.0);\n\n    float size = 2.0;\n    cur_sdf = minSDF(cur_sdf, vec2(sdBox(p-vec3(0.0, -size, 0.0), vec3(size, 0.01, size)), OBJ1));//plane\n    cur_sdf = minSDF(cur_sdf, vec2(sdBox(p-vec3(-size, 0.0, 0.0), vec3(0.01, size, size)), LEFT_WALL));//side walls\n    cur_sdf = minSDF(cur_sdf, vec2(sdBox(p-vec3(size, 0.0, 0.0), vec3(0.01, size, size)), RIGHT_WALL));\n    cur_sdf = minSDF(cur_sdf, vec2(sdBox(p-vec3(0.0, size, 0.0), vec3(size, 0.01, size)), OBJ1));//cealing\n    cur_sdf = minSDF(cur_sdf, vec2(sdBox(p-vec3(0.0, 0.0, size), vec3(size, size, 0.01)), OBJ1));//backwall\n\n    cur_sdf = minSDF(cur_sdf, vec2(sdBox(p-vec3(0.0, 1.99, 0.0), vec3(0.5, 0.01, 0.5)), LIGHT_ID));//light\n\n   \n    cur_sdf = minSDF(cur_sdf, vec2(sdSphere(p-vec3(-1.0, -1.5, 0.3), 0.5), OBJ2 ));//sphere\n    cur_sdf = minSDF(cur_sdf, vec2(sdSphere(p-vec3(0.2, -1.7, -1.0), 0.3), OBJ2 ));//sphere\n\n    vec3 q = p-vec3(1.0, -1.1, 0.5);\n    q.xz = rot_point(q.xz, 0.4);\n    cur_sdf = minSDF(cur_sdf, vec2(sdBox(q, vec3(0.4, 0.9, 0.4)), OBJ2));//box\n    return cur_sdf;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0);//error bias\n    vec3 n = normalize(vec3(\n            map(p + e.xyy).x - map(p - e.xyy).x,\n            map(p + e.yxy).x - map(p - e.yxy).x,\n            map(p + e.yyx).x - map(p - e.yyx).x));\n    return n;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0001;\n    vec2 res;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + t*rd;\n        res = map(p);\n        if(res.x < SURF_DIST || res.x > MAX_DIST) break;\n        t += res.x;\n    }\n\n    if (t > MAX_DIST) t = -1.0;\n    \n    return vec2(t, res.y);\n}\n/*\nfloat calcShadow(vec3 ro, vec3 rd)\n{\n    float t = 0.0001;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + t*rd;\n        float res = map(p).x;\n        if(res < SURF_DIST || res > MAX_DIST) break;\n        t += res;\n    }\n\n    return t>MAX_DIST ? 1.0 : 0.0;\n}*/\n\nvec4 getMaterial(float objID){\n\n    vec4 col = vec4(vec3(1.0), 0.0);\n    if(objID == OBJ2)       {col = vec4(vec3(0.7), 0.0);}\n    else if(objID == OBJ1)  {col = vec4(vec3(1.0), 0.0);}//vec3(0.016, 0.02, 0.03)\n    else if(objID == RIGHT_WALL)  {col = vec4(vec3(0.7, 0.05, 0.1), 0.0);}\n    else if(objID == LEFT_WALL)  {col = vec4(vec3(0.1, 0.7, 0.03), 0.0);}\n    else if(objID == LIGHT_ID)  {col = vec4(vec3(1.0, 0.83, 0.71), 4.0);}\n    else                    {col = vec4(vec3(0.2), 0.0);}\n\n    return col;\n}\n\n\n#define GI_BOUNCE 6\nvec3 pathTraceColor(vec3 ro, vec3 rd, float rngFloat)\n{\n    vec3 total_col = vec3(0.0);\n    vec3 ray_col = vec3(1.0);\n    for(int i = 0; i < GI_BOUNCE; i++)\n    {\n        //raymarch scene/////////\n        vec2 res = rayMarch(ro, rd);\n        float t = res.x;\n        float objID = res.y;\n\n        //check ray didnt escape scene/////////\n        if(t < 0.0)  {break;}\n\n        //point position and normal/////////\n        vec3 p = ro + t*rd;\n        vec3 n = getNormal(p);\n\n        //lighting for current path////////\n        vec4 material = getMaterial(objID);\n        float emisiv = material.w;\n        \n        ray_col *= material.xyz; //add surface colour to ray\n\n        vec3 indirect_light = ray_col * emisiv;\n        total_col += indirect_light * ray_col; //indirect + direct light\n\n        //setup new ray/////////\n        ro = p+n*0.05;\n        rd = getBRDFray(n, 76.2 + 73.1*float(i) + rngFloat + 17.7*float(iFrame));\n    }\n    return total_col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //center 0,0\n    float rng = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame)); //RNG\n    \n    //AA through random offset\n    vec2 offset = -0.5 + vec2( hash(rng+13.271), hash(rng+63.216) );\n    vec2 uv = ((fragCoord+offset) - 0.5*iResolution.xy)/iResolution.y; \n   \n\n    vec3 ro = vec3(0.0, 0.0,-5.5);\n    vec3 rd = vec3(uv.x, uv.y, 1.0);\n\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    if( iFrame==0 ) {col = vec3(0.0);};\n\n    col += pathTraceColor(ro, rd, rng);\n\n\n    fragColor = vec4( col , 1.0);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2GWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 346]], "test": "untested"}
{"id": "st23Ww", "name": "Clock hands", "author": "nide", "description": "Clock hands rendered using subpixel antialiasing", "tags": ["linesantialiasing"], "likes": 1, "viewed": 329, "published": 3, "date": "1624042902", "time_retrieved": "2024-07-30T19:15:18.435156", "image_code": "// Copied from https://www.shadertoy.com/view/ltcBzj\n\nfloat distance_to_line (vec2 p, vec2 p1, vec2 p2) {\n    vec2 p_p1 = p - p1;\n    vec2 p2_p1 = p2 - p1;\n    float h = clamp (dot (p_p1, p2_p1) / dot (p2_p1, p2_p1), 0.0, 1.0);\n    float d = length (p_p1 - p2_p1 * h);\n    return d;\n}\n\n\nvec2 circlePtAnimated(float lt) {\n    return vec2(sin(lt*3.1416*2.0), cos(lt*3.1416*2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    \n    float curTimeSeconds = iDate.w;\n    vec4 millisSecsMinsHours = vec4(\n        mod(curTimeSeconds,                      1.0), \n        mod(floor(curTimeSeconds)  /   60.0,     1.0), \n        mod(floor(curTimeSeconds / 60.0) / 60.0, 1.0), \n        mod((curTimeSeconds / 3600.0) / 12.0,    1.0)\n        );\n    vec4 lineLen = vec4(0.1, 0.8, 0.75, 0.6) * 0.5;\n\n    float lineThickness = 1.0;\n    \n    vec2 ptCenter = iResolution.xy/2.0;\n    vec3 color = vec3(0.0);\n    vec3 dbgCol = vec3(0.0);\n    for (int i = 0; i < 4; i++) {\n        if (millisSecsMinsHours[1] > 1.0) {\n            dbgCol.r = 1.0;\n        }\n        \n        vec2 ptEnd = ptCenter + lineLen[i] * circlePtAnimated(millisSecsMinsHours[i]) * iResolution.yy;\n        \n        \n        // rgb-subpixel antialiasing\n        float colCr = lineThickness - distance_to_line (fragCoord - vec2 (1./3., 0.), ptCenter, ptEnd);\n        float colCg = lineThickness - distance_to_line (fragCoord,                    ptCenter, ptEnd);\n        float colCb = lineThickness - distance_to_line (fragCoord + vec2 (1./3., 0.), ptCenter, ptEnd);\n        \n        color += max(vec3(0.0), vec3(colCr, colCg, colCb));\n\n        lineThickness *= 2.;\n    }\n    float distCt = length((ptCenter.xy - fragCoord.xy) / iResolution.yy);\n    float fadeLen = lineThickness / iResolution.y;\n#if 0\n    float circle = smoothstep(0.95-fadeLen*0.5, 0.95, distCt * 2.) * smoothstep(0.95+fadeLen*0.5, 0.95, distCt * 2.);\n    vec4 col = vec4((color+vec3(circle))*vec3(0.9, 0.8, 0.9)*0.1, 1.0);\n#else\n    vec4 col = vec4(color, 1.0);\n#endif\n    fragColor = pow(col,vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 105, 105, 284], [287, 287, 320, 320, 379], [381, 381, 438, 438, 2090]], "test": "untested"}
{"id": "Nt2GDm", "name": "raw materials", "author": "elenzil", "description": "why not.", "tags": ["mixing"], "likes": 2, "viewed": 251, "published": 3, "date": "1624033327", "time_retrieved": "2024-07-30T19:15:19.336745", "image_code": "M(0.321)\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "M(1.0)\n", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define UV   (XY/iResolution.xy)\n\n#define M(tFac)                                                                        \\\nvoid mainImage( out vec4 RGBA, in vec2 XY )                                            \\\n{                                                                                      \\\n    RGBA = mixTheThings(UV, iTime * tFac, iChannel0, iChannel1, iChannel2, iChannel3); \\\n}\n\nfloat us(float t) { return sin(t) * 0.5 + 0.5; }\n\nvec4 mixTheThings(in vec2 uv, in float t, in sampler2D s0, in sampler2D s1, in sampler2D s2, in sampler2D s3) {\n    vec4 i0 = texture(s0, uv, 0.0);\n    vec4 i1 = texture(s1, uv, 0.0);\n    vec4 i2 = texture(s2, uv, 0.0);\n    vec4 i3 = texture(s3, uv, 0.0);\n    \n    vec4 i01 = mix(i0 , i1 , us(t * 1.00));\n    vec4 i23 = mix(i2 , i3 , us(t * 1.52));\n    vec4 c   = mix(i01, i23, us(t * 1.91));\n    \n    return c;\n}\n\n", "buffer_b_code": "M(0.91)\n", "buffer_b_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "M(0.876)\n", "buffer_c_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "M(0.783)\n", "buffer_d_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2GDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "flj3Wm", "name": "Synchronized Line Animation", "author": "Shane", "description": "Rendering repeat line sequences within triangle cells to create a synchronized line animation.", "tags": ["triangle", "line", "hexagon", "geometry"], "likes": 50, "viewed": 683, "published": 3, "date": "1624032012", "time_retrieved": "2024-07-30T19:15:20.362005", "image_code": "/*\n\n\tSynchronized Line Animation\n\t---------------------------    \n    \n    Rendering repeat line sequences within triangle cells to create a synchronized \n    line animation.\n    \n    This particular sequence is a rough recreation of an animation that I've seen \n    in various reincarnations before. I'm pretty sure the original was conceived by \n    a visual artist known as Admiral Potato, who has an awesome body of work... and \n    a Shadertoy account, from what I can see. The link to his work is below.\n    \n    It's based on a very simple idea: Partition space into some kind of grid, then\n    use the vertex, midpoint, etc, geometry to render node based line animations. \n    I've done similar things before with a simple square grid, but hadn't tried it \n    with a more interesting tiling arrangement.\n    \n    Aesthetically, I adhered to the spirit of the original, but rendered it in a way\n    that was more condusive to realtime constraints. Anyway, this was just a simple\n    but rushed geometric animation example, so don't worry about the code itself too \n    much. It was a spur of the moment thing, which meant it was hacked together with \n    old routines of mine and without a lot of forethought. Hopefully, Admiral Potato \n    himself will one day convert his original to pixel shader form and post it on \n    Shadertoy. \n\n\n\n    Reference link:\n    \n    // Admiral Potato's Tumblr page. If you're interested in graphics, then \n    // you've probably seen versions of his work floating around the net.\n    http://admiralpotato.tumblr.com/\n    \n    // The link to the original animation.\n    Hex Doctor - Admiral Potato\n    http://nuclearpixel.com/motion/hex-doctor/\n    \n \n\n*/\n\n\n// Color palette: Pink\\Green: 0, Copper\\Gold: 1, Silver: 2\n#define PALETTE 0\n\n// Display the triangle cell borders.\n//#define SHOW_CELLS\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n// IQ's line distace formula. \nfloat sdLine(in vec2 p, in vec2 a, in vec2 b){\n\n\tp -= a, b -= a;\n\treturn length(p - b*clamp(dot(p, b)/dot(b, b), 0., 1.));\n}\n\n\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n    \n    //float idm = 1. - s.x*s.y;\n    //if(idm == 0.) idm += 1e-6;\n    //mat2 inM = 1./(idm)*mat2(1, s.y, s.x, 1);\n    //return inM*p;\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n/*\n// Exponential easing function.\nfloat exponentialOut(float t) {\n  return t == 1. ? t : 1. - pow(2., -8.*t);\n}\n\n// Quad easing function. \nfloat easeOutQuad(float t) {\n    return -t*(t - 2.);\n}\n*/ \n\n// Global distance values for the two colored lines and end points.\n// This was hacked in at the last minutes... I'll incorporate it\n// into the structure below at some stage.\nfloat line = 1e5;\nfloat line2 = 1e5;\nfloat circle = 1e5;\nfloat circle2 = 1e5;\n \n\n// Global vertices, local coordinates, etc, of the triangle cell.\nstruct triS{\n    \n    vec2[3] v; // Outer vertices.\n    vec2 p; // Local coordinate.\n    vec2 id; // Position based ID.\n    float dist; // Distance field value.\n    float triID; // Triangle ID.\n};\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\ntriS blocks(vec2 q){\n    \n\n    const float tf = 2./sqrt(3.);\n    // Scale.\n\tconst vec2 scale = vec2(tf, 1)*vec2(1./2.);\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n     // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(tf/2., 0);\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual block ID and block center.\n    vec2 idi, cntr;\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    // Unskewed block corner postions.\n    vec2[4] vert = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    // Unskewing to enable rendering back in normal space.\n    vert[0] = unskewXY(vert[0]*dim, sk);\n    vert[1] = unskewXY(vert[1]*dim, sk);\n    vert[2] = unskewXY(vert[2]*dim, sk);\n    vert[3] = unskewXY(vert[3]*dim, sk); \n    \n    // Skewed local coordinates.\n    vec2 skqxy = skewXY(q.xy, sk);\n    \n    \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n \n    // Initializing the global vertices and local coordinates of the triangle cell.\n    triS gT, tri1, tri2;\n    \n    // Initialize the various distance field values to a maximum.\n    line = 1e5;\n    line2 = 1e5;\n    circle = 1e5;\n    circle2 = 1e5;\n    \n\n    // End point width and line width values.\n    const float cw = .02;\n    const float lw = .007;\n    \n    // Fractional time for the four nodes. \n    const int ttm = 4;\n    float tm = 2. - iTime;\n    float modtm = mod(tm, float(ttm));\n    int index = int(modtm);\n    // Another animation thread.\n    float tm2 = iTime;\n    float modtm2 = mod(tm2, float(ttm));\n    int index2 = int(modtm2);\n \n\n    // Iterate through four neighboring grid squares -- Each square is skewed\n    // and subdivided diagonally to determine the nearest triangle. Yeah, it's\n    // annoying work, but the lines are rendered outside the confines of each\n    // triangle cell, which means neighboring cells need to be accounted for.\n    for(int i = min(0, iFrame); i<4; i++){    \n        \n        // Block center.\n        cntr = ps4[i]/2.;\n\n        // Skewed local coordinates.\n        p = skqxy;\n        //ip = floor(p/s - cntr) + .5 + cntr; // Local tile ID.\n        // Correct positional individual tile ID.\n        idi = (floor(p/s - cntr) + .5 + cntr)*s;\n        p -= idi; // New local position.\n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);       \n         \n        // Unskewing the rectangular cell ID.\n\t\tidi = unskewXY(idi, sk);  \n\n        \n        // Partioning the rectangle into two triangles.\n        for(int triJ = min(0, iFrame); triJ<2; triJ++){\n        \n            // Vertices for triangle one or two.\n            if(triJ==0) tri1.v = vec2[3](vert[0], vert[1], vert[2]); \n            else tri1.v = vec2[3](vert[0], vert[2], vert[3]);\n            \n            tri1.id = idi + inCentRad(tri1.v[0], tri1.v[1], tri1.v[2]).xy; // Position Id.\n            tri1.triID = float(i + triJ*4); // Triangle ID. Not used here.\n            tri1.dist = sdTri(p, tri1.v[0], tri1.v[1], tri1.v[2]); // Field distance.\n            tri1.p = p; // 2D coordinates.\n\n            // Mid edge points.\n            vec2[3] mid = vec2[3](mix(tri1.v[0], tri1.v[1], .5), mix(tri1.v[1], tri1.v[2], .5), mix(tri1.v[2], tri1.v[0], .5));\n\n            // Animating three edge lines and three vertex based lines.\n            for(int j = min(0, iFrame); j<3; j++){\n\n                 \n                // Three edge lines. Each map out a rhomboid path between four nodes.\n                //\n                // Rhombic nodal points -- These are hand picked.\n                vec2[4] pnt = vec2[4](mix(tri1.v[(0 + j)%3], mid[(2 + j)%3], .5), mix(mid[(2 + j)%3], mid[(0 + j)%3], .5), \n                                mix(mid[(2 + j)%3], mid[(1 + j)%3], .5), mid[(2 + j)%3]);\n                vec4 vAng = vec4(6.2831/3., 6.2831/6., 6.2831/3., 6.2831/6.); // Sweep angle.\n                vec2 p0 = p - pnt[(index + 1)%4]; // Pivot point.\n                float ang = mix(0., vAng[index], (fract(tm))); // Angular position.\n                p0 *= rot2(-ang); // Angular pivot.\n                vec2 p1 = (pnt[index] - pnt[(index + 1)%4]); // Anchor point.\n\n                // Line and circular end points for this edge.\n                float ln = sdLine(p0, vec2(0), p1);\n                float cir = min(length(p0), length(p0 - p1));  \n\n                // Add the line and end points for this edge to the total.\n                circle = min(circle, cir - cw);\n                line = min(line, ln - lw); \n\n                // Three vertex-based lines. Each map out a rhomboid path between four nodes.\n                //\n                // Do the same as above.\n                pnt = vec2[4](tri1.v[(0 + j)%3], mix(tri1.v[(0 + j)%3], tri1.v[(1 + j)%3], .25), \n                              mix(tri1.v[(0 + j)%3], tri1.v[(2 + j)%3], .25), vec2(0));\n                vec2 refDir = mix(pnt[0], pnt[2], .5) - pnt[1];\n                pnt[3] = pnt[1] + length(refDir)*normalize(refDir)*2.;\n\n                p0 = p - pnt[(index2 + 1)%4];\n                vAng = vAng.wzyx;\n                ang = mix(0., vAng[index2], (fract(tm2)));\n                p0 *= rot2(-ang);\n                p1 = (pnt[index2] - pnt[(index2 + 1)%4]);\n                ln = sdLine(p0, vec2(0), p1);\n\n                cir = min(length(p0), length(p0 - p1));  \n              \n                circle2 = min(circle2, cir - cw);\n                line2 = min(line2, ln - lw); \n                \n                \n                // If applicable, update the overall minimum distance value,\n                // then return the correct triangle information.\n                if(tri1.dist<d){\n                    d = tri1.dist;\n                    gT = tri1;\n                    //gT.id = idi + inCentRad(gT.v[0], gT.v[1], gT.v[2]).xy;\n                }\n                \n                \n            } \n        }\n        \n        if(line>1e6) break; // Fake break to help the compiler.\n    \n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return gT;\n}\n\n// A simpler triangle routine to help render the background.\nfloat gTri;\n\nvec4 getTri(vec2 p, float sc){\n \n    \n    // Rectangle stretch.\n    vec2 rect = vec2(2./sqrt(3.), 1)*sc; \n    //const vec2 rect = vec2(.85, 1.15)*scale; \n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x/2./sc, 0); // 12 x .2\n    //p.x += rect.x/2.; \n     \n     p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //float tri = p.x/rect.x < -p.y/rect.y? 1. : 0.;\n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 0. : 1.;\n   \n    p = unskewXY(p, sk);\n    \n    return vec4(p, id);\n    \n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes; \n    \n     \n    // Scaling and translation.\n    const float gSc = 1.;\n    vec2 p = rot2(3.14159/6.)*uv*gSc;// + vec2(0, iTime/24.);//rot2(3.14159/6.)*\n    vec2 oP = p; // Saving a copy for later.\n    \n    // Resolution and scale based smoothing factor.\n    float sf = gSc/iResolution.y;\n    \n    // Sun direction and shadow sample.\n    vec2 sDir = rot2(3.14159/6.)*normalize(vec2(-1));\n    triS gTSh = blocks(p - sDir*.025);\n    \n    // Shadow field values.\n    float lineSh = line, line2Sh = line2, circleSh = circle, circle2Sh = circle2;\n    \n    // Take a function sample. \n    triS gT = blocks(p); \n    \n \n    // Triangle vertices, local coordinates and position-based ID.\n    // With these three things, you can render anything you want.\n    vec2[3] svV = gT.v;\n    vec2 svP = gT.p;\n    vec2 svID = gT.id;\n\n    \n    // Initializing the scene to a dark background color.\n    vec3 bg = vec3(.07);\n    vec3 col = bg;  \n    \n  \n    #ifdef SHOW_CELLS\n    // Triangle edge lines.\n    float ln = 1e5;\n    ln = min(ln, sdLine(svP, svV[0], svV[1]));\n    ln = min(ln, sdLine(svP, svV[1], svV[2]));\n    ln = min(ln, sdLine(svP, svV[2], svV[0]));\n    ln -= .0015; \n     \n    // Render the triangle cell edges.\n    col = mix(col, col*1.6, (1. - smoothstep(0., sf*4.*iRes/450., ln - .0005)));\n    col = mix(col, col*.3, (1. - smoothstep(0., sf*2., ln)));\n    #endif\n    \n \n    // The triangle background pattern.\n    //\n    // Sunken holes.\n    vec2 q = oP;\n    float tSc = 1./2./4.;\n    vec2 offs = vec2(sqrt(3.), 1)/3./16.;\n    vec4 triSh = getTri(q - sDir*.025*tSc, tSc);\n    float dotsSh = length(triSh.xy - offs) - .02;\n    if(gTri<.5) dotsSh = length(triSh.xy + offs) - .02;\n    \n    vec4 tri = getTri(q, tSc); \n    \n    float dots = length(tri.xy - offs) - .02;\n    if(gTri<.5) dots = length(tri.xy + offs) - .02;\n    \n    // Render the sunken holes.\n    col = mix(col, bg*.55, 1. - smoothstep(0., sf*2., dots - .003));\n    col = mix(col, (bg + .03)*(max(dots - dotsSh, 0.)/(.025/8.)*.5 + .5), 1. - smoothstep(0., sf, dots));\n \n    // Raised holes.\n    q = oP; \n    q += vec2(sqrt(3.), 1)/2.*tSc;\n    triSh = getTri(q - sDir*.025*tSc, tSc);\n    dotsSh = length(triSh.xy) - .02;\n    \n    tri = getTri(q, tSc);\n    dots = length(tri.xy) - .02;\n    \n     // Render the raised holes.\n    col = mix(col, bg*.55, 1. - smoothstep(0., sf*2., dots - .003));\n    col = mix(col, 1.3*(bg + .03)*(max(dotsSh - dots, 0.)/(.025/8.)*.5 + .5), 1. - smoothstep(0., sf, dots));\n\n\n    // Render the drop shadow over the background.\n    float shadow = min(min(lineSh, line2Sh), min(circleSh, circle2Sh));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*12., shadow - .006))*.5);\n \n    // Back texture. Not used.\n    //vec3 tx = texture(iChannel0, oP).xyz; tx *= tx;\n    //tx = smoothstep(-.1, .5, tx);\n    //col *= tx*2.;\n    \n    // Color palette.\n    vec3 col1 = vec3(.75, 1, .3);//vec3(.3, 1, .5);//vec3(1, .75, .3)\n    vec3 col2 = vec3(1, .2, .4);//vec3(1, .2, .4);\n    #if PALETTE == 1\n    col1 = vec3(1, .65, .25);\n    col2 = vec3(.75, .35, .15);\n    #elif PALETTE == 2\n    col1 = vec3(.6);\n    col2 = col1;\n    #endif\n     \n    // Render the hexagon line layers -- AO, stroke, color, etc.\n    float sh2 = max(.2 - line2/.006, 0.);\n    sh2 *= max(line2Sh - line2, 0.)/.025 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., line2 - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, line2 - .003));\n    col = mix(col, col2*sh2, 1. - smoothstep(0., sf, line2));\n    //col = mix(col, col*2., 1. - smoothstep(0., sf, line2 + .007)); // Extra shine.\n   \n    // Render the triangle line layers with a higher Z value.\n    float sh = max(.2 - line/.006, 0.);\n    sh *= max(lineSh - line, 0.)/.025 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., line - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, line - .003));\n    col = mix(col, col1*sh, 1. - smoothstep(0., sf, line));\n    //col = mix(col, col*2., 1. - smoothstep(0., sf, line + .007)); // Extra shine.\n    \n    \n    \n    // Silver end points.\n    col1 = vec3(1); col2 = col1;\n    // Gold ends.\n    //col1 = vec3(1.2, .95, .5); col2 = col1;\n    // Silver fluorescent ends.\n    //col1 = mix(col1*3., vec3(1), .65); col2 = mix(col2*4., vec3(1), .65);\n    \n    // Render the hexagonal end points.\n    sf *= 1.5;\n    sh2 = max(.7 - circle2/.016, 0.);\n    sh2 *= max(circle2Sh - circle2, 0.)/.025*.5 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., circle2 - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, circle2 - .003));\n    col = mix(col, col2*sh2, 1. - smoothstep(0., sf, circle2));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*1.5, circle2 + .01));\n   \n    // Render the triangle end points.\n    sh = max(.7 - circle/.016, 0.);\n    sh *= max(circleSh - circle, 0.)/.025*.5 + .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., circle - .003))*.35);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, circle - .003));\n    col = mix(col, col1*sh, 1. - smoothstep(0., sf, circle));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*1.5, circle + .01));\n    \n    \n    // Fake overhead lighting to roughly match the shadows.\n    col *= max(1.25 - length(uv + sDir*.5)*.5, 0.);\n    \n    \n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*1.05;\n    \n    \n    // Rought gamma correction and presentation.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flj3Wm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1839, 1872, 1894, 1894, 1952], [1955, 1983, 2004, 2004, 2067], [2070, 2112, 2171, 2171, 2751], [2754, 2789, 2831, 2857, 3136], [3138, 3169, 3215, 3215, 3293], [3297, 3360, 3388, 3388, 3432], [3434, 3499, 3529, 3667, 3715], [11078, 11078, 11108, 11141, 12110]], "test": "untested"}
{"id": "Nlj3Dw", "name": "Fork noir Helium_ykt 757", "author": "Helium_ykt", "description": "saturation animation (optimization)", "tags": ["saturation"], "likes": 0, "viewed": 209, "published": 3, "date": "1624026831", "time_retrieved": "2024-07-30T19:15:21.225695", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy; \n    vec4 texColor = texture(iChannel0,xy);\n\n    float average = (texColor.r+texColor.g+texColor.b)/5.0;  \n    vec4 grayScale = vec4(texColor.r - average,average,average,1.0); \n    fragColor =  grayScale;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlj3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 309]], "test": "untested"}
{"id": "7tS3Dm", "name": "A bit better grapher", "author": "Maximxls", "description": "from no optimizations to recalculation of some values for every pixel\nnow with threshold based of function\n", "tags": ["math"], "likes": 1, "viewed": 177, "published": 3, "date": "1624017120", "time_retrieved": "2024-07-30T19:15:22.077418", "image_code": "#define xFrom -8.\n#define xTo    8.\n#define yFrom -4.5\n#define yTo    4.5\n\n#define axesThickness 0.03\n\n#define RADIUS 2.\n\nfloat leftSide(float x, float y)\n{\n    return y;\n}\n\nfloat rightSide(float x, float y)\n{\n    return x * sin(x);\n}\n\n// or threshold\nfloat threshold(float x, float y)\n{\n    float z = 2.*atan(abs(sin(x)+x*cos(x)));\n    return 2.+.02*y*y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Size of the screen in coordinate system units\n    vec2 span = vec2(xTo - xFrom, yTo - yFrom);\n    \n    // Pixel in coordinate system\n    vec2 point = vec2(xFrom + uv.x * span.x, yFrom + uv.y * span.y);\n    \n    // Treshold\n    float treshold = abs(threshold(point.x, point.y)) / max(span.x, span.y);\n    \n    // If point is a solution\n    bool sol = abs(leftSide(point.x, point.y) - rightSide(point.x, point.y)) < treshold;\n    \n    // If point is on axes\n    bool axes = abs(point.x) < axesThickness || abs(point.y) < axesThickness;\n    \n    float col = 1.;\n    \n    if (sol || axes) {\n        col = 0.;\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tS3Dm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 156, 156, 172], [174, 174, 209, 209, 234], [236, 252, 287, 287, 357], [359, 359, 416, 471, 1198]], "test": "untested"}
{"id": "stBGDm", "name": "terrible POLAR grapher!!!", "author": "Maximxls", "description": "as far as I know, this is the only polar grapher. Does not wrap angles by default. ", "tags": ["math"], "likes": 0, "viewed": 227, "published": 3, "date": "1624016132", "time_retrieved": "2024-07-30T19:15:22.867306", "image_code": "#define PI 3.14159265359\n\n#define xFrom -16.\n#define xTo    16.\n#define yFrom -9.\n#define yTo    9.\n\n#define tresholdMultiplier 1.\n#define axesThickness      1.\n\n#define RADIUS 3.\n\nfloat leftSide(float r, float t)\n{\n    return r;\n}\n\nfloat rightSide(float r, float t)\n{\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Size of the screen in coordinate system units\n    vec2 span = vec2(xTo - xFrom, yTo - yFrom);\n    \n    // Treshold\n    vec2 tresholds = span / iResolution.xy;\n    float treshold = min(tresholds.x, tresholds.y) * tresholdMultiplier;\n    \n    // Pixel in cartesian coordinate system\n    vec2 point = vec2(xFrom + uv.x * span.x, yFrom + uv.y * span.y);\n    \n    // If point is on axes\n    float axesTreshold = treshold / tresholdMultiplier * axesThickness;\n    bool axes = abs(point.x) < axesTreshold || abs(point.y) < axesTreshold;\n    \n    // convert into polar\n    point = vec2(sqrt(point.x * point.x + point.y * point.y), atan(point.y, point.x));\n    \n    // make angles positive\n    if (point.y < 0.) {\n        point.y += 2. * PI;\n    }\n    \n    // If point is a solution\n    bool sol = abs(leftSide(point.x, point.y) - rightSide(point.x, point.y)) < treshold;\n    \n    float col = 1.;\n    \n    if (sol || axes) {\n        col = 0.;\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 215, 215, 231], [233, 233, 268, 268, 284], [286, 286, 343, 393, 1449]], "test": "untested"}
{"id": "slB3Dw", "name": "natural log fractal 2", "author": "peabrainiac", "description": "Yet another shader based on the fractal generated by iterating log(-z)/log(z), but this time zooming out to infinity, forever.", "tags": ["fractal", "zoom"], "likes": 7, "viewed": 301, "published": 3, "date": "1624005318", "time_retrieved": "2024-07-30T19:15:23.695092", "image_code": "/*\n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org/>\n */\n#define PI 3.14159265358979323846264\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    float zoom = 0.3*iTime*iTime/(iTime+2.0);\n    vec2 c = (fragCoord-0.5*iResolution.xy)/length(iResolution.xy)+vec2(0.0000001);\n    vec2 dc = vec2(1.0/length(iResolution.xy),0.0);\n    vec2 z = c;\n    vec2 dz = dc;\n    float s = 1.0/exp2(16.0);\n    int i2 = 0;\n    float total = 0.0;\n    \n    vec2 z2 = vec2(0.5*log(dot(z,z))+zoom,atan(z.y,z.x));\n    vec2 z3 = vec2(z2.x,z2.y-PI*sign(z2.y));\n    vec2 z4 = z2-z3;\n    vec2 z5 = vec2(z2.x*z2.x-z2.y*z2.y,2.0*z2.x*z2.y);\n    z5 = vec2(z.x*z5.x-z.y*z5.y,dot(z,z5.yx));\n    z4 = vec2(dot(z4,z5),z4.y*z5.x-z4.x*z5.y)/dot(z5,z5);\n    z = vec2(dot(z2,z3),z3.y*z3.x-z3.x*z2.y)/dot(z2,z2);\n    dz = vec2(dz.x*z4.x-dz.y*z4.y,dot(dz,z4.yx));\n    for (int i=0;i<999;i++){\n        vec2 z2 = vec2(0.5*log(dot(z,z)),atan(z.y,z.x));\n        vec2 z3 = vec2(z2.x,z2.y-PI*sign(z2.y));\n        vec2 z4 = z2-z3;\n        vec2 z5 = vec2(z2.x*z2.x-z2.y*z2.y,2.0*z2.x*z2.y);\n        z5 = vec2(z.x*z5.x-z.y*z5.y,dot(z,z5.yx));\n        z4 = vec2(dot(z4,z5),z4.y*z5.x-z4.x*z5.y)/dot(z5,z5);\n        z = vec2(dot(z2,z3),z3.y*z3.x-z3.x*z2.y)/dot(z2,z2);\n        dz = vec2(dz.x*z4.x-dz.y*z4.y,dot(dz,z4.yx));\n        while(dot(dz,dz)>s*dot(z,z)){\n            total += clamp(2.0*(0.7-length(z))*(0.7-length(z)),0.0,1.0);\n            s *= 2.0;\n            i2++;\n            if (i2>=20){\n                fragColor = vec4(vec3(total/float(i2)),1.0);\n                return;\n            }\n\t\t}\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slB3Dw.jpg", "access": "api", "license": "unlicense", "functions": [[1327, 1327, 1382, 1382, 2797]], "test": "untested"}
{"id": "tltcRM", "name": "Fractal 59_gaz", "author": "gaz", "description": "3d", "tags": ["fractal"], "likes": 16, "viewed": 466, "published": 3, "date": "1624005089", "time_retrieved": "2024-07-30T19:15:24.571749", "image_code": "// soundin shader by FabriceNeyret2\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n} // EOL soundin shader\n\n\n// +++++++++++++++++++++++\n\nvoid rot(inout vec3 p,vec3 a,float r){\n\ta=normalize(a);\n\tp=mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)  ;\n}\n\n#define sabs(p) sqrt((p)*(p)+1e-5)\n#define smin(a,b) (a+b-sabs(a-b))*.5\n#define smax(a,b) (a+b+sabs(a-b))*.5\n\nfloat dodec(vec3 p,float r){\n\tfloat G=sqrt(5.)*.5+.5;\n\tvec3 n=normalize(vec3(G,1,0));\n\tfloat d=0.;\n    p=sabs(p);\n    d=smax(d,dot(p,n));\n    d=smax(d,dot(p,n.yzx));\n    d=smax(d,dot(p,n.zxy));\n\treturn d-r;\n}\n\nfloat icosa(vec3 p,float r){\n\tfloat G=sqrt(5.)*.5+.5;\n\tvec3 n=normalize(vec3(G,1./G,0));\n\tfloat d=0.;\n    p=sabs(p);\n    d=smax(d,dot(p,n));\n    d=smax(d,dot(p,n.yzx));\n    d=smax(d,dot(p,n.zxy));\n\td=smax(d,dot(p,normalize(vec3(1))));\n    return d-r;\n}\n\n#define hash(p)fract(sin(p*12345.5))\n\nfloat stone(vec3 p)\n{\n  p.y-=iTime;\n    float c=2.;\n    vec3 e=floor(p/c);\n    e = sin(11.0*(2.5*e+3.0*e.yzx+1.345)); \n    p-=e*.6;\n    p=mod(p,c)-c*.5;\n    rot(p,hash(e+166.887)-.5,iTime*1.5); \n    if(hash(dot(e,vec3(.234,.24,98))+16776.887)<.5)\n    {\n        return min(.6,icosa(p,.12));    \n    }else{\n        return min(.6,dodec(p,.12));    \n    \n    }\n}\n\nfloat Scale;\nfloat obj(vec3 p){\n\trot(p,vec3(.5*cos(iTime*.2),2.*sin(iTime)*.4,sin(iTime*.5)),iTime*.5);\n\tfloat s=3.5;\n\tp=abs(p);\n\tvec3  off=p*mix(3.,45.,smoothstep(-.5,.97,cos(iTime*.5)));\n\tfor (int i=0; i<7; i++){\n        p=1.-abs(abs(p-2.)-1.); \n    \tfloat r=-3.*clamp(.68*max(1.2/dot(p,p),.7),0.,3.);\n        s*=r;\n\t\tp*=r;\n        p+=off;\n    }\n    s=abs(s);\n    Scale=s;\n    float a=18.;\n    p-=clamp(p,-a,a);\n\treturn length(cross(p,normalize(vec3(1,3,10))))/s;\n}\n\nfloat map(vec3 p){\n    float d=dot(p-vec3(0,-3,0),vec3(0,1,0))-1.5;\n    d=min(d,dot(p-vec3(0,0,-5),vec3(0,0,1)));\n    d= min(d,stone(p));\n    return min(d,obj(p));\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.005;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<200;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 randVec(float s)\n{\n    vec2 n=hash(vec2(s,s+215.3));\n    return vec3(cos(n.y)*cos(n.x),sin(n.y),cos(n.y)*sin(n.x));\n}\n\nvec3 randCurve(float t,float n)\n{\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++){\n        p+=randVec(n+=365.)*sin((t*=1.3)+sin(t*.6)*.5);      \n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // call soundin shader \n\tif (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(0.05,0.1))*10.0);if(c>=0.){fragColor=vec4(c);return;}}\n\t\n    // ++++++++++\n\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,4.);\n    vec3 rd = normalize(vec3(uv,-2.0));\n    vec3 col = vec3(.7,.1,.0)*hash(dot(uv*3.,vec2(.1234,.566)));\n\tconst float maxd = 30.0;\n    float t = march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=cos(vec3(1,5,9)+log(Scale)*.5)*3.5+0.5;\n        col=vec3(1);\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(5,28,10)*.5;\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li),.5,1.);\n        float sha = calcShadow(lightPos,-li,len);\n        col *= max(sha*dif, 0.4);\n        float rimd = pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn = rimd+2.2*(1.-rimd);\n    \tcol *= frn*.9;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += 2.*vec3(0.9,0.5,0.1)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 80.0);      \n        col = mix(vec3(.2,.3,.6),col,exp(-t*t*.002));\n    }\n    \n    vec3 pos;\n    for(float i=1.;i<250.;i++)\n    {\n        vec3 p=(vec3(hash(i*23.1234),hash(i*56.1234),hash(i*78.1234))*2.-1.)*vec3(5,1,3);\n        p+=randCurve(iTime*.5+hash(i*2256.1234)*1000.,(i+67.234)*345.99)*.5;\n        if(dot(rd,p-ro)<t)\n        {\n            float L=length(cross(rd,p-ro));\n            float weight=exp(-L*L*5.)*exp(-t*t*.01);\n            col = mix(col, vec3(1), weight*.4);\t\t\t\n        }\n    }\n    \n    col = pow(col,vec3(2.));\n    fragColor.xyz = col;\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// +++++++++++++++++++++++\n\n#define bpm 95.\n#define key D\n#define scale Major_scale\n\n// == seqence == +++++++++++++\n\nfloat NOTETIME;\nint NUMBER;\nfloat VEROCITY;\n\nfloat BEAT = 30. / bpm; // 8 Beat\nfloat SUM;\nfloat TIME;\n\nvoid seq(int number, float noteValue, float velocity){\n    float tmp = noteValue * BEAT;\n    if(SUM <= TIME){\n        NOTETIME = min(tmp, TIME - SUM);\n        NUMBER = number;\n        VEROCITY = velocity;\n        if(number == 255){\n            NOTETIME = 100.;\n            NUMBER = 0;\n        }\n    }\n    SUM += tmp;\n}\n\n#define Q(p,v) seq(p,float(v), 1.);\n#define S(p,v,s) seq(p,float(v), s);\n#define T(v) seq(0,float(v), 1.);\n#define U(v,s) seq(0,float(v), s);\n#define R(v) seq(255,float(v), 1.);\n\n#define REP(n) TIME=mod(time, BEAT * float(n));\n#define FOR(n) for(int i=0;i<n;i++){\n#define END }\n#define RESET SUM = 0.;\n\n// \n\n// ++ Chord fuctions +++++++++++++++++++++\nint packChord(int root, ivec3 t, int inv)\n{\n    int[3] a;\n    for(int i=0;i<3;i++){\n       a[i]=root+int[](t[1]-12,t[2]-12,t[0],t[1],t[2])[i+2-inv];\n    }\n    return a[0]+(a[1]<<7)+(a[2]<<14)+(127<<21);\n}\n\nint packChord(int root, ivec4 t, int inv)\n{\n    int[4] a;\n    for(int i=0;i<4;i++){\n       a[i]=root+int[](t[1]-12,t[2]-12,t[3]-12,t[0],t[1],t[2],t[3])[i+3-inv];\n    }\n    return a[0]+(a[1]<<7)+(a[2]<<14)+(a[3]<<21);\n}\n\n#define unpack4x7(i) ivec4(i&127,i>>7&127,i>>14&127,i>>21&127)\n\n// +++++++++++++++++++++\n\n// OSC\n#define osc_sin(x) sin((x)*6.2832)\n#define osc_saw(x) (1.0-fract(x)*2.0)\n#define osc_sqr(x) sign(0.5-fract(x))\n#define osc_tri(x) asin(sin((x)*6.2832))/1.5708\n\nfloat note2freq(int n){\n  return 440.*exp2((float(n)-69.)/12.);\n}\n\n// Note numbers\n#define C  60\n#define Cs 61\n#define D  62\n#define Ds 63\n#define E  64\n#define F  65\n#define Fs 66\n#define G  67\n#define Gs 68\n#define A  69\n#define As 70\n#define B  71\n#define UP +12\n#define DN -12\n\n\n//Chord types\n#define _M    ivec3(0,4,7)\n#define _m    ivec3(0,3,7)\n#define _6    ivec4(0,4,7,9)\n#define _7    ivec4(0,4,7,10)\n#define _M7   ivec4(0,4,7,11)\n#define _m7   ivec4(0,3,7,10)\n#define _add9 ivec4(0,4,7,14)\n#define _sus2 ivec3(0,2,7)\n#define _sus4 ivec3(0,5,7)\n#define _dim  ivec3(0,3,6)\n// #define _dim  ivec4(1,4,7,_)\n#define _aug  int[](0,4,8)\n\n// Scale\n#define Major_scale          int[](0,2,4,5,7,9,11)\n#define Minor_scale          int[](0,2,3,5,7,8,10)\n#define Natural_minor_scale  int[](0,2,3,5,7,8,10)\n#define Harmonic_minor_scale int[](0,2,3,5,7,8,11)\n#define Melodic_minor_scale  int[](0,2,3,5,7,9,11)\n\n#define P(n) key + scale[(n-1)%7] + (n-1)/7*12\n#define H(r,t,i) packChord(key+scale[r-1],t,i)\n\n// ++ sound srouce ++++++++++++++++\n// FM operator -> vec4(Level,Maltiple,Detune,Envelope),operator\n#define FM(a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p) mat4 DAT=mat4(a,b,c,d, e,f,g,h, i,j,k,l, m,n,o,p);\n\n#define OP(a,i) a.x*osc_sin(a.y*exp2(log2(f)+a.z/12.)*t+i)*exp(-t*5./a.w)\n\n#define O1(i) OP(DAT[0], i)\n#define O2(i) OP(DAT[1], i)\n#define O3(i) OP(DAT[2], i)\n#define O4(i) OP(DAT[3], i)\n    \n#define A0(F) O4(O3(O2(O1(F*O1(0.)))))\n#define A1(F) O4(O3(O2(0.)+O1(F*O1(0.))))\n#define A2(F) O4(O3(O2(0.))+O1(F*O1(0.)))\n#define A3(F) O4(O3(0.)+O2(O1(F*O1(0.))))\n#define A4(F) O4(O3(0.))+O2(O1(F*O1(0.)))\n#define A5(F) O4(O1(F*O1(0.)))+O3(O1(F*O1(0.)))+O2(O1(F*O1(0.)))\n#define A6(F) O4(0.)+O3(0.)+O2(O1(F*O1(0.)))\n#define A7(F) O4(0.)+O3(0.)+O2(0.)+O1(F*O1(0.))\n\n \nfloat gNoize(float t, float a, float b, float c){\n    float g=fract(sin((t+exp2(a))*exp2(b))*exp2(c))+6.0;\n    return exp(-0.08*g*g) *40.0-1.;\n}\n\nfloat kick(float t){\n   return (sin(pow(1.0-min(1.0,t*3.5),15.0)*55.0+1.2)*exp(-t*3.0)\n    +0.3*sign(0.5-fract(70.0*t))*exp(-t*25.0))\n    *cos(120.0*exp(-t*2.0));\n}\n\nfloat snare(float t){\n    float n=gNoize(t,0.,10.,10.)*exp(-t*10.);\n    float f=t*160.;\n    float m2=.3*osc_tri(1.2*f)*exp(-t*3.);\n    float m1=.05*osc_sin(10.*f+m2)*exp(-t*3.);\n    float c=osc_sin(f+m1)*exp(-t*15.);\nreturn n+c;\n}\n\nfloat hihat(float t)\n{\n    return gNoize(t,0.,10.,18.)*exp(-t*15.);\n}\n\nfloat lead(float t, float f)\n{\n    FM(\n      .2, 1., 0., 2.,\n      .4, 2., .1, 3.,\n      .5, 3., 0., 3.,\n      .7, 1., 0., 3.\n    );\n    return A4(5.0);\n}\n\nfloat piano(float t,float f){\n    float g=0.,a,b=0.;\n    f*=t;\n    for(float j=1.;j<8.;j++){\n        b+=a=exp(-j*.5);\n        g+=a*osc_sin(f*j)*exp(-t*1.5/(1.-j*.1));\n    }\n    g*=1.+1.5*exp(-5.*t);\n    return g/b;\n}\n\nfloat base(float t,float f)\n{\n\tf *= t;\n  \treturn clamp((\n        5.0*osc_sin(f)\n        + 2.0*osc_sin(f*2.0)\n        + osc_tri(f*3.0)\n    \t)/4.0,-1.0,1.0)*exp(-5.0*t);\n}\n\n\n// ++ tracks +++++++++++++++++++++++++\n\n// kick\nfloat track1(float time){\n    RESET\n    REP(8)\n    T(2)T(2)T(2)T(2)\n    \n    return kick(NOTETIME);  \n}\n\n// snare\nfloat track2(float time){\n  RESET\n  REP(8*4)\n  FOR(7)\n    R(2)T(2)\n  END\n  R(1)T(1)T(1)T(1)\n  \n  return snare(NOTETIME);  \n}\n\n// hihat\nfloat track3(float time){\n  RESET\n  REP(8)\n  T(1)T(1)U(1, 2.)T(1)\n  T(1)T(1)U(1, 2.)T(1)\n  \n  return hihat(NOTETIME);  \n}\n\nfloat track4(float time, out ivec4 chord){\n    \n  RESET\n  REP(8*4)\n  Q(H(4,_M7,0),8)\n  Q(H(5,_7,0),8)\n  Q(H(3,_m7,0),8)\n  Q(H(6,_m7,0),8)\n  \n  chord = unpack4x7(NUMBER);\n  float gain=0.;\n  for(int i=0;i<4;i++){\n    if(chord[i]<127)\n        gain += 0.3*piano(NOTETIME,note2freq(chord[i]-12));\n  }\n  return gain;  \n}\n\nfloat track5(float time, ivec4 chord){\n    RESET\n    REP(4)\n    Q(chord[0]-24, 1)\n    Q(chord[0]-12, 1)\n    Q(chord[0]-24, 1)\n    Q(chord[0]-12, 1)\n\n    return base(NOTETIME,note2freq(NUMBER));\n}\n\nfloat track6(float time){\n    RESET\n    REP(32)\n    Q(1,1)\n    Q(5,2)\n    Q(6,1)\n    Q(8,1)\n    Q(2,2)\n    Q(3,1)\n    Q(4,1)\n    Q(1,1)\n    Q(5,2)\n    Q(6,1)\n    Q(8,1)\n    Q(2,2)\n    Q(3,1)\n    Q(5,1) \n    Q(1,1)\n    Q(5,2)\n    Q(6,1)\n    Q(8,1)\n    Q(2,2)\n    Q(3,1)\n    Q(4,1)\n    Q(1,1)\n    Q(5,2)\n    Q(6,1)\n    Q(8,1)\n    Q(2,2)\n    Q(6,1)\n    Q(3,1)\n \n    return lead(NOTETIME, note2freq(P(NUMBER)));\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 gain = vec2(0);\n    gain += vec2(.2)* track1(time); // kick\n    gain += vec2(.2)* track2(time); // snare\n    gain += vec2(.2)* track3(time); // hihat\n    ivec4 chord;\n    gain += vec2(.2)* track4(time, chord); // chord\n    gain += vec2(.15)* track5(time, chord); // base\n    gain += vec2(.1)* track6(time); // lead\n    \n    return gain;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 300, 347, 526], [579, 579, 617, 617, 685], [797, 797, 825, 825, 1005], [1007, 1007, 1035, 1035, 1259], [1299, 1299, 1320, 1320, 1657], [1672, 1672, 1690, 1690, 2126], [2128, 2128, 2146, 2146, 2293], [2295, 2295, 2321, 2321, 2473], [2475, 2475, 2529, 2529, 2696], [2698, 2698, 2750, 2750, 2833], [2835, 2835, 2858, 2858, 2957], [2959, 2959, 2992, 2992, 3127], [3129, 3129, 3185, 3214, 4876]], "test": "untested"}
{"id": "7l23D1", "name": "natural log fractal", "author": "peabrainiac", "description": "Complex natural log fractal found on https://www.youtube.com/watch?v=VqmsaW9SXbA.", "tags": ["fractal", "interactive", "zoomable"], "likes": 21, "viewed": 414, "published": 3, "date": "1624003824", "time_retrieved": "2024-07-30T19:15:25.335706", "image_code": "// Fork of \"fractal interiors\" by peabrainiac. https://shadertoy.com/view/fd23R3\n// 2021-06-16 16:00:38\n// Original video: https://www.youtube.com/watch?v=VqmsaW9SXbA\n\n/*\n * A fractal I found on youtube a while ago and found quite interesting.\n * It is generated by iterating z'=log(-z)/log(z), and coloring each point\n * based on how quickly its derivative grows (since the orbit itself never\n * actually diverges to infinity).\n *\n * The shader displays an animation by default, but you can also explore\n * the fractal on your own by using WASD and the up and down arrow keys.\n * \n * If you want to dig into the code, Buffer A contains the actual fractal-\n * related code, while Buffer B contains all of the controls, together\n * with a bunch of code that is currently unused and has just been copied\n * over from one of my previous shaders.\n * This whole piece of code is licensed under the unlicense (see below),\n * so feel free to fork and edit it as you like.\n * \n *  - - - - -\n * \n * This is free and unencumbered software released into the public domain.\n * \n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n * \n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org/>.\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 color(vec2 c, vec2 dc);\n\nfloat fractal(in vec2 c, in vec2 dc, in int iter, in vec2 param);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    if (texelFetch(iChannel1,ivec2(0),0).x==0.0){\n        // if the update flag in buffer B is not set, simply keep the old value\n        fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    }else{\n        vec3 pos = texelFetch(iChannel1,ivec2(2,0),0).xyz;\n        vec2 dc = vec2(10.0/(length(iResolution)*pos.z),0.0);\n        vec2 c = pos.xy+dc.x*vec2(1.,-1.)*(fragCoord-iResolution.xy*0.5);\n        fragColor = vec4(color(c,dc),1.0);\n    }\n}\n\n// computes the brightness the pixel at a given fractal coordinate should have\nvec3 color(vec2 c, vec2 dc){\n    vec3 config = texelFetch(iChannel1,ivec2(1,0),0).xyz;\n    int formula = int(config.x);\n    float param = config.y;\n    int iter = int(config.z);\n    if (formula!=-1){\n        return vec3(fractal(c,dc,iter,vec2(cos(.7*sin(param)),sin(0.7*sin(param)))));\n    }else{\n        return vec3(0.0);\n    }\n}\n\nfloat fractal(in vec2 c, in vec2 dc, in int iter, in vec2 param){\n    vec2 z = c;\n    vec2 dz = dc;//vec2(1.0,0.0);\n    for (int i=0;i<iter&&dot(dz,dz)<0.5*dot(z,z);i++){\n        //vec2 z2 = clog(z);\n        //vec2 z3 = vec2(z2.x,z2.y-PI*sign(z2.y));\n        //vec2 z4 = z2-z3;\n        //vec2 z5 = cmul(z,cmul(z2,z2));\n        //z4 = cdiv(z4,z5);\n        //z = cdiv(z3,z2);\n        //dz = cmul(dz,z4);\n        vec2 z2 = vec2(0.5*log(dot(z,z)),atan(z.y,z.x));\n        vec2 z3 = vec2(z2.x,z2.y-PI*sign(z2.y));\n        vec2 z4 = z2-z3;\n        vec2 z5 = vec2(z2.x*z2.x-z2.y*z2.y,2.0*z2.x*z2.y);\n        z5 = vec2(z.x*z5.x-z.y*z5.y,dot(z,z5.yx));\n        z4 = vec2(dot(z4,z5),z4.y*z5.x-z4.x*z5.y)/dot(z5,z5);\n        z = vec2(dot(z2,z3),z3.y*z3.x-z3.x*z2.y)/dot(z2,z2);\n        dz = vec2(dz.x*z4.x-dz.y*z4.y,dot(dz,z4.yx));\n    }\n    return 2.0*(0.7-length(z))*(0.7-length(z));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n * stored values, in order:\n *  - refresh flag, animation flag, reset flag\n *  - formula id, formula param, iterations\n *  - X, Y, zoom\n */\nconst vec3[] defaultValues = vec3[](vec3(1.0,1.0,0.0),vec3(0.0,0.0,500.0),vec3(0.0,0.0,1.0));\n\nfloat keysDown();\nint keyState(int key);\nivec4 keyStates(int key1, int key2, int key3, int key4);\nint keyPressed(int key);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 p = ivec2(fragCoord);\n    if (p.y>0||p.x>=3){\n        discard;\n    }else if (iFrame==0){\n        fragColor = vec4(defaultValues[p.x],1.0);\n    }else{\n        fragColor = texelFetch(iChannel0,p,0);\n        if (p==ivec2(0)){\n            // flag updates\n            float keys = keysDown();\n            if (fragColor.y==1.0){\n                if (keys/*+iMouse.x+iMouse.y*/>0.0){\n                    // animation end because of user input\n                    fragColor.xyz = vec3(1.0,0.0,1.0);\n                }\n            }else{\n                //refresh flag update\n                fragColor.x = min(1.0,keys+step(mod(float(iFrame),30.0),0.0));\n                fragColor.z = 0.0;\n            }\n        }else if(p==ivec2(1,0)){\n            // formula & iteration changes\n            vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n            fragColor.x = mod(fragColor.x+float(keyPressed(KEY_E)-keyPressed(KEY_Q)),6.0);\n            if (flags.y==1.0){\n                // animation\n                fragColor.y = 0.15*iTime*iTime/(iTime+2.0);\n            }else{\n                if (flags.z==1.0){\n                    fragColor.y = 0.0;\n                }\n                // normal controls\n                float zoom = texelFetch(iChannel0,ivec2(2,0),0).z;\n                float paramChange = iTimeDelta/zoom*float(keyState(KEY_RIGHT)-keyState(KEY_LEFT));\n                fragColor.y = mod(fragColor.y+paramChange,2.0*PI);\n                fragColor.z += min(100.0,fragColor.z*(pow(2.0,iTimeDelta*float(keyState(KEY_R)-keyState(KEY_F)))-1.0));\n            }\n        }else if(p==ivec2(2,0)){\n            // zoom & position changes\n            vec3 flags = texelFetch(iChannel0,ivec2(0),0).xyz;\n            if (flags.y==1.0){\n                // animation\n                float theta = 0.3*iTime*iTime/(iTime+2.0);\n                float a = 0.5*theta-0.25*PI;\n                a = cos(a-0.5*sin(a));\n                float b = 1.0-abs(a);\n                b = b*b;\n                a = sign(a)*(1.0-b*b*b*b*b);\n                a = 0.5+0.5*a;\n                fragColor.xy = (0.35+a*1.25)*vec2(-sin(theta),-cos(theta));//+vec2((a-1.0)*0.125,0.0);\n                fragColor.z = 0.75*(4.0-3.0*a)*(1.0+3.0*(iTime*iTime)/((iTime*iTime)+5.0));\n                //fragColor.z = exp(3.0*cos(a));\n            }else{\n                if (flags.z==1.0){// reset flag\n                    //fragColor.xyz = vec3(-0.5,-0.5,2.0);\n                }\n                // normal controls\n                fragColor.xy -= 2.0*iTimeDelta*vec2(float(keyState(KEY_A)-keyState(KEY_D)),float(keyState(KEY_W)-keyState(KEY_S)))/fragColor.z;\n                float zoomChange = iTimeDelta*float(keyState(KEY_UP)-keyState(KEY_DOWN));\n                fragColor.z *= pow(2.0,zoomChange);\n            }\n        }\n    }\n}\n\nfloat keysDown(){\n    float temp = dot(vec4(keyStates(KEY_UP,KEY_RIGHT,KEY_DOWN,KEY_LEFT)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_W,KEY_A,KEY_S,KEY_D)),vec4(1.0));\n    temp += dot(vec4(keyStates(KEY_Q,KEY_E,KEY_R,KEY_F)),vec4(1.0));\n    return temp;\n}\n\nint keyState(int key){\n    return int(texelFetch(iChannel1,ivec2(key,0),0).x);\n}\n\nivec4 keyStates(int key1, int key2, int key3, int key4){\n    return ivec4(keyState(key1),keyState(key2),keyState(key3),keyState(key4));\n}\n\nint keyPressed(int key){\n    return int(texelFetch(iChannel1,ivec2(key,1),0).x);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_E = 69; // nice.\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_F = 70;\n\nconst float PI = 3.14159265358979323846264;\n\n// taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 complexColor(vec2 z){\n    float t = length(z);\n    t = 2.0*t/(t+1.0);\n    float t2 = 1.0-min(1.0,2.0-t);\n    float t3 = 1.0-min(1.0,t);\n    return hsv2rgb(vec3(0.5+(0.5/PI)*atan(-z.y,-z.x),1.0-t2*t2,1.0-t3*t3));\n}\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(dot(a,vec2(1.0,-1.0)*b),dot(a,b.yx));\n}\n\nvec2 cdiv(vec2 a, vec2 b){\n    return vec2(dot(a,b),dot(a.yx,vec2(1.0,-1.0)*b))/dot(b,b);\n}\n\nvec2 clog(vec2 a){\n    return vec2(0.5*log(dot(a,a)),atan(a.y,a.x));\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l23D1.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[168, 2275, 2329, 2329, 2389]], "test": "untested"}
{"id": "stS3Ww", "name": "Ellipse Extraction", "author": "oneshade", "description": "Extracting the major and minor axes from an ellipse in the general quadric form. There are two versions, one that uses trig and one that doesn't. The one with trig is simpler but I'm unsure in terms of performance.", "tags": ["2d", "quadric", "ellipse", "conversion", "extraction"], "likes": 3, "viewed": 196, "published": 3, "date": "1623991446", "time_retrieved": "2024-07-30T19:15:26.099664", "image_code": "// See the desmos graphs where I worked most of this out:\n// Computing major and minor axes: https://www.desmos.com/calculator/12t322u7xa\n// Converting ellipse with center and axes to a general quadric: https://www.desmos.com/calculator/tialwuz5wh\n// I was thinking of using this to parametrize the intersection\n// between a plane and an ellipsoid\n\n// Drawing utility\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Main stuff\nstruct Quadric { float a; float b; float c; float d; float e; float f; };\nstruct Ellipse { vec2 center; mat2 axes; };\n\nfloat evalQuadric(in vec2 p, in Quadric q) {\n    return q.a * p.x * p.x + q.b * p.y * p.y + q.c * p.x * p.y +\n           q.d * p.x + q.e * p.y + q.f;\n}\n\nvec2 evalQuadricPrime(in vec2 p, in Quadric q) {\n    return vec2(2.0 * q.a * p.x + q.c * p.y + q.d,\n                2.0 * q.b * p.y + q.c * p.x + q.e);\n}\n\n#if 0 // Trig version\nEllipse parametrizeEllipse(in Quadric q) {\n    float cx = 2.0 * q.b * q.d - q.c * q.e, cy = 2.0 * q.a * q.e - q.c * q.d;\n    float s = q.c * q.c - 4.0 * q.a * q.b;\n\n    float g = ((q.a * cx * cx + q.b * cy * cy + q.c * cx * cy) / s +\n                q.d * cx + q.e * cy) / s + q.f;\n\n    float a = 0.5 * atan(q.b - q.a, q.c);\n    vec2 k = vec2(cos(a), sin(a));\n    float i = k.x - k.y, j = k.x + k.y;\n\n    float ii = i * i, jj = j * j, ij = q.c * i * j;\n    vec2 u = vec2( i, j) * sqrt(-g / (q.a * ii + q.b * jj + ij));\n    vec2 v = vec2(-j, i) * sqrt(-g / (q.a * jj + q.b * ii - ij));\n\n    return Ellipse(vec2(cx, cy) / s, mat2(u, v));\n}\n\n#else // Trigless version\nEllipse parametrizeEllipse(in Quadric q) {\n    float cx = 2.0 * q.b * q.d - q.c * q.e, cy = 2.0 * q.a * q.e - q.c * q.d;\n    float s = q.c * q.c - 4.0 * q.a * q.b;\n\n    float g = ((q.a * cx * cx + q.b * cy * cy + q.c * cx * cy) / s +\n                q.d * cx + q.e * cy) / s + q.f;\n\n    float ba = q.b - q.a, r = ba / q.c;\n    float ca = 0.5 * sign(q.c) / sqrt(1.0 + r * r);\n    float ch = sqrt(0.5 + ca), sh = sqrt(0.5 - ca) * sign(ba);\n    float i = ch - sh, j = ch + sh;\n\n    float ii = i * i, jj = j * j, ij = q.c * i * j;\n    vec2 u = vec2( i, j) * sqrt(-g / (q.a * ii + q.b * jj + ij));\n    vec2 v = vec2(-j, i) * sqrt(-g / (q.a * jj + q.b * ii - ij));\n\n    return Ellipse(vec2(cx, cy) / s, mat2(u, v));\n}\n#endif\n\nQuadric implicitizeEllipse(in Ellipse e) {\n    mat2 inv = inverse(e.axes);\n    vec2 ce = inv * e.center;\n    return Quadric(dot(inv[0], inv[0]),\n                   dot(inv[1], inv[1]),\n                   2.0 * dot(inv[0], inv[1]),\n                   -2.0 * dot(inv[0], ce),\n                   -2.0 * dot(inv[1], ce),\n                   dot(ce, ce) - 1.0);\n}\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.05, sdIsosceles(p - vec2(0.0, m), 0.2, 0.35));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 8.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    vec3 color = vec3(0.15);\n    float unit = 16.0 / iResolution.y;\n\n    // Ellipse position and axes for testing\n    vec2 pos = vec2(3.0 * cos(iTime), sin(2.0 * iTime));\n    vec2 ab = vec2(2.0 + cos(iTime), 2.0 + sin(iTime));\n    float rot = iTime - 2.0 * sin(0.5 * iTime);\n\n    // Rotate and scale\n    vec2 u = vec2(cos(rot), sin(rot));\n    vec2 v = vec2(-u.y, u.x) * ab.y;\n    u *= ab.x;\n\n    // Add some shear\n    u.y += 0.5 + cos(iTime);\n    v.x += 0.5 - sin(iTime);\n\n    // Implicitize the ellipse and then extract the center and axes\n    // This makes it possible to make an identity check\n    Quadric q = implicitizeEllipse(Ellipse(pos, mat2(u, v)));\n    Ellipse e = parametrizeEllipse(q);\n\n    // Grid\n    float spacing = 0.5, hSpacing = 0.5 * spacing;\n    drawSDF(abs(mod(uv.x + hSpacing, spacing) - hSpacing) - 0.001, vec3(0.5));\n    drawSDF(abs(mod(uv.y + hSpacing, spacing) - hSpacing) - 0.001, vec3(0.5));\n\n    drawSDF(abs(uv.x) - 0.01, vec3(0.6, 0.0, 0.0));\n    drawSDF(abs(uv.y) - 0.01, vec3(0.0, 0.0, 0.6));\n\n    // Quadric\n    drawSDF(evalQuadric(uv, q) / length(evalQuadricPrime(uv, q)), vec3(0.0, 0.0, 1.0));\n\n    // Draw an outline using the extracted ellipse parameters\n    uv -= e.center;\n    float tStep = 0.2;\n    float coStep = cos(tStep), siStep = sin(tStep);\n    mat2 stepMat = mat2(coStep, siStep, -siStep, coStep);\n    vec2 prev = vec2(1.0, 0.0);\n    for (float t=0.0; t < 6.28; t += tStep) {\n        vec2 cur = stepMat * prev;\n        drawSDF(sdLine(uv, e.axes * prev, e.axes * cur) - 0.01, vec3(1.0));\n        prev = cur;\n    }\n\n    // Original axes\n    drawSDF(abs(dot(uv, normalize(vec2(-u.y, u.x)))) - 0.02, vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(dot(uv, normalize(vec2(-v.y, v.x)))) - 0.02, vec3(0.0, 1.0, 0.0));\n\n    // Computed axes and center\n    drawSDF(sdVectorArrow(uv, e.axes[0]), vec3(1.0, 0.5, 0.0));\n    drawSDF(sdVectorArrow(uv, e.axes[1]), vec3(0.8, 1.0, 0.0));\n    drawSDF(length(uv) - 0.1, vec3(1.0, 0.8, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stS3Ww.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[582, 582, 626, 626, 733], [735, 735, 783, 783, 888], [2297, 2297, 2339, 2339, 2654], [2656, 2664, 2711, 2711, 2819], [2821, 2821, 2866, 2866, 2934], [2936, 2936, 2990, 2990, 3266], [3268, 3268, 3311, 3311, 3498], [3500, 3500, 3555, 3555, 5739]], "test": "untested"}
{"id": "ftBGWm", "name": "Schwarzschild black hole", "author": "michael0884", "description": "Simulating light rays in an effective potential", "tags": ["camera"], "likes": 8, "viewed": 563, "published": 3, "date": "1623978505", "time_retrieved": "2024-07-30T19:15:27.056106", "image_code": "vec3 saturate(vec3 c)\n{\n    return tanh(pow(c,vec3(0.55)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(saturate(acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 8.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = normalize(vec3(1))*5.1;\n        ca = aa2q( normalize(vec3(0,1,-0.3)), 1.17);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}", "buffer_b_code": "#define SPP 1\n\n\nconst float aperture_size = 0.0;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    vec2 apert_cent = -0.*uv;\n    \n    vec2 ap = aperture();\n    \n    if(!(distance(ap, apert_cent) < 1.0)) return false;\n    \n    float apd = length(ap);\n    \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1];\n    \n    ro = get(CamP).xyz + aperture_size*daperture;\n  \n    float focus =2.5 + 0.8*pow(apd,5.0);\n\n   \n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    \n    return true;\n}\n\nconst vec3 BH_pos = vec3(0.0); //BH position\nconst float BH_R = 0.5; //event horizon radius\n\n//the black hole \"force\"\nvec3 force(vec3 p)\n{\n    vec3 r = (p - BH_pos);\n    float R = length(r);\n    return -1.5*BH_R*r/pow(R,5.0);\n}\n\n//integration timestep\nconst float dt = 0.15;\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += rand2();\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    vec3 fcol = vec3(0.0);\n    \n    //this blog post is used as reference\n    //https://rantonels.github.io/starless/ \n    \n    vec3 ro = cp; //initial position\n    vec3 rv = rd; //the initial velocity of the virtual ray test particle\n    \n    for(int i = 0; i<128; i++)\n    {\n        //integrate velocity (simple integration)\n        rv += force(ro)*dt;\n        ro += rv*dt;\n        \n        if(distance(BH_pos, ro) < 0.9*BH_R) return vec4(fcol, 1.0); //got below event horizon\n    }\n    \n    fcol = 15.*pow(texture(iChannel1, rv).xyz,vec3(4.0));\n    \n    return vec4(fcol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    \n   \n    //prev \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else\n        fragColor = vec4(0.0);\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBGWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 61], [63, 63, 120, 120, 235]], "test": "untested"}
{"id": "NlS3Dw", "name": "Spherical Harmonics Viewer", "author": "weasel", "description": "A new raymarching spherical harmonics viewer for all functions up to l~30 with |m|<17. Select the spherical harmonic you want using your mouse. Only a few are available with the mouse selection directly, others need to be selected in the code.", "tags": ["3d", "raymarching", "physics"], "likes": 16, "viewed": 538, "published": 3, "date": "1623960949", "time_retrieved": "2024-07-30T19:15:27.811087", "image_code": "#define PI 3.14159265359\n\n/*** math heavy part for spherical harmonics ***/\n\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(1.0-x*x, float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n/*** Now the rendering ***/\n\nfloat map(float t, float a, float b, float A, float B) {\n    if (A - B == 0. || a - b == 0.)\n        return (A+B)*0.5;\n    return A + (t - a) * (B - A) / (b - a);\n}\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\nvec3 rotateZ(vec3 pos, float angle) {\n    return vec3(cmul(pos.xy, cexp(vec2(0.,-angle))), pos.z);\n}\n\nfloat sphereSdf(vec3 pos, float r) {\n    return length(pos)-r;\n}\n\n#define SELECT_GRID 7.0\nvoid get_lm(out int l, out int m, in vec2 fragCoord) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    int t = int(iTime);\n    \n    if (mouse.x + mouse.y > 0.0) {\n        vec2 coord = iMouse.z > 0.5 ? fragCoord : iMouse.xy;\n        ivec2 cell = ivec2(coord/iResolution.y*SELECT_GRID);\n        t = (int(SELECT_GRID) - cell.y - 1) + cell.x * int(SELECT_GRID);\n        l = cell.x;\n        m = cell.y;\n        return;\n    }\n    \n    l = int(floor(sqrt(0.25 + float(2*t)) - 0.5));\n    m = int(floor(float(t) - 0.5*float(l + l*l)));\n}\n\nfloat globalSdf(vec3 pos, out vec3 color, in vec2 fragCoord) {\n    // get spherical coordinates\n    float sin_theta = length(pos.xy);\n    float ball_phi = sin_theta > 0.0 ? atan(pos.x, pos.y) : 0.0;\n    float ball_theta = atan(sin_theta, pos.z);\n\n    int m, l;\n    get_lm(l, m, fragCoord);\n\n    // evaluate spherical harmonics\n    float off = m == 0 ? 0.0 : iTime/float(m);\n    vec2 sph_harm = sphere_harm(ball_theta, ball_phi + off, l, m);\n\n    // normalization for visual purposes\n    sph_harm *= SQRT2PI;\n    float occ = abs(sph_harm.x);\n    \n    float crit = float(1+max(abs(m), l-abs(m)));\n    float crit2 = 1.0 / (3.0 + crit);\n    float max_abs_sd = (length(pos)+0.01)*PI*2.0/crit;\n    \n    float sdx = sphereSdf(pos, max(sph_harm.x, 0.))*crit2;\n    float sdy = sphereSdf(pos, -min(sph_harm.x, 0.))*crit2;\n    color = vec3(float(sdx < sdy),occ,0);\n    float sd = min(sdx, sdy);\n    return min(max_abs_sd, abs(sd)) * sign(sd);\n}\n\nvec3 calculate_normal(in vec3 world_point, float sd, in vec2 fragCoord) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n    vec3 col;\n    float gradient_x = globalSdf(world_point + small_step.xyy, col, fragCoord) - sd;\n    float gradient_y = globalSdf(world_point + small_step.yxy, col, fragCoord) - sd;\n    float gradient_z = globalSdf(world_point + small_step.yyx, col, fragCoord) - sd;\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    return normalize(normal);\n}\n\nvec4 lighting(vec3 cp, vec3 color, vec3 normal, vec3 rdir) {\n    // from https://www.shadertoy.com/view/ts3XDj\n    // geometry\n    vec3 ref = reflect( rdir, normal );\n\n    // material\t\t\n    vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), color.r );\n\n    float occ = min(color.g, 1.0);//clamp(2.0*tmat.z, 0.0, 1.0);\n    float sss = 0.0;//pow(clamp(1.0 + dot(normal, rdir), 0.0, 1.0), 1.0);\n\n    // lights\n    vec3 lin  = 2.5*occ*vec3(1.0)*(0.6 + 0.4*normal.y);\n         lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n    // surface-light interacion\n    vec3 col = mate.xyz * lin;\n    return vec4(col, 1.0);\n}\n\n#define NUMBER_OF_STEPS 128\n#define MINIMUM_HIT_DISTANCE 0.005\n#define MAXIMUM_TRACE_DISTANCE 6.0\nvec4 raymarch(in vec3 rpos, in vec3 rdir, in vec2 fragCoord) {\n    float t = 0.0;\n    float closest_t = 0.0;\n    float closest_t_r = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r2 = MAXIMUM_TRACE_DISTANCE;\n    float closest_t_r3 = MAXIMUM_TRACE_DISTANCE;\n    vec4 col = vec4(0,0,0,0);\n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 cp = rpos + t * rdir;\n        \n        vec3 color = vec3(0.0);\n\t\tfloat sd = globalSdf(cp, color, fragCoord);\n        \n        if (abs(sd) < 0.7*MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculate_normal(cp, sd, fragCoord);\n            col = lighting(cp, color, normal, rdir);\n            break;\n        }\n        \n        closest_t_r3 = closest_t_r2;\n        closest_t_r2 = closest_t_r;\n        if (sd < closest_t_r) {\n            closest_t = t;\n            closest_t_r = sd;\n        }\n\n        if (t > MAXIMUM_TRACE_DISTANCE)\n            break;\n        \n        t += sd;\n    }\n    if (abs(closest_t_r3) > MINIMUM_HIT_DISTANCE) {\n        return col;\n    }\n    vec3 cp = rpos + closest_t * rdir;\n    vec3 color = vec3(0.0);\n    float sd = globalSdf(cp, color, fragCoord);\n    vec3 normal = calculate_normal(cp, sd, fragCoord);\n    float a = 1.0-abs(closest_t_r3)/MINIMUM_HIT_DISTANCE;\n    vec4 col2 = lighting(cp, color, normal, rdir);\n    col2.a = a;\n    return mix(col, col2, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float rot = 0.5*sin(iTime*0.5) * PI/2.1;\n    \n    if (iMouse.z > 0.5) {\n        // selection on click\n        uv = fract(fragCoord/iResolution.y*SELECT_GRID)*2.0-1.0;\n        rot = -0.5;\n    }\n\n     // camera movement\n\tvec3 cam_pos = 3.0 * rotateX(vec3(0,1,0), rot);\n    vec3 look_at = vec3(0);   \n    vec3 look_up = vec3(0,0,1);\n    // camera matrix\n    vec3 ww = normalize(look_at - cam_pos);\n    vec3 uu = normalize(cross(ww, look_up));\n    vec3 vv = normalize(cross(uu, ww));\n\t// create perspective view ray\n    vec3 rpos = cam_pos;\n\tvec3 rdir = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n    \n    vec4 col = raymarch(rpos, rdir, fragCoord);\n    vec3 bg = vec3(0.3) * clamp(1.0-2.6*length(fragCoord/iResolution.xy-0.5)*0.5,0.0,1.0);\n    col = vec4(mix(bg, col.rgb, col.a), 1.0);\n    col = vec4(pow(clamp(col.rgb,0.0,1.0), vec3(0.4545)), 1.0);\n\n    if (iMouse.z > 0.5) {\n        // selection on click\n        ivec2 select = abs(ivec2(fragCoord/iResolution.y*SELECT_GRID)-ivec2(iMouse.xy/iResolution.y*SELECT_GRID));\n        if (select.x + select.y == 0) {\n            // draw selection box\n            vec2 absuv = abs(uv);\n            vec2 cmp = min(absuv, vec2(0.9));\n            float d = length(absuv - cmp);\n            float fac = max(0.05 - abs(d - 0.05), 0.0)/0.025;\n            ivec2 checkers = ivec2(round(uv * 3.5));\n            fac *= float((checkers.x + checkers.y + 1)&1);\n            col = mix(col, vec4(1.0), fac);\n        }\n    }\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3Dw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 122, 140, 140, 236], [238, 258, 277, 277, 374], [376, 413, 439, 439, 649], [651, 674, 693, 693, 741], [743, 769, 796, 796, 861], [863, 886, 905, 905, 931], [933, 967, 987, 987, 1001], [1002, 1002, 1021, 1021, 1040], [1042, 1077, 1121, 1121, 1587], [1589, 1621, 1677, 1677, 1855], [1886, 1886, 1942, 1942, 2050], [2052, 2052, 2089, 2089, 2152], [2154, 2154, 2191, 2191, 2254], [2256, 2256, 2292, 2292, 2320], [2875, 2875, 2937, 2970, 3808], [3810, 3810, 3883, 3883, 4295], [4297, 4297, 4357, 4423, 4912], [5012, 5012, 5074, 5074, 6348], [6350, 6350, 6405, 6405, 7949]], "test": "untested"}
{"id": "ftSGWw", "name": "snowflake_", "author": "mdb", "description": "model of the generation of snowflakes in nature\nyou can play with settings in the common and the bigger the screen the more the snowflake grows and the more complex it get", "tags": ["cellular", "snowflake", "nature", "generation"], "likes": 7, "viewed": 350, "published": 3, "date": "1623959109", "time_retrieved": "2024-07-30T19:15:28.567066", "image_code": "/*\nsee in common for variables on the snowflake grow\n\nsee buffer A for the actual algo\n\n\n*/\n\nvec2 hexagon( vec2 p )\n{\n    // get the hexagonal coord from the cartesian coord system\n    // from https://www.shadertoy.com/view/Xd2GR3\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0, v);\n\tfloat cb = step(2.0, v);\n\tvec2  ma = step(pf.xy, pf.yx);\n\t\n\treturn vec2( pi + ca - cb * ma);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //hexagonal coordinate of the fragCoord\n    vec2 co = hexagon(fragCoord);\n    \n    //normalize the coordinate on the x axis\n    co /= iResolution.xy;\n    \n    //get the value of the cell\n    // cell.x <=> steam amount in the cell\n    // cell.y <=> 1 if cell is frozen else 0\n    vec2 cell = texture(iChannel0, co*0.5).xy;\n    \n    // color stuff\n    vec3 col = vec3(0.0, 0.5, 0.7);\n    col += cell.x - cell.y;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// frame delay if you want to go full screen you need to do it before the cells init\n// else the snowflake will not be centered and might be corrupted\n// so make it something like 120 to give you 2sec before the end of the initialisation\n#define frameDelay 0\n\n//3 variables of the simulation\n\nconst float a = 0.6; // a < 1, initial amount of steam\nconst float b = 0.9; // a < 1, how much steam diffuse at each iteration from on cell to it's neighbors \nconst float c = 0.001; // steam generated at each iteration by the frozen cells\n\n/* \nfeel free to experiment with those 3 settings\n\ngood settings:\na,    b,    c\n0.6   0.4   0.001\n0.6   0.9   0.001\n0.6   0.99  0.0001\n0.6   0.9   0.004\n*/\n", "buffer_a_code": "//sore the state of each cell and update it for the next gen\n\n// directions of neighbors on the exagonal grid\nconst vec2 dir[6] = vec2[](vec2(1.0, 0.0),\n                           vec2(-1.0, 0.0),\n                           vec2(0.0, 1.0),\n                           vec2(0.0, -1.0),\n                           vec2(1.0, 1.0),\n                           vec2(-1.0, -1.0));\n\nint type(vec2 cell){\n    //test if the cell is frozen\n    if(texture(iChannel0, cell/iResolution.xy).y > 0.5) return 1;\n    \n    for(int i = 0; i < 6; i++){ // for all neighbors\n        vec2 data = texture(iChannel0, (cell + dir[i])/iResolution.xy).xy;\n        if(data.y > 0.5)return 1;//a neighbors is frozen\n    }\n    return 2;  // no neighbor is frozen\n}\n           \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    //initialisation of all cells in the start\n    if(iFrame - frameDelay < 3){\n        float frozen = 0.0;\n        if(ivec2(fragCoord) - ivec2(iResolution.xy*vec2(0.28, 0.5)) == ivec2(0))frozen = 1.0;\n        fragColor = vec4(a, frozen, 0.0, 1.0);\n        return;\n    }\n    \n    // there is 2 type of cell, \n    // type 1: frozen cells or neighbor to a frozen cell\n    // type 2: others\n    // cells data is stored as vec2(steam density, float(is frosen))\n    \n    // each iteration is composed of 2 step\n    vec2 self = texture(iChannel0, uv).xy;\n    int selfType = type(fragCoord);\n    \n    // first, diffusion of steam \n    // type 2 cells give a part of their steam to neighbors\n    if(selfType == 2) self.x *= (1.0 - b);\n    \n    // get steam from all type 2 neighbors\n    for(int i = 0; i < 6; i++){\n        vec2 neighbor = texture(iChannel0, (fragCoord + dir[i])/iResolution.xy).xy;\n        if(type(fragCoord + dir[i]) == 2){\n            self.x += b / 6.0 * neighbor.x;\n        }\n    }\n    // then each type 1 cells get additional steam and if their steam amount >=1, they froze\n    if(selfType == 1){\n        self.x += c;\n        if(self.x >= 1.0) self.y = 1.0;\n    }\n    \n    \n    fragColor = vec4(self, 0.0, 1.0);\n}\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 117, 230, 490], [492, 492, 549, 593, 996]], "test": "untested"}
{"id": "7lX3Ds", "name": "Abstract triangle", "author": "z0rg", "description": "Description", "tags": ["3d", "triangle", "abstract", "pattern"], "likes": 10, "viewed": 269, "published": 3, "date": "1623956191", "time_retrieved": "2024-07-30T19:15:29.406821", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.,1.)\nmat2 r2d(float a){float ca = cos(a),sa=sin(a);return mat2(ca,-sa,sa,ca);}\n#define PI 3.14159265\n\nfloat _bbox(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n  return max(l.x,max(l.y,l.z));\n}\n\nvec2 map(vec3 p)\n{\n  float t = iTime*.01;\n  float shp = -p.y;//-texture2D(noise, p.xz*.01+vec2(sin(t),cos(t))).x*.05;\n  p+=vec3(0.,-.75,0.);\n  p.yz*= r2d(PI*.2);\n  p.xy*= r2d(PI*.25);\n\n  shp = min(shp,_bbox(p,vec3(1.)));\n  return vec2(shp,0.);\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  vec3 p = ro;\n  for (int i = 0; i<steps;++i)\n  {\n    vec2 res = map(p);\n    if (res.x<0.01)\n      return vec3(res.x,distance(p,ro),res.y);\n    p+= rd*res.x;\n  }\n  return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd,r));\n  return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n\n  vec3 ro = vec3(0.,-5.,-1.);\n  vec3 ta = vec3(0.,0.,0.);\n  vec3 rd = normalize(ta-ro);\n\n  rd = getCam(rd,uv);\n\n  vec3 res = trace(ro,rd,32);\n  if (res.y>0.)\n  {\n    vec3 p = ro+rd*res.y;\n    vec3 n = getNorm(p,res.x);\n    col = n*.5+.5;\n    vec3 lpos = vec3(sin(iTime),-1./3.,cos(iTime))*10.;\n    vec3 ldir = lpos-p;\n    vec3 nldir = normalize(ldir);\n    vec3 h = normalize(rd-ldir);\n    col = vec3(1.)*pow(sat(-dot(n,h)),.75);\n    vec3 ressh = trace(p+n*0.02,nldir,64);\n    if (ressh.y >0.)\n    {\n\n       col*= .75;\n    }\n    col += vec3(.4,.5,.7)*.5;\n    float dao = 0.6;\n    col *= sat(pow(sat(map(p+n*dao).x/dao),.5)+.1);\n    col+= pow(1.-sat(-dot(rd,n)),.25)*vec3(1.,.5,.7).yzx*.25;\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy) / iResolution.xx;\n  uv *= 2.;\n  vec3 col = rdr(uv);\n  vec3 o = col;\n  vec3 inv = 1.-sat(col.zyx);\n  inv = mix(inv,1.-inv,sat((uv.x-uv.y+sin((uv.y+uv.x)*5.+iTime*2.)*.1)*400.));\n  col = mix(col,inv,1.-sat((sin((uv.y+uv.x)*20.)+.4)*400.));\n  col = pow(col,vec3(.5));\n  col = mix(col,o,sat((length(uv)-.4)*400.));\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lX3Ds.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[427, 427, 445, 445, 500], [524, 524, 553, 553, 608], [610, 610, 628, 628, 855], [857, 857, 898, 898, 1082], [1084, 1084, 1115, 1115, 1263], [1265, 1265, 1296, 1296, 1404], [1406, 1406, 1425, 1425, 2147], [2149, 2149, 2206, 2206, 2600]], "test": "untested"}
{"id": "flBGWw", "name": "brick generator", "author": "Sp3cim4n", "description": "simple shader, generates bricks pattern with a bit of randomness.", "tags": ["procedural", "pattern", "bricks"], "likes": 5, "viewed": 269, "published": 3, "date": "1623951662", "time_retrieved": "2024-07-30T19:15:30.258545", "image_code": "#define ANIMATED_SEED       floor(iTime * 2.0)\n#define FIXED_SEED          32.4\n#define BRICK_SIZE          0.1\n#define BRICK_ASPECT        3.0\n#define BRICK_PADDING       0.1\n#define BRICK_PADDING_BLUR  0.1\n#define BRICK_COLOR_A       vec3(0.88,0.32,0.28)\n#define BRICK_COLOR_B       vec3(0.70,0.15,0.1)\n#define BRICK_COLOR_C       vec3(0.1,0.1,0.25)\n\nfloat r11(float seed)\n{\n    return fract(sin(42.11*seed + 90.33)*1277.3);\n}\n\nfloat r21(vec2 seed)\n{\n    return fract(sin(82.33*seed.x + 72.3 * seed.y)*5432.677);\n}\n\nvoid makeBrick(vec2 uv, out vec2 id,out vec2 lv)\n{\n    vec2 brickUV = vec2(uv.x/BRICK_ASPECT,uv.y);\n    id = floor(brickUV / BRICK_SIZE);\n    if(int(id.y)%2 == 0)\n    {\n        brickUV.x += BRICK_SIZE*0.5;\n        id = floor(brickUV / BRICK_SIZE);\n    }\n    lv = fract(brickUV / BRICK_SIZE);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    float seed = ANIMATED_SEED;\n    //float seed = FIXED_SEED;\n    \n    vec2 id;\n    vec2 lv;\n    makeBrick(uv, id, lv);\n    \n    //color brick randomly\n    float x1 = smoothstep(0.0,BRICK_PADDING/BRICK_ASPECT,lv.x);\n    float x2 = smoothstep(1.0,1.0-BRICK_PADDING/BRICK_ASPECT,lv.x);\n    float y1 = smoothstep(0.0,BRICK_PADDING,lv.y);\n    float y2 = smoothstep(1.0,1.0-BRICK_PADDING,lv.y);\n    float brickInsideMask = x1 * x2 * y1 * y2;\n    \n    float colMixParam = r21(id * seed);\n    vec3 col = mix(BRICK_COLOR_A, BRICK_COLOR_B, colMixParam);\n    \n    col = mix(BRICK_COLOR_C,col ,brickInsideMask);\n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBGWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 376, 376, 428], [430, 430, 452, 452, 516], [518, 518, 568, 568, 811], [813, 813, 868, 868, 1577]], "test": "untested"}
{"id": "7ljGWD", "name": "Pixel perfect outline ( LOD )", "author": "FabriceNeyret2", "description": "LOD variant of \"Pixel perfect outline\" by portponky. [url]https://shadertoy.com/view/7tj3Wh[/url]\n", "tags": ["pixel", "outline"], "likes": 26, "viewed": 900, "published": 3, "date": "1623940707", "time_retrieved": "2024-07-30T19:15:31.074362", "image_code": "// LOD variant of \"Pixel perfect outline\" by portponky. https://shadertoy.com/view/7tj3Wh\n\n\n/* */  // antialiased version\n#define inside(P,l) step(.1, length(  textureLod(iChannel0, (P)/iResolution.xy,l)  \\\n                                    - vec4(.05, .64, .15, 1) ) )\n// #define inside(P,l) step(.1, length(  texelFetch(iChannel0, ivec2(P)>>int(l),int(l))  \\\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O -= O;\n    for(float l=0.,c; l<8.; l++) {\n        c = 0.;\n        for (int k=0; k<9; k++)\n            c += inside( U + vec2(k%3,k/3)-1. , l);\n        if (c<4.) O += .15* vec4(0, .58, .88, 1);\n        O += (1.-O) * min( 9.-c , c ) / 5.;\n     // O = mix(O, vec4(1), min( 9.-c , c ) / 5. ); // simplified above\n    }\n}\n\n\n/*  // --- aliased version \n\n#define inside(P,l) length( textureLod(iChannel0, (P)/R,l) - vec4(.05, .64, .15, 1) ) > .1\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n     right = vec2(1,0),\n      down = vec2(0,1);\n    \n    O-=O; \n    for(float l=0.; l<8.; l++)\n      if( !(inside(U,l)) ) \n      if (    inside(U + right, l) \n           || inside(U + down , l) \n           || inside(U - right, l) \n           || inside(U - down ,l) ) O++; \n           else O+=.15 * vec4(0, .58, .88, 1);\n}\n\n/**/", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 364, 402, 402, 723]], "test": "untested"}
{"id": "stjGWD", "name": "Pixel perfect outline (antialias", "author": "FabriceNeyret2", "description": "Antialiased variant of \"Pixel perfect outline\" by portponky. [url]https://shadertoy.com/view/7tj3Wh[/url]\n", "tags": ["pixel", "outline"], "likes": 20, "viewed": 666, "published": 3, "date": "1623940364", "time_retrieved": "2024-07-30T19:15:31.906138", "image_code": "// Antialiased variant of \"Pixel perfect outline\" by portponky. https://shadertoy.com/view/7tj3Wh\n\n#define inside(P) step(.1, length(  texture(iChannel0, (P)/iResolution.xy)  \\\n                                    - vec4(.05, .64, .15, 1) ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4(0);\n    \n    for (int k=0; k<9; k++)\n        O += inside( U + vec2(k%3,k/3)-1. );\n        \n    O = min( 9.-O , O ) / 5.;\n\n// --- with original colors\n//  O = O.a>4. ? mix( vec4(0),  vec4(1), (9.-O)/5. )\n//             : mix( vec4(0, .58, .88, 1),  vec4(1), O/5. );   \n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 281, 281, 564]], "test": "untested"}
{"id": "sl2GDW", "name": "The shimmer manifest 002", "author": "xenn", "description": "Y'know those pinboard sculpture thingies:\n\nhttps://www.boredpanda.com/be-a-pin-up-by-lulu-guinness", "tags": ["dots", "mograph", "chromab", "mdtmjvm"], "likes": 12, "viewed": 389, "published": 3, "date": "1623937859", "time_retrieved": "2024-07-30T19:15:32.839643", "image_code": "// Fork of \"The shimmer\" by xenn. https://shadertoy.com/view/7lBGWD\n// 2021-06-17 13:50:02\n\n// Fork of Jeyko, 2021-06-17 https://www.shadertoy.com/user/jeyko\n// \"maybe mention that this forked from my shader?\n// It just keeps the website sorted.\"\n\n// Jeyko has heaps of intrigueing and fascinating code vignettes, you should check them all out!\n// 2021-06-09 02:00:41\n\n// and it has been further forked with the following and possibly one each per buffer channel.\n// Though, each buffer also may change in the future too. So, No promises. No threats.\n\n// ahem \n// also created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(10.0*cos(iTime/3.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.478975+(0.1*cos(iTime/4.3))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec)+vec4(col);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": " \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 9;\n    \n    const float warp = 0.7;    \n    float warpTrk = 2. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarbB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 5;\n    \n    const float warp = .9;\n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n", "buffer_a_code": "// :)\n// in the vibe of https://twitter.com/beesandbombs\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin(a,b) a.x < b.x ? a : b\n#define preplim(g,c,l) g-c*clamp(round((g)/c),-l,l)\n#define xor(a,b,c) min(max(a,-b), max(-a,b + c))\n\n\n\nfloat pixSz;\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv, out vec2 gv) {\n\tvec2 r = vec2(1, 01.-(0.502*(cos(iTime/4.))));\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s; return max(p.x, p.y);\n}\nvoid getTile( vec2 p, out float d, inout vec3 col, vec2 gv, vec4 hc){\n    vec2 op = p;\n    for(float i = 0.; i < 3.; i++){\n        float t = iTime - i*.05;\n        p = op;\n        \n        float m =   + 0.3*sin( hc.z*1. + sin(hc.w + t)*0.4)*sin(t) + .4*( length(hc.zw) + sin(length(hc.w)*0.));\n        p *= rot(0. \n            + m - length(hc.zw)*0.9\n            + t*3.);\n\n        p.y += 0.5;\n        p.x -= sin(hc.w)*.5*(sin(m*1.14));\n        d = length(p) - sin(m*2. + t)*0.04 - 0.05;\n\n        col[int(i)] = mix( col[int(i)], 1., smoothstep(pixSz*2.,0.,d));\n    \n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    \n    uv *= 32.;\n    \n    //uv.y += iTime*0.5;\n    \n    pixSz = fwidth(uv.x);\n    \n    vec2 gv;\n    vec4 hc = HexCoords(uv, gv);\n    /*\n    float d = map(gv);\n    col += smoothstep(pixSz,0.,abs(d));\n    */\n    for(float i = 0.; i < 7.; i++){\n        vec2 offs = vec2(0);\n        \n        float ioffs = 0.;\n        if(i < 3. ){\n            float offsIdx = tau*(i + ioffs)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        } else if( i == 3.) {\n        \n        } else if( i == 4. || i == 5.){\n            float offsIdx = tau*(i + ioffs - 1. + float(i == 5.)  )/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        \n        } else if( i == 6.){\n            float offsIdx = tau*(i + ioffs - 2.)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        }\n        \n        vec4 hc = HexCoords(uv + offs, gv);\n        \n        float d; \n        getTile(gv - offs, d, col, uv - offs, hc);\n        \n        \n        \n    }\n    \n    \n    \n    col = max(col,0.);\n    col = mix(col,col*col*0.0,pow(smoothstep(0.,1.,dot(ouv,ouv)),1.0));\n\n    col *= vec3(1.,1.,1.);\n    \n   // if( mod(iTime/10.,1.) > 0.66)\n        col = 1. - col;\n  //  if(iMouse.z > 0.5)\n        col = 1. - col;\n    col = pow(col,vec3(.5));\n    \n    \n    fragColor.xyz += col;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fork of \"spilled\" by flockaroo. https://shadertoy.com/view/MsGSRd\n// 2020-05-07 11:42:26\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(10.0*cos(iTime/3.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.478975+(0.1*cos(iTime/4.3))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec)+vec4(col);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define PI 3.1415926536\n\nvec2 rotate(vec2 src, float angle) {\n    float sn = sin(angle);\n    float cs = cos(angle);\n    return vec2(src.x * cs - src.y * sn, src.x * sn + src.y * cs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,4,4));\n\n    float radius = 0.0065;\n    float angle = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    float angle2 = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    float angle3 = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    \n    vec2 vector = vec2(0, radius);\n    \n    vec4 red = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 7.0) * 0.0025*/, angle));\n    vec4 green = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 9.0) * 0.0025*/, angle2 + 2.0 * PI / 3.0));\n    vec4 blue = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 11.0) * 0.0025*/, angle3 + 2.0 * PI / 3.0 * 2.0));\n    fragColor = vec4(red.r, green.g, blue.b, 1.0);\n\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"spilled\" by flockaroo. https://shadertoy.com/view/MsGSRd\n// 2020-05-07 11:42:26\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(100.0*cos(iTime/4.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel2, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.0+(1.0*cos(iTime/3.))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = (texture(iChannel0,uv)-texture(iChannel2,uv))*(vec4(diff)+vec4(col))+vec4(spec)+vec4(col);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2GDW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[702, 702, 725, 725, 773], [779, 779, 814, 814, 953], [955, 955, 1012, 1012, 2102]], "test": "untested"}
{"id": "7tjGDW", "name": "Fork CBM 3D hayesmaker 945", "author": "hayesmaker64", "description": "cbm logo", "tags": ["raymarch", "logo", "extrude", "cbm"], "likes": 1, "viewed": 215, "published": 3, "date": "1623937040", "time_retrieved": "2024-07-30T19:15:33.650475", "image_code": "// yx's commodore shape from here - https://www.shadertoy.com/view/4lGfzK\n//\n// Raymarched by Del 25/11/2018\n\nfloat cbm(vec2 p)\n{\n    const float A = 10.;\n    const float B = 0.034 * A;\n    const float C = 0.166 * A;\n    const float E = 0.364 * A;\n    const float F = 0.52 * A;\n    const float G = 0.53 * A;\n    const float H = 75.636 * A;\n    const float I = 0.97 * A;\n    \n    p.y = abs(p.y);\n    \n    float outerCircle = length(p)-I*.5;\n    float innerCircle = length(p*vec2(F/G,1))-F*.5;\n    float verticalMask = p.x-(H-I*.5);\n    \n    float topMask = p.y-C-B*.5;\n    float bottomMask = p.y-B*.5;\n    float angleMask = ((p.x-p.y)-A+I*.5+E*.5)/sqrt(2.);\n    \n    float vents = max(max(angleMask,max(topMask,-bottomMask)), -verticalMask);\n    \n    float ring = max(max(outerCircle,-innerCircle),verticalMask);\n    \n    return min(vents, ring);\n}\n\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n#define\tTAU 6.28318\n\n\nfloat map(vec3 p)\n{\n    float time = iTime+0.2;\n    p.z -= 13.0+sin(fract(time*0.15)*TAU)*2.0;\n    \n    float twist = 0.5+sin(fract(time*0.25)*TAU)*0.5;\n    twist *= p.y * 0.1;\n    p.xz *= rotate(twist+fract(time*0.26)*TAU);\n    \n    float dist = cbm(p.xy);\n    \n    float dep = 0.5;\n    vec2 e = vec2( dist, abs(p.z) - dep );\n    dist = min(max(e.x,e.y),0.0) + length(max(e,0.0));\n    dist -= 0.07;\n    return dist;\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 normal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\nvec3 render(vec2 uv)\n{\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.95));\n\tvec3 p = vec3(0.0);\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++)\n    {\n\t\tp = ro + rd * t;\n\t\tfloat d = map(p);\n\t\tif (d < .001 || t > 100.) break;\n\t\tt += d *0.75;\n\t}\n    \n    vec3 c = vec3(0.35,0.35,0.45);\n    c*= 1.2-abs(uv.y);\n    \n    if (t<100.0)\n    {\n\t   \tvec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));\n        vec3 nor = normal(p);\n\n        float dif = max(dot(nor, lightDir), 0.0);\n        c = vec3(0.5) * dif;\n\n        float tf = 0.02;\n        c += vec3(0.65,0.6,0.25) + reflect(vec3(p.x*tf, p.y*tf,tf), nor);\n\n        vec3 ref = reflect(rd, nor);\n        float spe = max(dot(ref, lightDir), 0.0);\n        c += vec3(2.0) * pow(spe, 32.);\n    }\n\n    c *= 1.0 - 0.3*length(uv);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = render(uv);\n\tfragColor = vec4(col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 129, 129, 847], [850, 850, 872, 872, 939], [962, 962, 981, 981, 1380], [1383, 1455, 1481, 1596, 1792], [1793, 1793, 1815, 1815, 2584], [2586, 2586, 2643, 2643, 2803]], "test": "untested"}
{"id": "fljGDW", "name": "Maxnorm Distance to Ellipse", "author": "oneshade", "description": "I found this one was very intuitive and also made a deconstruction of the method (running by default).", "tags": ["2d", "sdf", "distance", "ellipse", "maxnorm", "deconstruction"], "likes": 5, "viewed": 160, "published": 3, "date": "1623921408", "time_retrieved": "2024-07-30T19:15:34.507184", "image_code": "#define DECONSTRUCT\n\n// Drawing utility\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    //p = abs(p);\n    //p = max(p, (p - ab).yx);\n    //float ba = ab.y / ab.x, a = ba * ba + 1.0;\n    //float b = p.y - p.x, bb = b * b;\n    //return p.x - (sqrt(bb - (bb - ab.y * ab.y) * a) - b) / a;\n\n    // Simpler ellipse distance by iq\n    p = abs(p);\n    p = max(p, (p - ab).yx);\n    float a = dot(ab, ab);\n    float b = p.y - p.x;\n    return p.x - (ab.y * sqrt(a - b * b) - ab.x * b) * ab.x / a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    #ifdef DECONSTRUCT\n    float shift = 0.5 - 0.5 * cos(0.1 * iTime);\n    float scale = mix(1.0, 2.0, shift);\n\n    vec2 uv = abs((fragCoord - 0.5 * shift * iResolution.xy) / iResolution.y) * scale;\n    float unit = 2.0 * scale / iResolution.y;\n\n    vec2 ab = vec2(1.25, 0.4);\n    float dist = sdEllipse(uv, ab) / scale;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(dist));\n    color *= 0.8 + 0.2 * cos(240.0 * dist);\n    drawSDF(abs(dist) * scale, vec3(1.0));\n\n    // Sample point\n    vec2 p = vec2(1.5, 0.5);\n    float r = (0.5 + 0.5 * sin(0.25 * iTime)) + 0.25;\n    float c = cos(r), s = sin(r);\n    p *= mat2(c * ab.x, -s * ab.x, s * ab.y, c * ab.y);\n\n    // Sample Distance\n    float pDist = abs(sdEllipse(p, ab));\n    drawSDF(length(uv - p) - 0.008, vec3(0.0, 1.0, 0.0));\n    drawSDF(abs(max(abs(uv.x - p.x), abs(uv.y - p.y)) - pDist), vec3(0.0, 1.0, 0.0));\n\n    // Vertical edge touching\n    if (abs(p.x) - ab.x > abs(p.y)) {\n        float seg = length(uv - vec2(p.x - pDist, clamp(uv.y, p.y - pDist, p.y + pDist)));\n        drawSDF(seg - 0.008, vec3(1.0, 0.0, 0.0));\n        if (abs(uv.x) - ab.x > abs(uv.y)) color.b += 0.5;\n        drawSDF(abs(uv.y - uv.x + ab.x) * sqrt(0.5) - 0.003, vec3(0.0));\n    }\n\n    // Horizontal edge touching\n    else if (abs(p.y) - ab.y > abs(p.x)) {\n        float seg = length(uv - vec2(clamp(uv.x, p.x - pDist, p.x + pDist), p.y - pDist));\n        drawSDF(seg - 0.008, vec3(1.0, 0.0, 0.0));\n        if (abs(uv.y) - ab.y > abs(uv.x)) color.b += 0.5;\n        drawSDF(abs(uv.x - uv.y + ab.y) * sqrt(0.5) - 0.003, vec3(0.0));\n    }\n\n    // Corner touching\n    else {\n        drawSDF(abs(uv.y - uv.x + p.x - p.y) * sqrt(0.5) - 0.001, vec3(0.0));\n        drawSDF(length(uv - p + pDist) - 0.015, vec3(1.0, 0.0, 0.0));\n    }\n\n    #else\n    // Alternate reality! :D\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.5, 0.5 * sin(time)) * cos(time);\n\n    vec2 dims = vec2(0.3 + 0.05 * sin(iTime), 0.2 + 0.1 * cos(0.5 * iTime));\n    float dist = sdEllipse(uv, dims);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n    color *= 1.0 - exp(-4.0 * abs(dist));\n    color *= 0.8 + 0.2 * cos(240.0 * dist);\n    drawSDF(abs(dist), vec3(1.0));\n\n    float mDist = abs(sdEllipse(mouse, dims));\n    drawSDF(length(uv - mouse) - 0.008, vec3(0.0, 1.0, 0.0));\n    drawSDF(abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist), vec3(0.0, 1.0, 0.0));\n\n    #endif\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 161, 401, 565], [567, 567, 622, 622, 3408]], "test": "untested"}
{"id": "flj3WW", "name": "Fork Class I: S Raytracing", "author": "boomji", "description": "sampling version 1:\n", "tags": ["sampling"], "likes": 0, "viewed": 214, "published": 3, "date": "1623918827", "time_retrieved": "2024-07-30T19:15:35.363893", "image_code": "vec3 bgColor = vec3(0, 1, 1);\n\nvec3 sample_function(in float x, in float y) {\n\n    \n    // Disk: x*x + y*y = r*r\n    /*\n    float s = abs(x*x + y*y);\n    if (s < 0.3) {\n        return vec3(0.8, 0.8, 0.8);\n    }\n    else return bgColor;\n    */\n    \n    // Sine wave: y = Amplitude* Sin(Frequency*x)\n    /*\n    float s = abs(y*2.0-sin(3.0*x));\n    if (s < 0.001) {\n        return vec3(0, 0, 0);\n    }\n    else return bgColor;\n    */ \n    \n    \n    \n    // Heart\n    \n    x = x*2.5;\n    y = y*2.5;\n    float s = 1.25*y - sqrt(abs(x));\n    if ((x*x + s*s -1.0) < 0.001) {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else return bgColor;\n    \n    \n    \n    // 2-d klein bottle\n    /*\n    x = x*5.0;\n    y = y*5.0;\n    \n    float s = (x*x + y*y + 2.0*y -1.0)*(x*x + y*y - 2.0*y -1.0)* (x*x + y*y - 2.0*y -1.0) + 16.0*x*((x*x + y*y - 2.0*y -1.0));\n    if (s < 0.001) {\n        return vec3(abs(x/5.0), abs(y/5.0), 0);\n    }\n    else return bgColor;   \n    */\n}\n\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   float x = fragCoord.x;\n   float y = fragCoord.y;\n   \n   // map (0.5, w-0.5) to (-1, 1)\n   // and (0.5, h-0.5) to (-1, 1)\n   x = (x/width)*2.0 - 1.0;\n   y = (y/height)*2.0 - 1.0;\n   \n   // correct aspect ratio\n   float aspect = width / height; \n   y= y/aspect;\n   \n   // sample the function\n   vec3 samp = sample_function(x, y);\n   \n   fragColor = vec4(samp, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flj3WW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 77, 459, 954], [958, 1037, 1092, 1246, 1685]], "test": "untested"}
{"id": "ftBGDD", "name": "Fake Shadow Test CL", "author": "chenglou", "description": "The equivalent of CSS shadow, in shader.\nMouse click and drag to move shadow.", "tags": ["test"], "likes": 0, "viewed": 180, "published": 3, "date": "1623907078", "time_retrieved": "2024-07-30T19:15:36.207637", "image_code": "vec4 black = vec4(0,0,0,1);\nvec4 white = vec4(1,1,1,1);\nvec4 blueish = vec4(0,0.5,0.8,1);\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    // equation from https://iquilezles.org/articles/distfunctions2d\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Configs. Feel free to tweak\n    vec2 boxDimensions = vec2(500, 300);\n    vec2 center = vec2(700, 400);\n    float shadowSpread = 20.;\n    \n    // Draw box\n    float sdBox_ = sdBox(fragCoord.xy - center, boxDimensions / 2.);\n    // Draw shadow. Mouse click and drag to move it\n    float sdShadow = sdBox(fragCoord.xy - center + (iMouse.xy - center) / 30., boxDimensions / 2.);\n\n    if (sdBox_ <= 0.) {\n        // negative sdf -> inside the box\n        fragColor = blueish;\n    } else if (sdShadow > 0.) {\n        // positive sdf -> outside the box. Sdf gets rounder and rounder the further it is from the box\n        fragColor = mix(black, white, sdShadow / 20.);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBGDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 128, 197, 277], [279, 279, 336, 371, 1013]], "test": "untested"}
{"id": "7tSGDD", "name": "Arc - distance L-inf", "author": "iq", "description": "Distance to an arc in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url].", "tags": ["2d", "distancefield", "sdf", "arc", "linf"], "likes": 7, "viewed": 784, "published": 3, "date": "1623906295", "time_retrieved": "2024-07-30T19:15:36.950651", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an arc of a circle in the L-infinity metric space.\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\nfloat dist( in vec2 p, in vec2 c )\n{\n    p = abs(p-c);\n    return max(p.x,p.y);\n}\n\nfloat sdArc( in vec2 p, float rb, float w, float an )\n{\n    vec2 u = vec2(cos(an),sin(an));\n    vec2 v = vec2(-u.y,u.x);\n    float h = sqrt(rb*rb-w*w);\n\n    // bounding points: arc extremes\n    float d = min(dist(p, u*w+h*v),\n                  dist(p, u*w-h*v));\n    // bounding points: cardinals\n    if( -rb*u.x<w ) d = min(d,dist(p,vec2(-rb,0.0)));\n    if(  rb*u.x<w ) d = min(d,dist(p,vec2( rb,0.0)));\n    if( -rb*u.y<w ) d = min(d,dist(p,vec2(0.0,-rb)));\n    if(  rb*u.y<w ) d = min(d,dist(p,vec2(0.0, rb)));\n    \n    // circular section\n    float b1 = 0.5*(p.x+p.y);\n    float b2 = 0.5*(p.x-p.y);\n    float c = dot(p,p) - rb*rb;\n    float h1 = b1*b1-c*0.5;\n    float h2 = b2*b2-c*0.5;\n    if( h1>0.0 )\n    {\n        vec2 t = vec2(-b1,b1)+sqrt(h1);\n        if( dot(p+vec2( 1, 1)*t.x,u)<w ) d=min(d,abs(t.x));\n        if( dot(p+vec2(-1,-1)*t.y,u)<w ) d=min(d,abs(t.y));\n    }\n    if( h2>0.0 )\n    {\n        vec2 t = vec2(-b2,b2)+sqrt(h2);\n        if( dot(p+vec2( 1,-1)*t.x,u)<w ) d=min(d,abs(t.x));\n        if( dot(p+vec2(-1, 1)*t.y,u)<w ) d=min(d,abs(t.y));\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n    p *= 1.5;\n    m *= 1.5;\n\n    if( iMouse.x<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,1));\n\n    float ra = 0.9;\n    float w = 0.5 + 0.35*cos(iTime);\n    float an = iTime*0.7;\n\n    \n    float d = sdArc(p, ra, w, an);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n    \n    d = sdArc(m, ra, w, an);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.015, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.015, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSGDD.jpg", "access": "api", "license": "mit", "functions": [[1246, 1246, 1282, 1282, 1327], [1329, 1329, 1384, 1384, 2417], [2419, 2419, 2474, 2474, 3278]], "test": "untested"}
{"id": "7tB3WD", "name": "polar rave 2.5", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 3, "viewed": 304, "published": 3, "date": "1623902694", "time_retrieved": "2024-07-30T19:15:37.767467", "image_code": "// Fork of \"polar rave 2.2\" by None. https://shadertoy.com/view/-1\n// 2021-06-17 04:03:47\n\n// Fork of \"polar rave 2.2\" by firebreathz. https://shadertoy.com/view/flSGDW\n// 2021-06-17 03:27:42\n\n// Fork of \"polar rave 2\" by firebreathz. https://shadertoy.com/view/slj3zw\n// 2021-06-16 18:27:30\n\n// Fork of \"polar rave\" by firebreathz. https://shadertoy.com/view/7l2Gzw\n// 2021-06-13 21:22:36\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 21:01:10\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 36\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,-1.5,20.5);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 5.0*uv-2.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    uv.x-=0.5;\n    uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 9.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band/band*band; \n    \n    band = band*0.03;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,-10.000) ).x;  \n    \n    if(band<0.0||band>=10.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 9;\n    vec3 colors[nColors];  \n    colors[0] = vec3(0.502,0.502,1.000);\n    colors[1] = vec3(0.235,0.000,0.235);\n    colors[2] = vec3(0.000,0.000,0.400);\n    colors[3] = vec3(0.000,0.000,0.627);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-0)/n)*n);\n    }\n    \n    float h = PI*0.4;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.1,0.75,f);\n    col *= smoothstep(1.875,0.025,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(3.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.x));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.x));\n    ref += drawBands(vec2(p.x,1.0+p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0+p.y+eps.y));\n\n    ref /= -8.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.5*smoothstep(10.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.2)*smoothstep(1.0,0.0,length(p*2.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(6.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(0.10-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2226.0;\n    col += dither;\n    \n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tB3WD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[596, 596, 619, 619, 700], [702, 702, 744, 744, 805], [807, 807, 832, 832, 2382], [2384, 2384, 2441, 2441, 3708]], "test": "untested"}
{"id": "7lBGWD", "name": "The shimmer", "author": "xenn", "description": "Y'know those pinboard sculpture thingies:\n\nhttps://www.boredpanda.com/be-a-pin-up-by-lulu-guinness/?utm_source=google&utm_medium=organic&utm_campaign=organic", "tags": ["dots", "mograph", "chromab", "mdtmjvm"], "likes": 3, "viewed": 340, "published": 3, "date": "1623900187", "time_retrieved": "2024-07-30T19:15:38.850571", "image_code": "// Fork of Jeyko, 2021-06-17 https://www.shadertoy.com/user/jeyko\n// \"maybe mention that this forked from my shader?\n// It just keeps the website sorted.\"\n\n// Jeyko has heaps of intrigueing and fascinating code vignettes, you should check them all out!\n// 2021-06-09 02:00:41\n\n// and it has been further forked with the following and possibly one each per buffer channel.\n// Though, each buffer also may change in the future too. So, No promises. No threats.\n\n// ahem \n// also created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(10.0*cos(iTime/3.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.478975+(0.1*cos(iTime/4.3))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec)+vec4(col);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": " \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\nfloat cyclicNoise(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarb(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 9;\n    \n    const float warp = 0.7;    \n    float warpTrk = 2. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseMarbB(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.75;\n    const int octaves = 5;\n    \n    const float warp = .9;\n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.09;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk + vec3(0,-time*2.,0) - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n", "buffer_a_code": "// :)\n// in the vibe of https://twitter.com/beesandbombs\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define dmin(a,b) a.x < b.x ? a : b\n#define preplim(g,c,l) g-c*clamp(round((g)/c),-l,l)\n#define xor(a,b,c) min(max(a,-b), max(-a,b + c))\n\n\n\nfloat pixSz;\n\n// Hex code from BigWings! He has a tutorial on them.\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c, p.x);\n    return c;\n}\n\nvec4 HexCoords(vec2 uv, out vec2 gv) {\n\tvec2 r = vec2(1, 01.-(0.502*(cos(iTime/4.))));\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    gv = dot(a, a) < dot(b,b) ? a : b;\n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = uv-gv;\n    return vec4(x, y, id.x,id.y);\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n    p = abs(p) - s; return max(p.x, p.y);\n}\nvoid getTile( vec2 p, out float d, inout vec3 col, vec2 gv, vec4 hc){\n    vec2 op = p;\n    for(float i = 0.; i < 3.; i++){\n        float t = iTime - i*.05;\n        p = op;\n        \n        float m =   + 0.3*sin( hc.z*1. + sin(hc.w + t)*0.4)*sin(t) + .4*( length(hc.zw) + sin(length(hc.w)*0.));\n        p *= rot(0. \n            + m - length(hc.zw)*0.9\n            + t*3.);\n\n        p.y += 0.5;\n        p.x -= sin(hc.w)*.5*(sin(m*1.14));\n        d = length(p) - sin(m*2. + t)*0.04 - 0.05;\n\n        col[int(i)] = mix( col[int(i)], 1., smoothstep(pixSz*2.,0.,d));\n    \n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    \n    uv *= 32.;\n    \n    //uv.y += iTime*0.5;\n    \n    pixSz = fwidth(uv.x);\n    \n    vec2 gv;\n    vec4 hc = HexCoords(uv, gv);\n    /*\n    float d = map(gv);\n    col += smoothstep(pixSz,0.,abs(d));\n    */\n    for(float i = 0.; i < 7.; i++){\n        vec2 offs = vec2(0);\n        \n        float ioffs = 0.;\n        if(i < 3. ){\n            float offsIdx = tau*(i + ioffs)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        } else if( i == 3.) {\n        \n        } else if( i == 4. || i == 5.){\n            float offsIdx = tau*(i + ioffs - 1. + float(i == 5.)  )/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        \n        } else if( i == 6.){\n            float offsIdx = tau*(i + ioffs - 2.)/6.;\n            offs = vec2(sin(offsIdx),cos(offsIdx))*0.5;\n        }\n        \n        vec4 hc = HexCoords(uv + offs, gv);\n        \n        float d; \n        getTile(gv - offs, d, col, uv - offs, hc);\n        \n        \n        \n    }\n    \n    \n    \n    col = max(col,0.);\n    col = mix(col,col*col*0.0,pow(smoothstep(0.,1.,dot(ouv,ouv)),1.0));\n\n    col *= vec3(1.,1.,1.);\n    \n   // if( mod(iTime/10.,1.) > 0.66)\n        col = 1. - col;\n  //  if(iMouse.z > 0.5)\n        col = 1. - col;\n    col = pow(col,vec3(.5));\n    \n    \n    fragColor.xyz += col;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fork of \"spilled\" by flockaroo. https://shadertoy.com/view/MsGSRd\n// 2020-05-07 11:42:26\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(10.0*cos(iTime/3.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.478975+(0.1*cos(iTime/4.3))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec)+vec4(col);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define PI 3.1415926536\n\nvec2 rotate(vec2 src, float angle) {\n    float sn = sin(angle);\n    float cs = cos(angle);\n    return vec2(src.x * cs - src.y * sn, src.x * sn + src.y * cs);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,4,4));\n\n    float radius = 0.0065;\n    float angle = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    float angle2 = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    float angle3 = iTime * 4.0 + (uv.x * 80.0 + uv.y * 80.0) * 0.015;\n    \n    vec2 vector = vec2(0, radius);\n    \n    vec4 red = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 7.0) * 0.0025*/, angle));\n    vec4 green = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 9.0) * 0.0025*/, angle2 + 2.0 * PI / 3.0));\n    vec4 blue = texture(iChannel0, uv + rotate(vector/* + sin(iTime * 11.0) * 0.0025*/, angle3 + 2.0 * PI / 3.0 * 2.0));\n    fragColor = vec4(red.r, green.g, blue.b, 1.0);\n\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"spilled\" by flockaroo. https://shadertoy.com/view/MsGSRd\n// 2020-05-07 11:42:26\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,01.0/iResolution.y),500.+(100.0*cos(iTime/4.)));\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,88.0)*1.25;\n    //spec=0.0;\n\t// Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.01*sin(iTime));\n    \n    vec3 base = texture(iChannel2, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    vec3 overlay = texture(iChannel1,offs).rgb;\n    \n     vec4 col = vec4(base + overlay*(0.0+(1.0*cos(iTime/3.))), 1.0);\n    \n//    fragColor = col;\n    \n    fragColor = (texture(iChannel0,uv)-texture(iChannel2,uv))*(vec4(diff)+vec4(col))+vec4(spec)+vec4(col);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBGWD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[610, 610, 633, 633, 681], [687, 687, 722, 722, 861], [863, 863, 920, 920, 2010]], "test": "untested"}
{"id": "ftS3DD", "name": "Capsule - distance L-inf 2", "author": "iq", "description": "Distance to an capsule in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url]. [b]This code is VERY innefficient[/url]. Feel free to simplifying this.", "tags": ["2d", "distancefield", "sdf", "capsule", "oriented", "linf"], "likes": 8, "viewed": 717, "published": 3, "date": "1623890994", "time_retrieved": "2024-07-30T19:15:39.702294", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a capsule in the L-infinity metric space. Compare\n// to euclidean: https://www.shadertoy.com/view/3tdSDj\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n// -------------------------------\n// THIS CODE IS VERY INNEFICIENT, RIGHT NOW IT'S DOING A BRUTE\n// FORCE COMPUTATION. SOME OTHER DAY I'll GIVE IT A TRY\n// -------------------------------\n\n\nfloat sdCapsule( in vec2 p, vec2 va, vec2 vb, float rb )\n{\n    // recenter primitive\n    p -= (vb+va)*0.5;\n    const float k = sqrt(0.5);\n    float l = length(vb-va);\n    vec2 u = (vb-va)/l;\n    vec2 v = vec2(-u.y,u.x);\n    l *= 0.5;\n    vec2 a = u*l;\n    vec2 w = v*rb;\n\n    // distance to body sides\n    float ss = (u.x*u.y>0.0)?1.0:-1.0;\n    float de = 1.0/(a.y+ss*a.x);\n    vec2 w1 = p-a-w;\n    vec2 w2 = p-a+w;\n    vec2 q1 = abs(w1+a*clamp(-(w1.y+ss*w1.x)*de, 0.0, 2.0));\n    vec2 q2 = abs(w2+a*clamp(-(w2.y+ss*w2.x)*de, 0.0, 2.0));\n    float d1 = max(q1.x,q1.y);\n    float d2 = max(q2.x,q2.y);\n    float d = min(d1,d2);\n\n    // inside circular caps\n    vec2 pa = p - a;\n    vec2 pb = p + a;\n    float da = dot(pa,pa);\n    float db = dot(pb,pb);\n    if( min(da,db)<rb*rb )\n    {\n        float s = 1.0; if( db<da ) {pa=pb;s=-1.0;}\n        float b1 = 0.5*(pa.x+pa.y);\n        float b2 = 0.5*(pa.x-pa.y);\n        float c = dot(pa,pa) - rb*rb;\n        vec2  t1 = vec2(-b1,b1)+sqrt(b1*b1-c*0.5);\n        vec2  t2 = vec2(-b2,b2)+sqrt(b2*b2-c*0.5);\n        // 4 solution. Up to 3 can be valid\n        if( s*dot(pa+vec2( 1, 1)*t1.x,-u)<0.0 ) d=min(d,t1.x);\n        if( s*dot(pa+vec2(-1,-1)*t1.y,-u)<0.0 ) d=min(d,t1.y);\n        if( s*dot(pa+vec2( 1,-1)*t2.x,-u)<0.0 ) d=min(d,t2.x);\n        if( s*dot(pa+vec2(-1, 1)*t2.y,-u)<0.0 ) d=min(d,t2.y);\n        d = -d;\n    }\n    // outside circular caps\n    else \n    {\n        vec2  qa = abs(mat2(u.x,-u.y,u.y,u.x)*p) - vec2(l,rb);\n        float di = max(qa.x, qa.y);\n        // outside circular caps AND outside of body\n        if( di>0.0 )\n        {\n            float dc;\n            \n            // first cap\n            pa = abs(pa);\n            if( abs(pa.y-pa.x)<rb )\n            {\n                float b = 0.5*(pa.x+pa.y);\n                float c = dot(pa,pa) - rb*rb;\n                dc = b - sqrt(b*b-c*0.5);\n            }\n            else\n            {\n                dc = max(pa.x,pa.y)-rb;\n            }\n            d = min(d,dc);\n\n            // sadly, we still need to test the second cap\n            pb = abs(pb);\n            if( abs(pb.y-pb.x)<rb )\n            {\n                float b = 0.5*(pb.x+pb.y);\n                float c = dot(pb,pb) - rb*rb;\n                dc = b - sqrt(b*b-c*0.5);\n            }\n            else\n            {\n                dc = max(pb.x,pb.y)-rb;\n            }            \n            d = min(d,dc);\n        }\n        d *= sign(di);\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n    p *= 1.9;\n    m *= 1.9;\n\n    if( iMouse.x<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    vec2  v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2  v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float ra = 0.3*(0.5+0.5*cos(iTime*1.1+1.0));\n    \n    float d = sdCapsule(p, v1, v2, ra);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(80.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    d = sdCapsule(m, v1, v2, ra);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3DD.jpg", "access": "api", "license": "mit", "functions": [[1491, 1491, 1549, 1575, 3941], [3943, 3943, 3998, 3998, 4890]], "test": "untested"}
{"id": "flB3DD", "name": "Transformed Box AABB", "author": "oneshade", "description": "Maybe not so useful but it can help in avoiding unneccessary matrix inverse computations or maybe in collision detections. I was mainly interested in trying to generalize [url=https://www.shadertoy.com/view/stSGDh]this[/url] SDF to 3D.", "tags": ["3d", "aabb", "boundingbox", "transformed"], "likes": 9, "viewed": 357, "published": 3, "date": "1623881401", "time_retrieved": "2024-07-30T19:15:40.550027", "image_code": "// Desmos graph: https://www.desmos.com/calculator/peu1crmp2n\n\n// Constants\n#define EPSILON 1e-3\n#define INFINITY 1e20\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Settings\n#define ZOOM 1.0\n#define AA 2\n\n// Convenience structs\nstruct Ray { vec3 pos; vec3 dir; };\nstruct Light { vec3 pos; vec3 color; };\nstruct TraceInfo { bool hit; float dist; vec3 pos; vec3 nor; vec3 mat; };\n\n// Axis aligned bbox of a transformed box\n// The vector returned gives the upper and lower bounds\n// relative to the box's center\nvec3 transformedBoxAABB(in vec3 dims, in mat3 mat) {\n    vec3 w = mat[0] * dims.x;\n    vec3 h = mat[1] * dims.y;\n    vec3 d = mat[2] * dims.z;\n    vec3 a = w + h, b = w - h;\n    return max(max(abs(a + d), abs(a - d)),\n               max(abs(b + d), abs(b - d)));\n}\n\n// Box intersector adapted from https://www.shadertoy.com/view/ld23DV\nbool testAABB(in vec3 pos, in vec3 dims, in Ray ray) {\n    ray.pos -= pos;\n    vec3 n = ray.pos / ray.dir;\n    vec3 k = dims / abs(ray.dir);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nvoid addBox(in vec3 pos, in vec3 dims, in mat3 transform, in vec3 mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    mat3 inv = inverse(transform);\n    ray.pos = inv * ray.pos;\n    ray.dir = inv * ray.dir;\n\n    vec3 n = ray.pos / ray.dir;\n    vec3 k = dims / abs(ray.dir);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) tN = -1.0;\n    vec3 nor = -sign(ray.dir) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    if (tN > 0.0 && (scene.hit ? tN < scene.dist : true)) {\n        scene.hit = true;\n        scene.dist = tN;\n        scene.pos = transform * (ray.pos + ray.dir * tN);\n        scene.nor = transform * nor;\n        scene.mat = mat;\n        scene.pos += pos;\n    }\n}\n\n// Very inefficient\nvoid addCylinder(in vec3 pos, in int align, in float height, in float radius, in vec3 mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n    if (align == 0) {\n        ray.pos.xy = ray.pos.yx;\n        ray.dir.xy = ray.dir.yx;\n    }\n\n    if (align == 2) {\n        ray.pos.yz = ray.pos.zy;\n        ray.dir.yz = ray.dir.zy;\n    }\n\n    // Quadratic coefficients\n    float a = dot(ray.dir.xz, ray.dir.xz);\n    float b = 2.0 * dot(ray.pos.xz, ray.dir.xz);\n    float c = dot(ray.pos.xz, ray.pos.xz) - radius * radius;\n\n    // Solve with a plane for the base and top\n    float discr = b * b - 4.0 * a * c;\n    if (discr > 0.0) {\n        float hh = 0.5 * height;\n        float tBase = +(hh - ray.pos.y) / ray.dir.y;\n        float tTop  = -(hh + ray.pos.y) / ray.dir.y;\n        vec4 roots = vec4(-(vec2(-1, 1) * sqrt(discr) + b) / a * 0.5, tBase, tTop);\n\n        float t = INFINITY;\n        vec3 hitPos, nor = vec3(0.0, -1.0, 0.0);\n        int nClosest;\n        for (int n=0; n < 4; n++) {\n            vec3 hitCandid = ray.pos + ray.dir * roots[n];\n            if (roots[n] > 0.0 && roots[n] < t  && abs(hitCandid.y) < hh + EPSILON && dot(hitCandid.xz, hitCandid.xz) < radius * radius + EPSILON) {\n                t = roots[n];\n                hitPos = hitCandid;\n                nClosest = n;\n            }\n        }\n\n        if (nClosest < 2) nor = vec3(hitPos.xz / radius, 0.0).xzy; // Sides\n        else nor.y = sign(2.5 - float(nClosest)); // Base and top\n        if (t > 0.0 && t < INFINITY && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = hitPos + pos;\n            scene.nor = nor;\n            scene.mat = mat;\n            if (align == 0) {\n                scene.pos.xy = scene.pos.yx;\n                scene.nor.xy = scene.nor.yx;\n            }\n\n            if (align == 2) {\n                scene.pos.yz = scene.pos.zy;\n                scene.nor.yz = scene.nor.zy;\n            }\n        }\n    }\n}\n\n// Main scene\nTraceInfo traceScene(in Ray ray) {\n    TraceInfo scene = TraceInfo(false, -1.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\n    vec3 dims = vec3(1.0);\n    dims = vec3(0.75, 1.5, 0.75);\n\n    float y = iTime; // Yaw\n    float p = 0.5;   // Pitch\n    float r = iTime; // Roll\n\n    float cy = cos(y), sy = sin(y);\n    float cp = cos(p), sp = sin(p);\n    float cr = cos(r), sr = sin(r);\n\n    mat3 mat = mat3(cy * cr + sy * sp * sr, cp * sr,  sy * cr - cy * sp * sr,\n                    sy * sp * cr - cy * sr, cp * cr, -sy * sr - cy * sp * cr,\n                                  -sy * cp,      sp,                 cy * cp);\n\n    mat[0].x += sin(iTime);\n    mat[2].y += cos(iTime);\n\n    vec3 bbox = transformedBoxAABB(dims, mat);\n    if (testAABB(vec3(0.0), bbox, ray)) addBox(vec3(0.0), dims, mat, vec3(1.0, 0.5, 0.0), ray, scene);\n\n    float width = 2.0 * bbox.x;\n    addCylinder(vec3(0.0, -bbox.y, -bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0,  bbox.y, -bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0,  bbox.y,  bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(0.0, -bbox.y,  bbox.z), 0, width, 0.05, vec3(0.0), ray, scene);\n\n    float height = 2.0 * bbox.y;\n    addCylinder(vec3(-bbox.x, 0.0, -bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, 0.0, -bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, 0.0,  bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(-bbox.x, 0.0,  bbox.z), 1, height, 0.05, vec3(0.0), ray, scene);\n\n    float depth = 2.0 * bbox.z;\n    addCylinder(vec3(-bbox.x, -bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x, -bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3( bbox.x,  bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n    addCylinder(vec3(-bbox.x,  bbox.y, 0.0), 2, depth, 0.05, vec3(0.0), ray, scene);\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * PI;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    Light light = Light(vec3(-10.0, 10.0, 10.0), vec3(0.8, 0.2, 0.2));\n\n    // Mouse rotation\n    vec2 c = cos(mouse), s = sin(mouse);\n    mat2 yaw = mat2(c.x, -s.x, s.x, c.x);\n    mat2 pitch = mat2(c.y, -s.y, s.y, c.y);\n\n    // Take multiple subsamples for antialiasing\n    float aaStep = 1.0 / float(AA);\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            vec2 uv = (fragCoord + vec2(xOffs, yOffs) - center) / iResolution.y;\n            Ray camRay = Ray(vec3(0.0, 0.0, 8.0), normalize(vec3(uv, -ZOOM)));\n\n            // Rotate with mouse\n            camRay.pos.yz *= pitch;\n            camRay.pos.xz *= yaw;\n            camRay.dir.yz *= pitch;\n            camRay.dir.xz *= yaw;\n\n            // Render the scene\n            TraceInfo scene = traceScene(camRay);\n            if (scene.hit) {\n                vec3 lightDir = normalize(light.pos - scene.pos);\n                float shade = max(0.0, dot(scene.nor, lightDir));\n                fragColor.rgb += light.color * scene.mat * shade;\n            }\n\n            // Sample the background on a miss\n            else fragColor += 1.15 - length(uv);\n        }\n    }\n\n    // Average and tonemap\n    fragColor.rgb = pow(fragColor.rgb / float(AA * AA), vec3(0.75));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flB3DD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 519, 571, 571, 783], [785, 855, 909, 909, 1149], [1151, 1151, 1258, 1258, 1943], [1945, 1965, 2092, 2092, 3944], [3946, 3960, 3994, 3994, 5921], [5923, 5923, 5978, 5978, 7461]], "test": "untested"}
{"id": "NlBGWD", "name": "iChannel texture - 001", "author": "catafest", "description": "a simple iChannel texture mapping by UV", "tags": ["texture", "ichannel"], "likes": 0, "viewed": 1124, "published": 3, "date": "1623873566", "time_retrieved": "2024-07-30T19:15:41.433665", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy / iResolution.xy;\n    \n   vec4 color = vec4(0.0,0.0,0.0,0.0);\n    \n    if (uv.x > 0.0 && uv.x < 0.5)\n    {\n   \t\tcolor = texture(iChannel0, vec2(1.0 - (uv.x/0.5), uv.y/0.5));\n    } \n    else if (uv.x > 0.5 && uv.x < 1.0) \n    { \n        color = texture(iChannel1, vec2(1.0 - (uv.x/0.5), uv.y));\n    } \n\tfragColor = color;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBGWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 403]], "test": "untested"}
{"id": "flSGDW", "name": "polar rave 2.2", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 6, "viewed": 336, "published": 3, "date": "1623868105", "time_retrieved": "2024-07-30T19:15:42.190640", "image_code": "// Fork of \"polar rave 2\" by firebreathz. https://shadertoy.com/view/slj3zw\n// 2021-06-16 18:27:30\n\n// Fork of \"polar rave\" by firebreathz. https://shadertoy.com/view/7l2Gzw\n// 2021-06-13 21:22:36\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 21:01:10\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 40\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 5.0*uv-2.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    uv.x-=0.5;\n    //uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 9.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band/band*band; \n    \n    band = band*0.03;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,-10.000) ).x;  \n    \n    if(band<0.0||band>=10.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 6;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.05,1.05,1.0);\n    colors[1] = vec3(1.205,1.00,1.00);\n    colors[2] = vec3(0.608,0.000,0.608);\n    colors[3] = vec3(1.90,0.75,3.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-0)/n)*n);\n    }\n    \n    float h = PI*0.4;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.1,0.75,f);\n    col *= smoothstep(1.875,0.025,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(3.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.x));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.x));\n    ref += drawBands(vec2(p.x,1.0+p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0+p.y+eps.y));\n\n    ref /= -8.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.5*smoothstep(10.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.2)*smoothstep(1.0,0.0,length(p*2.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(6.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(0.10-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2226.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSGDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 426, 426, 507], [509, 509, 551, 551, 610], [612, 612, 637, 637, 2180], [2182, 2182, 2239, 2239, 3496]], "test": "untested"}
{"id": "7tj3W1", "name": "dust", "author": "forerun", "description": "dusty ting", "tags": ["dust"], "likes": 6, "viewed": 401, "published": 3, "date": "1623857101", "time_retrieved": "2024-07-30T19:15:42.948614", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //storm settings\n    float strength = smoothstep(-1.0,-1.0,sin(iTime*0.25));  // 0.0 - 1.0\n    float blowout_factor = 2.5;\n    float distort_strength = 0.2;\n    float xspd = -1.0;\n    float yspd = 0.1;\n    \n    //setup texture scaling and movement\n    float tex_x = mod( ((uv.x * 4.0) + (iTime * xspd)) , 1.0 );\n    float tex_y = mod( ((uv.y * 4.0) + (iTime * yspd)) , 1.0 );\n    \n    float tex1_x = mod( ((uv.x * 2.0) + (iTime * xspd)) , 1.0 );\n    float tex1_y = mod( ((uv.y * 2.0) + (iTime * yspd)) , 1.0 );\n    \n    float tex2_x = mod( ((uv.x * 1.0) + (iTime * xspd)) , 1.0 );\n    float tex2_y = mod( ((uv.y * 1.0) + (iTime * yspd)) , 1.0 );\n    \n    //get 3 layers of texture\n    float texColor = texture( iChannel1, vec2(tex_x,tex_y) ).r;\n    float texColor1 = texture( iChannel1, vec2(tex1_x,tex1_y) ).r;\n    float texColor2 = texture( iChannel1, vec2(tex2_x,tex2_y) ).r;\n    \n    //mix texture layers  \n    float t = max( max(dot( texColor, 0.28), dot( texColor1, 0.34)), dot( texColor2, 0.34));\n  \tt *= strength;\n    \n    //set storm intensity as distort\n    float noise = smoothstep(0.11,0.45,t);\n    vec2 sceneNoise = uv + (vec2(noise*xspd,noise*yspd)*distort_strength);\n    \n    //get scene\n    vec3 sceneColor = texture( iChannel0, sceneNoise ).rgb;\n    \n    t *= blowout_factor;\n    \n    //mix colorized textures to scene\n    fragColor.rgb = mix(sceneColor, vec3(0.65, 0.52, 0.44), t);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3W1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1513]], "test": "untested"}
{"id": "sljGW1", "name": "slowest grapher of all time", "author": "Maximxls", "description": "from no optimizations to recalculation of some values for every pixel", "tags": ["math"], "likes": 2, "viewed": 213, "published": 3, "date": "1623854828", "time_retrieved": "2024-07-30T19:15:43.699606", "image_code": "#define xFrom -16.\n#define xTo    16.\n#define yFrom -9.\n#define yTo    9.\n\n#define Treshold       10.\n#define axesThickness  0.05\n\n#define RADIUS 3.\n\nfloat leftSide(float x, float y)\n{\n    return RADIUS*RADIUS;\n}\n\nfloat rightSide(float x, float y)\n{\n    return x * x + y * y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Size of the screen in coordinate system units\n    vec2 span = vec2(xTo - xFrom, yTo - yFrom);\n    \n    // Pixel in coordinate system\n    vec2 point = vec2(xFrom + uv.x * span.x, yFrom + uv.y * span.y);\n    \n    // Treshold\n    vec2 tresholds = Treshold / span;\n    float treshold = min(tresholds.x, tresholds.y);\n    \n    // If point is a solution\n    bool sol = abs(leftSide(point.x, point.y) - rightSide(point.x, point.y)) < treshold;\n    \n    // If point is on axes\n    bool axes = abs(point.x) < axesThickness || abs(point.y) < axesThickness;\n    \n    float col = 1.;\n    \n    if (sol || axes) {\n        col = 0.;\n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljGW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 184, 184, 212], [214, 214, 249, 249, 277], [279, 279, 336, 386, 1126]], "test": "untested"}
{"id": "7tjGDh", "name": "shrogger", "author": "forerun", "description": "grogger", "tags": ["progger"], "likes": 1, "viewed": 217, "published": 3, "date": "1623854332", "time_retrieved": "2024-07-30T19:15:44.447606", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //storm settings\n    float strength = smoothstep(-1.0,-1.0,sin(iTime*0.25));  // 0.0 - 1.0\n    float blowout_factor = 2.5;\n    float distort_strength = 0.2;\n    float xspd = -1.0;\n    float yspd = 0.1;\n    \n    //setup texture scaling and movement\n    float tex_x = mod( ((uv.x * 4.0) + (iTime * xspd)) , 1.0 );\n    float tex_y = mod( ((uv.y * 4.0) + (iTime * yspd)) , 1.0 );\n    \n    float tex1_x = mod( ((uv.x * 2.0) + (iTime * xspd)) , 1.0 );\n    float tex1_y = mod( ((uv.y * 2.0) + (iTime * yspd)) , 1.0 );\n    \n    float tex2_x = mod( ((uv.x * 1.0) + (iTime * xspd)) , 1.0 );\n    float tex2_y = mod( ((uv.y * 1.0) + (iTime * yspd)) , 1.0 );\n    \n    //get 3 layers of texture\n    float texColor = texture( iChannel1, vec2(tex_x,tex_y) ).r;\n    float texColor1 = texture( iChannel1, vec2(tex1_x,tex1_y) ).r;\n    float texColor2 = texture( iChannel1, vec2(tex2_x,tex2_y) ).r;\n    \n    //mix texture layers  \n    float t = max( max(dot( texColor, 0.28), dot( texColor1, 0.34)), dot( texColor2, 0.34));\n  \tt *= strength;\n    \n    //set storm intensity as distort\n    float noise = smoothstep(0.11,0.45,t);\n    vec2 sceneNoise = uv + (vec2(noise*xspd,noise*yspd)*distort_strength);\n    \n    //get scene\n    vec3 sceneColor = texture( iChannel0, sceneNoise ).rgb;\n    \n    t *= blowout_factor;\n    \n    //mix colorized textures to scene\n    fragColor.rgb = mix(sceneColor, vec3(0.65, 0.52, 0.44), t);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1513]], "test": "untested"}
{"id": "NtS3Dh", "name": "_ Simple Camera Rotation _", "author": "Mihaha", "description": "The pivot function itself:\nx1 = x*cos(r) - y*sin(r)\ny1 = x*sin(r) + y*cos(r)\n--------------------------------------\nfloat r = 45; // Angle of Rotation\nuv *= mat2( cos(r), -sin(r), sin(r), cos(r) );", "tags": ["vignette", "rotation", "figures"], "likes": 2, "viewed": 318, "published": 3, "date": "1623845109", "time_retrieved": "2024-07-30T19:15:45.201590", "image_code": "/*\n\n> by MihasGames, 16.06.2021 - 17.06.2021 <\n(https://mihas-games.itch.io/)\n\nThank FabriceNeyret2 for the recommendations for improving the code!\n\n*/\n\nfloat sum(vec2 v) { return v.x + v.y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    float map = 4., \n          t = iTime;\n    \n    // Pixel Normalizations //\n    vec2 uv101 = fragCoord.xy/iResolution.xy - 0.5,\n         uv = uv101*map * vec2(iResolution.x / iResolution.y, 1);\n    \n    // Rotation //\n    float r = t/1.5; // Angle of Rotation\n    uv *= mat2( cos(r), -sin(r), sin(r), cos(r) );\n    \n    // Figures //\n    if (sum(cos(uv*30.)) > 0.9) col = vec3(uv.x, uv.y, 1); // Multicolored Circles\n    \n    float k = (cos(t*2.)*0.5+0.5)*3.+0.5;\n    if (sum( pow(abs(uv), vec2(k)) ) < 1.) col -= 1.; // Black Figure\n    \n    col *= (1. - length(uv101/2.))*1.2; // Vignette\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3Dh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[153, 153, 172, 172, 192], [194, 194, 251, 251, 906]], "test": "untested"}
{"id": "fljGW1", "name": "Martian Tango", "author": "dr2", "description": "The complete Mars experience", "tags": ["interactive", "mars", "drive", "helicopter", "rover"], "likes": 20, "viewed": 331, "published": 3, "date": "1623836174", "time_retrieved": "2024-07-30T19:15:46.233830", "image_code": "// \"Martian Tango\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Drive the Mars rover; mouseable; knob controls rover speed and steering\n  (otherwise random path).\n  Copter flies autonomously (sometimes close to ground); slow horizontal response\n  and rapid vertical collision avoidance leads to interesting behavior (hence\n  the tango).\n  Wheel tracks remain on ground (temporarily).\n  Inset views are from forward and downward wide-angle copter cameras.\n  You are on the pale blue dot.\n  (Portions from \"Drive The Rover\", \"Lunar Buggy\" and \"Fly The Mars Copter\".)\n*/\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri);\nfloat Maxv2 (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Noiseff (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int npTrail = 64;  // same for image and buffer\nconst int npFst = 9;\n\nmat3 flMat;\nvec3 sunDir, qHit, carPos, wlBase, flPos;\nvec2 wlRot[2], csArm, csArmA, flHip;\nfloat tCur, dstFar, carRot, strRot, flDir, flTilt, legLenU, legLenD, aU, aD, pPitch,\n   pRot, flScl, dGlow;\nint idObj, idVu;\nbool isSh;\nconst int idChas = 1, idFuel = 2, idWhl = 3, idLnk = 4, idArm = 5, idPiv = 6, idAxl = 7,\n   idTur = 8, idGrbl = 9, idCamR = 10, idCamP = 11, idAnt = 12, idSol = 13,\n   idFlBod = 14, idLeg = 15, idPTube = 16, idProp = 17, idCamV = 18, idCamH = 19;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat CarDf (vec3 p)\n{\n  vec3 q, qq, bSize;\n  vec2 kRot;\n  float dMin, d, r, a, s, rt, wlRad, armLen;\n  dMin = dstFar;\n  p -= carPos;\n  p.xz = Rot2D (p.xz, carRot);\n  bSize = vec3 (0.8, 0.3, 1.6);\n  rt = 0.07;\n  wlRad = wlBase.y;\n  armLen = 1.;\n  p.y -= wlRad;\n  for (float k = float (VAR_ZERO); k < 2.; k ++) {\n    q = p;\n    q.x = abs (q.x) - wlBase.x;\n    if (k == 1.) q.xz = Rot2D (vec2 (q.x, abs (q.z) - wlBase.z), - strRot * sign (p.x));\n    q.y -= 0.85;\n    d = PrCapsDf (q.xzy, rt, 0.15);\n    q.y -= -0.5;\n    d = min (d, max (PrTorusBxDf (q, vec3 (0.25, 0.2, 0.15), rt), q.x));\n    DMINQ (idLnk);\n  }\n  for (float k = float (VAR_ZERO); k < 6.; k ++) {\n    kRot = vec2 (2. * mod (k, 2.), floor (k / 2.)) - 1.;\n    q = p;\n    q.xz -= kRot.xy * wlBase.xz;\n    if (kRot.y != 0.) q.xz = Rot2D (q.xz, - strRot * kRot.y);\n    r = length (q.yz);\n    d = length (max (vec2 (r - wlRad, abs (q.x) - 0.15) - 0.1, 0.));\n    if (d < 0.1) {\n      d = max (length (max (vec2 (r - wlRad, abs (q.x) - 0.15), 0.)) - 0.05, wlRad - 0.02 - r);\n      q.yz = (kRot.y != 1.) ? Rot2D (q.yz, - ((kRot.x < 0.) ? wlRot[0].x : wlRot[0].y)) :\n         Rot2D (q.yz, - ((kRot.x < 0.) ? wlRot[1].x : wlRot[1].y));\n      a = (r > 0.) ? atan (q.z, - q.y) / (2. * pi) : 0.;\n      d = max (d, 0.03 - length (Rot2D (q.yz, 2. * pi * floor (28. * a + 0.5) / 28.) + \n         vec2 (wlRad + 0.05, 0.)));\n      d = min (d, max (abs (r - wlRad + 0.04) - 0.02, abs (q.x) - 0.04));\n      q.yz = Rot2D (q.yz, 2. * pi * floor (7. * a + 0.5) / 7.);\n      d = min (d, max (PrTorusBxDf (q - vec3 (0., -0.31, 0.), vec3 (0.08, 0.05, 0.1), 0.02),\n         - q.x * kRot.x));\n      d = min (d, max (r - 0.18, abs (q.x) - 0.2));\n      DMINQ (idWhl);\n    } else dMin = min (dMin, d);\n  }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (wlBase.x, 1., -1.);\n  d = PrRoundCylDf (q.yzx, 0.1, 0.02, 0.1);\n  DMINQ (idAxl);\n  d = PrCapsDf (q, rt, 1.);\n  q.z -= 1.5;\n  d = min (d, max (PrTorusBxDf (q.yzx, vec3 (0.05, 1.1, 0.4), rt), - q.y));\n  DMINQ (idLnk);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (wlBase.xz, 0.85).xzy;\n  d = PrRoundCylDf (q.xzy, 0.1, 0.02, 0.04);\n  DMINQ (idGrbl);\n  q = p;\n  q.y -= 1.45;\n  d = PrCylDf (q.yzx, 0.1, wlBase.x);\n  q.x = abs (abs (q.x) - wlBase.x + 0.3) - 0.3;\n  d = min (d, PrRoundCylDf (q.yzx, 0.1, 0.02, 0.1));\n  DMINQ (idAxl);\n  q = p;\n  q.y -= 1.5;\n  d = PrRoundBoxDf (q, bSize, 0.02);\n  DMINQ (idChas);\n  qq = abs (q) - vec3 (0.35, 0.22, 0.8);\n  d = min (min (PrTorusBxDf (vec3 (q.yz, qq.x), vec3 (bSize.yz, 0.03), 0.03),\n     PrTorusBxDf (vec3 (q.xz, qq.y), vec3 (bSize.xz, 0.03), 0.03)),\n     PrTorusBxDf (vec3 (q.xy, qq.z), vec3 (bSize.xy, 0.03), 0.03));\n  DMIN (idGrbl);\n  q = p;\n  q.yz -= vec2 (1.85, -1.6);\n  d = PrRoundCylDf (q.yzx, 0.3, 0.1, 0.6);\n  DMINQ (idFuel);\n  d = PrTorusBxDf (q.xzy, vec3 (0.6, 0.3, 0.1), 0.03);\n  DMIN (idGrbl);\n  q = p;\n  q.x = abs (abs (q.x) - 0.18);\n  d = PrCapsDf (q - vec3 (0.05, 1.16, bSize.z), 0.04, 0.1);\n  DMIN (idGrbl);\n  q = p;\n  q.yz -= vec2 (1.75, 1.8);\n  d = PrRoundBoxDf (q, vec3 (0.15, 0.05, 0.2), 0.02);\n  DMIN (idGrbl);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z - 0.85));\n  q -= vec3 (0.55, 1.8, 0.25);\n  d = PrRoundCylDf (q.xzy, 0.1, 0.02, 0.1);\n  q.y -= 0.1;\n  d = min (d, PrSphDf (q, 0.05));\n  DMIN (idGrbl);\n  q = p;\n  q.yz -= vec2 (1.8, 1.1);\n  d = PrRoundBoxDf (q, vec3 (0.2, 0.1, 0.2), 0.02);\n  q.xz = abs (q.xz);\n  d = min (d, PrSphDf (q - vec3 (0.1, 0.12, 0.1), 0.05));\n  DMIN (idGrbl);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z + 0.1)) - vec2 (0.65, 0.3);\n  q.y -= 1.85;\n  d = PrRoundCylDf (q.xzy, 0.1, 0.02, 0.02);\n  DMIN (idGrbl);\n  q = p;\n  q.y -= 2.02;\n  d = PrRoundCylDf (q.xzy, 0.3, 0.02, 0.2);\n  DMINQ (idTur);\n  q.y -= 0.4;\n  d = PrRoundCylDf (q.xzy, 0.22, 0.02, 0.2);\n  DMINQ (idTur);\n  q = p;\n  q.y -= 2.6;\n  d = PrCapsDf (q.yzx, 0.03, 0.6);\n  DMIN (idGrbl);\n  q.x = abs (q.x) - 0.46;\n  q.yz = Rot2D (q.yz, -0.2 * pi);\n  d = PrRoundBoxDf (q, vec3 (0.15, 0.01, 0.25), 0.01);\n  DMINQ (idSol);\n  q = p;\n  q.xz = abs (vec2 (q.x, q.z - 0.3));\n  q -= vec3 (0.75, 1.8, 1.2);\n  d = PrCapsDf (q.xzy, 0.05, 0.2);\n  DMIN (idGrbl);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.78, 2.25, -0.9);\n  q.xy = Rot2D (q.xy, 0.1 * pi);\n  d = max (abs (PrSphDf (q, 0.25)) - 0.01, q.y + 0.05);\n  DMINQ (idAnt);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.75, 2., 1.55);\n  q.yz = Rot2D (q.yz, -0.05 * pi);\n  d = PrCapsDf (q, 0.1, 0.1);\n  DMINQ (idCamR);\n  q = p;\n  q.xz = abs (q.xz);\n  q -= vec3 (bSize.xz, 1.2).xzy;\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  d = PrSphDf (q, 0.1);\n  DMINQ (idCamR);\n  q = p;\n  q.y -= 1.1;\n  q.yz = Rot2D (q.yz, -0.5 * pi);\n  d = PrSphDf (q, 0.1);\n  DMINQ (idCamR);\n  q = p;\n  q.y -= 3.;\n  d = PrCylDf (q.xzy, 0.05, 0.8);\n  DMIN (idGrbl);\n  q.y -= 0.8;\n  d = PrRoundCylDf (q.xzy, 0.2, 0.02, 0.08);\n  DMINQ (idCamP);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 1.2, 1.7);\n  d = PrCapsDf (q, 0.03, 0.2);\n  q.z -= 0.2;\n  d = min (d, PrCapsDf (q.xzy, 0.02, 0.3));\n  DMIN (idGrbl);\n  q = p;\n  q.yz -= vec2 (1.85, 1.9);\n  d = PrRoundCylDf (q.xzy, 0.05, 0.02, 0.05);\n  q.y -= 0.15;\n  q.yz = Rot2Cs (q.yz, csArmA) - 2. * armLen * csArm.yx;\n  q.z = abs (q.z);\n  q.yz -= 2. * armLen * (csArm * vec2 (1., -1.)).yx;\n  q.yz = Rot2Cs (q.yz, csArm * vec2 (1., -1.));\n  q.z -= - armLen;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.03, 0.04, armLen), 0.02));\n  DMINQ (idArm);\n  q.z = abs (q.z) - armLen;\n  d = PrRoundCylDf (q.yzx, 0.1, 0.02, 0.08);\n  DMINQ (idPiv);\n  q = p;\n  q.yz -= vec2 (1.85, 2.) + Rot2Cs (vec2 (0., 4. * armLen * csArm.x), csArmA * vec2 (1., -1.));\n  d = PrRoundCylDf (q.xzy, 0.2, 0.02, 0.05);\n  q.z = abs (q.z);\n  q.yz -= vec2 (-0.1, 0.1);\n  d = min (d, PrCapsDf (q.xzy, 0.02, 0.05));\n  DMIN (idGrbl);\n  return dMin;\n}\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q;\n  vec2 fb;\n  float dMin, d;\n  p = flMat * (p - vec3 (flPos.xz, flHip.y * flScl).xzy);\n  p.y -= 0.5;\n  dMin = dstFar / flScl;\n  p /= flScl;\n  p.y += flHip.y;\n  q = p;\n  q.y -= flHip.y;\n  fb = normalize (vec2 (1.2, 1.));\n  for (float k = -1. + float (VAR_ZERO); k <= 1.; k += 2.) {\n    q = p;\n    q.xz = Rot2D (q.xz, k * pRot);\n    q.y -= flHip.y + 2.4 + 1.2 * k;\n    d = PrRoundCylDf (q.xzy, 0.2 - 0.05 * k, 0.01, 1.2);\n    DMINQ (idPTube);\n    q.y -= 1.;\n    d = min (max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (q.x, abs (q.z)), fb)),\n       max (PrRoundCylDf (vec3 (q.x, Rot2D (q.yz, - k * pPitch)).xzy, 3., 0.02, 0.01),\n       dot (vec2 (- q.x, abs (q.z)), fb)));\n    DMINQ (idProp);\n  }\n  q = p;\n  q.y -= flHip.y + 0.1;\n  d = PrRoundCylDf (q.xzy, flHip.x, 0.05, 0.2);\n  q.y -= 0.4;\n  d = min (d, PrRoundCylDf (q.xzy, 0.35 * flHip.x, 0.05, 0.15));\n  DMINQ (idFlBod);\n  q = p;\n  q.y -= flHip.y - 0.2;\n  d = PrCapsDf (q.xzy, 0.35 * flHip.x, 0.1);\n  DMINQ (idCamV);\n  q.yz -= vec2 (0.2, flHip.x);\n  d = PrCapsDf (q, 0.15 * flHip.x, 0.2);\n  DMINQ (idCamH);\n  q = p;\n  q.xz = Rot2D (q.xz, pi / 6.);\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi)) + 0.5) / 6.);\n  q.xy = Rot2D (q.xy - flHip * vec2 (-1., 1.), aU);\n  q.x += 0.5 * legLenU;\n  d = PrCapsDf (q.yzx, 0.1 * (0.8 + 0.2 * q.x / (0.5 * legLenU)) / 0.6, 0.5 * legLenU);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenU;\n  q.xy = Rot2D (q.xy, aD - aU);\n  q.x += 0.5 * legLenD;\n  d = PrCapsDf (q.yzx, 0.1 * (0.9 + 0.1 * q.x / (0.5 * legLenD)), 0.5 * legLenD);\n  DMINQ (idLeg);\n  q.x += 0.5 * legLenD;\n  q.xy = Rot2D (q.xy, 0.5 * pi - aD);\n  q.x -= -0.02;\n  d = PrRoundCylDf (q.yzx, 0.3, 0.02, 0.05);\n  DMINQ (idLeg);\n  if (idVu == 0 && ! isSh) dGlow = min (dGlow, dMin);\n  return flScl * dMin;\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = CarDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat ObjFRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = CarDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjFNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = min (CarDf (p), FlyerDf (p));\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 CarCol ()\n{\n  vec3 col;\n  float a, r;\n  if (idObj == idCamP || idObj == idTur || idObj == idAnt) a = atan (qHit.x, qHit.z) / (2. * pi);\n  if (idObj == idWhl || idObj == idAxl || idObj == idPiv || idObj == idFuel) r = length (qHit.yz);\n  else if (idObj == idCamP || idObj == idTur) r = length (qHit.xz);\n  if (idObj <= idPiv) {\n    if (idObj == idChas) col = vec3 (1., 1., 0.9) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (PrRoundBox2Df (vec2 (qHit.y, abs (abs (qHit.z) - 0.8) - 0.4), vec2 (0.05, 0.15), 0.05))));\n    else if (idObj == idFuel) col = vec3 (0.8, 0.85, 0.9) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (PrRoundBox2Df (qHit.xz, vec2 (0.3, 0.1), 0.02) - 0.1))) *\n       (0.8 + 0.2 * smoothstep (0., 0.02, abs (abs (r - 0.23) - 0.03)));\n    else if (idObj == idWhl) col = (r > 0.13) ? vec3 (0.95, 0.95, 1.) * (1. - 0.3 * step (0.47, r)) :\n       vec3 (1., 0.5, 0.) * (0.3 + 0.7 * smoothstep (0., 0.02, r - 0.05));\n    else if (idObj == idLnk) col = vec3 (0.9, 0.9, 1.);\n    else if (idObj == idArm) col = vec3 (0.9, 1., 0.9) * (0.8 + 0.2 * smoothstep (0., 0.02,\n       abs (mod (qHit.z + 0.1, 0.2) - 0.1)));\n    else if (idObj == idPiv) col = vec3 (0.8, 0.9, 0.9) * (0.5 + 0.5 * smoothstep (0., 0.01,\n       min (abs (abs (qHit.x) - 0.04), r - 0.02) - 0.01));\n  } else {\n    if (idObj == idAxl) col = vec3 (0.9, 0.95, 0.9) * (0.5 + 0.5 * smoothstep (0., 0.02,\n       abs (r - 0.07) - 0.01)) * (0.5 + 0.5 * smoothstep (0., 0.01, abs (abs (qHit.x) - 0.06) - 0.01));\n    else if (idObj == idTur) col = vec3 (0.9, 0.95, 0.9) * (1. - 0.3 * smoothstep (0., 0.02,\n       0.05 - abs (abs (qHit.y) - 0.1)) *  smoothstep (0., 0.02, abs (mod (8. * a + 0.5, 1.) -\n       0.5) - 0.35)) * (0.8 + 0.2 * smoothstep (0., 0.02, abs (r - 0.15) - 0.01));\n    else if (idObj == idGrbl) col = vec3 (0.9, 0.9, 0.8);\n    else if (idObj == idCamR) col = mix (vec3 (0.2), vec3 (0.9, 0.3, 0.3), (1. - step (0., qHit.z) *\n       smoothstep (0., 0.01, 0.1 - length (qHit.xy))));\n    else if (idObj == idCamP) col = mix (vec3 (0.2), vec3 (0.9, 0.3, 0.3), smoothstep (0., 0.02,\n       length (vec2 (Rot2D (qHit.xz, 2. * pi * (floor (8. * a + 0.5) / 8.)).x, qHit.y)) - 0.05)) *\n       (0.7 + 0.3 * smoothstep (0., 0.02, abs (r - 0.15) - 0.01));\n    else if (idObj == idAnt) col = vec3 (0.5, 0.9, 0.5) * (1. - 0.3 * smoothstep (0., 0.02,\n       abs (mod (16. * a + 0.5, 1.) - 0.5) - 0.35));\n    else if (idObj == idSol) col = (qHit.y > 0.) ? vec3 (0.9, 0.9, 0.3) : vec3 (0.8, 0.8, 0.7);\n  }\n  return vec4 (col, 0.1);\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4;\n  float r;\n  if (idObj == idFlBod || idObj == idProp) r = length (qHit.xz);\n  if (idObj == idFlBod) col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02,\n     abs (r - 1.1) - 0.1));\n  else if (idObj == idLeg) col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * sin (8. * pi * qHit.x));\n  else if (idObj == idPTube) col4 = vec4 (0.8, 1., 0.8, 0.2) * (1. - 0.2 *\n     sin (4. * atan (qHit.z, qHit.x)));\n  else if (idObj == idProp) col4 = vec4 (1., 0.9, 0.8, 0.2) * (0.9 + 0.1 * sin (8. * pi * r));\n  else if (idObj == idCamV) col4 = vec4 (0.1, 0.1, 0.1, 0.2);\n  else if (idObj == idCamH) col4 = mix (vec4 (0.1, 0.1, 0.1, 0.2), vec4 (0.6 +\n     0.4 * sin (4. * pi * tCur), 0., 0., -1.), step (length (qHit.xy), 0.1));\n  return col4;\n}\n\nfloat TrailShd (vec2 p)\n{\n  vec3 u;\n  vec2 gB[2], gF[2], dg, q;\n  float st, s, gLen;\n  st = 1.;\n  for (float kz = -1. + float (VAR_ZERO); kz <= 1.; kz ++) {\n    gB[0] = carPos.xz;\n    gF[0] = gB[0] + Rot2D (vec2 (0., kz * wlBase.z), - carRot);\n    for (int j = VAR_ZERO; j < npTrail; j ++) {\n      gB[1] = gB[0];\n      gF[1] = gF[0];\n      u = Loadv4 (npFst + j).xyz;\n      if (u.z >= 0.) {\n        gB[0] = u.xy;\n        gF[0] = gB[0] + Rot2D (vec2 (0., kz * wlBase.z), - u.z);\n        s = 1.;\n        if (kz == 0.) {\n          dg = gF[0] - gF[1];\n          gLen = length (dg);\n          if (gLen > 0.) {\n            q = Rot2Cs (p - 0.5 * (gF[0] + gF[1]), dg.yx / gLen);\n            q.x = abs (q.x) - wlBase.x;\n            s = min (s, PrRoundBox2Df (q, vec2 (0.08, 0.5 * gLen), 0.05));\n          }\n        } else {\n          for (float k = -1.; k <= 1.; k += 2.) {\n            dg = gF[0] - gF[1];\n            gLen = length (dg);\n            if (gLen > 0.) {\n              q = Rot2Cs (p - 0.5 * (gF[0] + gF[1]) + Rot2D (vec2 (k * wlBase.x, 0.), - u.z),\n                 dg.yx / gLen);\n              s = min (s, PrRoundBox2Df (q, vec2 (0.08, 0.5 * gLen), 0.05));\n            }\n          }\n        }\n        st = min (st, 1. - 0.3 * sqrt (1. - float (j) / float (npTrail)) *\n           (1. - smoothstep (0., 0.05, s)));\n      } else break;\n    }\n  }\n  return st;\n}\n\n#define SQ(x) ((x) * (x))\n\nvoid SetFlyerConf ()\n{\n  float legHtMin, legHtMax, toePos, d, h, c;\n  legLenU = 2.;\n  legLenD = 3.;\n  flHip.x = 1.5;\n  toePos = 4.;\n  legHtMin = 0.45 * (legLenU + legLenD);\n  legHtMax = sqrt (SQ (legLenU + legLenD) - SQ (toePos - flHip.x));\n  flHip.y = flPos.y / flScl + legHtMin;\n  h = min (flHip.y, legHtMax);\n  d = sqrt (SQ (h) + SQ (toePos - flHip.x));\n  c = (SQ (legLenU) - SQ (legLenD) + SQ (d)) / (2. * legLenU * d);\n  aU = acos (clamp (c, -1., 1.)) + acos (h / d) - 0.5 * pi;\n  c = (SQ (legLenU) + SQ (legLenD) - SQ (d)) / (2. * legLenU * legLenD);\n  aD = aU + acos (clamp (c, -1., 1.)) + pi;\n  d = flHip.y - (legLenU + legLenD);\n  if (d > 0.) {\n    d = 0.13 * pi * smoothstep (0., 5., d);\n    aU -= d;\n    aD -= d;\n  }\n}\n\nvoid SetCarConf ()\n{\n  float armAng;\n  armAng = pi * (0.2 + 0.15 * sin (0.2 * pi * tCur));\n  csArm = sin (armAng + vec2 (0.5 * pi, 0.));\n  csArmA = sin (-0.2 * pi + 0.5 * armAng + vec2 (0.5 * pi, 0.));\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd, float sh)\n{\n  vec3 col, vn;\n  vec2 vf;\n  float f, h, st;\n  f = 1. - smoothstep (0.3, 0.5, dstGrnd / dstFar);\n  h = f * Fbm2 (0.5 * ro.xz);\n  h = smoothstep (0.5, 0.7, h);\n  col = vec3 (0.6, 0.45, 0.2) * (1. - 0.3 * (1. - 0.7 * smoothstep (0.5, 0.8, dstGrnd / dstFar)) *\n     Fbm2 (4. * ro.xz) * (1. - 0.5 * h));\n  col *= 1. + 0.2 * h;\n  st = TrailShd (ro.xz);\n  vn = vec3 (0., 1., 0.);\n  if (f > 0.) vn = VaryNf (2. * ro, vn, (1. - 0.5 * h) * (1. + 2. * step (st, 0.99)) * f);\n  col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) * (0.3 + 0.7 * st) +\n     0.15 * h * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 qHitT, col, vn, bgCol;\n  float dstObj, dstCar, dstFlyer, dstGrnd, sh, f;\n  int idObjT;\n  bool isBg;\n  SetCarConf ();\n  isBg = false;\n  bgCol = vec3 (0.2, 0.15, 0.05);\n  isSh = false;\n  dstCar = ObjCRay (ro, rd);\n  idObjT = idObj;\n  qHitT = qHit;\n  dGlow = dstFar;\n  if (idVu == 0) {\n    dGlow /= flScl;\n    dstFlyer = ObjFRay (ro, rd);\n    dGlow *= flScl;\n  } else dstFlyer = dstFar;\n  dstGrnd = dstFar;\n  dstObj = min (dstCar, dstFlyer);\n  if (dstObj < dstFar) {\n    if (dstCar < dstFlyer) {\n      idObj = idObjT;\n      qHit = qHitT;\n    }\n    ro += dstObj * rd;\n    if (dstCar < dstFlyer) {\n      vn = ObjCNf (ro);\n      col4 = CarCol ();\n    } else {\n      vn = ObjFNf (ro);\n      col4 = FlyerCol ();\n    }\n    dGlow = dstFar;\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n  } else {\n    isBg = true;\n    col = bgCol;\n  }\n  if (! isBg) {\n    if (col4.a >= 0.) {\n      isSh = true;\n      sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      if (dstObj < dstFar) col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n      else col = mix (GrndCol (ro, rd, dstGrnd, sh), bgCol, smoothstep (0.5, 1.,\n         dstGrnd / dstFar));\n    } else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));\n  }\n  if (min (dstObj, dstGrnd) >= dstFar) {\n    col = bgCol + StarPat (rd, 8.);\n    col = mix (vec3 (0.2, 0.2, 1.), col, smoothstep (0., 2., 1e5 * (1. -\n       dot (rd, normalize (vec3 (1., 0.1, -1.))))));\n  }\n  if (idVu == 0) col = mix (col, vec3 (0.4, 0.6, 0.4), exp (- 16. * dGlow) *\n     (1. - 0.5 * Noiseff (tCur)));\n  return clamp (col, 0., 1.);\n}\n\nmat3 FlMat (float flTilt)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (flTilt, flDir);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n         mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y , 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col, wgBxC, g;\n  vec2 canvas, uv, ud, um, wd, mSize, ut[2], mMid[2], cnPos;\n  float el, az, asp, aspW, zmFac, s;\n  int wgSel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  mPtr.xyz = stDat.xyz;\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (1);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  stDat = Loadv4 (2);\n  wlBase = stDat.xyz;\n  stDat = Loadv4 (3);\n  strRot = stDat.y;\n  stDat = Loadv4 (4);\n  wlRot[0] = stDat.xy;\n  wlRot[1] = stDat.zw;\n  stDat = Loadv4 (5);\n  cnPos = stDat.xy;\n  stDat = Loadv4 (6);\n  flPos = stDat.xyz;\n  stDat = Loadv4 (8);\n  flDir = stDat.x;\n  flTilt = stDat.y;\n  flMat = FlMat (flTilt);\n  pRot = stDat.z;\n  pPitch = stDat.w;\n  aspW = 1.4;\n  mSize = 0.33 * vec2 (aspW, 1.);\n  mMid[0] = vec2 (- (asp - mSize.x), 1. - mSize.y);\n  mMid[1] = vec2 (asp - mSize.x, 1. - mSize.y);\n  ut[0] = abs (uv - mMid[0]) - mSize;\n  ut[1] = abs (uv - mMid[1]) - mSize;\n  idVu = 0;\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      idVu = k + 1;\n      break;\n    }\n  }\n  flScl = 0.25;\n  SetFlyerConf ();\n  az = 0.;\n  el = -0.1 * pi;\n  if (wgSel == 0 && mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.);\n  vuMat = StdVuMat (el, az);\n  if (idVu == 0) {\n    ro = carPos + vuMat * vec3 (0., 3., -20.);\n    zmFac = 3.5 + 2. * el;\n    rd = vuMat * normalize (vec3 (uv, zmFac)); \n  } else if (idVu == 1) {\n    ro = flPos + vec3 (0., 2., 0.);\n    zmFac = 0.8;\n    rd = normalize (vec3 (uv, zmFac));\n    rd.yz = Rot2D (rd.yz, 0.05 * pi);\n    rd = rd * flMat;\n  } else if (idVu == 2) {\n    ro = flPos + vec3 (0., 2., 0.);\n    zmFac = 0.4;\n    rd = normalize (vec3 (uv, zmFac));\n    rd.yz = Rot2D (rd.yz, 0.5 * pi);\n    rd.xz = Rot2D (rd.xz, flDir);\n  }\n  dstFar = 200.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 4.) col = vec3 (0.3, 0.6, 0.7);\n  }\n  if (idVu == 0) {\n    wgBxC = vec3 (0.39, -0.3, 0.135);\n    ud = 0.5 * uv - wgBxC.xy * vec2 (asp, 1.);\n    s = (length (ud) - wgBxC.z) * canvas.y;\n    col = mix (vec3 (0.7), col, smoothstep (0., 1., abs (s) - 1.));\n    if (s < 0.) {\n      col = mix (vec3 (0.7), col, smoothstep (0., 1., Minv2 (abs (ud)) * canvas.y - 1.));\n      col = mix (vec3 (0.3, 0.7, 1.), col, smoothstep (0., 1., abs (length (ud - cnPos) - 0.02) *\n         canvas.y - 1.));\n    }\n    um = vec2 (0.75, -0.96) * vec2 (asp, 1.);\n    ud = abs (uv - um) - vec2 (0.35, 0.05);\n    if (Maxv2 (ud) < 0.) {\n      uv -= um + vec2 (0.1, -0.02);\n      wd = vec2 (0.1, 0.06) * vec2 (asp, 1.);\n      g = floor (vec3 (5. * flPos.xz, 5. * (flPos.y + 1.)));\n      s = ShowInt (uv + vec2 (0.22, 0.), wd, 5., g.x) + ShowInt (uv, wd, 5., g.y) +\n         ShowInt (uv + vec2 (-0.22, 0.), wd, 5., g.z);\n      col = mix (col, vec3 (0.3, 0.7, 1.), s);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrTorusBxDf (vec3 p, vec3 b, float ri)\n{\n  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  q = 1. - smoothstep (vec2 (0.), vec2 (0.04, 0.07), abs (q) - vec2 (0.13, 0.5));\n  return q.x * q.y;\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  vec2 vp, vm, vo;\n  float d;\n  int k, kk;\n  vp = vec2 (0.5, 0.5);\n  vm = vec2 (-0.5, 0.5);\n  vo = vp - vm;\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Martian Tango\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Noiseff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int npTrail = 64;  // same for image and buffer\nconst int npFst = 9;\n\nvec3 carPos, wlBase;\nfloat carRot;\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 wgBxC, flPos, flVel, flAcc;\n  vec2 iFrag, canvas, cnPos, wlRot[2], ud, w, wr[2];\n  float tCur, tCurP, autoMd, cRotN, strRot, wlRad, rTurn[2], spd, tc, nStep, asp, s,\n     flDir, flDirN, flTilt, pRot, pPitch;\n  int pxId, wgSel, nFrame;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= npFst + npTrail) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  init = (nFrame <= 2);\n  asp = canvas.x / canvas.y;\n  if (init) {\n    carPos = vec3 (0.);\n    carRot = 0.;\n    strRot = 0.;\n    wlBase = vec3 (1.4, 0.5, 2.);\n    wlRot[0] = vec2 (0.);\n    wlRot[1] = vec2 (0.);\n    nStep = 0.;\n    cnPos = vec2 (0.);\n    mPtrP = mPtr;\n    wgSel = 0;\n    autoMd = 1.;\n    flPos = vec3 (0.);\n    flVel = vec3 (0.);\n    flDir = 0.5 * pi;\n    flTilt = 0.;\n    pRot = 0.;\n    pPitch = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP.xyz = stDat.xyz;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (1);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n    stDat = Loadv4 (2);\n    wlBase = stDat.xyz;\n    tCurP = stDat.w;\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    strRot = stDat.y;\n    autoMd = stDat.z;\n    stDat = Loadv4 (4);\n    wlRot[0] = stDat.xy;\n    wlRot[1] = stDat.zw;\n    stDat = Loadv4 (5);\n    cnPos = stDat.xy;\n    stDat = Loadv4 (6);\n    flPos = stDat.xyz;\n    stDat = Loadv4 (7);\n    flVel = stDat.xyz;\n    stDat = Loadv4 (8);\n    flDir = stDat.x;\n    flTilt = stDat.y;\n    pRot = stDat.z;\n    pPitch = stDat.w;\n  }\n  if (pxId < npFst) {\n    wgBxC = vec3 (0.39, -0.3, 0.135);\n    if (mPtr.z > 0.) {\n      ud = mPtr.xy * vec2 (asp, 1.) - wgBxC.xy * vec2 (asp, 1.);\n      if (wgSel == 1) {\n        autoMd = - tCur;\n        cnPos = ud;\n        s = length (cnPos);\n        if (s > 0.) cnPos = min (s, wgBxC.z) * cnPos / s;\n      } else if (mPtrP.z <= 0. && length (ud) < wgBxC.z) wgSel = 1;\n    } else {\n      wgSel = 0;\n      cnPos *= 1. - 5e-3;\n    }\n    wlRad = wlBase.y;\n    ++ nStep;\n    if (autoMd > 0.) {\n      tc = 0.005 * nStep;\n      s = 2. * Noiseff (37.1 * mod (floor (tc), 16.)) - 1.;\n      s = max (0.3, abs (s)) * sign (s);\n      strRot = 0.15 * pi * s * SmoothBump (0.2, 0.8, 0.1, mod (tc, 1.));\n      spd = 0.4 * (0.12 - 0.06 * abs (strRot / (0.12 * pi)));\n      w = vec2 (- strRot / (0.15 * pi), spd / 0.5);\n      w = pow (abs (w), 1. / vec2 (1.5)) * sign (w);\n      cnPos = w * wgBxC.z;\n    } else {\n      w = cnPos / wgBxC.z;\n      w = pow (abs (w), vec2 (1.5)) * sign (w);\n      strRot = -0.15 * pi * w.x;\n      spd = 0.06 * w.y;\n      if (tCur + autoMd > 10.) autoMd = 1.;\n    }\n    wr[0] = vec2 (1.);\n    wr[1] = wr[0];\n    flAcc = vec3 (carPos.xz - flPos.xz, 0.).xzy;\n    if (abs (strRot) > 1e-4) {\n      cRotN = carRot - strRot * spd / pi;\n      rTurn[0] = wlBase.z / asin (strRot);\n      s = wlBase.z / rTurn[0];\n      rTurn[1] = rTurn[0] * sqrt (1. - s * s);\n      carPos.xz += 2. * rTurn[0] * (sin (carRot - vec2 (0.5 * pi, 0.)) -\n         sin (cRotN - vec2 (0.5 * pi, 0.)));\n      carRot = mod (cRotN, 2. * pi);\n      wr[0] += vec2 (-1., 1.) * wlBase.x / rTurn[0];\n      wr[1] += vec2 (-1., 1.) * wlBase.x / rTurn[1];\n    } else {\n      carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n    }\n    wlRot[0] += wr[0] * spd / wlRad;\n    wlRot[1] += wr[1] * spd / wlRad;\n    flVel.xz = mix (flVel.xz, flAcc.xz, 0.003);\n    flPos.xz += 0.02 * flVel.xz;\n    flDirN = (length (flVel.xz) > 0.005) ? atan (- flVel.x, flVel.z) : flDir;\n    flDirN -= 2. * pi * sign (flDirN - flDir) * step (pi, abs (flDirN - flDir));\n    flDir = mix (flDir, flDirN, 0.01);\n    flPos.y = 6. * (1. - smoothstep (4., 10., length (flAcc)));\n    flTilt = min (0.03 * pi * length (flVel.xz), 0.1 * pi);\n    flTilt *= smoothstep (1., 2., flPos.y);\n    pRot += ((flPos.y > 0.05) ? 3. : 0.7) * pi * (tCur - tCurP);\n    pPitch = 0.05 * pi * (0.5 + 1.5 * smoothstep (0.03, 0.05, flPos.y));\n    flPos.y += 0.5 * Noiseff (tCur);\n  }\n  if (! init) {\n    if (nFrame + 5 < npTrail || mod (float (nFrame), 8.) == 0. &&\n       length (carPos.xz - Loadv4 (npFst).xy) > 0.5) {\n      if (pxId == npFst) stDat = vec4 (Loadv4 (1).xzw, 0.);\n      else if (pxId > npFst && pxId < npFst + npTrail) stDat = Loadv4 (pxId - 1);\n    } else if (pxId >= npFst && pxId < npFst + npTrail) stDat = Loadv4 (pxId);\n  } else {\n    stDat = vec4 (0., 0., -1., 0.);\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 1) stDat = vec4 (carPos, carRot);\n  else if (pxId == 2) stDat = vec4 (wlBase, tCur);\n  else if (pxId == 3) stDat = vec4 (nStep, strRot, autoMd, 0.);\n  else if (pxId == 4) stDat = vec4 (wlRot[0], wlRot[1]);\n  else if (pxId == 5) stDat = vec4 (cnPos, 0., 0.);\n  else if (pxId == 6) stDat = vec4 (flPos, 0.);\n  else if (pxId == 7) stDat = vec4 (flVel, 0.);\n  else if (pxId == 8) stDat = vec4 (flDir, flTilt, pRot, pPitch);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljGW1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2021, 2021, 2043, 2043, 7684], [7686, 7686, 7710, 7710, 9537], [9539, 9539, 9573, 9573, 9756], [9758, 9758, 9792, 9792, 9977], [9979, 9979, 10001, 10001, 10256], [10258, 10258, 10280, 10280, 10537], [10539, 10539, 10576, 10576, 10859], [10861, 10861, 10877, 10877, 13369], [13371, 13371, 13389, 13389, 14144], [14146, 14146, 14171, 14171, 15507], [15536, 15536, 15558, 15558, 16265], [16267, 16267, 16287, 16287, 16470], [16472, 16472, 16530, 16530, 17179], [17181, 17181, 17216, 17216, 17669], [17671, 17671, 17706, 17706, 19479], [19481, 19481, 19508, 19508, 19722], [19724, 19724, 19780, 19780, 22873], [22875, 22875, 22921, 22921, 22968], [22970, 22970, 23017, 23017, 23064], [23066, 23066, 23099, 23099, 23126], [23128, 23128, 23170, 23170, 23221], [23223, 23223, 23280, 23280, 23356], [23358, 23358, 23401, 23401, 23465], [23467, 23467, 23513, 23513, 23594], [23596, 23596, 23618, 23618, 23645], [23647, 23647, 23669, 23669, 23696], [23698, 23698, 23720, 23720, 23758], [23760, 23760, 23796, 23796, 24002], [24004, 24004, 24034, 24034, 24147], [24149, 24149, 24180, 24180, 24244], [24246, 24246, 24269, 24269, 24373], [24446, 24446, 24478, 24478, 25026], [25028, 25028, 25088, 25088, 25630], [25664, 25664, 25688, 25688, 25741], [25743, 25743, 25767, 25767, 25879], [25881, 25881, 25906, 25906, 26052], [26054, 26054, 26079, 26079, 26265], [26267, 26267, 26288, 26288, 26443], [26445, 26445, 26474, 26474, 26686], [26688, 26688, 26727, 26727, 26984], [27078, 27078, 27103, 27103, 27226]], "test": "untested"}
{"id": "Ntj3Wh", "name": "ShackNews3D", "author": "Del", "description": "https://www.shacknews.com/\n\ncheck out my game! https://store.steampowered.com/app/1153850/Super_Space_Towers/", "tags": ["logo"], "likes": 3, "viewed": 606, "published": 3, "date": "1623825283", "time_retrieved": "2024-07-30T19:15:47.090540", "image_code": "#define PI 3.14159265\n#define TWO_PI 6.2831853\n\n//------------------------------------------------------------------------\n// Distance Funcs\n//------------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat circle(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Text\nfloat char(inout vec2 p, int C,float d,float w)\n{\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.)\n    {\n        p.x -= w;\n        return d;\n    }\n    vec4 cc = textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , dFdx(p/16.),dFdy(p/16.) );\n    p.x -= w;\n    return min(d,(cc.w-0.505));\n}\n\nfloat fontDist(vec2 p)\n{\n    p.x *= 2.0;\n    p.x += 5.8;\n    p.y -= 1.0;\n    p.y *= 0.7;\n    \n    float d = 1e5;\n    float w = 0.514;\n    \n    d =  char(p,83,d,w);\n    d =  char(p,72,d,w);\n    d =  char(p,65,d,w);\n    d =  char(p,67,d,w);\n    d =  char(p,75,d,w+0.2);\n    d =  char(p,78,d,w);\n    d =  char(p,69,d,w);\n    d =  char(p,87,d,w);\n    d =  char(p,83,d,w+5.2);\n    p = 1.0-p;\n    d =  char(p,50,d,w);\n    d =  char(p,53,d,w+0.2);\n    d =  char(p,89,d,w);\n    d =  char(p,69,d,w);\n    d =  char(p,65,d,w);\n    d =  char(p,82,d,w);\n    d =  char(p,83,d,w);\n    \n    return d;\n}\n\nfloat CircleText(vec2 p)\n{\n\tfloat r = length(p*1.3);\n\tfloat a = atan(p.y,p.x);\n    float yp = (2.0* PI*(r*r));\n    float xp = -a;\n    vec2 p2 = vec2(xp, yp);\n    return fontDist(p2)+0.01;\n}\n\nfloat DateText(vec2 p)\n{\n    float d = 1e5;\n    float w = 0.5;\n    p*=14.0;\n    p.y += 0.77;\n    p.x -= 4.27;\n    d =  char(p,50,d,w);\n    d =  char(p,48,d,w);\n    d =  char(p,50,d,w);\n    d =  char(p,49,d,w-13.1);\n    d =  char(p,49,d,w);\n    d =  char(p,57,d,w);\n    d =  char(p,57,d,w);\n    d =  char(p,54,d,w);\n    return d;\n}\n\n//------------------------------------------------------------------------\n// Camera\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float dist = 5.5;\n    float vv = sin(iTime*1.1);\n    float yoff = 1.5+vv;\n    dist += vv*0.5;\n    float an = PI*0.5;\n\tcamPos = vec3(dist*sin(an),yoff,dist*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 doModel( vec3 p )\n{\n    vec2 res = vec2(0.0,0.0);\t\t\t// distance,material index\n    \n    vec3 pp = p;\n    pp.xz*=rot(iTime-1.1f);\n    float d1 = sdCylinder(pp,vec3(-0.2,0.0,0.0),vec3(0.2,0.0,0.0),2.0)-0.15;\n    \n    p.y += 2.2;\n    float d2 = sdPlane(p);\n    \n    res = opU(vec2(d1,2.0),vec2(d2,1.0));\n    return res;\n}\n\nvec3 GetShack(vec2 p)\n{\n    vec3 background = vec3(0.04);\n\n    //p.y *= 1.2+sin(fract(iTime*0.9)*6.28)*0.1;// bounce\n    //p.x *= 1.2+cos(fract(iTime*0.9)*6.28)*0.1;// bounce\n\n    \n    float blur = 0.005;\n    \n    //vec3 background = vec3(0.0);\n    vec3 grey = vec3(0.2,0.2,0.2)*0.45;\n    vec3 txtcol = vec3(0.8,0.8,0.8)*0.45;\n    vec3 blue = vec3(0.2,0.6,0.6)*0.45;\n    \n    float _d = length(p);\n    vec3 color = background;\n    float d = smoothstep(0.0,blur, _d-0.3);\n    color = mix(grey,color,d);\n\n\n    d = _d-0.23;\n    d = abs(d)-0.01;\n    d = smoothstep(0.0,blur, d);\n    color = mix(blue,color,d);\n\n    d = _d-0.51;\n    d = abs(d)-0.012;\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n\n\n\tvec2 tri = vec2(0.22,-0.13); // width, height\n\n\tfloat td = sdTriangleIsosceles( p-vec2(-0.05,0.18), tri );\n    d = smoothstep(0.0,blur, td-0.0125);\n    color = mix(grey,color,d);\n\n    d = smoothstep(0.0,blur, td);\n    color = mix(txtcol,color,d);\n    \n    \n    vec2 pp = p-vec2(-0.05,0.0);\n    \n    d = sdOrientedBox(pp,vec2(-0.09,0.05),vec2(-0.0795,-0.14),0.05);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n    \n    d = sdOrientedBox(pp,vec2(0.09,0.05),vec2(0.0795,-0.14),0.05);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n    \n    d = circle(p+vec2(0.07,0.055),0.0125);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n\n    d = CircleText(p);\n    d = min(d,DateText(p));\n    d = smoothstep(0.0,0.03,d);\n    if (p.y > 0.1)\n        color = mix(txtcol,color,d);\n    else\n        color = mix(blue,color,d);\n\n    return color;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal.\n//------------------------------------------------------------------------\n// c = colour index (added by del for some materials)\nvec3 doMaterial( in vec3 pos, in vec3 nor,float c )\n{\n    if (c<=1.0)\n    {\n        // checker floor\n        float f = mod( floor(1.0*pos.z) + floor(1.0*pos.x), 2.0);\n        vec3 col2 = vec3(0.05,0.35,0.45);\n        vec3 col1 = col2*0.4;\n\t    return mix(col1,col2,f);\n    }\n\n    mat2 m = rot(iTime-1.1f);\n    nor.xz*=m;\n\n    vec3 dir = vec3(1.0,0.0,0.0);\n    float dif = dot(nor,dir);\n    \n    if (abs(dif)<0.01)\n        return vec3(0.04);\n    vec3 p = pos;\n    p.xz*=m;\n    vec2 uv = vec2(p.y,p.z);\n    uv *= rot(-PI*0.5);\n    uv.x *= sign(dif);\n    uv *= 0.27;\n    return GetShack(uv);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\t\t// dir\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0;\n    if( dif>0.01 )\n        sha=calcSoftshadow( pos+0.01*nor, lig );\n\n    // hack in some specular\n    vec3 ref = reflect(rd, nor);\n\tfloat spe = max(dot(ref, lig), 0.0);\n\tdif += pow(spe,16.0);\n\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.0075*dis*dis);\n\n    return col;\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 40.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\t//float res = -1.0;\n    vec2 res = vec2(-1.0,0.0);\n    float c = 0.0;\n    \n    for( int i=0; i<120; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n        vec2 res2 = doModel( ro+rd*t );\n\t    h = res2.x;\n        c = res2.y;\n        \n        t += h;\n    }\n\n    if( t<maxd )\n    {\n        res.x = t;\n        res.y = c;\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n  \tvec3 col = mix( vec3(0.2, 0.2, 0.5), vec3(0.5, 0.7, 1.0), fragCoord.y / iResolution.y );\n    col *= 0.5;\n\n\t// raymarch\n    vec2 res = calcIntersection( ro, rd ); \n    float t = res.x;\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor, res.y );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntj3Wh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 242, 242, 257], [258, 258, 293, 293, 319], [321, 370, 421, 421, 787], [789, 789, 825, 825, 855], [856, 856, 907, 907, 1192], [1193, 1193, 1259, 1259, 1476], [1478, 1478, 1499, 1499, 1567], [1570, 1578, 1627, 1627, 1874], [1876, 1876, 1900, 1900, 2462], [2464, 2464, 2490, 2490, 2653], [2655, 2655, 2679, 2679, 2985], [2987, 3147, 3228, 3228, 3431], [3433, 3433, 3463, 3463, 3496], [3498, 3498, 3522, 3522, 3821], [3823, 3823, 3846, 3846, 5424], [5426, 5773, 5826, 5826, 6363], [6576, 6576, 6660, 6660, 7373], [7375, 7375, 7424, 7424, 7997], [7999, 7999, 8031, 8031, 8451], [8453, 8453, 8501, 8501, 8929], [8931, 8931, 8995, 8995, 9173], [9175, 9175, 9232, 9232, 10544]], "test": "untested"}
{"id": "stB3D1", "name": "sdfCrossCircle", "author": "a745806106", "description": "sdf painting test", "tags": ["sdf2dpattern"], "likes": 1, "viewed": 224, "published": 3, "date": "1623817867", "time_retrieved": "2024-07-30T19:15:47.975175", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q=uv-vec2(0.5,0.5);\n    q.x*=iResolution.x/iResolution.y;\n    \n    float inputVal=fract(iTime);\n    //inputVal=inputVal*2.0-1.0;\n    inputVal=2.0*sin(iTime);\n    float insertVal=(inputVal+2.0)*0.625-0.5;\n    \n    float curveVal=1.0-abs(2.0*sin(2.0*atan(q.y,q.x)+inputVal));\n    float r=0.3+0.1*insertVal*smoothstep(0.3,1.3,curveVal);\n    r*=abs(inputVal);\n    float Result =smoothstep(r+0.01,r,length(q));\n    \n    // Output to screen\n    fragColor = vec4(0,0.7391,1.0,1.0)*Result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stB3D1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 640]], "test": "untested"}
{"id": "7lS3Dh", "name": "LookingGlass: Magnetismic", "author": "xjorma", "description": "Original shader from Nimitz\nShader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["3d", "noise", "tutorial", "volumetric", "animated", "glass", "looking", "lookingglass"], "likes": 0, "viewed": 185, "published": 3, "date": "1623802669", "time_retrieved": "2024-07-30T19:15:48.731153", "image_code": "//Magnetismic by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XlB3zV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//Getting 60fps here at high quality\n#define HIGH_QUALITY\n\n#ifdef HIGH_QUALITY\n#define STEPS 130\n#define ALPHA_WEIGHT 0.015\n#define BASE_STEP 0.025\n#else\n#define STEPS 50\n#define ALPHA_WEIGHT 0.05\n#define BASE_STEP 0.1\n#endif\n\n#define time iTime\nvec2 mo;\nvec2 rot(in vec2 p, in float a){float c = cos(a), s = sin(a);return p*mat2(c,s,-s,c);}\nfloat hash21(in vec2 n){ return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p), fp = fract(p);\n    fp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 cl = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\n\treturn mix(cl.x, cl.y, fp.z);\n}\n\nfloat fbm(in vec3 p, in float sr)\n{\n    p *= 3.5;\n    float rz = 0., z = 1.;\n    for(int i=0;i<4;i++)\n    {\n        float n = noise(p-time*.6);\n        rz += (sin(n*4.4)-.45)*z;\n        z *= .47;\n        p *= 3.5;\n    }\n    return rz;\n}\n\nvec4 map(in vec3 p)\n{\n    float dtp = dot(p,p);\n\tp = .5*p/(dtp + .2);\n    p.xz = rot(p.xz, p.y*2.5);\n    p.xy = rot(p.xz, p.y*2.);\n    \n    float dtp2 = dot(p, p);\n    p = (mo.y + .6)*3.*p/(dtp2 - 5.);\n    float r = clamp(fbm(p, dtp*0.1)*1.5-dtp*(.35-sin(time*0.3)*0.15), 0. ,1.);\n    vec4 col = vec4(.5,1.7,.5,.96)*r;\n    \n    float grd = clamp((dtp+.7)*0.4,0.,1.);\n    col.b += grd*.6;\n    col.r -= grd*.5;    \n    vec3 lv = mix(p,vec3(0.3),2.);\n    grd = clamp((col.w - fbm(p+lv*.05,1.))*2., 0.01, 1.5 );\n    col.rgb *= vec3(.5, 0.4, .6)*grd + vec3(4.,0.,.4);\n    col.a *= clamp(dtp*2.-1.,0.,1.)*0.07+0.87;\n    \n    return col;\n}\n\nvec4 vmarch(in vec3 ro, in vec3 rd)\n{\n\tvec4 rz = vec4(0);\n\tfloat t = 2.5;\n    t += 0.03*hash21(gl_FragCoord.xy);\n\tfor(int i=0; i<STEPS; i++)\n\t{\n\t\tif(rz.a > 0.99 || t > 6.)break;\n\t\tvec3 pos = ro + t*rd;\n        vec4 col = map(pos);\n        float den = col.a;\n        col.a *= ALPHA_WEIGHT;\n\t\tcol.rgb *= col.a*1.7;\n\t\trz += col*(1. - rz.a);\n        t += BASE_STEP - den*(BASE_STEP-BASE_STEP*0.015);\n\t}\n    return rz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord, in vec3 rom, in vec3 rdm)\n{\n\tvec2 p = fragCoord.xy/iResolution.xy*2. - 1.;\n\tp.x *= iResolution.x/iResolution.y*.85;\n    p *= 1.1;\n\tmo = 2.0*iMouse.xy/iResolution.xy;\n    mo = (mo==vec2(.0))?mo=vec2(0.5,1.):mo;\n\t\n\tvec3 ro = 4.*normalize(vec3(cos(2.75-2.0*(mo.x+time*0.05)), sin(time*0.22)*0.2, sin(2.75-2.0*(mo.x+time*0.05))));\n\tvec3 eye = normalize(vec3(0) - ro);\n\tvec3 rgt = normalize(cross(vec3(0,1,0), eye));\n\tvec3 up = cross(eye,rgt);\n\tvec3 rd = normalize(p.x*rgt + p.y*up + (3.3-sin(time*0.3)*.7)*eye);\n\t\n\tro = rom;\n\trd = rdm;\n\t\n\tvec4 col = clamp(vmarch(ro, rd),0.,1.);\n    col.rgb = pow(col.rgb, vec3(.9));\n    /*col.rb = rot(col.rg, 0.35);\n    col.gb = rot(col.gb, -0.1);*/\n    \n    fragColor = vec4(col.rgb, 1.0);\n}\n\nconst float\tsideAngle       = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 2.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 5.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam, 0, dist),vec3(-minCam, 0, dist), valueId);\n\tvec3\tscreenPos = vec3((fract.x - 0.5) * cameraSize,(fract.y - 0.5) * cameraSize / aspectRatio,0);\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n\tmainImage( color, fract*(iResolution.xy), screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lS3Dh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[478, 478, 510, 510, 564], [565, 565, 589, 589, 654], [655, 655, 679, 679, 890], [892, 892, 927, 927, 1128], [1130, 1130, 1151, 1151, 1762], [1764, 1764, 1801, 1801, 2179], [2181, 2181, 2262, 2262, 2958], [3219, 3219, 3274, 3274, 3986]], "test": "untested"}
{"id": "stSGDh", "name": "Maxnorm Distance to Rotated Box", "author": "oneshade", "description": "Method for getting the distance to a rotated box that I described here (with some tweaks for preference): [url=https://www.shadertoy.com/view/NlBGDh]https://www.shadertoy.com/view/NlBGDh[/url]", "tags": ["2d", "sdf", "distance", "maxnorm", "linf", "rotated"], "likes": 5, "viewed": 227, "published": 3, "date": "1623798273", "time_retrieved": "2024-07-30T19:15:49.487132", "image_code": "float sdBox(in vec2 p, in vec2 dims, in float rot) {\n    float u = cos(rot), v = sin(rot);\n\n    vec4 h = vec4(dims * u, dims * v);\n    vec2 a = vec2(h.x - h.w, h.z + h.y);\n    vec2 b = vec2(h.x + h.w, h.z - h.y);\n\n    vec2 qa = abs(mat2(u, -v, v, u) * p) - dims;\n    vec2 qb = abs(p) - max(abs(a), abs(b));\n\n    return max(max(qb.x, qb.y), max(qa.x, qa.y) / max(abs(u - v), abs(u + v)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.5, 0.5 * sin(time)) * cos(time);\n\n    vec2 dims = vec2(0.3 + 0.05 * sin(iTime), 0.2 + 0.1 * cos(0.5 * iTime));\n    float dist = sdBox(uv, dims, iTime);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n\tcolor *= 0.8 + 0.2 * cos(240.0 * dist);\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(dist)));\n\n    float mDist = abs(sdBox(mouse, dims, iTime));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.008));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist) - 0.001));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSGDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 389], [391, 391, 446, 446, 1457]], "test": "untested"}
{"id": "stBGWh", "name": "LookingGlass: Plasma Globe", "author": "xjorma", "description": "Original Shader from Nimitz\nShader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["3d", "raymarching", "tutorial", "rays", "plasma", "volumetric", "glass", "looking", "lookingglass"], "likes": 0, "viewed": 243, "published": 3, "date": "1623795541", "time_retrieved": "2024-07-30T19:15:50.334865", "image_code": "// Plasma Globe by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsjXRm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//looks best with around 25 rays\n#define NUM_RAYS 13.\n\n#define VOLUMETRIC_STEPS 19\n\n#define MAX_ITER 35\n#define FAR 6.\n\n#define time iTime*1.1\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat noise( in float x ){return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\t\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rg = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, fp.z);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\n//See: https://www.shadertoy.com/view/XdfXRj\nfloat flow(in vec3 p, in float t)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i= 1.;i < 5.;i++ )\n\t{\n\t\tp += time*.1;\n\t\trz+= (sin(noise(p+t*0.8)*6.)*0.5+0.5) /z;\n\t\tp = mix(bp,p,0.6);\n\t\tz *= 2.;\n\t\tp *= 2.01;\n        p*= m3;\n\t}\n\treturn rz;\t\n}\n\n//could be improved\nfloat sins(in float x)\n{\n \tfloat rz = 0.;\n    float z = 2.;\n    for (float i= 0.;i < 3.;i++ )\n\t{\n        rz += abs(fract(x*1.4)-0.5)/z;\n        x *= 1.3;\n        z *= 1.15;\n        x -= time*.65*z;\n    }\n    return rz;\n}\n\nfloat segm( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\t\n\treturn length( pa - ba*h )*.5;\n}\n\nvec3 path(in float i, in float d)\n{\n    vec3 en = vec3(0.,0.,1.);\n    float sns2 = sins(d+i*0.5)*0.22;\n    float sns = sins(d+i*.6)*0.21;\n    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);\n    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);\n    return en;\n}\n\nvec2 map(vec3 p, float i)\n{\n\tfloat lp = length(p);\n    vec3 bg = vec3(0.);   \n    vec3 en = path(i,lp);\n    \n    float ins = smoothstep(0.11,.46,lp);\n    float outs = .15+smoothstep(.0,.15,abs(lp-1.));\n    p *= ins*outs;\n    float id = ins*outs;\n    \n    float rz = segm(p, bg, en)-0.011;\n    return vec2(rz,id);\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j)\n{\n\tfloat precis = 0.001;\n    float h=0.5;\n    float d = startf;\n    for( int i=0; i<MAX_ITER; i++ )\n    {\n        if( abs(h)<precis||d>maxd ) break;\n        d += h*1.2;\n\t    float res = map(ro+rd*d, j).x;\n        h = res;\n    }\n\treturn d;\n}\n\n//volumetric marching\nvec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig)\n{   \n    vec3 p = ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    float w = 0.;\n    for( int i=0; i<VOLUMETRIC_STEPS; i++ )\n    {\n        r = map(p,j);\n        p += rd*.03;\n        float lp = length(p);\n        \n        vec3 col = sin(vec3(1.05,2.5,1.52)*3.94+r.y)*.85+0.4;\n        col.rgb *= smoothstep(.0,.015,-r.x);\n        col *= smoothstep(0.04,.2,abs(lp-1.1));\n        col *= smoothstep(0.1,.34,lp);\n        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);\n    }\n    return sum;\n}\n\n//returns both collision dists of unit sphere\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, vec3 _ro, vec3 _rd )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n    \n\t//camera\n\tvec3 ro = vec3(0.,0.,5.);\n    vec3 rd = normalize(vec3(p*.7,-1.5));\n    mat2 mx = mm2(time*.4+um.x*6.);\n    mat2 my = mm2(time*0.3+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec3 bro = _ro;\n    vec3 brd = _rd;\n\t\n    vec3 col = vec3(0.0125,0.,0.025);\n    #if 1\n    for (float j = 1.;j<NUM_RAYS+1.;j++)\n    {\n        ro = bro;\n        rd = brd;\n        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);\n        ro.xy *= mm;rd.xy *= mm;\n        ro.xz *= mm;rd.xz *= mm;\n        float rz = march(ro,rd,2.5,FAR,j);\n\t\tif ( rz >= FAR)continue;\n    \tvec3 pos = ro+rz*rd;\n    \tcol = max(col,vmarch(pos,rd,j, bro));\n    }\n    #endif\n    \n    ro = bro;\n    rd = brd;\n    vec2 sph = iSphere2(ro,rd);\n    \n    if (sph.x > 0.)\n    {\n        vec3 pos = ro+rd*sph.x;\n        vec3 pos2 = ro+rd*sph.y;\n        vec3 rf = reflect( rd, pos );\n        vec3 rf2 = reflect( rd, pos2 );\n        float nz = (-log(abs(flow(rf*1.2,time)-.01)));\n        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));\n        col += (0.1*nz*nz* vec3(0.12,0.12,.5) + 0.05*nz2*nz2*vec3(0.55,0.2,.55))*0.8;\n    }\n    \n\tfragColor = vec4(col*1.3, 1.0);\n}\n\n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 2.2;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 5.0;  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n\tmainImage( color, fract*(iResolution.xy), screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[370, 370, 391, 391, 443], [444, 444, 470, 470, 522], [524, 524, 546, 546, 579], [581, 581, 605, 605, 824], [936, 981, 1016, 1016, 1232], [1234, 1254, 1278, 1278, 1474], [1476, 1476, 1513, 1513, 1639], [1641, 1641, 1676, 1676, 1889], [1891, 1891, 1918, 1918, 2205], [2207, 2207, 2288, 2288, 2527], [2529, 2551, 2614, 2614, 3149], [3151, 3197, 3236, 3236, 3424], [3426, 3426, 3503, 3503, 4779], [5037, 5037, 5093, 5093, 5791]], "test": "untested"}
{"id": "slBGWh", "name": "LookingGlass: Protean Clouds", "author": "xjorma", "description": "Original shader from Nimitz\nShader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["procedural", "3d", "tutorial", "fast", "volumetric", "glass", "looking", "lookingglass"], "likes": 1, "viewed": 225, "published": 3, "date": "1623795379", "time_retrieved": "2024-07-30T19:15:51.173623", "image_code": "// Protean clouds by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/3l23Rh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tTechnical details:\n\n\tThe main volume noise is generated from a deformed periodic grid, which can produce\n\ta large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple\n\tfetches of volume gradient computation for improved lighting.\n\n\tTo further accelerate marching, since the volume is smooth, more than half the the density\n\tinformation isn't used to rendering or shading but only as an underlying volume\tdistance to \n\tdetermine dynamic step size, by carefully selecting an equation\t(polynomial for speed) to \n\tstep as a function of overall density (not necessarialy rendered) the visual results can be \n\tthe\tsame as a naive implementation with ~40% increase in rendering performance.\n\n\tSince the dynamic marching step size is even less uniform due to steps not being rendered at all\n\tthe fog is evaluated as the difference of the fog integral at each rendered step.\n\n*/\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+iTime)*(0.1 + prm1*0.05) + iTime*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + iTime*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 iLerp(in vec3 a, in vec3 b, in float x)\n{\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, vec3 _ro, vec3 _rd )\n{\t\n\tvec2 q = fragCoord.xy/iResolution.xx;\n    vec2 p = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    bsMo = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*3.;\n    vec3 ro = vec3(0,0,time);\n    \n    ro += vec3(sin(iTime)*0.5,sin(iTime*1.)*0.,0);\n        \n    float dspAmp = 1.;\n    ro.xy += disp(ro.z)*dspAmp;\n    float tgtDst = 3.5;\n    \n\tvec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n    ro.x -= bsMo.x*2.;\n\t\n\t// camera-to-world rotation\n    mat3 ca = setCamera( ro, target, 0.0 );\n\t\n    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n    vec3 updir = normalize(cross(rightdir, target));\n    rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n    prm1 = smoothstep(-0.4, 0.4,sin(iTime*0.3));\n\t\n\t\n\t_rd.z = -_rd.z;\n\t_ro.z = -_ro.z;\n\tvec4 scn = render(ro + ca*_ro, ca*_rd, time);\n\t\t\n    vec3 col = scn.rgb;\n    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n    \n    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tfragColor = vec4( col, 1.0 );\n}\n\n\n/*\nout vec4 fragColor;\nvoid main()\n{\n    vec4 color;\n\tmainImage( color, vUV.xy*iResolution );\n    fragColor = TDOutputSwizzle(color);\n}\n*/\n\n\nconst float\tsideAngle       = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 6.0;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 5.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio, 0);\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n\tmainImage( color, fract*(iResolution.xy), screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBGWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1132, 1132, 1153, 1153, 1205], [1317, 1317, 1336, 1336, 1353], [1354, 1354, 1406, 1406, 1450], [1490, 1490, 1509, 1509, 1560], [1562, 1562, 1580, 1580, 2107], [2109, 2109, 2160, 2160, 3194], [3196, 3196, 3218, 3218, 3333], [3335, 3408, 3454, 3454, 3800], [3802, 3802, 3854, 3854, 4031], [4033, 4033, 4110, 4110, 5325], [5729, 5729, 5785, 5785, 6483]], "test": "untested"}
{"id": "NlBGDh", "name": "Oriented Box - distance L-inf", "author": "iq", "description": "Distance to an oriented box in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url].", "tags": ["2d", "distancefield", "sdf", "box", "oriented", "linf"], "likes": 9, "viewed": 848, "published": 3, "date": "1623788178", "time_retrieved": "2024-07-30T19:15:52.002407", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an oriented box in the L-infinity metric space. I made \n// a semi-brute force version (checking 3 edges) but before I could \n// take an optimziation pass oneshade wrote a simpler one, which I\n// adapted here.\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 r, float ang )\n{\n    vec2 w = vec2(cos(ang),sin(ang));\n    \n    vec4  q = w.xyyx * p.xxyy;\n    vec4  s = w.xyyx * r.xxyy;\n\n    return max( \n        // rotated rectangle\n        max(abs(q.x+q.z)-r.x, abs(q.w-q.y)-r.y ) / \n        max(abs(w.x-w.y),     abs(w.x+w.y)),\n        // axis aligned bbox\n        max(abs(p.x)-max(abs(s.x-s.z),abs(s.x+s.z)), \n            abs(p.y)-max(abs(s.y+s.w),abs(s.y-s.w)) ) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if( iMouse.x<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n    \n    const vec2 rad = vec2(0.5,0.2);\n    float ang = 0.51*iTime;\n    \n    float d = sdOrientedBox(p, rad, ang);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n    \n    d = sdOrientedBox(m, rad, ang);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBGDh.jpg", "access": "api", "license": "mit", "functions": [[1405, 1405, 1461, 1461, 1852], [1854, 1854, 1909, 1909, 2688]], "test": "untested"}
{"id": "sljGWz", "name": "Fractal 58_gaz", "author": "gaz", "description": "fractal", "tags": ["fractal"], "likes": 11, "viewed": 367, "published": 3, "date": "1623767618", "time_retrieved": "2024-07-30T19:15:52.804263", "image_code": "float SUM; \nfloat TIME;\nfloat T;\n\nvoid Q(float interval){\n  T=clamp((TIME-SUM)/interval,0.,1.);\n  SUM=SUM+interval;\n}\n\nfloat apollonian(inout vec3 p)\n{\n    p=mod(p-2.,4.)-2.;\n    \n    float r=12.5;\n    float x=5.2;\n    float y=7.1;\n    float z=2.5;\n        \n    SUM=0.;\n    TIME = mod(iTime,18.);\n    Q(2.);\n    r+=T*T*3.;\n    Q(2.);\n    x-=T*T*5.;\n    Q(2.);\n    z-=T*T*2.;\n    Q(2.);\n    y-=T*T*3.;\n    Q(2.);\n    r+=T*T*2.;\n    Q(2.);\n    x+=T*T*2.;\n    Q(2.);\n    y+=T*T*3.;\n    Q(2.);\n    z+=T*T*4.;\n          \n    float e,s=2.;\n    for(int i=0;i<6;i++){\n        p=abs(p-vec3(x,y,z)*.05)-vec3(x,y,z-.3);\n        e=(r+.2)/clamp(dot(p,p),.1,r);\n        s*=e;\n        p=abs(p)*e;\n    }\n    return min(length(p.xz),p.y)/s;\n}\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 p,r=iResolution;\n    vec3 ro=eye(iTime);\n    vec3 ta =target(iTime);\n    vec3 rd=lookat(ro,ta,vec3(0,1,0))*normalize(vec3((C-.5*r.xy)/r.y,1));\n    \n    for(float i=1.,g=1.5,e;i<99.;i++)\n    {\n        p=g*rd+ro;\n        g+=e=apollonian(p)+.001;\n        O.rgb+=mix(vec3(1),hue(length(p)*.2),.6)*.002/e/i;\n    }\n\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=mod(p-.2,1.)-.5;\n        g+=e=length(p.xz)-.005;\n        e<.001?O.g+=.2/i:i;\n    }\n\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        p=mod(p-.5,1.)-.5;\n        g+=e=length(p.yz)-.005;\n        e<.001?O.r+=.2/i:i;\n    }\n\n    for(float i=1.,g=0.,e;i<99.;i++){\n        p=g*rd+ro;\n        \n        p=mod(p+.1,1.)-.5;\n        g+=e=length(p.xy)-.005;\n        e<.001?O.b+=.3/i:i;\n    }\n    O.xyz = min(O.xyz, .95);\n    O.xyz = pow(O.xyz, vec3(.8,1.2,3.));\n}\n", "image_inputs": [], "common_code": "#define PI acos(-1.0)\n#define TAU PI*2.0\n\n#define hue(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define hash(n) fract(sin(n)*5555.0)\n\nvec3 randVec(float n)\n{\n    float a=(hash(n)*2.-1.)*TAU,b=asin(hash(n+215.3)*2.-1.);\n    return vec3(cos(a),sin(a)*cos(b),sin(a)*sin(b));\n}\n\nvec3 randCurve(float t,float n)\n{\n    t*=0.15;\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++)\n    {\n        p += randVec(n+=365.)*sin((t*=1.3)+sin(t*0.6)*0.5);\n    }\n    return p;\n}\n\nvec3 eye(float time){\n    float seed=12713.0;\n    return randCurve(time,seed)*5.0;\n}\n\nvec3 target(float time){\n    float seed=12713.0;\n    return randCurve(time+2.5,seed)*5.0;\n}\n\nmat3 lookat(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target-eye), u = normalize(cross(w,up));\n    return mat3(u,cross(u,w),w);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljGWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 57, 57, 117], [119, 119, 151, 151, 725], [727, 727, 763, 763, 1630]], "test": "untested"}
{"id": "7tj3Wz", "name": "Rhombus - distance L-inf", "author": "iq", "description": "Distance to a rhombus in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url]. Like all add second degree shapes, it boils down to a quadratic equation rather than a cubic like in the regular L2 metric space.", "tags": ["2d", "distancefield", "sdf", "rhombus", "linf"], "likes": 6, "viewed": 525, "published": 3, "date": "1623760200", "time_retrieved": "2024-07-30T19:15:53.554258", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a rhombus in the L-infinity metric space.\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n\nfloat sdRhombus( in vec2 p, float w, float h )\n{\n    p = abs(p); p.x -= w;\n    \n    float f = clamp( (p.y-p.x)/(h+w), 0.0, 1.0 );\n    \n    vec2 q = abs(p-f*vec2(-w,h));\n    \n    return max(q.x,q.y)*((h*p.x+w*p.y>0.0)?1.0:-1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    if( iMouse.z<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    float w = 1.0*abs(cos( 0.11*iTime + 0.0 ));\n\tfloat h = 0.8*abs(cos( 0.13*iTime + 1.0 ));\n    \n    float d = sdRhombus(p, w, h);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    \n    d = sdRhombus(m, w, h);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3Wz.jpg", "access": "api", "license": "mit", "functions": [[1238, 1238, 1286, 1286, 1467], [1469, 1469, 1524, 1524, 2317]], "test": "untested"}
{"id": "sl2GWz", "name": "Rounded Box - distance L-inf", "author": "iq", "description": "Distance to a rounded box in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url]. Like all add second degree shapes, it boils down to a quadratic equation rather than a cubic like in the regular L2 metric space.", "tags": ["2d", "distancefield", "sdf", "capsule", "linf"], "likes": 6, "viewed": 647, "published": 3, "date": "1623759641", "time_retrieved": "2024-07-30T19:15:54.307244", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a rounded box in the L-infinity metric space\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n\nfloat sdRoundBox( in vec2 p, in vec2 ra, in float rb )\n{\n    p = abs(p) - ra;\n    p = max(p,p.yx-rb);\n    float a = 0.5*(p.x+p.y);\n    float b = 0.5*(p.x-p.y);\n    return a - sqrt(rb*rb*0.5-b*b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if( iMouse.z<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    float rad = 0.2;\n    vec2  wid = vec2(0.6,0.2)+0.2*sin(0.13*iTime+vec2(3,2));\n    \n    float d = sdRoundBox(p, wid, rad);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    \n    d = sdRoundBox(m, wid, rad);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2GWz.jpg", "access": "api", "license": "mit", "functions": [[1241, 1241, 1297, 1297, 1438], [1440, 1440, 1495, 1495, 2283]], "test": "untested"}
{"id": "Nt2GWR", "name": "Circle - distance L-inf", "author": "iq", "description": "Distance to a circle in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url]. Like all add second degree shapes, it boils down to a quadratic equation rather than a cubic like in the regular L2 metric space.", "tags": ["2d", "distancefield", "sdf", "circle", "linf"], "likes": 7, "viewed": 926, "published": 3, "date": "1623757876", "time_retrieved": "2024-07-30T19:15:55.051255", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a circle in the L-infinity metric space\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n\nfloat sdSphere( in vec2 p, in float r )\n{\n    p = abs(p);\n    p = max(p,p.yx-r);\n    float a = 0.5*(p.x+p.y);\n    float b = 0.5*(p.x-p.y);\n    return a - sqrt(r*r*0.5-b*b);\n}\n\n/*\n// my original version, with a branch\nfloat sdSphere( in vec2 p, in float r )\n{\n    p = abs(p);\n    \n    if( abs(p.y-p.x)<r )\n    {\n        float b = 0.5*(p.x+p.y);\n        float c = 0.5*(dot(p,p) - r*r);\n        return b - sqrt(b*b-c);\n    }\n    else\n    {\n        return max(p.x,p.y)-r;\n    }\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if( iMouse.z<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    const float rad = 0.5;\n    \n    float d = sdSphere(p, rad);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    \n    d = sdSphere(m, rad);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2GWR.jpg", "access": "api", "license": "mit", "functions": [[1236, 1236, 1277, 1277, 1410], [1716, 1716, 1771, 1771, 2486]], "test": "untested"}
{"id": "7tj3DR", "name": "Ellipse - distance L-inf", "author": "iq", "description": "Distance to an ellipse in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url]. Like all add second degree shapes, it boils down to a quadratic equation rather than a cubic like in the regular L2 metric space.", "tags": ["2d", "distancefield", "sdf", "ellipse", "linf"], "likes": 6, "viewed": 614, "published": 3, "date": "1623757865", "time_retrieved": "2024-07-30T19:15:55.895997", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an ellipse in the L-infinity metric space\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n\n\nfloat sdEllipse( in vec2 p, in vec2 r )\n{\n    p = abs(p);\n    p = max(p,(p-r).yx); // idea by oneshade\n    \n    float m = dot(r,r);\n    float d = p.y-p.x;\n    return p.x - (r.y*sqrt(m-d*d)-r.x*d) * r.x/m;\n}\n\n/*\n// my first attempt\nfloat sdEllipse( in vec2 p, in vec2 r )\n{\n    p = abs(p);\n    if( p.y-r.y>p.x ) return p.y-r.y;\n    if( p.x-r.x>p.y ) return p.x-r.x;\n    \n    r *= r;\n\n    float c = r.x*r.y;\n\n    float k2 = r.x + r.y; r *= p.yx; \n    float k1 = r.x + r.y; r *= p.yx; \n    float k0 = r.x + r.y - c;\n    \n    return (k1-sqrt(max(k1*k1-k0*k2,0.0)))/k2;\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n\t\n    if( iMouse.z<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,1));\n\n    vec2 ra = vec2(0.7,0.2) + 0.2*sin(0.1*iTime*vec2(1.1,1.3)+vec2(0,1));\n    \n \tfloat d = sdEllipse( p, ra );\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    d = sdEllipse(m, ra );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3DR.jpg", "access": "api", "license": "mit", "functions": [[1239, 1239, 1280, 1280, 1445], [1810, 1810, 1865, 1865, 2627]], "test": "untested"}
{"id": "Nlj3WR", "name": "Box - distance L-inf", "author": "iq", "description": "Distance to a box in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url].", "tags": ["2d", "distancefield", "sdf", "box", "linf"], "likes": 5, "viewed": 1102, "published": 3, "date": "1623757864", "time_retrieved": "2024-07-30T19:15:56.703837", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a box in the L-infinity metric space\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n\n\nfloat sdBox( in vec2 p, in vec2 rad )\n{\n    p = abs(p)-rad;\n\n    return max(p.x,p.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if( iMouse.z<0.01 ) m=sin(-0.17*iTime*vec2(1.1,1.3)+vec2(0,2));\n    \n    const vec2 rad = vec2(0.5,0.2);\n    \n    float d = sdBox(p, rad);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    \n    d = sdBox(m, rad);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlj3WR.jpg", "access": "api", "license": "mit", "functions": [[1234, 1234, 1273, 1273, 1321], [1323, 1323, 1378, 1378, 2104]], "test": "untested"}
{"id": "7l2GWR", "name": "Segment - distance L-inf", "author": "iq", "description": "Distance to a line segment in the [url=https://en.wikipedia.org/wiki/Lp_space]L-infinity metric space[/url]. Like in the regular L2 metric space, it boils down to a clamped projection and a distance measure.", "tags": ["2d", "distancefield", "sdf", "segment", "linf"], "likes": 6, "viewed": 652, "published": 3, "date": "1623757864", "time_retrieved": "2024-07-30T19:15:57.467794", "image_code": "// The MIT License\n// Copyright © 2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a line segment in the L-infinity metric space.\n// Like in the regular L2 metric space, it boils down to a\n// clamped projection and a distance measure.\n//\n// List of some other 2D distances in L-infinity:\n//\n// https://www.shadertoy.com/playlist/XXccDH\n\n\nfloat sdLine( in vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    \n    float s = (ba.x*ba.y>0.0)?1.0:-1.0;\n    float h = clamp( (pa.y+s*pa.x)/(ba.y+s*ba.x), 0.0, 1.0 );\n    \n    vec2 q = abs(pa-h*ba);\n    return max(q.x,q.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    if( iMouse.z<0.01 ) m=sin(-0.15*iTime*vec2(1.1,1.3)+vec2(0,2));\n\n    vec2 v1 = vec2(1.0,0.8)*cos( 0.1*iTime + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = vec2(1.0,0.8)*cos( 0.1*iTime + vec2(0.0,3.00) + 1.5 );\n    \n    float d = sdLine(p, v1, v2);\n\n    vec3 col = vec3(1.0,0.9,1.0) + sign(d)*vec3(-0.3,0.4,0.3);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    \n    d = sdLine(m, v1, v2);\n     col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, abs(max(abs(p.x-m.x), abs(p.y-m.y)) - abs(d))));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.004, 0.008, length(p-m)-0.015));\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2GWR.jpg", "access": "api", "license": "mit", "functions": [[1348, 1348, 1391, 1391, 1595], [1597, 1597, 1652, 1652, 2486]], "test": "untested"}
{"id": "7t23WR", "name": "shacknews", "author": "Del", "description": "https://www.shacknews.com/\n\ncheck out my game! https://store.steampowered.com/app/1153850/Super_Space_Towers/", "tags": ["logo"], "likes": 3, "viewed": 335, "published": 3, "date": "1623753292", "time_retrieved": "2024-07-30T19:15:58.226765", "image_code": "// shacknews hack :)\n// Del 15/06/2021 - just for fun\n// shacknews rocks :)\n\n#define PI 3.14159265\n#define TWO_PI 6.2831853\n\n\nfloat circle(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\n // --- access to the image of ascii code c\nfloat char(inout vec2 p, int C,float d,float w)\n{\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.)\n    {\n        p.x -= w;\n        return d;\n    }\n    vec4 cc = textureGrad( iChannel0, p/16. + fract( vec2(C, 15-C/16) / 16. ) , dFdx(p/16.),dFdy(p/16.) );\n    p.x -= w;\n    return min(d,(cc.w-0.505));\n}\n\nfloat fontDist(vec2 p)\n{\n    p.x *= 2.0;\n    p.x += 5.8;\n    p.y -= 1.0;\n    p.y *= 0.7;\n    \n    float d = 1e5;\n    float w = 0.514;\n    \n    d =  char(p,83,d,w);\n    d =  char(p,72,d,w);\n    d =  char(p,65,d,w);\n    d =  char(p,67,d,w);\n    d =  char(p,75,d,w);\n    p.x -= 0.2;\n    d =  char(p,78,d,w);\n    d =  char(p,69,d,w);\n    d =  char(p,87,d,w);\n    d =  char(p,83,d,w);\n    p.x -= 5.2;\n    p = 1.0-p;\n    d =  char(p,50,d,w);\n    d =  char(p,53,d,w);\n    p.x -= 0.2;\n    d =  char(p,89,d,w);\n    d =  char(p,69,d,w);\n    d =  char(p,65,d,w);\n    d =  char(p,82,d,w);\n    d =  char(p,83,d,w);\n    \n    return d;\n}\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nfloat CircleText(vec2 p)\n{\n\n    //p*=rot(sin(fract(iTime*0.44)*6.28)*0.35);\n\n\tfloat r = length(p*1.3);\n\tfloat a = atan(p.y,p.x);\n    float yp = (2.0* PI*(r*r));\n    float xp = -a;\n    vec2 p2 = vec2(xp, yp);\n    return fontDist(p2)+0.01;\n}\n\n\nfloat DateText(vec2 p)\n{\n    float d = 1e5;\n    float w = 0.5;\n    \n    p*=14.0;\n    p.y += 0.77;\n    p.x -= 4.27;\n    d =  char(p,50,d,w);\n    d =  char(p,48,d,w);\n    d =  char(p,50,d,w);\n    d =  char(p,49,d,w);\n    p.x += 13.1;\n    d =  char(p,49,d,w);\n    d =  char(p,57,d,w);\n    d =  char(p,57,d,w);\n    d =  char(p,54,d,w);\n    return d;\n}\n\nvec3 hash33( vec3 x )\n{\n\treturn texture( iChannel1, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.15);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 neb(in vec2 uv)\n{\n    float dd = length(uv*uv)*0.125;\n    \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 3.141592/8.));\n    rd.xy *= rot(dd-iTime*.025);\n\t\n\tfloat c = noiseLayers(rd*2.25);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.45,3.5);    \n    \n    \n    vec3 col =  vec3(0.55,0.8,0.35);\n    vec3 col2 =  vec3(.85,0.85,1.4)*2.0;\n\n    \n    \n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    //pulse = clamp(pulse,0.0,2.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return sqrt(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n    vec3 background = neb(p);\n\n    p.y *= 1.2+sin(fract(iTime*0.9)*6.28)*0.1;// bounce\n    p.x *= 1.2+cos(fract(iTime*0.9)*6.28)*0.1;// bounce\n\n    \n    float blur = 0.005;\n    \n    //vec3 background = vec3(0.0);\n    vec3 grey = vec3(0.2,0.2,0.2);\n    vec3 txtcol = vec3(0.8,0.8,0.8);\n    vec3 blue = vec3(0.2,0.6,0.6);\n    \n    float _d = length(p);\n    \n    float d = smoothstep(0.0,blur, _d-0.5);\n    vec3 color = mix(background*0.45,background,d);\n    \n    \n    d = smoothstep(0.0,blur, _d-0.3);\n    color = mix(grey,color,d);\n\n\n    d = _d-0.23;\n    d = abs(d)-0.01;\n    d = smoothstep(0.0,blur, d);\n    color = mix(blue,color,d);\n\n    d = _d-0.51;\n    d = abs(d)-0.012;\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n\n\n\tvec2 tri = vec2(0.22,-0.13); // width, height\n\n\tfloat td = sdTriangleIsosceles( p-vec2(-0.05,0.18), tri );\n    d = smoothstep(0.0,blur, td-0.0125);\n    color = mix(grey,color,d);\n\n    d = smoothstep(0.0,blur, td);\n    color = mix(txtcol,color,d);\n    \n    \n    vec2 pp = p-vec2(-0.05,0.0);\n    \n    d = sdOrientedBox(pp,vec2(-0.09,0.05),vec2(-0.0795,-0.14),0.05);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n    \n    d = sdOrientedBox(pp,vec2(0.09,0.05),vec2(0.0795,-0.14),0.05);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n    \n    d = circle(p+vec2(0.07,0.055),0.0125);\n    d = smoothstep(0.0,blur, d);\n    color = mix(txtcol,color,d);\n\n    d = CircleText(p);\n    d = smoothstep(0.0,0.03,d);\n    if (p.y > 0.)\n        color = mix(txtcol,color,d);\n    else\n        color = mix(blue,color,d);\n\n    d = DateText(p);\n    \n    d = smoothstep(0.0,blur, d);\n    color = mix(blue*1.1,color,d);\n        \n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t23WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 162, 162, 192], [193, 193, 244, 244, 529], [530, 530, 596, 596, 813], [817, 860, 909, 909, 1156], [1158, 1158, 1182, 1182, 1780], [1781, 1781, 1802, 1802, 1870], [1872, 1872, 1898, 1947, 2111], [2114, 2114, 2138, 2138, 2461], [2463, 2463, 2486, 2486, 2566], [2568, 2588, 2610, 2610, 3007], [3009, 3022, 3052, 3052, 3325], [3327, 3327, 3349, 3349, 3909], [3911, 3911, 3966, 3966, 5749]], "test": "untested"}
{"id": "ft2GDz", "name": "oushinnyo's first shader", "author": "oushinnyo", "description": "Just the parctice of a rookie.", "tags": ["2d"], "likes": 1, "viewed": 197, "published": 3, "date": "1623728880", "time_retrieved": "2024-07-30T19:15:58.983741", "image_code": "#define PI 3.14159265359\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec3 color=vec3(0.);\n        \n    vec2 l1=vec2(0.);\n    l1.x=step(0.1,uv.x)-step(0.11,uv.x);\n    l1.y=step(0.,uv.y);\n    \n    \n    vec2 l2=vec2(0.);\n    l2.x=step(0.89,uv.x)-step(0.9,uv.x);\n    l2.y=step(0.,uv.y);\n    \n    vec2 l3=vec2(0.);\n    l3.x=step(0.,uv.x);\n    l3.y=step(0.79,uv.y)-step(0.8,uv.y);\n    \n    vec2 l4=vec2(0.);\n    l4.x=step(0.,uv.x);\n    l4.y=step(0.89,uv.y)-step(0.9,uv.y);\n    \n    vec2 l5=vec2(0.);\n    l5.x=step(0.95,uv.x)-step(0.96,uv.x);\n    l5.y=step(0.,uv.y);\n    \n    vec2 l6=vec2(0.);\n    l6.x=step(0.05,uv.x)-step(0.06,uv.x);\n    l6.y=step(0.8,uv.y);\n    \n    vec2 lt=vec2(0.);\n    lt.x=step(0.9,1.-uv.x)-l6.x;\n    lt.y=step(0.8,uv.y)-l4.y;\n    \n    vec2 rd=vec2(0.);\n    rd.x=step(0.9,uv.x)-l5.x;\n    rd.y=step(0.95,1.-uv.y);\n    \n    vec2 rt=vec2(0.);\n    rt.x=step(0.975,uv.x);\n    rt.y=step(0.8,uv.y)-l4.y;\n    \n    vec3 red=vec3(0.8039,0.102,0.102);\n    vec3 green=vec3(0.4118,0.3490,0.8039);\n    vec3 yellow=vec3(1.,1.7255,0.0588);\n    vec3 white=vec3(0.9922,0.9608,0.9020);\n    vec3 black=vec3(0.,0.,0.);\n    \n    \n    \n    float pct=lt.x*lt.y+rd.x*rd.y+rt.x*rt.y+l1.x*l1.y+l2.x*l2.y+l3.x*l3.y+l4.x*l4.y+l5.x*l5.y+l6.x*l6.y;\n    pct=step(1.0,1.-pct);\n    \n    color=lt.x*lt.y*red+rd.x*rd.y*green+rt.x*rt.y*yellow+pct*white+l1.x*l1.y*black+l2.x*l2.y*black+l3.x*l3.y*black+l4.x*l4.y*black+l5.x*l5.y*black+l6.x*l6.y*black;\n    \n    fragColor=vec4(color,1.); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 82, 82, 1523]], "test": "untested"}
{"id": "Nt23WR", "name": "LookingGlass: Tutorial VR Base", "author": "xjorma", "description": "Shader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy", "tags": ["tutorial", "glass", "looking", "lookingglass"], "likes": 0, "viewed": 347, "published": 3, "date": "1623706092", "time_retrieved": "2024-07-30T19:15:59.732738", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n//#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_DIST\t\t150.\nconst float PI = radians(180.);\n\n\n\nfloat map(vec3 p)\n{\n\treturn length(p) - 1.0;\n}\n\n\n\nfloat rayMarch(in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 40; i++)\n  {\n    float h = map(ro + rd * t);\n    t += h;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.2 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float t = rayMarch(ro, rd, 0.);\n    vec3\tcol = vec3(0);\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);   \n        col = texture(iChannel0, reflect(rd, n)).rgb;\n    }\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro + vec3(0, 0, 9), rd), 1);\n}\n\n\n// Comment the original mainImage\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI * 0.3;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - PI / 2.;\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        tot += Render(ro ,rd);\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt23WR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[245, 245, 264, 264, 291], [295, 295, 350, 350, 515], [1072, 1072, 1127, 1127, 1223], [1226, 1226, 1263, 1263, 1493], [1495, 1495, 1537, 1537, 1701], [1703, 1703, 1781, 1781, 1840]], "test": "untested"}
{"id": "flj3WR", "name": "Mountain rivers", "author": "jarble", "description": "Yet another fractal terrain experiment.", "tags": ["fractal", "terrain", "river", "mountain"], "likes": 5, "viewed": 279, "published": 3, "date": "1623704656", "time_retrieved": "2024-07-30T19:16:00.480738", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\nfloat noise(in vec2 uv)\n{\n    \n    return sin(uv.x*1.25)+cos(uv.y/1.25);\n}\n\n\n#define OCTAVES 6\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float amplitude = 1.5;\n    float freq = 0.8;\n    uv /= amplitude;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.45-abs(noise(uv * freq)-.45) * amplitude));\n        \n        amplitude *= -.27;\n        \n        freq *= 3.5-value/8.0;\n        \n        uv += uv.yx/freq;\n        //uv += vec2(cos(uv.x/freq),sin(uv.y/freq));\n    }\n    \n    return value-2.6;\n}\n\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flj3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 435, 435, 484], [505, 505, 528, 577, 1068], [1143, 1143, 1181, 1181, 1241], [1243, 1243, 1276, 1276, 1496], [1498, 1498, 1536, 1536, 1763], [1765, 1765, 1803, 1803, 2027], [2029, 2029, 2058, 2058, 2153], [2155, 2155, 2192, 2192, 2251], [2254, 2322, 2341, 2341, 2380], [2382, 2382, 2402, 2402, 2478], [2480, 2480, 2499, 2499, 2538], [2540, 2540, 2597, 2597, 2832], [2834, 2834, 2869, 2869, 3263], [3265, 3265, 3319, 3319, 3985], [3988, 3988, 4040, 4040, 4475], [4477, 4477, 4534, 4534, 5725]], "test": "untested"}
{"id": "slS3WR", "name": "2d tentacles", "author": "avin", "description": "Special for https://t.me/webgl_ru \"Tentacles\" competition", "tags": ["tentacles"], "likes": 31, "viewed": 924, "published": 3, "date": "1623685857", "time_retrieved": "2024-07-30T19:16:01.365373", "image_code": "\n#define COL1 vec3(32, 43, 51) / 255.0 \n#define COL2 vec3(235, 241, 245) / 255.0 \n\n#define SF 1./min(iResolution.x,iResolution.y)*SIZE*.5\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\n\n// ---------------------\n\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// ----------------------\n\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n { \n    vec2 ouv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x; \n    \n    float SIZE = iResolution.x/75.;\n        \n    ouv *= SIZE;\n    \n    float mask = 0.0;    \n    \n    vec2 uv = ouv;\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;    \n    \n    float t = iTime*3.;\n    \n    float totalLayers = 30.;\n    for(float layer = 0.0; layer <= totalLayers; layer++ ) {\n        \n        uv += vec2(0., -sqrt(sqrt(layer))*.02);\n        \n        float layerFactor1 = layer/totalLayers;\n        float layerFactor2 = layerFactor1*.85 + .15;\n        \n        float layerFactorMove = layer*.15;\n        \n        \n    \n        for(float y =- 1.0; y <= 1.0; y++ ) {\n            for(float x =- 1.0; x <= 1.0; x++ ) {\n                vec2 rid = id - vec2(x, y);\n                \n                float pf = .1 + layerFactor1*.25;\n                \n                vec2 ruv = uv + vec2(x, y) + \n                    vec2(0, mod(rid, 2.)*.5) + \n                    vec2(\n                        noise(vec3(rid, t - layerFactorMove))*pf,\n                        noise(vec3(rid, t + 2000. - layerFactorMove))*pf\n                    );            \n\n                float l = length(ruv);            \n\n                float diameter = .70 - layerFactor2*.675;\n                float d = SS(l, diameter);      \n\n                mask = max(mask, d * layerFactor1);      \n                                \n                mask -= SS(l+SF*1.5, diameter);\n            }\n        }\n    }\n    \n    vec3 col = vec3(1.0);\n    col = mix(COL1, COL2, abs(mask));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slS3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 226, 226, 321], [323, 323, 349, 349, 823], [854, 854, 910, 910, 2481]], "test": "untested"}
{"id": "7lB3WR", "name": "Day 543", "author": "jeyko", "description": "potaterrino", "tags": ["dots", "mograph", "mdtmjvm"], "likes": 26, "viewed": 502, "published": 3, "date": "1623685236", "time_retrieved": "2024-07-30T19:16:02.222082", "image_code": "// hueshift from https://www.shadertoy.com/view/MsjXRt\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    //fragCoord += 650.*noise(vec3(uv*0.5,5.))/iResolution.xy;\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n\n    //col += smoothstep(0.,5.,max(noise(vec3(uv*2.,5.)) - 0.5,0.))*0.25;\n    \n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(fragCoord + n1d*200. ,256.)),0).xyz;\n    \n    \n    //C = smoothstep(0.,1.,C);z\n    \n    //col.xyz = pow(max(col.xyz,0.), vec3(0.55) + n*0.1);\n    \n    \n    \n    col = pow(max(col,0.),vec3(0.4545));\n\n    col.xyz += smoothstep(0.5,0.,length(col))*n*0.1;\n    \n    col.xyz -= smoothstep(0.4,1.,length(col))*n*0.1;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pmod(p,a) mod(p,a) - 0.5*a\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi radians(90.)\n#define iTime (iTime + 20.)\n\nfloat sdBox(vec2 p, vec2 s){p = abs(p) - s; return max(p.x,p.y);}\n\n\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 4.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1,1.,0.9);\n    vec3 c = vec3(0.4,0.41,0.4)*0.;\n    vec3 cb = vec3(0.,0.7,0.3);\n    \n    vec2 md = vec2(0.1,0.2);    \n    {\n        vec2 p = uv;\n        \n        p.x += iTime*0.1;\n        \n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        \n        float die = fract(sin(id.x*10.*sin(id.y*10.) + cos(id.x*6.)*id.y + id.x));\n        if (die < 0.35){\n            p = pmod(p,md.x/4.);\n            //float d = length(p) - 0.003 + sin(die*20. + iTime*5.)*0.002;\n            p = abs(p)*rot(0.5*pi);\n            float d = sdBox(p,vec2(0.004,0.003+ sin(die*20. + iTime*5.)*0.002));\n            \n            \n            col = mix(col,c,smoothstep(fwidth(d),0.,d));\n            \n        } else if (die < 0.6){\n            //p = abs(p);\n            p[int(die*2000. + iTime)%2] -= 0.4;\n            float d = sdBox(p,vec2(0.07))+ sin(die*20. + iTime*5.)*0.0;\n            d = abs(d);\n            d = pmod(d + iTime*0.,0.01);\n            col = mix(col,cb,smoothstep(fwidth(uv.y),0.,d));\n        } else if (die < 0.8){\n            //p = pmod(p,md.x/4.);\n            //float d = sdBox(p,vec2(0.003));\n            float d = abs(p.x);\n            //d = min(d,abs(p.y));\n            //d -= 0.00;\n            //col = vec3(0);\n            //col = mix(col,1.-col,smoothstep(fwidth(uv.y),0.,d));\n        }\n    }\n    {\n        md = md.yx;\n        md.x *= 1.;\n        vec2 p = uv;\n        \n        p.x += iTime*0.1;\n        \n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        \n        float die = fract(sin(id.x*10.*sin(id.y*10.) + cos(id.x*6.)*id.y + id.x));\n        if (die < 0.35){\n            p = pmod(p,md.x/4.);\n            float d = length(p) - 0.003 + sin(die*20. + iTime*5.)*0.002;\n            col = mix(col,c,smoothstep(fwidth(d),0.,d));\n            \n        } else if (die < 0.5){\n            col -= col*1. - vec3(0.,0.4,0.2);\n        }\n    \n    }\n    \n    {\n        for(float i = 0.; i < 250.; i++){\n            float sp = (1. + sin(i*114.5)*0.5)*0.1;\n            float T = iTime + sin(iTime + i)*0.5;\n            vec2 p = uv + vec2(-1.5 + mod(T*sp,1.)*4.,sin(i*4.5 + T*0.1));\n            float s = 0.2 + sin(i)*0.1;\n            s *= 0.5;\n            float d = 10e4;\n            \n            if(sp < 0.1){\n                d = length(p) - s;\n\n                d = pmod(abs(d),0.01);\n                d = max(d,length(p) - s);\n                d = abs(d) - 0.002;\n\n            } else if (sp < 0.14) {\n                float outer = length(p) - s;\n                \n                p = pmod(p,0.01);\n                d = length(p) - 0.003;\n\n                //d = pmod(abs(d),0.01);\n                //d = abs(d) - 0.002;\n                d = max(d,outer);\n            } else {\n                //float outer = length(p) - s;\n                \n                d = length(p) - s;\n\n                //d = max(d,outer);\n            }\n            \n            col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n        \n        }\n    \n    }\n    {\n        for(float i = 0.; i < 10.; i++){\n            float t = iTime + sin(iTime + i);\n            float sp = (1. + sin(i*114.5)*0.5)*0.1;\n            vec2 p = uv + vec2(-1.5 + mod(t*sp,1.)*4.,sin(i*4.5 + t*0.));\n            p *= 2. + sin(i);\n            float d = text(p, float[4](114.,130.,133.,120.), -0.5 , 0.2 , false, 0., 0.54 , false);\n            \n            vec3 cc = vec3(0);\n            col = mix(col,cc,smoothstep(fwidth(d)*(1.-step(0.01,d)),0.,d));\n\n        }\n        //vec2 p = uv;\n        \n    \n    }\n    \n    \n    {\n        if(abs(uv.y) > 0.45)\n            col = 1.-length(col)*vec3(1);\n    \n    }\n    {\n        vec2 p = uv;\n        p.x += iTime;\n        p.x = pmod(p.x,15.);\n        \n        float sz = .1;\n        //p.y = abs(p.y);\n        p *= rot(0.5*pi);\n        float d = abs(p.x);\n        d = max(pmod(d,sz*(0.25 + 0.01)),abs(p.x - sz*0.5 ) - sz);\n        //col = mix(col,vec3(1,1,1.) - col*(0.5+0.5*vec3(0.5,0.6,0.9)), smoothstep(fwidth(uv.y),0.,d));\n        \n    \n    }\n    vec3 ccc = col.zyx;\n    \n    //ccc -= 1.;\n    //ccc.zx *= rot(5.4);\n    ccc = HueShift ( ccc, -.2).xyz;\n    //ccc += 1.;\n    col = mix(col,ccc, smoothstep(0.8,0.85,sin(iTime*0.5 + uv.x*0.25)));\n        \n    col = mix(col,col.xzy, smoothstep(0.7,0.76,sin(iTime*0.5 + 3. + uv.x*0.25)));\n        \n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return vec4(Color,1.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lB3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 113, 113, 899]], "test": "untested"}
{"id": "ftSGDz", "name": "No GI", "author": "fraser", "description": "I'm gonna try to add GI to this, wish me luck!", "tags": ["3d", "raymarching", "sdf", "cineshader"], "likes": 1, "viewed": 5586, "published": 3, "date": "1623674370", "time_retrieved": "2024-07-30T19:16:03.052862", "image_code": "// A way of packaging together distance information with an object identifier \n// (uint standing in for an enum). Possibly expand to include more information \n// (blending, etc) later, though it'll be tough without even so much as a \n// c-union, never-mind something like rust-enums.\n#define SKY_MAT    0u\n#define MATTE_MAT  1u\n#define ORANGE_MAT 2u\n#define GREEN_MAT  3u\n#define LIGHT_MAT  4u\nstruct DistIden{\n\tfloat dist;\n\tuint  iden;\n};\n\n// speed isn't particularly important rn, so I'm going with an exponential \n// implementation for commutability. We can change this later for RTRT.  \nfloat smin(float a, float b, float k){\n\treturn -log2(exp2(-k*a) + exp2(-k*b))/k;\n}\nfloat smax(float a, float b, float k){\n\treturn log2(exp2(k*a) + exp2(k*b))/k;\n}\n\n#define windowPeriod 3.0\n#define boxwidth 3.0\n#define boxheight 1.5\n#define boxthickness 0.1\n\n#define ENABLE_boxroundness 0  // 1\n#define boxroundness 0.0       // 0.1\n\nfloat SDF_SPHERE(vec3 pos, float r){\n\treturn length(pos)-r;\n}\n\nfloat SDF_BOXTUBE(vec3 pos){\n\tvec2 q2 = abs(pos.yz) - vec2(boxheight/2.0, boxwidth/2.0);\n\tfloat d_tube = abs(length(max(q2,0.0)) + min(max(q2.x,q2.y),0.0)-boxroundness*3.0) - boxthickness;\n\tvec3 q3 = abs(vec3(mod(pos.x, windowPeriod)-windowPeriod*0.5, pos.y-boxheight/2.0, pos.z)) - vec3(0.5,0.5,0.5);\n\tfloat d_hole = length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0)-boxroundness;\n#if ENABLE_boxroundness == 0\n\treturn max(d_tube, -d_hole);\n#else\n\treturn smax(d_tube, -d_hole, 50.0);\n#endif\n}\n\nDistIden DI_WORLD(vec3 pos){\n\tfloat d_sphere1   = SDF_SPHERE(vec3(mod(pos.x,2.62)-1.31, pos.y+0.6, pos.z+1.25), 0.85);\n\tfloat d_sphere2   = SDF_SPHERE(vec3(mod(pos.x-4.0,11.0)-5.5, pos.y-0.35, pos.z-1.1), 0.25);\n\tfloat d_left_wall = max(1.35-pos.z, abs(pos.y)-boxheight/2.0-boxthickness-0.1);\n\tfloat d_boxtube   = SDF_BOXTUBE(pos);\n\t\n\tDistIden di;\n\t\n\tdi.iden = MATTE_MAT; // as either option on this junction uses MATTE\n\tdi.dist = smin(d_boxtube, d_sphere1, 12.0);\n\t\n\tdi.iden = d_sphere2 < di.dist ? ORANGE_MAT : di.iden;\n\tdi.dist = min(d_sphere2, di.dist);\n\t\n\tdi.iden = d_left_wall < di.dist ? GREEN_MAT : di.iden;\n\tdi.dist = min(d_left_wall, di.dist);\n\t\n\treturn di;\n}\n\n#define RAY_ITERATIONS 512 // set via macro\nDistIden raycast(vec3 rayOrg, vec3 rayDir, float maxDist){\n\tfloat rayLength = 0.0;\n\tDistIden query;\n\tfor(int i=0;i<RAY_ITERATIONS;i++){\n\t\tquery = DI_WORLD(rayOrg + rayLength * rayDir);\n\t\tif(query.dist<0.001) break;\n\t\tif(rayLength>maxDist){\n\t\t\tquery.iden = SKY_MAT;\n\t\t\tbreak;\n\t\t}\n\t\trayLength += query.dist;\n\t}\n\tquery.dist = rayLength;\n\treturn query;\n}\n\n// using iq's \"tetrahedron technique\"\nvec3 calcNormal(vec3 pos){\n\tvec2 EPSILON = 0.0001*vec2(1,-1);\n\treturn normalize(EPSILON.xyy*DI_WORLD(pos+EPSILON.xyy).dist+ \n\t\t\t\t\t EPSILON.yyx*DI_WORLD(pos+EPSILON.yyx).dist+ \n\t\t\t\t\t EPSILON.yxy*DI_WORLD(pos+EPSILON.yxy).dist+ \n\t\t\t\t\t EPSILON.xxx*DI_WORLD(pos+EPSILON.xxx).dist);\t\n}\n\n\nvec3 skyColour(vec3 dir){\n\treturn vec3(0.639, 0.941, 1) - dir.y * 0.63;\n}\n\nconst vec3 sun_dir = normalize(vec3(-0.03,0.5,0.5));\n\n\n#define FAR_PLANE 5000.0 // set via macro, optionally non-existent via macro\nvec4 render(vec3 pos, vec3 dir){\n\tvec3 col = skyColour(dir);\n\t\n\tDistIden ray = raycast(pos, dir, FAR_PLANE);\n\tif(ray.iden != SKY_MAT){\n\t\tpos += ray.dist * dir;\n\t\tvec3 normal = calcNormal(pos);\n\t\t\n\t\tfloat ambient \t\t= clamp(1.0-normal.y,0.25,2.0)*0.4;\n\t\tambient \t\t\t+=clamp(1.0-normal.x,0.0 ,2.0)*0.1;\n\t\tfloat sun_diffuse\t= clamp(dot(sun_dir,normal),0.0,1.0);\n\t\tfloat sun_shadow\t= (raycast(pos+normal*0.001, sun_dir, FAR_PLANE).iden==SKY_MAT)?1.0:0.0;\n\t\tvec3 matte = vec3(0.2);\n\t\tswitch(ray.iden){\n\t\t\tcase ORANGE_MAT:\n\t\t\t\tmatte *= vec3(1.0,0.5,0.0);\n\t\t\t\tbreak;\n\t\t\tcase GREEN_MAT:\n\t\t\t\tmatte *= vec3(0.0,1.0,0.16);\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcol =  matte*(vec3(1, 0.980, 0.839)*6.0*sun_shadow*sun_diffuse+ambient*vec3(1, 0.95, 0.93)*1.2);\n\t}\n\treturn vec4(col, 1.0/(1.0+ray.dist));\n}\n\nmat3 cameraMatrix(vec3 cameraPointingVec){\n\tvec3 x = normalize(vec3(cameraPointingVec.z, 0.0, -cameraPointingVec.x));\n\treturn mat3(x, cross(cameraPointingVec,x), -cameraPointingVec);\n}\n\nconst float FOV_OFFSET = 1.64; //=1/tan(0.5*FOV)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //<Camera>\n\tvec2 uv = (2.0*fragCoord-vec2(iResolution.xy))/float(min(iResolution.x, iResolution.y));\n\t// 1.0≈1m\n\t// this following 4 var system is temporary, will be turned into a proper set of uniforms with more control later.\n\t\tvec3  subjectPos    = vec3(-iTime*0.75, -0.3, 0.0); \n\t\tfloat yawAngle      = -0.2 + sin(iTime*0.347)*0.05;\n\t\tfloat subjectXZDist = 2.0;\n\t\tfloat subjectYDist  = 0.6 + sin(iTime*0.6)*0.1;\n\tvec3 rayOrg = subjectPos + vec3(subjectXZDist*cos(yawAngle), subjectYDist, subjectXZDist*sin(yawAngle));\n\tvec3 rayDir = cameraMatrix(normalize(rayOrg - subjectPos)) * normalize(vec3(uv, FOV_OFFSET));\n\t//</Camera>\n\t\n\tfragColor = render(rayOrg, rayDir);\n\t\n\tfragColor.xyz = pow(fragColor.xyz,vec3(0.4545)); // gamma correction\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSGDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 591, 629, 629, 673], [674, 674, 712, 712, 753], [924, 924, 960, 960, 985], [987, 987, 1015, 1015, 1485], [1487, 1487, 1515, 1515, 2156], [2202, 2202, 2260, 2260, 2552], [2554, 2592, 2618, 2618, 2872], [2875, 2875, 2900, 2900, 2948], [3082, 3082, 3114, 3114, 3852], [3854, 3854, 3896, 3896, 4038], [4090, 4090, 4144, 4159, 4893]], "test": "untested"}
{"id": "wtcyWS", "name": "mousdist", "author": "Esfo", "description": "mouse distance", "tags": ["mouse"], "likes": 0, "viewed": 189, "published": 3, "date": "1623659408", "time_retrieved": "2024-07-30T19:16:03.896605", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 norm = fragCoord/iResolution.xy;\n    vec2 mnorm = iMouse.xy/iResolution.xy;\n    float dist = distance(norm, mnorm);\n    fragColor = vec4(dist,2,dist,10);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 222]], "test": "untested"}
{"id": "NlS3WR", "name": "live blend react", "author": "firebreathz", "description": "awesome", "tags": ["blend"], "likes": 2, "viewed": 231, "published": 3, "date": "1623648554", "time_retrieved": "2024-07-30T19:16:04.764285", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvA = fragCoord / iChannelResolution[0].xy;\n    vec2 uvB = fragCoord / iChannelResolution[1].xy;\n\n    // Output to screen\n    // Fragment is the sum of both gradients: red to green\n    fragColor = texture(iChannel0, uvA) + texture(iChannel1, uvB);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 18:25:29\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 40\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    //uv.x-=0.25;\n    //uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 5.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.99;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,0.08) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 6;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.05,1.05,1.0);\n    colors[1] = vec3(1.205,1.00,1.00);\n    colors[2] = vec3(1.50,1.00,1.25);\n    colors[3] = vec3(1.90,0.75,3.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*1.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.025,0.875,f);\n    col *= smoothstep(0.875,0.625,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(0.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.y));\n\n    ref /= 8.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.5*smoothstep(1.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.02)*smoothstep(1.0,0.0,length(p*8.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(0.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(1.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2226.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 c, vec2 q)\n{\n    float a=iTime*.1+1.,b=.5,g,e,t=0.,s;\n    vec3 r=vec3(0.,0.,3.),w=normalize(vec3((q-iResolution.xy/2.)/iResolution.y,-.5)),p;\n\n    mat2 x=mat2(cos(a),sin(a),sin(a),-cos(a)),y=mat2(cos(b),sin(b),sin(b),-cos(b));\n\n    w.xz=y*w.xz;\n    r.xz=y*r.xz;\n\n    w.yz=x*w.yz;\n    r.yz=x*r.yz;\n\n    c.rgb=vec3(0.,0.,.02);\n\n    for(int i=0;i<35;++i)\n    {\n        p=r+w*t;\n\n        float f=.25,d=1e4;\n        for(int j=0;j<2;++j)\n        {\n            s=.2*dot(p,p);\n            p=p/s;\n            f*=s;\n            g=p.z;\n            e=atan(p.y,p.x);\n            p=(mod(p,2.)-1.)*1.25;\n        }\n\n        d=min((length(abs(p.xy)-1.3)-.1)*f,1e2);\n\n        if(d<1e-3)\n            break;\n\n        c.rgb+=vec3(.3,.4,.8)*(pow(.5+.5*cos(g*.5+a*77.+cos(e*10.)),16.))*\n            (1.-smoothstep(0.,1.,70.*d))*.25;\n\n        t+=d;\n    }\n}\n\n", "buffer_b_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlS3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 366]], "test": "untested"}
{"id": "flS3WR", "name": "bloom ploar caps bright round", "author": "firebreathz", "description": "Test realistic bloom using texture lods", "tags": ["2d", "blur", "filter", "bloom", "lod"], "likes": 6, "viewed": 297, "published": 3, "date": "1623647013", "time_retrieved": "2024-07-30T19:16:05.642936", "image_code": "// Fork of \"bloom ploar caps\" by firebreathz. https://shadertoy.com/view/ftS3WR\n// 2021-06-14 05:01:35\n\n// Fork of \"Lod bloom\" by luluco250. https://shadertoy.com/view/MlBcRV\n// 2021-06-14 04:34:05\n\n// Final blend\n\n#define BLOOM_INTENSITY 9.9\n#define BLOOM_STEPS 9\n#define SHOW_BLOOM 0\n\nconst vec2[] offsets = vec2[](\n    vec2(0.05, 0.075),\n    vec2(0.975, 0.05),\n    vec2(0.975, 0.55),\n    vec2(0.975, 0.875),\n    vec2(0.7, 0.95),\n    vec2(0.65, 0.7),\n    vec2(0.65, 0.5),\n    vec2(0.475, 0.65),\n    vec2(0.325, 0.65)\n);\n\nvec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {\n    return (uv - center) * scale + center;\n}\n\nvec4 read_bloom(sampler2D sp, vec2 uv, float lod, vec2 center) {\n    uv = scale_uv(uv, vec2(1.0 / pow(2.0, lod)), center);\n    return texture(sp, uv);\n}\n\nvec4 get_bloom(sampler2D sp, vec2 uv, int steps) {\n    vec4 col = vec4(0.0);\n    \n    for (int i = 1; i <= steps; ++i)\n        col += read_bloom(sp, uv, float(i), offsets[i - 1]);\n    \n    return col / float(steps);\n}\n\nvec3 screen(vec3 a, vec3 b, float w) {\n    return mix(a, vec3(1.0) - (vec3(1.0) - a) * (vec3(1.0) - b), w);\n}\n\nvec3 tonemap(vec3 col) {\n    return col / (vec3(1.0) + col);\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    \n    #if SHOW_BLOOM == -1\n    \n    color = texture(iChannel0, uv);\n    \n    #elif SHOW_BLOOM == 2\n    \n    color = texture(iChannel1, uv);\n    \n    #else\n    \n    vec4 bloom = get_bloom(iChannel1, uv, BLOOM_STEPS);\n    \n    #if SHOW_BLOOM == 1\n    \n    color = bloom;\n    \n    #else\n    \n    color = texture(iChannel0, uv);\n    \n    if (iMouse.z > 0.0)\n    \tcolor += (bloom * BLOOM_INTENSITY) * iMouse.x / iResolution.x;\n    else\n        color += bloom * BLOOM_INTENSITY;\n    \n    color.rgb = tonemap(color.rgb);\n    color.rgb *= 1.0 - smoothstep(0.0, 2.0, distance(uv, vec2(0.5)));\n    \n    //color.rgb = screen(color.rgb, bloom.rgb, BLOOM_INTENSITY);\n    \n    #endif\n    #endif\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 18:25:29\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 40\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    //uv.x-=0.25;\n    //uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 5.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.99;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,0.08) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 6;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.05,1.05,1.0);\n    colors[1] = vec3(1.205,1.00,1.00);\n    colors[2] = vec3(1.50,1.00,1.25);\n    colors[3] = vec3(1.90,0.75,3.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*1.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.025,0.875,f);\n    col *= smoothstep(0.875,0.625,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(0.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.y));\n\n    ref /= 8.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.5*smoothstep(1.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.02)*smoothstep(1.0,0.0,length(p*8.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(0.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(1.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2226.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Split source into lods\n\nconst vec2[] offsets = vec2[](\n    vec2(0.05, 0.075),\n    vec2(0.975, 0.05),\n    vec2(0.975, 0.55),\n    vec2(0.975, 0.875),\n    vec2(0.7, 0.95),\n    vec2(0.65, 0.7),\n    vec2(0.65, 0.5),\n    vec2(0.475, 0.65),\n    vec2(0.325, 0.65)\n);\n\nvec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {\n    return (uv - center) * scale + center;\n}\n\nvoid draw(inout vec4 color, sampler2D sp, vec2 uv, float lod, vec2 center) {\n    uv = scale_uv(uv, vec2(pow(2.0, lod)), center);\n    \n    if (uv.x >= -0.1 && uv.x <= 1.1 && uv.y >= -0.1 && uv.y <= 1.1)\n        color += textureLod(sp, uv, lod);\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    color = vec4(0.0);\n    \n    for (int i = 1; i < 10; ++i)\n        draw(color, iChannel0, uv, float(i), offsets[i - 1]);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Horizontal blur\n\n#define BLUR_SAMPLES 9\n#define pi 3.141592\n#define pow2(x) (x * x)\n\nfloat gaussian(float x, float sigma) {\n    return (1.0 / sqrt(2.0 * pi * pow2(sigma))) * exp(-(pow2(x) / (2.0 * pow2(sigma))));\n}\n\nvec4 blur(sampler2D sp, vec2 uv, vec2 scale) {\n    vec4 col = vec4(0.0);\n    float accum, weight, offset;\n    \n    for (int i = -BLUR_SAMPLES / 2; i < BLUR_SAMPLES / 2; ++i) {\n        offset = float(i);\n        weight = gaussian(offset, sqrt(float(BLUR_SAMPLES)));\n        col += texture(sp, uv + scale * offset) * weight;\n        accum += weight;\n    }\n    \n    return col / accum;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color = blur(iChannel0, uv, vec2(ps.x, 0.0));\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Vertical blur\n\n#define BLUR_SAMPLES 9\n#define pi 3.141592\n#define pow2(x) (x * x)\n\nfloat gaussian(float x, float sigma) {\n    return (1.0 / sqrt(2.0 * pi * pow2(sigma))) * exp(-(pow2(x) / (2.0 * pow2(sigma))));\n}\n\nvec4 blur(sampler2D sp, vec2 uv, vec2 scale) {\n    vec4 col = vec4(0.0);\n    float accum, weight, offset;\n    \n    for (int i = -BLUR_SAMPLES / 2; i < BLUR_SAMPLES / 2; ++i) {\n        offset = float(i);\n        weight = gaussian(offset, sqrt(float(BLUR_SAMPLES)));\n        col += texture(sp, uv + scale * offset) * weight;\n        accum += weight;\n    }\n    \n    return col / accum;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1.0) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    color = blur(iChannel0, uv, vec2(0.0, ps.y));\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3WR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[523, 523, 572, 572, 617], [619, 619, 683, 683, 771], [773, 773, 823, 823, 990], [992, 992, 1030, 1030, 1101], [1103, 1103, 1127, 1127, 1165], [1167, 1167, 1211, 1211, 1935]], "test": "untested"}
{"id": "7l23zm", "name": "We Got Misleading Directions", "author": "stseagle", "description": "Inspired by a zigzagging pattern quilt", "tags": ["2d", "grid", "triangles", "quilt"], "likes": 2, "viewed": 249, "published": 3, "date": "1623642186", "time_retrieved": "2024-07-30T19:16:06.520589", "image_code": "float zig(in vec2 uv) {\n    return 1.-step(2.*abs(uv.y-0.5)-uv.x, 0.01);\n}\n\nfloat zag(in vec2 uv) {\n    return 1.-step(2.*abs(uv.y-0.5)-(1.-uv.x), 0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Tile the image into long skinny tiles\n    vec2 uv = 15.* fragCoord/iResolution.x*(iResolution.y/iResolution.x);\n    uv.x *= 2.5;\n    vec2 pos = floor(uv);\n    uv = fract(uv);\n    \n    \n    // Starting from the regular color changey pretty thing.\n    vec3 col = 0.5 + 0.35*cos(iTime * 0.5 - pos.x * 0.2 - pos.y +uv.xyx+vec3(0,1.3,3.5));\n    \n    vec3 triangle = vec3(0.);\n    \n    float offset = mod(pos.x+mod(pos.y,2.)*3.,6.);\n    \n    // The rows need to be offset from each other, and the arrows flip every three tiles\n    \n    if (offset <3.) {\n        triangle = vec3(zig(uv));\n    } else {\n        triangle = vec3(zag(uv));\n    }\n    \n\n    // That's it\n    fragColor = vec4(max(triangle,col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l23zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 74], [76, 76, 99, 99, 155], [157, 157, 214, 259, 926]], "test": "untested"}
{"id": "7tj3zm", "name": "Fork Fork Polar circling", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 3, "viewed": 244, "published": 3, "date": "1623636394", "time_retrieved": "2024-07-30T19:16:07.384280", "image_code": "// Fork of \"Fork Fork Polar circle\" by firebreathz. https://shadertoy.com/view/stjGzm\n// 2021-06-14 02:05:25\n\n// Fork of \"Fork Fork Polar \" by firebreathz. https://shadertoy.com/view/stj3Rw\n// 2021-06-14 01:09:17\n\n// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 18:25:29\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 40\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    //uv.x-=0.25;\n    //uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 5.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.01;\n    band += 0.04;\n    \n    s = texture( iChannel0, vec2(band,0.08) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 1.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 6;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.05,1.05,1.0);\n    colors[1] = vec3(1.205,1.00,1.00);\n    colors[2] = vec3(1.50,1.00,1.25);\n    colors[3] = vec3(1.90,0.75,3.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*1.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.025,0.875,f);\n    col *= smoothstep(0.875,0.625,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(0.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,0.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,0.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,0.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.y));\n\n    ref /= 1.0;\n     \n    float colStep = length(smoothstep(0.0,0.01,col));\n    \n    vec3 cs1 = drawBands(vec2(0.0,1.1));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*0.0-1.5))*0.5*smoothstep(1.0,-0.0,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.02)*smoothstep(1.0,0.0,length(p*8.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(0.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(1.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/20000.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tj3zm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[419, 419, 442, 442, 523], [525, 525, 567, 567, 626], [628, 628, 653, 653, 2190], [2192, 2192, 2249, 2249, 3504]], "test": "untested"}
{"id": "stSGRw", "name": "Nonintersecting Convex Polygons", "author": "pyBlob", "description": "Finds the least distance one has to push boxes apart, so they don't intersect (or pull, so that they touch). Should generalize to arbitrary convex polygons. Can be further simplified for boxes due to symmetry,\n\nMouse: drag box 2", "tags": ["collision"], "likes": 8, "viewed": 270, "published": 3, "date": "1623629348", "time_retrieved": "2024-07-30T19:16:08.270910", "image_code": "// find point x on box(p, b, r) that maximizes dot(x, n)\nvec2 support(vec2 p, vec2 b, mat2 r, vec2 n)\n{\n    return p + b * sign(r * n) * r;\n}\n\n// given a face with index (side, false) on box 1 or index (side, true) on box 2\n// how far do you have to push/pull the boxes, so that they definitely don't intersect\nvoid push1(\n    inout vec4 C, vec2 uv,\n    inout float d, inout vec2 normal, inout vec2 hit,\n    vec2 p1, vec2 b1, mat2 r1,\n    vec2 p2, vec2 b2, mat2 r2,\n    int side,\n    bool flip)\n{\n    if (flip)\n    {\n        swap(p1, p2);\n        swap(b1, b2);\n        swap(r1, r2);\n    }\n    const vec2[] sides = vec2[](vec2(-1,0),vec2(1,0),vec2(0,-1),vec2(0,1));\n    vec2 n = sides[side] * r1;\n    vec2 x = support(p2, b2, r2, -n);\n    vec2 y = support(p1, b1, r1, n);\n    d = dot(x - y, n);\n    normal = flip ? -n : n;\n    hit = flip ? y : x;\n    C = blend(C, vec4(.8,.2,0,1), abs(length(uv - y) - 6. * f));\n    C = blend(C, vec4(0,.5,0,1), abs(length(uv - x) - 10. * f));\n}\n\n// push boxes apart using the least distance traveled\nvoid push2(\n    inout vec4 C, vec2 uv,\n    inout float d, inout vec2 normal, inout vec2 hit,\n    vec2 p1, vec2 b1, mat2 r1,\n    vec2 p2, vec2 b2, mat2 r2)\n{\n    d = -10.;\n    vec4 c = vec4(0);\n    for (int j=0 ; j<2 ; ++j)\n    for (int i=0 ; i<4 ; ++i)\n    {\n        float di = -10.;\n        vec2 ni, hi;\n        vec4 ci = vec4(0);\n        push1(ci, uv, di, ni, hi, p1, b1, r1, p2, b2, r2, i, j == 0);\n        if (di > d)\n        {\n            d = di;\n            hit = hi;\n            normal = ni;\n            c = ci;\n        }\n    }\n    d = min(d, 0.); // only push, comment to pull\n    C = blend(C, c, 0.);\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    f = 1. / iResolution.y;\n    vec2 uv = (O - iResolution.xy / 2.) * f;\n\n    vec2 p1 = vec2(0);\n    vec2 b1 = vec2(.2, .1);\n    mat2 r1 = R(.2);\n\n    vec2 p2 = (iMouse.xy - iResolution.xy / 2.) * f;\n    vec2 b2 = vec2(.2, .1);\n    mat2 r2 = R(1.3);\n    \n    demo(p1, b1, r1, p2, b2, r2, iMouse, iTime);\n    \n    float d = 0.;\n    vec2 normal = vec2(0);\n    vec2 hit = vec2(0);\n    vec4 c = vec4(0);\n\n    // uncomment + edit exactly one\n    //push1(c, uv, d, normal, hit, p1, b1, r1, p2, b2, r2, 0, false);\n    //push1(c, uv, d, normal, hit, p1, b1, r1, p2, b2, r2, 2, true);\n    push2(c, uv, d, normal, hit, p1, b1, r1, p2, b2, r2);\n\n    C = vec4(0);\n    C = blend(C, c, 0.);\n    C = blend(C, vec4(1,0,0,1), arrow(uv, hit, hit - d * normal));\n    C = blend(C, vec4(1), abs(box(r1 * (uv - (p1 + d / 2. * normal)), b1)));\n    C = blend(C, vec4(1), abs(box(r2 * (uv - (p2 - d / 2. * normal)), b2)));\n    C = blend(C, vec4(0,0,1,1), abs(box(r1 * (uv - p1), b1)));\n    C = blend(C, vec4(0,0,1,1), abs(box(r2 * (uv - p2), b2)));\n    C = pow(C, vec4(.45));\n}\n", "image_inputs": [], "common_code": "const float pi = radians(180.);\n\nfloat box(vec2 p, vec2 b)\n{\n    // https://iquilezles.org/articles/distfunctions\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    b -= a;\n    p -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\nfloat arrow(vec2 p, vec2 a, vec2 b)\n{\n    vec2 t = b - a;\n    vec2 n = vec2(-t.y, t.x);\n    float r = line(p, a, b);\n    r = min(r, line(p, b - .2 * t - .1 * n, b));\n    r = min(r, line(p, b - .2 * t + .1 * n, b));\n    return r;\n}\n\nmat2 R(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec4 blend(vec4 C, vec4 c)\n{\n    return C + c * (1. - C.w);\n}\n\nfloat f;\nvec4 blend(vec4 C, vec4 c, float r)\n{\n    return blend(C, c * smoothstep(f, 0., r));\n}\n\n#define mk_swap(t) \\\nvoid swap(inout t a, inout t b) \\\n{ \\\n    t tmp = a; \\\n    a = b; \\\n    b = tmp; \\\n}\n\nmk_swap(vec2)\nmk_swap(mat2)\n\nvoid demo(\n    inout vec2 p1, inout vec2 b1, inout mat2 r1,\n    inout vec2 p2, inout vec2 b2, inout mat2 r2,\n    vec4 iMouse, float iTime)\n{\n    if (iMouse.z == 0.)\n    {\n        float r = .12;\n        float a = iTime / 5.;\n        p1 = vec2(r,0) * R(a + radians(180.));\n        p2 = vec2(r,0) * R(a);\n        r1 = R(iTime / 7.);\n        r2 = R(-iTime / 3.);\n    }\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSGRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 103, 103, 141], [979, 1033, 1189, 1189, 1644], [1646, 1646, 1685, 1685, 2738]], "test": "untested"}
{"id": "7t2Gzw", "name": "Squircle Reparametrization", "author": "oneshade", "description": "Reparametrization of a squircle (square circle, circle with general power). The goal is to achieve approximately constant speed while moving around its perimeter. Currently only works for powers >1. It becomes unstable for powers greater than 5 too.", "tags": ["squircle", "parametrization", "reparametrization"], "likes": 17, "viewed": 244, "published": 3, "date": "1623627438", "time_retrieved": "2024-07-30T19:16:09.044840", "image_code": "// Desmos graph: https://www.desmos.com/calculator/fd8azv2lgv\n\n#define REPARAMETRIZE\n\n// Constants\n#define TAU 6.28318530718 // 2π\n#define RHO 1.57079632679 // π/2\n\n// Magic constant I haven't found a good way to autoselect yet\n// Its a sort of scale factor\n#define h 1.758\n\n// Utilities\n#define drawSDF(dist, col, opac) color = mix(color, col, smoothstep(unit, 0.0, dist) * (opac))\n\n// SDFs\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nvec2 pSquircle(in float t, in float r, in float n) {\n    vec2 p = vec2(cos(t), sin(t));\n    return pow(abs(p), vec2(n)) * sign(p) * r;\n}\n\n// Approximation of arclength and inverse arclength\nfloat gain(in float x, in float n) {\n    float r = round(x);\n    return abs(r - 0.5 * pow(2.0 * abs(r - x), n));\n}\n\nfloat arcSquircle(in float t, in float r, in float n) {\n    t /= RHO;\n    return (gain(fract(t), n) + floor(t)) * r * h;\n}\n\nfloat invArcSquircle(in float t, in float r, in float n) {\n    t /= r * h;\n    return (gain(fract(t), 1.0 / n) + floor(t)) * RHO;\n}\n\nfloat sdSquircle(in vec2 p, in float r, in float n) {\n    p = abs(p);\n    vec2 pn = pow(p, vec2(n));\n    return abs((pn.x + pn.y - pow(r, n)) / length(pn / p * n));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 2.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    float time = 0.25 * iTime;\n    vec3 color = vec3(1.0);\n\n    float r = 0.75;\n    float n = mix(1.0, 5.0, 0.5 + 0.5 * sin(0.25 * iTime));\n\n    // This conversion bit was pulled out to simplify things\n    // It is necessary for the parametrization to match the implicit form\n    float pn = 2.0 / n;\n\n    // Squircle\n    float squircleAngle = atan(pow(abs(uv.y), 1.0 / pn) * sign(uv.y), pow(abs(uv.x), 1.0 / pn) * sign(uv.x));\n\n    #ifndef REPARAMETRIZE\n    float arclen = TAU * r;\n    #else\n    float arclen = arcSquircle(TAU, r, pn);\n    squircleAngle = arcSquircle(squircleAngle, r, pn);\n    #endif\n\n    float dashesMask = mod(floor(squircleAngle / arclen * 50.0 - 2.5 * iTime), 2.0);\n    drawSDF(sdSquircle(uv, r, n), vec3(0.0), dashesMask);\n\n    // Points moving around the perimeter\n    #ifndef REPARAMETRIZE\n    for (float t=0.0; t < TAU; t += TAU / 50.0) {\n        drawSDF(sdDisk(uv, pSquircle(t + time, r, pn), 0.025), vec3(1.0, 0.4, 0.5), 0.5 + 0.5 * sin(iTime));\n    }\n    #else\n    for (float t=0.0; t < arclen; t += arclen / 50.0) {\n        drawSDF(sdDisk(uv, pSquircle(invArcSquircle(t + time, r, pn), r, pn), 0.025), vec3(1.0, 0.4, 0.5), 0.5 + 0.5 * sin(iTime));\n    }\n    #endif\n\n    //drawSDF(abs(uv.y - arcSquircle(uv.x, r, n)), vec3(0.0));\n    //drawSDF(abs(uv.y - invArcSquircle(uv.x, r, n)), vec3(0.0));\n\n    // Vignette (kinda)\n    uv *= 0.5;\n    float dd = dot(uv, uv);\n    color -= 0.5 * dd * dd;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2Gzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 394, 441, 441, 549], [551, 551, 599, 599, 631], [633, 633, 685, 685, 769], [771, 823, 859, 859, 937], [939, 939, 994, 994, 1061], [1063, 1063, 1121, 1121, 1194], [1196, 1196, 1249, 1249, 1362], [1364, 1364, 1419, 1419, 3074]], "test": "untested"}
{"id": "Nl23Rw", "name": "Dice Game | Die Die Die", "author": "byt3_m3chanic", "description": "Having some fun with typography and making dice cause @blackle / cheezy music added for your enjoyment. (play some music to make the background EQ move)", "tags": ["raymarching", "game", "text", "audio", "visualizer", "typography", "dice"], "likes": 53, "viewed": 5093, "published": 3, "date": "1623625733", "time_retrieved": "2024-07-30T19:16:09.875619", "image_code": "/**\n\n     _____     __     ______     ______        ______     ______     __    __     ______    \n    /\\  __-.  /\\ \\   /\\  ___\\   /\\  ___\\      /\\  ___\\   /\\  __ \\   /\\ \"-./  \\   /\\  ___\\   \n    \\ \\ \\/\\ \\ \\ \\ \\  \\ \\ \\____  \\ \\  __\\      \\ \\ \\__ \\  \\ \\  __ \\  \\ \\ \\-./\\ \\  \\ \\  __\\   \n     \\ \\____-  \\ \\_\\  \\ \\_____\\  \\ \\_____\\     \\ \\_____\\  \\ \\_\\ \\_\\  \\ \\_\\ \\ \\_\\  \\ \\_____\\ \n      \\/____/   \\/_/   \\/_____/   \\/_____/      \\/_____/   \\/_/\\/_/   \\/_/  \\/_/   \\/_____/ \n                                                                                           \n\n    @byt3_m3chanic | 06/13/2021\n    \n    more typography stuff | die = 1 dice\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .001\n\nfloat sampleFreq(float freq) { return texture(iChannel0, vec2(freq, 0.25)).x;}\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n//@iq\nfloat box(vec3 p, vec3 b, in vec4 r )\n{   r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\tvec3 d = abs(p) - b+vec3(r.x,0,0);\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n// Letters from 2D to 3D extruded SDF's\nfloat getD(vec2 uv)\n{\n    float letd = box(uv,vec2(.125,.25),vec4(.125,.125,.00,0));\n    letd=abs(letd)-.05;\n    letd=min(box(uv+vec2(.125, .0),vec2(.05,.3)),letd);\n    return letd;\n}\nfloat getI(vec2 uv)\n{\n    uv.y=abs(uv.y);\n    float leti = box(uv,vec2(.05,.3));\n    leti = min(box(uv-vec2(.0, .25),vec2(.20,.05)),leti);\n    return leti;\n}\nfloat getC(vec2 uv)\n{\n    float letc = box(uv-vec2(.125,0),vec2(.25,.25),vec4(0,0,.2,.2));\n    letc=abs(letc)-.05;\n    letc=max(letc,-box(uv-vec2(.715 , .0),vec2(.5,.5)));\n    return letc;\n}\nfloat getE(vec2 uv)\n{\n    uv.y=abs(uv.y);\n    float lete = box(uv-vec2(.0, .0),vec2(.05,.3));\n    lete = min(box(uv-vec2(.1, .0),vec2(.10,.05)),lete);\n    lete = min(box(uv-vec2(.125, .25),vec2(.15,.05)),lete);\n    return lete;\n}\n//@iq\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat glow=0.,g_hs,s_hs;\nfloat mtime,time;\nmat2 turn,r90,r180;\n\nfloat dice(vec3 p)\n{\n    vec3 p3 = vec3(abs(p.x),p.y,abs(p.z));\n    vec3 p2 = vec3(abs(p.x),p.yz);\n    \n    float dz = .1;\n    float ox = .35;\n    float cz = .575;\n    \n    float base = box(p,vec3(.5,.5,.5))-.075;\n    // has to be a better way - I dont know it yet\n    float dots;\n    dots = length(abs(p)-vec3(ox,ox,cz))-dz;\n    dots = min(length(p2-vec3(cz,ox,ox))-dz,dots);\n    dots = min(length(p2-vec3(cz,-ox,-ox))-dz,dots);\n    dots = min(length(p3-vec3(ox,-cz,ox))-dz,dots);\n    dots = min(length(p3-vec3(ox,-cz,0))-dz,dots);\n    dots = min(length(p-vec3(cz,0,0))-dz,dots);\n    dots = min(length(p-vec3(0,cz,0))-dz,dots);\n    dots = min(length(p-vec3(0,0,cz))-dz,dots);\n    \n    base = max(base,-dots);\n    \n    return base;\n}\n\nvec2 map(vec3 pos, float sg)\n{\n    pos.y+=.85;\n    vec2 res = vec2(1e5,0.);\n    vec3 q = pos-vec3(0.,.75,0.);\n    vec3 p = pos-vec3(0.,.5,0.);\n\n    q.xz*=turn;\n\n    float amount = 8.;\n    float a = atan(q.z, q.x);\n    //@shane rep\n    float ia = floor(a/6.2831853*amount);\n    ia = (ia + .5)/amount*6.2831853;\n    //id and wave\n    float id = -mod(ia,.0);\n    float cy = sin( id*2. + (iTime * .5) * PI) * 0.5;\n    q.y +=cy;\n    q.xz *= rot(ia);\n    q.x -= 3.65;\n  \n    float hs = hash21(vec2(id,3.34));\n    int pk = int(floor(hs*10.));\n    //turn dice to random side\n    vec3 dp = q;\n    dp.yx*=turn;\n    dp.zx*=turn;\n    if(pk==1) dp.yz*=r90;\n    if(pk==2) dp.yz*=-r90;\n    if(pk==3) dp.xy*=r90;\n    if(pk==4) dp.xy*=-r90;\n    if(pk==5) dp.xy*=r180;\n\n    float d1 = dice(dp);\n    if(d1<res.x){\n        res = vec2(d1,2.);\n        hit=p;\n        g_hs=hs;\n    }\n\n    p.yz+=vec2(-1.5,.0);\n    p*=.35;\n    \n    float ld=getD(p.xz+vec2(.70,0.));\n    ld=abs(abs(ld)-.025)-.0075;\n    float td = opx(ld,p.y,.025);\n    \n    float li=getI(p.xz+vec2(.20,0.));\n    li=abs(abs(li)-.025)-.0075;\n    float ti = opx(li,p.y,.025);    \n\n    float lc=getC(p.xz-vec2(.30,0.));\n    lc=abs(abs(lc)-.025)-.0075;\n    float tc = opx(lc,p.y,.025); \n    \n    float le=getE(p.xz-vec2(.70,0.));\n    le=abs(abs(le)-.025)-.0075;\n    float te = opx(le,p.y,.025); \n    \n    td=min(ti,td);\n    td=min(tc,td);\n    td=min(te,td);\n    \n    if(td<res.x)\n    {\n        res=vec2(td,3.);\n    \thit=pos;\n    }\n    \n    if(sg>0.) glow += .0001/(.01+td*td);\n\n    float flr = pos.y+1.5;\n    if(flr<res.x)\n    {\n        res=vec2(flr,1.);\n    \thit=pos;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += ray.x * .75;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec4 FC = vec4(0.078,0.078,0.078,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,192, 1.);\n\n    hitPoint = hit;\n    s_hs=g_hs;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(3,8,-8);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h * .95;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        \n        diff *= shdw;\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n\n        if(m==1.){\n        vec3 clr =mix(vec3(0.000,0.502,0.016),vec3(0.043,0.529,0.596),uv.y+.5);\n            h=vec3(.15);\n            //big back visualizer\n            vec2 uv = (hitPoint.xz-vec2(0,0))*1.5;\n            vec2 f = fract(uv)-.5;\n            vec2 fid = floor(uv)+.5;\n            float ht = sampleFreq(abs(fid.x)*.05);\n            float ff = box(f,vec2(.45));\n            ff=smoothstep(.011,.01,ff);\n            \n            if(ht>abs(fid.y*.095)) h=mix(h,clr,ff);\n            \n            ref = vec3(.8)-fresnel;\n            C+=diff*h;\n        }\n        \n        if(m==2.){\n            vec3 hp = hitPoint;\n            h=s_hs>.5?vec3(0):vec3(1);\n            ref = vec3(.6)-fresnel;\n            C+=(diff*h)+spec;\n        }\n  \n        if(m==3.){\n            h=vec3(.95);\n            ref = vec3(.6)-fresnel;\n            C+=diff*h;\n        }\n\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    \n    } else {\n        C = FC.rgb;ref=vec3(.35);\n    }\n\n    C = mix(FC.rgb,C,  exp(-.000025*d*d*d));     \n    \n   // \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    r90=rot(90.*PI/180.);\n    r180=rot(180.*PI/180.);\n    mtime=floor(abs(T));\n    turn = rot(T*20.*PI/180.);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,6.25);\n    vec3 rd = normalize(vec3(uv,-1));\n    // camera //\n    mat2 rx =rot(-1.4);\n    mat2 ry =rot(-.2);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n    // camera //\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 3.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.000015*d*d*d));\n    }\n    \n    //glow \n    glow=clamp(glow,0.,.85);\n    vec3 clr =mix(vec3(0.024,0.878,0.733),vec3(0.337,0.839,0.000),uv.y+.5);\n    C = mix(C,clr,glow);\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    // gamma\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n", "image_inputs": [{"id": 32382, "src": "https://soundcloud.com/rxpapi/dice-game", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl23Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[811, 811, 841, 841, 889], [890, 890, 911, 911, 966], [967, 967, 985, 985, 1030], [1031, 1031, 1050, 1050, 1082], [1084, 1084, 1111, 1111, 1190], [1191, 1197, 1236, 1236, 1394], [1395, 1395, 1430, 1430, 1510], [1511, 1511, 1557, 1557, 1714], [1715, 1755, 1776, 1776, 1938], [1939, 1939, 1960, 1960, 2096], [2097, 2097, 2118, 2118, 2287], [2288, 2288, 2309, 2309, 2517], [2518, 2524, 2573, 2573, 2669], [2769, 2769, 2789, 2789, 3502], [3504, 3504, 3534, 3534, 5137], [5139, 5139, 5169, 5169, 5420], [5422, 5422, 5477, 5477, 5702], [5743, 5743, 5837, 5837, 7883], [7885, 7885, 7926, 7926, 8912]], "test": "untested"}
{"id": "stj3Rw", "name": "Polar react", "author": "firebreathz", "description": "Yet another audio visualizer. Tried to fake some depth with the light and reflection. Try reversing the band order. :)", "tags": ["2d", "visualizer"], "likes": 1, "viewed": 100, "published": 3, "date": "1623608794", "time_retrieved": "2024-07-30T19:16:10.631598", "image_code": "// Fork of \"Fork Fork Polar firebreath 967\" by firebreathz. https://shadertoy.com/view/NdBXRG\n// 2021-06-13 18:25:29\n\n#define time iTime\n#define PI 3.14159265359\n\n#define NUM_BANDS 40\n\n//#define REVERSED\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453)*2.0-1.0;\n}\n\nvec3 mixc(vec3 col1, vec3 col2, float v)\n{\n    v = clamp(v,0.0,1.0);\n    return col1+v*(col2-col1);\n}\n\nvec3 drawBands(vec2 uv)\n{\n  \tuv = 2.0*uv-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    uv = vec2(length(uv), atan(uv.y,uv.x));\n    \n    //uv.x-=0.25;\n    //uv.x = max(0.0,uv.x);\n    \n    uv.y -= PI*0.5;\n    vec2 uv2 = vec2(uv.x, uv.y*-1.0);\n    uv.y = mod(uv.y,PI*2.0);\n    uv2.y = mod(uv2.y,PI*2.0);\n    \n    vec3 col = vec3(0.0);\n    vec3 col2 = vec3(0.0);\n    \n    float nBands = float(NUM_BANDS);\n    float i = floor(uv.x*nBands);\n    float f = fract(uv.x*nBands);\n    float band = i/nBands;\n   \tfloat s;\n   \t\n    #ifdef REVERSED\n    band = 5.0-band;\n    #endif \n    \n    //cubic easing\n    band *= band*band; \n    \n    band = band*0.99;\n    band += 0.01;\n    \n    s = texture( iChannel0, vec2(band,0.08) ).x;  \n    \n    if(band<0.0||band>=1.0){\n        s = 0.0;\n    }\n    \n    /* Gradient colors and amount here */\n    const int nColors = 6;\n    vec3 colors[nColors];  \n    colors[0] = vec3(1.05,1.05,1.0);\n    colors[1] = vec3(1.205,1.00,1.00);\n    colors[2] = vec3(1.50,1.00,1.25);\n    colors[3] = vec3(1.90,0.75,3.25);\n \n    vec3 gradCol = colors[0];\n    float n = float(nColors)-1.0;\n    for(int i = 1; i < nColors; i++)\n    {\n\t\tgradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);\n    }\n    \n    float h = PI*1.5;\n    \n    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));\n    col *= gradCol;\n\n    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));\n    col2*= gradCol;\n    \n    col = mix(col,col2,step(0.0,uv.y-PI));\n\n    col *= smoothstep(0.025,0.875,f);\n    col *= smoothstep(0.875,0.625,f); \n    \n    col = clamp(col,0.0,1.0);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = vec2(uv.x, uv.y+0.1);\n\tvec3 col = vec3(0.0);\n    col += drawBands(p);//*smoothstep(1.0,0.5,uv.y);;\n    \n    vec3 ref = vec3(0.0);\n    vec2 eps = vec2(0.0025,-0.025);\n\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xx);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.xy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yy);\n    ref += drawBands(vec2(p.x,1.0-p.y)+eps.yx);\n    \n    ref += drawBands(vec2(p.x+eps.x,1.0-p.y));\n    ref += drawBands(vec2(p.x+eps.y,1.0-p.y));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.x));\n    ref += drawBands(vec2(p.x,1.0-p.y+eps.y));\n\n    ref /= 8.0;\n     \n    float colStep = length(smoothstep(1.0,0.1,col));\n    \n    vec3 cs1 = drawBands(vec2(3.5,0.51));\n    vec3 cs2 = drawBands(vec2(0.5,0.93));\n        \n    vec3 plCol = mix(cs1,cs2,length(p*1.0-1.0))*0.5*smoothstep(1.75,-0.5,length(p*0.0-1.0));\n    vec3 plColBg = vec3(0.02)*smoothstep(1.0,0.0,length(p*8.0-1.0));\n    vec3 pl = (plCol+plColBg)*smoothstep(0.5,0.65,5.0-uv.y);\n    \n    col += clamp(pl*(1.0-colStep),0.0,1.0);\n    \n    col += ref*smoothstep(0.125,1.6125,p.y); \n    \n    col = clamp(col, 0.0, 1.0);\n\n    float dither = noise3D(vec3(uv,time))*9.0/2226.0;\n    col += dither;\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 21, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stj3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 228, 228, 309], [311, 311, 353, 353, 412], [414, 414, 439, 439, 1976], [1978, 1978, 2035, 2035, 3290]], "test": "untested"}
{"id": "Nlj3zm", "name": "Looking Glass: Hyperdodecahedron", "author": "xjorma", "description": "Shader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy\n", "tags": ["tutorial", "glass", "4d", "dodecahedron", "tesseract", "looking", "hypercube", "r4", "lookingglass"], "likes": 0, "viewed": 261, "published": 3, "date": "1623606830", "time_retrieved": "2024-07-30T19:16:11.567097", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n//#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_DIST\t\t150.\nconst float PI = radians(180.);\n\n#define THICKNESS\t0.1\n#define LIGHTHEIGHT\t1.10\n#define SCALE\t\t1.7\n\n\nmat4 rot4d;\n\nvoid init4d()\n{\n\tfloat a1 = iTime * 0.5;\n\tfloat a2 = iTime * 0.5;\n\n    vec4 x = vec4(cos(a1), -sin(a1),     0.0,     0.0);\n    vec4 y = vec4(sin(a1),  cos(a1),     0.0,     0.0);\n    vec4 z = vec4(    0.0,      0.0, cos(a2), -sin(a2));\n    vec4 w = vec4(    0.0,      0.0, sin(a2),  cos(a2));\n    rot4d = mat4(x, y, z, w);\n}\n\nvec3 transform4d(vec4 p)\n{\n    p = rot4d * p;\n\tfloat a = LIGHTHEIGHT / (p.w - LIGHTHEIGHT);\n    return p.xyz * a * SCALE;    \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\nconst float k = 15.0;\n\nfloat map(vec3 p)\n{\n    p *= fromEuler(vec3(iTime * 0.12, iTime * 0.15, iTime * 0.136));\n    float sminAcc = 0.;\n    for( int i = 0; i < numVertices / 2; i++)\n    {\n        sminAcc += exp2(-k * sdCapsule(p, transform4d(vertices[i*2 + 0]), transform4d(vertices[i*2 + 1]), THICKNESS));\n    }\n\treturn -log2( sminAcc ) / k;\n}\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    return col*col;\n}\n\n\nfloat rayMarch(in vec3 ro, in vec3 rd)\n{\n  float t = 5.0;\n  for (int i = 0; i < 40; i++)\n  {\n    float h = map(ro + rd * t);\n    t += h;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.2 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float t = rayMarch(ro, rd);\n    vec3\tcol = vec3(0);\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);   \n        col = texture(iChannel0, reflect(rd, n)).rgb * pow(dot(rd, n), 2.);\n        col = mix(col, vec3(dot(col, vec3(1.0 / 3.0))), 0.5);\t\t// Desaturate\n        //col = applyFog(col, t / 2., vec3(0));\n    }\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n\tcol = pow(col, vec3(0.8));\n\tcol = contrast(col, 1.2);\n\tcol = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\tinit4d();\n    fragColor = vec4(Render(ro + vec3(0.0, 0.0, 9.0), rd), 1);\n}\n\n\n// Comment the original mainImage\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tinit4d();\n\n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI * 0.3;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - PI / 2.;\n        vec3 ro = 9. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        tot += Render(ro ,rd);\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n*/\n\n#define QAA\t2                                     \n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 9.5;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 9.5;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4\taccColor = vec4(0.);\n    for( int m = 0; m < QAA; m++ )\n    for( int n = 0; n < QAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m), float(n)) / float(QAA) - 0.5) / iResolution.xy                                                                                 ;\n\t\t\n\t\tvec2\tcoord = (fragCoord / iResolution.xy  + o) * vec2(quiltColumns,quiltRows);\n\t\tvec2\tfract = fract(coord);\n\t\tvec2\tfloor = floor(coord);\n\t\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\t\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\t\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\t\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\t\n\t\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\t\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\t\tvec3\tdirRay = normalize(screenPos - camPos);\n\t\tvec4\tcolor;\n\t\tmainVR(color, fragCoord, screenPos - vec3(0, 0, 9) - nearClip * dirRay, dirRay);\n\t\taccColor += clamp(color, 0.0, 1.0);\n\t}\n\tfragColor = accColor / float(QAA*QAA);\n}\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int numVertices = 160;\n\nconst vec4 vertices[160] = vec4[](\nvec4(0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(0.573492586613, -0.186338871717, -0.789344370365, 0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, 0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(0.573492586613, 0.789345026016, -0.186338797212, 0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(0.0, -0.603005826473, -0.78934442997, 0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(0.927930414677, -0.301502913237, -0.186338871717, 0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, 0.3), vec4(-0.573492586613, -0.186338871717, -0.789344370365, 0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, 0.3), vec4(0.0, -0.975683927536, -0.18633890152, 0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, 0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(-0.927930414677, -0.301502913237, -0.186338871717, 0.3), \nvec4(-0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(-0.573492586613, 0.789345026016, -0.186338797212, 0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(0.0, 0.975683867931, 0.18633890152, 0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, 0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, 0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, 0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, 0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, 0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, 0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, 0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, 0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, 0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(0.0, 0.975683867931, 0.18633890152, 0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, 0.3), \nvec4(0.0, 0.975683867931, 0.18633890152, 0.3), vec4(0.0, 0.603005826473, 0.78934442997, 0.3), \nvec4(-0.927930414677, 0.301502913237, 0.186338871717, 0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(-0.573492586613, -0.789345026016, 0.186338797212, 0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, 0.3), \nvec4(0.573492586613, -0.789345026016, 0.186338797212, 0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, 0.3), \nvec4(0.927930414677, 0.301502913237, 0.186338871717, 0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, 0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, 0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(0.573492586613, 0.186338871717, 0.789344370365, 0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, 0.3), \nvec4(0.354437857866, -0.48784211278, 0.78934431076, 0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, 0.3), \nvec4(-0.354437857866, -0.48784211278, 0.78934431076, 0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, 0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, -0.3), vec4(0.573492586613, -0.186338871717, -0.789344370365, -0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, -0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, -0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, -0.3), vec4(0.573492586613, 0.789345026016, -0.186338797212, -0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, -0.3), vec4(0.0, -0.603005826473, -0.78934442997, -0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, -0.3), vec4(0.927930414677, -0.301502913237, -0.186338871717, -0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, -0.3), vec4(-0.573492586613, -0.186338871717, -0.789344370365, -0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, -0.3), vec4(0.0, -0.975683927536, -0.18633890152, -0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, -0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, -0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, -0.3), vec4(-0.927930414677, -0.301502913237, -0.186338871717, -0.3), \nvec4(-0.354437857866, 0.48784211278, -0.78934431076, -0.3), vec4(-0.573492586613, 0.789345026016, -0.186338797212, -0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, -0.3), vec4(0.0, 0.975683867931, 0.18633890152, -0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, -0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, -0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, -0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, -0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, -0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, -0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, -0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, -0.3), vec4(0.0, 0.975683867931, 0.18633890152, -0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, -0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(0.0, 0.975683867931, 0.18633890152, -0.3), vec4(0.0, 0.603005826473, 0.78934442997, -0.3), \nvec4(-0.927930414677, 0.301502913237, 0.186338871717, -0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(-0.573492586613, -0.789345026016, 0.186338797212, -0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(0.573492586613, -0.789345026016, 0.186338797212, -0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(0.927930414677, 0.301502913237, 0.186338871717, -0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, -0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, -0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.573492586613, 0.186338871717, 0.789344370365, -0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(0.354437857866, -0.48784211278, 0.78934431076, -0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(-0.354437857866, -0.48784211278, 0.78934431076, -0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(0.354437857866, 0.48784211278, -0.78934431076, -0.3), \nvec4(0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(0.573492586613, -0.186338871717, -0.789344370365, -0.3), \nvec4(0.0, -0.603005826473, -0.78934442997, 0.3), vec4(0.0, -0.603005826473, -0.78934442997, -0.3), \nvec4(-0.573492586613, -0.186338871717, -0.789344370365, 0.3), vec4(-0.573492586613, -0.186338871717, -0.789344370365, -0.3), \nvec4(-0.354437857866, 0.48784211278, -0.78934431076, 0.3), vec4(-0.354437857866, 0.48784211278, -0.78934431076, -0.3), \nvec4(-0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(-0.573492586613, 0.789345026016, -0.186338797212, -0.3), \nvec4(-0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(-0.927930414677, -0.301502913237, -0.186338871717, -0.3), \nvec4(0.0, -0.975683927536, -0.18633890152, 0.3), vec4(0.0, -0.975683927536, -0.18633890152, -0.3), \nvec4(0.927930414677, -0.301502913237, -0.186338871717, 0.3), vec4(0.927930414677, -0.301502913237, -0.186338871717, -0.3), \nvec4(0.573492586613, 0.789345026016, -0.186338797212, 0.3), vec4(0.573492586613, 0.789345026016, -0.186338797212, -0.3), \nvec4(0.0, 0.975683867931, 0.18633890152, 0.3), vec4(0.0, 0.975683867931, 0.18633890152, -0.3), \nvec4(-0.927930414677, 0.301502913237, 0.186338871717, 0.3), vec4(-0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(-0.573492586613, -0.789345026016, 0.186338797212, 0.3), vec4(-0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.573492586613, -0.789345026016, 0.186338797212, 0.3), vec4(0.573492586613, -0.789345026016, 0.186338797212, -0.3), \nvec4(0.927930414677, 0.301502913237, 0.186338871717, 0.3), vec4(0.927930414677, 0.301502913237, 0.186338871717, -0.3), \nvec4(0.0, 0.603005826473, 0.78934442997, 0.3), vec4(0.0, 0.603005826473, 0.78934442997, -0.3), \nvec4(0.573492586613, 0.186338871717, 0.789344370365, 0.3), vec4(0.573492586613, 0.186338871717, 0.789344370365, -0.3), \nvec4(0.354437857866, -0.48784211278, 0.78934431076, 0.3), vec4(0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(-0.354437857866, -0.48784211278, 0.78934431076, 0.3), vec4(-0.354437857866, -0.48784211278, 0.78934431076, -0.3), \nvec4(-0.573492586613, 0.186338871717, 0.789344370365, 0.3), vec4(-0.573492586613, 0.186338871717, 0.789344370365, -0.3) );\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlj3zm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[324, 324, 339, 339, 648], [650, 650, 676, 676, 777], [779, 779, 831, 831, 952], [954, 954, 980, 980, 1332], [1357, 1357, 1376, 1376, 1678], [1680, 1680, 1707, 1707, 1772], [1775, 1775, 1815, 1815, 1979], [2536, 2536, 2591, 2591, 2687], [2690, 2690, 2727, 2727, 3100], [3102, 3102, 3145, 3145, 3203], [3205, 3205, 3249, 3249, 3348], [3350, 3350, 3392, 3392, 3492], [3495, 3495, 3537, 3537, 3701], [3703, 3703, 3781, 3781, 3857], [5373, 5373, 5430, 5430, 6501]], "test": "untested"}
{"id": "NssSW2", "name": "Importance sampling test", "author": "mdb", "description": "test of importance sampling of any hdr environnement map", "tags": ["pathtracing", "importancesampling"], "likes": 3, "viewed": 388, "published": 3, "date": "1623587776", "time_retrieved": "2024-07-30T19:16:12.582382", "image_code": "#define noiseFilter\n#define Kernel 6\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n#ifdef noiseFilter\n    float sigma = 3.0;\n    float kernel[Kernel*2+1];\n    for (int j = 0; j <= Kernel; ++j)\n    {\n        kernel[Kernel+j] = kernel[Kernel-j] = normpdf(float(j), sigma);\n    }\n\n    vec4 data = texture(iChannel1, uv);\n    vec3 n0 = data.xyz;\n    float depth0 = data.w;\n    float z = 0.0;\n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    vec3 p0 = camPos + depth0 * rd;\n    \n    for(int i = - Kernel; i <= Kernel; i++){\n        for(int j = - Kernel; j <= Kernel; j++){\n            vec2 uv2 =  uv + vec2(i, j)/iResolution.xy;\n            data = texture(iChannel1,uv2);\n            vec3 n = data.xyz;\n            float depth = data.w;\n            \n            rd = normalize(dir0 + right*uv.x + up*uv.y);\n            vec3 p = camPos + depth * rd;\n            //same normal, on the same plane and not to far away\n            if (dot(n, n0)>0.95 \n                && abs(dot(n0, p - p0)) < 0.09\n                && dot(p-p0, p-p0)<max(0.02, 0.02*depth0)){\n                \n                col += kernel[Kernel+j]*kernel[Kernel+i]*texture(iChannel0, uv2).rgb;\n                z += kernel[Kernel+j]*kernel[Kernel+i];\n            }\n        }\n     }\n     col /= z;\n     if (depth0 == -1.0) col = texture(iChannel0, uv).rgb;\n    \n    col = 1.0-exp(-0.5*col); \n    \n#else\n    col = texture(iChannel0, uv).xyz;\n    \n    col = 1.0-exp(-0.5*col); \n    col = pow(col, vec3(0.7)); \n#endif\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//where all the stuff append\n\n#define MAXDEPTH 8\n\n\nstruct Mat{vec3 c, e;}; //color, emission\n\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x) + uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nvec4 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z);\n    if(dot(n, v) < 0.0) return vec4(-v, 1.0);\n    return vec4(v, 1.0);\n}\n\nvec4 newDirImpSamp(vec3 n){\n     //dichotomie\n    float total = texture(iChannel2, vec2(1.0, 1.0/float(downSample))).x*2.0;\n    float goal = random();\n    float y, val;\n    vec2 data;\n    float Min = 0.0;\n    float Max = 1.0;\n    for(int i = 0; i < 1024; i++){\n      float Mid = 0.5*(Min+Max);\n      vec2 data = texture(iChannel2, vec2(1.0, Mid/float(downSample))).xy;\n      val = data.x/total;\n      if(abs(val - goal) < 0.008){y = Mid; break;}\n      (val < goal) ? Min = Mid : Max = Mid;\n      \n    }\n    \n    float weightY = data.y/total;\n    \n    //ont the x-axis at position y\n    data = texture(iChannel2, vec2(1.0, y)/float(downSample)).xy;\n    total = data.x*2.0;\n    goal = random();\n    float x;\n    Min = 0.0;\n    Max = 1.0;\n    for(int i = 0; i < 1024; i++){\n      float Mid = 0.5*(Min+Max);\n      data = texture(iChannel2, vec2(Mid, y)/float(downSample)).xy;\n      val = data.x/total;\n      if(abs(val - goal) < 0.008){x = Mid; break;}\n      (val < goal) ? Min = Mid : Max = Mid;\n    }\n    float weightX = data.y/total;\n    \n    \n    float teta = x*2.0*PI;\n    float z = y*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), z, sqrt(1.0-z*z)*sin(teta));\n    if(dot(v, n) < 0.0)return newDir(n);\n    \n    float weightF = float(downSample*downSample)/(iResolution.x*iResolution.y);\n    float weightG = weightX*weightY + 0.0001;\n    float weight = weightF / weightG;\n    return vec4(v, weight);\n\n}\n\nfloat intersect(vec3 ro, vec3 rd, out Mat obj, out vec3 n){\n\n    float t = 1e7;\n    obj = Mat(vec3(0.9), vec3(0.0));\n    for(int i = 0; i < NUMBOX; i++){\n        Box B = boxs[i];\n        float t2 = box(ro, rd, B).x;\n        \n        if( t2 > 0.0 && t2 < t){\n            t = t2;\n            n = normal(ro + t*rd, B);\n            \n            if(i==3)obj = Mat(vec3(0.0, 0.9, 0.0), vec3(0.0));\n            if(i==9)obj = Mat(vec3(0.9, 0.0, 0.0), vec3(0.0));\n            if(i==11)obj = Mat(vec3(0.9, 0.9, 0.1), vec3(0.0));\n            if(i!=3 && i!=9 && i!= 11)obj = Mat(vec3(0.9), vec3(0.0));\n        }\n        \n        \n    }\n    if(t > 1e6){ obj = Mat(vec3(0.0), texture(iChannel1, rd).xyz);return -1.0;}\n    return t;\n}\n\n\n\nvec3 march(vec3 ro, vec3 rd){\n\tvec3 col = vec3(0.0);\n\tvec3 mask = vec3(1.0);\n    vec3 n;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tMat obj;\n        float t = intersect(ro, rd, obj, n);\n        \n\t\tro = ro + t * rd;\n#ifdef ImportanceSampling\n        vec4 new = newDirImpSamp(n);\n#else\n\t\tvec4 new = newDir(n);\n#endif\n        rd = new.xyz;\n\t\tcol += mask * obj.e * new.w;\n\t\tmask *= obj.c * new.w;\n        \n        if(t<=0.0)break; // dont intersect anything\n        if (dot(mask, mask)<0.000001)break; // have absorbed to much light that the ray is useless\n\n\t}\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initBoxs();\n    initRandomGenerator(fragCoord);\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    \n    vec3 col = march(camPos, rd);\n    \n    //mix with previous frames\n    vec3 last = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    float weight = 1.0/float(max(0, iFrame - frameDelay - 5) + 1);\n    col = mix(last, col, weight);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "\n\n//the nevironnement map with just a sun and a blue sky\n//you can add as many light here with any shape\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3, 0.7, 1.0)*4.9; //sky color\n    \n    vec3 sunColor = vec3(0.9764, 0.8058, 0.641);\n    vec3 sunDir = normalize(vec3(-0.2, 0.2, 1.0));\n    if(dot(sunDir, rd) > 0.999) col = sunColor*vec3(700.0); //small but powerful sun\n    col += sunColor*50.0*pow(0.5 + 0.5*dot(sunDir, rd), 200.0);\n    col += sunColor*pow(0.5 + 0.5*dot(sunDir, rd), 8.0);\n    \n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy/float(downSample);\n    vec3 col = vec3(0.5);\n    \n    // if all the work is already done\n    if(iFrame - frameDelay > 5){\n        col = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    //get the values from the cube map\n    if(iFrame - frameDelay < 4 && all(lessThanEqual(fragCoord, res))){\n        vec2 uv = fragCoord/res;\n\n        float teta = uv.x*2.0*PI;\n        float z = uv.y*2.0-1.0;\n        vec3 rd = vec3(sqrt(1.0-z*z)*cos(teta), z, sqrt(1.0-z*z)*sin(teta));\n        col = textureLod(iChannel0, rd, log2(float(downSample))).rgb;\n        col = vec3((col.r + col.g + col.b)/3.0);\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    //sum the row values\n    if(iFrame - frameDelay == 4){  // initialisation with delay if some frames are skip\n        if(all(lessThanEqual(fragCoord, res))){\n            vec2 invRes = 1.0/res;\n            vec2 uv = fragCoord/res;\n            col = texture(iChannel1, uv/float(downSample)).xyz;\n            col.x = 0.0;\n            for(int i = 0; i < 8000; i++){\n                if(uv.x < 0.0) break;\n                col.x += texture(iChannel1, uv/float(downSample)).x;\n                uv.x -= invRes.x;\n            }  \n        }\n        if(fragCoord.y <= res.y && fragCoord.x > iResolution.x - 3.0){\n            vec2 invRes = 1.0/res;\n            vec2 uv = vec2(1.0, fragCoord.y/res.y);\n            for(int i = 0; i < 8000; i++){\n                if(uv.x < 0.0) break;\n                col += texture(iChannel1, uv/float(downSample)).xyz;\n                uv.x -= invRes.x;\n            }  \n            \n        }\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    //sum the values of the final column\n    if(iFrame - frameDelay == 5 && fragCoord.y <= res.y && fragCoord.x > iResolution.x - 3.0){\n        vec2 invRes = 1.0/res;\n        vec2 uv = vec2(1.0, fragCoord.y/res.y);\n        col = texture(iChannel1, uv/vec2(1.0, float(downSample))).xyz;\n        col.x = 0.0;\n        for(int i = 0; i < 8000; i++){\n            if(uv.y < 0.0) break;\n            col.x += texture(iChannel1, uv/vec2(1.0, float(downSample))).x;\n            uv.y -= invRes.y;\n        }\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    col = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n\n#define downSample 2   // error due to float numbers; better with 2, and 6 if you go full screen\n#define frameDelay 0\n\n//comment here to try without importance sampling\n#define ImportanceSampling\n\n\n#define NUMBOX 14\nstruct Box{vec3 up, down;};\nBox[NUMBOX] boxs;\n\n\nconst vec3 camPos = vec3(0.5, 1.0, -1.8)*0.8;\nconst vec3 target = vec3(0.0, 0.0, 0.0);\n\n\n// pseudo random numbers////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvoid initBoxs(){\n    seed = 34267554u;\n    for(int idx = 0; idx < NUMBOX - 1; idx++){\n        vec3 a = vec3(random(), random(), random());\n        vec3 b = vec3(random(), random(), random());\n        a = 2.0*a - 1.0;\n        b = 2.0*b - 1.0;\n        vec3 s = vec3(1.1);\n        a *= s; b *= s;\n        boxs[idx] = Box(max(a, b), min(a, b));\n    }\n    boxs[NUMBOX - 1] = Box(vec3(10.0, -0.95, 10.0), vec3(-10.0, -1.0, -10.0));\n}\n/////////////////////////////////////////////////////////////////////////\n\nvec2 box(vec3 ro, vec3 rd, Box AABB){\n        vec3 down = AABB.down;\n        vec3 up = AABB.up;\n        \n        vec3 dirfrac = 1.0 / rd;\n        float t1 = (down.x - ro.x)*dirfrac.x;\n        float t2 = (up.x - ro.x)*dirfrac.x;\n        float t3 = (down.y - ro.y)*dirfrac.y;\n        float t4 = (up.y - ro.y)*dirfrac.y;\n        float t5 = (down.z - ro.z)*dirfrac.z;\n        float t6 = (up.z - ro.z)*dirfrac.z;\n\n        float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n        float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n        if (tmax < 0.0) return vec2(-1.0);\n\n        // if tmin > tmax, ray doesn't intersect AABB\n        if (tmin > tmax) return vec2(-1.0);\n\n        return vec2(tmin, tmax);\n}\n\nvec3 normal(vec3 pos, Box b){\n    pos -= 0.5*(b.up + b.down);\n    pos /= 0.5*abs(b.up - b.down);\n    vec3 n = vec3(0.0);\n    if(abs(pos.x)>0.995){n.x = pos.x;}\n    if(abs(pos.y)>0.995){n.y = pos.y;}\n    if(abs(pos.z)>0.995){n.z = pos.z;}\n    n = normalize(n);\n    return n;\n}\n\n", "buffer_c_code": "//get normal information and depth info\n\nfloat intersect(vec3 ro, vec3 rd, out vec3 n){\n\n    float t = 1e7;\n    for(int i = 0; i < NUMBOX; i++){\n        Box B = boxs[i];\n        float t2 = box(ro, rd, B).x;\n        \n        if( t2 > 0.0 && t2 < t){\n            t = t2;\n            n = normal(ro + t*rd, B);\n        }\n        \n        \n    }\n    if(t > 1e6) return -1.0;\n    return t;\n}\n\n\n\nvec4 march(vec3 ro, vec3 rd){\n    vec3 n;\n    float t = intersect(ro, rd, n);\n    return vec4(n, t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame - frameDelay > 3){\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        return;\n    }\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initBoxs();\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    \n    fragColor = march(camPos, rd);\n    \n    \n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssSW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 81, 81, 134], [136, 136, 193, 193, 1829]], "test": "untested"}
{"id": "ft23Rw", "name": "Phong Shading Model w/ RayMarch", "author": "muio", "description": "A bare-bones implementation of phong shadeing model using ray-marching and SDFs.", "tags": ["raymarching", "phong", "sdf"], "likes": 2, "viewed": 167, "published": 3, "date": "1623584693", "time_retrieved": "2024-07-30T19:16:13.337364", "image_code": "/// Possible things one could add to this:\n/// * Rays should attenuate the further away they get from the camera.\n/// * \n\n// Colors should be in standard rgb format: 0. < rgb < 1.\n\n#define MAX_MARCH_STEPS (1<<7)\n#define MAX_MARCH_DIST 100.\n#define SURF_DIST_MARCH .01\n#define EULER_APPROX_OFFSET .003\n\nstruct Sphere {\n    vec3 o;\n    float r;\n};\n\nstruct PhongMaterial {\n    vec3 albedo;\n    float ks, kd, ka, alpha;\n};\n\nstruct PointLight {\n    vec3 pos;\n    vec3 col;\n};\n\n\nconst Sphere s = Sphere(vec3(0, 1, 6), 1.);\nconst PointLight light = PointLight(vec3(0, 5, 6),\n                                    vec3(1.000,0.878,0.878));\nconst PhongMaterial sphereMaterial = PhongMaterial(vec3(0.94,1.,0.12), \n                                                   .3, .64, .3, 16.);\nconst PhongMaterial globalMaterial = PhongMaterial(vec3(.4, .9, 1.), \n                                                   .1, .7, .2, 4.);\nconst PhongMaterial mats[2] = PhongMaterial[](globalMaterial, \n                                              sphereMaterial);\n                                                   \nconst vec3 rayOrigin = vec3(0, 1, 1);\n\n\n\nfloat SphereSDF(in vec3 p, in Sphere s) {\n    return length(p - s.o) - s.r;\n}\n\nfloat SceneSDF(out int hitObject, in vec3 p) { // sdf for the scene.\n    float sphereDist = SphereSDF(p, s);\n    float planeDist = p.y; // ground\n    \n    float d = min(planeDist, sphereDist);\n    hitObject = sphereDist == d ? 1 : 0;\n    return d;\n}\n\nfloat RayMarch(out int hitObject, in vec3 ro, in vec3 rd) {\n    float dO = 0.; // Distance I've marched from origin\n\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = SceneSDF(hitObject, p);\n        dO += dS;  // Safe distance to march with\n        if (dO > MAX_MARCH_DIST || // Far-plane clipping\n            dS < SURF_DIST_MARCH)  // Did we hit anything?\n            break;\n    }\n\n    return dO;\n}\n\n/*\nvec3 GetNormalEulerTwoSided(in vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    int _;\n    \n    vec3 left = vec3(SceneSDF(_, p),\n                     SceneSDF(_, p - e.yxy),\n                     SceneSDF(_, p - e.yyx)),\n        right = vec3(SceneSDF(_, p + e.xyy),\n                     SceneSDF(_, p + e.yxy),\n                     SceneSDF(_, p + e.yyx));\n        \n    vec3 n = normalize(-left + right);\n    return n;\n}\n*/\n\nvec3 GetNormalEulerOneSided(in vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    int _;\n    vec3 center = vec3(SceneSDF(_, p)),\n          right = vec3(SceneSDF(_, p + e.xyy),\n                       SceneSDF(_, p + e.yxy),\n                       SceneSDF(_, p + e.yyx));\n        \n    vec3 n = normalize(right - center);\n    return n;\n}\n\n#define GetNormal GetNormalEulerOneSided\n//#define GetNormal GetNormalEulerTwoSided\n\n\n/*\n  p  -> position of point to shade\n  ro -> ray origin (position of the camera)\n*/\nvec3 PhongIllumination(in vec3 p, in vec3 ro, in int hitObject) {\n    vec3 lightPosOffset = vec3(sin(2. * iTime), 0, cos(2. * iTime)) * 3.;\n    vec3 lightPos = light.pos + lightPosOffset;\n    // PhongMaterial mat = (hitObject == 1) ? sphereMaterial : globalMaterial; // bugs are great!\n    \n    vec3 l = normalize(lightPos - p); // light vector\n    vec3 n = GetNormal(p); // get normal of p\n    vec3 r = reflect(l, n);\n    vec3 v = normalize(p - ro);\n    \n    float dif  = clamp(dot(l, n), 0., 1.);\n    float spec = clamp(dot(v, r), 0., 1.);\n    \n    // shadow stuff\n    vec3 pOffset = n * SURF_DIST_MARCH * 1.2; // move the point above a little\n    int _;\n    float d = RayMarch(_, p + pOffset, l);\n    if (d < length(lightPos - p)) { // If true then we've shaded a point on some object before, \n                                    // so shade the currnet point as shodow.\n        dif *= .3; // no half-shadow because the light source is a point.    \n        spec = 0.; // shadows don't have specular component, I think.\n    }\n    \n    // Acutal Phong stuff\n    vec3 ambientDiffuse = light.col * mats[hitObject].albedo;\n    vec3 light1DiffuseComponent = dif * light.col;\n    vec3 light1SpecularComponent = vec3(pow(spec, mats[hitObject].alpha));\n    \n    vec3 col = mats[hitObject].ka * ambientDiffuse + \n               mats[hitObject].kd * light1DiffuseComponent + \n               mats[hitObject].ks * light1SpecularComponent;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5 ) / iResolution.y; // center around origin\n    \n    // simplest camera\n    vec3 ro = rayOrigin;\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    \n    // RayMarching stuff\n    int object;\n    float d = RayMarch(object, ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 col = PhongIllumination(p, ro, object);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft23Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1129, 1129, 1170, 1170, 1206], [1208, 1208, 1254, 1276, 1457], [1459, 1459, 1518, 1518, 1906], [2392, 2392, 2432, 2481, 2782], [2870, 2955, 3020, 3020, 4406], [4409, 4409, 4466, 4466, 4854]], "test": "untested"}
{"id": "flf3Rr", "name": "Amogus", "author": "manu210404", "description": "shader got the sussy drip\nthe code very sussy tho (dont read ples)", "tags": ["2d", "sound", "sdf", "drip", "amongus", "amogus"], "likes": 31, "viewed": 908, "published": 3, "date": "1623581231", "time_retrieved": "2024-07-30T19:16:14.103316", "image_code": "float msign(in float x) { return (x<0.0)?-1.0:1.0; }\n// sdEllipse by iq - https://www.shadertoy.com/view/4sS3zz\nfloat sd_ellipse( vec2 p, in vec2 ab )\n{\n  //if( ab.x==ab.y ) return length(p)-ab.x;\n\n\n\tp = abs( p ); \n    if( p.x>p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2+n2-1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float d = c3 + m2*n2;\n    float q = d  + m2*n2;\n    float g = m  + m *n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h) + 2.0;\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt( m2-c*(s+t) );\n        float ry = sqrt( m2-c*(s-t) );\n        co = ry + sign(l)*rx + abs(g)/(rx*ry);\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt(d);\n        float s = msign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float t = msign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -(s+t) - c*4.0 + 2.0*m2;\n        float ry =  (s-t)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = ry/sqrt(rm-rx) + 2.0*g/rm;\n    }\n    co = (co-m)/2.0;\n\n    float si = sqrt( max(1.0-co*co,0.0) );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * msign(p.y-r.y);\n}\n\n\n// opSmoothUnion and opSmoothSubtraction by iq - https://www.shadertoy.com/view/lt3BW2\nfloat s_min( float d1, float d2, float k ) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat s_sub( float d1, float d2, float k ) {\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat edge(float a, vec2 p) {\n    p *= rot(a);\n    return p.y;\n}\n\nvec4 blend(vec4 a, vec4 b) {\n    return vec4(a.w*a.xyz + (1.-a.w)*b.xyz, max(a.w, b.w));\n}\n\nfloat sd_amogus(vec2 p) {\n    \n    // who the heck would use bezier curves for that? not me.\n    \n    float b = sd_ellipse(p, vec2(.5,1.66));   // body\n    b = s_sub(edge(PI*0.97, p)+0.75, b, 0.4); // carving away some edges\n    b = s_sub(edge(PI*0.6, p)+0.42, b, 0.1);\n    b = s_sub(edge(PI*0.54, p)+0.37, b, 0.1);\n    b = s_sub(edge(PI*0.07, p)+0.55, b, 0.1);\n    \n    float r = b;\n    \n    float l = sd_ellipse(p-vec2(-0.02,-0.4),vec2(.21,0.2625)); // seperation between the legs, starting with an ellipse\n    l = s_sub(edge(PI, p) - 0.2, l, 0.1);                      // again, carvin away some parts of the ellipse\n    l = s_sub(edge(PI*0.4, p)+0.32, l, 0.1);\n    \n    r = s_sub(l, r, 0.1); // subtracting that modified ellipse from the body\n    \n    float f1 = sd_ellipse((p*rot(PI*0.1)-vec2(-0.3,-0.53)),vec2(1./0.6*0.14,1.0*0.14)); // left foot, again an ellipse\n    f1 = s_sub(edge(PI*1.09, p)-0.45, f1, 0.1);                                         // make the footh a bit steeper in the front\n    \n    r = s_min(f1, r, 0.07);\n    \n    float f2 = sd_ellipse((p-vec2(0.22,-0.6)),vec2(1./0.52*0.14,1.0*0.14)); // right foot\n    f2 = s_sub(edge(PI*1.1, p)-0.35, f2, 0.2);                    // flatten the foot in the front\n    //f2 = s_sub(edge(PI*0.1, p)+0.75, f2, 0.2);\n    \n    r = s_min(f2, r, 0.05);\n    r = s_sub(edge(PI*-0.05, p)+0.75, r, 0.2); // flatten the underside of the right foot\n    \n    // maybe i should have used bezier curves\n    return r;\n}\n\nvec4 visor(vec2 p) {\n    float l = sd_ellipse(p-vec2(0.0,0.45), vec2(0.4,0.1));\n    l = s_sub(edge(PI*0.45, p)+0.1, l, 0.1);\n    l = s_sub(edge(PI*1.48, p)+0.35, l, 0.1);\n    \n    vec4 e1 = vec4(vec3(0.467,0.549,0.733), smoothstep(0.0,0.025,sd_ellipse(p-vec2(0.1,0.47), vec2(0.2,0.05))));\n    vec4 e2 = vec4(vec3(0.686,0.776,0.871), smoothstep(0.0,0.025,sd_ellipse(p-vec2(0.1,0.47), vec2(0.1,0.025))));\n    vec4 e3 = vec4(vec3(0.910,0.929,0.969), smoothstep(0.0,0.025,sd_ellipse(p-vec2(0.1,0.47), vec2(0.05,0.0125))));\n    vec4 c = blend(e1, e2);\n    c = blend(c, e3);\n\n    \n    float area = smoothstep(0.03,0.0,l);\n    float outline = smoothstep(0.01,0.033,abs(l));\n    \n    return vec4(vec3(outline)*c.xyz, area);\n    //return c;\n}\n\n\nvec4 amogus(vec2 p) {\n    vec2 e = vec2(0.01,0.0);\n    vec2 d = vec2(sd_amogus(p+e.xy)-sd_amogus(p-e.xy), sd_amogus(p+e.yx)-sd_amogus(p-e.yx))/e.x*0.5;\n    float l = sd_amogus(p);\n    float nl = l/length(d);\n    \n    \n    float area = smoothstep(0.03,0.0,nl);\n    float outline = smoothstep(0.01,0.033,abs(nl));\n    \n    \n    //vec3 col = d_to_color(l);\n    vec4 col = vec4(outline*vec3(0.898,0.933,1.000), area);\n\n    vec4 vis = visor(p);\n    \n    col = blend(vis, col);\n    return col;\n    \n}\n\nfloat sdChecker(in vec2 p) {\n    p = fract(p*0.5-0.5)*2.-1.;\n    p = abs(p);\n    float adj = max(abs(p.x-1.0)-0.5,abs(p.y-1.0)-0.5);\n    return min(max(p.x-0.5,p.y-0.5), adj);\n}\n\nvec3 d_to_color(float d) {\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\treturn mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n}\n\nvec2 transform(vec2 p) {\n    float t = (iTime-1.0) * BPS * 0.5; // enter bps here\n    float d = smoothstep(6.0,7.0,t); // intensity of the distortion/movement\n    \n    vec2 offs = p+vec2(sin(t*PI*2.), cos(t*PI))*0.2*(0.5 + 0.5 * d);\n    offs *= rot(sin(t*PI)*PI*0.1);\n    p *= (1.-pow(abs(sin(t*PI*2.)), 10.))*(0.25 + 0.25*d)-pow(length(p), 1.)*(0.5+0.5*d)*0.25;\n    p += offs;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    uv = transform(uv);\n    \n    vec4 col = amogus(uv);\n    vec4 bg = vec4(vec3(0.910,0.129,0.404),1.0);\n    bg.rgb *= 0.75 + 0.25 * smoothstep(0.0,0.05,sdChecker(uv*2.));\n    col = blend(col, bg);\n    \n    vec2 nuv = fragCoord/iResolution.xy*2.-1.;\n    col *= 0.6+0.4*(1.-nuv.x*nuv.x)*(1.-nuv.y*nuv.y);\n    \n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "sound_code": "const float G2  = 98.00;\nconst float C3  = 130.81;\nconst float BF4 = 466.16;\nconst float C5  = 523.25;\nconst float D5  = 587.33;\nconst float EF5 = 622.25;\nconst float F5  = 698.46;\nconst float GF5 = 739.99;\n\nfloat square_wave(float f, float x) {\n    return floor(2.*floor(f*x)-floor(2.*f*x)+1.);\n}\n\nfloat triangle_wave(float f, float x) {\n    return abs(fract(f*x)*2.-1.)*2.-1.;\n}\n\nfloat sine_wave(float f, float x) {\n    return sin(6.2831*f*x);\n}\n\nfloat amog_note(float f, float x) {\n    //float n = noise(x)*smoothstep(0.1,0.,x)*smoothstep(0.0,0.01,x)*0.1;\n    float amp = smoothstep(0.0,0.01,x);\n    amp *= sine_wave(7., x)*0.5+0.5;\n    amp *= 0.25+0.75*smoothstep(0.12,0.1,x);\n    amp *= smoothstep(0.3, 0.2, x);\n    float w = sine_wave(f, x)*0.875+triangle_wave(f*2.,x)*0.125;\n    return w * amp;\n}\n\nfloat amog_bass(float f, float x) {\n    float amp = smoothstep(0.3,0.2, x);\n    amp *= smoothstep(-0.00,0.01,x);\n    amp *= 0.5 + 0.5 * smoothstep(0.1, 0.0, x);\n    return (square_wave(f, x) + sine_wave(f*.5, x))*amp*0.5;\n}\n\nfloat soft_bass(float f, float x) {\n    float amp = smoothstep(0.3,0.2, x);\n    amp *= smoothstep(-0.00,0.01,x);\n    amp *= 0.5 + 0.5 * smoothstep(0.1, 0.0, x);\n    return (sine_wave(f*.5, x))*amp*0.5;\n}\n\nfloat clap(float x) {\n    float amp = smoothstep(0.2,0.1,x);\n    amp *= smoothstep(0.0,0.01,x);\n    amp *= fract(x*20.);\n    return (FBM21(x*50.).x*0.5+noise(x*200.))*amp*0.25;\n}\n\nfloat hihat(float x) {\n    float amp = smoothstep(0.2,0.15, x);\n    amp *= smoothstep(0.0,0.02, x);\n    amp *= 0.25 + 0.75 * smoothstep(0.1,0.05, x);\n    return (noise((x-.25)*(x-.25)*1000.)*0.5 + FBM21(x).x)*amp*0.5;\n}\n\nvec2 amog_drums(float t) {\n    float eigh = fract(t*BPS*4.)/BPS;\n    float trip = fract(t*BPS*3.)/BPS;\n    float sext = fract(t*BPS*12.)/BPS*0.5;\n    float fast = fract(t*BPS*18.)/BPS*0.5;\n    \n    float x = t*BPS-16.;\n    float amp = 1.;\n    amp *= 0.5 + 0.5 * smoothstep(0.125, 0.0, fract(x/2.));\n    if(x > 0.) {x = fract(x*0.125)*8.;\n        if(x > .5 && x < 1.) {amp *= smoothstep(1., 0.5, x); x = fast;} else \n        if(x > 2.5 && x < 2.75) {amp *= smoothstep(2.75, 2.5, x)*2.; x = fast;} else \n        if(x > 2.75 && x < 3.) {amp *= smoothstep(3., 2.75, x)*2.; x = fast;} else \n        if(x > 7. && x < 7.25) {x = sext;} else \n        if(x > 8. && x < 9.) {x = trip;} else \n        {x = eigh;}\n    }\n    float h = hihat(x) * amp;\n    \n    x = t*BPS-16.;\n    amp = 0.5;\n    if(x > 0.) {x = fract(x*0.25)*4.;\n        if(x > .25 && x < .75) {x -= 0.25; x *= 2.;} else \n        if(x > 1. && x < 1.5) {x -= 1.; amp = 1.;} else \n        if(x > 1.75 && x < 2.25) {x -= 1.75; x *= 2.;} else \n        if(x > 2.25 && x < 2.75) {x -= 2.25; x *= 2.;} else \n        if(x > 3. && x < 3.5) {x -= 3.; amp = 1.;}\n    }\n    float c = clap(x) * amp;\n    return vec2(\n            h*0.5 + c\n        );\n}\n\nvec2 amog_melody_synth(float t) {\n    t = fract(t/16.*BPS)*16.*RBPS;\n    return vec2(\n         amog_note(C5, t-1.*RBPS)\n        +amog_note(EF5, t-1.5*RBPS)\n        +amog_note(F5, t-2.*RBPS)\n        +amog_note(GF5, t-2.5*RBPS)\n        +amog_note(F5, t-3.*RBPS)\n        +amog_note(EF5, t-3.5*RBPS)\n        +amog_note(C5, t-4.*RBPS)\n        +amog_note(BF4, t-5.5*RBPS)\n        +amog_note(D5, t-5.75*RBPS)\n        +amog_note(C5, t-6.*RBPS)\n        \n        +amog_note(C5, t-9.*RBPS)\n        +amog_note(EF5, t-9.5*RBPS)\n        +amog_note(F5, t-10.*RBPS)\n        +amog_note(GF5, t-10.5*RBPS)\n        +amog_note(F5, t-11.*RBPS)\n        +amog_note(EF5, t-11.5*RBPS)\n        +amog_note(GF5, t-12.*RBPS)\n        +amog_note(GF5, t-14.*RBPS)// them Triplets\n        +amog_note(F5, t-14.33*RBPS)\n        +amog_note(EF5, t-14.66*RBPS)\n        +amog_note(GF5, t-15.*RBPS)\n        +amog_note(F5, t-15.33*RBPS)\n        +amog_note(EF5, t-15.66*RBPS)\n        +amog_note(C5, t-16.*RBPS)\n        )*0.5;\n}\n\nvec2 amog_melody_bass(float t) {\n    t = fract(t/16.*BPS)*16.*RBPS;\n    float bt = fract(t/8.*BPS)*8.*RBPS;\n    return vec2(\n        +soft_bass(C3, bt-0.*RBPS)\n        +soft_bass(C3, bt-1.*RBPS)\n        +soft_bass(C3, bt-2.*RBPS)\n        +soft_bass(C3, bt-3.*RBPS)\n        +soft_bass(C3, bt-4.*RBPS)\n        +soft_bass(C3, bt-5.*RBPS)\n        +soft_bass(C3, bt-6.*RBPS)\n        +soft_bass(G2, bt-7.5*RBPS)\n        +soft_bass(C3, bt-8.*RBPS)\n        \n        +amog_bass(G2, t-7.5*RBPS)\n        +amog_bass(C3, t-8.*RBPS)\n        +amog_bass(C3, t-0.*RBPS)\n        );\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 s = vec2(amog_melody_bass(time)) * vec2(sin(time*BPS*0.25*PI), sin((time+1.)*BPS*0.25*PI));\n    s += vec2(amog_melody_synth(time)) * vec2(0.5,1.0);\n    s += vec2(amog_drums(time)) * vec2(1.0,0.25);\n    return s;\n}", "sound_inputs": [], "common_code": "const float BPM = 100.;\nconst float BPS = BPM/60.;\nconst float RBPS = 60./BPM;\n#define PI 3.1415926\n\n\n// from https://www.shadertoy.com/view/4ts3z2\nvec2 add = vec2(1.0, 0.0);\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\nfloat noise(float x) {\n\tvec2 p2 = fract(vec2(x) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\nvec2 Noise22(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                    mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n    return res-.5;\n}\nvec2 FBM21(float v)\n{\n    vec2 r = vec2(0.0);\n    vec2 x = vec2(v, v*1.3+23.333);\n    float a = .6;\n    for (int i = 0; i < 8; i++)\n    {\n        r += Noise22(x * a) / a;\n        a += a;\n    }\n    return r;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flf3Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 52], [53, 112, 152, 196, 1253], [1256, 1343, 1387, 1387, 1463], [1465, 1465, 1509, 1509, 1587], [1589, 1589, 1608, 1608, 1684], [1686, 1686, 1715, 1715, 1750], [1752, 1752, 1780, 1780, 1842], [1844, 1844, 1869, 1936, 3313], [3315, 3315, 3335, 3335, 4048], [4051, 4051, 4072, 4072, 4545], [4547, 4547, 4575, 4575, 4724], [4726, 4726, 4752, 4752, 4936], [4938, 4938, 4962, 4962, 5331], [5333, 5333, 5390, 5440, 5855]], "test": "untested"}
{"id": "stBGzm", "name": "Smooth Voronoi Experiment", "author": "oneshade", "description": "I tried adding a smooth minimum to the voronoi distance and got a neat result to play around with.\nThis is reminding me very much of Shane's shaders...", "tags": ["voronoi", "experiment", "smooth"], "likes": 26, "viewed": 595, "published": 3, "date": "1623567923", "time_retrieved": "2024-07-30T19:16:14.862286", "image_code": "// Alternative by iq suggested by Shane\n// Its associative and commutative\n// Associative: sminExp(a, sminExp(b, c, k), k) = sminExp(sminExp(a, b, k), c, k)\n// Commutative: sminExp(a, b, k) = sminExp(b, a, k)\nfloat sminExp(in float a, in float b, in float k) {\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 3.0 + 1.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n\n    float t = iTime * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\nfloat smoothVoronoi(in vec2 p, in float k) {\n    // Get closest point\n    vec2 cell = floor(p), closest = getPoint(cell);\n    float minDist = length(p - closest);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) continue;\n            vec2 curCell = cell + vec2(i, j), curPoint = getPoint(curCell);\n            float dist = length(p - curPoint);\n            if (dist < minDist) {\n                closest = curPoint;\n                minDist = dist;\n            }\n        }\n    }\n\n    // Get closest border (should be doing 5x5 search but it doesn't affect this look)\n    cell = floor(closest);\n    vec2 p1 = getPoint(cell + 1.0);\n    float dist = dot(p - 0.5 * (closest + p1), normalize(closest - p1));\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if ((i == 0 && j == 0) || (i == 1 && j == 1)) continue;\n            vec2 curPoint = getPoint(cell + vec2(i, j));\n            dist = sminExp(dist, dot(p - 0.5 * (closest + curPoint), normalize(closest - curPoint)), k);\n        }\n    }\n\n    return dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 3.0 + 0.5 * iTime;\n    float unit = 6.0 / iResolution.y;\n\n    float k = 13.0; // How much the tiles are packed\n    float voro = smoothVoronoi(uv, k);\n\n    float dx = (smoothVoronoi(uv + vec2(0.001, 0.0), k) - voro) / 0.001;\n    float dy = (smoothVoronoi(uv + vec2(0.0, 0.001), k) - voro) / 0.001;\n    vec3 grad = normalize(vec3(dx, dy, 1.0));\n\n    fragColor = vec4(0.0);\n\n    fragColor.gb += 0.5 + 0.5 * grad.xy;\n    fragColor.r += grad.z;\n\n    fragColor.rgb -= smoothstep(unit, 0.0, voro);\n    fragColor.rgb += pow(grad.z, 10.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 209, 260, 260, 331], [333, 422, 448, 448, 534], [536, 561, 590, 590, 873], [875, 875, 919, 944, 1966], [1968, 1968, 2023, 2023, 2623]], "test": "untested"}
{"id": "7lSGzm", "name": "Bulls Eyes", "author": "oneshade", "description": "Accidentally created this cool look while experimenting with voronoi patterns.", "tags": ["voronoi", "stripes", "target", "blobbies"], "likes": 14, "viewed": 191, "published": 3, "date": "1623566494", "time_retrieved": "2024-07-30T19:16:15.610286", "image_code": "// https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 6.0 - 3.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n    float t = iTime * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\nfloat voronoi(in vec2 p, in float smoothness) {\n    vec2 cell = floor(p);\n    float minDist = 1e20;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCell = cell + vec2(i, j);\n            vec2 curPoint = getPoint(curCell);\n            minDist = smin(minDist, length(p - curPoint), smoothness);\n        }\n    }\n\n    return sin(minDist * 40.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(smoothstep(0.5, 0.0, voronoi(uv * 4.0, 0.2) - 0.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 40, 88, 88, 191], [193, 282, 308, 308, 394], [396, 421, 450, 450, 732], [734, 734, 781, 781, 1118], [1120, 1120, 1175, 1175, 1317]], "test": "untested"}
{"id": "7tSGzm", "name": "XOR Towers 156 chars", "author": "GregRostami", "description": "Another fork of KilledByAPixel's Voxel Fractal:\n[url]https://www.shadertoy.com/view/NlB3Rz[/url]\n\nIt's REALLY amazing how many patterns an XOR can create without repeats.\nUse the Mouse to move around.", "tags": ["3d", "voxels", "xor", "tiny", "short", "1tc"], "likes": 8, "viewed": 367, "published": 3, "date": "1623561168", "time_retrieved": "2024-07-30T19:16:16.516862", "image_code": "void mainImage(out vec4 o, vec2 u)\n{ \n  ivec4 b;\n  for (;(b.x^b.y^b.z)%99 > b.z-8;)\n    b = ivec4(3.*--u/iResolution.y*o.a + 2.*iTime + .1*iMouse.xy, o+=.1);\n  o = o/70. - .02*vec4(b%3);\n}", "image_inputs": [{"id": 27430, "src": "https://soundcloud.com/sanya89/jean-michel-jarre-04-en-attendant-cousteau", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSGzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 188]], "test": "untested"}
{"id": "stB3zw", "name": "Distance to Ellipse (Iterative)", "author": "oneshade", "description": "Inspired by [url=https://www.shadertoy.com/view/slS3Rw]https://www.shadertoy.com/view/slS3Rw[/url]\nLeft side: trig\nRight side: no trig", "tags": ["2d", "sdf", "iterative", "ellipse"], "likes": 4, "viewed": 167, "published": 3, "date": "1623542901", "time_retrieved": "2024-07-30T19:16:17.533145", "image_code": "float sdEllipse(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    if (ab.y > ab.x) p = p.yx, ab = ab.yx;\n\n    vec2 pab = p * ab;\n    float s1 = ab.x * ab.x - ab.y * ab.y;\n    float s2 = length(pab);\n    float offs = atan(pab.x / pab.y);\n\n    float t = 1.1;\n    for (int n=0; n < 10; n++) {\n        float to = t + offs, t2 = 2.0 * t;\n        float y = 0.5 * s1 * sin(t2) + s2 * cos(to);\n        t -= y / (s1 * cos(t2) - s2 * sin(to));\n        if (abs(y) < 1e-7 * (s2 + s1)) break;\n    }\n\n    pab = p / ab;\n    return length(p - vec2(cos(t), sin(t)) * ab) * sign(dot(pab, pab) - 1.0);\n}\n\n// Trigless version (solving as a quartic in sin(t))\n// Note that the final solution is asin(solveQuartic()) which allows\n// the final position to be calculated without any trig\n// (a*cos(asin(solveQuartic())), b*sin(asin(solveQuartic()))) =\n// (a * sqrt(1 - solveQuartic()^2), b * solveQuartic())\nfloat sdEllipse2(in vec2 p, in vec2 ab) {\n    if (ab.y > ab.x) p = p.yx, ab = ab.yx;\n    p = abs(p);\n\n    // Line (mainly optimization, the solver handles this case just fine)\n    if (abs(ab.x) < 1e-3 || abs(ab.y) < 1e-3) return length(vec2(p.x - clamp(p.x, -ab.x, ab.x), p.y));\n    if (abs(ab.x - ab.y) < 1e-3) return length(p) - ab.x; // Circle (nab = a^2 - b^2 = 0 ---> sq/nab^2 = undefined)\n\n    vec2 abab = ab * ab, pp = p * p * abab;\n    float nab = abab.x - abab.y, sq = pp.x + pp.y;\n    float k = 1.0 + pp.x / pp.y;\n\n    float b = 2.0 / (sqrt(k / sq) * nab);\n    float c = sq / (nab * nab);\n    float e = c / k;\n    c -= 1.0;\n\n    float t = 0.73;\n    for (int n=0; n < 12; n++) {\n        float y = (((t + b) * t + c) * t - b) * t - e;\n        t -= y / (((4.0 * t + 3.0 * b) * t + 2.0 * c) * t - b);\n        if (abs(y) < 1e-7 * (b + e)) break;\n    }\n\n    vec2 pab = p / ab;\n    return length(p - vec2(sqrt(1.0 - t * t), t) * ab) * sign(dot(pab, pab) - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 10.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 9.0; // Slight lag to maintain visibility\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(6.0, 3.0);\n\n    vec2 ab = abs(mouse);\n    float d = uv.x < 0.0 ? sdEllipse(uv, ab) : sdEllipse2(uv, ab);\n    d *= 0.2; // Undo UV scaling and shrink the isolines a bit for visual purposes\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), smoothstep(0.015, 0.0, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stB3zw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 579], [581, 879, 920, 920, 1845], [1847, 1847, 1902, 1902, 2630]], "test": "untested"}
{"id": "Nl2GRD", "name": "Asteroid Field Thingy", "author": "Zi7ar21", "description": "Inspired by SpaceEngine's New Volumetric Rings Beta. http://spaceengine.org/news/blog210611/", "tags": ["raymarching", "voronoi", "ray", "raymarch", "raymarched", "worley", "raymarcher", "march", "asteroid", "asteroid"], "likes": 5, "viewed": 458, "published": 3, "date": "1623528720", "time_retrieved": "2024-07-30T19:16:18.321039", "image_code": "// ####### Asteroid Field Thingy #######\n// Made by Jacob Bingham (Zi7ar21) on June 11th, 2021\n// Last Updated on June 12th, 2021 at 13:00 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/Nl2GRD\n\n/*\nI was inspired by SpaceEngine's new Volumetric Rings beta. I have no clue how they work, but here is something I think may be similar.\nhttps://spaceengine.org/news/blog210611/\n*/\n\n// \"License\":\n// You are free to use this code, even commercially, as long as you keep comments in the source with credits to snippets that aren't mine.\n// e.g. Dave_Hoskins' Hash33 Hash without Sine Function: https://www.shadertoy.com/view/4djSRW\n// Of course, you must also still respect whatever licenses they use. We are programmers, not lawyers! :)\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// Traditional Input Names\n#define resolution iResolution\n//#define time iTime\n#define time (float(iFrame)/60.0)\n\n// ##### Parameters #####\n\n// Image Gamma\n#define gamma 2.2\n\n// Camera Field of View\n#define camfov 1.0\n\n// Distance Considered a Collision\n#define hitDist 1E-3\n\n// Maximum Distance before counting a Ray-Marched Ray as having Escaped\n#define maxDist 32.0\n\n// Maximum Ray-Marching Steps\n#define maxStep 1024\n\n// ##### Structs #####\n\n// Material Datatype\nstruct material {\n    vec3 albedo;\n    vec3 normal;\n};\n\n// ##### Simple Functions #####\n\n// Dot Product on a Vector (for distance estimator length() performance improvements)\n// e.g. dot(spherePosition-pos, spherePosition-pos) can be done better with dotp(spherePosition-pos)\n// And once you have compared all of these you can use sqrt() to get the length\nfloat dotp(vec3 vec)\n{\n    return dot(vec, vec);\n}\n\n// ##### Color Management #####\n\n// HDR Tonemapping Function\nvec3 HDRtoLDR(vec3 color)\n{\n    // Values below 0.0 are problematic, they must be exterminated!\n    color = max(color, 0.0);\n\n    // Sh*tty Color Space\n    color = vec3(\n    color.r*1.00+color.g*0.05+color.b*0.03,\n    color.r*0.05+color.g*1.00+color.b*0.05,\n    color.r*0.03+color.g*0.05+color.b*1.00);\n\n    // Gamma Correction\n    color = pow(color/(color+1.0), vec3(1.0/gamma));\n\n    // Return the\n    return clamp(color, 0.0, 1.0);\n}\n\n// ##### Hashes and Random Number Generation #####\n\n// Hash33 Hash without Sine: https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3)\n{\n    p3 = fract(p3*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// ##### Rendering #####\n\n// Distance Estimator\n// Basically Worley Noise\nfloat DE(vec3 pos)\n{\n    // Set-Up Variables\n    float minDist = 1000.0;\n\n    // Cell Loop (3*3*3)\n    for(int x = -1; x <= 1; x++) {\n    for(int y = -1; y <= 1; y++) {\n    for(int z = -1; z <= 1; z++) {\n        vec3 pointPosition = vec3(x, y, z)+hash(floor(vec3(x, y, z)+pos));\n        minDist = min(dotp(fract(pos)-pointPosition), minDist);\n    }\n    }\n    }\n\n    // Return the Distance Estimate\n    return sqrt(minDist)-0.1;\n}\n\n// Tetrahedron Numerical Normals\nvec3 getNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist)+\n    k.xyy*DE(pos+k.xyy*hitDist)+\n    k.yxy*DE(pos+k.yxy*hitDist)+\n    k.yyx*DE(pos+k.yyx*hitDist));\n}\n\n// Distance Estimator Ray-Marching\nfloat raycastDE(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    // Set-Up Variables\n    float t = 0.0;\n\n    // Ray-Marching\n    for(int i = 0; i < maxStep; i++)\n    {\n        // Check if the Ray Escaped\n        if(t > maxDist)\n        {\n            break;\n        }\n\n        // Compute Distance Estimate\n        float td = DE(ro+rd*t);\n\n        // Check for a Collision\n        if(td < hitDist*t)\n        {\n            // Compute Normal\n            materialProperties.normal = getNormal(ro+rd*t);\n\n            // Return Distance\n            return t;\n        }\n\n        // March the Ray\n        t += td;\n    }\n\n    // The Ray Never hit Anything\n    return -1.0;\n}\n\n// Scene Intersection Function\nfloat intersect(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    //float t0 = raycastDE(ro, rd, materialProperties);\n    return raycastDE(ro, rd, materialProperties);\n}\n\n// Shading\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    material materialProperties;\n\n    // Compute Intersection\n    float t = intersect(ro, rd, materialProperties);\n\n    // Basically Fog\n    materialProperties.albedo = vec3(clamp(1.0-(t/maxDist), 0.0, 1.0));\n\n    // Return Sky Color\n    if(t < 0.0)\n    {\n        // Sky Color (Black Void)\n        return vec3(0.0);\n    }\n\n    // Light Source Direction\n    vec3 lightDirection = normalize(vec3(1.0, 1.0, -1.0));\n\n    // Compute Shading\n    float lighting0 = max(dot(materialProperties.normal, lightDirection), 0.0)*0.8;\n    float lighting1 = max(dot(materialProperties.normal,-lightDirection), 0.0)*0.1;\n\n    // Return Shaded Result\n    return materialProperties.albedo*(lighting0+lighting1+0.2);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(gl_FragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n    vec3 ro = vec3(0.0, 0.0, time);\n    mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Frame\n    vec3 color = radiance(ro, rd);\n\n    // HDR Tonemapping\n    color = HDRtoLDR(color);\n\n    // Output the Rendered Frame\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2GRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1816, 2083, 2105, 2105, 2133], [2168, 2196, 2223, 2291, 2632], [2686, 2753, 2773, 2773, 2899], [2927, 2975, 2995, 3019, 3404], [3406, 3439, 3465, 3465, 3658], [3660, 3695, 3769, 3793, 4373], [4375, 4406, 4480, 4536, 4588], [4590, 4601, 4634, 4658, 5357], [5359, 5390, 5445, 5474, 5949]], "test": "untested"}
{"id": "NlSGRm", "name": "Ray Marching - 003", "author": "catafest", "description": "Another simple example with Ray Marching's shading function to build a square floor.", "tags": ["raymarching", "environment", "squares"], "likes": 1, "viewed": 401, "published": 3, "date": "1623515428", "time_retrieved": "2024-07-30T19:16:19.076020", "image_code": "//constants \nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n/*\nhttps://en.wikipedia.org/wiki/Ray_tracing_(graphics)\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\np - point \nsd -  signed distance value\ncol - color\nclosest_object - closest object \n*/\n\n// surface by signed distance and color for \nstruct Surface {\n    float sd; \n    vec3 col;\n};\n// floor by point and color \nSurface Floor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n// define a scene function by point \nSurface Scene(vec3 p) {\n  vec3 floorColor = vec3(1. + 0.1*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface closest_object = Floor(p, floorColor);\n  return closest_object;\n}\n// the main Ray Marching funtion\n/*\n*/\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface closest_object; \n  // steps for ray marching\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    closest_object = Scene(p);\n    depth += closest_object.sd;\n    if (closest_object.sd < PRECISION || depth > end) break;\n  }\n  \n  closest_object.sd = depth;\n  \n  return closest_object;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 background_Color = vec3(0.1, 0.7, 0.9);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface the_floor = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (the_floor.sd > MAX_DIST) {\n    col = background_Color; // then the ray didn't hit anything and fill with background_Color\n  } else \n  {\n    // show closest_object\n    float dif = clamp(0.7, 0.6, 1.); // diffuse reflection\n    col = dif * the_floor.col + background_Color * .2; // Add a bit of background color to the diffuse color\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSGRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 478, 511, 511, 561], [562, 599, 622, 622, 768], [769, 808, 868, 868, 1215], [1218, 1218, 1275, 1275, 2005]], "test": "untested"}
{"id": "ftB3Rw", "name": "Volcanic islands", "author": "jarble", "description": "This fractal terrain looks volcanic.", "tags": ["fractal", "terrain", "island", "volcano", "volcanic"], "likes": 4, "viewed": 249, "published": 3, "date": "1623504841", "time_retrieved": "2024-07-30T19:16:19.955668", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 1.0;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.25-(noise(uv * freq)) * amplitude));\n        \n        amplitude *= .3;\n        \n        freq *= 1.3+value/2.;\n        \n        uv = uv.yx;\n    }\n    \n    return (value-2.8)/4.0;\n}\n\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftB3Rw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 411, 436, 436, 470], [490, 490, 513, 562, 983], [1058, 1058, 1096, 1096, 1156], [1158, 1158, 1191, 1191, 1411], [1413, 1413, 1451, 1451, 1678], [1680, 1680, 1718, 1718, 1942], [1944, 1944, 1973, 1973, 2068], [2070, 2070, 2107, 2107, 2166], [2169, 2237, 2256, 2256, 2295], [2297, 2297, 2317, 2317, 2393], [2395, 2395, 2414, 2414, 2453], [2455, 2455, 2512, 2512, 2747], [2749, 2749, 2784, 2784, 3178], [3180, 3180, 3234, 3234, 3900], [3903, 3903, 3955, 3955, 4390], [4392, 4392, 4449, 4449, 5640]], "test": "untested"}
{"id": "stj3zD", "name": "Bouncy ball formula", "author": "voxel", "description": "Demonstration of a very simple bouncing effect which can be used as an easing function.", "tags": ["graph", "physics"], "likes": 3, "viewed": 265, "published": 3, "date": "1623491057", "time_retrieved": "2024-07-30T19:16:20.845290", "image_code": "/* Configuration:\n * R is the rate of decay, i.e., how much faster and shorter is each bounce?\n * B is the number of bounces.\n *\n * W1 is the width of the first bounce. This can be derived from the formula\n *    for the B-th partial sum of a geometric series. If you replace pow(R, B)\n *    with 0 you can get infinitely many bounces.\n *\n * f() here can be an arbitrary function which is graphed by mainImage(). The\n *     x-axis of the graph runs from 0 (left) to 1 (right).\n *\n * The implementation isn't too complicated:\n *\n * - The first line just re-scales the argument to fit in the center of the\n *   graph. Comment it out and you'll see what I mean.\n *\n * - We need to figure out what bounce the argument belongs in. In theory this\n *   could be done using floor(log(... , ...)) but it's simpler to look through\n *   every bounce until we find one whose end position is > x. The variable\n *   t tracks the end position and w tracks the width of the bounce. If B is\n *   constant you might get better performance by unrolling this loop since it\n *   will run no more than B times.\n *\n * - Next we need to calculate the height we are at within the parabolic bounce.\n *   The general formula for this is k*(x-a)*(x-b) where a and b are the roots,\n *   which are the beginning and end of the bounce (t-w and t respectively).\n *   k can be derived from the fact that the output must be 1 on the 1st bounce.\n *\n * The main function graphs f() and uses it to control the height of a ball.\n */\n\n#define R  0.4\n#define B  4.\n\nconst float W1 = ((1. - R) / (1. - pow(R, B)));\n\nfloat f(float x) {\n    x = clamp((x-.25)*2., 0., 1.);\n    float t = 0., w = W1;\n    while (x > (t += w)) w *= R;\n    return (x-t+w) * (x-t) / (-.25*W1*w);\n}\n\nvoid mainImage(out vec4 color, in vec2 co) {\n    vec3 col = mix(\n        vec3(0.,0.,.8),\n        vec3(.9),\n        // graph shape\n        smoothstep(0., 5., abs(f(co.x/iResolution.x)*iResolution.y-co.y))\n            *\n        // bouncy ball\n        smoothstep(5., 10., distance(co, iResolution.xy * vec2(.5, f(fract(iTime/6.)))))\n    );\n\n    // Output to screen\n    color = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stj3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1574, 1574, 1592, 1592, 1730], [1732, 1732, 1776, 1776, 2122]], "test": "untested"}
{"id": "sljGzD", "name": "silly simple warping dot grid", "author": "benhardy", "description": "Just a simple one to demo how fast you can crank a shader out to a friend", "tags": ["simple", "mod", "kata"], "likes": 7, "viewed": 312, "published": 3, "date": "1623481866", "time_retrieved": "2024-07-30T19:16:21.595284", "image_code": "const float WINDOW_WIDTH = 15.0;\n\n#define AA_SPAN 1.5\n\n#define ASPECT (iResolution.y/iResolution.x)\n\nvec2 cmod(vec2 pos, vec2 off) {\n    return mod(pos+0.5, off) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 win = WINDOW_WIDTH * (fragCoord/iResolution.xy - 0.5) * vec2(1, ASPECT);\n    float ang = 3.0 * sin(iTime*1.0 + 5.0* sin(iTime*0.23));\n    vec2 rot_pos = vec2(cos(ang)*win.x-sin(ang)*win.y,sin(ang)*win.x+cos(ang)*win.y);\n    vec2 warp_centre = 3.0 * vec2(sin(iTime*2.0), cos(5.0*iTime));\n    vec2 to_warp = rot_pos - warp_centre;\n    float d_warp = length(to_warp);\n    d_warp += (sin(iTime*3.5+ 2.3* sin(iTime*0.33))+1.2)*0.02*( pow(d_warp, 3.0) + 0.1 );\n    vec2 warped = warp_centre +d_warp * normalize(to_warp);\n    \n    vec2 pos = cmod(warped, vec2(1));\n    float dist = length(pos) - 0.25;\n\n    // smoothstep based antialiasing thanks to @FabriceNeyret2\n    float level = smoothstep(0.0, WINDOW_WIDTH*AA_SPAN/iResolution.x, dist);\n    vec3 col = vec3(level);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljGzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 132, 132, 170], [172, 172, 229, 279, 1110]], "test": "untested"}
{"id": "stjGRD", "name": "winding number of a 2d shape", "author": "copperbotte", "description": "a visualization of the winding number field for a 2d shape with a discontinuity.\n\nClick for an alternative visualization.\n\nsimilar to the 2d sample provided in \"robust inside outside segmentation using generalized winding numbers\" by jacobson et al (2013)", "tags": ["math"], "likes": 16, "viewed": 469, "published": 3, "date": "1623478856", "time_retrieved": "2024-07-30T19:16:22.428058", "image_code": "\n//build an sdf for visualization purposes.\nfloat sdf_point(in vec2 point, in vec2 pos)\n{\n    vec2 delta = point - pos;\n    return length(delta);\n}\n\nfloat sdf_line(in vec2 normal, in float offset, in vec2 pos)\n{\n    float proj_dist = dot(normal, pos);\n    proj_dist -= offset;\n    \n    return abs(proj_dist);\n}\n\nfloat sdf_segment(in vec2 p1, in vec2 p2, in vec2 pos)\n{\n    //move pos into the coordinate system of the line, where the line is the x axis from 0 to 1.\n    //If it's x coordinate is outside the line range, use the shortest point sdf.\n    //else, use the line sdf.\n\n    //gather data for the line sdf\n    vec2 dp = p2 - p1;\n    //vec2 normal = normalize(cross(vec3(dp, 0), vec3(0,0,1)).xy);\n    vec2 normal = normalize(vec2(dp.y, -dp.x)); // complex rotation is valid in 2d\n    float offset = dot(p1, normal);\n    \n    //find the tangent coordinate\n    vec2 tangent = normalize(dp);\n    float t_1 = dot(tangent, p1);\n    float t_2 = dot(tangent, p2);\n    float dt = t_2 - t_1;\n    \n    //manually project the x axis instead of a matrix, sdf_line handles the y.\n    //maybe this is slower, but for this demo it shouldn't matter.\n    float t_pos = dot(tangent, pos);\n    \n    //inverse lerp\n    t_pos = (t_pos - t_1) / dt;\n    \n    //test within line\n    if(t_pos < 0.0)\n        return sdf_point(p1, pos);\n    \n    if(1.0 < t_pos)\n        return sdf_point(p2, pos);\n    \n    return sdf_line(normal, offset, pos);\n}\n\n//find the winding number usint a pair of vertices and a point.\nfloat wind_segment(in vec2 p1, in vec2 p2, in vec2 pos)\n{\n    //the winding number is the signed path length of the projeciton of a curve onto a unit circle of radius r.\n    //this number is divided by its circumference, and means how many times the circle has gone around the point.\n    \n    vec2 d_p1 = normalize(p1 - pos);\n    vec2 d_p2 = normalize(p2 - pos);\n    \n    //winding number starts at p1, ends at p2.\n    //this can either be done via atan difference (probably has issues near the negative y direction)\n    //float w1 = atan(d_p1.y, d_p1.x);\n    //float w2 = atan(d_p2.y, d_p2.x);\n    //return w2 - w1;\n    \n    //or, by acos of a normalized dot.\n    float d = dot(d_p1, d_p2);\n    float ac = acos(d);\n    if(isnan(ac))\n        return 0.0;\n        \n    //find winding sign\n    float s = cross(vec3(d_p1, 0.0), vec3(d_p2, 0.0)).z;\n    ac *= sign(s);\n    \n    return ac / (2.0 * 3.141592);\n}\n\n\n\n\n//this demo has one of the line segments move.\nfloat moving_discontinuity(in vec2 uv, out float sdf)\n{\n\n    vec2[] verts = vec2[] (\n        vec2( 0.5, 0.5),\n        vec2(-0.5, 0.5),\n        vec2(-0.5,-0.5),\n        vec2( 0.5,-0.5)\n    );\n    \n    //adjust the last line\n    vec2 disp = vec2(0.2*sin(iTime / 2.0), 0.0);\n    \n    //display lines and generate winding number\n    sdf = 100000.0;\n    float wind = 0.0;\n    for(int i=0; i<4; ++i)\n    {\n        vec2 v1 = verts[i];\n        vec2 v2 = verts[(i+1)%4];\n        \n        if(i == 3)\n        {\n            v1 += disp;\n            v2 += disp;\n        }\n        \n        float t_sdf = sdf_segment(v1, v2, uv);\n        if(t_sdf < sdf) sdf = t_sdf;\n        \n        wind += wind_segment(v1, v2, uv);\n    }\n\n    return wind;\n}\n\n//this demo has the line segment grow.\nfloat growing_discontinuity(in vec2 uv, out float sdf)\n{\n\n    const int vert_count = 4;\n    vec2[vert_count] verts = vec2[] (\n        vec2( 0.5, 0.5),\n        vec2(-0.5, 0.5),\n        vec2(-0.5,-0.5),\n        vec2( 0.5,-0.5)\n    );\n    \n    //make a value grow for 3 seconds, and stop for two.\n    float time = min(mod(iTime, 5.0), 3.0) / 3.0;\n    \n    //find the distance between each segment\n    float[vert_count] dists;\n    for(int i=0; i<vert_count; ++i)\n        dists[i] = length(verts[(i+1)%vert_count] - verts[i]);\n        \n    //find the total distance for each segment\n    //include a zero sum for comparisons later\n    float[vert_count+1] sum_dists;\n    sum_dists[0] = 0.0;\n    for(int i=0; i<vert_count; ++i)\n        sum_dists[i+1] = sum_dists[i] + dists[i];\n    \n    //normalize the dists by the total distance\n    float[vert_count+1] pct_dists;\n    for(int i=0; i<vert_count+1; ++i)\n        pct_dists[i] = sum_dists[i] / sum_dists[vert_count];\n    \n    //convert time to the percentage path around a specific path segment\n    //default is 100% of the polygon\n    int segment = 4;\n    float pct = 0.0;\n    for(int i=0; i<vert_count; ++i)\n    {\n        if(pct_dists[i+1] <= time) continue;\n        segment = i;\n        \n        //inverse lerp\n        pct = (time - pct_dists[i]) / (pct_dists[i+1] - pct_dists[i]);\n        break;\n    }\n    \n    sdf = 100000.0;\n    float wind = 0.0;\n    \n    //display points and winding number before the segment\n    for(int i=0; i<segment; ++i)\n    {\n        vec2 v1 = verts[i];\n        vec2 v2 = verts[(i+1)%vert_count];\n    \n        float t_sdf = sdf_segment(v1, v2, uv);\n        if(t_sdf < sdf) sdf = t_sdf;\n        \n        wind += wind_segment(v1, v2, uv);\n    }\n\n    //display the next point to a calculated point (lerp)\n    if(segment != vert_count)\n    {\n        vec2 v1 = verts[segment];\n        vec2 v2 = mix(verts[segment], verts[(segment+1)%vert_count], pct);\n        float t_sdf = sdf_segment(v1, v2, uv);\n        if(t_sdf < sdf) sdf = t_sdf;\n\n        wind += wind_segment(v1, v2, uv);\n    }\n\n    return wind;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = mix(vec2(-1,-1), vec2(1,1), uv);\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    //sdf testing\n    //col *= 1.0 - exp(-50.0*sdf_line(normal, offset, uv));\n    //col *= 1.0 - exp(-50.0*sdf_point(verts[0], uv));\n    \n    float sdf = 100000.0;\n    //float wind = moving_discontinuity(uv, sdf);\n    float wind = growing_discontinuity(uv, sdf);\n    \n    //alternative visualizations\n    if(iMouse.z < 0.5)\n        col = vec3(1.0);\n    else\n        col = 0.5 + 0.5*cos((2.0*3.141592) *5.0*wind + iTime+uv.xyx+vec3(0,2,4));\n    \n    col *= 0.5 * wind + 0.5;\n    \n    //col *= 1.0 - exp(-100.0*sdf);\n    if(sdf < 0.005) col *= 0.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //fragColor = vec4(uv, 0.0, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjGRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 44, 89, 89, 147], [149, 149, 211, 211, 310], [312, 312, 368, 613, 1425], [1427, 1491, 1548, 1774, 2394], [5286, 5286, 5343, 5393, 6259]], "test": "untested"}
{"id": "slj3R1", "name": "Tangram Fish", "author": "stseagle", "description": "An additional happy accident.  It was supposed to be a quilt, and now it's some fish.  NBD.", "tags": ["2d", "geometry", "quiltpattern"], "likes": 5, "viewed": 230, "published": 3, "date": "1623467990", "time_retrieved": "2024-07-30T19:16:23.266815", "image_code": "float zagRight(in vec2 _st) {\n    return step(0.05, abs(_st.x) - abs(_st.y));\n}\n\nfloat zagLeft(in vec2 _st) {\n    return step(0.1, (_st.x) - abs(_st.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/100.*(iResolution.y/iResolution.x);\n        \n    \n    vec3 col = vec3(1.);\n    \n    vec2 pos = floor(st);\n        st.x += iTime * 0.5 + pos.y;\n       st = 4.*(fract(st )-0.5);\n       \n    if (mod(pos.x+pos.y,2.)>0.) {\n        col *= zagLeft(st);\n    } else {\n        col *= zagRight(st);\n    }\n    \n    \n    \n    col.r *= mod(pos.x, 3.4)/2. * (1. + 0.3* sin(iTime));\n    col.g *= mod(pos.y, 3.1)/1.9 * (1. + 0.3* sin(iTime));\n    col.b *= mod(pos.x + pos.y + 1., 3.7)/1.9* (1. + 0.5* sin(iTime+0.6));\n    \n       \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slj3R1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 79], [81, 81, 109, 109, 155], [157, 157, 214, 214, 815]], "test": "untested"}
{"id": "7tl3Wf", "name": "multipass optimization play", "author": "mds2", "description": "Trying to see if I can accelerate ray-casting a complicated model by using low-res multiple passes.\n\nSwiping mouse left/right turns optimization off (orange) or on (not orange)", "tags": ["multipassopt"], "likes": 7, "viewed": 280, "published": 3, "date": "1623457434", "time_retrieved": "2024-07-30T19:16:24.406767", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_twist(iTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float speed_test = step(2.0 * iMouse.x - 0.5 * iResolution.x, fragCoord.x);\n    \n    vec3 orig = get_orig(iTime);\n    vec3 dir = get_ray(fragCoord, iResolution.xy, iTime);\n\n    \n    vec4 col = texture(iChannel0,  0.25 * uv);\n    \n    float dist = float_from_col(col);\n    \n    float dist_refined = raymarch(orig, dir, speed_test * dist, 1.0e-4);\n    \n    \n    if (dist_refined > MAX_DIST) {\n      fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    \n    \n    vec3 loc = orig + dir * dist_refined;\n    \n    vec3 light = get_light(iTime);\n    \n    float dist_from_light = length(loc - light);\n    \n    vec2 light_uv = light_ray_to_uv(loc - light, iResolution.xy, iTime);\n    float light_dist_from_tex = float_from_col(texture(iChannel1, light_uv));\n    float dist_from_light_to_surf = raymarch(light, normalize(loc - light),\n                                             speed_test * 0.5 * light_dist_from_tex, 1.0e-4);\n    float subsurf = max(0.0, dist_from_light - dist_from_light_to_surf);\n    \n        \n    vec3 spectrum =  60.0 * vec3(0.05, 0.25, 0.85);\n    \n    \n    float metal = smoothstep(0.3, 0.2, engine_check(loc));\n\n    if (metal > 0.5) {\n      spectrum = spectrum * 0.001;\n    }\n\n    vec3 subsurf_bright = spectrum / (spectrum + subsurf);\n    \n    vec3 normal = sdf_normal(loc);\n    vec3 bounce = normalize(reflect(dir, normal));\n    \n    float dot_light = dot(normalize(light - loc), bounce);\n    vec3 refl_bright = smoothstep(vec3(0.8, 0.85, 0.9), vec3(1.0), vec3(dot_light));\n    float diffuse = 0.2 + max(0.0, dot(normalize(light - loc), normal));\n\n    if (metal > 0.5) {\n      diffuse = 0.2 + 1.0 * max(0.0, dot_light); //  + 0.1 * sin(20.0 * bounce.y);\n    }\n    \n    vec3 color1 = 0.75 * subsurf_bright * diffuse + 0.5 * refl_bright + 0.15 * subsurf_bright;\n    vec3 color2 = 0.75 * smoothstep(0.95, 1.0, refl_bright) + 0.25 * (0.5 + 0.5 * bounce);\n    \n    float material = smoothstep(0.05, 0.1, 2.0 * cockpit_check(loc)); \n    // material = 0.0;\n    // Output to screen\n    fragColor = vec4(mix(color2, color1, material) + mix(vec3(1., 0.5, 0.), vec3(0.), speed_test), 1.0);\n   // fragColor = fragColor + 200.0 * texture(iChannel1,  0.5 * uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_DIST 20.0\n\nmat3 global_twist = mat3(1.0, 0.0, 0.0,\n0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\nvoid set_twist(in float time) {\n  float ct = cos(0.5 * time);\n  float st = sin(0.5 * time);\n  global_twist = mat3(ct, st, 0.0, -st, ct, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 get_orig(in float time) {\n  return vec3(0.0, 4.0, -8.0);\n}\n\nvec3 get_ray(in vec2 fragCoord, in vec2 resolution, in float time) {\n  vec2 uv = (2.0 * fragCoord - resolution) / max(resolution.x, resolution.y);\n  const mat3 tilt = mat3(1.0, 0.0, 0.0,\n                         0.0, 0.8660254, 0.5,\n                         0.0, -0.5, 0.8660254);\n  return normalize(tilt * vec3(uv, 1.7));\n}\n\nvec3 get_light(in float time) {\n  vec3 pt = get_orig(time);\n  return mat3(0.6, 0.0, 0.8,\n              0.0, 1.0, 0.0,\n              -0.8, 0.0, 0.6) * pt;\n}\n\nvec3 get_light_ray(in vec2 fragCoord, in vec2 resolution, in float time) {\n\n  vec2 uv = (2.0 * fragCoord - resolution) / max(resolution.x, resolution.y);\n  const mat3 tilt = mat3(1.0, 0.0, 0.0,\n                         0.0, 0.8660254, 0.5,\n                         0.0, -0.5, 0.8660254);\n  vec3 dir = normalize(tilt * vec3(uv, 0.45));\n  return mat3(0.6, 0.0, 0.8,\n              0.0, 1.0, 0.0,\n              -0.8, 0.0, 0.6) * dir;\n}\n\nvec2 light_ray_to_uv(in vec3 ray, in vec2 resolution, in float time) {\n  // will break if time starts to matter, makes assumptions\n  const mat3 inv_light = mat3(0.6, 0.0, -0.8, 0.0, 1.0, 0.0, 0.8, 0.0, 0.6);\n  const mat3 inv_tilt = mat3(1.0, 0.0, 0.0,\n                             0.0, 0.8660254, -0.5,\n                             0.0, 0.5, 0.8660254);\n  vec3 xformed =  inv_tilt * (inv_light * ray);\n  vec2 uv = 0.45 * xformed.xy/xformed.z;\n  uv *= max(resolution.x, resolution.y)/resolution.xy;\n  uv = 0.5 * uv + 0.5;\n  return clamp(0.25 * uv, 0.0, 0.25);\n}\n\nfloat calc_stop_per_d(in float scale, in vec2 resolution) {\n  float per_pix_at_plane = 2.0 / max(resolution.x, resolution.y);\n  return per_pix_at_plane / (scale * 1.7);\n}\n\n/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/** more expensive, but smoother, blend funcs */\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\n/** best of both worlds */\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat checked_smooth_isect(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, -b, k);\n}\n\nfloat checked_smooth_diff(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, b, k);\n}\n\nfloat super_egg(in vec3 pt) {\n  vec3 squares = pt * pt;\n  float l = sqrt(sqrt(dot(squares, squares)));\n  return l - 1.0;\n}\n\nfloat semi_egg(in vec3 pt) {\n  return super_egg(vec3(pt.x, length(pt.yz), 0.0));\n}\n\nfloat car_core(in vec3 pt) {\n  return super_egg(pt / vec3(9.0, 4.0, 1.0));\n}\n\nfloat cockpit(in vec3 pt) {\n  return checked_smooth_isect(semi_egg((pt.yzx - vec3(0.,1.75, 4.)) / vec3(3., 2., 7.)),\n                              semi_egg((pt.yzx - vec3(0., 1.5, 3.)) / vec3(4., 3., 5.)),\n                              0.25);\n} \n\nfloat car(in vec3 pt) {\n  return checked_smooth_min(car_core(pt), cockpit(pt), 1.25);\n}\n\nfloat engines(in vec3 pt) {\n  return min(semi_egg((pt + vec3(9., 4.75, -2.3)) / vec3(6.0, 1.0, 1.0)),\n             semi_egg((pt + vec3(9.0, -4.75, -2.3)) / vec3(6., 1., 1.)));\n}\n\nfloat box(in vec3 pt_min, in vec3 pt_max, in vec3 pt) {\n  vec3 dists = max(pt_min - pt, pt - pt_max);\n  return max(dists.x, max(dists.y, dists.z));\n}\n\nfloat wings(in vec3 pt) {\n  float unboxed = checked_smooth_diff(\n    -min(-super_egg((pt + vec3(5., 0., -2.)) / vec3(9., 5., 2.)),\n         super_egg((pt + vec3(2., 0., -2.1)) / vec3(8.75, 4.25, 1.6))),\n    super_egg((pt + vec3(4., 0., -4.5)) / vec3(3., 12., 3.)),\n    1.0);\n    \n    return checked_smooth_isect(box(vec3(-9.5, -5., -5.), vec3(-3., 5., 5.), pt),\n                                unboxed, 1.);\n}\n\nfloat sdf(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  float carval =  min(car(p), engines(p));\n  return checked_smooth_min(carval, wings(p), 0.5);\n}\n\nfloat cockpit_check(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  return checked_smooth_diff(cockpit(p), car_core(p), 0.25);\n}\n\nfloat engine_check(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  return checked_smooth_min(engines(p), max(3.0 - p.z, wings(p)), 0.5);\n  // return checked_smooth_min(engines(p), wings(p), 0.5);\n  // return engines(p);\n}\n\nvec3 sdf_normal(in vec3 pt) {\n  float f = sdf(pt);\n  const float h = 0.001;\n  return normalize(vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f));\n}\n\nfloat raymarch(in vec3 orig, in vec3 dir,\n               in float start_d, in float stop_per_d) {\n  float along = start_d;\n  for (int i = 0; i < 256; ++i) {\n    vec3 pt = orig + along * dir;\n    float d = sdf(pt);\n    if (along > MAX_DIST || abs(d) < stop_per_d * max(along, 1.0)) {\n      return along;\n    }\n    along = along + 0.25 * d;\n  }\n  return along;\n}\n\nfloat float_from_col(in vec4 rgba) {\n  return 256.0 * rgba.r + rgba.g + 0.00390625 * (rgba.b + 0.00390625 * rgba.a);\n}\n\n\n\nvec4 col_from_float(in float val) {\n  vec4 result;\n  result.r = mod(0.00390625 * val, 1.0);\n  val = val - 256.0 * result.r;\n  result.g = mod(val, 1.0);\n  val = val - result.g;\n  val = val * 256.0;\n  result.b = mod(val, 1.0);\n  val = val - result.b;\n  val = val * 256.0;\n  result.a = mod(val, 1.0);\n  return result;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_twist(iTime);\n    vec3 orig = get_orig(iTime);\n    vec3 dir = get_ray(4.0 * fragCoord, iResolution.xy, iTime);\n    float dist_out = MAX_DIST + 1.0;\n    if (4.0 * fragCoord.x < iResolution.x && 4.0 * fragCoord.y < iResolution.y) {\n      dist_out = raymarch(orig, dir, 0.0, calc_stop_per_d(0.03125, iResolution.xy));\n    }\n    fragColor = col_from_float(dist_out);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_twist(iTime);\n\n    vec3 orig = get_light(iTime);\n    vec3 dir = get_light_ray(4.0 * fragCoord, iResolution.xy, iTime);\n    float dist_out = MAX_DIST + 1.0;\n    if (4.0 * fragCoord.x < iResolution.x && 4.0 * fragCoord.y < iResolution.y) {\n      dist_out = raymarch(orig, dir, 0.0, calc_stop_per_d(0.125, iResolution.xy));\n    }\n    fragColor = col_from_float(dist_out);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tl3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 59, 2361]], "test": "untested"}
{"id": "flj3RD", "name": "Cubemap texture with mouse", "author": "catafest", "description": "simple test with cubemap texture", "tags": ["mouse", "texture", "cubemap"], "likes": 1, "viewed": 380, "published": 3, "date": "1623445721", "time_retrieved": "2024-07-30T19:16:25.433023", "image_code": "// more on https://www.shadertoy.com/view/XsjfDD\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Set background color - blue\n    //fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    //Set background color - black\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Normalized pixel coordinates (from 0 to 1) and camera distance\n    float distance = 3.0;\n    vec2 uv = distance * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n    // Get mouse position between 0 and 1 \n    float rot_x = (iMouse.x / iResolution.x) * 3.1415*2.0;\n    float rot_y = (iMouse.y / iResolution.y) * 3.1415;\n    // Set camera rotation: left - right with rot_x, up - down with rot_y\n    vec3 camera_rotation = vec3(cos(rot_x), cos(rot_y), sin(rot_x));\n\n    vec3 f = -normalize(camera_rotation);     // Camera position forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Camera right \n    vec3 u = cross(r, f);                     // Camera to normalize image\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);// Render formula for fragColor output\n\n    // Output to screen\n    fragColor += texture(iChannel0, rd);\n\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flj3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 49, 106, 224, 1113]], "test": "untested"}
{"id": "ft2GRD", "name": "Maxnorm Distance to Cubic Curve", "author": "oneshade", "description": "First try at computing maxnorm distances.", "tags": ["2d", "distance", "curve", "cubic", "maxnorm", "exact"], "likes": 9, "viewed": 215, "published": 3, "date": "1623444739", "time_retrieved": "2024-07-30T19:16:26.214933", "image_code": "vec3 solveQuadratic(in float a, in float b, in float c) {\n    if (abs(a) < 1e-6) return vec3(-c / b, 0, 1);\n    float h = b * b - 4.0 * a * c;\n    if (h < 0.0) return vec3(0.0);\n    return vec3((vec2(-1.0, 1.0) * sqrt(h) - b) * 0.5 / a, 2.0);\n}\n\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    if (abs(a) < 1e-9) return vec4(solveQuadratic(b, c, d), 0.0).xywz;\n    float u = b / (3.0 * a);\n\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n    if (abs(p) < 1e-3) return vec4(-sign(q) * pow(abs(q), 1.0 / 3.0) - u, 0, 0, 1);\n\n    if (4.0 * p * p * p + 27.0 * q * q > 0.0) {\n        float ip = 3.0 / abs(p), sp = sqrt(ip), k = 0.5 * q * ip * sp, x;\n        if (p > 0.0) x = -2.0 / sp * sinh(asinh(k) / 3.0) - u;\n        else x = -2.0 / sp * cosh(acosh(abs(k)) / 3.0) * sign(q) - u;\n        return vec4(x, 0, 0, 1);\n    }\n\n    float m = sqrt(-p / 3.0);\n    float x1 = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    float h = sqrt(-3.0 * x1 * x1 - 4.0 * p);\n    float x2 = 0.5 * (h - x1), x3 = 0.5 * (-h - x1);\n\n    return vec4(x1 - u, x2 - u, x3 - u, 3);\n}\n\nfloat evalDist(in vec2 p, in float t, in float tmin, in float tmax, in bool limit, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    if (limit) t = clamp(t, tmin, tmax);\n    vec2 toCurve = p - (((a * t + b) * t + c) * t + d);\n    return max(abs(toCurve.x), abs(toCurve.y));\n}\n\nfloat sdCubic(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float tmin, in float tmax, in bool limit) {\n    // Solving for the global minimum of max(|a.x*t^3 + b.x*t^2 + c.x*t + d.x - p.x|, |a.y*t^3 + b.y*t^2 + c.y*t + d.y - p.y|)\n    // Minima and maxima are either intersections of the two with different combinations of signs where the derivative jumps from one to the other\n    // or the minima and maxima of one of the cubics (sign flip due to abs() does not change them)\n    vec2 dp = d - p;\n\n    // |a.x*t^3 + b.x*t^2 + c.x*t + d.x - p.x| = |a.y*t^3 + b.y*t^2 + c.y*t + d.y - p.y|\n    // All combinations of signs on both sides degenerate into either +/+ or +/-\n    vec4 minMax1 = solveCubic(a.x - a.y, b.x - b.y, c.x - c.y, dp.x - dp.y);\n    vec4 minMax2 = solveCubic(a.x + a.y, b.x + b.y, c.x + c.y, dp.x + dp.y);\n\n    // Minima and maxima of both cubics\n    // Remember that they CAN have a global minimum because of abs() forcing them\n    // to bounce back up when they go below the x axis\n    vec3 minMax3 = solveQuadratic(3.0 * a.x, 2.0 * b.x, c.x);\n    vec3 minMax4 = solveQuadratic(3.0 * a.y, 2.0 * b.y, c.y);\n\n    // Find minimum\n    float dist = evalDist(p, minMax1[0], tmin, tmax, limit, a, b, c, d);\n    for (int n=1; n < int(minMax1.w); n++) dist = min(dist, evalDist(p, minMax1[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax2.w); n++) dist = min(dist, evalDist(p, minMax2[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax3.z); n++) dist = min(dist, evalDist(p, minMax3[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax4.z); n++) dist = min(dist, evalDist(p, minMax4[n], tmin, tmax, limit, a, b, c, d));\n\n    return dist;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(2.0, 2.0 * sin(time)) * cos(time);\n\n    float t1 = iTime * 0.5, t2 = iTime, t3 = iTime * 1.25;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec2 v1 = vec2(c2, s3 * 1.5 - 0.25);\n    vec2 v2 = vec2(-2.0, 0.5);\n    vec2 v3 = vec2(2.0, 0.5);\n    vec2 v4 = vec2(s2, c3 * 1.5 - 0.25);\n\n    // To power basis\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1;\n\n    float dist = sdCubic(uv, a, b, c, d, 0.0, 1.0, true);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * dist);\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(dist)));\n\n    // Control points\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - v1) - 0.05));\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - v4) - 0.05));\n\n    float mDist = sdCubic(mouse, a, b, c, d, 0.0, 1.0, true);\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.03));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist) - 0.005));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 244], [246, 246, 311, 311, 1121], [1123, 1123, 1251, 1251, 1398], [1400, 1400, 1515, 1888, 3118], [3120, 3120, 3167, 3167, 3275], [3277, 3277, 3332, 3332, 4983]], "test": "untested"}
{"id": "Ntj3RW", "name": "River channels", "author": "jarble", "description": "This fractal landscape has many fluvial landforms.", "tags": ["fractal", "terrain", "river"], "likes": 3, "viewed": 356, "published": 3, "date": "1623437588", "time_retrieved": "2024-07-30T19:16:27.055685", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\nfloat fprand(vec2 uv, float f){\n    return sin(uv.y*f)+cos(uv.x*f);\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 6.0;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.25-abs(noise(uv * freq)) * amplitude));\n        \n        amplitude *= .55;\n        \n        freq *= 1.75+value;\n        \n        uv = uv.yx;\n    }\n    \n    return 1.-value;\n}\n\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntj3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 441, 441, 479], [481, 481, 506, 506, 540], [561, 561, 584, 633, 1049], [1124, 1124, 1162, 1162, 1222], [1224, 1224, 1257, 1257, 1477], [1479, 1479, 1517, 1517, 1744], [1746, 1746, 1784, 1784, 2008], [2010, 2010, 2039, 2039, 2134], [2136, 2136, 2173, 2173, 2232], [2235, 2303, 2322, 2322, 2361], [2363, 2363, 2383, 2383, 2459], [2461, 2461, 2480, 2480, 2519], [2521, 2521, 2578, 2578, 2813], [2815, 2815, 2850, 2850, 3244], [3246, 3246, 3300, 3300, 3966], [3969, 3969, 4021, 4021, 4456], [4458, 4458, 4515, 4515, 5706]], "test": "untested"}
{"id": "Nt2GRW", "name": "Mountain lakes", "author": "jarble", "description": "Yet another fractal terrain experiment.\nThis landscape isn't very realistic: I prefer [url=https://www.shadertoy.com/view/NljXWK]this one[/url].", "tags": ["fractal", "terrain", "river", "mountain"], "likes": 6, "viewed": 384, "published": 3, "date": "1623436913", "time_retrieved": "2024-07-30T19:16:27.955280", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 1.5;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.25-abs(noise(uv * freq)-.3) * amplitude));\n        \n        amplitude *= .27;\n        \n        freq *= 3.-value/8.0;\n        \n        //uv = uv.yx;\n    }\n    \n    return (value*2.0-3.15)/2.0;\n}\n\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2GRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 435, 435, 469], [490, 490, 513, 562, 997], [1072, 1072, 1110, 1110, 1170], [1172, 1172, 1205, 1205, 1425], [1427, 1427, 1465, 1465, 1692], [1694, 1694, 1732, 1732, 1956], [1958, 1958, 1987, 1987, 2082], [2084, 2084, 2121, 2121, 2180], [2183, 2251, 2270, 2270, 2309], [2311, 2311, 2331, 2331, 2407], [2409, 2409, 2428, 2428, 2467], [2469, 2469, 2526, 2526, 2761], [2763, 2763, 2798, 2798, 3192], [3194, 3194, 3248, 3248, 3914], [3917, 3917, 3969, 3969, 4404], [4406, 4406, 4463, 4463, 5654]], "test": "untested"}
{"id": "stSGRW", "name": "Day 540", "author": "jeyko", "description": "potatesteraa", "tags": ["design", "poster", "mdtmjvm", "acidgraphics"], "likes": 47, "viewed": 664, "published": 3, "date": "1623435600", "time_retrieved": "2024-07-30T19:16:29.046363", "image_code": "// Fork of \"Day 539\" by jeyko. https://shadertoy.com/view/slSGz1\n// 2021-06-11 08:12:26\n\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 6.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    n = sin(n*2.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    fragCoord += 650.*noise(vec3(uv*0.5,5.))/iResolution.xy;\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    float no = noise(vec3(uv*2.,35.));\n    col = mix(col,vec3(0),smoothstep(0.,0.5,max(noise(vec3(uv*2.2 + 0.1,35.)) - 0.5,0.))*0.4);\n    \n    col = mix(col,vec3(1),smoothstep(0.,5.,max(no - 0.5,0.))*.05);\n    \n    //col += min(no - 0.5,0.)*0.02;\n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(fragCoord + vec2(float(iFrame)*0.,0.),256.)),0).x*0.5;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(fragCoord + n1d*200. ,256.)),0).xyz*0.6;\n    \n    \n    //C = smoothstep(0.,1.,C);z\n    \n    //col.xyz = pow(max(col.xyz,0.), vec3(0.55) + n*0.1);\n    \n    \n    \n    col = pow(max(col,0.),vec3(0.4545));\n\n    col.xyz += smoothstep(1.,0.,length(col))*n*0.15;\n    \n    col.xyz -= smoothstep(0.,1.,length(col))*n*0.05;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi acos(-1.)\n\n        #define xor(a,b,c) min(max(a,-(b) + c),max(b,-(a)))\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}", "buffer_a_code": "float sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nfloat text(vec2 p, float[9] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float offs) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    char -= 32. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 9.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,-(iTime + sin(iTime))*0.2);\n    for(float i = 0.; i < 6.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.+iTime*1.5) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    return n;\n}\n\n\nfloat noiseGrid(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    for(float i = 0.; i <2.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.5;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    return n;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.8,0.5,0.4)*0.;\n    vec3 baseCol = col;\n    vec3 c = vec3(0.,0.511,0.2)*0.7;\n    \n\n    uv.x -= 0.725 + 0.04;\n\n    \n    {\n        // grid\n        vec2 p = uv;\n        \n        p.y -= 0.08;\n        p.x += 0.35;\n        \n        float bdb = sdBox(p,vec2(0.35));\n        \n        p *= rot(sin(length(p)*15. + iTime)*0.2*smoothstep(0.,-0.4,bdb));\n        \n        float w = 0.001;\n        float d = 10e5;\n        \n        //bd = bd + smoothstep(0.001,0.,bd)*smoothstep(-0.2,0.2,p.x)*texture(iChannel0,p).x;\n        \n        \n        float biters = 10. + floor(10.*( 1.*max(sin(iTime*1.),-0.5)));\n        float lastb;\n        for (float i = 0.; i < biters; i ++){\n            float b = sdBox(p,vec2(mod(exp(-i/10.),1.)*0.35));\n            if(i == biters - 1.)\n                lastb = b;\n            d = min( d,abs(b));\n        }\n        \n        float itersLines = 10.;\n        for (float i = 0.; i < itersLines; i ++){\n            vec2 q = p*rot(i/itersLines*pi + 1./itersLines*pi/2.);\n            d = min( d,abs(q.x));\n        }\n        \n        \n        \n        float outBox = smoothstep(fwidth(uv.y),0.,bdb);\n        float inBox = smoothstep(fwidth(uv.y),0.,-lastb);\n        \n        col = mix(col,c,inBox*outBox*smoothstep(fwidth(uv.y),0.,d - w));\n        \n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,abs(bdb) - w));\n            \n        \n        //d =  abs(bd);\n        \n        //col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n        \n    \n    }\n    \n    {\n        // MEATBALLS\n        float d = 10e5;\n        vec2 p = uv;\n        \n        p.y -= 0.08;\n        p.x += 0.35;\n        for(float i = 0.; i <6.; i++){\n            float m = i + iTime;\n            d = opSmoothUnion( d, length(p - vec2(cos(m*cos(i)),sin(m))*0.2) - 0.05*(1. + 0.5*sin(m*1.5)), 0.1);\n        \n        }\n        float ballFill = smoothstep(fwidth(d),0.,d);\n        col = mix(col,baseCol,ballFill);\n        col = mix(col,c,smoothstep(fwidth(d),0.,abs(d)));\n        col = mix(col,c,ballFill*smoothstep(-0.03,0.,d)*texture(iChannel0,p*0.3).x*2.*smoothstep(0.0,0.01,dot(vec2(-1),vec2(dFdx(d),dFdy(d)))));\n        \n        \n    }\n    \n    \n    \n    {\n        // GRAD LINE\n        vec2 p = uv;\n        \n        p.y += 0.38;\n        p.x += 0.35;\n        \n        float bd = sdBox(p - vec2(0,0.06),vec2(0.35,0.02));\n        float bdb = sdBox(p - vec2(0.0,-0.001),vec2(0.35,0.005));\n        \n        \n        float d = abs(bd);\n        \n        //bd = bd + smoothstep(0.001,0.,bd)*smoothstep(-0.2,0.2,p.x)*texture(iChannel0,p).x;\n        \n        d = bd;\n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,d)*smoothstep(0.0,0.24 + sin(iTime)*0.1,smoothstep(-0.3,2.,p.x)*texture(iChannel0,p*0.3).x*2.));\n        d =  abs(bd);\n        \n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,bdb));\n        \n        \n        \n        // botline\n    \n    }\n    uv.x += 0.725 + 0.85;\n\n    \n    {\n        // swirly\n        \n        vec2 p = uv;\n        float sc = 2.5;\n        \n        p.x -= 0.66;\n        p.y -= 0.35;\n        p *= sc;\n        float cd = length(p) - 0.2;\n        cd = sdBox(p,vec2(0.4,0.2));\n        p *= rot(sin((length(p)*1.)*6. + iTime + sin(iTime))*2.);\n        p = vec2(atan(p.x,p.y)/pi,length(p));\n        float fw = fwidth(p.x)/2.;\n        if(cd > 0.0)\n            fw = 0.00;\n        p.x = pmod(p.x,1./3.);\n        \n        float d = cd;\n        d = max(d,-abs(p.x) + 0.1);\n        d /= sc;\n       \n        //float fw = mix(fwidth(d),fwidth(uv.y)*2.,1.);\n        \n        //d = min(d,abs(cd - 0.006 ));\n        col = mix(col,c,smoothstep(fw,0.,(d)));\n        col = mix(col,c,smoothstep(fwidth(cd),0.,abs(cd) - 0.00));\n    \n    }\n    \n    {\n        // SINES\n        float w = 0.001;\n        vec2 p = uv;\n        p -= vec2(0.25,0.23);\n        \n        float bd = sdBox(p,vec2(0.2));\n        bd = mix(bd,length(p) - 0.2,0.5 + 0.5*sin((iTime*pi+sin(iTime*pi))/pi));\n        float outBox = smoothstep(fwidth(uv.y),0.,bd);\n        \n        float d = 10e5;\n        \n        float iters = 20.;\n        for(float i = 0.; i < iters; i++){\n            vec2 q = p + vec2(0.,i/iters*0.45 -0.2);\n            q.y += sin(q.x*4.2 + i*0.2 + iTime + sin(iTime))*0.04*cos(q.x*20. + sin(i + iTime + sin(iTime))*0.7 );\n            d = q.y - w;\n            \n            col = mix(col,c,outBox*smoothstep(fwidth(d),0.,abs(d)-w));\n        \n        }\n        \n        \n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,abs(bd) - w));\n            \n        \n    }\n    {\n        // lines\n        float md = 0.05;\n        vec2 p = uv;\n        p += vec2(-0.76,0.15);\n        \n        p *= rot(0.5*pi);\n        p.x -= p.y*0.;\n        \n        float id = floor(p.x/md);\n        \n        p.x = pmod(p.x,md);\n        \n        float d = abs(p.x) - md*0.4*(sin(id + iTime)*0.5 + 0.5);\n        d = max(d,abs(p.y) -0.02);\n        \n        if(abs(id) < 0.)\n            col = mix(col,c,smoothstep(fwidth(uv.y),0.,abs(d)));\n    }\n    {\n        // CIRCS\n        vec2 p = uv;\n        p.x -= 0.15;\n        p.y += 0.05;\n        float d = 10e5;\n        for(float i = 8.; i>  0.; i--){\n            vec2 q = p + vec2(0.,i/5./5.);\n            q.y *= 3.;\n            d = min(d,(length(q) - 0.2*i/25.*(0.5 + 0.5*sin(iTime + i*1.))) - 0.042);\n            \n        }\n        //col = mix(col,c,smoothstep(fwidth(d),0.,(d) - 0.001));\n        \n        \n    }\n    {\n        // smiley\n        vec2 p = uv;\n        p -= vec2(0.7 + sin(iTime)*0.04,-0.24);\n        p *= 1.5 + sin(iTime + sin(iTime))*0.1;\n        p *= rot(sin(iTime + sin(iTime))*0.2);\n        p -= noiseGrid(vec3(p*12.,1. + iTime*1.))*0.01;\n        \n        float d = length(p) - 0.2;\n        \n        \n        \n        d = max(d, -length(vec2(abs(p.x),p.y)*vec2(1. ,0.4) - vec2(0.05,0.01)) + 0.03);\n        p *= rot(1.*pi);\n        \n        float smile = abs(length(p) - 0.16) - 0.014;\n        vec2 pp = vec2(atan(p.x,p.y)/pi,length(p));\n        \n        float smw = 0.4 + sin(iTime)*0.05;\n        smile = max(smile,abs(pp.x) - smw);\n        \n        smile = min(smile,sdBox(abs(pp) - vec2(smw,0.15 + 0.0125),vec2(0.03,0.02)));\n        d = max(d, - smile);\n        \n        col = mix(col,c,smoothstep(fwidth(d),0.,(d)));\n    }\n    {\n        // TEXT\n        \n        float sc = 2.25;\n        vec2 p = uv - vec2(0.12,-0.2);\n        \n        float b = sdBox(p - vec2(0.21,-0.03),vec2(0.20,0.07));\n        p.x *= 1.;\n        p.y *= 0.95;\n        p *= sc;\n        \n        //float iters = 5.*(sin(iTime*4.)*0.5 + 0.5);\n        float iters = 6.;\n        float lt = 10e5;\n        for(float i = 0.; i < iters; i ++){\n            p.y -= 0.04;\n            float t;\n            \n            //t = text(p, float[8](135.,130.,121.,119.,120.,132.,117.,130.), -0.5 , 0.4 , true, 0., 0.5 , false, i);\n            t = text(p, float[9](131.,120.,113.,116.,117.,130.,114.,127.,121.), -0.5 , 0.4 , true, 0., 0.5 + i/iters*0.1 , false, i);\n            if(i==0.)\n                t = text(p, float[9](131.,120.,113.,116.,117.,130.,114.,127.,121.), -0.5 , 0.4 , false, 0., 0.5 , false, i);\n            \n            t -= 0.004;\n            t /= sc*1.;\n            \n            lt = min(lt,t);\n            \n        }\n        //lt = max(b,-lt);\n        \n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,lt));\n    }\n    {\n        // TEXTB\n        \n        float sc = 3.5;\n        vec2 p = uv - vec2(0.51,0.198);\n        \n        float b = sdBox(p - vec2(0.1675,-0.11),vec2(0.16));\n        p *= sc;\n        float t = 10e5;\n        float iters = 7.;\n        for(float i = 0.; i < iters; i ++){\n            vec2 a = vec2(0.,0.);\n            //if(sin(i))\n            a.x += max(sin(i + 2.6) - 0.5,0.)*1.;\n            vec2 b = vec2(a.x + 0.4 + sin(i + cos(i))*0.1,a.y + 0.);\n            t = min(t, sdSegment(p,a,b) - 0.04);\n            \n            p.y += 0.12;\n            \n        }\n        //lt = max(b,-lt);\n        \n        col = mix(col,c,smoothstep(fwidth(t),0.,t));\n    }\n    {\n        // dots\n        \n        \n        float sc = 1.9;\n        vec2 p = uv - vec2(0.03,-0.33);\n        \n        p *= sc;\n        float t = 10e5;\n        float iters = 7.;\n        for(float i = 0.; i < iters; i ++){\n            vec2 a = vec2(0.,0.6);\n            //if(sin(i))\n            a.y += max(sin(i + 2.6 + iTime) - 0.5,0.)*0.1;\n            vec2 b = vec2(a.x,a.y + 0.);\n            t = xor(t, abs(sdSegment(p,a,b) - 0.01*max(sin(i + iTime*2.),0.4)),0.05*(0.5 + 0.5*sin(i + iTime*5. + sin(iTime + i))) );\n            \n            p.y += 0.12;\n            \n        }\n        //t = xor(-t,-abs(p.x) - 0.02,-0.01);\n        //lt = max(b,-lt);\n        t /= sc;\n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,t));\n    }\n     {\n        // function\n        \n        vec2 p = uv;\n        float sc = 1.;\n        \n        p.x -= 0.33;\n        p.y += 0.3;\n        p *= sc;\n        float cd = length(p) - 0.2;\n        cd = sdBox(p,vec2(0.2,0.1));\n        vec2 q = p;\n        \n        q.x += iTime*0.1;\n        p = q;\n        q = pmod(q + 0.1/6.,0.1/3.);\n        \n        float d = abs(q.x);\n        d = min(d,abs(q.y));\n        \n        \n        //float fn = (p.y+ sin(p.x*10. + asin(sin(p.x*4. + cos(p.x)))*5.)*0.1) ;\n        //float fn = (p.y+ asin(sin(p.x*35. + asin(sin(p.x*10.)*cos(p.x)*2.)))*0.05) ;\n        float fn = (p.y+ asin(sin(p.x*35. + asin(sin(p.x*45.))))*0.05) ;\n        \n        col = mix(col,c,smoothstep(0.001,0.00,cd)*smoothstep(fwidth(fn),0.,abs(fn)-0.004));\n        \n        \n        d = max(d,cd);\n        d /= sc;\n       \n        //float fw = mix(fwidth(d),fwidth(uv.y)*2.,1.);\n        \n        //d = min(d,abs(cd - 0.006 ));\n        d = min(d,abs(cd));\n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,(d)));\n        \n    }\n\n\n\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSGRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 117, 117, 160], [313, 313, 334, 334, 730], [733, 733, 790, 790, 1758]], "test": "untested"}
{"id": "stS3zD", "name": "Eroded mountain terrain (v2)", "author": "jarble", "description": "This terrain generator is very simple, but it makes a realistic-looking landscape.", "tags": ["noise", "terrain", "fbm", "mountain", "erosion"], "likes": 17, "viewed": 926, "published": 3, "date": "1623431278", "time_retrieved": "2024-07-30T19:16:29.895094", "image_code": "#define SC (250.0)\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x)+cos(uv.y);\n}\n\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    uv /= 1.5;\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value = max(value,value+(.25-abs(noise(uv * freq)-.3) * amplitude));\n        \n        amplitude *= .37;\n        \n        freq *= 2.05;\n        \n        uv = uv.yx;\n    }\n    \n    return value*2.0-2.0;\n}\n\nfloat f(in vec3 p)\n{\n    \n    float h = fbm(p.xz);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * iTime;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    if (length(iMouse.xy) > 40.0) {\n        rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stS3zD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 79], [100, 100, 123, 172, 590], [592, 592, 612, 612, 658], [660, 660, 693, 693, 887], [889, 889, 956, 956, 1166], [1168, 1168, 1220, 1220, 1765], [1767, 1767, 1818, 1818, 2019], [2021, 2021, 2047, 2047, 2123], [2192, 2192, 2249, 2249, 4156]], "test": "untested"}
{"id": "NtB3RD", "name": "test audio:correlation in waves2", "author": "FabriceNeyret2", "description": "See sound tab: ( rise gain )\nsound made of 1000 random frequencies between 440 Hz an 880Hz.\nBut all fall in sync at 2\", then every 5\".  Listen, and try switch the random phase variant ( Sound tab, line 14 ).\n", "tags": ["audio", "correlation"], "likes": 8, "viewed": 439, "published": 3, "date": "1623407710", "time_retrieved": "2024-07-30T19:16:30.721882", "image_code": "// rise sound gain if necessary.\n// NB: sound quality degenerate over time because of float precision of time.\n\n// reuse base of https://shadertoy.com/view/7sSXzD\n// variant of https://shadertoy.com/view/fsjSzW\n\n// the interesting part is in the Sound tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n    if (iResolution.y<2000.) {float c=message((u/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){O=vec4(c);return;}}\n\n    \n    vec2 uv = u / iResolution.xy;\n\tO = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// rise sound gain if necessary.\n// NB: sound quality degenerate over time because of float precision of time. fix: https://www.shadertoy.com/view/4ltfRN\n\n#define hash(p)  fract(sin( (p) * 12.9898 ) * 43758.5453) // random\n\n\nvec2 mainSound( int it, float t )\n{\n    float v  = 0., w, A=0., tau = 6.2831853, f, phi;\n    \n    for (float i = 1.; i < 1000.; i++ ) {\n        f = 440.*(1.+ 1.*hash(i));                     // freq fi in Hz\n        phi = 0.;                                      // sync phases\n     // phi = tau*hash(i+.5);                          // random phases\n        w = 1.;                                        // weight for freq fi\n        v +=  cos( tau * f *  (t-2.)  + phi  ) *w;     // weighted wave\n        A += w;                                        // cumul weight for normalization\n    }\n     \n    return vec2(  v / A ); // normalization: std dev = sqrt(A) if decorrelated,\n                           //                max can be A if correlated\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtB3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[640, 640, 663, 710, 889], [891, 891, 932, 932, 1123]], "test": "untested"}
{"id": "flS3RD", "name": "Gradient Utility 2", "author": "Krabcode", "description": "shorter version of my other gradient utility", "tags": ["color", "gradient"], "likes": 1, "viewed": 226, "published": 3, "date": "1623406648", "time_retrieved": "2024-07-30T19:16:31.591557", "image_code": "\nfloat map(float n, float start1, float stop1, float start2, float stop2){\n    return ((n-start1)/(stop1-start1))*(stop2-start2)+start2;\n}\n\nvec3 hexToRgb(int color)\n{\n    float rValue = float(color / 256 / 256);\n    float gValue = float(color / 256 - int(rValue * 256.0));\n    float bValue = float(color - int(rValue * 256.0 * 256.0) - int(gValue * 256.0));\n    return vec3(rValue / 255.0, gValue / 255.0, bValue / 255.0);\n}\n\nconst int COLORS_PER_GRADIENT = 5;\nvec3 gradientColorAt(vec4[COLORS_PER_GRADIENT] gradient, float pct){\n    pct = clamp(pct, 0., 1.);\n    for (int i = 0; i < COLORS_PER_GRADIENT-1; i++){\n        // find which two positions pct is between\n        if (gradient[i].a <= pct && gradient[i+1].a >= pct){\n            // normalize the position between the two closest color positions\n            float norm = map(pct, gradient[i].a, gradient[i+1].a, 0., 1.);\n            // mix the two neighbouring colors in the usual way\n            return mix(gradient[i].rgb, gradient[i+1].rgb, norm);\n        }\n    }\n    // throw red exception \n    return vec3(1, 0, 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // https://colorhunt.co/\n    vec4[] gradient = vec4[](\n        vec4(hexToRgb(0xd9d9d9), 0.),\n        vec4(hexToRgb(0xe88a1a), 0.25),\n        vec4(hexToRgb(0xcf3030), 0.5),\n        vec4(hexToRgb(0x141414), 0.95),\n        vec4(vec3(0), 1.)\n    );\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = gradientColorAt(gradient, fract(uv.y + iTime));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flS3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 74, 74, 138], [140, 140, 166, 166, 424]], "test": "untested"}
{"id": "NtS3RD", "name": "Voronoi graph", "author": "HanShaoqiu", "description": "noise", "tags": ["noise"], "likes": 2, "viewed": 206, "published": 3, "date": "1623406332", "time_retrieved": "2024-07-30T19:16:32.856176", "image_code": "vec2 N22(vec2 p){\n\tvec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n\ta+=dot(a,a+100.45);\n\treturn fract(vec2 (a.x*a.y ,a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec4 col = vec4(1.0);\n    //col = texture(iChannel0,uv);\n    float m = 0.0;\n\tfloat t = iTime;\n\tfloat minDist = 10.0;\n\tfloat cellIndex = 0.0 ;\n    vec2 uv1  = uv *10.0 ;\n\tvec2 gv = fract(uv1);\n\tvec2 id = floor(uv1);\n\n\tfor(int x =-1 ; x<=1 ; x++){\n\t\tfor(int y =-1 ; y<=1 ; y++){\n\t\t vec2 offs = vec2 (x,y);\n\t\t\tvec2 n = N22(id+offs);\n\t\t\tvec2 p = sin(n*t*5.0)*0.5+0.5+offs;\n\t\t\tfloat d = length (gv-p);\n\t\t\tif(d<minDist){\n\t\t\t\tminDist = d;\n\t\t\t}\n\n\t\t}\n\t}\n    col *= minDist;\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3RD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 131], [133, 133, 190, 240, 795]], "test": "untested"}
{"id": "ftB3RW", "name": "noise texture learn", "author": "HanShaoqiu", "description": "noise texture sample", "tags": ["noise"], "likes": 7, "viewed": 446, "published": 3, "date": "1623394595", "time_retrieved": "2024-07-30T19:16:33.704907", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float noisetex = texture(iChannel1,uv+vec2(iTime*0.1,0.0)).r;\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv+vec2(noisetex,0.0)).xyz;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftB3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 368]], "test": "untested"}
{"id": "NtS3RW", "name": "scroll background", "author": "HanShaoqiu", "description": "scroll texture", "tags": ["scroll"], "likes": 0, "viewed": 224, "published": 3, "date": "1623393592", "time_retrieved": "2024-07-30T19:16:34.457893", "image_code": "float speedX = 0.5;\nfloat speedY = 0.5;\nbool isVertical = false;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    //\n    if(isVertical){\n        // horizontal scroll\n        col = texture(iChannel0,uv+vec2(iTime*speedX,0.0*speedY)).xyz;\n    }else{\n        // vertical scroll\n        col = texture(iChannel0,uv+vec2(0.0*speedX,iTime*speedY)).xyz;\n    }\n\n    \n    // Output to screen\n    fragColor = vec4(col.x,0.0,0.0,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtS3RW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 122, 172, 541]], "test": "untested"}
{"id": "st23z1", "name": "Warping Grid", "author": "oneshade", "description": "Warped.", "tags": ["texture", "warp", "bilinear", "piecewise"], "likes": 14, "viewed": 483, "published": 3, "date": "1623388309", "time_retrieved": "2024-07-30T19:16:35.208885", "image_code": "#define SCALE 4.0\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 10.0 - 5.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n    float t = iTime * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n// Get UV coordinates in a bilinear patch (requires solving a quadratic)\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nbool iBilinear(in vec2 xy, in vec2 a, in vec2 b, in vec2 c, in vec2 d, out vec4 uv) {\n    vec2 p = a - b + c - d;\n    vec2 q = b - a, r = d - a;\n\n    float c1 = cross2D(r, p);\n    float c2 = cross2D(r, q) + cross2D(a, p) + cross2D(p, xy);\n    float c3 = cross2D(a, q) + cross2D(q, xy);\n\n    float discr = c2 * c2 - 4.0 * c1 * c3;\n    if (discr > 0.0) {\n        uv.yw = (vec2(-1.0, 1.0) * sqrt(discr) - c2) / c1 * 0.5;\n        uv.xz = (xy.x - a.x - r.x * uv.yw) / (p.x * uv.yw + q.x);\n        return true;\n    }\n\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * SCALE;\n    float unit = 2.0 * SCALE / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 cell = floor(uv);\n    vec2 centerPoint = getPoint(cell);\n    for (int i=-1; i <= 1; i++) {\n        for (int j=-1; j <= 1; j++) {\n            if (abs(i) != abs(j)) {\n                // Draw lines to the right, left, top, and bottom cell points\n                vec2 edgePoint = getPoint(cell + vec2(i, j));\n                color += smoothstep(unit, 0.0, sdLine(uv, centerPoint, edgePoint));\n            }\n\n            if (i <= 0 && j >= 0) {\n                vec4 patchUv;\n\n                // Cells and their vertices\n                vec2 c1 = cell + vec2(i    , j - 1), v1 = getPoint(c1);\n                vec2 c2 = cell + vec2(i + 1, j - 1), v2 = getPoint(c2);\n                vec2 c3 = cell + vec2(i + 1, j    ), v3 = getPoint(c3);\n                vec2 c4 = cell + vec2(i    , j    ), v4 = getPoint(c4);\n\n                // Draw the current warped cell\n                if (iBilinear(uv, v1, v2, v3, v4, patchUv)) {\n                    if (all(lessThan(abs(patchUv.zw - 0.5), vec2(0.5)))) {\n                        vec2 texUv = (iResolution.y / SCALE * (c1 + patchUv.zw) + center) / iResolution.xy;\n                        color += texture(iChannel0, texUv).rgb;\n                    }\n                }\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 60, 86, 86, 172], [174, 199, 228, 228, 511], [513, 513, 560, 560, 668], [670, 743, 780, 780, 812], [813, 813, 898, 898, 1344], [1346, 1346, 1401, 1401, 2853]], "test": "untested"}
{"id": "7t2Gz1", "name": "Heat Spreader", "author": "itishappy", "description": "oh fuck yeah, spread it\nthis cheats. badly. looks pretty good tho!", "tags": ["heat"], "likes": 1, "viewed": 104, "published": 3, "date": "1623388156", "time_retrieved": "2024-07-30T19:16:36.046646", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n\tfragColor = vec4(color.xyz, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float gaussian_avg(vec2 xy, float heat) { //A trick to approximate a guassian\n    float neighbors = -3.*heat; // (black magic)\n    for(float i=-1.; i<=1.; i+=1.) {\n        for(float j=-1.; j<=1.; j+=1.) {\n        \tvec2 offset = vec2(i,j) / iResolution.xy;\n            float m = 3. - abs(i) - abs(j); // (black magic)\n        \tneighbors += m * texture(iChannel0, xy+offset).a; // Accumulate the result\t\t\t\t\t\t\t \n        }\n    }\n    return neighbors / 12.; // (black magic) Turn the sum into an avg\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\n    float heat = texture(iChannel0, xy).a;\n    \n    float avg = gaussian_avg(xy, heat);\n    \n    float alpha = 0.3;\n    \n    heat = alpha*avg + (1.-alpha)*heat; // This is probably cheating\n    \n    if(iTime < .1) { // Show iChannel1 for an instant\n        vec4 tex = texture(iChannel1, fragCoord.xy / iResolution.xx);\n        heat = dot(tex, vec4(.2126,.7152,.0722,0.)); // Relative luminance\n    }\n    \n    vec3 col = vec3(heat,0.,0.); // pick a fun color here\n\n    // Output to screen\n    fragColor = vec4(col,heat); // use the value for heat as alpha\n    \n}\n\n\n\n// Change the texture in iChannel1 for different inputs", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2Gz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 177]], "test": "untested"}
{"id": "tdcBRN", "name": "Mandelbrot I", "author": "itishappy", "description": "fractal", "tags": ["fractal"], "likes": 0, "viewed": 103, "published": 3, "date": "1623388103", "time_retrieved": "2024-07-30T19:16:36.840523", "image_code": "#define i_max 512.\n#define escape 4.\n#define gamma .6\n\nvec2 isq(vec2 z) { // square of a complex number: s=z^2\n    vec2 s;\n    s.x = z.x*z.x - z.y*z.y; // real part: x^2-y^2\n    s.y = 2. * z.x * z.y;    // imag part: 2xy\n    return s;\n}\n\nfloat mandel(vec2 c) { // mandelbrot set: does f(z)=z^2+c diverge? iterations until |z|>escape\n    vec2 z = vec2(0.);          // z_0 = 0\n    float i;\n    for (i=0.; i<i_max; i++) {\n\t\tz = isq(z) + c;         // f(z)=z^2+c\n        if (length(z) > escape) // |z|>escape\n            return i + 1. - log(log(length(z)))/log(2.);\n    }\n    return 0.;\n}\n\nmat2 rot(float a) { // rotation by angle a: used by the camera\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // aspect ratio\n    vec2 z = 2.*(2.*fragCoord-iResolution.xy)/length(iResolution.xy);\n    \n    // magic camera stuff\n    z += vec2(-.25, 0.);\n    z *= rot(.2*sin(.17*iTime));\n    z += vec2(-.25, 0.);\n    z *= 0.8+0.2*sin(0.03*iTime);\n    \n    // the magic\n    float m = mandel(z)/i_max;\n    \n    // attept at exposure\n    fragColor = vec4(vec3(pow(m,gamma)),10.);\n}\n\n// hmmmm...\n// how do complex numbers exponentiate???\n// I think I can eek more contrast out if I use s=z^x where x is slightly < 2\n// NOPE, that doesn't do what I expected, changing the exponent \"unwraps\" the fractal", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 73, 110, 236], [238, 238, 260, 332, 585], [587, 587, 606, 649, 701], [703, 703, 760, 780, 1130]], "test": "untested"}
{"id": "st2GR1", "name": "Vorochet I", "author": "oneshade", "description": "WIP", "tags": ["voronoi", "truchet", "tiling", "connections"], "likes": 11, "viewed": 138, "published": 3, "date": "1623379230", "time_retrieved": "2024-07-30T19:16:37.756075", "image_code": "// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat Hash31(in vec3 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float time = 2.0;//iTime\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 3.0 + 1.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n    float t = time * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\n// https://www.shadertoy.com/view/7dSSW1\n#define ID_POS(x) clamp(abs(4.-8.*fract(vec2(x+3,x-3)/8.))-2.,-1.,1.)\nvec2 intersect(vec2 p0, vec2 n0, vec2 p1, vec2 n1) {\n    float d = n0.x * n1.y - n0.y * n1.x; // 0 if paralelle but does not append here\n    vec2 p = (p0 - p1) / d;\n    return vec2(p.y * n1.x - p.x * n1.y, p.y * n0.x - p.x * n0.y);\n}\n\nvec2[8] getVoronoiPolygon(in vec2 cellId, out int out_sz) {\n\tvec2 rm = getPoint(cellId); // center of cell\n    vec2 c[8], n[8];\n    // Get liste of lines\n    for(int i=0; i < 8; i++) {\n        vec2 g0 = ID_POS(i),\n             r0 = getPoint(cellId + g0),  // centre de l'autre cellule\n             n0 = r0 - rm;\n         c[i] = rm + n0*.5;  // Pt entre les 2 cellules             \n         n[i] = normalize(vec2(-n0.y,n0.x));\n    }\n\n    // Find intersection between lines\n    vec4 seg[8]; // x:-2 y:-1 z:+1 w:+2  \n    for(int i=2; i < 10; i++) { // Intersection point with two previous lines\n        vec2 t1 = intersect(c[i % 8], n[i % 8], c[(i - 1) % 8], n[(i - 1) % 8]),\n             t2 = intersect(c[i % 8], n[i % 8], c[(i - 2) % 8], n[(i - 2) % 8]);\n        seg[i % 8].x = t2.x;     // -2 of seg  0\n        seg[i % 8].y = t1.x;     // -1 of seg  0\n        seg[(i - 1) % 8].z = t1.y; // +1 of seg -1\n        seg[(i - 2) % 8].w = t2.y; // +2 of seg -2      \n    }\n\n    // Reconstruct the polygon\n    out_sz = 0;\n    for(int i=0; i<8; i++) {\n        float dmin = max(seg[i].z, seg[i].w);\n        if (dmin < min(seg[i].x, seg[i].y)) { // skip useless segments\n            n[out_sz] = c[i] + dmin * n[i];\n            out_sz++;\n        }\n    }\n\n    return n;\n}\n\nfloat sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec2 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec2 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float zoom = mix(2.0, 10.0, 0.5 + 0.5 * cos(0.25 * iTime));\n    float fade = 0.5 + 0.5 * sin(iTime);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * zoom + 0.5 * iTime;\n    float unit = 2.0 * zoom / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 cell = floor(uv), closest;\n    float minDist = 1e20;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curPoint = getPoint(cell + vec2(i, j));\n            vec2 toCurPoint = uv - curPoint;\n            float curDist = dot(toCurPoint, toCurPoint);\n            if (curDist < minDist) { closest = curPoint; minDist = curDist; }\n        }\n    }\n\n    int numVerts;\n    vec2 closestCell = floor(closest);\n    vec2[8] voroPoly = getVoronoiPolygon(closestCell, numVerts);\n    for (int n=0; n < numVerts; n++) {\n        int randEdge = int(Hash31(vec3(closestCell, n)) * float(numVerts));\n        if (randEdge == n) randEdge = (randEdge + 1) % numVerts;\n\n        vec2 rand1 = voroPoly[randEdge], rand2 = voroPoly[(randEdge + 1) % numVerts];\n        vec2 v1 = voroPoly[n], v2 = voroPoly[(n + 1) % numVerts];\n\n        vec2 nor1 = normalize(v2 - v1).yx * vec2(-1.0, 1.0);\n        vec2 nor2 = normalize(rand2 - rand1).yx * vec2(-1.0, 1.0);\n\n        vec2 a = 0.5 * (v1 + v2), c = 0.5 * (rand1 + rand2);\n        vec2 b = a + nor1 * (c.y * nor2.x - c.x * nor2.y + nor2.y * a.x - nor2.x * a.y) / (nor1.y * nor2.x - nor1.x * nor2.y);\n        //vec2 b = 0.5 * (a + c) + normalize(c - a).yx * vec2(1.0, -1.0);\n        //vec2 b = closest;\n\n        color = max(color, vec3(smoothstep(unit, 0.0, sdBezier(uv, a, b, c))));\n        color.b = max(color.b, smoothstep(unit, 0.0, sdLine(uv, v1, v2) - 0.01) * fade);\n    }\n\n    color.rg = max(color.rg, 0.6 * Hash22(closestCell) * fade);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2GR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 67, 67, 153], [155, 155, 180, 180, 275], [277, 277, 301, 301, 436], [438, 463, 492, 492, 802], [915, 915, 967, 967, 1148], [2410, 2410, 2473, 2473, 3686], [3688, 3688, 3735, 3735, 3843]], "test": "untested"}
{"id": "st23zh", "name": "Voxel ascent", "author": "jarble", "description": "Alternative version of: https://www.shadertoy.com/view/7lj3zz", "tags": ["voxel", "tiny"], "likes": 4, "viewed": 240, "published": 3, "date": "1623376539", "time_retrieved": "2024-07-30T19:16:38.555936", "image_code": "bool voxel_thing(ivec4 b){\n//b.y += b.y%20;\nreturn (b.x>>b.y<<b.z)%(95)<99-b.z;\n}\n\nbool voxel_thing1(ivec4 b){\n    //b.z += int(1.0);\n    b.y += int(iTime*20.0);\n    b.x += int(12.0);\n    return voxel_thing(b) && voxel_thing(ivec4(b.yxz,b.w));\n}\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    o = vec4(0);\n    for(ivec4 b;voxel_thing1(b);)\n    b = ivec4((u/iResolution.y-.5)*o.a-20.0,o+=.1);\n    o /= vec4(1e2,4e3/o);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 43, 81], [83, 83, 110, 133, 245], [247, 247, 282, 282, 413]], "test": "untested"}
{"id": "7t2Gzh", "name": "Voxel filaments", "author": "jarble", "description": "Alternative version of: https://www.shadertoy.com/view/7lj3zz", "tags": ["voxel", "tiny"], "likes": 9, "viewed": 234, "published": 3, "date": "1623374097", "time_retrieved": "2024-07-30T19:16:39.420625", "image_code": "//<200 chars playlist: https://www.shadertoy.com/playlist/N3lGDN\n\n//Remix of: https://www.shadertoy.com/view/7lj3zz\n\nvoid mainImage(out vec4 o,vec2 u)\n{\n    u=u/iResolution.y/.8-.6;\n    for(ivec4 b=ivec4(o-=o);(b.x<<b.y>>b.z)%90<99-b.z;)\n    b = ivec4(u*o.a+iTime*vec2(9,2),o+=.1);\n    o /= 1e2/(++u).xyyx;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2Gzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 152, 152, 308]], "test": "untested"}
{"id": "st23Rh", "name": "RGB-MNCA - Infection Model", "author": "SlackermanzCA", "description": "Continuous 3-Channel MNCA with infectious spreading / virus-like mechanics\n\nhttps://old.reddit.com/r/cellular_automata/comments/nwwrkk/cellular_automata_with_infection_viruslike/\n\nhttps://twitter.com/slackermanz/status/1402823375190335488\n\n", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 5, "viewed": 492, "published": 3, "date": "1623370573", "time_retrieved": "2024-07-30T19:16:40.397014", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch( iChannel0, ivec2(gl_FragCoord[0], gl_FragCoord[1]), 0); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n#define PATTERN_SCALE 80.410011;\n\nconst uint MAX_RADIUS = 10u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\nfloat vwm()\t\t\t\t\t\t\t{ return PATTERN_SCALE; }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\nvec4 sigm(vec4 x, float w)          { return 1.0 / ( 1.0 + exp( (-w*2.0 * x * (PI/2.0)) + w * (PI/2.0) ) ); }\n    \nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\tfloat\tw = 1.0;\n\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\treturn a; }\n    \nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4 \tb = vec4(0.0,0.0,0.0,0.0);\n\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\tfloat\tw = 1.0;\n\t\t\tif( d <= r[0] && d > r[1] ) { b\t+= w * psn * 4.0; } } }\n\treturn b; }\n                \nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sigm(sum / tot, 4.0); }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    //\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  48.0 *  96.0;\n\tconst\tfloat \tn  \t\t= mnp *  48.0 *  16.0;\n    \n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n    \n    //\tNH Rings\n\tvec4[MAX_RADIUS] nh_rings_c_a;\n\tvec4[MAX_RADIUS] nh_rings_c_b;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tnh_rings_c_a[i] = nbhd( vec2(i+1u,i), txdata );\n\t\tnh_rings_c_b[i] = totl( vec2(i+1u,i), txdata ); }\n        \n    uint[12] NB = uint[12] (\n\t\t3461377796u, 417041638u, 562996052u, 1549794173u, \n\t\t1495856055u, 1041496622u, 536250637u, 472037485u, \n\t\t3347829930u, 759088187u, 2271176131u, 2130531014u );\n        \n    uint[24] UD = uint[24] (\n\t\t2522012616u, 3290110019u, 336085056u, 2382018599u, \n\t\t527806221u, 479867126u, 402941850u, 1967187242u, \n\t\t1645556923u, 1970514032u, 2013473316u, 2999218822u, \n\t\t1048736860u, 2044738396u, 1856371338u, 2153056504u, \n\t\t642195440u, 1998706351u, 88009286u, 2267559354u, \n\t\t977837465u, 1159951795u, 631346943u, 14962785u   );\n        \n    uint[ 2] SN = uint[ 2] (\n\t\t1431655765u, 1431655765u                            );\n\n\tuint[ 3] IO = uint[ 3] (\n\t\t2286157824u, 295261525u, 1713547946u                );\n\n\n    for(uint i = 0u; i < 24u; i++) {\n\t\tfloat nhv = bitring( nh_rings_c_a, nh_rings_c_b, NB[i/2u], (i & 1u) * 16u )[u32_upk( IO[i/8u], 2u, (i*4u+0u) & 31u )];\n\t\tif( nhv >= utp( UD[i], 8u, 0u) && nhv <= utp( UD[i], 8u, 1u)) { res_c[u32_upk( IO[i/8u], 2u, (i*4u+2u) & 31u )] += bsn(SN[i/16u], ((i*2u+0u) & 31u))*s; }\n\t\tif( nhv >= utp( UD[i], 8u, 2u) && nhv <= utp( UD[i], 8u, 3u)) { res_c[u32_upk( IO[i/8u], 2u, (i*4u+2u) & 31u )] += bsn(SN[i/16u], ((i*2u+1u) & 31u))*s; } }\n    \n\tres_c -= n;\n    res_c  = clamp(res_c,0.0,1.0);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 36.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0); res_c[1] = reseed(1); res_c[2] = reseed(2); }\n    fragColor=res_c;\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23Rh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1055, 1141]], "test": "untested"}
{"id": "fl2Gzh", "name": "Genuine gradient noise 2D", "author": "GenuineIntelligence", "description": "A genuine implementation of the gradient noise (aka Perlin noise).\nHere is the most comonly found version of the gradient noise,\nThe octave sum create a gradient fractional brownian motion.\nTo see the raw gradient noise, set nb_octave to 1", "tags": ["noise", "perlin", "gradient", "genuine"], "likes": 4, "viewed": 344, "published": 3, "date": "1623354303", "time_retrieved": "2024-07-30T19:16:41.441222", "image_code": "/* Copyright © 2021 by Arthur Cavalier, Théo Jonchier, Thibault Tricard\nThis work is free. You can redistribute it and/or modify it under the\nterms of the Do What The Fuck You Want To Public License, Version 2,\nas published by Sam Hocevar. See the COPYING file or http://www.wtfpl.net/ \nfor more details.*/\n\n/** INPUT PARAMETERS */\n\n#define scale 0.2\n#define nb_octaves 5\n\n/** @brief Generates a random 2D vector */\nvec2 random_2_2(vec2 p)\n{\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283);\n}\n\n/** @brief improved version of the smoothstep fucntion which garantees \n    zero 1st and 2nd order derivative at its end points (0 and 1) */\nfloat smootherstep(float t) \n{ \n    return t * t * t * (t * (t * 6. - 15.) + 10.); \n}\n\n/** @brief gradient noise */\nfloat gradientNoise(vec2 pos)\n{\n    vec2 fr = fract(pos);\n    vec2 fl = floor(pos);\n    \n    vec2 AA= fl;\n    vec2 AB= fl  + vec2(1,0);\n    vec2 BA= fl  + vec2(0,1);\n    vec2 BB= fl  + vec2(1,1);\n    \n    // we sample random vectors on a regular grid latices\n    //\n    //  AA-----------AB\n    //   |           |\n    //   |           |\n    //   |    pos    |\n    //   |           |\n    //   |           |\n    //  BA-----------BB\n    vec2 rAA = random_2_2(AA);\n    vec2 rAB = random_2_2(AB);\n    vec2 rBA = random_2_2(BA);\n    vec2 rBB = random_2_2(BB);\n    \n    // we compute de dot product between \n    // the unit vectors\n    // and the vector from the sample \n    // to the po regular grid position\n    float dAA = dot(rAA, fr);\n    float dAB = dot(rAB, fr-vec2(1,0));\n    float dBA = dot(rBA, fr-vec2(0,1));\n    float dBB = dot(rBB, fr-vec2(1,1));\n    \n    // bilinear interpolation of the value to reduce the grid \n    // artifact we smooth the interpolation weight.\n    fr.x = smootherstep(fr.x);\n    fr.y = smootherstep(fr.y);\n    \n    float d_AA_AB = mix(dAA,dAB,fr.x);\n    float d_BA_BB = mix(dBA,dBB,fr.x);\n\n    return mix(d_AA_AB,d_BA_BB,fr.y) +0.5;\n}\n\n/** @brief fractional brownian motion */\nfloat fbm(vec2 uv)\n{\n    float noise = 0.0;\n    float weights = 0.0;\n    \n    // sum of the value octaves\n    for(int i = 0; i< nb_octaves; i++){\n        // octave frequency\n        float freq = 0.0625 *  pow(2.0,float(i+1));\n        // octave weight\n        float weight = pow(2.0,-float(i+1));\n        \n        // sum of the octave times the weight\n        noise += gradientNoise(uv* freq)*weight;\n        // sum of the weight\n        weights += weight;\n    }\n    \n    // return the sum of octaves divided by the sum of the weight\n    return noise /weights;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // we sample the fractional brownian motion at a point\n    // we shift it from the origin to avoid artefacts\n    float value = fbm(fragCoord * scale  + vec2(97,89)) ;\n    \n    fragColor = vec4(value);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2Gzh.jpg", "access": "api", "license": "wtfpl-2.0", "functions": [[375, 418, 443, 443, 555], [557, 698, 728, 728, 783], [785, 814, 845, 845, 1976], [1978, 2019, 2039, 2039, 2580], [2583, 2583, 2640, 2753, 2847]], "test": "untested"}
{"id": "7tBGz1", "name": "Byzantine Buffering", "author": "paniq", "description": "A fluidly subdividing reaction/diffusion field. Use the mouse to control the zoom.", "tags": ["scaling", "cellularautomaton"], "likes": 34, "viewed": 656, "published": 3, "date": "1623339348", "time_retrieved": "2024-07-30T19:16:42.436562", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = iMouse.xy / iResolution.xy;\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    float m = float(iFrame % R) / float(R);  \n    uv -= C;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv / (1.0 + 0.1*dot(uv,uv));\n    uv.x /= iResolution.x / iResolution.y;\n    uv *= exp(mix(log(1.0),log(0.5),m));\n    float f = 0.004;\n    vec2 uv3 = uv * exp(0.0) + C;\n    vec2 uv2 = uv * exp(-f) + C;\n    vec2 uv1 = uv * exp(-f*2.0) + C;\n    float r = texture(iChannel0, uv1).r*0.5+0.5;\n    float g = texture(iChannel0, uv2).r*0.5+0.5;\n    float b = texture(iChannel0, uv3).r*0.5+0.5;    \n    fragColor = vec4(pow(vec3(r,g,b), vec3(0.5)),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec4 process(vec2 c) {\n    vec2 sz = iChannelResolution[0].xy;\n    vec4 v0 = texture(iChannel0, (c + vec2(-1,0)) / sz);\n    vec4 v1 = texture(iChannel0, (c + vec2( 1,0)) / sz);\n    vec4 v2 = texture(iChannel0, (c + vec2(0,-1)) / sz);\n    vec4 v3 = texture(iChannel0, (c + vec2(0, 1)) / sz);    \n    vec4 v4 = texture(iChannel0, c / sz);\n    float w = ((iFrame % 2) == 0)?0.367879:3.0;\n    float k = (1.0 - w) / 4.0;    \n    return w * v4 + k * (v0 + v1 + v2 + v3); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 C = iMouse.xy / iResolution.xy;\n    if (iFrame == 0) {\n        vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;        \n        uv.x *= iResolution.x / iResolution.y;\n        float c0 = length(uv) - 0.5;\n        float c1 = length(uv - vec2(0.0,0.25));\n        float c2 = length(uv - vec2(0.0,-0.25));\n        float d = max(min(max(c0, -uv.x),c1-0.25),-c2+0.25);        \n        d = max(d, -c1+0.07);\n        d = min(d, c2-0.07);\n        d = min(d, abs(c0)-0.01);\n        float w = sign(d) * sin(c0*80.0);\n        fragColor = vec4(w);\n    } else if ((iFrame % R) == 0) {\n        vec2 c = vec2(fragCoord / iResolution.xy);\n        fragColor = texture(iChannel0, (c - C) / 2.0 + C);\n    } else {\n        vec4 s = process(fragCoord);\n        fragColor = clamp(s, -1.0, 1.0);\n    }    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int R = 360;\n\n//const vec2 C = vec2(0.5, 0.0);\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 707]], "test": "untested"}
{"id": "slSGz1", "name": "Day 539", "author": "jeyko", "description": "potatester", "tags": ["design", "poster", "mdtmjvm", "acidgraphics"], "likes": 21, "viewed": 479, "published": 3, "date": "1623338157", "time_retrieved": "2024-07-30T19:16:43.525649", "image_code": "float sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 6.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    n = sin(n*2.);\n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    fragCoord += 650.*noise(vec3(uv*0.5,5.))/iResolution.xy;\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n\n    col += smoothstep(0.,5.,max(noise(vec3(uv*2.,5.)) - 0.5,0.))*0.25;\n    \n    \n    float n1d = texelFetch(iChannel2,ivec2(mod(fragCoord + vec2(float(iFrame),0.),256.)),0).x;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(fragCoord + n1d*200. ,256.)),0).xyz;\n    \n    \n    //C = smoothstep(0.,1.,C);z\n    \n    //col.xyz = pow(max(col.xyz,0.), vec3(0.55) + n*0.1);\n    \n    \n    \n    col = pow(max(col,0.),vec3(0.4545));\n\n    col.xyz += smoothstep(1.,0.,length(col))*n*0.15;\n    \n    col.xyz -= smoothstep(0.,1.,length(col))*n*0.05;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "buffer_a_code": "float sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    char -= 32. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,-(iTime + sin(iTime))*0.2);\n    for(float i = 0.; i < 6.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.+iTime*1.5) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    return n;\n}\n\n\nfloat noiseGrid(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    for(float i = 0.; i <2.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.5;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    return n;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 c = vec3(0.97,0.01,0.04)*0.7;\n    \n\n    uv.x += 0.025;\n\n    {\n        // planet\n        vec2 p = uv;\n        \n        p.y -= 0.;\n        p.x += 0.35;\n        \n        float bd = length(p) - 0.2;\n        \n        \n        float d = abs(bd);\n        \n        //bd = bd + smoothstep(0.001,0.,bd)*smoothstep(-0.2,0.2,p.x)*texture(iChannel0,p).x;\n        \n        d = -bd;\n        \n        float bdb = sdBox(p,vec2(0.44));\n        \n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,bdb)*smoothstep(fwidth(uv.y),0.,d)*smoothstep(0.0,0.04,smoothstep(-0.3,2. - noise(vec3(uv*4.,iTime))*0.6,d)*texture(iChannel0,p*0.3).x*2.));\n        \n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,abs(bdb) - 0.001));\n            \n        \n        //d =  abs(bd);\n        \n        //col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n        \n    \n    }\n    \n    uv.x -= 0.05;\n        {\n        // CIRCS\n        vec2 p = uv;\n        p -= vec2(0.5,-0.4);\n        float sc = 2.;\n        p *= sc;\n        \n        p.x = abs(p.x) - 0.5;\n        \n        float d = 10e5;\n        \n        #define xor(a,b,c) min(max(a,-(b) + c),max(b,-(a)))\n        for(float i = 0.; i < 7.; i++){\n            //d = min(d,abs(length(p - vec2(i*0.1,0.)) - 0.1));\n            d = xor(d,abs(length(p - vec2(i*0.07,0.)) - 0.04*(0.5 + 0.5*sin(i+iTime*3. + sin(iTime + i)))), (8.-i)/150.);\n        \n        }\n        d -= 0.005;\n        d /= sc;\n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n    }\n    \n    \n    {\n        // GRAD LINE\n        vec2 p = uv;\n        \n        p.y -= 0.34;\n        p.x -= 0.5;\n        \n        float bd = sdBox(p - vec2(0,0.05),vec2(0.3,0.05));\n        \n        \n        float d = abs(bd);\n        \n        //bd = bd + smoothstep(0.001,0.,bd)*smoothstep(-0.2,0.2,p.x)*texture(iChannel0,p).x;\n        \n        d = bd;\n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,d)*smoothstep(0.0,0.24 + sin(iTime)*0.1,smoothstep(-0.3,2.,p.x)*texture(iChannel0,p*0.3).x*2.));\n        d =  abs(bd);\n        \n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n        {\n            vec2 q = p;\n            q.y += 0.065;\n            float qd = sdBox(q,vec2(0.3,0.01));\n            float md = 0.02;\n            float id = floor(q.x/md);\n            q.x = pmod(q.x,md);\n            q.x += sin(id + iTime)*md*0.5;\n            //qd = max(qd,-abs(q.x) + 0.01);\n            //p.x = pmod(p.x,0.2);\n            //bd = xor(bd,abs(length(p) - 0.03) - 0.001,0.02);\n            col = mix(col,c,smoothstep(fwidth(uv.y),0.,qd));\n        \n        }        \n        {\n            vec2 q = p;\n            q.y += 0.435;\n            float qd = sdBox(q,vec2(0.3,0.01));\n            float md = 0.02;\n            float id = floor(q.x/md);\n            q.x = pmod(q.x,md);\n            q.x += sin(id + iTime)*md*0.5;\n            //qd = max(qd,-abs(q.x) + 0.01);\n            //p.x = pmod(p.x,0.2);\n            //bd = xor(bd,abs(length(p) - 0.03) - 0.001,0.02);\n            col = mix(col,c,smoothstep(fwidth(uv.y),0.,qd));\n        \n        }\n        \n        \n        // MIDLINE\n    \n    }\n    {\n        // text\n        float sc = 1.4;\n        vec2 p = uv - vec2(0.2,0.16);\n        p *= sc;\n        //float iters = 5.*(sin(iTime*4.)*0.5 + 0.5);\n        float iters = 5.;\n        \n        for(float i = 0.; i < iters; i ++){\n            p.y += 0.06;\n            float t;\n            \n            t = text(p, float[8](135.,130.,121.,119.,120.,132.,117.,130.), -0.5 , 0.4 , true, 0., 0.5 , false);\n            \n            if(i == 0.){\n                t = text(p, float[8](135.,130.,121.,119.,120.,132.,117.,130.), -0.5 , 0.4 , false, 0., 0.5 , false);\n            } else {\n            \n            }\n            t -= 0.004;\n            t /= sc;\n            if(mod(-iTime*4. + i,5.) > 1. || i == 0.)\n                col = mix(col,c,smoothstep(fwidth(uv.y),0.,t));\n        }\n                \n    }\n    {\n        // dots\n        vec2 p = uv;\n        p -= vec2(0.28,-0.25);\n        float d = 10e5;\n        for(float i = 0.; i < 74.; i++){\n            float k = i*0.2;\n            vec2 o = vec2(\n                cos(k + iTime)*cos(k*1.5 - iTime), sin(k*1. + iTime)\n            )*0.06;\n            \n            d = min(d,length(p - o) - 0.002);\n        }\n        col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n        \n    }\n    {\n        // circs\n        vec2 p = uv;\n        p -= vec2(0.438,-0.25);\n        float d = 10e5;\n        float iters = 6.;\n        for(float i = 0.; i < iters; i++){\n            \n            vec2 q = p;\n            //d = min(d,length(p - o) - 0.002);\n            q.xy *= rot(0.1 + i + iTime+ sin(iTime + i));\n            \n            d = length(q) - 0.07*i/iters;\n            d = abs(d) - 0.00;\n            \n            d = max(d,-abs(q.y) + 0.01);\n            d -= 0.001;\n            col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n    \n        }\n    {\n        // dots\n        vec2 p = uv;\n        p -= vec2(0.11,-0.25*0.);\n        float md = 0.025;\n        p.y += md*0.5;\n        vec2 id = floor(p/md);\n        p = pmod(p,md);\n        if(abs(id.x) < 2. && abs(id.y) < 18.){\n                float d = abs(p.x);\n        \n                if(noise(vec3(id,iTime*0.5)) < 0.2)\n                    d = min(d,length(p) - md*0.25);\n                \n                col = mix(col,c,smoothstep(fwidth(uv.y),0.,d));\n        }\n        \n        \n        }\n    }\n\n    {\n        // grid\n        vec2 p = uv;\n        p -= vec2(0.655,-0.25);\n        float md = 0.015;\n        vec2 res = vec2(9,5);\n        \n        float db = sdBox(p - vec2(0.5,0.)*md,(res - 0.5)*md);\n        \n        float n = noiseGrid(vec3(p.xy*10.,iTime*2.5));\n        p += n*0.01*smoothstep(0.0,-0.05,db);\n        p.y += md*0.5;\n        vec2 id = floor(p/md);\n        float fw = fwidth(p.x);\n        p = pmod(p,md);\n        p = abs(p) - md*0.5;\n        float d = abs(p.x);\n        d = min(d,abs(p.y));\n        d = max(d,db);\n        d = min(d,abs(db));\n        d -= 0.001;\n        col = mix(col,c,smoothstep(fw,0.,d));\n        \n        \n    }\n\n\n\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSGz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 71], [224, 224, 245, 245, 641], [644, 644, 701, 701, 1483]], "test": "untested"}
{"id": "ftS3z1", "name": "Day 538", "author": "jeyko", "description": "potatete", "tags": ["glass", "transparent", "design", "mograph", "mdtmjvm"], "likes": 18, "viewed": 411, "published": 3, "date": "1623309496", "time_retrieved": "2024-07-30T19:16:44.416268", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat env = 0.;\n\n\nfloat map(vec3 p){\n    p.xz *= rot(env + iTime);\n    p.yz *= rot(sin(iTime));\n    \n    //d = min(length(p.xy),length(p.zx));\n    //d = min(d,length(p.zy)) - 0.1;\n    \n    float e = env;\n    float db = sdBox(p,vec3(0.5) - sin(e)*0.1) - 0.07; \n    //p = pmod(p,0.4);\n    \n    float d = length(p) - 0.4 + sin(iTime)*0. + sin(e)*0.1;\n    //d = max(db,-d);\n    d = opSmoothSubtraction( d, db, 0.4 );\n    //d = abs(d) - 0.001;\n    return d;\n}\n\n\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.004,0.);\n    return normalize( \n        map(p) - vec3(\n            map(p - t.xyy),\n            map(p - t.yxy),\n            map(p - t.yyx)\n        )\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 uvn = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    env = iTime + sin(iTime);\n    \n    \n    vec3 ro = vec3(0,0,-2);\n    vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1));\n    float side = 1.;\n    \n    \n    \n    float chrab = 0.;\n    float refrd = 0.;\n    for(int i = 0; i < 450; i++){\n        float d = map(p)*side;\n        //float pl = plaIntersect( ro, rd, vec4(0,0,-2,1.) );\n        float db = -p.z + 0.8 + sin(env*pi/4. + 0.5*pi)*0.4;\n        vec3 n = getNormal(p)*side;\n        \n        float accrf = 0.;\n        float accbeer = 0.;\n            \n        if(side < 1.)\n            accbeer += d;\n            \n        if(d < 0.0001){\n            rd = refract(rd,n,0.94);\n            ro = p;\n            d += 0.01;\n            side *= -1.;\n            \n            //chrab += dot(rd,reflect(rd,n));\n            chrab += sin(dot(rd,reflect(rd,n))*10.);\n            float rf = pow(max(dot(n,normalize(rd-normalize(vec3(1)))),0.), 2. )*4.;\n            rf = pow(1.-max(dot(-rd,n),0.),5.);\n            accrf += rf;\n            col = mix(col,vec3(0.9,0.4,0.9)*1., rf);\n        } else if (db < 0.001){\n            //vec2 pp = (ro + rd*pl).xy;\n            //pp.x /= iResolution.x/iResolution.y;\n            \n            float chrabSteps = 14.;\n            vec3 acc = vec3(0);\n            for(float i = 0.; i < chrabSteps; i++){\n                for(int c = 0; c < 3; c++){\n                    vec2 pp = p.xy;\n                    vec2 oop = pp;\n                    pp.x += env + iTime*0.1;\n                    pp.x += vec3(-0.001,0.,0.002)[c]*chrab*16.*(0. - i/chrabSteps*1.);\n                    vec2 opp = pp;\n                    pp = pmod(pp,0.125);\n                    float d = length(pp) - 0.004;\n                    \n                    float md = 0.5;\n                    float db = abs(opp.y + abs(mod(opp.x*0.5,md) - 0.5*md)) - 1.;\n                    float cc = mix(1.,vec3(0.)[c],smoothstep(0.007,0.,d));\n                    \n                    {\n                        for(float arrow = 0.; arrow < 20.; arrow++){\n                            float sz = 1. + sin(arrow)*0.4;\n                            vec2 p = oop + vec2(mod((env + iTime*0.4)*(1. + sin(arrow*15.6)*0.6)*0.1,1.)*8. - 4.,sin(arrow*20.)*1.5);\n                            p *= sz;\n                            \n                            float md = 0.1;\n                            p.x -= abs(p.y);\n                            vec2 q = p;\n                            q.x = pmod(p.x,md);\n                            \n                            \n                            float d = length(q.x) - md*0.3;\n                            d = max(d,abs(p.y) - 0.04);\n                            \n                            d = max(d,abs(p.x) - md*floor(4. + sin(arrow*10.)));\n                            \n                            d /= sz;\n                            cc = mix(cc,0.,smoothstep(0.007,0.,d));\n                        }\n                    }\n                    \n                    //cc = mix(cc,vec3(1)[c],smoothstep(0.007,0.,db));\n                    //cc = mix(cc,vec3(0.1,1.,0.5)[c],smoothstep(0.007,0.,abs(db) - 0.02));\n                    \n                    \n                    acc[c] += cc ;\n\n                }\n                \n            }\n            col = mix(col,acc/chrabSteps,1.-col);\n            //col = mix(col,col*0.,accbeer*1.1);\n            \n            \n            //col = texture(iChannel0,pp).xyz;\n\n            break;\n        }\n\n        d = min(d,db);\n        \n        p += rd*d;\n    }\n    \n    {\n        vec2 p = uv;\n        p.xy *= rot(0.5*pi);\n        \n        if (p.y < 0.){\n            p.y = -p.y;\n        }\n        p.y -= 0.75;\n        p.y -= 0.12;\n        \n        float d = 10e5;\n        #define xor(a,b) min(max(a,-(b) + 0.04),max(b,-(a)))\n        for(float i = 0.; i < 12.; i++){\n            vec2 q = p;\n            float e = iTime*0.1 + env*0.1 + float(uv.x < 0.);\n            \n            if(mod(i,3.) < 1.){\n                q.x = -q.x;\n                e += 1.2;\n            }\n            q.x += sin(i + e);\n            q.y += fract(clamp(q.x*6.,0.,0.99))*0.15;\n            float ld = sdBox(q,vec2(0.5,0.014));\n            \n            d = xor(d,ld);\n            \n        }\n        \n        //d = abs(d);\n        \n        \n        p = uv;\n        p.y = abs(p.y) - 0.2;\n        float douter = p.y - 0.22;\n        douter = - douter;\n        float md = 0.04;\n        float id = floor(p.x/md);\n        p.x = pmod(p.x,md);\n        \n        \n        p.x += sin(id/md + (env + iTime*0.2)*2.)*md/1.;\n        \n        p.y -= 0.31;\n        //douter = max(douter,-sdBox(p,vec2(0.006,0.04)));\n        \n        col = mix(col,1.-col*vec3(0.5,0.1,0.2),smoothstep(0.001,0.,douter));\n        //col = mix(col,vec3(0.,0.7 ,0.6),smoothstep(0.004,0.,d));\n        \n    }\n    \n    //col = texture(iChannel0,uvn).xyz;\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pmod(p,a) mod(p,a) - 0.5*a \n\n#define iTime (iTime + 6.)\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3z1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 102, 102, 189], [190, 190, 221, 221, 299], [319, 319, 337, 337, 755], [758, 758, 781, 781, 958], [959, 959, 1016, 1016, 5977]], "test": "untested"}
{"id": "NtsGzl", "name": "circle demo111", "author": "zengqh", "description": "circle", "tags": ["circle"], "likes": 6, "viewed": 361, "published": 3, "date": "1623303934", "time_retrieved": "2024-07-30T19:16:45.399638", "image_code": "float drawCircle(vec2 pos, float t)\n{\n    float dist = length(pos);\n    \n    float radius = mod(t * .1, .3);\n    float fadeDis = smoothstep(.3, .0, radius);\n    \n    float intensity = clamp(pow(2./abs(dist-radius), .2), .0, 3.5);\n    \n    intensity *= smoothstep(2.2, 3.1, intensity);\n    \n    intensity *= fadeDis;\n    \n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float intensity = drawCircle(pos, iTime);\n    intensity += drawCircle(pos, iTime + 1.);\n    intensity += drawCircle(pos, iTime + 2.);\n    \n    fragColor = vec4(.0,.3,.8, 1.) * intensity;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 344], [346, 346, 403, 403, 691]], "test": "untested"}
{"id": "ftS3zh", "name": "Simple ocean waves", "author": "jarble", "description": "A simple ocean animation based on a procedural terrain demo.", "tags": ["waves", "sea", "fbm", "ocean"], "likes": 17, "viewed": 1011, "published": 3, "date": "1623293043", "time_retrieved": "2024-07-30T19:16:46.373036", "image_code": "#define SC (250.0)\n\nfloat noise(in vec2 uv)\n{\n    uv.x -= iTime/2.0;\n    return sin(uv.x);\n}\n\n#define OCTAVES 4\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // value += noise(uv * freq) * amplitude;\n        \n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value += (.25-abs(noise(uv * freq)-.3) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 3.+1./3.;\n        \n        uv += uv.yx/10.0;\n        //uv = uv.yx;\n    }\n    \n    return value;\n}\n\nfloat f(in vec3 p)\n{\n    \n    float h = fbm(p.xz);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z);\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftS3zh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 92], [112, 112, 135, 135, 605], [607, 607, 627, 627, 673], [675, 675, 708, 708, 902], [904, 904, 971, 971, 1181], [1183, 1183, 1235, 1235, 1780], [1782, 1782, 1833, 1833, 2034], [2036, 2036, 2062, 2062, 2138], [2141, 2141, 2198, 2198, 3930]], "test": "untested"}
{"id": "7ljGzR", "name": "Sierpinski Towers - 134 Bytes", "author": "KilledByAPixel", "description": "Tiny voxel raycaster based on a dweet: https://www.dwitter.net/d/23062", "tags": ["fractal", "voxel", "tiny", "1tc"], "likes": 19, "viewed": 979, "published": 3, "date": "1623264432", "time_retrieved": "2024-07-30T19:16:47.123030", "image_code": "void mainImage(out vec4 c,vec2 p)\n{\n  ivec4 b;\n  for(;(b.x^b.y&b.z)%200 > b.z-9;)\n    b = ivec4((p/5e2-.5)*c.a + iTime/.1, c+=.1);\n  c = vec4(b*b.x%2) + c/2e2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljGzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 161]], "test": "untested"}
{"id": "st23RR", "name": "ssfinctorator", "author": "poluchka", "description": "s", "tags": ["s"], "likes": 5, "viewed": 239, "published": 3, "date": "1623254944", "time_retrieved": "2024-07-30T19:16:47.871031", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define GAMMA 0\n// my modified round intersection from https://www.shadertoy.com/view/wsyyWw\n\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.;\n}\n\n// intersect a ray with a rounded box\n// https://iquilezles.org/articles/intersectors\n// Modified to support bigger radius, probably more optimal solution, but was too lazy and nor as good as IQ :(\n// I kept the -1 for no collision paradigm even if I hate it (Make code more complex), but I prefered to stay compatible with IQ interface.\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    \n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n  \n  \t// fat edges\n    float d;\n    d = capIntersect(ro, rd, size * vec3(-1, 1, 1), size, rad);\n    t = d > 0. ? d : 1e20;\n    d = capIntersect(ro, rd, size * vec3( 1,-1, 1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n    d = capIntersect(ro, rd, size * vec3( 1, 1,-1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n    \n}\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\n\n\nstruct objDec\n{\n    float r;\n    float s;\n    mat3  m;\n};\n    \n    \nobjDec inner, outter;\n\nconst float offset = 4.;\n\n        \nbool intersectObjFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec o)\n{\n    ro = o.m * ro;\n    rd = o.m * rd;\n    ro = ro + rd * offset;\n    rd = -rd;\n    float d = roundedboxIntersect( ro, rd, vec3(o.s), o.r);\n    if(d > 0.)\n    {\n        oNor = -roundedboxNormal( ro + rd *d, vec3(o.s), o.r ) * o.m;\n        oDis = offset - d;\n\t\treturn true;\n    }\n    oDis = tmax;\n    return false;\n}\n\nbool intersectObjFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec o)\n{\n    ro = o.m * ro;\n    rd = o.m * rd;\n    float d = roundedboxIntersect( ro, rd, vec3(o.s), o.r);\n    if(d > 0.)\n    {\n        oNor = roundedboxNormal( ro + rd *d, vec3(o.s), o.r ) * o.m;\n        oDis = d;\n\t\treturn true;\n    }\n    oDis = tmax;\n    return false;\n}\n\nbool intersectSceneFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor)\n{\n\tintersectObjFromOutside(ro, rd, tmax, oDis, oNor, outter);\n    float d2;\n    vec3  n2;\n    intersectObjFromInside(ro, rd, tmax, d2, n2, inner);\n    if(d2 < oDis)\n    {\n        oDis = d2;\n        oNor = n2;\n    }\n    return oDis < tmax;\n}\n\nbool intersectSceneFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor)\n{\n\tintersectObjFromOutside(ro, rd, tmax, oDis, oNor, inner);\n    float d2;\n    vec3  n2;\n    intersectObjFromInside(ro, rd, tmax, d2, n2, outter);\n    if(d2 < oDis)\n    {\n        oDis = d2;\n        oNor = n2;\n    }\n    return oDis < tmax;\n}\n\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd.xy).rgb;\n    #if GAMMA\n    \tcol = pow(col, vec3(2.2));\n    #endif\n    return col;\n}\n\n\n\n#define MAX_BOUNCES 4\n#define ABSORB\t\tvec3(0, 0, 0)\n\nvec3 Render(in vec3 ro, in vec3 rd, in float dist, float cref)\n{\n    float sgn = 1.;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.99;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        vec3\tn;\n        float \td;\n        bool\tinter;\n        if(sgn > 0.)\n        {\n            inter = intersectSceneFromOutside(ro, rd, dist, d, n);\n        }\n        else\n        {\n            inter = intersectSceneFromInside(ro, rd, dist, d, n);\n        }\n        \n        if(!inter)\n        {\n            col += rel * getSkyColor(rd);\n            return col;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * d);\n        vec3 p = ro + rd * d;\n        //n *= sgn;\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime * 0.95;\n    float v = (cos(t) + 1.) * 0.5;\n    \n    outter.r = v * 0.75 + 0.1;\n    outter.s   = (1.-v) * 0.75;\n    outter.m = fromEuler(vec3(t * 0.9 + 0.2,  t * 0.6 + 1.2, t * 0.5 + 0.9));\n    inner.r  = (1.-v) * 0.35 + 0.1;\n    inner.s\t   = v * 0.35;\n    inner.m = fromEuler(vec3(t * 0.8 + 1.5,  t * 0.4 + 0.7, t * 0.7 + 2.3));\n\n  \n\tvec3 tot = vec3(0.0);   \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + radians(180.);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) + radians(90.);\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col;\n        col.r = Render(ro, rd, 12.,0.67).r;\n        col.g = Render(ro, rd, 12.,0.7).g;\n        col.b = Render(ro, rd, 12.,0.73).b;\n        \n      \ttot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 1.2);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st23RR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[255, 323, 405, 405, 1135], [1137, 1475, 1556, 1578, 2460], [2462, 2489, 2554, 2554, 2616], [2618, 2618, 2644, 2644, 2996], [3126, 3126, 3236, 3236, 3551], [3553, 3553, 3664, 3664, 3928], [3930, 3930, 4030, 4030, 4269], [4271, 4271, 4370, 4370, 4609], [4613, 4613, 4640, 4640, 4761], [4818, 4818, 4882, 4882, 6306], [6308, 6308, 6350, 6350, 6514], [6517, 6517, 6561, 6561, 6660], [6662, 6662, 6702, 6702, 6772]], "test": "untested"}
{"id": "slj3RR", "name": "Fork Sphere in  poluchka 510", "author": "poluchka", "description": "Sphere in a box or a box in sphere ?\n\nInspired by Nathan Riley\nhttps://dribbble.com/shots/10879124-Morphing-Geometry", "tags": ["raytracing", "refraction", "sphere", "box", "diffraction", "reproduction"], "likes": 7, "viewed": 364, "published": 3, "date": "1623254715", "time_retrieved": "2024-07-30T19:16:48.754668", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define GAMMA 0\n\nstruct objDec\n{\n    float r;\n    float s;\n    mat3  m;\n};\n    \n    \nobjDec inner, outter;\n\nconst float offset = 4.;\n\n        \nbool intersectObjFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec o)\n{\n    ro = o.m * ro;\n    rd = o.m * rd;\n    ro = ro + rd * offset;\n    rd = -rd;\n    float d = roundedboxIntersect( ro, rd, vec3(o.s), o.r);\n    if(d > 0.)\n    {\n        oNor = -roundedboxNormal( ro + rd *d, vec3(o.s), o.r ) * o.m;\n        oDis = offset - d;\n\t\treturn true;\n    }\n    oDis = tmax;\n    return false;\n}\n\nbool intersectObjFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor, in objDec o)\n{\n    ro = o.m * ro;\n    rd = o.m * rd;\n    float d = roundedboxIntersect( ro, rd, vec3(o.s), o.r);\n    if(d > 0.)\n    {\n        oNor = roundedboxNormal( ro + rd *d, vec3(o.s), o.r ) * o.m;\n        oDis = d;\n\t\treturn true;\n    }\n    oDis = tmax;\n    return false;\n}\n\nbool intersectSceneFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor)\n{\n\tintersectObjFromOutside(ro, rd, tmax, oDis, oNor, outter);\n    float d2;\n    vec3  n2;\n    intersectObjFromInside(ro, rd, tmax, d2, n2, inner);\n    if(d2 < oDis)\n    {\n        oDis = d2;\n        oNor = n2;\n    }\n    return oDis < tmax;\n}\n\nbool intersectSceneFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor)\n{\n\tintersectObjFromOutside(ro, rd, tmax, oDis, oNor, inner);\n    float d2;\n    vec3  n2;\n    intersectObjFromInside(ro, rd, tmax, d2, n2, outter);\n    if(d2 < oDis)\n    {\n        oDis = d2;\n        oNor = n2;\n    }\n    return oDis < tmax;\n}\n\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    vec3 col = texture(iChannel0, rd).rgb;\n    #if GAMMA\n    \tcol = pow(col, vec3(2.2));\n    #endif\n    return col;\n}\n\n\n\n#define MAX_BOUNCES 4\n#define ABSORB\t\tvec3(0, 0, 0)\n\nvec3 Render(in vec3 ro, in vec3 rd, in float dist, float cref)\n{\n    float sgn = 1.;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.99;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        vec3\tn;\n        float \td;\n        bool\tinter;\n        if(sgn > 0.)\n        {\n            inter = intersectSceneFromOutside(ro, rd, dist, d, n);\n        }\n        else\n        {\n            inter = intersectSceneFromInside(ro, rd, dist, d, n);\n        }\n        \n        if(!inter)\n        {\n            col += rel * getSkyColor(rd);\n            return col;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * d);\n        vec3 p = ro + rd * d;\n        //n *= sgn;\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float t = iTime * 0.95;\n    float v = (cos(t) + 1.) * 0.5;\n    \n    outter.r = v * 0.75 + 0.1;\n    outter.s   = (1.-v) * 0.75;\n    outter.m = fromEuler(vec3(t * 0.9 + 0.2,  t * 0.6 + 1.2, t * 0.5 + 0.9));\n    inner.r  = (1.-v) * 0.35 + 0.1;\n    inner.s\t   = v * 0.35;\n    inner.m = fromEuler(vec3(t * 0.8 + 1.5,  t * 0.4 + 0.7, t * 0.7 + 2.3));\n\n  \n\tvec3 tot = vec3(0.0);   \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + radians(180.);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) + radians(90.);\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col;\n        col.r = Render(ro, rd, 12.,0.67).r;\n        col.g = Render(ro, rd, 12.,0.7).g;\n        col.b = Render(ro, rd, 12.,0.73).b;\n        \n      \ttot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 1.2);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// my modified round intersection from https://www.shadertoy.com/view/wsyyWw\n\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.;\n}\n\n// intersect a ray with a rounded box\n// https://iquilezles.org/articles/intersectors\n// Modified to support bigger radius, probably more optimal solution, but was too lazy and nor as good as IQ :(\n// I kept the -1 for no collision paradigm even if I hate it (Make code more complex), but I prefered to stay compatible with IQ interface.\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    \n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n  \n  \t// fat edges\n    float d;\n    d = capIntersect(ro, rd, size * vec3(-1, 1, 1), size, rad);\n    t = d > 0. ? d : 1e20;\n    d = capIntersect(ro, rd, size * vec3( 1,-1, 1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n    d = capIntersect(ro, rd, size * vec3( 1, 1,-1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n    \n}\n\nmat3 fromEuler(vec3 ang)\n{\n    mat3 mx = mat3(\n\t\t\t1.0,\t\t0.0,\t\t0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x),\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x));\n    mat3 my = mat3(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),\n\t\t\t0.0,\t\t1.0,\t\t0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y));\n    mat3 mz = mat3(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0);\n        \n    return mx*my*mz;\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slj3RR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[304, 304, 414, 414, 729], [731, 731, 842, 842, 1106], [1108, 1108, 1208, 1208, 1447], [1449, 1449, 1548, 1548, 1787], [1791, 1791, 1818, 1818, 1936], [1993, 1993, 2057, 2057, 3481], [3483, 3483, 3525, 3525, 3689], [3692, 3692, 3736, 3736, 3835], [3837, 3837, 3877, 3877, 3947]], "test": "untested"}
{"id": "7lB3zz", "name": "Block Impact", "author": "dr2", "description": "Block fired into walls of stacked block (mouseable, new runs start automatically or by clicking upper-right)", "tags": ["collision", "dynamics", "physics"], "likes": 26, "viewed": 521, "published": 3, "date": "1623228691", "time_retrieved": "2024-07-30T19:16:50.146945", "image_code": "// \"Block Impact\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Based on \"Domino Towers\", with coloring from \"Spectral Duck\")\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBox2Df (vec2 p, vec2 b);\nmat3 QtToRMat (vec4 q);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec3 blkGap, bSize, fcBlk, ltDir;\nvec2 qBlk;\nfloat tCur, dstFar, nRun;\nint idObj;\nconst float pi = 3.1415927;\n\nconst int nObj = 97;\n\nconst ivec3 nSphObjD = ivec3 (6, 3, 3);\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fId, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    u = (v + dn) * rd;\n    fId = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qBlk = vec2 (dot (u.zxy, fId), dot (u.yzx, fId));\n  }\n  return vec4 (dMin, fId);\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) dMin = dn;\n  return dMin;\n}\n\nfloat ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  vec2 qBlkN;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = BlkHit (rom, rdm, bSize);\n    if (cdn4.x < dMin) {\n      dMin = cdn4.x;\n      fcBlk = cdn4.yzw;\n      qBlkN = qBlk;\n      idObj = n;\n    }\n  }\n  qBlk = qBlkN;\n  return dMin;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    dMin = min (dMin, BlkHitSh (rom, rdm, bSize));\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\nvec3 ObjCol (vec3 rd, float sh)\n{\n  mat3 mRot;\n  vec3 q, vn, col;\n  float ep;\n  vn = fcBlk;\n  mRot = QtToRMat (GetQ (idObj));\n  col = HsvToRgb (vec3 (mod (- dot (rd, mRot * vn), 1.), 0.5, 1.));\n  ep = smoothstep (0., 0.2, PrBox2Df (qBlk, ((abs (vn.x) == 1.) ? bSize.zy :\n     ((abs (vn.y) == 1.) ? bSize.xz : bSize.yx)) - 0.2));\n  if (abs (vn.y) == 1.) ep = max (ep, 1. - smoothstep (0., 0.1,\n     abs (PrBox2Df (qBlk, 0.5 * bSize.xz)) - 0.05));\n  col *= 1. - 0.3 * ep;\n  if (ep > 0.) {\n    q = vec3 (qBlk, 0.);\n    if (abs (vn.x) == 1.) q = q.zxy;\n    else if (abs (vn.y) == 1.) q = q.xzy;\n    vn = VaryNf (32. * q, vn, 0.7);\n  }\n  vn = mRot * vn;\n  col = col * (0.2 +  0.8 * sh * max (dot (vn, ltDir), 0.)) +\n     0.2 * sh * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  bool isBg;\n  bSize = 0.5 * blkGap * (vec3 (nSphObjD) - 1.) + 0.4;\n  dstObj = ObjHit (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    isBg = false;\n  } else {\n    if (rd.y < 0.) ro += ((0.5 - ro.y) / rd.y) * rd;\n    isBg = true;\n  }\n  if (! isBg || isBg && rd.y < 0.) sh = 0.6 + 0.4 * ObjHitSh (ro + 0.01 * ltDir, ltDir, 60.);\n  if (! isBg) col = ObjCol (rd, sh);\n  else if (rd.y < 0.) {\n    vn = vec3 (0., 1., 0.);\n    col = mix (vec3 (0.8, 0.8, 0.75), vec3 (0.8, 0.8, 0.85),\n       smoothstep (0., 0.1, Fbm2 (0.1 * ro.xz) - 0.4));\n    col *= 0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.);\n    col *= 1. - 0.9 * smoothstep (0.9, 1., length (ro.xz) / dstFar);\n  } else col = vec3 (0.1);\n  if (isBg && rd.y < 0.) {\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjHit (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      col = mix (col, ObjCol (rd, 1.), 0.3);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA    0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac, sr, h;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  blkGap = stDat.yzw;\n  stDat = Loadv4 (1);\n  mPtr.xyz = stDat.xyz;\n  nRun = stDat.w;\n  dstFar = 300.;\n  az = -0.2 * pi;\n  el = -0.12 * pi;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.48 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 0., -120.);\n  h = 0.;\n  for (int n = VAR_ZERO; n < nObj; n ++) h += GetR (n).y;\n  ro.y = min (h / float (nObj), 10.);\n  ro = vuMat * ro;\n  zmFac = 5.3;\n  ltDir = vuMat * normalize (vec3 (0.6, 0.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (0.5, 1., 1.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 256.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Block Impact\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\nconst int nObj = 97;\n\nconst ivec3 nSphObjD = ivec3 (6, 3, 3);\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 5.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  if (nStep > 20.) {\n    vm += dt * am;\n    rm += dt * vm;\n    wm += dt * wam;\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec3 bSize;\n  float bsx, bsz, sy, fId, nb12, a, s, t;\n  bSize = 0.5 * blkGap * (vec3 (nSphObjD) - 1.) + 0.4;\n  bsx = bSize.x + 0.1;\n  bsz = bSize.z + 0.15;\n  if (mId < nObj - 1) {\n    fId = float (mId);\n    nb12 = floor (fId / 12.);\n    rm.y = (bSize.y + 0.1) * (2. * nb12 + 1.) + 0.5;\n    sy = 2. * mod (nb12, 2.) - 1.;\n    fId = mod (fId, 12.);\n    qm = RotToQt (vec3 (0., 1., 0.), 0.5 * pi * step (6., fId));\n    if (fId < 6.) {\n      s = sign (fId - 2.5);\n      rm.x = (mod (fId, 3.) - 1.) * 2. * bsx - s * sy * bsz;\n      rm.z = 3. * s * bsx;\n    } else {\n      s = sign (fId - 8.5);\n      rm.x = 3. * s * bsx;\n      rm.z = (mod (fId, 3.) - 1.) * 2. * bsx + s * sy * bsz;\n    }\n    vm = vec3 (0.);\n  } else {\n    t = 3.1 * floor (0.1 * todCur);\n    rm = vec3 (40., 5. + 5. * Hashff (t + 11.1 * nRun), 0.);\n    vm = vec3 (- (30. + 60. * Hashff (t + 21.1 * nRun)), 5., 0.);\n    a = pi * (Hashff (t + 31.1 * nRun) - 0.75);\n    rm.xz = Rot2D (rm.xz, a);\n    vm.xz = Rot2D (vm.xz, a);\n    qm = RotToQt (vec3 (0., 1., 0.), - a);\n  }\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 8000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (0.9, 0.9, 0.9);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 100. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Block Impact\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\nconst int nObj = 97;\n\nconst ivec3 nSphObjD = ivec3 (6, 3, 3);\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 5.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  if (nStep > 20.) {\n    vm += dt * am;\n    rm += dt * vm;\n    wm += dt * wam;\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec3 bSize;\n  float bsx, bsz, sy, fId, nb12, a, s, t;\n  bSize = 0.5 * blkGap * (vec3 (nSphObjD) - 1.) + 0.4;\n  bsx = bSize.x + 0.1;\n  bsz = bSize.z + 0.15;\n  if (mId < nObj - 1) {\n    fId = float (mId);\n    nb12 = floor (fId / 12.);\n    rm.y = (bSize.y + 0.1) * (2. * nb12 + 1.) + 0.5;\n    sy = 2. * mod (nb12, 2.) - 1.;\n    fId = mod (fId, 12.);\n    qm = RotToQt (vec3 (0., 1., 0.), 0.5 * pi * step (6., fId));\n    if (fId < 6.) {\n      s = sign (fId - 2.5);\n      rm.x = (mod (fId, 3.) - 1.) * 2. * bsx - s * sy * bsz;\n      rm.z = 3. * s * bsx;\n    } else {\n      s = sign (fId - 8.5);\n      rm.x = 3. * s * bsx;\n      rm.z = (mod (fId, 3.) - 1.) * 2. * bsx + s * sy * bsz;\n    }\n    vm = vec3 (0.);\n  } else {\n    t = 3.1 * floor (0.1 * todCur);\n    rm = vec3 (40., 5. + 5. * Hashff (t + 11.1 * nRun), 0.);\n    vm = vec3 (- (30. + 60. * Hashff (t + 21.1 * nRun)), 5., 0.);\n    a = pi * (Hashff (t + 31.1 * nRun) - 0.75);\n    rm.xz = Rot2D (rm.xz, a);\n    vm.xz = Rot2D (vm.xz, a);\n    qm = RotToQt (vec3 (0., 1., 0.), - a);\n  }\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 8000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (0.9, 0.9, 0.9);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 100. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Block Impact\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\nconst int nObj = 97;\n\nconst ivec3 nSphObjD = ivec3 (6, 3, 3);\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 5.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  if (nStep > 20.) {\n    vm += dt * am;\n    rm += dt * vm;\n    wm += dt * wam;\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec3 bSize;\n  float bsx, bsz, sy, fId, nb12, a, s, t;\n  bSize = 0.5 * blkGap * (vec3 (nSphObjD) - 1.) + 0.4;\n  bsx = bSize.x + 0.1;\n  bsz = bSize.z + 0.15;\n  if (mId < nObj - 1) {\n    fId = float (mId);\n    nb12 = floor (fId / 12.);\n    rm.y = (bSize.y + 0.1) * (2. * nb12 + 1.) + 0.5;\n    sy = 2. * mod (nb12, 2.) - 1.;\n    fId = mod (fId, 12.);\n    qm = RotToQt (vec3 (0., 1., 0.), 0.5 * pi * step (6., fId));\n    if (fId < 6.) {\n      s = sign (fId - 2.5);\n      rm.x = (mod (fId, 3.) - 1.) * 2. * bsx - s * sy * bsz;\n      rm.z = 3. * s * bsx;\n    } else {\n      s = sign (fId - 8.5);\n      rm.x = 3. * s * bsx;\n      rm.z = (mod (fId, 3.) - 1.) * 2. * bsx + s * sy * bsz;\n    }\n    vm = vec3 (0.);\n  } else {\n    t = 3.1 * floor (0.1 * todCur);\n    rm = vec3 (40., 5. + 5. * Hashff (t + 11.1 * nRun), 0.);\n    vm = vec3 (- (30. + 60. * Hashff (t + 21.1 * nRun)), 5., 0.);\n    a = pi * (Hashff (t + 31.1 * nRun) - 0.75);\n    rm.xz = Rot2D (rm.xz, a);\n    vm.xz = Rot2D (vm.xz, a);\n    qm = RotToQt (vec3 (0., 1., 0.), - a);\n  }\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 8000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (0.9, 0.9, 0.9);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 100. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lB3zz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[808, 808, 827, 827, 865], [867, 867, 886, 886, 924], [926, 926, 970, 970, 1451], [1453, 1453, 1500, 1500, 1811], [1813, 1813, 1846, 1846, 2268], [2270, 2270, 2316, 2316, 2625], [2627, 2627, 2660, 2660, 3439], [3441, 3441, 3476, 3476, 4454], [4473, 4473, 4529, 4529, 5917], [5919, 5919, 5952, 5952, 6041], [6043, 6043, 6068, 6068, 6443], [6445, 6445, 6467, 6467, 6494], [6496, 6496, 6518, 6518, 6556], [6558, 6558, 6580, 6580, 6618], [6620, 6620, 6650, 6650, 6763], [6765, 6765, 6801, 6801, 7007], [7009, 7009, 7033, 7033, 7150], [7184, 7184, 7208, 7208, 7320], [7322, 7322, 7347, 7347, 7533], [7535, 7535, 7556, 7556, 7711], [7713, 7713, 7742, 7742, 7954], [7956, 7956, 7995, 7995, 8247], [8341, 8341, 8366, 8366, 8489]], "test": "untested"}
{"id": "slS3Rz", "name": "Color Blocks Cityscape 173 chars", "author": "GregRostami", "description": "This is a fork of Voxel Fractal by KilledByAPixel [url]https://www.shadertoy.com/view/NlB3Rz[/url]\nThe XOR patterns keep changing as you fly across the cityscape.", "tags": ["3d", "raymarching", "voxel", "xor", "golfing"], "likes": 12, "viewed": 504, "published": 3, "date": "1623214475", "time_retrieved": "2024-07-30T19:16:51.148268", "image_code": "// 172 chars - Xor KILLED another char ...\nvoid mainImage( out vec4 o, vec2 u )\n{\n    ivec4 f;\n    for(vec2 r = iResolution.xy; (f.z&f.x^f.y)%99>f.z-99;)\n    f = ivec4((.6+.3*sin(iTime*.1)) *\n        (u+u-r)/r.y*o.x + iTime/.1, o++);\n    o = vec4(f%3)-o/77.;\n}\n\n\n// 173 chars - Thanks to Xor, the shader is 4 chars less!\n/*\nvoid mainImage( out vec4 o, vec2 u )\n{\n    ivec4 f;\n    for(;(f.z&f.x^f.y)%99 > f.z-99;)\n    f = ivec4( (.6+.3*sin(iTime*.1)) *\n        (u+u-(o.yz = iResolution.xy))/o.z*o.x + iTime/.1, o++);\n    o = vec4(f%3) - o.a/77.; \n}\n*/\n\n\n// 177 chars - Original by Greg Rostami\n/*\nvoid mainImage( out vec4 o, vec2 u )\n{\n    ivec4 f;\n    for(;(f.z&f.x^f.y)%99 > f.z-99;)\n    f = ivec4( (.7+.3*sin(iTime*.1)) *\n        (u+u-(o.xy = iResolution.xy))/o.y*o.a + iTime/.1, o.a++, 0);\n    o = vec4(f%3) - o.a/77.; \n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slS3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 81, 81, 260]], "test": "untested"}
{"id": "7lB3RR", "name": "halftone cmyk noodle", "author": "mds2", "description": "just a noodle", "tags": ["video", "halftone", "cmyk"], "likes": 8, "viewed": 528, "published": 3, "date": "1623199312", "time_retrieved": "2024-07-30T19:16:52.141613", "image_code": "float px_dotsize = 20.0; // almost const, computed once at start of main\nconst float dots_per_screen = 100.0;\nvec2 edge_size = vec2(0.01);\n\nmat2 makeTwist(in float theta) {\n  float st = sin(theta);\n  float ct = cos(theta);\n  return mat2(ct, st, -st, ct);\n}\n\nvec2 dotCenter(in vec2 uv, in mat2 twist) {\n  vec2 xformed = twist * uv;\n  xformed = xformed - mod(xformed, vec2(px_dotsize));\n  xformed = xformed + 0.5 * px_dotsize;\n  return transpose(twist) * xformed;\n}\n\nfloat dotNess(in vec2 uv, in vec2 dot_center, in float val) {\n  float rad = 0.6 * px_dotsize * sqrt(smoothstep(0.0, 1.0, val)); // val between 0 and 1\n  float len = length(uv - dot_center);\n  float out_val = (rad-len);\n  return clamp(out_val, 0.0, 1.0);\n}\n\nvec3 dotCmy(in vec2 uv) {\n  mat2 twist = makeTwist(0.1);\n  vec2 center = dotCenter(uv, twist);\n  float val = 1.0 - textureLod(iChannel0, center/iResolution.xy, 2.0).r;\n  float cyan = dotNess(uv, center, val);\n  twist = makeTwist(-0.75);\n  center = dotCenter(uv, twist);\n  val = 1.0 - textureLod(iChannel0, center/iResolution.xy, 2.0).g;\n  float magenta = dotNess(uv, center, val);\n  twist = makeTwist(0.4);\n  center = dotCenter(uv, twist);\n  val = 1.0 - textureLod(iChannel0, center/iResolution.xy, 2.0).b;\n  float yellow = dotNess(uv, center, val);\n  return vec3(cyan, magenta, yellow);\n}\n\nfloat edgeness(in vec2 uv) {\n  float f = dot(texture(iChannel0, uv).rgb, vec3(1.0));\n  vec2 grad = vec2(dot(texture(iChannel0, uv + edge_size * vec2(1.0, 0.0)).rgb, vec3(1.0)),\n                   dot(texture(iChannel0, uv + edge_size * vec2(0.0, 1.0)).rgb, vec3(1.0)))\n              - f;\n  // grad = grad / min(edge_size.x, edge_size.y);\n  return length(grad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    px_dotsize = max(iResolution.x, iResolution.y) / dots_per_screen;\n    edge_size = edge_size.x * iResolution.x / iResolution.xy;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 cmy = dotCmy(fragCoord);\n    \n    float edgeblack = smoothstep(0.75, 0.42, edgeness(uv));\n\n    // Output to screen\n    fragColor = vec4(edgeblack * (1.0 - cmy),1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lB3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 172, 172, 256], [258, 258, 301, 301, 463], [465, 465, 526, 526, 720], [722, 722, 747, 747, 1311], [1313, 1313, 1341, 1341, 1675], [1677, 1677, 1734, 1734, 2166]], "test": "untested"}
{"id": "stS3RR", "name": "dithering experiment", "author": "mds2", "description": "inspired by https://surma.dev/things/ditherpunk/", "tags": ["simple", "dither", "sketch"], "likes": 5, "viewed": 355, "published": 3, "date": "1623192082", "time_retrieved": "2024-07-30T19:16:53.054173", "image_code": "#define BW 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = step(texture(iChannel1, uv).rgb, texture(iChannel0, uv).rgb);\n    \n#if BW\n    float bw_col = step(dot(vec3(1.0), texture(iChannel1, uv).rgb),\n                        dot(vec3(1.0), texture(iChannel0, uv).rgb));\n    col = vec3(bw_col);\n#endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stS3RR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 71, 121, 509]], "test": "untested"}
{"id": "NlB3Rz", "name": "Voxel Fractal in 127 Bytes", "author": "KilledByAPixel", "description": "Tiny voxel raycaster based on a dweet: https://www.dwitter.net/d/23062", "tags": ["fractal", "voxel", "tiny", "1tc"], "likes": 18, "viewed": 651, "published": 3, "date": "1623183432", "time_retrieved": "2024-07-30T19:16:53.970722", "image_code": "void mainImage(out vec4 c, vec2 p)\n{\n  for(ivec4 b = ivec4(c -= c); (b.x^b.y&b.z)%99 > b.z-9;)\n    b = ivec4((p/5e2-.5)*c.a + iTime/.1, ++c);\n  c /= 99.;\n}\n\n/* smaller version that may not work on some machines\n\nvoid mainImage(out vec4 c,vec2 p){\nfor(ivec3 b;(b.x^b.y&b.z)%99>b.z-9;)\nb=ivec3((p/5e2-.5)*c.a+iTime/.1,c++);\nc/=99.;}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlB3Rz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 155]], "test": "untested"}
{"id": "NlfGDX", "name": "2D Bezier: linear-time algorithm", "author": "maras", "description": "Algorithm based on paper \"Linear-time geometric algorithm for evaluating Bézier curves\" (https://www.sciencedirect.com/science/article/abs/pii/S0010448518301234?via%3Dihub) by P. Woźny and F. Chudy.\nMore info in comment below (sorry, characters limit).", "tags": ["2d", "bezier", "curve", "learning", "education"], "likes": 6, "viewed": 468, "published": 3, "date": "1623181212", "time_retrieved": "2024-07-30T19:16:54.930157", "image_code": "/* \n Hi. I made this shader to make it easier to visualize Bezier curves and linear-time algorithm.\n You can find more shaders to learn about Bezier curves\n on my playlist: https://www.shadertoy.com/playlist/X3XfWf (still WiP)\n Enjoy <3\n*/\n\n// changeable parameters (feel free to experiment!) \n\n#define BEZIER_CURVE_POINTS 5 // int, minimum = 2, maximum = 13 \n// The parametr may take the value greater than 13, but then you can't hide/show all support points/lines.\n// Values greater than ~ 25 can cause numerical errors and visual glitches when final point is at the start of the curve.\n// PS: higher values can be imposible to compile if your GPU is weak. Sorry\n\n// Remember to change BEZIER_CURVE_POINTS parameter in \"Buffer A\" too! (second tab, you can select it ot the top of this window)\n// After changing BEZIER_CURVE_POINTS peremeter you need to reset shader's time (button on the bottom of shader window)\n\n#define BACKWARDS_ANIMATION true // bool\n\n#define SLOW_DOWN 2.0 // float, need to be typed with decimal point (.)\n\n// sorry for naming the parameter \"SLOW_DOWN\" instead of \"SPEED\", but default speed is really fast\n// and it's easier for you to slow down things by an integer instead of speeding up by for example 0.25.\n// If you want to speed up the animation you can use a float lower than 1.0\n\n// Information on the parameters below is provided in the comment\n\n#define SHOW_RED_DOTS true // bool\n#define SHOW_BLUE_DOT true // bool\n#define SHOW_FINAL_DOT true // bool\n\n#define SHOW_BLACK_LINE true // bool\n#define SHOW_GREY_LINES true // bool\n\n#define ALWAYS_SHOW_BEZIER_CURVE false // bool\n\n#define DRAWING_STEPS 80 // int, more than 1000 can really slow down your computer, be careful\n\n#define SHOW_1_SUPPORT_POINT true // bool\n#define SHOW_2_SUPPORT_POINT true // bool\n#define SHOW_3_SUPPORT_POINT true // bool\n#define SHOW_4_SUPPORT_POINT true // bool\n#define SHOW_5_SUPPORT_POINT true // bool\n#define SHOW_6_SUPPORT_POINT true // bool\n#define SHOW_7_SUPPORT_POINT true // bool\n#define SHOW_8_SUPPORT_POINT true // bool\n#define SHOW_9_SUPPORT_POINT true // bool\n#define SHOW_10_SUPPORT_POINT true // bool\n#define SHOW_11_SUPPORT_POINT true // bool\n\n#define SHOW_1_SUPPORT_LINE true // bool\n#define SHOW_2_SUPPORT_LINE true // bool\n#define SHOW_3_SUPPORT_LINE true // bool\n#define SHOW_4_SUPPORT_LINE true // bool\n#define SHOW_5_SUPPORT_LINE true // bool\n#define SHOW_6_SUPPORT_LINE true // bool\n#define SHOW_7_SUPPORT_LINE true // bool\n#define SHOW_8_SUPPORT_LINE true // bool\n#define SHOW_9_SUPPORT_LINE true // bool\n#define SHOW_10_SUPPORT_LINE true // bool\n#define SHOW_11_SUPPORT_LINE true // bool\n\n// non-changeable parameters (don't get me wrong, feel free to experiment with the entire code,\n// but you can screw something up :D )\n\n#define EDGE   0.005   // anti-aliasing\n#define SMOOTH 0.0025  // anti-aliasing \n\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\n\nconst int max_count = BEZIER_CURVE_POINTS;\nconst float radius = 20.0;\nconst float statePos = float(max_count);\n\n     \nconst vec3 support_lines_colors[11] = vec3[](\n                                      vec3(1.0, 0.839, 0.458),\n                                      vec3(1.0, 0.674, 0.478),\n                                      vec3(1.0, 0.658, 0.560),\n                                      vec3(1.0, 0.541, 0.788),\n                                      vec3(0.992, 0.380, 1.0),\n                                      vec3(0.788, 0.458, 1.0),\n                                      vec3(0.635, 0.541, 1.0),\n                                      vec3(0.380, 0.788, 1.0),\n                                      vec3(0.321, 1.0, 0.803),\n                                      vec3(0.807, 0.705, 0.592),\n                                      vec3(0.509, 0.482, 0.678));\n     \nconst vec3 support_points_colors[11]= vec3[](\n                                      vec3(0.992, 0.792, 0.325),\n                                      vec3(1.0, 0.639, 0.341),\n                                      vec3(1.0, 0.454, 0.301),\n                                      vec3(1.0, 0.039, 0.560),\n                                      vec3(0.807, 0.0, 0.819),\n                                      vec3(0.560, 0.0, 0.921),\n                                      vec3(0.333, 0.160, 1.0),\n                                      vec3(0.019, 0.662, 1.0),\n                                      vec3(0.0, 0.980, 0.694),\n                                      vec3(0.549, 0.443, 0.329),\n                                      vec3(0.270, 0.250, 0.392));                                       \n                                      \nconst vec3 final_dot_color = vec3(0.0,1.0,0.0);\n\nconst bool show_support_points[11] = bool[](\n                                     SHOW_1_SUPPORT_POINT,\n                                     SHOW_2_SUPPORT_POINT,\n                                     SHOW_3_SUPPORT_POINT,\n                                     SHOW_4_SUPPORT_POINT,\n                                     SHOW_5_SUPPORT_POINT,\n                                     SHOW_6_SUPPORT_POINT,\n                                     SHOW_7_SUPPORT_POINT,\n                                     SHOW_8_SUPPORT_POINT,\n                                     SHOW_9_SUPPORT_POINT,\n                                     SHOW_10_SUPPORT_POINT,\n                                     SHOW_11_SUPPORT_POINT);\n                                     \nconst bool show_support_lines[11] = bool[](\n                                    SHOW_1_SUPPORT_LINE,\n                                    SHOW_2_SUPPORT_LINE,\n                                    SHOW_3_SUPPORT_LINE,\n                                    SHOW_4_SUPPORT_LINE,\n                                    SHOW_5_SUPPORT_LINE,\n                                    SHOW_6_SUPPORT_LINE,\n                                    SHOW_7_SUPPORT_LINE,\n                                    SHOW_8_SUPPORT_LINE,\n                                    SHOW_9_SUPPORT_LINE,\n                                    SHOW_10_SUPPORT_LINE,\n                                    SHOW_11_SUPPORT_LINE);\n                                     \n\nfloat DistanceToLineSegment(vec2 point, vec2 start, vec2 end) {\n    float A = point.x - start.x;\n    float B = point.y - start.y;\n    float C = end.x - start.x;\n    float D = end.y - start.y;\n\n    float dot1 = A * C + B * D;\n    float len_sq = C * C + D * D;\n    float param = -1.0;\n    if (len_sq != 0.0) {  param = dot1 / len_sq; }\n       \n    float xx, yy;\n\n    if (param < 0.0) {\n        xx = start.x;\n        yy = start.y;\n    }\n\n    else if (param > 1.0) {\n        xx = end.x;\n        yy = end.y;\n    }\n\n    else {\n        xx = start.x + param * C;\n        yy = start.y + param * D;\n    }\n\n    float dx = point.x - xx;\n    float dy = point.y - yy;\n    return sqrt(dx * dx + dy * dy);\n}\n\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v / length(g); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 act_coord = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    float aspectRatio = iResolution.x / iResolution.y;\n    act_coord.x *= aspectRatio;\n    \n    float dist;\n\n    vec2 control_points[max_count];\n    \n    vec4 state = BufA(statePos);\n    vec3 color = vec3(1.0,1.0,1.0);\n\n    for (int i = 0; i < max_count; ++i) {\n        float f = float(i);\n        if (f >= state.y) { break; }\n        \n        vec2 center = BufA(f).xy;\n        center = ((center.xy / iResolution.xy) - vec2(0.25,0.5));\n        center.x *= aspectRatio;\n\n        control_points[i] = center;\n    }\n    \n\n    float t = fract(iTime / SLOW_DOWN);\n\n    if (int(iTime / SLOW_DOWN) % 2 == 1 && BACKWARDS_ANIMATION) {\n        t = 1.0 - t;\n    }\n    \n    vec2 test = vec2(-1.0);\n    \n    // draw bezier curve using linear-time algorithm\n    if (SHOW_BLACK_LINE) {\n        float end_algorithm = t;\n        float drawing_steps = float(DRAWING_STEPS);\n\n        if(ALWAYS_SHOW_BEZIER_CURVE) { end_algorithm = 1.0; }\n        else { drawing_steps *= t; } // without this big DRAWING_STEPS and small t couses visual glitch (i don't know why :D)\n\n        float increaser = end_algorithm / drawing_steps;\n\n        end_algorithm += 0.001; // without it some small values of CASTELJAUS_STEPS couses ending curve before endpoint\n                                // (i don't know why)\n                                \n        vec2 prev_point = control_points[0];\n        \n        for (float i = 0.0; i <= end_algorithm; i += increaser) {\n            float i2 = 1.0 - i;\n            \n            float h = 1.0;\n            float u = (1.0 - i);\n            int n = max_count - 1;\n            int n1 = n + 1;\n            vec2 Q = control_points[0];\n            \n            if (i != 0.0) {\n                if (i <= 0.5) {\n                    u = i / u;\n                    for (int k = 1; k <= n; ++k) {\n                        float prev_h = h;\n                        h = h * u * (float(n1) - float(k));\n                        h = h / (float(k) + h);\n                        float h1 = (h / prev_h) * ((float(k) * (1.0 - i)) / (i * float(n - k + 1)));\n                        Q = h1 * Q + h * control_points[k];\n                    }\n                }\n                else {\n                    u = u / i;\n                    for (int k = 1; k <= n; ++k) {\n                        float prev_h = h;\n                        h = h * (float(n1) - float(k));\n                        h = h / (float(k) * u + h);\n                        float h1 = (h / prev_h) * ((float(k) * (1.0 - i)) / (i * float(n - k + 1)));\n                        Q = h1 * Q + h * control_points[k];\n                    }\n                }\n            }\n            \n            vec2 point = Q;\n            \n            dist = DistanceToLineSegment(act_coord, prev_point, point) * 2.0;\n            \n            if (dist < EDGE + SMOOTH)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                color *= dist;\n            }\n            \n            prev_point = point;\n        }\n    }\n    \n    \n    // draw control points\n    for (int i = 1; i < max_count - 1; ++i) {\n        dist = SDFCircle(act_coord, control_points[i]);\n        if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n        {\n            dist = max(dist, 0.0);\n            dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n            color *= mix(vec3(0.0,0.0, float(max_count - i) / float(max_count) ),vec3(1.0,1.0,1.0),dist);\n        }\n    }\n    \n    // draw start point\n    dist = SDFCircle(act_coord, control_points[0]);\n    if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n        \n    // draw end point\n    dist = SDFCircle(act_coord, control_points[max_count-1]);\n    if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    // draw lines between control points\n    if (SHOW_GREY_LINES) {\n        for (int i = 0; i < max_count - 1; ++i) {\n            dist = DistanceToLineSegment(act_coord, control_points[i], control_points[i + 1]) * 2.0;\n            if (dist < EDGE + SMOOTH && SHOW_GREY_LINES)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                color *= mix(vec3(0.8),vec3(1.0,1.0,1.0),dist);\n            }\n        }\n    }\n    \n    // draw support lines and points\n    float h = 1.0;\n    float u = (1.0 - t);\n    int n = max_count - 1;\n    int n1 = n + 1;\n    vec2 Q = control_points[0];\n    vec2 prev_Q = Q;\n\n    if (t != 0.0) {\n        if (t <= 0.5) {\n            u = t / u;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * u * (float(n1) - float(k));\n                h = h / (float(k) + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n                \n                dist = DistanceToLineSegment(act_coord, prev_Q, control_points[k]) * 2.0;\n                if (dist < EDGE + SMOOTH && show_support_lines[k-1])\n                {\n                    dist = max(dist, 0.0);\n                    dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                    color *= mix(support_lines_colors[k-1], vec3(1.0,1.0,1.0),dist);\n                }\n\n                dist = SDFCircle(act_coord, Q);\n                if (dist < EDGE + SMOOTH && show_support_points[k-1])\n                {\n                    dist = max(dist, 0.0);\n                    dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n                    color = mix(support_points_colors[k-1], vec3(1.0,1.0,1.0),dist);\n                }\n                \n                prev_Q = Q;\n            }\n        }\n        else {\n            u = u / t;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * (float(n1) - float(k));\n                h = h / (float(k) * u + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n                \n                dist = DistanceToLineSegment(act_coord, prev_Q, control_points[k]) * 2.0;\n                if (dist < EDGE + SMOOTH && show_support_lines[k-1])\n                {\n                    dist = max(dist, 0.0);\n                    dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                    color *= mix(support_lines_colors[k-1], vec3(1.0,1.0,1.0),dist);\n                }\n\n                dist = SDFCircle(act_coord, Q);\n                if (dist < EDGE + SMOOTH && show_support_points[k-1])\n                {\n                    dist = max(dist, 0.0);\n                    dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n                    color = mix(support_points_colors[k-1], vec3(1.0,1.0,1.0),dist);\n                }\n                \n                prev_Q = Q;\n            }\n        }     \n    }\n    \n    // draw final point \n    h = 1.0;\n    u = (1.0 - t);\n    n = max_count - 1;\n    n1 = n + 1;\n    Q = control_points[0];\n\n    if (t != 0.0) {\n        if (t <= 0.5) {\n            u = t / u;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * u * (float(n1) - float(k));\n                h = h / (float(k) + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n            }\n        }\n        else {\n            u = u / t;\n            for (int k = 1; k <= n; ++k) {\n                float prev_h = h;\n                h = h * (float(n1) - float(k));\n                h = h / (float(k) * u + h);\n                float h1 = (h / prev_h) * ((float(k) * (1.0 - t)) / (t * float(n - k + 1)));\n                Q = h1 * Q + h * control_points[k];\n            }\n        }\n    }\n\n    vec2 point = Q;\n    \n    dist = SDFCircle(act_coord, point);\n    if (dist < EDGE + SMOOTH && SHOW_FINAL_DOT)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color = mix(final_dot_color, vec3(1.0,1.0,1.0),dist);\n    }\n    \n   \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// this code is copied from https://www.shadertoy.com/view/4dtSRn (shader by mhnewman)\n\n#define BEZIER_CURVE_POINTS 5 // int, minimum = 2, maximum = 13\n// The parametr may take the value greater than 13, but then you can't hide/show all support points/lines.\n// Values greater than ~ 25 can cause numerical errors and visual glitches when final point is at the start of the curve.\n\n// Remember to change BEZIER_CURVE_POINTS parameter in Image too! (second tab, you can select it ot the top of this window)\n// After changing BEZIER_CURVE_POINTS peremeter reset shader's time (button on the bottom of shader window)\n\nconst int maxCount = BEZIER_CURVE_POINTS;\nconst float radius = 20.0;\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        //\n        // Initial conditions\n        //\n        addObject(0.2 * iResolution.x, 0.2 * iResolution.y);  // start point\n        for(int i = 0; i < maxCount - 2; i++) {\n            addObject((0.1 + (float(i) / float(maxCount))) * iResolution.x,\n                      (0.8 - float(abs(i - maxCount / 2)) * 0.03) * iResolution.y); // control point\n        }\n        \n        addObject(0.8 * iResolution.x, 0.2 * iResolution.y); // end point\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / iResolution.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / iResolution.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / iResolution.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r * 5.0) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n            \tstate.x = 2.0 * statePos;\n            } else {\n    \t        state.x = state.y;\n        \t    state.y += 1.0;\n        \t}\n        }\n    } \n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6107, 6107, 6170, 6170, 6798], [6800, 6800, 6851, 6851, 7023]], "test": "untested"}
{"id": "ftB3zR", "name": "Double Slit", "author": "milesWaugh", "description": "A little thingy for fun", "tags": ["light", "slit"], "likes": 5, "viewed": 346, "published": 3, "date": "1623177673", "time_retrieved": "2024-07-30T19:16:55.683143", "image_code": "#define pi 3.141592653589793\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2. * (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 col, col1, col2;\n\n    col1 = vec3(cos(pi * uv.x * 8. - iTime)); //Initial waves\n    vec2 a = vec2(uv.x, uv.y - 0.5);\n    vec2 b = vec2(uv.x, uv.y + 0.5);\n    float c = dot(a, a);\n    float d = dot(b, b);\n    col2 = vec3(cos(pi * sqrt(c) * 8. - iTime) * exp(-c * .4) + cos(pi * sqrt(d) * 8. - iTime) * exp(-d * .4)) * .5; //Interference\n\n    col = mix(col1, col2, smoothstep(0., 1., uv.x * 15.)); //Interpolate\n    col *= min(smoothstep(0., 1., abs(uv.x) * 16.) / smoothstep(0., 1., abs(abs(uv.y) - 0.5) * 20.), 1.); //Barrier\n\n    col = col * col; //PDF\n\n    col = vec3((-cos(pi * (col.r)) / 2. + .5), col.r, (1. - (acos(2. * col.r - 1.)) / pi)); //color\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftB3zR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 85, 85, 854]], "test": "untested"}
{"id": "sllGDs", "name": "2do Truchet-2d-vertical", "author": "jorge2017a1", "description": "2do Truchet-2d", "tags": ["2d", "truchet"], "likes": 3, "viewed": 222, "published": 3, "date": "1623160665", "time_retrieved": "2024-07-30T19:16:56.436131", "image_code": "//2do Truchet-2d-vertical\n\n//Modificado por jorge2017a1\n//referencia\n//https://www.youtube.com/watch?v=2R7h76GoIJM ....Art Code\n\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat Hash21(vec2 p)\n{\n    p=fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.26);\n    return fract(p.x*p.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*= 7.0;\n    //uv+=iTime;\n    uv+=vec2(0.0, iTime*1.5);\n    \n    uv= rotatev2(uv, radians(45.0));\n    \n    vec3 col=vec3(0.0);\n    vec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n\n    float n=Hash21(id); //rango 0.0 a 1.0\n\n    float width=0.1;\n\n    if(n<0.5) gv.x*=-1.0;\n\n    //float d=abs(gv.x+gv.y); //diagonal...linea\n    \n//----------\n/// Tip Shane....9/jun/2021\nfloat d=abs(gv.x + gv.y)*.7071; // Diagonal line.\ngv = abs(gv) - .5; // Corners.\nd = min(d, abs(gv.x + gv.y)*.7071); \n//----------\n    \n    \n    float  mask=smoothstep(0.01,-0.01, d-width);\n\n    \n    float r = pow(1.0-sqrt( d),1.5 );\n    float g = pow(1.0-sqrt( d),1.5 );\n    float b = 1.0*(r+g);\n    \n    \n    \n    col+=vec3(r,g-0.8,b-0.8)*mask;\n        \n    \n    //if(gv.x>0.48 || gv.y>0.48) col=vec3(1.0,0.0,.0);\n    fragColor=vec4(col,1.0);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 165, 165, 262], [265, 265, 287, 287, 376], [379, 379, 436, 436, 1312]], "test": "untested"}
{"id": "ftl3Ds", "name": "Simple Rasterizer", "author": "jackdavenport", "description": "A very basic example of rasterized graphics drawing, with the addition of perspective correct texture mapping. It works on the same essential principles as OpenGL and all other graphics APIs (see comments).\n\nUse mouse to free rotate the pyramid.", "tags": ["rasterizer", "triangles", "raster", "geometry", "coordinates", "perspectivecorrect"], "likes": 15, "viewed": 774, "published": 3, "date": "1623133725", "time_retrieved": "2024-07-30T19:16:57.197096", "image_code": "#define VERTEX_COUNT 18\nconst vec3 vertices[VERTEX_COUNT] = vec3[VERTEX_COUNT] (\n    vec3(-0.5, 0.0, -0.5),\n    vec3( 0.5, 0.0, -0.5),\n    vec3(-0.5, 0.0,  0.5),\n    \n    vec3(-0.5, 0.0,  0.5),\n    vec3( 0.5, 0.0, -0.5),\n    vec3( 0.5, 0.0,  0.5),\n    \n    vec3(-0.5, 0.0, -0.5),\n    vec3( 0.5, 0.0, -0.5),\n    vec3( 0.0, 1.0,  0.0),\n    \n    vec3(-0.5, 0.0,  0.5),\n    vec3( 0.5, 0.0,  0.5),\n    vec3( 0.0, 1.0,  0.0),\n    \n    vec3(-0.5, 0.0, -0.5),\n    vec3(-0.5, 0.0,  0.5),\n    vec3( 0.0, 1.0,  0.0),\n    \n    vec3( 0.5, 0.0, -0.5),\n    vec3( 0.5, 0.0,  0.5),\n    vec3( 0.0, 1.0,  0.0)\n);\n\nconst vec2 texCoords[VERTEX_COUNT] = vec2[VERTEX_COUNT] (\n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(0., 0.),\n    \n    vec2(0., 0.),\n    vec2(1., 1.),\n    vec2(1., 0.),\n    \n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(.5, 0.),\n    \n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(.5, 0.),\n    \n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(.5, 0.),\n    \n    vec2(0., 1.),\n    vec2(1., 1.),\n    vec2(.5, 0.)\n);\n\n//-------- shaders -------/\n\nvec4 vertexShader(in vec3 vertex, in mat4 transform) {\n    // converts position into NDC\n    return transform * vec4(vertex, 1.);\n}\n\nvec4 fragmentShader(in vec2 uv) {\n    return texture(iChannel0, uv);\n}\n\n//-------- rasterizing -------//\n\nconst float fov  = 70.0;\nconst float near = 0.1;\nconst float far  = 10.;\n\nconst vec3 cameraPos = vec3(0., 0.3, 2.);\n\nvec4 pixel(in vec2 ndc, in float aspect, inout float depth, in int vertexIndex) {\n\n    float rotX = -25.;\n    float rotY = 45. + iTime * 20.;\n    \n    if(iMouse.xy != vec2(0.)) {\n        rotX = -100. + (iMouse.y * 150. / iResolution.y);\n        rotY = iMouse.x * 360. / iResolution.x;\n    }\n    \n\n    // step 0: calculate projection matrix\n    mat4 proj  = perspective(fov, aspect, near, far);\n    mat4 view  = translate(-cameraPos);\n    mat4 model = rotateX(rotX) * rotateY(rotY);\n    \n    mat4 mvp  = proj * view * model;\n\n    // step 1: run vertex shader and get ndc of each vertex\n    vec4 v0 = vertexShader(vertices[vertexIndex  ], mvp);\n    vec4 v1 = vertexShader(vertices[vertexIndex+1], mvp);\n    vec4 v2 = vertexShader(vertices[vertexIndex+2], mvp);\n    \n    // divide tex coords by w for perspective correctness\n    vec2 t0 = texCoords[vertexIndex  ] / v0.w; float oow0 = 1. / v0.w;\n    vec2 t1 = texCoords[vertexIndex+1] / v1.w; float oow1 = 1. / v1.w;\n    vec2 t2 = texCoords[vertexIndex+2] / v2.w; float oow2 = 1. / v2.w;\n    \n    // step 2: do perspective division and calculate barycentric coordinates\n    //         (and determine if we're even on the triangle)\n    v0 /= v0.w;\n    v1 /= v1.w;\n    v2 /= v2.w;\n    \n    vec3 tri = bary(v0.xy, v1.xy, v2.xy, ndc);\n    \n    // if any of the coordinates aren't within [0,1], we're outside the triangle\n    if(tri.x < 0. || tri.x > 1. || tri.y < 0. || tri.y > 1. || tri.z < 0. || tri.z > 1.) {\n        return vec4(0.);\n    }\n    \n    // step 3: perform depth testing and cull pixels outside the camera's Z range\n    float triDepth = baryLerp(v0.z, v1.z, v2.z, tri);\n    if(triDepth > depth || triDepth < -1. || triDepth > 1.) {\n        return vec4(0.);\n    }\n    \n    depth = triDepth; // write to depth buffer\n    \n    // step 3: run fragment shader to get pixel colour (and correct UVs)\n    float oneOverW = baryLerp(oow0, oow1, oow2, tri);\n    vec2 uv        = uvLerp(t0, t1, t2, tri) / oneOverW;\n    return fragmentShader(uv);\n\n}\n\n//-------- main ---------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = ((fragCoord.xy * 2.) / iResolution.xy) - vec2(1.);\n    float aspect = iResolution.x / iResolution.y;\n    vec3 outColor = vec3(.4,.6,.9);\n    \n    float depth = 1.0;\n    for(int i = 0; i < VERTEX_COUNT; i += 3) {\n        vec4 tri = pixel(ndc, aspect, depth, i);\n        outColor = mix(outColor.rgb, tri.rgb, tri.a);\n    }\n    \n    fragColor = vec4(outColor, 1.);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Source: http://gamedev.stackexchange.com/questions/23743/whats-the-most-efficient-way-to-find-barycentric-coordinates\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) {\n    vec2 v0 = b-a, v1 = c-a, v2 = p-a;\n    float d00 = dot(v0,v0);\n    float d01 = dot(v0,v1);\n    float d11 = dot(v1,v1);\n    float d20 = dot(v2,v0);\n    float d21 = dot(v2,v1);\n    float d = 1./(d00*d11-d01*d01);\n    float v = (d11*d20-d01*d21)*d;\n    float w = (d00*d21-d01*d20)*d;\n    float u = 1.-v-w;\n    return vec3(u,v,w);\n}\n\n//------------- interpolation ----------------//\n\nfloat baryLerp(float a, float b, float c, vec3 x) {\n    return a * x.x + b * x.y + c * x.z;\n}\n\nvec2 uvLerp(vec2 a, vec2 b, vec2 c, vec3 x) {\n    return a * x.x + b * x.y + c * x.z;\n}\n\n//------------- transformations --------------//\n\nmat4 perspective(float fovy, float aspect, float near, float far) {\n    float thf = 1./tan(radians(fovy)*.5);\n    float rng = far-near;\n    mat4 m = mat4(1.);\n    m[0][0] = thf/aspect;\n    m[1][1] = thf;\n    m[2][2] = -((far+near)/rng);\n    m[2][3] = -1.;\n    m[3][2] = -((2.*far*near)/rng);\n    m[3][3] = 0.;\n    return m;\n}\n\nmat4 translate(vec3 v) {\n    mat4 m = mat4(1.);\n    m[3][0] = v.x;\n    m[3][1] = v.y;\n    m[3][2] = v.z;\n    return m;\n}\n\nmat4 rotateX(float angle) {\n    float r = radians(angle), s = sin(r), c = cos(r);\n    mat4 m = mat4(1.);\n    float m10 = m[1][0], m20 = m[2][0];\n    float m11 = m[1][1], m21 = m[2][1];\n    float m12 = m[1][2], m22 = m[2][2];\n    float m13 = m[1][3], m23 = m[2][3];\n    m[1][0] = m10 * c - m20 * s;\n\tm[1][1] = m11 * c - m21 * s;\n\tm[1][2] = m12 * c - m22 * s;\n\tm[1][3] = m13 * c - m23 * s;\n\tm[2][0] = m10 * s + m20 * c;\n\tm[2][1] = m11 * s + m21 * c;\n\tm[2][2] = m12 * s + m22 * c;\n\tm[2][3] = m13 * s + m23 * c;\n    return m;\n}\n\nmat4 rotateY(float angle) {\n    float r = radians(angle), s = sin(r), c = cos(r);\n    mat4 m = mat4(1.);\n    float m00 = m[0][0], m20 = m[2][0];\n    float m01 = m[0][1], m21 = m[2][1];\n    float m02 = m[0][2], m22 = m[2][2];\n    float m03 = m[0][3], m23 = m[2][3];\n    m[0][0] = m00 * c - m20 * s;\n\tm[0][1] = m01 * c - m21 * s;\n\tm[0][2] = m02 * c - m22 * s;\n\tm[0][3] = m03 * c - m23 * s;\n\tm[2][0] = m00 * s + m20 * c;\n\tm[2][1] = m01 * s + m21 * c;\n\tm[2][2] = m02 * s + m22 * c;\n\tm[2][3] = m03 * s + m23 * c;\n    return m;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftl3Ds.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1034, 1034, 1088, 1122, 1165], [1167, 1167, 1200, 1200, 1237], [1390, 1390, 1471, 1471, 3384], [3415, 3415, 3472, 3472, 3851]], "test": "untested"}
{"id": "NtlGDs", "name": "Multi-Channel (RGB) MNCA", "author": "SlackermanzCA", "description": "Multi-Channel Continuous Multiple Neighborhood Cellular Automata", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 4, "viewed": 447, "published": 3, "date": "1623131178", "time_retrieved": "2024-07-30T19:16:58.087714", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch( iChannel0, ivec2(gl_FragCoord[0], gl_FragCoord[1]), 0); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n\nconst uint MAX_RADIUS = 10u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\nfloat vwm()\t\t\t\t\t\t\t{ return 255.000336 * 1.0; }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), vwm()); }\n    \nvec4  gdv( ivec2 of, sampler2D tx ) {\n\tof \t\t= ivec2(gl_FragCoord) + of;\n\tof[0] \t= (of[0] + textureSize(tx,0)[0]) % (textureSize(tx,0)[0]);\n\tof[1] \t= (of[1] + textureSize(tx,0)[1]) % (textureSize(tx,0)[1]);\n\treturn \ttexelFetch( tx, of, 0); }\n    \nvec4 nbhd( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4\ta = vec4(0.0,0.0,0.0,0.0);\n\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\tfloat\tw = 1.0;\n\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\tvec4 t0  = gdv( ivec2( i, j), tx ) * w * psn; a += t0 - fract(t0);\n\t\t\t\tvec4 t1  = gdv( ivec2( j,-i), tx ) * w * psn; a += t1 - fract(t1);\n\t\t\t\tvec4 t2  = gdv( ivec2(-i,-j), tx ) * w * psn; a += t2 - fract(t2);\n\t\t\t\tvec4 t3  = gdv( ivec2(-j, i), tx ) * w * psn; a += t3 - fract(t3); } } }\n\treturn a; }\n    \nvec4 totl( vec2 r, sampler2D tx ) {\n//\tPrecision limit of signed float32 for [n] neighbors in a 16 bit texture (symmetry preservation)\n\tuint\tchk = 2147483648u /\n\t\t\t(\t( \tuint( r[0]*r[0]*PI + r[0]*PI + PI\t)\n\t\t\t\t- \tuint( r[1]*r[1]*PI + r[1]*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= 65536u) ? 65536.0 : float(chk);\n\tvec4 \tb = vec4(0.0,0.0,0.0,0.0);\n\tfor(float i = 0.0; i <= r[0]; i++) {\n\t\tfor(float j = 1.0; j <= r[0]; j++) {\n\t\t\tfloat\td = round(sqrt(i*i+j*j));\n\t\t\tfloat\tw = 1.0;\n\t\t\tif( d <= r[0] && d > r[1] ) { b\t+= w * psn * 4.0; } } }\n\treturn b; }\n                \nvec4 bitring(vec4[MAX_RADIUS] rings_a, vec4[MAX_RADIUS] rings_b, uint bits, uint of) {\n\tvec4 sum = vec4(0.0,0.0,0.0,0.0);\n\tvec4 tot = vec4(0.0,0.0,0.0,0.0);\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i+of) == 1u) { sum += rings_a[i]; tot += rings_b[i]; } }\n\treturn sum / tot; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    //\tParameters\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\tconst\tfloat \ts  \t\t= mnp *  96.0 *  96.0;\n\tconst\tfloat \tn  \t\t= mnp *  96.0 *  16.0;\n    \n\tvec4 res_c = gdv( ivec2(0, 0), txdata );\n    \n    //\tNH Rings\n\tvec4[MAX_RADIUS] nh_rings_c_a;\n\tvec4[MAX_RADIUS] nh_rings_c_b;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tnh_rings_c_a[i] = nbhd( vec2(i+1u,i), txdata );\n\t\tnh_rings_c_b[i] = totl( vec2(i+1u,i), txdata ); }\n        \n    uint[12] NB = uint[12] (\n\t\t1857775778u, 373976652u,  2050229723u, 3957459881u, \n\t\t2971170932u, 179461069u,  3501247727u, 1512432443u, \n\t\t956981535u,  2382362945u, 168996476u,  2033912016u  );\n        \n    uint[24] UD = uint[24] (\n\t\t69206018u,   887201330u,  529408915u,  4175580383u, \n\t\t394674196u,  1588503026u, 90701929u,   2284734815u, \n\t\t1556401948u, 2673158198u, 4228048446u, 716239805u, \n\t\t1175339528u, 4070697602u, 3108524504u, 4271215171u, \n\t\t1366665979u, 2104054760u, 3123817950u, 2010068087u, \n\t\t2867880264u, 2061177276u, 3179780908u, 683022191u   );\n        \n    uint[ 2] SN = uint[ 2] (\n\t\t1631696705u, 2329356951u                            );\n\n\tuint[ 3] IO = uint[ 3] (\n\t\t2286157824u, 295261525u, 1713547946u                );\n\n\n    for(uint i = 0u; i < 24u; i++) {\n\t\tfloat nhv = bitring( nh_rings_c_a, nh_rings_c_b, NB[i/2u], (i & 1u) * 16u )[u32_upk( IO[i/8u], 2u, (i*4u+0u) & 31u )];\n\t\tif( nhv >= utp( UD[i], 8u, 0u) && nhv <= utp( UD[i], 8u, 1u)) { res_c[u32_upk( IO[i/8u], 2u, (i*4u+2u) & 31u )] += bsn(SN[i/16u], ((i*2u+0u) & 31u))*s; }\n\t\tif( nhv >= utp( UD[i], 8u, 2u) && nhv <= utp( UD[i], 8u, 3u)) { res_c[u32_upk( IO[i/8u], 2u, (i*4u+2u) & 31u )] += bsn(SN[i/16u], ((i*2u+1u) & 31u))*s; } }\n    \n\tres_c -= n;\n    res_c  = clamp(res_c,0.0,1.0);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = round(mod(float(iFrame),3.0));\n        res_c[2] = round(mod(float(iFrame),5.0)); }\n    if (iFrame == 0) { res_c[0] = reseed(0); res_c[1] = reseed(1); res_c[2] = reseed(2); }\n    fragColor=res_c;\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1055, 1141]], "test": "untested"}
{"id": "7tfGDs", "name": "Colorfully Lit Clouds", "author": "Zi7ar21", "description": "Some nice path-traced clouds.", "tags": ["raymarching", "ray", "raymarch", "raymarched", "gi", "volumetric", "raymarcher", "pathtrace", "pathtracing", "pathtracer", "trace", "path", "pathtraced"], "likes": 17, "viewed": 545, "published": 3, "date": "1623129208", "time_retrieved": "2024-07-30T19:16:58.856658", "image_code": "// ####### Colorfully Lit Clouds #######\n// Made by Jacob Bingham (Zi7ar21) on June 7th, 2021\n// Last Updated on June 7th, 2021 at 11:10 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/7tfGDs\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb_Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Final Image\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = HDRtoLDR(color);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### Parameters #####\n\n// Gamma Correction (Affects Preview Only, Image Export is Linear)\n#define gamma 2.2\n\n// Camera Field of View\n#define camfov 1.0\n\n// 1U = Direct Lighting\n// 4U = Eh, at least it's lit up\n// 8U = Good Global Illumination\n// 32U = Great Global Illumination\n// 128U = Perfect Global Illumination\n// 1024U = Absolutely no sane reason to go any higher\n#define maxBounces 8U\n\n// 0.25 = Garbage Density\n// 0.125 = Poor Density\n// 0.0625 = Great Density\n// 0.01 = Unreasonable and Very Slow, don't go any lower unless you are sampling really close objects\n//#define stepSize 0.0625\n#define stepSize 0.0625\n\n// 128U = Garbage Sampling\n// 1024U = OK Sampling\n// 8192U = Great Sampling\n// 65536U = Perfect Sampling, no need to go any higher\n#define maxStep 8192U\n// Note: use a low value and adjust the stepSize first, and then increase until nothing changes\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// ##### Shortcuts #####\n\n// Traditional Input Names\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffer\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// ##### Color Management #####\n\n// HDR Tonemapping Function\nvec3 HDRtoLDR(vec3 color)\n{\n    // Ensures that there is no values less than 0.0\n    color = max(color, 0.0);\n\n    // Sh*t Color Space Thing\n    color = vec3(\n    (color.r*1.00)+(color.g*0.05)+(color.b*0.03),\n    (color.r*0.05)+(color.g*1.00)+(color.b*0.04),\n    (color.r*0.03)+(color.g*0.04)+(color.b*1.00));\n\n    // Fit values to 0.0-1.0 and apply Gamma Correction\n    color = pow(color/(color+1.0), vec3(1.0/gamma));\n\n    // Return the Color\n    return clamp(color, 0.0, 1.0);\n}\n\n// ##### Random Number Generator #####\n\n// triple32 \"Best\" Integer Hash: https://www.shadertoy.com/view/WttXWX\nuint triple32(uint x)\n{\n    x ^= x >> 17U;\n    x *= 0xED5AD4BBU;\n    x ^= x >> 11U;\n    x *= 0xAC4C1B51U;\n    x ^= x >> 15U;\n    x *= 0x31848BABU;\n    x ^= x >> 14U;\n    return x;\n}\n// Honestly you should look into PCG Random for your own projects\n// I just used triple32 because the code looks elegant\n\n// Random Number Generator Seed\nuint ns;\n\n// Initialize Seed\n#define initializeRNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n//#define initializeRNG ns = uint(frame)\n\n// Random Scalar from 0.0 to 1.0\nfloat rand()\n{\n    ns = triple32(ns);\n    return float(ns)/float(0xFFFFFFFFU);\n}\n\n// Random Vectors\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand2(), rand());}\nvec4 rand4(){return vec4(rand3(), rand());}\n\n// Normalized Random Vectors: https://www.shadertoy.com/view/WttyWX\nvec2 nrand2(float sigma, vec2 mean)\n{\n    vec2 z = rand2();\n    return mean+sigma*sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n    vec4 z = rand4();\n    return mean+sigma*sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w));\n}\n\n// Uniform Random Vectors\nvec2 urand2()\n{\n    vec2 z = rand2();\n    return normalize(sqrt(-2.0*log(z.x   ))*vec2(cos(2.0*pi*z.y), sin(2.0*pi*z.y)));\n}\n\nvec3 urand3()\n{\n    vec4 z = rand4();\n    return normalize(sqrt(-2.0*log(z.xxy ))*vec3(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w)));\n}\n\nvec4 urand4()\n{\n    vec4 z = rand4();\n    return normalize(sqrt(-2.0*log(z.xxyy))*vec4(cos(2.0*pi*z.z), sin(2.0*pi*z.z), cos(2.0*pi*z.w), sin(2.0*pi*z.w)));\n}", "buffer_a_code": "// ##### Rendering #####\n\n/*\n// Noise (from Sampler)\nfloat noise(vec3 pos)\n{\n    return texture(iChannel1, pos/32.0).x;\n}\n*/\n\n// Dot Product on a Vector\n// (E.G. dotp(vector0-vector1) vs. dot(vector0-vector1, vector0-vector1))\nfloat dotp(vec3 vec)\n{\n    return dot(vec, vec);\n}\n\n// hash33 Hash without Sine: https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3*vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// Worley Noise\nfloat noise(vec3 pos)\n{\n    // Scale\n    pos = pos/32.0;\n\n    // Set-Up Variables\n    float minDist = 1000.0;\n\n    // Loop over 3x3x3 Volume\n    for(int x = -1; x <= 1; x++) {\n    for(int y = -1; y <= 1; y++) {\n    for(int z = -1; z <= 1; z++) {\n        // Nearest Point's Distance\n        minDist = min(dotp(fract(pos)-(vec3(x, y, z)+hash33(floor(vec3(x, y, z)+pos)/32.0))), minDist);\n    }\n    }\n    }\n\n    // Return the Value (Inverted for Cloud-like effect)\n    return max(1.0-sqrt(minDist), 0.0);\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec3 pos)\n{\n    // Set-Up Variables\n    float value = 0.0;\n    float scale = 1.0;\n    float atten = 0.5;\n\n    // Octaves\n    for(uint i = 0U; i < 4U; i++)\n    {\n        // Add Octave\n        value += noise(pos*scale)*atten;\n\n        // Increase Frequency\n        scale *= 2.0;\n\n        // Decrease Contribution of Next Octave\n        atten *= 0.5;\n    }\n\n    // Return the Final Value\n    return value;\n}\n\n// Volumetric Density Function\nfloat getVolume(vec3 pos, out vec3 volumeColor)\n{\n    // Default Color\n    volumeColor = vec3(0.8);\n\n    // Skip Sampling Noise Where it isn't Needed (Performance Increase)\n    if(dot(pos, pos) > 2.0 || pos.y > 0.16)\n    {\n        return 0.0;\n    }\n\n    float falloff = pos.y+0.6;\n\n    // Calculate Density\n    float density = max(fbm(pos*50.0)-falloff, 0.0)*256.0;\n\n    // blue fog test\n    //volumeColor = density > 0.0 ? vec3(0.5) : vec3(0.6, 0.8, 1.0);\n\n    // Return the Density\n    return density;\n}\n\n// Color of the Sky\nvec3 skyColor(vec3 dir)\n{\n    // Light\n    if(dot(normalize(vec3(1.0, 0.5, 1.0)), dir) > 0.95)\n    {\n        return vec3(10.0);\n    }\n\n    // Simple Atmosphere Effect\n    //return vec3(max(dot(vec3(0.0, 1.0, 0.0), dir)*0.8, 0.0)+0.2);\n\n    // Black Sky\n    return vec3(0.0);\n}\n\n// Light Collision Checker\nbool lightSource(vec3 pos, out vec3 color)\n{\n    color = vec3(10.0);\n\n    // Light Positions\n    vec3 light0 = vec3(-1.0, 0.0,-1.0);\n    vec3 light1 = vec3( 1.0, 0.0,-1.0);\n    vec3 light2 = vec3(-1.0, 0.0, 1.0);\n    vec3 light3 = vec3( 1.0, 0.0, 1.0);\n\n    // Find the Nearest Light\n    float minDist = min(min(dotp(pos-light0), dotp(pos-light1)), min(dotp(pos-light2), dotp(pos-light3)));\n\n    // Light Colors\n    color = minDist == dotp(pos-light0) ? vec3(2.00, 0.05, 0.05) : color;\n    color = minDist == dotp(pos-light1) ? vec3(2.00, 2.00, 0.05) : color;\n    color = minDist == dotp(pos-light2) ? vec3(0.05, 2.00, 0.05) : color;\n    color = minDist == dotp(pos-light3) ? vec3(0.05, 0.05, 2.00) : color;\n\n    // Return Collision\n    return minDist < 0.1;\n}\n\n// Volumetric Path-Tracing\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    vec3 raypos = ro;\n\n    // Initial Ray Length\n    float t = rand()*stepSize;\n\n    vec3 attenuation = vec3(1.0);\n    vec3 volumeColor = vec3(0.0);\n    uint bounces = 0U;\n\n    // Ray-Marching\n    for(uint i = 0U; i < maxStep; i++)\n    {\n        if(bounces > maxBounces)\n        {\n            break;\n        }\n\n        if(dot(raypos+rd*t, raypos+rd*t) > 2.5)\n        {\n            return attenuation*skyColor(rd);\n        }\n\n        vec3 lightColor;\n\n        if(lightSource(raypos+rd*t, lightColor))\n        {\n            return attenuation*lightColor;\n        }\n\n        float density = getVolume(raypos+rd*t, volumeColor);\n\n        float absorbance = exp(-density*stepSize);\n\n        if(absorbance < rand())\n        {\n            attenuation = clamp(attenuation*volumeColor, 0.0, 1.0);\n            raypos += rd*t;\n            t = 0.0;\n            rd = urand3();\n            bounces++;\n        }\n\n        t += stepSize;\n    }\n\n    // Sample Never Hit Anything, values below 0.0 will be discarded\n    return vec3(-1.0);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Progressive Rendering\n    fragColor = frame != 0 ? texel0 : vec4(0.0);\n\n    // Initialize the Random Number Generator\n    initializeRNG;\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, gl_FragCoord.xy)-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n    vec3 ro = vec3(0.0, 0.5, -1.5);\n    //mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, -0.5, 1.0);\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render and Output the Frame\n    vec3 color = radiance(ro, rd);\n\n    // Output the Rendered Frame\n    fragColor += any(lessThan(color, vec3(0.0))) || any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### Image Export #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Rendering Buffer\n    vec4 texel = texel0;\n\n    // Output the Final Image\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfGDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[511, 528, 583, 610, 761]], "test": "untested"}
{"id": "ftsGDl", "name": "Voxel Fractal City [2TC]", "author": "KilledByAPixel", "description": "Tiny voxel raycaster based on a dweet: https://www.dwitter.net/d/23062", "tags": ["voxel", "city", "tiny", "2tc"], "likes": 10, "viewed": 461, "published": 3, "date": "1623125489", "time_retrieved": "2024-07-30T19:16:59.685443", "image_code": "void mainImage(out vec4 c, vec2 p)\n{\n  ivec4 b = ivec4(c -= c);\n  for(;(b.x&=b.y^b.z-99)%99>b.z-64;)\n    b = ivec4(p/iResolution.xy*2.*c.z - c.z + iTime*vec2(49, 9), c += .1);\n  c = sin(float(b))*.5 +8e2*vec4(b%8)/c/c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 220]], "test": "untested"}
{"id": "NtsGWs", "name": "No Shera", "author": "jorge2017a1", "description": "No es Shera, no recuerdo su nombre :)", "tags": ["2d", "draw", "polygon", "poligono", "shera"], "likes": 5, "viewed": 244, "published": 3, "date": "1623117989", "time_retrieved": "2024-07-30T19:17:00.711699", "image_code": "//por jorge2017a1 ----jorgeFloresP---7/jun/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 colBlanco= vec3(1.0);\nconst vec3 col0= vec3(0.18,0.05,0.00);\nconst vec3 col1= vec3(0.98,0.47,0.63);\nconst vec3 col2= vec3(0.57,0.22,0.48);\nconst vec3 col3= vec3(0.64,0.11,0.13);\nconst vec3 col4= vec3(0.69,0.38,0.65);\nconst vec3 col5= vec3(0.11,0.28,0.56);\nconst vec3 col6= vec3(0.96,0.60,0.12);\nconst vec3 col7= vec3(0.87,0.66,0.56);\nconst vec3 col8= vec3(0.89,0.66,0.56);\n\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPolyc000 POLY(17)\nvec2 ptc000[ 17]=vec2[](  \nvec2(.118,.004),vec2(.170,.160),vec2(.208,.304),vec2(.242,.494),vec2(.269,.685),\nvec2(.278,.771),vec2(.300,.896),vec2(.323,.998),vec2(.998,.998),vec2(.996,.004),\nvec2(.854,.006),vec2(.849,.077),vec2(.849,.169),vec2(.852,.254),vec2(.546,.244),\nvec2(.557,.008),vec2(.118,.004) );\n\n\nfloat sdPolyc001 POLY(39)\nvec2 ptc001[ 39]=vec2[](  \nvec2(.452,.008),vec2(.420,.010),vec2(.390,.083),vec2(.388,.277),vec2(.395,.581),\nvec2(.383,.660),vec2(.383,.677),vec2(.388,.692),vec2(.399,.810),vec2(.426,.910),\nvec2(.465,.998),vec2(.840,.998),vec2(.869,.956),vec2(.891,.910),vec2(.943,.798),\nvec2(.954,.771),vec2(.985,.727),vec2(.981,.683),vec2(.972,.490),vec2(.973,.333),\nvec2(.993,.096),vec2(.926,.017),vec2(.867,.010),vec2(.878,.165),vec2(.889,.367),\nvec2(.891,.625),vec2(.874,.748),vec2(.845,.835),vec2(.792,.879),vec2(.721,.865),\nvec2(.639,.788),vec2(.554,.867),vec2(.519,.879),vec2(.480,.858),vec2(.445,.788),\nvec2(.426,.708),vec2(.425,.519),vec2(.441,.292),vec2(.452,.008) );\n\nfloat sdPolyc002 POLY(23)\nvec2 ptc002[ 23]=vec2[](  \nvec2(.555,.352),vec2(.567,.350),vec2(.583,.363),vec2(.598,.377),vec2(.608,.390),\nvec2(.626,.396),vec2(.637,.388),vec2(.644,.388),vec2(.655,.394),vec2(.663,.394),\nvec2(.678,.390),vec2(.714,.360),vec2(.727,.354),vec2(.742,.352),vec2(.719,.346),\nvec2(.694,.348),vec2(.676,.350),vec2(.651,.340),vec2(.639,.346),vec2(.626,.352),\nvec2(.623,.346),vec2(.597,.340),vec2(.555,.352) );\n\nfloat sdPolyc003 POLY(21)\nvec2 ptc003[ 21]=vec2[](  \nvec2(.570,.346),vec2(.582,.342),vec2(.593,.342),vec2(.609,.342),vec2(.626,.348),\nvec2(.631,.350),vec2(.639,.344),vec2(.649,.338),vec2(.657,.340),vec2(.666,.350),\nvec2(.679,.350),vec2(.700,.350),vec2(.719,.348),vec2(.727,.346),vec2(.717,.327),\nvec2(.696,.292),vec2(.680,.283),vec2(.618,.279),vec2(.607,.290),vec2(.587,.313),\nvec2(.570,.346) );\n\nfloat sdPolyc004 POLY(7)\nvec2 ptc004[ 7]=vec2[](  \nvec2(.431,.481),vec2(.446,.452),vec2(.470,.417),vec2(.470,.413),vec2(.446,.448),\nvec2(.431,.477),vec2(.431,.481) );\n\nfloat sdPolyc005 POLY(7)\nvec2 ptc005[ 7]=vec2[](  \nvec2(.890,.490),vec2(.875,.460),vec2(.844,.421),vec2(.844,.417),vec2(.875,.456),\nvec2(.890,.485),vec2(.890,.490) );\n\nfloat sdPolyc006 POLY(9)\nvec2 ptc006[ 9]=vec2[](  \nvec2(.616,.681),vec2(.628,.613),vec2(.628,.577),vec2(.622,.519),vec2(.624,.519),\nvec2(.630,.577),vec2(.630,.613),vec2(.618,.681),vec2(.616,.681) );\n\nfloat sdPolyc007 POLY(9)\nvec2 ptc007[ 9]=vec2[](  \nvec2(.610,.502),vec2(.604,.488),vec2(.604,.473),vec2(.612,.460),vec2(.615,.460),\nvec2(.607,.473),vec2(.607,.488),vec2(.612,.502),vec2(.610,.502) );\n\nfloat sdPolyc008 POLY(13)\nvec2 ptc008[ 13]=vec2[](  \nvec2(.670,.523),vec2(.678,.504),vec2(.685,.492),vec2(.691,.477),vec2(.686,.465),\nvec2(.681,.463),vec2(.684,.463),vec2(.689,.465),vec2(.693,.477),vec2(.687,.492),\nvec2(.680,.504),vec2(.672,.523),vec2(.670,.523) );\n\n\nfloat sdPolyc009 POLY(11)\nvec2 ptc009[ 11]=vec2[](  \nvec2(.618,.471),vec2(.625,.473),vec2(.632,.465),vec2(.638,.465),vec2(.639,.463),\nvec2(.639,.458),vec2(.638,.460),vec2(.632,.460),vec2(.625,.469),vec2(.618,.467),\nvec2(.618,.471) );\n\nfloat sdPolyc010 POLY(9)\nvec2 ptc010[ 9]=vec2[](  \nvec2(.651,.463),vec2(.657,.469),vec2(.665,.471),vec2(.672,.471),vec2(.672,.467),\nvec2(.665,.467),vec2(.657,.465),vec2(.651,.458),vec2(.651,.463) );\n\nfloat sdPolyc011 POLY(13)\nvec2 ptc011[ 13]=vec2[](  \nvec2(.473,.773),vec2(.493,.785),vec2(.512,.790),vec2(.532,.788),vec2(.556,.773),\nvec2(.570,.760),vec2(.562,.754),vec2(.544,.773),vec2(.529,.781),vec2(.513,.781),\nvec2(.495,.779),vec2(.477,.767),vec2(.473,.773) );\n\nfloat sdPolyc012 POLY(14)\nvec2 ptc012[ 14]=vec2[](  \nvec2(.724,.763),vec2(.746,.783),vec2(.773,.792),vec2(.787,.794),vec2(.810,.785),\nvec2(.830,.771),vec2(.838,.758),vec2(.836,.756),vec2(.809,.779),vec2(.789,.785),\nvec2(.779,.783),vec2(.753,.769),vec2(.734,.758),vec2(.724,.763) );\n\n\nfloat sdPolyc013 POLY(7)\nvec2 ptc013[ 7]=vec2[](  \nvec2(.680,.654),vec2(.677,.631),vec2(.684,.606),vec2(.686,.606),vec2(.679,.631),\nvec2(.683,.654),vec2(.680,.654) );\n\nfloat sdPolyc014 POLY(16)\nvec2 ptc014[ 16]=vec2[](  \nvec2(.438,.369),vec2(.451,.315),vec2(.501,.233),vec2(.552,.160),vec2(.594,.123),\nvec2(.632,.115),vec2(.676,.115),vec2(.722,.129),vec2(.783,.173),vec2(.881,.300),\nvec2(.900,.883),vec2(.422,.879),vec2(.426,.681),vec2(.426,.515),vec2(.432,.429),\nvec2(.438,.369) );\n\nfloat sdPolyc015 POLY(14)\nvec2 ptc015[ 14]=vec2[](  \nvec2(.470,.652),vec2(.474,.629),vec2(.484,.615),vec2(.504,.598),vec2(.530,.594),\nvec2(.544,.600),vec2(.576,.619),vec2(.587,.623),vec2(.573,.650),vec2(.555,.677),\nvec2(.527,.692),vec2(.493,.690),vec2(.477,.667),vec2(.470,.652) );\n\n\nfloat sdPolyc016 POLY(12)\nvec2 ptc016[ 12]=vec2[](  \nvec2(.486,.690),vec2(.499,.700),vec2(.519,.708),vec2(.536,.708),vec2(.559,.708),\nvec2(.587,.623),vec2(.562,.665),vec2(.544,.683),vec2(.508,.692),vec2(.498,.690),\nvec2(.471,.663),vec2(.486,.690) );\n\nfloat sdPolyc017 POLY(12)\nvec2 ptc017[ 12]=vec2[](  \nvec2(.501,.692),vec2(.479,.702),vec2(.481,.692),vec2(.465,.694),vec2(.473,.683),\nvec2(.452,.690),vec2(.461,.671),vec2(.444,.679),vec2(.465,.652),vec2(.478,.669),\nvec2(.499,.685),vec2(.501,.692) );\n\nfloat sdPolyc018 POLY(15)\nvec2 ptc018[ 15]=vec2[](  \nvec2(.712,.617),vec2(.732,.608),vec2(.761,.594),vec2(.768,.592),vec2(.786,.592),\nvec2(.821,.606),vec2(.834,.619),vec2(.837,.654),vec2(.829,.669),vec2(.806,.683),\nvec2(.775,.692),vec2(.748,.681),vec2(.735,.658),vec2(.720,.631),vec2(.712,.617) );\n\nfloat sdPolyc019 POLY(13)\nvec2 ptc019[ 13]=vec2[](  \nvec2(.713,.621),vec2(.726,.665),vec2(.733,.688),vec2(.739,.700),vec2(.756,.706),\nvec2(.793,.702),vec2(.822,.688),vec2(.838,.669),vec2(.834,.663),vec2(.795,.690),\nvec2(.778,.690),vec2(.748,.683),vec2(.713,.621) );\n\nfloat sdPolyc020 POLY(14)\nvec2 ptc020[ 14]=vec2[](  \nvec2(.807,.688),vec2(.824,.698),vec2(.827,.692),vec2(.838,.698),vec2(.835,.688),\nvec2(.840,.683),vec2(.852,.685),vec2(.845,.671),vec2(.859,.677),vec2(.856,.665),\nvec2(.840,.656),vec2(.827,.671),vec2(.806,.681),vec2(.807,.688) );\n\nfloat sdPolyc021 POLY(11)\nvec2 ptc021[ 11]=vec2[](  \nvec2(.347,.335),vec2(.326,.248),vec2(.319,.188),vec2(.316,.165),vec2(.331,.015),\nvec2(.334,.015),vec2(.319,.165),vec2(.321,.188),vec2(.328,.248),vec2(.349,.335),\nvec2(.347,.335) );\n\nfloat sdPolyc022 POLY(11)\nvec2 ptc022[ 11]=vec2[](  \nvec2(.385,.692),vec2(.378,.675),vec2(.351,.638),vec2(.323,.554),vec2(.301,.444),\nvec2(.301,.440),vec2(.323,.550),vec2(.351,.633),vec2(.378,.671),vec2(.385,.688),\nvec2(.385,.692) );\n\nfloat sdPolyc023 POLY(10)\nvec2 ptc023[ 10]=vec2[](  \nvec2(.495,.679),vec2(.499,.652),vec2(.501,.631),vec2(.514,.615),vec2(.536,.617),\nvec2(.549,.629),vec2(.554,.658),vec2(.554,.683),vec2(.523,.702),vec2(.495,.679) );\n\nfloat sdPolyc024 POLY(11)\nvec2 ptc024[ 11]=vec2[](  \nvec2(.746,.679),vec2(.745,.648),vec2(.752,.621),vec2(.768,.613),vec2(.787,.613),\nvec2(.800,.623),vec2(.804,.646),vec2(.807,.673),vec2(.802,.685),vec2(.775,.702),\nvec2(.746,.679) );\n\nfloat sdPolyc025 POLY(10)\nvec2 ptc025[ 10]=vec2[](  \nvec2(.598,.996),vec2(.681,.998),vec2(.676,.960),vec2(.662,.913),vec2(.648,.896),\nvec2(.628,.896),vec2(.610,.910),vec2(.600,.944),vec2(.597,.988),vec2(.598,.996) );\n\nfloat sdPolyc026 POLY(9)\nvec2 ptc026[ 9]=vec2[](  \nvec2(.610,.994),vec2(.665,.992),vec2(.665,.967),vec2(.656,.938),vec2(.646,.923),\nvec2(.633,.919),vec2(.619,.929),vec2(.609,.969),vec2(.610,.994) );\n\n//***------------****-----------****------------******-------\nvec3 RostroNoShera(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n\n    //pelo\n    float sdc000 = sdPolyc000(p, ptc000);\n    col=ponerBorde(col1,col,sdc000 );\n\n\n//rostro\nfloat sdc014 = sdPolyc014(p, ptc014);\ncol=ponerBorde(col7,col,sdc014 );\n\n    float t1=mod(iTime,1.0);\n    float t2=mod(iTime,2.0);\n\n    \n    if(t1<t2)\n    {\n        col=ponerBorde(col6,col,sdc014 );\n    }\n    \nfloat sdc001 = sdPolyc001(p, ptc001);\ncol=ponerBorde(col2,col,sdc001 );\n\nfloat sdc002 = sdPolyc002(p, ptc002);\ncol=ponerBorde(col3,col,sdc002 );\n\nfloat sdc003 = sdPolyc003(p, ptc003);\ncol=ponerBorde(col3,col,sdc003 );\n\nfloat sdc004 = sdPolyc004(p, ptc004);\ncol=ponerBorde(col1,col,sdc004 );\n\nfloat sdc005 = sdPolyc005(p, ptc005);\ncol=ponerBorde(col1,col,sdc005 );\n\nfloat sdc006 = sdPolyc006(p, ptc006);\ncol=ponerBorde(col1,col,sdc006 );\n\n//linea nariz 1\nfloat sdc007 = sdPolyc007(p, ptc007);\ncol=ponerBorde(col1,col,sdc007 );\n\n//linea nariz 2\nfloat sdc008 = sdPolyc008(p, ptc008);\ncol=ponerBorde(col1,col,sdc008 );\n\n//linea nariz 3\nfloat sdc009 = sdPolyc009(p, ptc009);\ncol=ponerBorde(col1,col,sdc009 );\n\n//linea nariz 4\nfloat sdc010 = sdPolyc010(p, ptc010);\ncol=ponerBorde(col1,col,sdc010 );\n\n//pestaña izq\nfloat sdc011 = sdPolyc011(p, ptc011);\ncol=ponerBorde(colNegro,col,sdc011 );\n\n//pestaña der\nfloat sdc012 = sdPolyc012(p, ptc012);\ncol=ponerBorde(colNegro,col,sdc012 );\n\n//linea\nfloat sdc013 = sdPolyc013(p, ptc013);\ncol=ponerBorde(col1,col,sdc013 );\n\n//ojo izq\nfloat sdc015 = sdPolyc015(p, ptc015);\ncol=ponerBorde(colBlanco,col,sdc015 );\n\n//cornea izq\nfloat sdc023 = sdPolyc023(p, ptc023);\ncol=ponerBorde(col5,col,sdc023 );\n\n//pestaña izq\nfloat sdc016 = sdPolyc016(p, ptc016);\ncol=ponerBorde(col1,col,sdc016 );\n\nfloat sdc017 = sdPolyc017(p, ptc017);\ncol=ponerBorde(colNegro,col,sdc017 );\n\n//ojo der\nfloat sdc018 = sdPolyc018(p, ptc018);\ncol=ponerBorde(colBlanco,col,sdc018 );\n//cornea der\nfloat sdc024 = sdPolyc024(p, ptc024);\ncol=ponerBorde(col5,col,sdc024 );\n\nfloat  pupilader=sdCircle( p-vec2(0.77,0.65), 0.01 );\ncol=ponerBorde(colNegro,col,pupilader );\n\nfloat  pupilaIzq=sdCircle( p-vec2(0.52,0.65), 0.01 );\ncol=ponerBorde(colNegro,col,pupilaIzq );\n\n//pestaña der\nfloat sdc019 = sdPolyc019(p, ptc019);\ncol=ponerBorde(col1,col,sdc019 );\n\n//ceja der\nfloat sdc020 = sdPolyc020(p, ptc020);\ncol=ponerBorde(colNegro,col,sdc020 );\n\n//linea 1\nfloat sdc021 = sdPolyc021(p, ptc021);\ncol=ponerBorde(colNegro,col,sdc021 );\n\n//linea 2\nfloat sdc022 = sdPolyc022(p, ptc022);\ncol=ponerBorde(colNegro,col,sdc022 );\n\nfloat sdc025 = sdPolyc025(p, ptc025);\ncol=ponerBorde(col6,col,sdc025 );\n\n\nfloat sdc026 = sdPolyc026(p, ptc026);\ncol=ponerBorde(col4,col,sdc026 );\n\n    \n    if(t1<t2)\n    {\n        //ojo der\n        col=ponerBorde(col7,col,sdc018-0.001 );\n        \n        //ojo izq\n        col=ponerBorde(col7,col,sdc015-0.001 );\n    }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.35;\n    vec2 p=uv;\n    p=p*0.55-vec2(-0.7,-0.5);\n    p.x*=0.6;\n    vec3 col=colNegro;\n     \n    col=RostroNoShera(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 278, 313, 313, 341], [343, 381, 417, 417, 462], [469, 469, 530, 530, 654], [657, 657, 717, 717, 843], [1263, 1263, 1294, 1294, 1315], [8954, 9016, 9059, 9059, 11833], [11835, 11835, 11892, 11892, 12165]], "test": "untested"}
{"id": "NlsGDl", "name": "Turbulent seas", "author": "jarble", "description": "The wind is blowing over the waves.", "tags": ["noise", "waves", "fbm", "ocean"], "likes": 6, "viewed": 358, "published": 3, "date": "1623107612", "time_retrieved": "2024-07-30T19:17:01.675123", "image_code": "#define SC (250.0)\n\nfloat random(vec2 p)\n{\n    return fract(p.x*p.y*fract(p.x*0.1183099));\n}\n\nfloat noise(in vec2 uv)\n{\n    return sin(uv.x+iTime)+cos(uv.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // value += noise(uv * freq) * amplitude;\n        \n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value += (.25-abs(noise(uv * freq)-.3) * amplitude);\n        \n        amplitude *= (.47+value)/2.0;\n        \n        freq *= 2.;\n        \n        uv += uv.yx/16.0;\n        uv = uv.yx;\n    }\n    \n    return value;\n}\n\nfloat f(in vec3 p)\n{\n    \n    float h = fbm(p.xz);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * iTime;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    \n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsGDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 42, 42, 92], [94, 94, 119, 119, 159], [179, 179, 202, 202, 676], [678, 678, 698, 698, 744], [746, 746, 779, 779, 973], [975, 975, 1042, 1042, 1252], [1254, 1254, 1306, 1306, 1851], [1853, 1853, 1904, 1904, 2105], [2107, 2107, 2133, 2133, 2209], [2212, 2212, 2269, 2269, 4009]], "test": "untested"}
{"id": "fts3Wl", "name": "Eroded mountain terrain (v1)", "author": "jarble", "description": "A modified version of an FBM terrain demo, using a much simpler noise function.", "tags": ["noise", "terrain", "fbm", "mountain", "erosion"], "likes": 16, "viewed": 543, "published": 3, "date": "1623101324", "time_retrieved": "2024-07-30T19:17:02.433097", "image_code": "#define SC (250.0)\n\nvec2 noise(in vec2 uv)\n{\n    return vec2(sin(uv.x),cos(uv.y));\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        vec2 n1 = noise(uv * freq);\n        value += (.25-abs(n1.x+n1.y-.3) * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 2.05;\n\n        uv = uv.yx + uv/16.0 + n1/freq;\n    }\n    \n    return value;\n}\n\nfloat f(in vec3 p)\n{\n    \n    float h = fbm(p.xz);\n    return h;\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 eps=vec3(.001 * t, .0, .0);\n    vec3 n=vec3(f(p - eps.xyy) - f(p + eps.xyy),\n                2. * eps.x,\n                f(p - eps.yyx) - f(p + eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd, float tMin, float tMax)\n{\n    float t = tMin;\n\tfor( int i = 0; i < 300; i++ )\n\t{\n        vec3 pos = ro + t * rd;\n\t\tfloat h = pos.y - f(pos);\n\t\tif( abs(h) < (0.0015 * t) || t > tMax ) \n            break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nvec3 lighting(vec3 p, vec3 normal, vec3 L, vec3 V)\n{\n    vec3 sunColor = vec3(1., .956, .839);\n    vec3 albedo = vec3(1.);\n   \tvec3 diff = max(dot(normal, L) * albedo, 0.);\n    \n    vec3 refl = normalize(reflect(L, normal));\n    float spec = max(dot(refl, -normalize(V)), 0.);\n    spec = pow(spec, 18.);\n    spec = clamp(spec, 0., 1.);\n    float sky = max(0.0, dot(vec3(0.,1.,0.), normal));\n    \n    //float amb = 0.5 * smoothstep(0.0, 2.0, p.y);\n    \n    vec3 col = diff * sunColor;\n    col += spec * sunColor;\n    col += sky * vec3(0., .6, 1.) * .1;\n    //col += amb * .2;\n    \n   \treturn col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n}\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\t\n    vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n    \n    vec3 camStep = vec3(lightDir.x, 0., lightDir.z) * iTime;\n    vec3 camPos = vec3(8., 2., 5.) + camStep;\n    vec3 camTarget = vec3(1., 1., 4.) + camStep;\n    mat3 mat = lookAt(camPos, camTarget, 0.0);\n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv.xy, 1.0));\n    rd.yx *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n    rd.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    float tMin = .1;\n    float tMax = 20.;\n    float t = rayMarching(ro, rd, tMin, tMax);\n    \n    vec3 col = vec3(0.);\n    \n    if (t > tMax)\n    {\n        // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n        float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        // sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc/SC)) );\n        // horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n    }\n    else\n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, t);\n        vec3 viewDir = normalize(ro - p);\n        \n        // lighting terrian\n        col = lighting(p, normal, lightDir, viewDir);\n        \n        // fog\n        float fo = 1.0-exp(-pow(30. * t/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, fco, fo);\n    }\n    \n    // Gama correction\n    col = pow(clamp(col, 0., 1.), vec3(.45)); \n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fts3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 44, 44, 84], [104, 104, 127, 127, 547], [549, 549, 569, 569, 615], [617, 617, 650, 650, 844], [846, 846, 913, 913, 1123], [1125, 1125, 1177, 1177, 1722], [1724, 1724, 1775, 1775, 1976], [1978, 1978, 2004, 2004, 2080], [2148, 2148, 2205, 2205, 4052]], "test": "untested"}
{"id": "ftl3Wl", "name": "Practice Simple Voronoi ", "author": "Venay", "description": "Just For Practice", "tags": ["voronoi"], "likes": 0, "viewed": 228, "published": 3, "date": "1623100418", "time_retrieved": "2024-07-30T19:17:03.335683", "image_code": "//---------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float size = 10.;\n    uv*=size;\n    \n    float a = Voronoi2D(uv);\n    fragColor = vec4(a);\n}", "image_inputs": [], "common_code": "float hash12(vec2 p){\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash22(vec2 uv){\n    float n = hash12(uv);\n    return vec2(n, hash12(uv + n));\n}\n\nvec3 hash33(vec3 v){\n    return vec3(hash12(v.xy), hash12(v.yz), hash12(v.xz));\n}\n//------------------\nfloat mDist(vec2 v1,vec2 v2){\n    return abs(v1.x - v2.x) + abs(v1.y - v2.y);\n}\n\nfloat Voronoi2D(vec2 uv){\n    vec2 id = floor(uv);\n    vec2 gv = uv-id;\n    float d = 1.;\n    \n    for(int i=-1 ; i<=1 ; i++){\n        for(int j=-1 ; j<=1 ; j++){\n            vec2 off = vec2(i,j);\n            vec2 v = hash22(id+off)+off;\n            d = min(d,distance(gv,v));\n        }\n    }\n    \n    return 1.-d;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftl3Wl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 18, 75, 75, 238]], "test": "untested"}
{"id": "slfGDs", "name": "Pioupiou", "author": "z0rg", "description": "piou", "tags": ["pioupiou"], "likes": 3, "viewed": 240, "published": 3, "date": "1623095225", "time_retrieved": "2024-07-30T19:17:04.320051", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0.,1.)\nmat2 r2d(float a){float ca = cos(a),sa=sin(a);return mat2(ca,-sa,sa,ca);}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n  vec2 l = abs(p)-s;\n  return max(l.x,l.y);\n}\n\n\nfloat line(vec2 p, vec2 s)\n{\n  vec2 rep = p;\n  rep.y= abs(p.y);\n  return min(_sqr(p, s),length(rep-vec2(0.,s.y))-s.x);\n}\nfloat pioupiou(vec2 p)\n{\n  return min(max(length(p)-.3,-(length(p-vec2(0.,.4))-.4)),\n    length(p-vec2(.15,.12))-.17);\n}\n\nvec3 foot(vec2 p, vec3 col, float off)\n{\n  float shp = 400.;\n  float h = .1;\n  p-= vec2(0.,-.2);\n  p*= r2d(sin(iTime*10.+off));\n  p+= vec2(0.,h);\n\n\n  float trunk = line(p,vec2(.02,h));\n  trunk = min(trunk, line(p-vec2(0.,-.1),vec2(.01,.05)));\n  vec2 mp = p;\n  mp.x = abs(mp.x);\n\ntrunk = min(trunk, line((mp-vec2(0.,-.1))*r2d(-1.57*.5),vec2(.01,.05)));\n\n  col = mix(col, vec3(.8,.6,.3),1.-sat(trunk*shp));\n  return col;\n}\n\nvec3 grass(vec2 uv, float t, vec3 col, vec3 rgb)\n{\n  float freq = 80.;\n  float shape  = uv.y-asin(sin(uv.x*freq+t))*.05;\n  col = mix(col, rgb,1.-sat(400.*shape));\n  return col;\n}\n\nfloat cloud(vec2 uv)\n{\n  uv.y+= -.5;\n  uv.x+=iTime*.3;\n  float rep = 0.1;\n  float id = floor((uv.x+rep*.5)/rep);\n  uv.x= mod(uv.x+rep*.5,rep)-rep*.5;\n  float acc = -uv.y;\n\n  acc = max(acc, length(uv)-abs(sin(id*.15))*.1);\n  return acc;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec2 ouv = uv;\n  vec3 col = vec3(.2,.5,.7);\n  float shp = 400.;\n  mat2 rotb = r2d(sin(iTime*15.)*.05);\n  float piou = pioupiou(uv*rotb);\n  col = grass(ouv-vec2(0.,-.3), iTime*10.,col,vec3(.1,.5,.3));\n  col = foot(uv,col,3.1415);\n  col = mix(col, vec3(.8,.7,.4), 1.-sat(shp*piou));\n  col = mix(col, vec3(.1,.1,.2), 1.-sat(shp*(abs(piou)-.01)));\n  col = mix(col, vec3(.1,.1,.2), 1.-sat(shp*(length((uv*rotb-vec2(.22,0.17)))-.02)));\n  col = foot(uv,col,0.);\n  uv*= rotb;\n  uv -= vec2(.35,.13);\n  float mouth = max(_sqr(uv, vec2(.05,.025)),-(_sqr(uv*r2d(1.57*.5)-vec2(.05),vec2(.05))));\n  col = mix(col, vec3(.8,.6,.3), 1.-sat(shp*mouth));\n  col = grass(ouv-vec2(0.1,-.4), iTime*20.,col,vec3(.1,.5,.3)*1.5);\ncol = grass(ouv-vec2(0.,-.6), iTime*30.,col,vec3(.1,.5,.3));\ncol = mix(col, vec3(1.), 1.-sat(cloud(ouv)*400.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy) / iResolution.xx;\n  vec3 col = rdr(uv*2.5);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfGDs.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[428, 428, 446, 446, 501], [503, 503, 531, 531, 577], [580, 580, 608, 608, 700], [701, 701, 725, 725, 821], [823, 823, 863, 863, 1243], [1245, 1245, 1295, 1295, 1423], [1425, 1425, 1447, 1447, 1662], [1664, 1664, 1683, 1683, 2517], [2519, 2519, 2576, 2576, 2703]], "test": "untested"}
{"id": "sllGWX", "name": "AudioGraphics", "author": "nialred", "description": "Graphics based on audio", "tags": ["audio", "graphics"], "likes": 2, "viewed": 302, "published": 3, "date": "1623076866", "time_retrieved": "2024-07-30T19:17:05.299432", "image_code": "const int MAX_MARCHING_STEPS = 500; // Max steps you are willing to search for a \"hit\" \nconst int MAX_STORED_DATA = 100;\nconst int MAX_DATA_BLOCK = MAX_STORED_DATA / 2;\nconst float MAX_DIST = 1000.0; // Max distance to search for a \"hit\"\nconst float MIN_DIST = 0.0; // Where to start the march \nconst float EPSILON = 0.001; // How close you need to be to be considered a hit\n\n// Speaker in audio data\nfloat data = 0.0;\nfloat prev_data = 0.0;\nfloat stored_data[MAX_STORED_DATA];\nfloat data_output[MAX_STORED_DATA];\n\nfloat prev_input = 0.0;\nint data_index = 0;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nSphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n\n\nfloat low_pass(float data_input)\n{\n    stored_data[data_index] = data_input;\n    float data_output = 0.0;\n    \n    for (int i=0; i<MAX_DATA_BLOCK; ++i)\n    {\n        data_output += (1.0/float(MAX_STORED_DATA))*stored_data[i];\n    }\n    \n    if (data_index == MAX_STORED_DATA)\n    {\n        data_index = 0;\n    }\n    \n    return data_output;\n}\n\n/*\nfloat low_pass(float data_input)\n{\n    float data_output = (data_input + prev_data)/2.0;\n    prev_data = data_input;\n    \n    return data_output;\n}\n*/\n\nvoid rotate_2d(float freq, inout vec2 p)\n{\n    float c = cos(freq);\n    float s = sin(freq);\n    p = vec2((p.x*c) - (p.y*s), (p.x*s) + (p.y*c));\n}\n\nfloat distort_surface(float freq, vec3 point)\n{\n    return 8.0*data*sin(point.x*freq) * sin(point.y*freq) * sin(point.z*freq);\n}\n\nvec3 ray_direction(float fieldOfView, vec2 uv) \n{ \n    float z = 1.0 / tan(radians(fieldOfView) / 2.0); // Distance to image plane\n    return normalize(vec3(uv, z));\n}\n\nfloat sphere_sdf(vec3 point)\n{\n    return length(point - sphere.center) - sphere.radius; // Return distance from sphere\n}\n\nfloat map_world(vec3 point)\n{   \n    rotate_2d(iTime/50.0, point.xy);\n    \n    float displacement = distort_surface(25.0*sin(iTime/100.0)+30.0, point);\n    float dist = sphere_sdf(point); // Distance from sphere \n    \n    return dist + displacement;\n}\n\nfloat shortest_distance_to_surface(vec3 eye_pos, vec3 march_dir, float start, float end)\n{\n    float depth = start; // Starting point for ray march (0.0)\n    float dist = 0.0;    // Initalize distance from sphere variable\n    int i = 0;           \n    \n    while (i < MAX_MARCHING_STEPS)\n    {\n        dist = map_world(eye_pos + (depth * march_dir)); // Distance to sphere (distorted)\n        \n        if (dist < EPSILON) // If at the surface, return the depth from image plane\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) // If at the max marching distance, return the max value\n        {\n            return end;\n        }\n        \n        i += 1;\n     }\n     \n     return end;\n}\n\nvec3 estimate_normal(vec3 point)\n{   \n    vec3 step = vec3(EPSILON, 0.0, 0.0);\n    \n    float gradient_x = map_world(point + step) - map_world(point - step);\n    float gradient_y = map_world(point + step.yxz) - map_world(point - step.yxz);\n    float gradient_z = map_world(point + step.yzx) - map_world(point - step.yzx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    \n    return normalize(normal);\n}\n\nfloat diffuse(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(light_pos - current_pos);\n    float intensity = max(0.0, dot(normal, light_dir));\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspect_ratio; // Account for image aspect ratio\n    \n    data  = texture(iChannel0, vec2(uv.x, 0.75)).x; \n    float wave = (data-0.5)*2.0;\n    data = 10.0*low_pass(data);\n    \n    sphere.radius = wave*sin(data)+1.0 *sphere.radius;\n    sphere.center.x = 0.15*sin(iTime);\n    sphere.center.y = 0.15*cos(iTime);\n    \n\n    // Define camera position\n    vec3 cam_pos = vec3(0.0, 0.0, -2.0);\n     \n    // Define ray as vector from camera position to pixel position\n    Ray ray = Ray(cam_pos, ray_direction(45.0, uv));\n      \n    // Define light position as a 3D vector\n    vec3 light_pos = vec3(20.0, 50.0, -50.0);\n    \n    // Find distance to surface\n    float dist = shortest_distance_to_surface(ray.origin, ray.direction, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) // If sphere doesn't exist at this pixel draw bg\n    { \n        // Eventually want to have the background be a cubic room \n        fragColor = vec4(0.2, 0.2, 0.2, 0.0);\n    }\n    \n    else // If sphere does exist at this pixel, draw color accordingly using basic lighting\n    {\n        vec3 point = ray.origin + dist*ray.direction;\n        vec3 normal = estimate_normal(point);\n        float intensity = diffuse(point, light_pos, normal);\n        normal = vec3(0.85, 0.95, 0.95) * (intensity);\n        normal = normal+0.15;\n        if( ( (uv.y<=0.0) && (abs(uv.y-wave)<=0.05) ) || ( (uv.y>=0.0) && (abs(uv.y-wave)<=0.05) ) )\n        {\n            normal.x = 0.85;\n            normal.y = 0.95;\n            normal.z = 0.95;\n        }\n        fragColor = vec4(normal, 1.0);\n        \n    }\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[721, 721, 755, 755, 1063], [1220, 1220, 1262, 1262, 1366], [1368, 1368, 1415, 1415, 1496], [1498, 1498, 1547, 1547, 1665], [1667, 1667, 1697, 1697, 1788], [1790, 1790, 1819, 1819, 2041], [2043, 2043, 2133, 2133, 2791], [2793, 2793, 2827, 2827, 3216], [3218, 3218, 3280, 3280, 3417], [3419, 3419, 3476, 3530, 5224]], "test": "untested"}
{"id": "flf3Dl", "name": "L1 Norm Rotation", "author": "paniq", "description": "Demonstration of rotation under L1 norm and primitives for polar transformations in L1 and L2", "tags": ["rotation", "norm", "l1", "l2"], "likes": 6, "viewed": 344, "published": 3, "date": "1623073385", "time_retrieved": "2024-07-30T19:17:06.124227", "image_code": "\n// uncomment to transform L2 to L1 space, rotate in L1 and \n// transform back from L1 to L2, to see how polar transformations\n// in L1 are equivalent to their counterpart in L2.\n//#define DEMO_POLAR_EQUIVALENCY\n\n// uncomment to demonstrate rotation in L2\n// uncommenting DEMO_POLAR_EQUIVALENCY will work in the inverse way\n//#define DEMO_L2_NORM_ROTATION\n\nconst float L1tau = 8.0;\nconst float L1pi = 4.0;\n\n// sign without zero\nfloat nzsign(float x) {\n    return (x < 0.0)?-1.0:1.0;\n}\n\nfloat L1cos(float x) {\n    return abs(mod(x, 8.0) - 4.0) / 2.0 - 1.0;\n}\n\nfloat L1sin(float x) {\n    return L1cos(x - 2.0);\n}\n\nfloat L1radians(float x) {\n    return x / 45.0;\n}\n\nfloat L1degrees(float x) {\n    return x * 45.0;\n}\n         \nvec2 L1polar(vec2 p) {\n    float r = abs(p.x) + abs(p.y);\n    return (r == 0.0)?vec2(0.0):vec2(2.0 * nzsign(p.y) * (1.0 - p.x / r), r);\n}\n\nvec2 L1cartesian(vec2 p) {\n    float a = p.x;\n    float r = p.y;\n    a = mod(a + 4.0, 8.0) - 4.0;\n    float cos_x = 1.0 - abs(a) / 2.0;\n    return r * vec2(cos_x, sign(a)*(1.0 - abs(cos_x)));\n}\n\nvec2 L1rotate (vec2 p, float q) {\n    p = L1polar(p);\n    return L1cartesian(vec2(p.x + q, p.y));\n}\n\nconst float L2tau = 6.28318530718;\nconst float L2pi = 3.14159265359;\n\nvec2 L2polar(vec2 p) {\n    float r = length(p);\n    return vec2(atan(p.y, p.x), r);\n}\n\nvec2 L2cartesian(vec2 p) {\n    float a = p.x;\n    float r = p.y;\n    return r * vec2(cos(a), sin(a));\n}\n\nvec2 L2rotate (vec2 p, float q) {\n#if 0 // logical\n    p = L2polar(p);\n    return L2cartesian(vec2(p.x + q, p.y));\n#else // fast\n    float c = cos(q);\n    float s = sin(q);\n    return vec2(c*p.x - s*p.y, c*p.y + s*p.x);\n#endif\n}\n\n// convert polar coordinates from L1 to L2 \nvec2 L1toL2(vec2 p) {\n    return vec2(p.x * L2tau / L1tau, p.y);\n}\n\n// convert polar coordinates from L2 to L1\nvec2 L2toL1(vec2 p) {\n    return vec2(p.x * L1tau / L2tau, p.y);\n}\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\t\n\tp.x *= iResolution.x/iResolution.y;\n\n#ifndef DEMO_L2_NORM_ROTATION\n\n#ifdef DEMO_POLAR_EQUIVALENCY\n    p = L1cartesian(L2toL1(L2polar(p)));\n#endif\n\n    p = L1rotate(p, -iTime*0.5);\n\n#ifdef DEMO_POLAR_EQUIVALENCY\n    p = L2cartesian(L1toL2(L1polar(p)));\n#endif\n\n#else\n\n#ifdef DEMO_POLAR_EQUIVALENCY\n    p = L2cartesian(L1toL2(L1polar(p)));\n#endif\n\n    // the two norms have different arc lengths, so we need\n    // to adjust speed for equivalency\n    p = L2rotate(p, -iTime*0.5 * L2tau / L1tau);\n\n#ifdef DEMO_POLAR_EQUIVALENCY\n    p = L1cartesian(L2toL1(L2polar(p)));\n#endif\n\n#endif\n\n    vec2 o = L1polar(p);\n    vec3 color = texture(iChannel0, p).rrr * (hue(o.r/L1tau) * 0.5 + 0.5) * (0.7 + 0.3*clamp(L1cos(o.g * L1tau * 10.0)*10.0*0.5+0.5,0.0,1.0));\n\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flf3Dl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 428, 451, 451, 484], [486, 486, 508, 508, 557], [559, 559, 581, 581, 610], [612, 612, 638, 638, 661], [663, 663, 689, 689, 712], [723, 723, 745, 745, 860], [862, 862, 888, 888, 1055], [1057, 1057, 1090, 1090, 1156], [1228, 1228, 1250, 1250, 1313], [1315, 1315, 1341, 1341, 1418], [1420, 1420, 1453, 1453, 1648], [1650, 1694, 1715, 1715, 1760], [1762, 1805, 1826, 1826, 1871], [1873, 1873, 1894, 1894, 2003], [2005, 2005, 2062, 2062, 2899]], "test": "untested"}
{"id": "stlGDf", "name": "Chronic", "author": "wyatt", "description": "A topographic map made of the shortest time paths through a star field. A texture is used to produced a conservative force field. Create a 'time zero' location, and the automata propagate the shortest time path from that location through the force field. ", "tags": ["optimization", "functional", "minimization"], "likes": 23, "viewed": 519, "published": 3, "date": "1623043576", "time_retrieved": "2024-07-30T19:17:07.046760", "image_code": "// Fork of \"Brachistochrone\" by wyatt. https://shadertoy.com/view/7tfGD2\n// 2021-06-07 04:54:05\n\nMain {\n    float \n        n = A(U+vec2(0,1)).z,\n        e = A(U+vec2(1,0)).z,\n        s = A(U-vec2(0,1)).z,\n        w = A(U-vec2(1,0)).z;\n    vec3 g = .2+normalize(vec3(e-w,n-s,4));\n    Q = g.x*vec4(1,.5,0,1)+g.y*vec4(0,.5,1,1);\n   \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texture(iChannel1,(U/R))\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define START  (.5*R)", "buffer_a_code": "Main {\n    float v = .001*length(B(U).xyz);\n    v *= v;\n    Q = A(U);\n    for (int x =-2;x<=2;x++)\n    for (int y =-2;y<=2;y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        \n        float uv = .001*length(B(U+u).xyz);\n        uv *= uv;\n        float dx_dt = .5*uv+.5*v;\n        vec4 a = A(U+u);\n        float dx = length(u);\n        float dt = dx/dx_dt;\n        if (abs(dx_dt)<1e-9) dt = 1e9;\n        if (a.z+dt<Q.z)\n            Q.z = a.z+dt;\n        \n        if (length(a.xy-U)<length(Q.xy-U))\n            Q.xy = a.xy;\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<2.)\n        Q.z = 0.;\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) {\n        Q = vec4(0);\n    }\n    if (iFrame < 1) {\n        Q = vec4(0);\n        Q.z = 1e9;\n    }\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sts3Wf", "name": "Juliaaaaaa", "author": "Shellderr", "description": "low-q julia set. better rendering needed.", "tags": ["julia"], "likes": 2, "viewed": 240, "published": 3, "date": "1623041793", "time_retrieved": "2024-07-30T19:17:07.845625", "image_code": "#define thresh 20.\n#define stop 200\n#define res iResolution\n\n// from yiwenl\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 cmul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 z = .8*(2.*fragCoord-res.xy)/res.y;  \n    vec2 c = iMouse.xy==vec2(0)? vec2(-.77,.45)/*vec2(cos(iTime*.4)-.3,-.66)*/: (2.*iMouse.xy-res.xy)/res.y;\n    int i = 0;\n    for(i; i < stop; i++){   \n        z = cmul(z,z)+c;   \n        if(length(z) > thresh)\n            break;      \n    }\n    vec3 col = hsv2rgb(vec3(log(.9+float(i)/380.)*2., 1., log(.7+float(i)/15.)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3Wf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 76, 97, 97, 266], [268, 268, 294, 294, 351], [353, 353, 409, 409, 815]], "test": "untested"}
{"id": "stsGWf", "name": "Blobbies Ray Intersection", "author": "oneshade", "description": "Blobbies! (with automated calculations). Now using [url=https://www.shadertoy.com/view/ltVfDK]this[/url] solver which does not have artifacts.", "tags": ["3d", "raytracing", "raycasting", "metaballs", "intersection", "blobbies"], "likes": 9, "viewed": 190, "published": 3, "date": "1623035378", "time_retrieved": "2024-07-30T19:17:08.722281", "image_code": "struct Linear { float a; float b; };\nstruct Quadratic { float a; float b; float c; };\nstruct Quartic { float a; float b; float c; float d; float e; };\n\n// Polynomial arithmetic makes things much easier and intuitive\nQuadratic add(in Quadratic a, in float b) { a.c += b; return a; }\nQuartic add(in Quartic a, in float b) { a.e += b; return a; }\nQuadratic add(in Quadratic a, in Quadratic b) { return Quadratic(a.a + b.a, a.b + b.b, a.c + b.c); }\nQuartic mul(in Quadratic a, in Quadratic b) { return Quartic(a.a * b.a, a.a * b.b + a.b * b.a, a.a * b.c + a.b * b.b + a.c * b.a, a.b * b.c + a.c * b.b, a.c * b.c); }\nQuadratic square(in Linear a) { return Quadratic(a.a * a.a, 2.0 * a.a * a.b, a.b * a.b); }\n\n// Automatic differentiation utilities (in three variables)\nvec4 add(in vec4 f, in float g) { f.x += g; return f; }\nvec4 mul(in vec4 f, in vec4 g) { return vec4(f.x * g.x, dot(f.xy, g.yx), dot(f.xz, g.zx), dot(f.xw, g.wx)); }\nvec4 square(in vec4 f) { return vec4(f.x * f.x, 2.0 * f.x * f.yzw); }\n\n// Smallest positive root of a quartic\nfloat quartic2(in float a, in float b, in float c, in float d, in float e) {\n    vec4 roots;\n    float t = -1.0;\n    for (int n=0; n < quartic(b / a, c / a, d / a, e / a, roots); n++) {\n        if (roots[n] > 0.0) {\n            t = t < 0.0 ? roots[n] : min(t, roots[n]);\n        }\n    }\n\n    return t;\n}\n\nfloat iBlobbies(in vec3 ro, in vec3 rd, in float size1, in float size2, in vec3 pos1, in vec3 pos2, in float blobbiness) {\n    vec3 ro1 = ro - pos1, ro2 = ro - pos2;\n    Linear x1 = Linear(rd.x, ro1.x), y1 = Linear(rd.y, ro1.y), z1 = Linear(rd.z, ro1.z);\n    Linear x2 = Linear(rd.x, ro2.x), y2 = Linear(rd.y, ro2.y), z2 = Linear(rd.z, ro2.z);\n\n    Quadratic blob1 = add(add(square(x1), add(square(y1), square(z1))), -size1);\n    Quadratic blob2 = add(add(square(x2), add(square(y2), square(z2))), -size2);\n\n    Quartic blobbies = add(mul(blob1, blob2), -blobbiness);\n    return quartic2(blobbies.a, blobbies.b, blobbies.c, blobbies.d, blobbies.e);\n}\n\nvec3 nBlobbies(in vec3 p, in float size1, in float size2, in vec3 pos1, in vec3 pos2, in float blobbiness) {\n    vec3 p1 = p - pos1, p2 = p - pos2;\n    vec4 x1 = vec4(p1.x, 1.0, 0.0, 0.0), y1 = vec4(p1.y, 0.0, 1.0, 0.0), z1 = vec4(p1.z, 0.0, 0.0, 1.0);\n    vec4 x2 = vec4(p2.x, 1.0, 0.0, 0.0), y2 = vec4(p2.y, 0.0, 1.0, 0.0), z2 = vec4(p2.z, 0.0, 0.0, 1.0);\n\n    vec4 blob1 = add(square(x1) + square(y1) + square(z1), -size1);\n    vec4 blob2 = add(square(x2) + square(y2) + square(z2), -size2);\n\n    vec4 blobbies = add(mul(blob1, blob2), -blobbiness);\n    return normalize(blobbies.yzw);\n}\n\nvec4 render(in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = 1406.42;\n\n    vec2 mouse = iMouse.z > 0.0 ? (iMouse.xy - center) / iResolution.y * 3.14 : vec2(0.0, -0.5);\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    vec4 fragColor = texture(iChannel0, rd);\n\n    vec3 pos = vec3(cos(iTime) * 2.0, sin(iTime), cos(iTime) * sin(iTime)) * 3.0;\n    float t = iBlobbies(ro, rd, 2.0, 5.0, pos, vec3(0.0), 5.0);\n    if (t > 0.0) {\n        vec3 hit = ro + rd * t;\n        vec3 n = nBlobbies(hit, 2.0, 5.0, pos, vec3(0.0), 5.0);\n        vec4 envMap = texture(iChannel0, reflect(rd, n));\n        fragColor = envMap * abs(dot(rd, n));\n    }\n\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = render(fragCoord);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint quartic(in float b, in float c, in float d, in float e, inout vec4 roots) {\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 216, 259, 259, 281], [282, 282, 321, 321, 343], [344, 344, 391, 391, 444], [445, 445, 490, 490, 611], [612, 612, 643, 643, 702], [704, 764, 797, 797, 819], [820, 820, 852, 852, 929], [930, 930, 954, 954, 999], [1001, 1040, 1116, 1116, 1343], [1345, 1345, 1467, 1467, 1995], [1997, 1997, 2105, 2105, 2587], [2589, 2589, 2621, 2621, 3625], [3627, 3627, 3682, 3682, 3719]], "test": "untested"}
{"id": "sllGDX", "name": "3d white blobs", "author": "BEN1JEN", "description": "A recreation of a shader featuring volumetric procedural white blobs that I've seen around vrchat.\nThis one works by ray marching and using a perlin noise function I've made to determine whether there should be a white blob or not.", "tags": ["procedural", "3d", "volumetric", "simplex", "blob", "white"], "likes": 2, "viewed": 292, "published": 3, "date": "1623032483", "time_retrieved": "2024-07-30T19:17:09.566025", "image_code": "#define PI 3.1415926535\n\nfloat rand(vec4 pos) {\n\tpos = pos + vec4(2.35219, 1.51092, 3.01246, 4.8263975209);\n    vec2 pos2d = pos.xy*1.0231 + pos.yz*1.7423 + pos.zw*0.9854 + pos.wx*0.4798;\n\tfloat rand = fract(sin(dot(pos2d, vec2(12.9898, 78.233))) * 43758.5453123);\n\trand = rand - floor(rand);\n\treturn rand;\n}\n\nfloat noise(vec4 pos, int octaves) {\n\tfloat total = 0.0;\n\tfloat multiplier = 0.0;\n\tfor (int o = 1; o <= octaves; o++) {\n\t\tvec4 lin = pos/float(o);\n        lin -= floor(lin);\n\n        float llll = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o)),     floor(pos.w/float(o)) ));\n\t\tfloat hlll = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o)),     floor(pos.w/float(o)) ));\n\t\tfloat lhll = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o)),     floor(pos.w/float(o)) ));\n\t\tfloat hhll = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o)),     floor(pos.w/float(o)) ));\n\t\tfloat llhl = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0, floor(pos.w/float(o)) ));\n\t\tfloat hlhl = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0, floor(pos.w/float(o)) ));\n\t\tfloat lhhl = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0, floor(pos.w/float(o)) ));\n\t\tfloat hhhl = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0, floor(pos.w/float(o)) ));\n\n        float lllh = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o)),     floor(pos.w/float(o))+1.0 ));\n\t\tfloat hllh = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o)),     floor(pos.w/float(o))+1.0 ));\n\t\tfloat lhlh = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o)),     floor(pos.w/float(o))+1.0 ));\n\t\tfloat hhlh = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o)),     floor(pos.w/float(o))+1.0 ));\n\t\tfloat llhh = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0, floor(pos.w/float(o))+1.0 ));\n\t\tfloat hlhh = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o)),     floor(pos.z/float(o))+1.0, floor(pos.w/float(o))+1.0 ));\n\t\tfloat lhhh = rand(vec4( floor(pos.x/float(o)),     floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0, floor(pos.w/float(o))+1.0 ));\n\t\tfloat hhhh = rand(vec4( floor(pos.x/float(o))+1.0, floor(pos.y/float(o))+1.0, floor(pos.z/float(o))+1.0, floor(pos.w/float(o))+1.0 ));\n\n\t\tfloat llzl = llll * (1.0 - lin.z) + llhl * lin.z;\n\t\tfloat hlzl = hlll * (1.0 - lin.z) + hlhl * lin.z;\n        float lhzl = lhll * (1.0 - lin.z) + lhhl * lin.z;\n\t\tfloat hhzl = hhll * (1.0 - lin.z) + hhhl * lin.z;\n\t\tfloat llzh = lllh * (1.0 - lin.z) + llhh * lin.z;\n\t\tfloat hlzh = hllh * (1.0 - lin.z) + hlhh * lin.z;\n\t\tfloat lhzh = lhlh * (1.0 - lin.z) + lhhh * lin.z;\n\t\tfloat hhzh = hhlh * (1.0 - lin.z) + hhhh * lin.z;\n\n        float lyzl = llzl * (1.0 - lin.y) + lhzl * lin.y;\n\t\tfloat hyzl = hlzl * (1.0 - lin.y) + hhzl * lin.y;\n\t\tfloat lyzh = llzh * (1.0 - lin.y) + lhzh * lin.y;\n\t\tfloat hyzh = hlzh * (1.0 - lin.y) + hhzh * lin.y;\n\n        float xyzl = lyzl * (1.0 - lin.x) + hyzl * lin.x;\n        float xyzh = lyzh * (1.0 - lin.x) + hyzh * lin.x;\n\n        float val = xyzl * (1.0 - lin.w) + xyzh * lin.w;\n\n        multiplier = multiplier + float(o);\n\t\ttotal = total + val * float(o);\n\t}\n\treturn total/multiplier;\n}\n\nbool getNoise(vec4 pos, float dist) {\n    return\n        noise(pos*10.0 + vec4(1.5, 0.5, -3.2, 6.5), 12) > 0.56 ||\n        noise(pos*8.0 + vec4(0.5, 6.5, -3.2, 1.5), 12) > 0.56;\n}\n\nvec3 hsv(float hue, float sat, float val) {\n    hue = mod(hue, 1.0);\n    hue *= 6.0;\n    if (hue < 1.0) {\n        return vec3(\n            1.0,\n            hue + (1.0-hue)*sat,\n            sat\n        )*val;\n    } else if (hue < 2.0) {\n        return vec3(\n            2.0-hue + (hue-1.0)*sat,\n            1.0,\n            sat\n        )*val;\n    } else if (hue < 3.0) {\n        return vec3(\n            sat,\n            1.0,\n            hue-2.0 + (3.0-hue)*sat\n        )*val;\n    } else if (hue < 4.0) {\n        return vec3(\n            sat,\n            4.0-hue + (hue-3.0)*sat,\n            1.0\n        )*val;\n    } else if (hue < 5.0) {\n        return vec3(\n            hue-4.0 + (5.0-hue)*sat,\n            sat,\n            1.0\n        )*val;\n    } else {\n        return vec3(\n            1.0,\n            sat,\n            6.0-hue + (hue-5.0)*sat\n        )*val;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float dist = 0.0;\n    vec3 dir = vec3(uv*2.0-1.0, 1.0);\n    vec2 r = iMouse.xy/vec2(640.0/PI/2.0, 360.0/PI) + vec2(0.0, PI/2.0);\n    vec2 tmp = dir.yz;\n    dir.y = tmp.x*cos(r.y) + tmp.y*sin(r.y);\n    dir.z = tmp.y*cos(r.y) - tmp.x*sin(r.y);\n    tmp = dir.xz;\n    dir.x = tmp.x*cos(r.x) - tmp.y*sin(r.x);\n    dir.z = tmp.y*cos(r.x) + tmp.x*sin(r.x);\n    float len = length(dir);\n    dir /= len;\n    vec3 pos = vec3(1.0 + sin(iTime/10.0), 10.0 - iTime/10.0, -2.0 + cos(iTime/10.0));\n    bool seen = false;\n    for (int i = 0; i < 10; i++) {\n        dist += float(i)/10.0;\n        if (getNoise(vec4(pos + dist*dir, iTime/10.0), dist)) {\n            seen = true;\n            break;\n        }\n    }\n    vec3 hit = vec3(0.0, 0.0, 0.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if (seen) {\n        for (; dist > 0.0; dist -= 0.1) {\n            if (!getNoise(vec4(pos + dist*dir, iTime/10.0), dist)) {\n                hit = pos + dist*dir;\n                break;\n            }\n        }\n        dir *= len;\n        if (seen) {\n            float val = 1.0-pow(dist/5.0, 3.0);\n            col = hsv(hit.y/10.0, 0.8+val*0.1, val);\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 47, 47, 308], [310, 310, 346, 346, 3580], [3582, 3582, 3619, 3619, 3761], [3763, 3763, 3806, 3806, 4633], [4635, 4635, 4692, 4742, 5982]], "test": "untested"}
{"id": "ftsGDf", "name": "1er Truchet-2d", "author": "jorge2017a1", "description": "1er Truchet-2d", "tags": ["2d", "truchet", "neon"], "likes": 4, "viewed": 358, "published": 3, "date": "1623009913", "time_retrieved": "2024-07-30T19:17:10.402788", "image_code": "//Modificado por jorge2017a1\n//referencia\n//https://www.youtube.com/watch?v=2R7h76GoIJM ....Art Code\n\nfloat Hash21(vec2 p)\n{\n    p=fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.26);\n    return fract(p.x*p.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*= 7.0;\n    uv+=iTime;\n    vec3 col=vec3(0.0);\n    vec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n\n    float n=Hash21(id); //rango 0.0 a 1.0\n\n    float width=0.1;\n\n    if(n<0.5) gv.x*=-1.0;\n\n    //float d=abs(gv.x+gv.y); //diagonal...linea ....sustitucion por lo siguiente\n\n//----------\n/// Tip Shane....9/jun/2021\nfloat d=abs(gv.x + gv.y)*.7071; // Diagonal line.\ngv = abs(gv) - .5; // Corners.\nd = min(d, abs(gv.x + gv.y)*.7071); \n//----------\n    \n    float  mask=smoothstep(0.01,-0.01, d-width);\n\n    float r = pow(1.0-sqrt( d),1.5 );\n    float g = pow(1.0-sqrt( d),1.5 );\n    float b = 1.0*(r+g);\n    \n    col+=vec3(r,g,b)*mask;\n    \n    //if(gv.x>0.48 || gv.y>0.48) col=vec3(1.0,0.0,.0);\n    fragColor=vec4(col,1.0);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 124, 124, 213], [216, 216, 273, 273, 1062]], "test": "untested"}
{"id": "flsGWf", "name": "OpenSetTest8", "author": "OpenSet", "description": "Click and drag on the window to change effect", "tags": ["webcam"], "likes": 26, "viewed": 1412, "published": 3, "date": "1623006612", "time_retrieved": "2024-07-30T19:17:11.261491", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 c = texture(iChannel0, uv);\n    c.rgb = sin(c.rgb*(30.0+iMouse.y*80.0/iResolution.y)+iTime+vec3(50., 0.2,.5*texture(iChannel1, vec2(1.5*length(uv-.4),10.)).r))*.45+.5;\n    fragColor = c;\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float z = (texture(iChannel2, vec2(length(uv-.5),1.)).r)*(20.0/iResolution.x*0.2+.001);\n    float zoom = (1.-z);sin(iTime*20.)*.51+.9;\n    uv-=.5;\n    uv*=zoom;\n    uv+=.5;\n    vec4 o = texture(iChannel0, uv);\n    vec4 c = texture(iChannel3,uv);\n    c = mix(c,o,.95);\n    fragColor = c;\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 294]], "test": "untested"}
{"id": "7lXGWf", "name": "Domino Towers", "author": "dr2", "description": "Dynamics of domino towers (mouseable, new runs start automatically  or by clicking upper-right)", "tags": ["collision", "dynamics", "physics", "rigidbody"], "likes": 9, "viewed": 382, "published": 3, "date": "1622981590", "time_retrieved": "2024-07-30T19:17:12.605898", "image_code": "// \"Domino Towers\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on \"Falling Towers\", with different visuals and more GPU parallelism\n// (as in \"Dominoes Toppling\")\n\n#define AA    0\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBox2Df (vec2 p, vec2 b);\nmat3 QtToRMat (vec4 q);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec3 blkGap, bSize, fcBlk, ltDir;\nvec2 qBlk;\nfloat tCur, dstFar, nRun;\nint idObj;\nconst float pi = 3.1415927;\n\n#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst int nObj = 112;\n#else\nconst int nObj = 56;\n#endif\n\nconst ivec3 nSphObjD = ivec3 (6, 3, 2);\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fId, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    u = (v + dn) * rd;\n    fId = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qBlk = vec2 (dot (u.zxy, fId), dot (u.yzx, fId));\n  }\n  return vec4 (dMin, fId);\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) dMin = dn;\n  return dMin;\n}\n\nfloat ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  vec2 qBlkN;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = BlkHit (rom, rdm, bSize);\n    if (cdn4.x < dMin) {\n      dMin = cdn4.x;\n      fcBlk = cdn4.yzw;\n      qBlkN = qBlk;\n      idObj = n;\n    }\n  }\n  qBlk = qBlkN;\n  return dMin;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    dMin = min (dMin, BlkHitSh (rom, rdm, bSize));\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\nfloat Spots (vec2 q, int nSpot)\n{\n  float bSz, w;\n  bSz = 0.6 * bSize.x;\n  if (nSpot == 2 || nSpot == 3) q = Rot2D (q, 0.25 * pi);\n  else if (nSpot == 6) q = q.yx;\n  w = 1.;\n  if (nSpot == 1) w = length (q);\n  else if (nSpot == 2) w = length (abs (q) - vec2 (0.4 * bSz, 0.));\n  else if (nSpot == 3) w = length (vec2 (mod (q.x + 0.35 * bSz, 0.7 * bSz) - 0.35 * bSz, q.y));\n  else if (nSpot == 4) w = length (abs (q) - 0.4 * bSz);\n  else if (nSpot == 5) w = min (length (abs (q) - 0.4 * bSz), length (q));\n  else if (nSpot == 6) w = length (vec2 (mod (q.x + 0.26 * bSz, 0.52 * bSz) - 0.26 * bSz,\n     abs (q.y) - 0.4 * bSz));\n  return smoothstep (-0.02, 0., w - 0.2 * bSz);\n}\n\nvec3 ObjCol (vec3 rd, float sh)\n{\n  vec3 vn, col, q;\n  float fId, sp, ep, em;\n  int ns1, ns2, n28;\n  col = vec3 (0.95, 0.95, 1.); \n  fId = float (idObj);\n  ep = smoothstep (0., 0.2, PrBox2Df (qBlk, ((abs (fcBlk.x) == 1.) ? bSize.zy :\n     ((abs (fcBlk.y) == 1.) ? bSize.xz : bSize.yx)) - 0.2));\n  col *= 1. - 0.3 * ep;\n  sp = 1.;\n  em = 1.;\n  if (mod (floor (fId / 8.), 2.) != 0. && fcBlk.z == 2. * mod (fId, 2.) - 1. ||\n     mod (floor (fId / 8.), 2.) == 0. && fcBlk.z == 2. * mod (floor (fId / 2.), 2.) - 1.) {\n    n28 = int (mod (fId, 28.));\n    ns1 = int (0.5 * (-1. + sqrt (float (1 + 8 * n28))));\n    ns2 = n28 - ns1 * (ns1 + 1) / 2;\n    sp = Spots (vec2 (qBlk.x, qBlk.y - 0.5 * bSize.x * sign (qBlk.y)),\n       ((qBlk.y > 0.) ? ns1 : ns2));\n    col = mix (vec3 (0., 0., 1.), col, sp);\n    em = smoothstep (0., 0.02, 0.1 - abs (qBlk.y));\n    col *= 1. - 0.3 * em;\n  }\n  vn = fcBlk;\n  if (sp < 1. || max (ep, em) > 0.) {\n    q = vec3 (qBlk, 0.);\n    if (abs (fcBlk.x) == 1.) q = q.zxy;\n    else if (abs (fcBlk.y) == 1.) q = q.xzy;\n    vn = VaryNf (32. * q, vn, 0.5);\n  }\n  vn = QtToRMat (GetQ (idObj)) * vn;\n  col = col * (0.2 +  0.8 * sh * max (dot (vn, ltDir), 0.)) +\n     0.2 * sh * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 vn, float sh)\n{\n  vec3 col;\n  col = mix (vec3 (0.7, 0.5, 0.5), vec3 (0.8, 0.85, 0.8),\n     smoothstep (0., 0.07, abs (abs (Fbm2 (0.1 * ro.xz) - 0.4) - 0.2)));\n  col *= 0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.);\n  col *= 0.2 + 0.8 * smoothstep (0.85, 0.95, dot (normalize (200. * ltDir - ro), ltDir));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float dstObj, sh;\n  bool isBg;\n  bSize = 0.5 * blkGap * (vec3 (nSphObjD) - 1.) + 0.4;\n  dstObj = ObjHit (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    isBg = false;\n  } else {\n    ro += ((0.5 - ro.y) / rd.y) * rd;\n    isBg = true;\n  }\n  sh = 0.6 + 0.4 * ObjHitSh (ro + 0.01 * ltDir, ltDir, 60.);\n  if (! isBg) col = ObjCol (rd, sh);\n  else col = BgCol (ro, vec3 (0., 1., 0.), sh);\n  if (isBg && rd.y < 0.) {\n    rd = reflect (rd, vec3 (0., 1., 0.));\n    ro += 0.01 * rd;\n    dstObj = ObjHit (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      col = mix (col, ObjCol (rd, 1.), 0.3);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac, sr, h;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  blkGap = stDat.yzw;\n  stDat = Loadv4 (1);\n  mPtr.xyz = stDat.xyz;\n  nRun = stDat.w;\n  dstFar = 300.;\n  az = -0.2 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  } else {\n    az -= 0.005 * pi * tCur;\n  }\n  el = clamp (el, -0.45 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 0., -120.);\n  h = 0.;\n  for (int n = VAR_ZERO; n < nObj; n ++) h += GetR (n).y;\n  ro.y = h / float (nObj);\n  ro = vuMat * ro;\n  zmFac = 4.;\n  ltDir = vuMat * normalize (vec3 (0.3, 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (1., 0.7, 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 256.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Domino Towers\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst int nObj = 112;\n#else\nconst int nObj = 56;\n#endif\n\nconst ivec3 nSphObjD = ivec3 (6, 3, 2);\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float fmId, rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 1.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  if (nStep > 100.) {\n    fmId = float (mId);\n    if (! (abs (fmId - 3.) == 1. || abs (fmId - 4.) == 1.) || nStep > 130.) vm += dt * am;\n    rm += dt * vm;\n    wm += dt * wam;\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec3 r, fn;\n  float fmId, rowGap, layGap, blkSpc;\n  int nb;\n  const int npRow = 2;\n  rowGap = 20.;\n  layGap = 2.74;\n  blkSpc = 1.4;\n  nb = mId / (2 * npRow * npRow);\n  fn.y = float (nb);\n  nb *= 2 * npRow * npRow;\n  r.y = (fn.y + 0.5) * layGap + 0.5;\n  for (int nz = 0; nz < 2 * npRow; nz ++) {\n    if (mod (fn.y, 2.) == 1. && nz == npRow) break;\n    fn.z = float (nz);\n    r.z = (mod (fn.y, 2.) == 1.) ? (fn.z + 1.) * rowGap : (floor (0.5 * fn.z) + 1.) * rowGap -\n       blkSpc * (2. - ((mod (fn.z, 2.) == 0.) ? 1. : 3.));\n    for (int nx = 0; nx < 2 * npRow; nx ++) {\n      if (mod (fn.y, 2.) == 0. && nx == npRow) break;\n      fn.x = float (nx);\n      r.x = (mod (fn.y, 2.) == 1.) ? (floor (0.5 * fn.x) + 1.) * rowGap -\n         blkSpc * (2.- ((mod (fn.x, 2.) == 0.) ? 1. : 3.)) : (fn.x + 1.) * rowGap;\n      if (nb == mId) {\n        rm = r;\n        qm = RotToQt (vec3 (0., 1., 0.), 0.5 * pi * mod (fn.y, 2.));\n      }\n      ++ nb;\n    }\n  }\n  rm.xz -= 0.5 * (float (npRow) + 1.) * rowGap;\n  vm = vec3 (0.);\n  wm = vec3 (0.);\n  fmId = float (mId);\n  if (abs (fmId - 3.) == 1. || abs (fmId - 4.) == 1.) {\n    vm.xz = 5. * (vec2 (3., -1.) * normalize (rm.xz) +\n       0.4 * (1. - 2. * vec2 (Hashff (fmId * todCur), Hashff (3.1 * fmId * todCur))));\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 20000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (0.9, 0.9, 0.7);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Domino Towers\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst int nObj = 112;\n#else\nconst int nObj = 56;\n#endif\n\nconst ivec3 nSphObjD = ivec3 (6, 3, 2);\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float fmId, rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 1.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  if (nStep > 100.) {\n    fmId = float (mId);\n    if (! (abs (fmId - 3.) == 1. || abs (fmId - 4.) == 1.) || nStep > 130.) vm += dt * am;\n    rm += dt * vm;\n    wm += dt * wam;\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec3 r, fn;\n  float fmId, rowGap, layGap, blkSpc;\n  int nb;\n  const int npRow = 2;\n  rowGap = 20.;\n  layGap = 2.74;\n  blkSpc = 1.4;\n  nb = mId / (2 * npRow * npRow);\n  fn.y = float (nb);\n  nb *= 2 * npRow * npRow;\n  r.y = (fn.y + 0.5) * layGap + 0.5;\n  for (int nz = 0; nz < 2 * npRow; nz ++) {\n    if (mod (fn.y, 2.) == 1. && nz == npRow) break;\n    fn.z = float (nz);\n    r.z = (mod (fn.y, 2.) == 1.) ? (fn.z + 1.) * rowGap : (floor (0.5 * fn.z) + 1.) * rowGap -\n       blkSpc * (2. - ((mod (fn.z, 2.) == 0.) ? 1. : 3.));\n    for (int nx = 0; nx < 2 * npRow; nx ++) {\n      if (mod (fn.y, 2.) == 0. && nx == npRow) break;\n      fn.x = float (nx);\n      r.x = (mod (fn.y, 2.) == 1.) ? (floor (0.5 * fn.x) + 1.) * rowGap -\n         blkSpc * (2.- ((mod (fn.x, 2.) == 0.) ? 1. : 3.)) : (fn.x + 1.) * rowGap;\n      if (nb == mId) {\n        rm = r;\n        qm = RotToQt (vec3 (0., 1., 0.), 0.5 * pi * mod (fn.y, 2.));\n      }\n      ++ nb;\n    }\n  }\n  rm.xz -= 0.5 * (float (npRow) + 1.) * rowGap;\n  vm = vec3 (0.);\n  wm = vec3 (0.);\n  fmId = float (mId);\n  if (abs (fmId - 3.) == 1. || abs (fmId - 4.) == 1.) {\n    vm.xz = 5. * (vec2 (3., -1.) * normalize (rm.xz) +\n       0.4 * (1. - 2. * vec2 (Hashff (fmId * todCur), Hashff (3.1 * fmId * todCur))));\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 20000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (0.9, 0.9, 0.7);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Domino Towers\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst int nObj = 112;\n#else\nconst int nObj = 56;\n#endif\n\nconst ivec3 nSphObjD = ivec3 (6, 3, 2);\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float fmId, rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 1.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  if (nStep > 100.) {\n    fmId = float (mId);\n    if (! (abs (fmId - 3.) == 1. || abs (fmId - 4.) == 1.) || nStep > 130.) vm += dt * am;\n    rm += dt * vm;\n    wm += dt * wam;\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec3 r, fn;\n  float fmId, rowGap, layGap, blkSpc;\n  int nb;\n  const int npRow = 2;\n  rowGap = 20.;\n  layGap = 2.74;\n  blkSpc = 1.4;\n  nb = mId / (2 * npRow * npRow);\n  fn.y = float (nb);\n  nb *= 2 * npRow * npRow;\n  r.y = (fn.y + 0.5) * layGap + 0.5;\n  for (int nz = 0; nz < 2 * npRow; nz ++) {\n    if (mod (fn.y, 2.) == 1. && nz == npRow) break;\n    fn.z = float (nz);\n    r.z = (mod (fn.y, 2.) == 1.) ? (fn.z + 1.) * rowGap : (floor (0.5 * fn.z) + 1.) * rowGap -\n       blkSpc * (2. - ((mod (fn.z, 2.) == 0.) ? 1. : 3.));\n    for (int nx = 0; nx < 2 * npRow; nx ++) {\n      if (mod (fn.y, 2.) == 0. && nx == npRow) break;\n      fn.x = float (nx);\n      r.x = (mod (fn.y, 2.) == 1.) ? (floor (0.5 * fn.x) + 1.) * rowGap -\n         blkSpc * (2.- ((mod (fn.x, 2.) == 0.) ? 1. : 3.)) : (fn.x + 1.) * rowGap;\n      if (nb == mId) {\n        rm = r;\n        qm = RotToQt (vec3 (0., 1., 0.), 0.5 * pi * mod (fn.y, 2.));\n      }\n      ++ nb;\n    }\n  }\n  rm.xz -= 0.5 * (float (npRow) + 1.) * rowGap;\n  vm = vec3 (0.);\n  wm = vec3 (0.);\n  fmId = float (mId);\n  if (abs (fmId - 3.) == 1. || abs (fmId - 4.) == 1.) {\n    vm.xz = 5. * (vec2 (3., -1.) * normalize (rm.xz) +\n       0.4 * (1. - 2. * vec2 (Hashff (fmId * todCur), Hashff (3.1 * fmId * todCur))));\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 20000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (0.9, 0.9, 0.7);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXGWf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[974, 974, 993, 993, 1031], [1033, 1033, 1052, 1052, 1090], [1092, 1092, 1136, 1136, 1617], [1619, 1619, 1666, 1666, 1977], [1979, 1979, 2012, 2012, 2434], [2436, 2436, 2482, 2482, 2791], [2793, 2793, 2826, 2826, 3466], [3468, 3468, 3501, 3501, 4744], [4746, 4746, 4787, 4787, 5089], [5091, 5091, 5126, 5126, 5795], [5797, 5797, 5853, 5853, 7274], [7276, 7276, 7309, 7309, 7398], [7400, 7400, 7425, 7425, 7800], [7802, 7802, 7824, 7824, 7851], [7853, 7853, 7875, 7875, 7913], [7915, 7915, 7937, 7937, 7975], [7977, 7977, 8007, 8007, 8120], [8122, 8122, 8158, 8158, 8364], [8398, 8398, 8422, 8422, 8534], [8536, 8536, 8561, 8561, 8747], [8749, 8749, 8770, 8770, 8925], [8927, 8927, 8956, 8956, 9168], [9170, 9170, 9209, 9209, 9389], [9483, 9483, 9508, 9508, 9631]], "test": "untested"}
{"id": "slXGWf", "name": "大龙猫 - Refract Test", "author": "totetmatt", "description": "Adaptation from https://www.youtube.com/watch?v=NCpaaLkmXI8 to \"custom framework\"", "tags": ["refraction"], "likes": 8, "viewed": 289, "published": 3, "date": "1622979830", "time_retrieved": "2024-07-30T19:17:13.389801", "image_code": "\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat diam(vec3 p,float s){\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n//from Iq\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\n   vec3 op = p;\n   vec2 h;\n   h.x = length(p)-1.;\n   h.y = 1.;\n  \n  p.xz*=rot(.7885+iTime*.125);\n  p.xz = abs(p.xz)-2.;\n  p+=vec3(0.,.25,0.);\n  p.xz *=rot(.785);\n  p.xy *=rot(.785+iTime);\n  vec2 t;\n  t.x = mix(box(p,vec3(.7)),diam(p,.7),(sin(iTime*.66)*.5+.5)*1.2)*.7; // Very nice result mixing box and diam\n  t.y = 2.;\n  h = t.x < h.x ? t:h;\n  \n  t.x = dot(op+1.,vec3(0.,1.,0.));\n  t.y = 3.;\n \n  h = t.x < h.x ? t:h;\n   return h;\n}\n\n#define q(s) s*sdf(p+s).x\nvec2 nv=vec2(-.0001,.0001);\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n vec3 col=vec3(.1);\n  vec3 ro=vec3(.0,.0,-5.),rd=normalize(vec3(uv,1.)),rp=ro;\n  vec3 light=vec3(1.,2.,-3.);\n  \n  bool inside = false;\n  vec3 refAcc = vec3(.0);\n  for(float i=0.;i<=69.;i++){ // Difference from Art of Code : One big march\n    \n      vec2 d = sdf(rp); // Usual things\n\n      d.x = abs(d.x); // So, when you march \"inside\",  sdf is negative (the S of sdf)\n      //On tutorial there is a \"side\" that * by -1 so that the ray always march \"ahead\" \n      // So far, never have to use negative distance per say, so doing an abs to \n      // always have positive distance.\n            //EDIT : Looks like can  create some artifact, bref, beware, adapt improvise, overcome\n\n      rp+=rd*d.x; \n      if(d.x <=0.001){ //  If we hit a surface\n          \n        if(d.y == 1.){ // The boring sphere\n          vec3 n = norm(rp);\n           col = vec3(1.)*dot(normalize(light-rp),n);\n           break;\n        } else if (d.y == 3.){ // The Checker floor\n             vec3 n = norm(rp);\n            vec2 ddx_uvw = dFdx( rp.xz ); \n            vec2 ddy_uvw = dFdy( rp.xz ); \n           col = vec3(1.)*dot(normalize(light-rp),n)*checkersTextureGradBox(rp.xz,ddx_uvw,ddy_uvw);\n           break;\n        } else if(d.y==2.) { // the Refractive (?) surface\n              \n              float IOR = 1.45;\n            if(!inside){ // Need to track if it's inside or outside\n              refAcc += vec3(-10.2,.0,.0); // Add some \"tint\" \n              vec3 n = norm(rp);\n              rd = refract(rd,n,1.0/IOR); // Less dense to more dense => 1./IOR\n              rp-=n*.001*5.; // The almighty offset du cul, but here we need to go \"inside\" so -n\n              inside = true;\n            } else if (inside) {\n            i/=2.;\n                refAcc += vec3(.1,.2,.3); // Add some \"tint\" \n     \n               vec3 n = -norm(rp); // norm will give always the norm that \"get out\", so whe need to negate to have the norm \"inside\"\n        \n               vec3 _rd = refract(rd,n,IOR); // More dense to les dense => IOR  . Headache when multiple refract materials :D\n          \n                  if(dot(_rd,_rd)==0.) \n                    { \n                          rd=reflect(rd,n);\n                          rp+=rd*.1;\n                      } else { inside=false;\n                          rd=_rd;\n                        \n                        rp -=0.05*n;\n                 \n                      }\n              }\n        }\n       }  \n        \n  }   \n  col +=refAcc;\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 26, 26, 117], [118, 118, 145, 145, 202], [203, 213, 282, 282, 461], [463, 463, 481, 481, 528], [529, 529, 546, 546, 980], [1036, 1036, 1054, 1054, 1113], [1115, 1115, 1172, 1172, 3759]], "test": "untested"}
{"id": "slX3WX", "name": "Raytraced 3D Truchet Pattern", "author": "oneshade", "description": "More voxel traversing.", "tags": ["3d", "raytracing", "torus", "truchet", "pattern", "voxeltraversal"], "likes": 7, "viewed": 222, "published": 3, "date": "1622970197", "time_retrieved": "2024-07-30T19:17:14.147775", "image_code": "struct Intersect {\n    vec3 nor;\n    vec2 uv;\n    float t;\n};\n\n// The heart of the truchet pattern...\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nvoid updateRoot(inout vec2 old, in vec2 new) { if (abs(new.y) < abs(old.y)) old = new; }\nint iTorus(in vec3 ro, in vec3 rd, in float radius, in float thickness, inout vec4 roots) {\n    float rr = radius * radius, rr4 = 4.0 * rr;\n    float qa = dot(rd, rd), qb = 2.0 * dot(ro, rd), qc = dot(ro, ro) + rr - thickness * thickness;\n\n    float a = qa * qa;\n    float b = 2.0 * qa * qb / a;\n    float c = (2.0 * qa * qc + qb * qb - rr4 * dot(rd.xz, rd.xz)) / a;\n    float d = (2.0 * qb * qc - 2.0 * rr4 * dot(ro.xz, rd.xz)) / a;\n    float e = (qc * qc - rr4 * dot(ro.xz, ro.xz)) / a;\n\n    // Quartic solver based on https://www.maa.org/sites/default/files/pdf/upload_library/22/Ford/auckly29.pdf\n    float bb = b * b;\n    float p = c - 3.0 * bb / 8.0;\n    float q = d - 0.5 * b * c + 0.125 * bb * b;\n    float r = e - 0.25 * b * d + 0.0625 * bb * c - 3.0 * bb * bb / 256.0;\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve for the roots of the factors\n    int n = 0; // Root counter\n    if (lambda < 0.0) return 0;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * b;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        roots.xy = (vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs;\n        n += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 others = (vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs;\n        if (n > 0) roots.zw = others;\n        else roots.xy = others;\n        n += 2;\n    }\n\n    return n;\n}\n\n// align 0: x aligned, align 1: y aligned, align 2: z aligned\nvoid addTorus(inout Intersect isect, in vec3 ro, in vec3 rd, in float radius, in float thickness, in vec3 pos, in int align) {\n    if (align == 0) ro = ro.yxz, rd = rd.yxz, pos = pos.yxz;\n    if (align == 2) ro = ro.xzy, rd = rd.xzy, pos = pos.xzy;\n\n    vec4 roots;\n    int nroots = iTorus(ro - pos, rd, radius, thickness, roots);\n\n    // Optimizing things to be out of the loop hasn't worked yet...\n    for (int idx=0; idx < nroots; idx++) { // All intersections need to be checked against the cell boundaries\n        vec3 hitPos = ro + rd * roots[idx];\n        if (roots[idx] > 0.0 && (isect.t > 0.0 ? roots[idx] < isect.t : true) &&\n            all(lessThan(abs(hitPos), vec3(0.5)))) {\n            hitPos -= pos;\n            float r = length(hitPos.xz);\n            isect.nor = normalize(vec3(hitPos.xz - normalize(hitPos.xz) * radius, hitPos.y)).xzy;\n            isect.nor = align == 0 ? isect.nor.yxz : align == 1 ? isect.nor : isect.nor.xzy;\n            isect.uv = vec2(atan(hitPos.z, hitPos.x), atan(hitPos.y, r - radius));\n            isect.t = roots[idx];\n        }\n    }\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 Hash33(in vec3 p) {\n\tp = fract(p * vec3(0.1031, 0.103, 0.0973));\n    p += dot(p, p.yxz + 33.33);\n    return fract((p.xxy + p.yxx) * p.zyx);\n}\n\nfloat sign2(in float x) { return x < 0.0 ? -1.0 : 1.0; } // Nonzero sign\nIntersect gridCell(in vec3 ro, in vec3 rd, in vec3 pos) {\n    ro -= pos;\n\n    vec3 rand = Hash33(pos) - 0.5;\n    vec3 flip = vec3(sign2(rand.x), sign2(rand.y), sign2(rand.z));\n\n    // Scramble the cell\n    ro *= flip;\n    rd *= flip;\n\n    // Arrange three tori connecting the three pairs of faces\n    Intersect isect = Intersect(vec3(0.0), vec2(0.0), -1.0);\n    addTorus(isect, ro, rd, 0.5, 0.05, vec3( 0.0, -0.5,  0.5), 0);\n    addTorus(isect, ro, rd, 0.5, 0.05, vec3( 0.5,  0.0, -0.5), 1);\n    addTorus(isect, ro, rd, 0.5, 0.05, vec3(-0.5,  0.5,  0.0), 2);\n\n    // Flip normal back into world space\n    isect.nor *= flip;\n\n    return isect;\n}\n\n// Learning from https://github.com/cgyurgyik/fast-voxel-traversal-algorithm/blob/master/overview/FastVoxelTraversalOverview.md\nIntersect traverse(vec3 ro, vec3 rd) {\n    vec3 invRd = 1.0 / rd, octant = sign(rd);\n    vec3 voxel = floor(ro) + 0.5;\n    vec3 corner = 0.5 * octant - ro;\n    for (int iter=0; iter < 15; iter++) {\n        Intersect cell = gridCell(ro, rd, voxel);\n        if (cell.t > 0.0) return cell;\n        vec3 tMax = (voxel + corner) * invRd; // Intersection with the cell boundaries\n        voxel += step(0.0, min(tMax.x, min(tMax.y, tMax.z)) - tMax) * octant; // Step in the direction of the nearest one\n    }\n\n    return Intersect(vec3(0.0), vec2(0.0), -1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, -iTime);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    Intersect hit = traverse(ro, rd);\n    //Intersect hit = gridCell(ro, rd, vec3(0.0)); // Grid cell debugging\n\n    // Render\n    if (hit.t > 0.0) {\n        float diff = abs(dot(hit.nor, normalize(mix(normalize(vec3(-1.0, 1.0, 1.0)), hit.nor, 0.5))));\n        float checker = 0.5 + 0.5 * mod(floor(hit.uv.x / 6.28 * 32.0) + floor(hit.uv.y / 3.14 * 3.0), 2.0);\n        fragColor.rgb = mix(vec3(checker, 0.0, 0.0), vec3(0.0), 1.0 - exp(-hit.t * 0.15)) / max(1.0, 0.125 * hit.t); // Fog\n        fragColor.rgb *= diff;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slX3WX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 102, 126, 126, 169], [170, 170, 216, 216, 258], [259, 259, 350, 350, 2996], [2998, 3060, 3186, 3186, 4142], [4144, 4233, 4257, 4257, 4379], [4381, 4381, 4406, 4406, 4437], [4438, 4454, 4511, 4511, 5098], [5100, 5228, 5266, 5266, 5782], [5784, 5784, 5839, 5839, 6900]], "test": "untested"}
{"id": "NlXGDX", "name": "Imperfect optical system", "author": "michael0884", "description": "just a camera controller with quaternions\nalso a fractal planet as a demo", "tags": ["camera"], "likes": 25, "viewed": 724, "published": 3, "date": "1622943022", "time_retrieved": "2024-07-30T19:17:15.079788", "image_code": "vec3 saturate(vec3 c)\n{\n    return tanh(pow(c,vec3(0.55)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(saturate(acc.xyz/acc.w), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 8.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    float mode = 0.0;\n    if(pressed(keyR)) mode = 1.0;\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = normalize(vec3(1))*5.1;\n        ca = aa2q( normalize(vec3(0,1,-0.3)), 1.17);\n    }\n    vec4 oldca = ca;\n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(10.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(distance(oldca, ca) > 0.001 || length(cv) > 0.01) mode = 1.0;\n    \n    if(p.x == CamP) o = vec4(cp, mode);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 0.8\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    mat3 m = mat3(0.5) + mat3(0, q.zyz * a, 0, q.xyx * a.xxy, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}", "buffer_b_code": "#define SPP 4\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nconst vec2 mp = vec2(-1.,1.);\n\nvoid mengerFold(inout vec3 z) \n{\n\tz.xy += min(z.x - z.y, 0.0)*mp;\n\tz.xz += min(z.x - z.z, 0.0)*mp;\n\tz.yz += min(z.y - z.z, 0.0)*mp;\n}\n\nfloat iFracScale, iFracAng1, iFracAng2;\nvec3 iFracShift, iFracCol;\n\nvec4 fractal(vec3 p)\n{\n    vec2 a1 = vec2(sin(iFracAng1), cos(iFracAng1));\n    vec2 a2 = vec2(sin(iFracAng2), cos(iFracAng2));\n\tmat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);\n\tmat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);\n    float scale = 1.0;\n    vec3 orbit = vec3(0.); \n    for (int i = 0; i <11; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale; scale*=iFracScale;\n\t\tp.xyz += iFracShift;\n        orbit = max(orbit, p.xyz*iFracCol);\n\t}\n    return vec4(clamp(orbit, 0., 1.), sdBox(p, vec3(6.0))/scale);\n}\n\nstruct Level\n{\n    float FracScale, FracAng1, FracAng2;\n    vec3 FracShift, FracCol; \n    vec4 MarblePos, FlagPos;\n    bool isPlanet;\n};\n\nconst int levelnum = 12;\nconst Level[] Levels = Level[]( \n//Jump the crater\nLevel(1.8, -0.12, 0.5,vec3(-2.12, -2.75, 0.49),vec3(0.42, 0.38, 0.19),\n      vec4(-2.95862, 2.68825, -1.11868, 0.035),vec4(2.95227, 2.65057, 1.11848, 0.035),false),\n//Too many trees\nLevel(1.9073f, -9.83f, -1.16f, vec3(-3.508, -3.593, 3.295),vec3(-0.34, 0.12, -0.08),\n      vec4(-3.40191, 4.14347, -3.48312, 0.04),vec4(3.40191, 4.065, 3.48312, 0.04),false),\n//Hole in one\nLevel(2.02f, -1.57f, 1.62f, vec3(-3.31f, 6.19f, 1.53f),vec3(0.12f, -0.09f, -0.09f),\n      vec4(3.18387f, 5.99466f, 0.0f, 0.009f),vec4(0.0f, -6.25f, 0.0f, 0.009f),false),\n//Around the world\nLevel(1.65f, 0.37f, 5.26f, vec3(-1.41f, -0.22f, -0.77f),vec3(0.14f, -1.71f, 0.31f),\n      vec4(0.0f, 2.29418f, 0.0f, 0.01f),vec4(0.0f, -2.25f, 0.0f, 0.01f),true),\n//Beware Of Bumps     \nLevel(1.66f, 1.52f, 0.19f,vec3(-3.83f, -1.94f, -1.09f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(0.68147f, 2.80038f, 2.52778f,0.02f),vec4(0.0f, 2.84448f, -2.71705f, 0.02f),false),\n//Mountain Climbing\nLevel(1.58f, -1.45f, 3.95f,vec3(-1.55f, -0.13f, -2.52f),vec3(-1.17f, -0.4f, -1.0f),\n      vec4(0.0f, 3.36453f, 2.28284f, 0.02f),vec4(0.0f, 3.68893f, -0.604513f, 0.02f),false),\n//Mind the gap                        \nLevel(1.81,-4.84,-2.99,vec3(-2.905, 0.765, -4.165),vec3(0.251,0.337,0.161),\n      vec4(-4.63064f, 3.8365f, 0.0f, 0.022f),vec4(4.63f, 3.61f, 0.0f, 0.022f),false),\n//The Sponge\nLevel(1.88f, 1.52f, 4.91f,vec3(-4.54f, -1.26f, 0.1f),vec3(-1.0f, 0.3f, -0.43f),\n      vec4(-2.8896f, 3.76526f, 0.0f, 0.03f),vec4(2.88924f, 3.73f, 0.0f, 0.03f),false),\n//Build Up Speed\nLevel(2.08f, -4.79f, 3.16f,vec3(-7.43f, 5.96f, -6.23f),vec3(0.16f, 0.38f, 0.15f),\n      vec4(6.06325f, 6.32712f, 0.0f, 0.023f),vec4(0.0f, 6.72f, 0.0f, 0.023f),false),\n//Around The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.03543f, 1.06432f, 1.22698f, 0.01f),vec4(-1.39536f, 0.641835f, 0.0f, 0.01f),false),\n//Top Of The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.04172f, 1.41944f, 1.09742f, 0.005f),vec4(-1.04172f, 1.414f, -1.09742f, 0.005f),false),\n//Mega Citadel\nLevel(1.4731, 0.0f, 0.0f, vec3(-10.27, 3.28, -1.90),vec3(1.17, 0.07, 1.27),\n      vec4(-0.05, 14.69, 0.02, 0.009),vec4(-14.76, 0.01, -0.00, 0.009),false)\n );\n\nvoid LoadLevel(Level LVL)\n{\n    iFracScale = LVL.FracScale;\n    iFracAng1 = LVL.FracAng1;\n    iFracAng2 = LVL.FracAng2;\n    iFracShift = LVL.FracShift;\n    iFracCol = LVL.FracCol;\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 p )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n    //p = mod(p + vec3(3.0), vec3(6.)) - vec3(3.0);\n    res = opU( res, vec2( fractal(p).w, 1.0) );\n    \n    return res;\n}\n\nvec3 normal(vec3 p) \n{\n    const float dx = 0.00001;\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  normalize(k.xyy*map(p + k.xyy*dx).x +\n                      k.yyx*map(p + k.yyx*dx).x +\n                      k.yxy*map(p + k.yxy*dx).x +\n                      k.xxx*map(p + k.xxx*dx).x);\n}\n\nbool trace(inout vec4 ro, vec3 rd)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float de = abs(map(ro.xyz).x); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de - 2.0*step(de, md)*md); \n        if(de < md) return true;\n        if(ro.w > MAX_DIST) return false;\n    }\n    return true;\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*pow2( pow2(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\nconst float aperture_size = 0.34;\nvec2 aperture()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nbool getRay(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    mat3 cam = getCam(get(CamA));\n    \n    vec2 apert_cent = -0.8*uv;\n    \n    vec2 ap = aperture();\n    \n    if(!(distance(ap, apert_cent) < 1.0)) return false;\n    \n    float apd = length(ap);\n    \n    vec3 daperture = ap.x*cam[0] + ap.y*cam[1];\n    \n    ro = get(CamP).xyz + aperture_size*daperture;\n  \n    float focus =2.5 + 0.8*pow(apd,5.0);\n\n   \n    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);\n    \n    return true;\n}\n\nvec4 render(vec2 fragCoord)\n{\n    fragCoord += rand2();\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cp, rd;\n    if(!getRay(uv, cp, rd)) return vec4(0,0,0,1);\n   \n    vec4 ro = vec4(cp,0.0);\n    vec3 fcol;\n    if(trace(ro, rd))\n    {\n        const float roughness = 0.07;\n        vec3 N = normal(ro.xyz);\n        vec3 col = sin(vec3(1,2,3)*length(ro.xyz)*16.0-2.)*0.5 + 0.5;\n\n        vec3 V = -rd;\n        vec3 R = reflect(rd, N);\n        vec3 L = light;\n        vec3 H = normalize(V + L);\n\n        vec3 kS = fresnel(V, N, vec3(0.7));\n        vec3 kD = 1.0 - kS;\n\n        float NdotL = max(dot(N, L), 2e-3);\n        float NdotV = max(dot(N, V), 2e-3);\n\n        float selfshadow = G_ggx(NdotL,roughness)*G_ggx(NdotV,roughness)/max(4.0*NdotL*NdotV,1e-3);\n        vec3 specular = selfshadow*kS*NDF_ggx(H, N, roughness);  \n\n        vec3 direct = (kD * col / PI + tanh(4.*col)*specular) * NdotL;\n        fcol = 5.*direct + 0.1*col;\n\n    }\n    else fcol = vec3(0.0);\n\n    return vec4(fcol, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    LoadLevel(Levels[3]);\n    \n    rng_initialize(fragCoord, iFrame);\n    \n    fragColor = vec4(0.0);   \n    //prev \n    if(get(CamP).w == 0.0)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n   \n   for(int i = 0; i < SPP; i++)\n       fragColor += render(fragCoord);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXGDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 61], [63, 63, 120, 120, 235]], "test": "untested"}
{"id": "Ntf3DX", "name": "Motion Blurred Disk", "author": "oneshade", "description": "Wanted to do my own derivation of analytic motion blur for a disk.", "tags": ["motionblur", "analytic", "disk"], "likes": 9, "viewed": 198, "published": 3, "date": "1622941412", "time_retrieved": "2024-07-30T19:17:15.940487", "image_code": "/*\nThis is not totally correct since it is not moving perfecty linearly\nbut its good enough.\n\nIt does becomes obvious with with high velocity (or low framerate) and nonlinear\nturns though.\n\nThe problem consists of finding how much of the frame duration the\nsample point was over the disk which involves computing the intersection\nof the relative path of the sample point with the disk and computing the gap\nbetween the two intersections.\n*/\n\n// I'm getting lazy on my derivatives :P\nvec2 var2dual(in float x) { return vec2(x, 1.0); }\nvec2 fMul(in vec2 a, in vec2 b) { return vec2(a.x * b.x, a.x * b.y + a.y * b.x); }\nvec2 fDiv(in vec2 a, in vec2 b) { return vec2(a.x / b.x, (b.x * a.y - a.x * b.y) / (b.x * b.x)); }\nvec2 fPow(in vec2 a, in vec2 b) { float q = pow(a.x, b.x); return vec2(q, q * (b.x * a.y / a.x + b.y * log(a.x))); }\nvec2 fSquare(in vec2 z) { return vec2(z.x * z.x, 2.0 * z.x * z.y); }\nvec2 fExp(in vec2 z, in float base) { float q = pow(base, z.x); return vec2(q, q * z.y); }\nvec2 fSin(in vec2 z) { return vec2(sin(z.x), cos(z.x) * z.y); }\nvec2 fCos(in vec2 z) { return vec2(cos(z.x), -sin(z.x) * z.y); }\nvec2 fMin(in vec2 a, in vec2 b) { return a.x < b.x ? a : b; }\nvec2 fMax(in vec2 a, in vec2 b) { return a.x > b.x ? a : b; }\nvec2 fClamp(in vec2 z, in vec2 edge0, in vec2 edge1) { return fMax(edge0, fMin(edge1, z)); }\nvec2 fSmoothstep(in vec2 edge0, in vec2 edge1, in vec2 z) { z = fClamp(fDiv(z - edge0, edge1 - edge0), vec2(0.0), vec2(1.0, 0.0)); vec2 sq = fSquare(z); return 3.0 * sq - 2.0 * fMul(sq, z);}\nvec2 fMix(in vec2 a, in vec2 b, in vec2 t) { return a + fMul(b - a, t); }\n\n// p: sample point\n// o: disk origin\n// r: disk radius\n// v: disk velocity\n// dt: frame duration\nfloat movingDisk(in vec2 p, in vec2 o, in float r, in vec2 v, in float dt) {\n    vec2 p0 = p - o, p1 = v * dt;\n\n    float a = dot(p1, p1);\n    float b = dot(p0, p1);\n    float c = dot(p0, p0) - r * r;\n\n    float h = b * b - a * c;\n    if (h > 0.0) {\n        vec2 t = clamp((vec2(-1.0, 1.0) * sqrt(h) - b) / a, 0.0, 1.0);\n        return t.y - t.x;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 diskX = 0.5 * fCos(6.0 * var2dual(iTime));\n    vec2 diskY = 0.5 * fMul(fCos(6.0 * var2dual(iTime)), fSin(6.0 * var2dual(iTime)));\n    color += movingDisk(uv, vec2(diskX.x, diskY.x), 0.1, vec2(diskX.y, diskY.y), iTimeDelta);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntf3DX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[442, 483, 510, 510, 533], [534, 534, 567, 567, 616], [617, 617, 650, 650, 715], [716, 716, 749, 749, 832], [833, 833, 858, 858, 901], [902, 902, 939, 939, 992], [993, 993, 1015, 1015, 1056], [1057, 1057, 1079, 1079, 1121], [1122, 1122, 1155, 1155, 1183], [1184, 1184, 1217, 1217, 1245], [1246, 1246, 1300, 1300, 1338], [1339, 1339, 1398, 1398, 1529], [1530, 1530, 1574, 1574, 1603], [1605, 1702, 1778, 1778, 2073], [2075, 2075, 2130, 2130, 2495]], "test": "untested"}
{"id": "7lsGD2", "name": "Lime", "author": "voxel", "description": "The rotation is sublime", "tags": ["2d", "fruit"], "likes": 22, "viewed": 429, "published": 3, "date": "1622919909", "time_retrieved": "2024-07-30T19:17:16.792209", "image_code": "const vec3 BG    = vec3(.6);\nconst vec3 PEEL  = vec3(.0, .4, .0);\nconst vec3 PITH  = vec3(.95, 1, .9);\nconst vec3 FLESH = vec3(.7, .8, .0);\nconst int SECTIONS = 9;\n\nconst float PHI = 1.618033988749895; // (1+sqrt(5)) / 2\nconst float PI2 = 6.283185307179586; // 2*pi\n\n// gold noise (shadertoy.com/view/ltB3zD)\nfloat rand21(vec2 p, float seed) { return fract(tan(distance(p*PHI, p)*seed)*p.x); }\nfloat minc(vec2 p) { return min(p.x, p.y); }\nfloat noise(vec2 p, float seed) {\n    vec2 r = floor(p);\n    vec2 s = fract(p);\n    float h00 = rand21(r,             seed);\n    float h01 = rand21(r + vec2(0,1), seed);\n    float h10 = rand21(r + vec2(1,0), seed);\n    float h11 = rand21(r + vec2(1,1), seed);\n    return mix(mix(h00, h01, s.y),\n               mix(h10, h11, s.y),\n               s.x);\n}\n\nfloat height(float r, float angle) {\n    angle -= PI2 * float(SECTIONS) * .5; // section dividers are in the middle\n    float scaledAngle = fract(angle / PI2) * float(SECTIONS);\n    float section = floor(scaledAngle);\n    float subAngle = fract(scaledAngle);\n    return noise(vec2(r*8., subAngle * 15.), section + 100.);\n}\n\n// return the color of a lime with unit radius centered at the origin\nvec3 lime(vec2 p) {\n    float r = length(p);\n    float angle = atan(p.y, p.x) + iTime*.2;\n    \n    float subpos, idx;\n    {\n        float scaledAngle = fract(angle / PI2) * float(SECTIONS);\n        idx = floor(scaledAngle);\n        float hsh1 = rand21(vec2(idx, 10.), 1.);\n        float hsh2 = rand21(vec2(idx, 10.), 2.);\n        subpos = fract(scaledAngle) + 0.03*sin((10.+2.*hsh1)*(r+hsh2));\n    }\n\n    float thresh = .94 + .005 * sin(angle*20.) + .0015 * cos(angle*65.+4.);\n    float pthresh = thresh - .1*smoothstep(.2, -0.2, distance(subpos, .5));\n    \n    float flesh;\n    {\n        float width = atan(.015 / r);\n        flesh = smoothstep(0., width, distance(subpos, .5));\n        flesh *= smoothstep(pthresh-.02, pthresh-.04, r);\n        float center = .04 + .02*smoothstep(.4, -0.2, distance(subpos, .5));\n        flesh *= smoothstep(center, center + .02, r);\n    }\n\n    vec3 color;\n    {\n        float h = height(r, angle);\n        color = mix(FLESH*.85, FLESH*1.1, h);\n        vec2 p2 = p + vec2(-.02,.05);\n        float r2 = length(p2);\n        float angle2 = atan(p2.y, p2.x) + iTime*.2;\n        float h2 = height(r2, angle2);\n        color += .4 * smoothstep(.2, .6, h - h2);\n    }\n    color = mix(PITH, color, flesh);\n    color = mix(color, PEEL, smoothstep(thresh, thresh+.05, r));\n    color = mix(color, BG*.7, smoothstep(1., 1.015, r));\n    color = mix(color, BG, smoothstep(1., 1.3, r));\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy / 2.;\n    float scale = minc(res) * .8;\n    vec3 col = lime((fragCoord - res) / scale);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 309, 343, 343, 393], [394, 394, 414, 414, 438], [439, 439, 472, 472, 791], [793, 793, 829, 829, 1115], [1117, 1187, 1206, 1206, 2613], [2615, 2615, 2670, 2670, 2821]], "test": "untested"}
{"id": "NtX3zl", "name": "Line Fractal", "author": "scry", "description": "just a doodle", "tags": ["2d", "fractal", "zoom", "infinite"], "likes": 5, "viewed": 296, "published": 3, "date": "1622918396", "time_retrieved": "2024-07-30T19:17:17.726711", "image_code": "#define iTime iTime*0.5\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat line(vec2 uvu, float l, float w) {\n    return smoothstep(w, 0.,abs(uvu.x-0.5)-0.005)*smoothstep(0.001,0.,abs(uvu.y-0.5)-l);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    uv += 0.5;\n    //\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    //col.r += smoothstep(0.01,0.,abs(uv.x-0.5));\n    //col.r *= smoothstep(0.01,0.,abs(uv.y-0.5)-0.4);\n    uv -= 0.5;\n    float c = length(uv);\n    float cc = c;\n    //uv.y -= 0.5;\n    //uv = abs(uv)-(sin(iTime*0.5)*0.5+0.5)*0.5;\n    //uv = abs(uv);\n    //uv = fract(uv);\n    //uv.x += 0.5;\n    //c = fract(c);\n    //uv.x += iTime;\n    uv = vec2(log(c),atan(uv.x,uv.y));\n    //uv.x *= 0.1;\n    //uv.x *= 0.5;\n    //uv.x /= c;\n    uv.x -= sin(c+iTime*0.25);\n    //uv.x -= sin(uv.y*4.+iTime);\n    uv.x *= 0.5;\n    //uv.x *= 2.;\n    uv.x -= iTime;\n    //uv.x *= 0.5;\n    uv.x += 1.;\n    //uv = abs(uv)-0.5;\n    //uv *= r2d(iTime*0.1);\n    //uv.x  = abs(uv.x);\n    //uv.y *= 4./3.14;\n    float vt = uv.x;\n    //vt = c*20.;\n    //float sy = float(int(fract(uv.x*0.05)*4.+0.9));\n    float sy = floor(fract(uv.x*0.05)*4.+0.9);\n    //uv.x -= sin(uv.y+iTime)*0.2;\n    //sy = floor(fract(uv.x)*4.);\n    //uv.x /= 8.-sy;\n    //uv.x *= .0000001;\n    //uv *= 0.25;\n    uv.y *= sy/3.14;\n    vt += iTime*0.025;\n    float ux = uv.x;\n    //vt += iTime+uv.y*0.1;\n    //uv.y *= 4./3.14;\n   // vt *= c*0.001;\n    //uv.x -= iTime;\n    //float vt = uv.x;\n    uv = fract(uv)-0.5;\n    c = length(uv);\n    //uv = vec2(log(c),atan(uv.x,uv.y))*0.1;\n    //uv.x += iTime;\n    //uv.y *= 2.;\n    //uv.x += 1.5;\n    //uv.x += 0.5;\n    int steps = 8;\n    //float c = length(uv);\n    //uv -= 0.5;\n    //uv = abs(uv+0.5)-0.5;\n    //uv += 0.5;\n    int s2 = 6;\n    s2 = int(mod(ux*1.,18.));\n    for (int i=0;i<s2;i++) {\n        uv = abs(uv)-(sin(vt*0.5)*0.5+0.5)*0.5;\n        uv *= r2d(float(i)+vt);\n    }\n    //uv -= 0.5;\n    //uv += 0.5;\n    //float c = length(uv);\n    uv *= r2d(sin(c*8.*sin(vt*0.5)+vt*0.5));\n    for (int i=0;i<steps;i++) {\n        uv *= r2d(-vt*0.1);\n        col.r += line(uv+0.5,0.4,(sin(uv.x*04.91)*0.5+0.5)*0.01)*21.;\n    }\n    \n    //col.r -= 4.5;\n    //col.r = fract(col.r*0.01+iTime*0.1);\n    //col.r *= 0.01;\n    //col.r = sin(col.r+iTime*0.1);\n    col.bg = col.rr;\n    col.r *= 0.05;\n    col.r += ux*0.2;\n    //col.r -= iTime*4.;\n    col = vec3(sin(col.r),cos(col.r+0.2),cos(-col.r))*0.8;\n    //col = sin(col+uv.x);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 44, 44, 93], [95, 95, 135, 135, 226], [229, 229, 286, 336, 2706]], "test": "untested"}
{"id": "7ls3W2", "name": "sdfsphere merge", "author": "spectrum", "description": "sdfsphere ass", "tags": ["sdf", "sphere"], "likes": 1, "viewed": 225, "published": 3, "date": "1622915554", "time_retrieved": "2024-07-30T19:17:18.556492", "image_code": "float sdfSphere(vec3 uv, vec3 c, float r) {\n    return pow(max(r - length(uv - c), 0.), 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float col = 0.;\n\n    float c1 = sdfSphere(vec3(uv,0.), vec3(0.), .2);\n    float c2 = sdfSphere(vec3(uv,0.), vec3(vec2(-.15,.15),0.), .1);\n    float c3 = sdfSphere(vec3(uv,0.), vec3(vec2(.15,.15),0.), .1);\n    \n    col = max(col,c1);\n    col = max(col,c2);\n    col = max(col,c3);\n    \n    float e1 = sdfSphere(vec3(uv,0.), vec3(vec2(-.08,.05),0.), .03);\n    float e2 = sdfSphere(vec3(uv,0.), vec3(vec2(.08,.05),0.), .03);\n    col -= e1;\n    col -= e2;\n\n    float b1 = sdfSphere(vec3(uv,0.), vec3(vec2(-.08,.05),0.), .023);\n    float b2 = sdfSphere(vec3(uv,0.), vec3(vec2(.08,.05),0.), .023);\n    col += b1;\n    col += b2;\n\n    float m1 = sdfSphere(vec3(uv,0.), vec3(vec2(0.,-.04),0.), .049);\n    float m2 = sdfSphere(vec3(uv,0.), vec3(vec2(0.,-.07),0.), .035);    \n    col -= min(m1,m2);\n    \n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ls3W2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 95], [97, 97, 154, 154, 1048]], "test": "untested"}
{"id": "NllGR7", "name": "raytracing spheres and planes", "author": "sirjofri", "description": "raytracing spheres and planes. It also uses some DFAO and cheap anti aliasing plus motion blur.", "tags": ["raytracing", "motionblur", "dfao"], "likes": 3, "viewed": 380, "published": 3, "date": "1622899001", "time_retrieved": "2024-07-30T19:17:19.373308", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = vec4(texture(iChannel0, uv).rgb + fract(iTime*2.0*sin(dot(uv, vec2(12.9898, 78.233))*43758.5453))*.02, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// very cheap AA. Uses 5 frames, but doesn't cost a thing. But: flickering.\n// this also causes motion blur, by accident.\n//  0   - no AA\n//  1-5 -  valid AA levels\n// everything below 0 or above 5 is ignored.\n#define AA 5\n\n// scene speed. \"game time\"\n#define S (1.)\n\n// def this if refraction doesn't work or looks weird.\n//#define refract _refract\n\nconst float maxdist = 10000.;\nconst float nearcull = 0.;           // cull everything near the camera\nconst float shadowdist = 0.001;      // shadow ray distance (keep very small)\nconst float refdist = 0.001;         // reflection ray distance (keep very small)\nconst int refsteps = 4;              // reflection steps\n\nvec3 dirlight = normalize(vec3(.8, -.8, 1.));\nvec3 dirlightcolor = vec3(1., .8, .8);\nvec3 fog = vec3(.8, .8, 1.);\n\nvec3 _refract(vec3 I, vec3 N, float eta)\n{\n    eta += 2.;\n    float e = eta*eta;\n    float d = dot(N, I);\n    float k = 1.0 - e*(1.0-d*d);\n    if (k < 0.0)\n        return vec3(0.);\n    return eta*I - (eta*d + sqrt(k)) * N;\n}\n\nvoid movedirlight()\n{\n    dirlight = normalize(vec3(.8, -.8+cos(iTime*S), cos(iTime*S)*.5+.9));\n}\n\nstruct Tp {\nvec3 wp;\nfloat dist;\nvec3 norm;\nint mat;\n};\n\nTp nil(vec3 ro, vec3 rd, float d)\n{\n    return Tp(ro+d*rd, d, vec3(0.), 0);\n}\n\nTp rtSphere(vec3 ro, vec3 rd, vec3 p, float r, int mat)\n{\n    float dotp = dot(rd, ro)-dot(rd, p);\n    float dist = distance(ro, p);\n    float dd = dotp*dotp - (dist*dist - r*r);\n    if (dd < 0.)\n        return nil(ro, rd, maxdist);\n    float d1 = -dotp + sqrt(dd);\n    float d2 = -dotp - sqrt(dd);\n    float d = min(d1, d2);\n    if (d < nearcull)\n       return nil(ro, rd, maxdist);\n    vec3 wp = ro+rd*d;\n    vec3 n = normalize(wp-p);\n    return Tp(wp, d, n, mat);\n}\n\nTp rtPlane(vec3 ro, vec3 rd, vec3 pp, vec3 pn, int mat)\n{\n    float x = dot(rd, pn);\n    if (x == 0.)\n        return nil(ro, rd, maxdist);\n    float d = dot(pp-ro, pn)/x;\n    if (d < 0.)\n        return nil(ro, rd, maxdist);\n    return Tp(ro+d*rd, d, pn, mat);\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n    return distance(pos, p) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n    return dot(p, n) + h;\n}\n\nTp opUnion(Tp a, Tp b)\n{\n    float d = min(a.dist, b.dist);\n    if (d == a.dist) return a;\n    return b;\n}\n\n// the following two functions are the same for different techniques.\n//\n// distance function for the primitives. Used for AO\nfloat mmap(vec3 ro)\n{\n    float plane1 = sdPlane(ro, vec3(0., 0., 1.), 0.);\n    float plane2 = sdPlane(ro, normalize(vec3(-.5, 0., 1.)), 2.);\n    float planes = min(plane1, plane2);\n    float ball1 = sdSphere(ro, vec3(0.7, 15., 1.), 1.);\n    float ball2 = sdSphere(ro, vec3(0.2, 15., .8)+vec3(sin(iTime*2.*S)*3., cos(iTime*2.*S)*2.4, 0.), .8);\n    float balls = min(ball1, ball2);\n    float rball = sdSphere(ro, vec3(1.2, 7., 1.), .3);\n    return min(min(planes, balls), rball);\n}\n\n// raytrace the individual objects, combine them\nTp map(vec3 ro, vec3 rd)\n{\n    Tp plane1 = rtPlane(ro, rd, vec3(0.), vec3(0., 0., 1.), 1);\n    Tp plane2 = rtPlane(ro, rd, vec3(0., 0., -2.), normalize(vec3(-.5, 0., 1.)), 2);\n    Tp planes = opUnion(plane1, plane2);\n    Tp ball1 = rtSphere(ro, rd, vec3(0.7, 15., 1.), 1., 3);\n    Tp ball2 = rtSphere(ro, rd, vec3(0.2, 15., .8)+vec3(sin(iTime*2.*S)*3., cos(iTime*2.*S)*2.4, 0.), .8, 3);\n    Tp balls = opUnion(ball1, ball2);\n    Tp rball = rtSphere(ro, rd, vec3(1.2, 7., 1.), .3, 4);\n    return opUnion(opUnion(planes, balls), rball);\n}\n\n// distance field AO, aka DFAO\nfloat calcAO(Tp s)\n{\n    float d = 0.4;\n    vec3 tp = s.wp + s.norm*d;\n    return clamp(mix(.5, 1., mmap(tp)/d), 0., 1.);\n}\n\nvec3 color(Tp s)\n{\n    \n    vec2 g = floor(mod(s.wp.xy, 2.));\n    float m = clamp(mod(g.x+g.y, 2.), 0., 1.);\n    if (s.dist >= maxdist)\n        return fog;\n    switch (s.mat){\n    case 1: // white ground plane\n        return mix(mix(vec3(1.), vec3(0.), m), vec3(.5), clamp(s.dist*.015, 0., 1.));\n    case 2: // green angled plane\n        return mix(mix(vec3(0., 1., 0.), vec3(0.), m), vec3(0., .5, 0.), clamp(s.dist*.015, 0., 1.));\n    case 3: // red balls\n        return vec3(.8, .02, 0.);\n    case 4: // glass ball\n        return vec3(0.1, 0.3, 0.2);\n    }\n    return vec3(clamp(mod(g.x+g.y, 2.), 0., 1.));\n}\n\nfloat getReflectivity(float d, Tp s)\n{\n    if (s.dist >= maxdist)\n        return 1.;\n    float refl = 1.;\n    switch (s.mat){\n    case 1:\n        refl = mix(0.4, .97, pow(d, .6));\n        break;\n    case 2:\n        refl = mix(0.3, .97, pow(d, .2));\n        break;\n    case 3:\n        refl = mix(0.3, .57, pow(d, .8));\n        break;\n    case 4:\n        refl = mix(0.4, .97, pow(d, .4));\n        break;\n    }\n    return clamp(refl, 0., 1.);\n}\n\n// blend fog and stuff\nvec3 pp(vec3 c, Tp s, vec2 uv)\n{\n    float h = clamp(1.1-s.wp.z*.05, 0., 1.);\n    float d = clamp(s.dist*.002-.05, 0., 1.);\n    return pow(mix(c, fog, d), vec3(1./2.2));\n}\n\nfloat calcShadow(Tp scene)\n{\n    Tp smap = map(scene.wp+shadowdist*scene.norm, dirlight);\n    float ao = calcAO(scene);\n    return clamp(pow(smap.dist, 6.), 0., 1.)*ao;\n}\n\nvec3 getLight(Tp s)\n{\n    return dirlightcolor * (clamp(dot(s.norm, dirlight), 0., 1.) * calcShadow(s)) + fog*.1;\n}\n\nvec3 getReflection(Tp s, vec3 rd)\n{\n    float d = dot(s.norm, rd);\n    d = clamp(d*d, 0., 1.);\n    vec3 ray = rd;\n    Tp refs = s;\n    vec3 refc = vec3(0.);\n    for (int i=0; i<refsteps; i++){\n        float d = dot(refs.norm, ray);\n        d = d*d;\n        ray = reflect(ray, refs.norm);\n        vec3 rcol = color(refs);\n        float r = getReflectivity(d, refs);\n        refs = map(refs.wp+ray*refdist, ray);\n        // which one of those next two lines is more realistic?\n     //   refc += color(refs)*getLight(refs)*rcol*r;\n        refc = mix(color(refs)*getLight(refs)*rcol, refc, r);\n    }\n    return refc;\n}\n\n// is the material refracting?\nbool refracting(Tp s)\n{\n    return s.mat == 4;\n}\n\nvec4 getRefraction(Tp s, vec3 rd)\n{\n    float r1 = 1.05;\n    float r2 = 1.0;\n    if (!refracting(s))\n        return vec4(0.);\n    vec3 ray = refract(rd, s.norm, r1/r2);\n    Tp scene = map(s.wp + refdist*ray, ray);\n    if (!refracting(scene))\n        return vec4(color(scene)*getLight(scene)*normalize(color(s)), clamp(scene.dist, 0., 1.));\n    ray = refract(ray, scene.norm, r2/r1);\n    Tp scout = map(scene.wp + refdist*ray, ray);\n    return vec4(color(scout)*getLight(scout)*normalize(color(s)), clamp(scout.dist, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ouv = uv;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 diff = ((fragCoord+vec2(1.))-fragCoord)/2./iResolution.xy;\n    diff *= .5;\n    \n    movedirlight();\n    \n    float cammove = smoothstep(-.1, .8, cos(iTime*.8*S))*2.-1.;\n    vec3 ro = vec3(sin(iTime*6.*S)*.02+cammove, cammove*5.+sin(iTime*9.*S)*.01, 2.-cammove+cos(iTime*5.*S)*.01);\n    vec3 rd = normalize(vec3(uv.x, 2., uv.y));\n    \n#if AA != 0\n    //   1 4\n    //    0\n    //   3 2\n    switch (iFrame% max(5, min(0, AA)) ){\n    case 0:\n        break;\n    case 1:\n        rd = normalize(vec3(uv.x-diff.x, 2., uv.y-diff.y));\n        break;\n    case 2:\n        rd = normalize(vec3(uv.x+diff.x, 2., uv.y+diff.y));\n        break;\n    case 3:\n        rd = normalize(vec3(uv.x-diff.x, 2., uv.y+diff.y));\n        break;\n    case 4:\n        rd = normalize(vec3(uv.x+diff.x, 2., uv.y-diff.y));\n        break;\n    }\n#endif\n    \n    Tp scene = map(ro, rd);\n    vec3 col = color(scene);\n    vec3 lightcol = getLight(scene);\n    vec3 refl = getReflection(scene, rd);\n    vec4 refr = getRefraction(scene, rd);\n    \n    float d = dot(scene.norm, rd);\n    d = d*d;\n\n    col = mix(col, refr.rgb, refr.a);\n    col = mix(refl, col*lightcol*lightcol, getReflectivity(d, scene));\n    col = pp(col, scene, uv);\n#if AA != 0\n    if (iFrame != 0) {\n        vec3 ocol = texture(iChannel0, ouv).rgb;\n        col += ocol;\n        col /= 2.;\n    }\n#endif\n\n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 226]], "test": "untested"}
{"id": "Nd23zc", "name": "Raytraced Implicit Fields", "author": "oneshade", "description": "Trilinear approximation (now much faster thanks to @kastorp).", "tags": ["voxels", "approximation", "raytraced", "implicit", "cell", "trilinear", "traversal"], "likes": 12, "viewed": 194, "published": 3, "date": "1622892933", "time_retrieved": "2024-07-30T19:17:20.132279", "image_code": "#define USE_DISTANCE_FIELD_NORMAL\n#define CELL_TRAVERSALS 40\n#define VOXEL_SIZE 0.25\n\nfloat implicit(in vec3 p) {\n    p *= VOXEL_SIZE; // Undo scaling in the implicit surface\n    float n = mix(0.5, 6.0, 0.5 + 0.5 * sin(iTime));\n    return pow(abs(p.x), n) + pow(abs(p.y), n) + pow(abs(p.z), n) - pow(1.5, n);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    float m = implicit(p);\n    return normalize(vec3(implicit(p + e.xyy) - m,\n                          implicit(p + e.yxy) - m,\n                          implicit(p + e.yyx) - m));\n}\n\n// Cubic solver\nint solveCubic(in float a, in float b, in float c, in float d, out vec3 roots) {\n    float u = b / (3.0 * a);\n\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n    if (abs(p) < 1e-9) { roots.x = -sign(q) * pow(abs(q), 1.0 / 3.0) - u; return 1; }\n\n    if (4.0 * p * p * p + 27.0 * q * q > 0.0) {\n        float ip = 3.0 / abs(p), sp = sqrt(ip), k = 0.5 * q * ip * sp;\n        if (p > 0.0) roots.x = -2.0 / sp * sinh(asinh(k) / 3.0) - u;\n        else roots.x = -2.0 / sp * cosh(acosh(abs(k)) / 3.0) * sign(q) - u;\n        return 1;\n    }\n\n    float m = sqrt(-p / 3.0);\n    roots.x = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    float h = sqrt(-3.0 * roots.x * roots.x - 4.0 * p);\n    roots.yz = 0.5 * vec2(h - roots.x, -h - roots.x);\n    roots -= u;\n\n    return 3;\n}\n\n// Intersection\nvec4 iTrilinearIsoSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    vec4 u = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);\n    vec3 v = vec3(b, c, e) - a;\n\n    vec3 xxyyzz = ro.xxy * ro.yzz;\n    vec3 uuvvww = rd.xxy * rd.yzz;\n\n    float t3 = u.x * rd.x * rd.y * rd.z;\n    float t2 = dot(ro.zyx, uuvvww) * u.x + dot(u.yzw, uuvvww);\n    float t1 = dot(u, vec4(dot(xxyyzz, rd.zyx), dot(ro.xy, rd.yx), dot(ro.xz, rd.zx), dot(ro.yz, rd.zy))) + dot(v, rd);\n    float t0 = u.x * ro.x * ro.y * ro.z + dot(u.yzw, xxyyzz) + dot(v, ro) + a;\n\n    t3 += 0.000001; // To deal with precision issues that seem to arise with this surface\n\n    vec4 hits;\n    hits.w = float(solveCubic(t3, t2, t1, t0, hits.xyz));\n\n    return hits;\n}\n\n// Normal\nvec3 nTrilinearIsoSurf(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    vec4 u = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);\n    return normalize(u.x * p.yxx * p.zzy + u.yyz * p.yxx + u.zww * p.zzy + vec3(b, c, e) - a);\n}\n\nvec4 gridCell(in vec3 ro, in vec3 rd, in vec3 pos) {\n    ro -= pos;\n\n    // Isovalues\n    float a = implicit(pos);\n    float b = implicit(pos + vec3(1.0, 0.0, 0.0));\n    float c = implicit(pos + vec3(0.0, 1.0, 0.0));\n    float d = implicit(pos + vec3(1.0, 1.0, 0.0));\n    float e = implicit(pos + vec3(0.0, 0.0, 1.0));\n    float f = implicit(pos + vec3(1.0, 0.0, 1.0));\n    float g = implicit(pos + vec3(0.0, 1.0, 1.0));\n    float h = implicit(pos + 1.0);\n\n    float sa = sign(a);\n    if (sa == sign(b) && sa == sign(c) && sa == sign(d) &&\n        sa == sign(e) && sa == sign(f) && sa == sign(g) &&\n        sa == sign(h)) return vec4(-1.0, vec3(0.0));\n\n    // Intersect\n    vec4 hit = iTrilinearIsoSurf(ro, rd, a, b, c, d, e, f, g, h);\n    float t = -1.0;\n    vec3 hitPos;\n\n    // Find closest\n    for (int n=0; n < int(hit[3]); n++) {\n        vec3 hitCandid = ro + rd * hit[n];\n        if (hit[n] > 0.0 && (t < 0.0 ? true : hit[n] < t) && all(lessThan(abs(hitCandid - 0.5), vec3(0.5)))) {\n            t = hit[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    #ifdef USE_DISTANCE_FIELD_NORMAL\n    vec3 nor = getNormal(pos + hitPos);\n    #else\n    vec3 nor = nTrilinearIsoSurf(hitPos, a, b, c, d, e, f, g, h);\n    #endif\n\n    return vec4(t, nor);\n}\n\n// Adapted from https://www.shadertoy.com/view/MdBGRm\n// vec4(dist, normal)\nvec4 traverse(vec3 ro, vec3 rd) {\n    vec3 grid = floor(ro);\n    vec3 gridStep = sign(rd);\n    vec3 corner = max(gridStep, 0.0);\n\n    vec3 ratio = (grid + corner - ro) / rd;\n    vec3 ratioStep = gridStep / rd;\n\n    for (int i=0; i < CELL_TRAVERSALS; i++) {\n        vec4 hit = gridCell(ro, rd, grid);\n        if (hit.x > 0.0) return hit;\n\n        vec3 cp = step(ratio, ratio.yzx);\n        vec3 mask = cp * (1.0 - cp.zxy);\n\n        grid += gridStep * mask;\n        ratio += ratioStep * mask;\n\t}\n\n    return vec4(-1.0, 0.0, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Intersect\n    ro /= VOXEL_SIZE; // Shrink voxels to half size\n    vec4 hit = traverse(ro, rd);\n    vec3 hitPos = ro + rd * hit.x;\n\n    // Render the shape if hitting\n    if (hit.x > 0.0) {\n        float diff = abs(dot(hit.yzw, -rd));\n        fragColor = mix(vec4(hit.yzw, 1.0), texture(iChannel0, reflect(-rd, hit.yzw)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd23zc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 113, 113, 310], [312, 312, 339, 339, 554], [556, 572, 652, 652, 1383], [1385, 1401, 1545, 1545, 2233], [2235, 2245, 2376, 2376, 2569], [2571, 2571, 2623, 2623, 3825], [3827, 3903, 3936, 3936, 4436], [4438, 4438, 4493, 4493, 5548]], "test": "untested"}
{"id": "NtsGWj", "name": "Distance to Truchet", "author": "oneshade", "description": "Distance to 2D truchet and a parametrization.", "tags": ["2d", "sdf", "truchet", "distance", "parametrization"], "likes": 13, "viewed": 247, "published": 3, "date": "1622873154", "time_retrieved": "2024-07-30T19:17:20.925159", "image_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy).x;\n}\n\nvec2 sdTruchet(in vec2 p) {\n    vec2 cId = floor(p);\n    vec2 cUv = fract(p) - 0.5;\n\n    cUv.x *= sign(Hash21(cId) - 0.5);\n    cUv -= cUv.x < -cUv.y ? -0.5 : 0.5;\n\n    float t = atan(cUv.y, cUv.x);\n    t *= sign(mod(cId.x + cId.y, 2.0) - 0.5);\n\n    return vec2(abs(length(cUv) - 0.5), t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0 + 0.25 * iTime;\n\n    vec2 truchet = sdTruchet(uv);\n    float d = truchet.x - 0.1;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d) * 0.6));\n\n    if (d < 0.02) {\n        truchet.y -= 0.5 * iTime;\n        float fade = 0.5 + 0.5 * sin(iTime);\n        float vertStripes = abs(mod(d + 0.0333, 0.0666) - 0.0333);\n        float horiStripes = abs(mod(truchet.y + 0.1, 0.2) - 0.1) * 0.5;\n        color += fade * smoothstep(0.03, 0.0, min(vertStripes, horiStripes));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 114, 114, 251], [253, 253, 280, 280, 543], [545, 545, 600, 600, 1371]], "test": "untested"}
{"id": "ftlGWj", "name": "Ls_Glint", "author": "pucknz", "description": "Testing ... original code for Autodesk flame matchbox by lewis@lewissaunders.com", "tags": ["highlights", "glint"], "likes": 4, "viewed": 400, "published": 3, "date": "1622869080", "time_retrieved": "2024-07-30T19:17:21.859660", "image_code": "//\n//\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//                        MM.                          .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                     MM.  .MMMM        MMMMMMM    MMM.  .MM\n//                    MM.  .MMM           MMMMMM     MMM.  .MM\n//                   MM.  .MmM              MMMM      MMM.  .MM\n//                  MM.  .MMM                 MM       MMM.  .MM\n//                 MM.  .MMM                   M        MMM.  .MM\n//                MM.  .MMM                              MMM.  .MM\n//                 MM.  .MMM                            MMM.  .MM\n//                  MM.  .MMM       M                  MMM.  .MM\n//                   MM.  .MMM      MM                MMM.  .MM\n//                    MM.  .MMM     MMM              MMM.  .MM\n//                     MM.  .MMM    MMMM            MMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                        MM.                          .MM\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//\n//\n//\n//\n// Adaptation pour Natron par F. Fernandez\n// Code original : Ls_Glint Matchbox pour Autodesk Flame\n\n// Adapted to Natron by F.Fernandez\n// Original code : Ls_Glint Matchbox for Autodesk Flame\n\n\n// iChannel0: pass2_result, filter = linear , wrap = clamp\n// iChannel1: Source, filter = linear , wrap = clamp\n// iChannel2: Mask, filter = linear , wrap = clamp\n// BBox: iChannel0\n\n\n// Glint pass 3: Gaussian blur vertical and comp\n// lewis@lewissaunders.com\n\n\n\nfloat blursize = 0.5;     // Blur : , min=0.0, max=10000.0\nfloat blursizer = 1.0;    // Blur weight R : , min=0.0, max=10000.0\nfloat blursizeg = 1.0;    // Blur weight G : , min=0.0, max=10000.0\nfloat blursizeb = 1.0;    // Blur weight B : , min=0.0, max=10000.0\n\nbool screen = true; // Screen Highlights : (Screens the glints over the image instead of simply adding them)\nbool usematte = false; // Use Matte on Glint Source : (Generate glints only from highlights inside the matte; the matte can also be RGB to selectively tint the stars)\nbool useblendmatte = false; // Use Matte to Blend (faster) : (Only processes pixels inside the matte - this is really fast for small mattes, but glints will be cut off at the matte edge)\nbool outputglints = false; // Output Glints Only : (Output just the glints on black)\n\n\n// RGB to Rec709 YPbPr\nvec3 yuv(vec3 rgb) {\n    return mat3(0.2215, -0.1145, 0.5016, 0.7154, -0.3855, -0.4556, 0.0721, 0.5, -0.0459) * rgb;\n}\n\n// Return a 1D Gaussian blur from texture tex\n// xy: centre of blur in pixels\n// res: pixel size of mipmap level selected by lod param\n// sizes: sigma of blurs, in pixels\n// dir: direction of blur, usually vec2(1.0, 0.0) for horizontal followed by\n//      another pass for vertical\nvec4 gaussianblur(sampler2D tex, vec2 xy, vec2 res, float sizered, float sizegreen, float sizeblue, float sizealpha, vec2 dir) {\n    vec4 sigmas = vec4(sizered, sizegreen, sizeblue, sizealpha);\n\n    // Set up state for incremental coefficient calculation, see GPU Gems\n    // We use vec4s to store four copies of the state, for different size\n    // red/green/blue/alpha blurs\n    vec4 gx, gy, gz;\n    gx = 1.0 / (sqrt(2.0 * 3.141592653589793238) * sigmas);\n    gy = exp(-0.5 / (sigmas * sigmas));\n    gz = gy * gy;\n    // vec4 a, centre, sample1, sample2 = vec4(0.0);\n    vec4 a = vec4(0.0);\n    vec4 centre = vec4(0.0);\n    vec4 sample1 = vec4(0.0);\n    vec4 sample2 = vec4(0.0);\n\n    // First take the centre sample\n    centre = texture(tex, xy / res);\n    a += gx * centre;\n    vec4 energy = gx;\n    gx *= gy;\n    gy *= gz;\n\n    // Now the other samples\n    float support = max(max(max(sigmas.r, sigmas.g), sigmas.b), sigmas.a) * 3.0;\n    for(float i = 1.0; i <= support; i++) {\n        sample1 = texture(tex, (xy - i * dir) / res);\n        sample2 = texture(tex, (xy + i * dir) / res);\n        a += gx * sample1;\n        a += gx * sample2;\n        energy += 2.0 * gx;\n        gx *= gy;\n        gy *= gz;\n    }\n\n    a /= energy;\n\n    if(sizered < 0.1) a.r = centre.r;\n    if(sizegreen < 0.1) a.g = centre.g;\n    if(sizeblue < 0.1) a.b = centre.b;\n\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(iResolution.x, iResolution.y);\n    vec2 xy = fragCoord.xy;\n\n    vec3 frontpix = texture(iChannel1, xy/res).rgb;\n    vec3 mattepix = texture(iChannel2, xy/res).rgb;\n\n    vec3 blurred = gaussianblur(iChannel0, xy, res, blursize*blursizer, blursize*blursizeg, blursize*blursizeb, 0.0, vec2(0.0, 1.0)).rgb;\n\n    // Blend with front input\n    vec3 result;\n    float blurredluma;\n    if(useblendmatte == true) {\n        blurred *= mattepix;\n        blurredluma = yuv(blurred.rgb).r; // Luma is used for matte output below\n    }\n    if(screen == true) {\n        result = max(max(frontpix, blurred), blurred+frontpix-(blurred*frontpix));\n    } else {\n        result = frontpix + blurred;\n    }\n    if(outputglints == true) {\n        result = blurred;\n    }\n\n    // Matte output is luma of glint only\n    fragColor = vec4(result, blurredluma);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n//\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//                        MM.                          .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                     MM.  .MMMM        MMMMMMM    MMM.  .MM\n//                    MM.  .MMM           MMMMMM     MMM.  .MM\n//                   MM.  .MmM              MMMM      MMM.  .MM\n//                  MM.  .MMM                 MM       MMM.  .MM\n//                 MM.  .MMM                   M        MMM.  .MM\n//                MM.  .MMM                              MMM.  .MM\n//                 MM.  .MMM                            MMM.  .MM\n//                  MM.  .MMM       M                  MMM.  .MM\n//                   MM.  .MMM      MM                MMM.  .MM\n//                    MM.  .MMM     MMM              MMM.  .MM\n//                     MM.  .MMM    MMMM            MMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                        MM.                          .MM\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//\n//\n//\n//\n// Adaptation pour Natron par F. Fernandez\n// Code original : Ls_Glint Matchbox pour Autodesk Flame\n\n// Adapted to Natron by F.Fernandez\n// Original code : Ls_Glint Matchbox for Autodesk Flame\n\n\n// iChannel0: Source, filter = linear , wrap = clamp\n// iChannel1: Mask, filter = linear , wrap = clamp\n// BBox: iChannel0\n\n\n// Glint pass 1: convolve with a dynamically generated star function\n// lewis@lewissaunders.com\n\n\n// TODO: option to downres / process / upres, as request by GP-M\n\n\n\nfloat threshold = .3;              // Threshold : (Highlights darker than this are ignored), min=0.0, max=200.0\nfloat thresholdclamp = 5.0;         // Threshold Clamp : (Highlights brighter than this don't increase the glint further, to avoid hot pixels creating huge stars), min=0.0, max=200.0\n\nfloat gain = 50.0;                  // Gain : (Overall brightness of stars), min=0.0, max=2000.0\nfloat size = 100.0;                  // Size : (Size of the stars), min=0.01, max=400.0\nfloat rays = 6.0;                   // Rays : (How many points each star has), min=0.0, max=100.0\nfloat spin = 48.0;                  // Spin : (Rotate the stars), min=-360.0, max=360.0\nfloat falloff = 1.9;                // Falloff : (Dissolves away ends of rays), min=-2.0, max=4.0\nfloat twirl = 0.0;                  // Twirl : (Bend the arms of the stars), min=-1080.0, max=1080.0\nfloat barrel = 0.0;                 // Barrel Distort : (Bend stars around center of frame), min=-10.0, max=10.0\nfloat barrelbend = 2.0;             // Barrel Bend : (Bendiness of barrel distortion), min=1.0, max=20.0\nfloat saturation = 0.0;             // Saturation : (How much star colour comes from the underlying image), min=-10.0, max=10.0\nfloat extrasize = 1.0;              // Extra Size : (Extra multiplier on size if you want extra big glints - it will get slow, be careful!), min=0.01, max=20.0\nfloat extrarays = 1.0;              // Extra Rays : (Extra multiplier on ray count if you want many more ray arms - it will get slow, be careful!), min=0.01, max=20.0\n\nvec3 tint = vec3( 1.0 , 1.0 , 1.0); // Tint : (Tint the stars towards this colour)\n\nbool dirton = true; // Use Noise : \nbool usematte = true; // Use Matte on Glint Source : (Generate glints only from highlights inside the matte; the matte can also be RGB to selectively tint the stars)\nbool useblendmatte = false; // Use Matte to Blend (faster) : (Only processes pixels inside the matte - this is really fast for small mattes, but glints will be cut off at the matte edge)\n\nvec2 dirtParam = vec2( 0.1, 5.0 ); // Dirt Parameters : \n\nvec3 dispDispOffsetDispCycles = vec3( 0.25 , -45.0 , 1.0 ); // Dispersion Parameters : \n\nvec2 aspectAA = vec2( 1.0 , 1.4 ); // Aspect and AA samples : \n\n\n\n#define realsize (size*extrasize)\n#define samples (size*extrasize*aspectAA.y)\n#define tau (2.0*3.1415926535)\n\n// RGB to Rec709 YPbPr\nvec3 yuv(vec3 rgb) {\n    return mat3(0.2215, -0.1145, 0.5016, 0.7154, -0.3855, -0.4556, 0.0721, 0.5, -0.0459) * rgb;\n}\n\n// Rec709 YPbPr to RGB\nvec3 rgb(vec3 yuv) {\n    return mat3(1.0, 1.0, 1.0, 0.0, -0.1870, 1.8556, 1.5701, -0.4664, 0.0) * yuv;\n}\n\n// Noise\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / vec2(iResolution.x, iResolution.y);\n    vec3 frontpix = texture(iChannel0, uv).rgb;\n    vec3 mattepix = texture(iChannel1, uv).rgb;\n    vec3 sampler, glint = vec3(0.0);\n    vec2 offset;\n    float angle;\n\n    // If matte is being used to blend with, we can take a massive shortcut where it's black\n    if(useblendmatte && (length(mattepix) < 0.0001)) {\n        fragColor = vec4(frontpix, 0.0);\n        return;\n    }\n\n    // Iterate around rays\n    for(float ray = 0.0; ray < floor(rays*extrarays); ray++) {\n        // Figure out what angle this ray is at\n        angle = ray * tau/floor(rays*extrarays);\n\n        // Spin rotates entire glint\n        angle -= spin/360.0 * tau;\n\n        // Iterate along arm of ray\n        for(float i = realsize/samples; i < realsize; i += realsize/samples) {\n            // Twirl ray around further as we move out\n            angle -= (twirl/samples * i/realsize)/360.0 * tau;\n\n            // Offset along ray direction\n            offset = i/vec2(iResolution.x, iResolution.y) * vec2(cos(angle), sin(angle));\n\n            // Horizontal stretch/squash for anamorphic glints\n            offset.x *= aspectAA.x;\n\n            // Barrel pushes ends of rays away towards edge of frame\n            offset -= pow((i/realsize), barrelbend) * 0.1 * barrel * (-uv+vec2(0.5, 0.5));\n\n            // Read a pixel\n            sampler = texture(iChannel0, uv + offset).rgb;\n\n            // Affect it by the matte\n            if(usematte) {\n                sampler *= texture(iChannel1, uv + offset).rgb;\n            }\n\n            // Only keep pixels over threshold\n            sampler = min(sampler, thresholdclamp);\n            sampler *= max(sampler - threshold, 0.0);\n\n            // Falloff darkens the ray ends\n            if(falloff > 1.0) {\n                sampler *= max(0.0, mix(1.0, -falloff+2.0, i/realsize));\n            } else {\n                sampler *= max(0.0, mix(falloff, 1.0, i/realsize));\n            }\n\n            // Do saturation in YUV\n            vec3 sampley = yuv(sampler);\n            sampley.gb *= saturation;\n\n            // Hue varies along length of ray\n            float hue = dispDispOffsetDispCycles.b * tau *-i/realsize;\n            hue -= dispDispOffsetDispCycles.g/360.0 * tau;\n\n            // I'm adventurously using YUV to do a rainbow tint here\n            // The discontinuities in the usual HSV method bug me\n            // and are probably slower than this, which just requires\n            // matrix mults and a bit of trig\n            // Hue is the angle around centre of UV plane\n            vec2 rainbow = vec2(cos(hue), sin(hue)) * sampley.r;\n            sampley.gb = mix(sampley.gb, rainbow, dispDispOffsetDispCycles.r * i/realsize);\n            sampler = rgb(sampley);\n\n            if(dirton) {\n                // Multiply by a bit of noise texture\n                float noiz = rand(vec2(42.1, 12.4) + 0.01 * vec2(dirtParam.y/100.0)   * offset);\n                noiz +=      rand(vec2(4.1, 1.4)   + 0.01 * vec2(dirtParam.y/1000.0)  * offset);\n                noiz +=      rand(vec2(2.1, 2.4)   + 0.01 * vec2(dirtParam.y/10000.0) * offset);\n                sampler *= mix(1.0, clamp(10.0 * noiz, 0.0, 99.0), dirtParam.x);\n            }\n\n            // Accumulate\n            glint += sampler;\n        }\n    }\n    // Normalise all our accumulated samples\n    glint /= floor(rays*extrarays) * samples;\n\n    // Master brightness\n    glint *= gain;\n\n    // Tint in YUV space\n    vec3 glinty = yuv(glint);\n    vec3 tinty = yuv(tint);\n    tinty.gb *= glinty.r; // If U/V aren't 0 when Y is black, bad things happen...\n    glinty.gb = mix(glinty.gb, tinty.gb, 4.0*length(tinty.gb));\n    glint = rgb(glinty);\n\n    fragColor = vec4(glint, 0.0);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//\n//\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//                        MM.                          .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                     MM.  .MMMM        MMMMMMM    MMM.  .MM\n//                    MM.  .MMM           MMMMMM     MMM.  .MM\n//                   MM.  .MmM              MMMM      MMM.  .MM\n//                  MM.  .MMM                 MM       MMM.  .MM\n//                 MM.  .MMM                   M        MMM.  .MM\n//                MM.  .MMM                              MMM.  .MM\n//                 MM.  .MMM                            MMM.  .MM\n//                  MM.  .MMM       M                  MMM.  .MM\n//                   MM.  .MMM      MM                MMM.  .MM\n//                    MM.  .MMM     MMM              MMM.  .MM\n//                     MM.  .MMM    MMMM            MMM.  .MM\n//                      MM.  .MMMMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                       MM.  .MMMMMMMMMMMMMMMMMMMMMM.  .MM\n//                        MM.                          .MM\n//                          MMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//\n//\n//\n//\n// Adaptation pour Natron par F. Fernandez\n// Code original : Ls_Glint Matchbox pour Autodesk Flame\n\n// Adapted to Natron by F.Fernandez\n// Original code : Ls_Glint Matchbox for Autodesk Flame\n\n\n// iChannel0: pass1_result, filter = linear , wrap = clamp\n// BBox: iChannel0\n\n\n// Glint pass 2: Gaussian blur horizontal\n// lewis@lewissaunders.com\n\n\n\nfloat blursize = 0.5;     // Blur : , min=0.0, max=10000.0\nfloat blursizer = 1.0;    // Blur weight R : , min=0.0, max=10000.0\nfloat blursizeg = 1.0;    // Blur weight G : , min=0.0, max=10000.0\nfloat blursizeb = 1.0;    // Blur weight B : , min=0.0, max=10000.0\n\n\n\n// Return a 1D Gaussian blur from texture tex\n// xy: centre of blur in pixels\n// res: pixel size of mipmap level selected by lod param\n// sizes: sigma of blurs, in pixels\n// dir: direction of blur, usually vec2(1.0, 0.0) for horizontal followed by\n//      another pass for vertical\nvec4 gaussianblur(sampler2D tex, vec2 xy, vec2 res, float sizered, float sizegreen, float sizeblue, float sizealpha, vec2 dir) {\n    vec4 sigmas = vec4(sizered, sizegreen, sizeblue, sizealpha);\n\n    // Set up state for incremental coefficient calculation, see GPU Gems\n    // We use vec4s to store four copies of the state, for different size\n    // red/green/blue/alpha blurs\n    vec4 gx = vec4(0.0);\n    vec4 gy = vec4(0.0);\n    vec4 gz = vec4(0.0);\n\n    gx = 1.0 / (sqrt(2.0 * 3.141592653589793238) * sigmas);\n    gy = exp(-0.5 / (sigmas * sigmas));\n    gz = gy * gy;\n    // vec4 a, centre, sample1, sample2 = vec4(0.0);\n    vec4 a = vec4(0.0);\n    vec4 centre = vec4(0.0);\n    vec4 sample1 = vec4(0.0);\n    vec4 sample2 = vec4(0.0);\n\n    // First take the centre sample\n    centre = texture(tex, xy / res);\n    a += gx * centre;\n    vec4 energy = gx;\n    gx *= gy;\n    gy *= gz;\n\n    // Now the other samples\n    float support = max(max(max(sigmas.r, sigmas.g), sigmas.b), sigmas.a) * 3.0;\n    for(float i = 1.0; i <= support; i++) {\n        sample1 = texture(tex, (xy - i * dir) / res);\n        sample2 = texture(tex, (xy + i * dir) / res);\n        a += gx * sample1;\n        a += gx * sample2;\n        energy += 2.0 * gx;\n        gx *= gy;\n        gy *= gz;\n    }\n    \n    a /= energy;\n    \n    if(sizered < 0.1) a.r = centre.r;\n    if(sizegreen < 0.1) a.g = centre.g;\n    if(sizeblue < 0.1) a.b = centre.b;\n    \n    return a; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = vec2(iResolution.x, iResolution.y);\n    vec2 xy = fragCoord.xy;\n    fragColor = gaussianblur(iChannel0, xy, res, blursize*blursizer, blursize*blursizeg, blursize*blursizeb, 0.0, vec2(1.0, 0.0));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2471, 2494, 2514, 2514, 2612], [2614, 2896, 3024, 3024, 4263], [4265, 4265, 4322, 4322, 5179]], "test": "untested"}
{"id": "stf3Dj", "name": "2D Bezier: De Casteljau's", "author": "maras", "description": "Based on \"2D Quadratic Bezier\" by demofox (shadertoy.com/view/MtS3Dy)\nand \"Reusable drag and drop\" by mhnewman (shadertoy.com/view/4dtSRn).\nMore info in comment below (sorry, characters limit).", "tags": ["2d", "interactive", "bezier", "curve", "learning"], "likes": 13, "viewed": 544, "published": 3, "date": "1622860021", "time_retrieved": "2024-07-30T19:17:22.845026", "image_code": "/* \n Hi. I made this shader to make it easier to visualize Bezier curves and de Casteljau's algorithm.\n You can find more shaders to learn about Bezier curves\n on my playlist: https://www.shadertoy.com/playlist/X3XfWf (still WiP)\n Enjoy <3\n*/\n\n// changeable parameters (feel free to experiment!) \n\n#define BEZIER_CURVE_POINTS 5 // int, minimum = 2, maximum = 13\n\n// Remember to change BEZIER_CURVE_POINTS parameter in \"Buffer A\" too! (second tab, you can select it ot the top of this window)\n// After changing BEZIER_CURVE_POINTS peremeter you need to reset shader's time (button on the bottom of shader window)\n// PS: higher values can be imposible to compile if your GPU is weak. Sorry\n\n#define BACKWARDS_ANIMATION true // bool\n\n#define SLOW_DOWN 2.0 // float, need to be typed with decimal point (.)\n\n// sorry for naming the parameter \"SLOW_DOWN\" instead of \"SPEED\", but default speed is really fast\n// and it's easier for you to slow down things by an integer instead of speeding up by for example 0.25.\n// If you want to speed up the animation you can use a float lower than 1.0\n\n// Information on the parameters below is provided in the comment\n\n#define SHOW_RED_DOTS true // bool\n#define SHOW_BLUE_DOT true // bool\n#define SHOW_FINAL_DOT true // bool\n\n#define SHOW_BLACK_LINE true // bool\n#define SHOW_GREY_LINES true // bool\n\n#define ALWAYS_SHOW_BEZIER_CURVE false // bool\n\n#define CASTELJAUS_STEPS 50 // int, more than 1000 can really slow down your computer, be careful\n\n#define SHOW_1_SUPPORT_POINT true // bool\n#define SHOW_2_SUPPORT_POINT true // bool\n#define SHOW_3_SUPPORT_POINT true // bool\n#define SHOW_4_SUPPORT_POINT true // bool\n#define SHOW_5_SUPPORT_POINT true // bool\n#define SHOW_6_SUPPORT_POINT true // bool\n#define SHOW_7_SUPPORT_POINT true // bool\n#define SHOW_8_SUPPORT_POINT true // bool\n#define SHOW_9_SUPPORT_POINT true // bool\n#define SHOW_10_SUPPORT_POINT true // bool\n#define SHOW_11_SUPPORT_POINT true // bool\n\n#define SHOW_1_SUPPORT_LINE true // bool\n#define SHOW_2_SUPPORT_LINE true // bool\n#define SHOW_3_SUPPORT_LINE true // bool\n#define SHOW_4_SUPPORT_LINE true // bool\n#define SHOW_5_SUPPORT_LINE true // bool\n#define SHOW_6_SUPPORT_LINE true // bool\n#define SHOW_7_SUPPORT_LINE true // bool\n#define SHOW_8_SUPPORT_LINE true // bool\n#define SHOW_9_SUPPORT_LINE true // bool\n#define SHOW_10_SUPPORT_LINE true // bool\n#define SHOW_11_SUPPORT_LINE true // bool\n\n// non-changeable parameters (don't get me wrong, feel free to experiment with the entire code,\n// but you can screw something up :D )\n\n#define EDGE   0.005   // anti-aliasing\n#define SMOOTH 0.0025  // anti-aliasing \n\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\n\nconst int max_count = BEZIER_CURVE_POINTS;\nconst float radius = 20.0;\nconst float statePos = float(max_count);\n\nconst int factorials[13] = int[](\n                           1,\n                           1,\n                           2,\n                           6,\n                           24,\n                           120,\n                           720,\n                           5040,\n                           40320,\n                           362880,\n                           3628800,\n                           39916800,\n                           479001600);\n     \nconst vec3 support_lines_colors[11] = vec3[](\n                                      vec3(1.0, 0.839, 0.458),\n                                      vec3(1.0, 0.674, 0.478),\n                                      vec3(1.0, 0.658, 0.560),\n                                      vec3(1.0, 0.541, 0.788),\n                                      vec3(0.992, 0.380, 1.0),\n                                      vec3(0.788, 0.458, 1.0),\n                                      vec3(0.635, 0.541, 1.0),\n                                      vec3(0.380, 0.788, 1.0),\n                                      vec3(0.321, 1.0, 0.803),\n                                      vec3(0.807, 0.705, 0.592),\n                                      vec3(0.509, 0.482, 0.678));\n     \nconst vec3 support_points_colors[11]= vec3[](\n                                      vec3(0.992, 0.792, 0.325),\n                                      vec3(1.0, 0.639, 0.341),\n                                      vec3(1.0, 0.454, 0.301),\n                                      vec3(1.0, 0.039, 0.560),\n                                      vec3(0.807, 0.0, 0.819),\n                                      vec3(0.560, 0.0, 0.921),\n                                      vec3(0.333, 0.160, 1.0),\n                                      vec3(0.019, 0.662, 1.0),\n                                      vec3(0.0, 0.980, 0.694),\n                                      vec3(0.549, 0.443, 0.329),\n                                      vec3(0.270, 0.250, 0.392));                                       \n                                      \nconst vec3 final_dot_color = vec3(0.0,1.0,0.0);\n\nconst bool show_support_points[11] = bool[](\n                                     SHOW_1_SUPPORT_POINT,\n                                     SHOW_2_SUPPORT_POINT,\n                                     SHOW_3_SUPPORT_POINT,\n                                     SHOW_4_SUPPORT_POINT,\n                                     SHOW_5_SUPPORT_POINT,\n                                     SHOW_6_SUPPORT_POINT,\n                                     SHOW_7_SUPPORT_POINT,\n                                     SHOW_8_SUPPORT_POINT,\n                                     SHOW_9_SUPPORT_POINT,\n                                     SHOW_10_SUPPORT_POINT,\n                                     SHOW_11_SUPPORT_POINT);\n                                     \nconst bool show_support_lines[11] = bool[](\n                                    SHOW_1_SUPPORT_LINE,\n                                    SHOW_2_SUPPORT_LINE,\n                                    SHOW_3_SUPPORT_LINE,\n                                    SHOW_4_SUPPORT_LINE,\n                                    SHOW_5_SUPPORT_LINE,\n                                    SHOW_6_SUPPORT_LINE,\n                                    SHOW_7_SUPPORT_LINE,\n                                    SHOW_8_SUPPORT_LINE,\n                                    SHOW_9_SUPPORT_LINE,\n                                    SHOW_10_SUPPORT_LINE,\n                                    SHOW_11_SUPPORT_LINE);\n                                     \nint BinomialCoefficient(int n, int k) {\n    return factorials[n] / (factorials[k] * factorials[n-k]);\n}\n\nfloat DistanceToLineSegment(vec2 point, vec2 start, vec2 end) {\n    float A = point.x - start.x;\n    float B = point.y - start.y;\n    float C = end.x - start.x;\n    float D = end.y - start.y;\n\n    float dot1 = A * C + B * D;\n    float len_sq = C * C + D * D;\n    float param = -1.0;\n    if (len_sq != 0.0) {  param = dot1 / len_sq; }\n       \n    float xx, yy;\n\n    if (param < 0.0) {\n        xx = start.x;\n        yy = start.y;\n    }\n\n    else if (param > 1.0) {\n        xx = end.x;\n        yy = end.y;\n    }\n\n    else {\n        xx = start.x + param * C;\n        yy = start.y + param * D;\n    }\n\n    float dx = point.x - xx;\n    float dy = point.y - yy;\n    return sqrt(dx * dx + dy * dy);\n}\n\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v / length(g); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 act_coord = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    float aspectRatio = iResolution.x / iResolution.y;\n    act_coord.x *= aspectRatio;\n    \n    float dist;\n\n    vec2 control_points[max_count];\n    \n    vec4 state = BufA(statePos);\n    vec3 color = vec3(1.0,1.0,1.0);\n\n    for (int i = 0; i < max_count; ++i) {\n        float f = float(i);\n        if (f >= state.y) { break; }\n        \n        vec2 center = BufA(f).xy;\n        center = ((center.xy / iResolution.xy) - vec2(0.25,0.5));\n        center.x *= aspectRatio;\n\n        control_points[i] = center;\n    }\n    \n\n    float t = fract(iTime / SLOW_DOWN);\n\n    if (int(iTime / SLOW_DOWN) % 2 == 1 && BACKWARDS_ANIMATION) {\n        t = 1.0 - t;\n    }\n    \n    // draw bezier curve using de Casteljau's algorithm\n    if (SHOW_BLACK_LINE) {\n        vec2 prev_point = control_points[0];\n\n        float end_algorithm = t;\n\n        if(ALWAYS_SHOW_BEZIER_CURVE) { end_algorithm = 1.0; }\n\n        float increaser = end_algorithm / float(CASTELJAUS_STEPS);\n\n        end_algorithm += 0.001; // without it some small values of CASTELJAUS_STEPS couses ending curve before endpoint\n                                // (i don't know why)\n        \n        for (float i = 0.0; i <= end_algorithm; i += increaser) {\n            float i2 = 1.0 - i;\n            \n            vec2 point = vec2(0.0);\n            \n            for (int point_index = 0; point_index < max_count; ++point_index) {\n                point += float(BinomialCoefficient(max_count - 1, point_index)) \n                         * pow(i2, float(max_count - 1 - point_index)) \n                         * pow(i, float(point_index))\n                         * control_points[point_index];\n             }\n            \n            dist = DistanceToLineSegment(act_coord, prev_point, point) * 2.0;\n            \n            if (dist < EDGE + SMOOTH)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                color *= vec3(dist);\n            }\n            \n            prev_point = point;\n        }\n    }\n    \n    // draw control points\n    for (int i = 1; i < max_count - 1; ++i) {\n        dist = SDFCircle(act_coord, control_points[i]);\n        if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n        {\n            dist = max(dist, 0.0);\n            dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n            color *= mix(vec3(0.0,0.0, float(max_count - i) / float(max_count) ),vec3(1.0,1.0,1.0),dist);\n        }\n    }\n    \n    // draw start point\n    dist = SDFCircle(act_coord, control_points[0]);\n    if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n        \n    // draw end point\n    dist = SDFCircle(act_coord, control_points[max_count-1]);\n    if (dist < EDGE + SMOOTH && SHOW_RED_DOTS)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    // draw lines between control points\n    if (SHOW_GREY_LINES) {\n        for (int i = 0; i < max_count - 1; ++i) {\n            dist = DistanceToLineSegment(act_coord, control_points[i], control_points[i + 1]) * 2.0;\n            if (dist < EDGE + SMOOTH && SHOW_GREY_LINES)\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                color *= mix(vec3(0.8),vec3(1.0,1.0,1.0),dist);\n            }\n        }\n    }\n    \n    // draw support lines and points\n    vec2 support_points[max_count] = control_points;\n    \n    for (int i = 0; i < max_count - 1; ++i) {\n        support_points[0] = support_points[0] + t * (support_points[1] - support_points[0]);\n        \n        for (int j = 1; j < max_count - i - 1; ++j) {\n            support_points[j] = support_points[j] + t * (support_points[j+1] - support_points[j]);\n            \n            dist = DistanceToLineSegment(act_coord, support_points[j-1], support_points[j]) * 2.0;\n            if (dist < EDGE + SMOOTH && show_support_lines[i])\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n                color *= mix(support_lines_colors[i], vec3(1.0,1.0,1.0),dist);\n            }\n            \n            dist = SDFCircle(act_coord, support_points[j-1]);\n            if (dist < EDGE + SMOOTH && show_support_points[i])\n            {\n                dist = max(dist, 0.0);\n                dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n                color = mix(support_points_colors[i], vec3(1.0,1.0,1.0),dist);\n            }\n        }\n        \n        dist = SDFCircle(act_coord, support_points[max_count - i - 1]);\n        if (dist < EDGE + SMOOTH && i != 0  && show_support_points[i])\n        {\n            dist = max(dist, 0.0);\n            dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n            color = mix(support_points_colors[i-1], vec3(1.0,1.0,1.0),dist);\n        }\n    }\n    \n    vec2 point = vec2(0.0);\n    float t2 = (1.0 - t);\n            \n    for (int point_index = 0; point_index < max_count; ++point_index) {\n        point += float(BinomialCoefficient(max_count - 1, point_index)) \n                 * pow(t2, float(max_count - 1 - point_index)) \n                 * pow(t, float(point_index))\n                 * control_points[point_index];\n     }\n    \n    // draw final point\n    dist = SDFCircle(act_coord, point);\n    if (dist < EDGE + SMOOTH && SHOW_FINAL_DOT)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color = mix(final_dot_color, vec3(1.0,1.0,1.0),dist);\n    }\n    \n   \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// this code is copied from https://www.shadertoy.com/view/4dtSRn (shader by mhnewman)\n\n#define BEZIER_CURVE_POINTS 5 // int, minimum = 2, maximum = 13\n// Remember to change BEZIER_CURVE_POINTS parameter in Image too! (second tab, you can select it ot the top of this window)\n// After changing BEZIER_CURVE_POINTS peremeter reset shader's time (button on the bottom of shader window)\n\nconst int maxCount = BEZIER_CURVE_POINTS;\nconst float radius = 20.0;\n\nconst vec4 deleteRect = vec4(0.0, 0.0, 40.0, 40.0);\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nbool inRect(vec2 pos, vec4 rect) {\n    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        //\n        // Initial conditions\n        //\n        addObject(0.2 * iResolution.x, 0.2 * iResolution.y);  // start point\n        for(int i = 0; i < maxCount - 2; i++) {\n            addObject((0.1 + (float(i) / float(maxCount))) * iResolution.x,\n                      (0.8 - float(abs(i - maxCount / 2)) * 0.03) * iResolution.y); // control point\n        }\n        \n        addObject(0.8 * iResolution.x, 0.2 * iResolution.y); // end point\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / iResolution.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / iResolution.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / iResolution.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r * 5.0) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n            \tstate.x = 2.0 * statePos;\n            } else {\n    \t        state.x = state.y;\n        \t    state.y += 1.0;\n        \t}\n        }\n    } \n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6345, 6345, 6384, 6384, 6448], [6450, 6450, 6513, 6513, 7141], [7143, 7143, 7194, 7194, 7366], [7368, 7368, 7425, 7425, 13249]], "test": "untested"}
{"id": "7tfGD2", "name": "Brachistochrone", "author": "wyatt", "description": "[url]https://en.wikipedia.org/wiki/Brachistochrone_curve[/url]", "tags": ["optimization", "functional", "minimization"], "likes": 11, "viewed": 366, "published": 3, "date": "1622855400", "time_retrieved": "2024-07-30T19:17:23.775538", "image_code": "Main {\n    vec4 a = A(U);\n    Q = sin(a.zzzz);\n    Q = vec4(1,0,1,1)*smoothstep(.1,.05,abs(Q.xxxx));\n    Q = max(Q,a.w*vec4(0,.5,1,1));\n    \n    if (U.x<20.||U.y<50.||R.x-U.x<20.||R.y-U.y<50.)\n        Q *= 0.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define START  vec2(15,R.y-35.)", "buffer_a_code": "Main {\n    float h = U.y-START.y;\n    float v = sqrt(2.*abs(h));\n    Q = A(U);\n    for (int x =-3;x<=3;x++)\n    for (int y =-3;y<=3;y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        float h = U.y+u.y-START.y;\n        float uv = sqrt(2.*abs(h));\n        float dx_dt = .5*uv+.5*v;\n        vec4 a = A(U+u);\n        float dx = length(u);\n        float dt = dx/dx_dt;\n        if (abs(dx_dt)<1e-9) dt = 1e9;\n        if (a.z+dt<Q.z)\n            Q.z = a.z+dt;\n        \n        if (length(a.xy-U)<length(Q.xy-U))\n            Q.xy = a.xy;\n    }\n    float \n        n = A(Q.xy+vec2(0,1)).z,\n        e = A(Q.xy+vec2(1,0)).z,\n        s = A(Q.xy-vec2(0,1)).z,\n        w = A(Q.xy-vec2(1,0)).z;\n    vec2 g = vec2(e-w,n-s);\n    if (length(g)>0.) {\n        g = normalize(g);\n        Q.xy += 2.5*g;\n    }\n    float l = smoothstep(2.,1.,length(U-Q.xy));\n    Q.w = max(Q.w*.99,l);\n    if (length(U-START)<30.)\n        Q.xy = U+sin(100.*iTime);\n    if (iFrame < 1||U.x<3.||U.y<3.||R.x-U.x<3.||R.y-U.y<3.) {\n        Q = vec4(0);\n        Q.z = 1e9;\n    }\n    if (length(U-START)<1.) Q.z = 0.;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfGD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tX3Dj", "name": "shader-web-background aquarelle", "author": "morisil", "description": "Check mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 33, "viewed": 918, "published": 3, "date": "1622843049", "time_retrieved": "2024-07-30T19:17:24.850663", "image_code": "// Fork of \"shader-web-background JS lib\" by morisil. https://shadertoy.com/view/wlKyR1\n// 2021-06-04 21:43:06\n\n/*\n  This shader is here to spread the news about JavaScript library:\n  \n  https://xemantic.github.io/shader-web-background/\n \n  It is designed to be compatible with Shadertoy while adding more\n  integration options and saving many once-per-frame computations.\n  Even complex shaders should work on almost any hardware. I wanted\n  to build a base, which would let me use shaders as part of my\n  regular web development process, to transform my future website\n  into more immersive experiences. Check the project on mobile and\n  how it is reacting to device orientation, parallax scrolling, etc.\n  \n  Note: Mouse movement will make feedback follow the cursor.  \n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = 1. - texture(iChannel0, gl_FragCoord.xy / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .2;\nconst float iFeedbackColorShiftImpact = .004;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .35;\nconst float iBlobEdgeSmoothing        = .04;\nconst float iBlob1Radius              = .3;\nconst float iBlob1PowFactor           = 40.;\nconst float iBlob1ColorPulseSpeed     = .07;\nconst float iBlob2Radius              = .4;\nconst float iBlob2PowFactor           = 40.;\nconst float iBlob2ColorPulseSpeed     = .07;\nconst float iBlob2ColorPulseShift     = .5;\nconst float iColorShiftOfRadius       = .5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (colorShift.rg - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel0, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[778, 778, 833, 833, 910]], "test": "untested"}
{"id": "7tXGWj", "name": "Triangle Grid Learning", "author": "oneshade", "description": "Learning about how to make triangle grids. [url=https://thebookofshaders.com/11/]https://thebookofshaders.com/11/[/url]", "tags": ["grid", "triangles", "animation", "skew"], "likes": 6, "viewed": 205, "published": 3, "date": "1622835019", "time_retrieved": "2024-07-30T19:17:25.793143", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 6.0 / iResolution.y; // Approximately pixel size\n    float transition = 0.5 + 0.5 * sin(iTime);\n\n    // The grid is complete when skew=0.5 and stretch=sqrt(0.75)\n    float skew = 0.5 * transition;\n    uv.x /= mix(1.0, sqrt(0.75), transition); // Scale width to form equilateral triangles\n    uv.y += skew * uv.x; // Skew vertically\n\n    uv *= 2.0; // Zoom out to see more cells\n    uv = fract(uv); // Subdivide into a grid\n\n    float sTriId = step(0.0, uv.x - uv.y); // Upper left of the cell: 0, lower right of the cell: 1\n\n    // Cell coloring show UVs and local IDs\n    fragColor = mix(vec4(uv, 0.0, 1.0), vec4(sTriId, 0.0, 1.0 - sTriId, 1.0), transition);\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0), smoothstep(unit, 0.0, abs(uv.y - uv.x)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXGWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 892]], "test": "untested"}
{"id": "NlXGDj", "name": "Limit Cycle (Fitzhugh-Nagumo)", "author": "Ebanflo", "description": "Portrait of the Fitzhugh-Nagumo neuron model. Mouse x represents input current. Once the reset parameter nullcline is between the critical points of the voltage nullcline a Hopf bifurcation occurs, which represents the neuron firing.", "tags": ["2d", "math", "neuron"], "likes": 2, "viewed": 292, "published": 3, "date": "1622819677", "time_retrieved": "2024-07-30T19:17:26.679773", "image_code": "#define I 4.0*iMouse.x/iResolution.x - 2.0\n\n#define a 0.7\n#define b 0.8\n#define tau 12.5\n\n#define num_steps 200\n#define init vec2(-1)\n#define AA 1\n\nconst vec4 pi = vec4(1, 2, 4, 8)*atan(1.0);\n\nconst float eps = 0.3;\n\nconst bool displayNullclines = true;\n\n// probably would be a better idea to store this in a buffer or something\nvec2 curve[num_steps];\n\nfloat sigmoid(float x){return 0.5*tanh(x) + 0.5;}\n\nvec3 color(vec2 p){\n    float red = sigmoid(p.y);\n    float green = sigmoid(dot(vec2(0.707, -0.707), p));\n    float blue = sigmoid(dot(vec2(-0.707, -0.707), p));\n    float brightness = pow(length(p), 0.25);\n    return vec3(red, green, blue)*brightness;\n}\n\nvec2 forwardComp(vec2 state, mat2 weights, int t, bool n){\n    //return tanh(weights*state - bias) - state;\n    float v = state.x;\n    float w = state.y;\n    return vec2(v - 0.333*v*v*v - w + I, (v + a - b*w)/tau);\n}\n\nvec2 dCurve(vec2 p){\n    \n    float dist = 9e9;\n    float num = 0.0;\n    \n    for(int i = 0; i < num_steps - 1; i++){\n        \n        vec2 pos = p - curve[i];\n        vec2 segment = curve[i + 1] - curve[i];\n        float len = length(segment);\n        vec2 normed = segment/len;\n        vec2 ortho = vec2(normed.y, -normed.x);\n        \n        float proj1 = dot(normed, pos);\n        float d = (proj1 < len && proj1 > 0.0)\n                ? abs(dot(pos, ortho))\n                : min(length(pos), distance(pos, segment));\n        \n        if (d < dist) {\n            dist = d;\n            num = float(i);\n        }\n    }\n    return vec2(dist, num);\n}\n\nvoid eulerStep(vec2 p, mat2 weights){\n    curve[0] = p;\n    for(int i = 1; i < num_steps; i++){\n        curve[i] = curve[i - 1] + eps*forwardComp(curve[i - 1], weights, i, true);\n    }\n}\n\nvec3 render(vec2 frag, mat2 weights){\n    \n    vec2 xy = 3.0*(2.0*frag - iResolution.xy)/iResolution.y;\n    //xy *= 8.0;\n    \n    vec2 flow = forwardComp(xy, weights, 0, false);\n     \n    if(displayNullclines){\n        if(abs(flow.x) < 0.02) return vec3(0);\n        if(abs(flow.y) < 0.001) return vec3(0);\n    }\n    \n    //vec3 col = color(xy);\n    vec3 col = color(flow);\n    \n    vec2 curve = dCurve(xy);\n    float d = curve.x;\n    float n = curve.y;\n    if(d < 0.02) return col + vec3(0.6);\n    else return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy == vec2(0) ? 10.0*sin(iTime + vec2(0, pi.y))\n           : 2.0*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    //m = vec2(cos(angle*pi.w), sin(angle*pi.w));\n    #ifdef mouse\n    //m = normalize(m);\n    #endif\n    \n    float t = atan(m.y, m.x);\n    float scale = length(m);\n    vec2 trig = sin(vec2(t, t + pi.y));\n    mat2 weights = scale*mat2(trig.y, -trig.x, trig.x, trig.y);\n    \n    eulerStep(init, weights);\n    \n    fragColor = vec4(0, 0, 0, 1);\n    for(int i = 0; i < AA; i++){\n        for(int j = 0; j < AA; j++){\n            fragColor.rgb += render(fragCoord + vec2(i, j), weights);\n        }\n    }\n    fragColor.rgb /= float(AA*AA);\n    //fragColor.rgb += texture(iChannel0, fragCoord/iResolution.xy).r;\n    //fragColor.rgb = color((2.0*fragCoord - iResolution.xy)/iResolution.y);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXGDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 353, 376, 376, 402], [404, 404, 423, 423, 658], [660, 660, 718, 767, 876], [878, 878, 898, 898, 1529], [1531, 1531, 1568, 1568, 1717], [1719, 1719, 1756, 1756, 2235], [2237, 2237, 2294, 2294, 3112]], "test": "untested"}
{"id": "flf3Dj", "name": "IEEE754 & NaN", "author": "mla", "description": "Do various operations on different kinds of values produce NaNs or not?\n\nIf all 6 expressions produce NaN the image will be all white.\n\nWhat do you see?\n", "tags": ["nan", "ieee754"], "likes": 3, "viewed": 384, "published": 3, "date": "1622818507", "time_retrieved": "2024-07-30T19:17:27.547453", "image_code": "void mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0);\n  const float one1 = 1.0;\n  float one2 = 1.0;\n  float one3 = max(1.0,-iTime);\n\n  const float zero1 = 0.0;\n  float zero2 = 0.0;\n  float zero3 = max(0.0,-iTime);\n\n  // Nvidia/Linux/FF+Chrome: magenta/cyan\n  // Nvidia/Windows/Chrome/Opengl: magenta/cyan\n  // Nvidia/Windows/Chrome/D3D: magenta/black\n  // Nvidia/Windows/Edge/Opengl+D3D: magenta/black\n  // iPhone 5s: yellow/white\n  // AMD R580/Windows/Chrome+FF: magenta/black\n  // AMD 7480D/Linux/FF: white/cyan\n  // Intel/Windows/FF/D3D: magenta/black\n  // Intel/Linux/FF+Chrome: white/cyan\n  // Raspberry Pi: white/cyan\n  // Pixel 4a/Samsung A5 Chrome: white/black\n  if (uv.x < 0.0) {\n    col.r = float(isnan(zero1/zero1));\n    col.g = float(isnan(zero2/zero2));\n    col.b = float(isnan(zero3/zero3));\n  } else {\n    col.r = float(isnan(sqrt(-one1)));\n    col.g = float(isnan(sqrt(-one2)));\n    col.b = float(isnan(sqrt(-one3)));\n  }\n\n  fragColor = vec4(col,1);\n  //fragColor = vec3(col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flf3Dj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 1076]], "test": "untested"}
{"id": "Ntl3R2", "name": "Resolution Games Logo", "author": "arda", "description": "Made this logo for my job update. The code has some unused parts, I will clean them up later. Soft shadow implementation inspired by athibau’s shader.", "tags": ["raymarch"], "likes": 0, "viewed": 240, "published": 3, "date": "1622814953", "time_retrieved": "2024-07-30T19:17:28.333351", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .01\n#define DEG_TO_RAD 0.0174533\n#define ROUNDING 0.04\n#define EULER 2.71828182846\n#define PI 3.1415\n\n//Primitive SDFs\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//Operations\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat opRounding(float d,float h )\n{\n    return d - h;\n}\n\n//Transformation Matrices\n\nmat4 TMatrix(vec3 t)\n{\n    return mat4(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1);\n}\n\nmat4 SMatrix(vec3 s)\n{\n    return mat4(s.x,0,0,0,0,s.y,0,0,0,0,s.z,0,0,0,0,1);\n}\n\nmat4 RMatrix(vec3 r)\n{\n    mat4 rX = mat4(1,0,0,0,\n                   0,cos(r.x),sin(r.x),0,\n                   0,-sin(r.x),cos(r.x),0,\n                   0,0,0,1\n                  );\n    mat4 rY = mat4(cos(r.y),0,-sin(r.y),0,\n                   0,1,0,0,\n                   sin(r.y),0,cos(r.y),0,\n                   0,0,0,1\n                  );\n    mat4 rZ = mat4(cos(r.z),-sin(r.z),0,0,\n                   sin(r.z),cos(r.z),0,0,\n                   0,0,1,0,\n                   0,0,0,1\n                  );\n    return rZ*rY*rX;\n}\n\nmat4 IMatrix()\n{\n    return mat4(1,0,0,0,\n                0,1,0,0,\n                0,0,1,0,\n                0,0,0,1\n               );\n}\n\n//Input\n\nvec2 GetMousePos()\n{\n    float x = iMouse.x/iResolution.x;\n    float y = iMouse.y/iResolution.y;\n    return (vec2(x,y)-0.5)*2.0;\n}\n\n//Scene\n\nfloat SceneSDF(vec3 p)\n{\n\tvec3 s = vec3(0, 1, 0);\n    vec2 m = GetMousePos();\n    vec4 mp = vec4(p,1);\n    mp *= TMatrix(-s.xyz)*RMatrix(vec3(45,45,-90)*DEG_TO_RAD);\n    \n    float planeDist = p.y + 1.0;\n    float box1 = sdBox(mp.xyz,vec3(1.0));\n    float box3 = sdBox(mp.xyz,vec3(0.4));\n    float box5 = sdBox(mp.xyz,vec3(0.2));\n    mp *= TMatrix(vec3(-0.66,0.66,0.66));\n    float box2 = sdBox(mp.xyz,vec3(1.0));\n    float box4 = sdBox(mp.xyz,vec3(0.7));\n    \n    float LogoDist = opSubtraction(box2,box1);\n    LogoDist = opUnion(LogoDist,box3);\n    LogoDist = opSubtraction(box4,LogoDist);\n    LogoDist = opUnion(LogoDist,box5);\n    \n    //float d = min(LogoDist, planeDist);\n    float d = LogoDist;\n    return d;\n}\n\n//Raymarch\n\nfloat GetDist(vec3 p) {\n    return SceneSDF(p);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat calculateObstruction(vec3 pos, vec3 lpos, float lrad)\n{\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float d, t=lrad*0.1;\n    float obstruction=0.;\n    for(int j=0; j<16; j++)\n    {\n        d = SceneSDF(pos + t*toLight);\n        obstruction = max((-d)*distToLight/(2.0*lrad*t), obstruction);\n        if(obstruction >= 1.){break;}\n        t += max(d, lrad*t/distToLight);\n        if(t >= distToLight) break;\n    }\n    return clamp(obstruction, 0.,1.);\n}\n\nvec3 GetPointLight(vec3 p,vec3 c,vec3 pos, float r) {\n    \n    vec3 l = normalize(pos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    dif *= exp(1.0-length(pos-p)); //Light Falloff\n    if(d<length(pos-p))\n    {\n    float ob = 1.0-calculateObstruction(p,pos,r);\n    dif *= ob;\n    }\n    \n    return dif*c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,1,-6);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //Camera Anim\n    float animT = fract(iTime*0.12);\n    animT = cos((2.0*animT+1.0)*PI)*0.5+0.5;\n    float rs = 1.0/(1.0+pow(EULER,-50.0*(animT-0.2)));\n    mat4 rotAnimMx = RMatrix(vec3(0,(1.0-rs)*180.0*DEG_TO_RAD,0));\n    ro = (vec4(ro,1)*rotAnimMx).xyz;\n    rd = (vec4(rd,1)*rotAnimMx).xyz;\n    \n    //InOut\n    float et = pow(cos(animT),200.0);\n    mat4 transAnimMx = TMatrix(vec3(0,et*4.0,0));\n    ro = (vec4(ro,1)*transAnimMx).xyz;\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n        \n    col += GetPointLight(p,vec3(1.0,0.7,0.0),vec3(-3.0,3.0,-4.0),0.8)*10.0;\n    col += GetPointLight(p,vec3(1.0,0.25,0.0),vec3(4.0,1.0,-4.0),0.2)*15.0;\n    col += GetPointLight(p,vec3(1.0,0.7,0.1),vec3(0.0,4.0,-6.0),0.5)*30.0;\n    \n    col *= (1.0-et);\n            \n    col += pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntl3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 212, 212, 299], [301, 301, 346, 346, 437], [439, 439, 474, 474, 498], [500, 500, 533, 533, 598], [614, 614, 651, 651, 672], [674, 674, 717, 717, 739], [741, 741, 785, 785, 806], [809, 809, 845, 845, 865], [894, 894, 916, 916, 974], [976, 976, 998, 998, 1056], [1058, 1058, 1080, 1080, 1586], [1588, 1588, 1604, 1604, 1723], [1734, 1734, 1754, 1754, 1864], [1875, 1875, 1899, 1899, 2592], [2606, 2606, 2629, 2629, 2655], [2657, 2657, 2691, 2691, 2897], [2899, 2899, 2923, 2923, 3112], [3114, 3114, 3175, 3175, 3613], [3615, 3615, 3668, 3668, 4000], [4002, 4002, 4059, 4059, 5091]], "test": "untested"}
{"id": "7s2Sz3", "name": "Cyberfish", "author": "z0rg", "description": "I was inspired by cyberpunk2077 :)", "tags": ["lights", "cyberpunk", "zefzefafish"], "likes": 20, "viewed": 930, "published": 3, "date": "1622807302", "time_retrieved": "2024-07-30T19:17:29.718648", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 10;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 3.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*(fi/fcnt)*blur*.1;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    \t\n        \n    }\n    \n    return col/float(cnt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity =204./640.;  \n    vec3 bloomSample = doBloom(uv, 70./360., 337./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.5));\n    \n    col = col + (bloomSample*bloomIntensity);\n    \n    col = pow(col, vec3(1.2));\n    \n    col *= 1.-sat((length(cuv)-.25)*3.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27360, "src": "https://soundcloud.com/centroidband/uncharted-worlds-1", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _time;\n\nfloat smin( float a, float b, float k ) { // Thanks IQ\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(max(l.x, l.y), l.z);\n}\n\nvec2 fish(vec3 p)\n{\nvec3 op = p;\n    p*= .5;\n    p.y += sin(p.x+_time*.25)*0.15-.1;\n    p.xz *= r2d(sin(_time*2.+p.x*3.)*.3);\n    p -= vec3(0.,-.3,0.);\n    p.xy *= mix(1.,.985,sat(sin((p.x)*100.+_time*5.)*.5+.5));\n    float acc = 100.;\n    \n    acc = min(acc, length(p*vec3(1.,2.,3.))-.25);\n    acc = smin(acc, length(p*vec3(1.,2.,3.)-vec3(-0.25,.0,0.))-.17, .1);\n    \n    vec3 pail = p;\n    pail.yz *= r2d(.15*sign(pail.z*2.)*sin(_time));\n    acc = min(acc, max(abs(pail.y-.06)-0.001, (length(pail*vec3(3.,1.,1.)-vec3(.1,0.,0.))-.25)));\n    \n    \n    vec3 ptail = p*vec3(1.,sign(p.y),1.);\n    ptail -=  vec3(-.5,0.05,0.);\n    ptail.xy *= r2d(.7);\n    ptail.z -= sat(10.*-ptail.x)*sin(ptail.y*200.)*.005;\n    \n    acc = smin(acc, max(abs(ptail.z)-0.001, length(ptail*vec3(1.,2.,1.))-.125), .05);\n    vec3 peye = p-vec3(0.15,-0.03,0);\n    peye.z = abs(peye.z)-.05;\n    acc = min(acc, length(peye)-.03);\n   \n\n    return vec2(acc, 0.);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 fish = vec2(fish(p).x, 0.); \n\n    float repx = 3.;\n    vec3 pbat = p-vec3(-_time,0.,-.5);\n    pbat.x = mod(pbat.x+repx*.5, repx)-repx*.5;\n    \n    float widthCol = .1;\n    vec2 closeBat = vec2(min(_cube(pbat, vec3(widthCol,2.,widthCol)), _cube(p-vec3(0.,.5, -5.), vec3(5., .1, 4.))), 1.);\n    \n    vec2 farBat = vec2(_cube(p-vec3(0.,0.,5.), vec3(15., 5., 1.)), 2.);\n    \n    return _min(_min(closeBat, fish), farBat);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec3 getNormal(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\n\n\nvec3 _accMarch;\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 res = vec3(-1.);\n    \n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            return vec3(res.x, distance(p, ro), res.y);\n        }\n        p += rd*res.x*.15;\n        if (res.y == 0.)\n            _accMarch += .03*vec3(1.)*(1.-sat(res.x/.2));\n    }\n    \n    return res;\n}\n\nfloat mapRoom(vec3 p)\n{\n    p -= vec3(-iTime,0.,0.);\n    vec3 rep = vec3(2.,2.,5.);\n    p = mod(p+rep*.5,rep)-rep*.5;\n    \n    return min(-_cube(p, rep*.45), _cube(p-vec3(0.,.8,0.), vec3(.3,.1,1.)));\n}\nvec3 getNormalRoom(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(mapRoom(p-e.xyy), mapRoom(p-e.yxy), mapRoom(p-e.yyx)));\n}\nvec3 rdrRoom(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n    for (int i = 0; i < 20; ++i)\n    {\n    \n        float res = mapRoom(p);\n        if (res < 0.01)\n        {\n\n            \n            vec3 n = getNormalRoom(p, res);\n            \n            float dist = distance(p, ro);\n            \n            p -= vec3(-_time,0.,0.);\n            vec3 rep = vec3(2.,2.,5.);\n            vec3 id = floor((p+rep*.5)/rep);\n            p = mod(p+rep*.5,rep)-rep*.5;\n            \n            vec3 lpos = vec3(0.,-.75,1.);\n            vec3 ldir = lpos-p;\n            vec3 ambient = vec3(0.051,0.051,0.071);\n            return ambient+8.*pow(texture(iChannel1, id.xy*.1).x,5.)*mix(vec3(0.886,0.737,0.412), texture(iChannel2, id.xy*.05).xyz,.5)*sat(dot(ldir, n))*(1.-sat(length(ldir)/2.));\n        }\n        p += rd*res;\n\n    }\n    \n    return vec3(0.);\n}\n\nvec3 rdrHolo(vec2 uv)\n{\n    vec2 rep = vec2(.2);\n \n     vec2 id = floor((uv+rep*.5)/rep);\n    uv = mod(uv+rep*.5,rep)-rep*.5;\n    vec2 l = abs(uv)-rep*.25;\n    \n    vec3 rgb = vec3(0.);\n    \n    rgb = mix(rgb, vec3(0.141,0.557,1.000), sat(sin((id.x+id.y)*.1+_time))-.5);\n    rgb += vec3(1.000,0.396,0.141)*sat(sin((id.x-id.y)*1.+_time*2.)+sin(id.x));\n    \n    vec2 repid = vec2(40.,20);\n    vec2 idscreen = floor((id+repid*.5)/repid);\n    id = mod(id+repid*.5,repid)-repid*.75;\n    \n    vec2 screenl = abs(id)-repid*.4;\n    float screen = max(screenl.x, screenl.y);\n    \n    rgb *= (1.-sat(screen*400.));\n    \n    if (mod(idscreen.x+idscreen.y, 2.0) < 0.1)\n        rgb = rgb.zxy;\n    \n    return sat(rgb)*(1.-sat(max(l.x, l.y)*400.))*5.;\n}\n\nvec3 material(vec3 trace, vec3 ro, vec3 rd, vec3 p, vec3 n, vec2 uv)\n{\n    vec3 col = vec3(0.051,0.051,0.071);\n    //col = n*.5+.5;\n    if (trace.z == 2.)\n    {\n        col = p;\n        col = rdrRoom(p, normalize(rd+(texture(iChannel1, uv*4.).xxx-.5)*.1));\n        col += rdrHolo(p.xy-vec2(-_time,0.));\n    }\n    if (trace.z == 0.)\n    {\n        col += vec3(0.976,0.243,0.388)*pow(sat(dot(n, normalize(vec3(-1.)))),7.);\n        col += vec3(0.976,0.427,0.243)*(1.-pow(sat(-dot(n, rd)),2.));\n    }\n    return col;\n}\n\n\n\nvec3 rdr(vec2 uv, vec2 ouv)\n{\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(2.,0.,-3.);\n    vec3 ta = vec3(sin(_time*.5)*.1,sin(_time*.5+.5)*.1,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 300);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNormal(p, res.x);\n        //l = n*.5+.5;\n        //if (res.z == 0. || res.z == 2.)\n        {\n            col = material(res, ro, rd, p, n, uv);            \n        }\n        if (res.z == 1. || res.z == 2.)\n        {\n            vec3 reflro = p+n*0.01;\n            float spec = 0.5;\n            if (res.z == 2.)\n            {\n                float glassfreq = 20.;\n                float glassSep = .9;\n                float glassMult = 1.;\n                float normMult = .75;\n                n += normalize(n+normMult*vec3(sat((sin((p.x+_time)*glassfreq)-glassSep)*glassMult), sat((sin((p.y)*glassfreq)-glassSep)*glassMult), 0.));\n                spec = 0.1;\n                \n                float rain = texture(iChannel1, (uv*r2d(-.25)*vec2(4.,.5)+vec2(0., mod(iTime,10.)))).x;\n                col += pow(rain,15.)*vec3(800./iResolution.x);\n    \n                float rainB = texture(iChannel1, (uv*r2d(-.1)*vec2(4.,.25)*2.+vec2(0., mod(iTime*1.2,10.)))).x;\n                col += pow(rainB,7.)*vec3(800./iResolution.x);\n            }\n\n            \n            vec3 acc = vec3(0.);\n            for (int ir = 0; ir < 1; ++ir)\n            {\n                        vec3 refl = normalize(reflect(rd, n));\n                vec3 resrefl = trace(reflro, normalize(refl+(texture(iChannel1, vec2(float(ir)*0.1,float(ir)*.2)+uv*20.+mod(_time*0.1,100.)).xxx-.5)*spec), 256);\n                if (resrefl.y > 0.)\n                {\n                    vec3 reflp = reflro+refl*resrefl.y;\n                    vec3 refln = getNormal(reflp, resrefl.x);\n                    acc += .15* material(resrefl, reflro, refl, reflp, refln, uv);\n                    acc += dFdx(acc)*.5;\n                    acc += dFdy(acc)*.5;\n    \n                }\n                acc += .5*pow(texture(iChannel0, refl).xyz,vec3(1.))*.5+vec3(0.024,0.094,0.118)*.3;\n\n            }\n            col += acc;\n        }\n    }\n    col += _accMarch*vec3(0.976,0.243,0.388);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _time = iTime+texture(iChannel3, fragCoord/8.).x*.075;\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv, fragCoord/iResolution.xy);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define nsat(a) clamp(a, -1., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\n", "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 rdrWaterDroplets(vec2 ouv, vec2 cuv)\n{\n    vec3 col = texture(iChannel0, ouv).xyz;\n    float mapA = -.5+(texture(iChannel1, cuv*.2+vec2(0., iTime*.005)).x*texture(iChannel1, cuv*.3).x);\n    mapA = pow(mapA, .5);\n    col = mapA*vec3(1.);\n    \n    vec2 off = sat(vec2(dFdx(mapA), dFdy(mapA))*5.);\n    \n    col = mix(texture(iChannel0, ouv).xyz, texture(iChannel0, (ouv-off)).xyz, (1.-sat(length(off*2.))));\n    \n    return col;\n}\n\nvec3 rdr(vec2 uv, vec2 cuv)\n{\n    vec3 col = rdrWaterDroplets(uv, cuv);\n    \n    { // Not so cheap antialiasing SSAA x4\n        //col = vec3(1.,0.,0.); // debug\n        vec2 off = vec2(1., -1.)/(iResolution.x*1.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdrWaterDroplets(uv, cuv-off.xx);\n        acc += rdrWaterDroplets(uv, cuv-off.xy);\n        acc += rdrWaterDroplets(uv, cuv-off.yy);\n        acc += rdrWaterDroplets(uv, cuv-off.yx);\n        col = acc/5.;\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = rdr(uv, cuv*2.);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2Sz3.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 449, 449, 964], [967, 967, 1024, 1024, 1495]], "test": "untested"}
{"id": "NtX3Wj", "name": "water fun", "author": "zengqh", "description": "water", "tags": ["water"], "likes": 2, "viewed": 299, "published": 3, "date": "1622802639", "time_retrieved": "2024-07-30T19:17:30.637192", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y -= .5;\n    uv.y *= 2.0;\n    float reflect = 0.;\n    \n    if (uv.y < 0.)\n    {\n        uv.y += cos(uv.x * 33. - iTime * 1.6) * sin(uv.y * 96. + iTime * 1.75) * .015;\n        reflect = 1.;\n    }\n    \n    vec2 st = vec2(uv.x, abs(uv.y));\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, st).xyz;\n    \n    if (reflect > 0.)\n    {\n        //col *= vec3(.5,.6,.5);\n        //col += vec3(0., .3, 0.4);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3Wj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 638]], "test": "untested"}
{"id": "7llGDB", "name": "SDF autovoxelizer", "author": "toomuchvoltage", "description": "SDF autovoxelizer... the more granular the faster!", "tags": ["sdf", "distance", "field", "signed", "voxelizer", "autovoxelizer"], "likes": 15, "viewed": 652, "published": 3, "date": "1622790026", "time_retrieved": "2024-07-30T19:17:31.502877", "image_code": "/***********************************************************\n\n   SDF autovoxelizer.\n   If you know a faster way, please comment.\n\n   Covered under the MIT license:\n\n   Copyright (c) 2021 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n\n#define DRAW_DISTANCE 100.0\n#define M_PI 3.1415926535\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sceneMetaballs (vec3 p)\n{\n    float curTime = iTime * 3.0;\n    vec3 p1 = vec3(sin(curTime * 0.95 + 11.0), sin(curTime * 0.87 + 9.0), cos(curTime * 0.95 - 7.0)) * 0.5;\n    vec3 p2 = vec3(sin(curTime * 1.24 + 2.0), sin(curTime * 1.37 - 8.0), cos(curTime * 1.17 + 6.0)) * 0.5;\n    vec3 p3 = vec3(sin(curTime * 1.04 - 3.0), sin(curTime * 1.05 + 3.0), cos(curTime * 1.41 + 3.0)) * 0.5;\n    float sp1 = length(p + p1) - 0.5;\n    float sp2 = length(p + p2) - 0.5;\n    float sp3 = length(p + p3) - 0.5;\n    return opSmoothUnion (opSmoothUnion(sp1, sp2, 0.7), sp3, 0.7);\n}\n\n// Larval by Paul Malin: https://www.shadertoy.com/view/ldB3Rz\n\n// mat3 from quaternion\nmat3 SetRot( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n// mat3 from axis / angle\nmat3 SetRot( vec3 vAxis, float fAngle )\n{\t\n\treturn SetRot( vec4(normalize(vAxis) * sin(fAngle), cos(fAngle)) );\n}\n\nmat3 m;\nfloat sceneKIFS( in vec3 vPos )\n{\n    vPos /= 0.1;\n    const float fScale=1.25;\n    const vec3 vOffset = vec3(-1.0,-2.0,-0.2);\t\n\t\n\tfloat fTotalScale = 1.0;\n\tfor(int i=0; i<16; i++)\n\t{\t\n\t\tvPos.xyz = abs(vPos.xyz);\n\t\tvPos *= fScale;\n\t\tfTotalScale *= fScale;\n\t\tvPos += vOffset;\n\t\tvPos.xyz = (vPos.xyz) * m;\n\t\t\n\t\tfloat fCurrDist = length(vPos.xyz) * fTotalScale;\n\t}\n\n\tfloat l = length(vPos.xyz) / fTotalScale;\n\t\n\tfloat fDist = l - 0.1;\n\treturn fDist * 0.1;\n}\n\nfloat sdBox( vec3 p, float b )\n{\n    vec3 q = abs(p) - vec3 (b);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Switch below to sceneKIFS(x) for KIFS!\n#define scene(x) sceneMetaballs(x)\n#define edgeLen 0.025\n\nfloat voxelizeScene (vec3 p)\n{\n    float halo = scene(p) - edgeLen * 1.732;\n    if ( halo >= 0.001 )\n    {\n        return halo;\n    }\n    else\n    {\n        vec3 tmpI;\n        modf(p / edgeLen, tmpI);\n        vec3 descP = (tmpI) * edgeLen;\n\n        float retdist = edgeLen;\n        for (int i = -1; i != 2; i++)\n            for (int j = -1; j != 2; j++)\n                for (int k = -1; k != 2; k++)\n                {\n                    descP = (tmpI + vec3(i,j,k)) * edgeLen;\n                    float sceneEval = scene(descP);\n                    if ( sceneEval < 0.0 ) retdist = min(sdBox(p - descP, edgeLen), retdist);\n                }\n        return retdist;\n    }\n}\n\nbool sphereMarchScene(vec3 startPt, vec3 dir, out vec3 hitPt, out vec3 hitNorm)\n{\n    float i = 0.0;\n    vec3 samplePt = startPt;\n    for (i = 0.0; i != 120.0; i += 1.0)\n    {\n        float curDist = voxelizeScene (samplePt);\n        if ( curDist < 0.001 )\n        {\n            hitNorm.x = voxelizeScene(samplePt + vec3(0.001, 0.0, 0.0)) - voxelizeScene(samplePt - vec3(0.001, 0.0, 0.0));\n            hitNorm.y = voxelizeScene(samplePt + vec3(0.0, 0.001, 0.0)) - voxelizeScene(samplePt - vec3(0.0, 0.001, 0.0));\n            hitNorm.z = voxelizeScene(samplePt + vec3(0.0, 0.0, 0.001)) - voxelizeScene(samplePt - vec3(0.0, 0.0, 0.001));\n            hitNorm = normalize (hitNorm);\n            hitPt = samplePt;\n            return true;\n        }\n        samplePt += curDist * dir;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    m = SetRot( vec3(0.1, 1.0, 0.01), iTime * 0.3 );\n\n    vec2 uvRaw = fragCoord/iResolution.xy;\n    vec2 uv = uvRaw * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec4 mouseInfo = iMouse / iResolution.xxxx;\n    \n    vec3 curEye = vec3 (cos(mouseInfo.x * 6.0 - M_PI * 0.5), mouseInfo.y * 6.0 - M_PI * 0.5, sin(mouseInfo.x * 6.0 - M_PI * 0.5)) * 3.0;\n    vec3 sampleLook = normalize (-curEye);\n    \n    vec3 side = cross (vec3 (0.0, -1.0, 0.0), sampleLook);\n    vec3 up = cross (side, sampleLook);\n    if ( dot (up, vec3 (0.0, 1.0, 0.0)) < 0.0 ) up = -up;\n    \n    vec3 sampleDir = normalize (sampleLook + side * uv.x + up * uv.y);\n    vec3 samplePt = curEye + sampleDir;\n\n    samplePt = curEye + sampleDir;\n    bool samplingLight = false;\n    vec3 hitNorm, hitPoint;\n    vec3 colorAccum = vec3 (0.0);\n\n    if ( sphereMarchScene (samplePt, sampleDir, hitPoint, hitNorm) )\n        fragColor = vec4 (abs(dot(sampleDir,hitNorm)));\n    else\n        fragColor = texture(iChannel0, sampleDir);\n    \n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llGDB.jpg", "access": "api", "license": "mit", "functions": [[1572, 1572, 1624, 1624, 1723], [1725, 1725, 1756, 1756, 2294], [2813, 2839, 2880, 2880, 2952], [2962, 2962, 2995, 2995, 3416], [3418, 3418, 3450, 3450, 3548], [3650, 3650, 3680, 3680, 4323], [4325, 4325, 4406, 4406, 5129], [5131, 5131, 5188, 5188, 6198]], "test": "untested"}
{"id": "7ll3WB", "name": "Binomial Square Root", "author": "oneshade", "description": "The binomial theorem works for square roots too! It expands out into an infinite series (only 15 terms are computed here though). Demoing sqrt(1 - x^2). Series is in red, \"exact\" is in blue. I think I made a bug when I optimized the factorials...", "tags": ["square", "root", "binomial", "infiniteseries"], "likes": 3, "viewed": 155, "published": 3, "date": "1622778127", "time_retrieved": "2024-07-30T19:17:32.298749", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// Infinite series (binomial expansion) of (a+b)^0.5\n// Lots of optimizations and now it looks very obfuscated\n// It seems bugged too, for a=1 and b=(+/-)x^2 it gives the same result\nfloat SqrtSum(in float a, in float b) {\n    float res = 0.0, f = 1.0, m = 1.0;\n    for (float k=0.0; k < 15.0; k++) {\n        float h = 0.5 - k, ff = f;\n        for (float x=1.0; x <= k; x++) { ff *= k + x; }\n        float coeff = ff / (2.0 * m * h * f * f);\n        res += coeff * pow(a, h) * pow(b, k);\n        f *= k + 1.0;\n        m *= 4.0;\n    }\n\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    if (mod(iTime, 2.0) < 1.0) {\n        // Series\n        vec2 y = vec2(SqrtSum(1.0, -uv.x * uv.x), 0.0);\n        y.y = (SqrtSum(1.0, -((uv.x + 0.002) * uv.x + 0.000001)) - y.x) / 0.001; // Numerical derivative\n        if (abs(uv.x) < 1.0) draw(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.02, vec3(0.8, 0.0, 0.0));\n    }\n\n    else {\n        // \"Exact\"\n        vec2 y = vec2(sqrt(1.0 - uv.x * uv.x), 0.0);\n        y.y = -uv.x / y.x; // Exact derivative\n        if (abs(uv.x) < 1.0) draw(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.02, vec3(0.0, 0.0, 0.8));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ll3WB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 251, 290, 290, 620], [622, 622, 677, 677, 1664]], "test": "untested"}
{"id": "ftX3DS", "name": "Circle demo1", "author": "sean1998", "description": "show circle", "tags": ["2d", "circle"], "likes": 1, "viewed": 212, "published": 3, "date": "1622769917", "time_retrieved": "2024-07-30T19:17:33.117560", "image_code": "float circle(in vec2 uv, vec2 center, in float radius){\n    vec2 dist = uv - center;\n\treturn 1.-smoothstep(radius-(radius*0.01), radius+(radius*0.01), dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //scale up\n    uv = uv * 20.0 - 10.0;    \n    float f = fract(length(uv));\n    vec3 col = vec3(f, sin(f + iTime), cos(f + iTime));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftX3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 173], [175, 175, 232, 282, 514]], "test": "untested"}
{"id": "stl3DS", "name": "Continuous Factorial Approx. I", "author": "oneshade", "description": "[url=https://en.wikipedia.org/wiki/Stirling%27s_approximation]https://en.wikipedia.org/wiki/Stirling%27s_approximation[/url] (calculator suitable version)", "tags": ["approximation", "gamma", "continuous", "factorial", "specialfunction"], "likes": 8, "viewed": 209, "published": 3, "date": "1622767857", "time_retrieved": "2024-07-30T19:17:33.920413", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// Autodiff utilities\nvec2 fMul(in vec2 a, in vec2 b) { return vec2(a.x * b.x, a.x * b.y + a.y * b.x); }\nvec2 fInv(in vec2 z) { float q = 1.0 / z.x; return vec2(q, -z.y * q / z.x); }\nvec2 fPow(in vec2 a, in vec2 b) { float q = pow(a.x, b.x); return vec2(q, q * (b.x * a.y / a.x + b.y * log(a.x))); }\nvec2 fIntPow(in vec2 z, in int power) { float res = 1.0; for (int n=0; n < abs(power); n++) { res *= z.x; } if (power < 0) res = 1.0 / res; return vec2(res, float(power) * res / z.x * z.y); }\nvec2 fSqrt(in vec2 z) { float q = sqrt(z.x); return vec2(q, 0.5 * z.y / q); }\nvec2 fSinh(in vec2 z) { return vec2(sinh(z.x), cosh(z.x) * z.y); }\n\n// Constants\n#define TAU 6.2831853071\n#define E_INV 0.36787944117\n\nfloat factorial(in float x) {\n    x += 1.0;\n    return sqrt(TAU / x) * pow(E_INV * x * sqrt(x * sinh(1.0 / x) + 1.0 / (810.0 * x * x * x * x * x * x)), x);\n}\n\n// Autodifferentiated version\nvec2 factorial(in vec2 x) {\n    x.x += 1.0;\n    return fMul(fSqrt(TAU * fInv(x)), fPow(fMul(E_INV * x, fSqrt(fMul(x, fSinh(fInv(x))) + fInv(810.0 * fIntPow(x, 6)))), x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Draw the function\n    vec2 y = factorial(vec2(uv.x, 1.0));\n    draw(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.02, vec3(0.6, 0.0, 0.8));\n\n    // Draw continuous Pascal's triangle\n    //float n = uv.x + 8.0;\n    //float k = uv.y + 4.0;\n    //float binCoeff = round(gamma(n) / (gamma(k) * gamma(n - k))); // Rounding is affordable since I'm only wanting integers\n    //color = vec3(binCoeff * 0.01);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stl3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 90, 123, 123, 172], [173, 173, 195, 195, 250], [251, 251, 284, 284, 367], [368, 368, 407, 407, 559], [560, 560, 583, 583, 637], [638, 638, 661, 661, 704], [773, 773, 802, 802, 930], [932, 962, 989, 989, 1134], [1136, 1136, 1191, 1191, 2021]], "test": "untested"}
{"id": "stl3WS", "name": "A lil tune (GPU music)", "author": "Plento", "description": "Very bored today, spent too long on this. Its super messy but I wanna get better at it! Maybe I'll check out midi next? ", "tags": ["2d", "sound", "gpusound"], "likes": 19, "viewed": 462, "published": 3, "date": "1622763949", "time_retrieved": "2024-07-30T19:17:34.682376", "image_code": "\n// Cole Peterson\n\n\n// I really want to get better at audio programming because its rly fun!\n// This code is rllyy messyy\n \n// Also, changing the bpm will break everything.\n\n#define scl 27.\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv2 = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 uv = u / R;\n    \n    if(cos(iTime*.8) > 0.9){\n        uv.x -= 0.5;\n        uv.x = -abs(uv.x);\n    }\n    \n    if(-cos(iTime*.5) > 0.){\n        uv -= .5;\n        uv *= (1. + cos(cBeat(iTime*4.))*.6);\n        uv += .5;\n    }\n    \n    if(-sin(iTime*.6) > 0.3){\n        uv -= .5;\n        uv *= rot(cos(cBeat(iTime*2.))*.4);\n        uv += .5;\n    }\n    \n    vec2 id = floor(uv * scl);\n    \n    if(-sin(iTime*.7) > 0.7){\n        uv.x += iTime*0.2 * sign(mod(id.y, 2.) - 1.);\n    }\n    \n    id = floor(uv * scl);\n    vec2 id2 = floor(uv * scl*4.);\n    vec2 ruv = fract(uv * scl);\n    \n    vec3 col = vec3(0.0);\n    \n    float tt = 33.*(id.x*14. + id.y*22.);\n    \n    col += .4 + .4*cos(vec3(.8, .2, 1.2)*tt);\n    \n    vec2 rnd = hash22(id*333. + cBeat(iTime*2.));\n    \n    vec2 rnd2 = hash22(id2*633. + cQuarter(iTime));\n    \n    if(iTime < 1.8)\n        rnd.x = 0.;\n    \n    if(rnd2.x < .3){\n        col += 0.2;\n    }\n    \n    if(rnd.x < .7){\n        col *= 0.;\n    }\n    \n    col += .3*max(1. - iTime*.7, 0.);\n    \n    col = mix(col, vec3(.25), step(.83, abs(uv2.x)));\n    col = mix(col, vec3(.2), step(.46, abs(uv2.y)));\n    \n    f = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "#define R iResolution.xy\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n\n\n// Constants\nconst float pi = 3.1415;\nconst float BPM = 60.0;\n\nconst float bd = BPM / 60.;\nconst float qd = bd / 4.;\n\n\n\n\n\n// Timing\nfloat beat(float t){\n    return mod(t, 60. / BPM);\n}\n\nfloat beat_id(float t){\n    return mod(floor(BPM*t / 60.), 4.);\n}\n\nfloat cBeat(float t){\n   return floor(BPM*t / 60.);\n}\n\n\nfloat quarter(float t){\n    return mod(BPM*t / 60., .25);\n}\n\nfloat quarter_id(float t){\n    return mod(floor(4. * BPM*t / 60.), 4.);\n}\n\nfloat cQuarter(float t){\n   return floor(4.*BPM*t / 60.);\n}\n\nfloat bar(float t){\n    return mod(t, 2. * (60. / BPM));\n}\n\nfloat cBar(float t){\n    return floor(8.*BPM*t / 60.);\n}\n\n\n// Note stuff\nconst float baseFreq = 110.0; // A1\nconst float d12thRootOf2 = pow(2.0, 1.0 / 12.0);\n\n\n// Get the note but also change pitch of everything sometimes for variety \nfloat note(float k, float t){\n    \n    float h = 2., wha = 0.;\n    \n    if(mod(cBeat(.5*t+bd), 2.) > 0. && cBeat(t) >= 32.){\n        h = 4.;\n        \n        wha = mod(floor(.5*BPM*(t-bd*2.) / 60.), h);\n    }\n    else{\n        wha = mod(floor(.5*BPM*(t-bd*2.) / 60.), h);\n    }\n    k += wha*3.0;\n\n    return baseFreq * pow(d12thRootOf2, k);\n}\n\n\n\n// Waveforms\nfloat sine(float t, float hz, float k){\n    return sin(hz*t*pi*2. + k);\n}\n\nfloat tri(float t, float hz, float k){\n    return (2. / pi) * asin(sin(2.*pi*t*hz + k));\n}\n\nfloat sqr(float t, float hz, float k){\n    return sign(sin(2.*pi*t*hz + k)) * 0.5;\n}\n\n\n// noise\nfloat nse(float t){\n    return fract(120.0*sin(t*1000.0));\n}\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nfloat tick(float t){\n    return nse(t*999.) * exp(-t*40.);\n}\n\n// Metronome sound\nfloat blip(float t, float hz, float k){\n    return (1. - exp(-t*40.)) * sine(t, hz, 0.0) * exp(-t * k);\n}\n\n\n\n// Utility functions\nfloat dist1(float s, float d){\n \treturn clamp(d * s, -1., 1.);   \n}\nvec2 dist2(vec2 s, float d){\n \treturn clamp(d * s, vec2(-1.0), vec2(1.0));   \n}\n\n\n\n\n\n\n\n\n\n\n", "sound_code": "\n\n// My attempt at some drum sounds\nvec2 snare(float t){\n    vec2 s = exp(-t*23.) * hash22(iSampleRate * vec2(t, t*1.423)) * 2.0 - 1.0; \n    s = dist2(s, 1.3) * .85;\n    s += .5*dist1(exp(-t*28.) * sine(t, 200., 0.), 4.2);\n    return s * 0.5;\n}\n\nvec2 kick(float t){\n    vec2 s = vec2(0);\n    s += 1.1*dist2(exp(-t*25.) * vec2(sine(t, 75., 0.)), 2.1);\n    s += .6 * exp(-t*15.) * vec2(sine(t, 70., 0.));\n    return s;\n}\n\nvec2 hat(float t){\n    vec2 s = sqrt(t*7.) * exp(-t*38.) * hash22(iSampleRate * vec2(t, t*1.423)) * 2.0 - 1.0; \n    s = dist2(s, 1.1) * .85;\n    return s * 0.7;\n}\n\n// Add sound on a quarter beat\nvec2 onQ(float t, float n, vec2 s){\n    vec2 ms = vec2(0);\n\n    if(quarter_id(t) == n){\n        ms += s;\n    }\n    return ms;\n}\n\n\n// Make song\nvec2 snd(float t){\n    vec2 ms = vec2(0);\n    \n    ms += .6*onQ(t, 0., vec2(kick(beat(t))));\n    ms += .6*onQ(t, 2., vec2(snare(beat(t - qd*2.))));\n    \n    if(beat_id(t*2.) > 1.){\n        ms += .9 * onQ(t, 1., vec2(kick(beat(t - qd))));\n    }\n    \n    if(beat_id(t) > 1. && cQuarter(t) >= 16.){\n        ms += .37*onQ(t, 2., .22*vec2(sqr(beat(t - 2.*qd), note(12., t), 0.),\n        sqr(beat(t - 2.*qd), note(12., t) + 4., 0.)));\n        \n        ms += .2*onQ(t, 2., .22*vec2(tri(beat(t - 2.*qd), note(0., t), 0.),\n        tri(beat(t - 2.*qd), note(0., t) + 4., 0.)));\n    }\n    \n    if(cQuarter(t) >= 8.){\n        ms += onQ(t, 0., .4*vec2(tri(beat(t), note(-12., t), 0.)));\n        ms += onQ(t, 0., .13*vec2(sine(beat(t), note(0., t), 0.)));\n        \n        if(beat_id(t*2.) > 1.)\n            ms += 2.6*onQ(t, 1., .1*vec2(tri(beat(t + bd), note(10., t), 0.)));\n        \n        //if(beat_id((t+bd*2.)) > 2.)\n            //ms += 2.2*onQ(t, 3., .1*vec2(tri(beat(t - qd*2.), note(12., t), 0.)));\n        \n        ms += onQ(t, 2., .3*vec2(tri(beat(t - qd*2.), note(0., t), 0.)));\n        \n        if(beat_id(t*2.) > 1.){\n            ms += .36*onQ(t, 3., vec2(tri(beat(t - 3.*qd), note(-2., t), 0.),\n            tri(beat(t - 3.*qd), note(-2., t) + 2., 0.)));\n            ms += 1.1*onQ(t, 3., vec2(blip(beat(t - qd*3.), 400., 16.)));\n        }\n        \n        ms += .43*onQ(t, 1., vec2(hat(beat(t - qd))));\n        ms += .43*onQ(t, 3., vec2(hat(beat(t - qd*3.))));\n        \n        ms += 1.3*onQ(t, 3., vec2(blip(beat(t - qd*3.), 200., 16.)));\n    }\n    return ms;\n\n}\n\nvec2 mainSound( int samp, float time ){\n    vec2 ms = snd(time);\n    \n    //return clamp(ms * 1.2, -0.95, 0.95) * .6;\n    return ms * .7;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stl3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 231, 231, 1428]], "test": "untested"}
{"id": "ftsGWB", "name": "Simple Bitfield test", "author": "grufkork", "description": "Found a post talking about generating patterns with simple mathematical functions, and thought it would be perfect to make a shader out of. Crazy how maths works...", "tags": ["bitfield"], "likes": 7, "viewed": 302, "published": 3, "date": "1622746890", "time_retrieved": "2024-07-30T19:17:35.434366", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float divisor = 9.; // Try different values here!\n    \n    int x = int(fragCoord.x / 3. + iTime * 10.);\n    int y = int(fragCoord.y / 3. + iTime * 5.);\n            \n    float a = mod(float(x ^ y), divisor);\n\n    // Output to screen\n    fragColor = vec4(vec3(a),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 330]], "test": "untested"}
{"id": "NtsGWS", "name": "Day 532", "author": "jeyko", "description": "potate", "tags": ["space", "wow", "motiongraphics", "mdtmjvm"], "likes": 24, "viewed": 538, "published": 3, "date": "1622738692", "time_retrieved": "2024-07-30T19:17:36.337950", "image_code": "\n// vhs filter forked from an old shader of mine\n// THE BLOOM ON LINE 145 is from FMS_Cat !! \n\n\n#define R (iResolution.xy)\n#define T(U) texture(iChannel0,(U)/R)\n#define Tn(U,mip) texture(iChannel0,(U),mip)\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    n += valueNoise(uv*800.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    //n = max(n, 0.);\n    \n    n = smoothstep(0.,1.,n);\n    return n;\n}\n\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 nuv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 muv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 offs = vec2(cos(iTime*0.5),sin(iTime*0.9))*0.04;\n    offs += vec2(muv)*0.1;\n    \n    uv += offs;\n    nuv += offs;\n    vec2 bentuv = nuv * (1. - smoothstep(1.,0.,dot(nuv,nuv)*0.2)*0.4);\n    \n    bentuv *= 1.7;\n    \n    \n    float df = dFdx(uv.x);\n    float amt = (dot(nuv,nuv) + 0.1)*2.*(1.04-eass((iTime)/3.,3.));\n    \n    float env = eass(iTime*1.,3.);\n    float envb = eass((iTime - 2.)*0.4,2.);\n    float envc = eass((iTime - 4.)*1.,2.);\n    float envd = eass((iTime - 9.)*1.,2.);\n    \n    \n    vec4 nA = fbm(uv*0.02 + iTime*(20.));\n    vec4 nB = fbm(vec2(1. + iTime*0.3 + sin(iTime)*0.1,uv.y*0.42));\n    vec4 nC = valueNoise(vec2( iTime,uv.y),0.5);\n    vec4 nD = valueNoise(vec2( iTime*50.,uv.y),0.5);\n    vec4 nE = fbm(vec2(uv.x*0.02,iTime));\n    vec4 nF = fbm(vec2(uv.x*1.0,mod(iTime*200.,2000.)));\n    vec4 nG = fbm(vec2(uv.x,uv.y + mod(iTime,2000.)));\n    vec4 nT = valueNoise(vec2( iTime),0.5);\n    \n    float glitch = 0.;\n    glitch += pow(nB.x,0.5)*0.005 + nB.y*0.005;\n    glitch *= 1.;\n    uv.x += glitch*0.1;\n    \n    \n    //+ float ( 0. == floor(fract(uv.y*iResolution.y/8.)*2.) ) \n    \n    float slidey = smoothstep(0.01,0.,abs(uv.y - nC.x*1.4) - 0.1 + nE.x*0.06);\n    \n    \n    slidey *= smoothstep(0.,df*(224.2 ),abs(nuv.x + R.x/R.y*0.5 - 0.01) - 0.004);\n    \n    \n    glitch += slidey*0.002;\n    uv.x += slidey*(pow(nC.y,0.01)*0.004 + 0.001);\n    \n    \n    uv.x += 0.1*pow(nB.x,2.)*smoothstep(df*(4.2 ),0.,(abs(nuv.x + R.x/R.y*0.5 - 0.01) - 0.004 )*0.2);\n    \n    uv.x += pow(nB.x,2.)*0.007;\n    \n    C += smoothstep(df*(1. + nE.y*2.2),0.,abs(uv.y  + nC.x*.02 + 0.1 - 2.*nD.y*float(nC.z>0.4)) + nE.x*0.04 - (nE.y*0.01))*(0.5*nE.y );\n    \n    \n    \n    if(nA.x*nA.z > 0.1 - 0.0009*sin(iTime) ){\n        glitch += 0.01;\n        uv += 0.02;\n    }\n    if(nB.x*nB.y > 0.1 - envc*0.10001){\n        \n        //glitch += envc*0.;\n        //uv += 0.1 + iTime;\n    }\n    \n    \n    \n    \n    \n    float mip = 0.5 + nG.x*5.;\n    \n    float iters = 130.;\n    \n    vec3 chrab = vec3(0);\n    vec2 chruv = uv;\n    vec2 dir = vec2(1.,0.);\n    amt *= 1.;\n    amt += glitch*104.4;\n    for(float i = 0.; i < iters; i++){\n        //uv.x += 0.01;\n        float slider = i/iters;\n        chrab.r += Tn(uv + amt*dir*0.004*slider,mip).r;\n        chrab.g += Tn(uv + -amt*dir*0.01*slider,mip).g;\n        chrab.b += Tn(uv + amt*dir*0.01*slider,mip).b;\n    }\n    \n    chrab /= iters;\n    vec3 bloom = vec3(0);\n      for( float x = -1.0; x < 2.5; x += 1.0 ){\n        bloom += vec3(\n          Tn( uv + vec2( x - 0.0, 0.0 ) * 7E-3, mip).x,\n          Tn( uv + vec2( x - 1.0 + sin(iTime), 0.0 ) * 7E-3,mip ).y,\n          Tn( uv + vec2( x - 4.0 - sin(iTime*4.), 0.0 ) * 7E-3, mip ).z\n        );\n      }\n    bloom/=iters;\n    \n    C.rgb += mix(chrab,bloom,0.5);\n    \n    \n    C = mix(C,vec4(1),(smoothstep(0.5,0.41,pow(nT.x,0.9)) + 0.02)*pow(smoothstep(0.6,0.,valueNoise( uv*190. + vec2(0,nA.x*30. + pow(nB.y, 0.01)*70.*nT.y) + mod(iTime*2000.,20000.),1. + 3.*nC.x).x),18. - nT.w*uv.y*17.));\n    \n    C.rgb = mix(vec3(1),C.rgb,1.);\n    \n    vec2 bentuvold = bentuv;\n    \n    float dfbentuv = dFdx(bentuv.x);\n    \n    bentuv = abs(bentuv);\n    float dedges = abs(bentuv.x) - 0.9;\n    dedges = max(dedges, bentuv.y - 0.5);\n    float edger = 0.1;\n    //dedges = max(dedges,-length(bentuv- vec2(R.x/R.y,R.y/R.y)*0.5 + edger) - edger);\n    \n   // C *= smoothstep(dfbentuv*4.,0.,);\n    C *= pow(smoothstep(0.1,0., bentuv.x - R.x/R.y*0.47),1.);\n    C *= pow(smoothstep(0.1,0., bentuv.y - R.y/R.y*0.4),1.);\n    \n    \n    C = mix(C, Tn(uv + 0.2,2.)*0.04,1.-smoothstep(dfbentuv*4.,0.,dedges));\n    \n    C *= smoothstep(1.,0.2, 0.3 + 0.2*uv.y*(0.7 + nD.x));\n    C *= pow(smoothstep(1.,0., dot(nuv*0.6,nuv)),1.);\n    \n    bentuvold -= vec2(0.3,0.1);\n    \n    C += pow(smoothstep(1.,0., length(bentuvold) - 0.),4.)*0.01*vec4(0.6,0.9,0.9,0.);\n    \n    C.xyz *= vec3(1,1,0.9);\n    \n    C = pow(max(C,0.),vec4(0.4545));\n\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sdBox(vec2 p,vec2 s){ p =abs(p) -s; return max(p.y,p.x);}", "buffer_a_code": "#define pmod(p,a) mod(p,a) - 0.5*a\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define T (iTime + sin(iTime*2.)*0.4)*0.6\n\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.003);\n    \n    \n    {\n        vec3 ro = vec3(0,0,2);\n        vec3 rd = normalize(vec3(uv,1));\n        float iters = 16.;\n        for(float i = 0.; i < iters; i++){\n            float env = mod((T*0.25 + i/iters),1.);\n            float pl = plaIntersect( ro - vec3(0,0,1. + env*2.),  rd, vec4(0,0,-1,0) );\n            vec2 p = (ro + rd*pl).xy;\n            float md = 0.1;\n            p.x += sin(i/iters*4. + T)*0.05;\n            vec2 id = floor(p/md);\n            p = pmod(p,md);\n\n            float d = length(p);\n\n            float att = smoothstep(0.,0.01,env) * smoothstep(1.,0.2,env) ;\n            //att = 1.;\n            //col = mix(col,vec3(0.1,1.,0.6),smoothstep(fwidth(d) - 0.003,0.,d - env*0.0)*att);\n            d -= 0.003;\n            float pmp = (0.5 + 0.5*sin(iTime + i/iters*0.5));\n            vec3 c = vec3(1. + pmp ,1. + 2.*pmp,0.6+ sin(id.x + cos(id.y*20.)*4.)*0.3);\n            \n            c *= max(sin(T*2. - i/iters*2.),0.);\n            col = mix(col,c,smoothstep(fwidth(pl) + 0.002,0.,d - env*0.0*att)*att);\n\n        }\n        \n    }\n\n\n    {\n        vec2 p = uv;\n        p = vec2(atan(p.y,p.x)/pi*2.,length(p));\n        float lpy = log(p.y);\n        p.y = lpy + T*1.;\n        \n        \n        vec2 op = p;\n        //float md = 0.4;\n        vec2 md = vec2(1./2.,0.8);\n        vec2 id = floor(p/md);\n        \n        p = uv;\n        p *= rot(sin(id.y + T + sin(T + id.y) + iTime*0.5)*1.9);\n        p = vec2(atan(p.y,p.x)/pi*2.,length(p));\n        \n        p.y = log(p.y) + T*1.;\n        id = floor((p-vec2(md.x*0.25,0.))/md);\n        \n        p.y += sin(id.x + iTime + sin(id.x + iTime))*0.2*max(sin(id.y),0.);\n        \n        \n        //p *= rot(sin(id.y + iTime)*0.01);\n        p = pmod(p,md);\n        \n        float d = abs(p.y);\n        d = min(d,abs(p.y));\n        //p = abs(p) + 0.01;\n        d = max(d,-length(p) + length(md.x)*0.1);\n        \n        col = mix(col, vec3(12.6,3. + sin(id.y)*0.,0.1),smoothstep(fwidth(op.y)*1.5,0.,d)*smoothstep(0.,0.02,dot(uv,uv)));\n        \n    }\n    {\n        \n        float d = 10e4;\n        //uv -= vec2(0.5,0.2);\n        float sc = 4.;\n        #define xor(a,b) min(max(a ,-(b) + 0.2),max(b,-(a)))\n        \n        float enva = iTime + sin(iTime);\n        for(float i = 0.; i < 8.; i++){\n            float env = iTime + sin(iTime + i*.3) + i*0.1;\n            vec2 p = uv * rot(env*2.)*sc;\n            float ld = sdBox(p,vec2(-0.4 + sin(env)*1. + sin(i + iTime)*0.5 ));\n            ld = abs(ld);\n            ld = max(ld,-abs(p.x) + 0.2);\n            ld = max(ld,-abs(p.y) + 0.2);\n            d = xor(d,ld);\n        }\n        //d -= 0.01;\n        col = mix(col,2.*vec3(4.,(0.5 + 0.5*sin(iTime*4.)),.5)*pow(abs(sin(enva)),0.2),smoothstep(fwidth(uv.y) + 0.01,0.,d/sc));\n    }\n\n    {\n        \n        float d = 10e4;\n        float t = iTime*4.;\n        float envc = max(sin(t + sin(t)),0.);\n        envc *= pow(envc,2.);\n        for(float i = 0.; i < 17.; i++){\n            float env = iTime + sin(iTime + i*2.3)*1.6 + i*.5;\n            vec2 p = uv * rot(env);\n            float ld = sdBox(uv,vec2(1.6 + sin(iTime)*0.,0.4 ));\n            ld = max(ld,-abs(p.x) + 0.2 + sin(env)*0.1);\n            ld = max(ld,-abs(p.y) + 0.2 + sin(env)*0.1);\n            //ld = abs(ld) - 0.4;\n            \n            d = xor(d,ld);\n        }\n        \n\n        col = mix(col,4.5-col*1.,smoothstep(fwidth(uv.y) + 0.01,0.,d)*envc);\n    }\n    vec3 oc = col.zyx;\n    //oc = vec3(1.,1.,1.)*2. - oc*vec3(1.,1.,1.)*4.4;\n    oc = vec3(1.,1.,1.)*2. - length(oc)*vec3(1.,1.,1.)*4.4;\n    \n    col = mix(col,oc,smoothstep(-0.7,-0.8,sin(iTime*1. + sin(iTime)*1.)));\n\n    col = abs(col);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 227, 227, 284], [285, 285, 318, 318, 847], [848, 848, 866, 866, 1102], [1106, 1106, 1136, 1136, 1245], [1248, 1248, 1297, 1297, 5376]], "test": "untested"}
{"id": "slXGDB", "name": "2d landscape-v-2", "author": "jorge2017a1", "description": "2d landscape-v-2", "tags": ["2dlandscapev2"], "likes": 5, "viewed": 298, "published": 3, "date": "1622729866", "time_retrieved": "2024-07-30T19:17:37.094926", "image_code": "//por jorge2017a1...jorge flores p.\n//referencia\n//https://www.shadertoy.com/view/XsG3WR......//Created by Hamneggs in 2016-01-27\n//https://www.shadertoy.com/view/wldcWr  ....//Created by TheNosiriN in 2020-12-25\n//https://www.shadertoy.com/view/ttVfWG .....//Created by Plento in 2021-03-06\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define PI 3.14\n#define roundnes 0.025\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n// Channel definitions.\n#define DATA_BUFFER iChannel0\n#define NOISE_TEX iChannel1\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\n\n// Noise stuff\nfloat rand(vec2 n){ \n\treturn fract(sin(dot(n, vec2(17.12037, 5.71713))) * 12345.6789);\n}\nfloat noise(vec2 n){\n\tvec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b + d.xx), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat fbm2(vec2 n, float t){\n\tfloat sum = 0.0, amp = 1.0;\n\tfor (int i = 0; i < 10; i++){\n        n.x += t;\n\t\tsum += noise(n) * amp;\n\t\tn += n;\n\t\tamp *= 0.5;\n\t}\n\treturn sum;\n}\n\n//https://www.shadertoy.com/view/XsG3WR\n//Lunar Lander\n//Created by Hamneggs in 2016-01-27\n/* \n    The FBM that gives rise to the terrain. (literally)\n */\nfloat fbm( in vec2 uv )\n{\n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    result += texture(NOISE_TEX, uv*8.0).r*.1250;\n    result += texture(NOISE_TEX, uv*16.).r*.0625;\n    return result * .533333; // * (1.0/1.875);\n}\n\n\nfloat distLunarSurface( in vec2 uv )\n{\n    uv.x *= .0125;\n    vec2 q = uv; q.y=0.0;\n    float f = fbm(q);\n    return uv.y - f*f*1.;\n}\n\n\nvec3 Lunar(vec2 p, vec3 col, vec3 colTierraA,vec3 colTierraB)\n{\n     float dl1=distLunarSurface(p);\n     float dl2=distLunarSurface(p-vec2(0.001,0.0125));\n     \n     col= ponerBorde2(colTierraA, col, dl2 );\n     col= ponerBorde2(colTierraB, col, dl1 );\n     \n     \n     return col;\n}\n\n\n\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat star(vec2 uv, float time, float flare)\n{\n\tfloat d = length(uv);\n    float m = (max(0.2, abs(sin(time))) * 0.02) / d;\n    \n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*flare;\n    uv *= rotate(45.0);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*0.5*flare;\n    \n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\n\n\n\nfloat hash21(vec2 p)\n{\n \tp = fract( p*vec2(123.34, 456.21) );\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec3 hash23( vec2 co )\n{\n   vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n   vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n   vec3 c = mix(a, b, 0.5);\n   return c;\n}\n\n\nfloat starFieldMin(vec2 p)\n{\n    vec3 rnd = hash23(p * iResolution.x);\n    float intensity = pow((1.+sin((iTime+27.0)*rnd.x))*.5, 7.) ;\n    return max(rnd.x * pow(rnd.y,7.) * intensity, 0.);\n\n}\n\n\n//Shader try of StarofBethlehem\nfloat starField(vec2 uv)\n{\n    vec3 col = vec3(0);\n    float colf=0.0;\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for (int x=-1; x<=1; x++){\n        for (int y=-1; y<=1; y++)\n        {\n            vec2 offset = vec2(x, y);\n            \n            float n = hash21(id + offset);\n            float size = min(0.25, fract(n*1234.567) + 0.1);\n            float star = star(gv - offset - (vec2(n, fract(n*100.0)) - 0.5), iTime*fract(n*135.246), smoothstep(.9, 1., size)*.6);\n            \n            colf += star * size;\n        }\n    }\n    \n    return colf;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 nv=uv;\n    vec2 p=uv*0.5+vec2(0.0+iTime*0.05,0.125);\n    \n    \n    // Noise for clouds and fuselage\n    float nse = fbm2(5.*vec2(uv.x, uv.y*14.5), 0.)-.5;\n    float nse2 = fbm2(nv*4., iTime*.14)-.5;\n    float nse3= fbm2(p*4., 0.14)-.5;\n    \n    vec3 cloud = vec3(nse2)*0.7;\n    \n    \n    // Bg color\n    vec3 col = mix(vec3(.7, .8, .99), vec3(.8, .8, .8), nv.y) + cloud*cloud*.5;\n     col= mix(vec3(0.125), vec3(.2, .2, .8), nv.y) + col*cloud*.5;\n     col += (starField(uv*50.0)) + starFieldMin(uv)*2.0;\n     \n     col=Lunar(p-vec2(0.0,-0.05),col,vec3(1.0),vec3(0.8,0.5,0.35) *nse3);\n     \n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[794, 794, 854, 854, 980], [982, 982, 1043, 1043, 1167], [1171, 1186, 1205, 1205, 1274], [1275, 1275, 1295, 1295, 1493], [1494, 1494, 1522, 1522, 1667], [1669, 1824, 1849, 1849, 2154], [2157, 2157, 2195, 2195, 2290], [2293, 2293, 2356, 2356, 2576], [2581, 2581, 2607, 2607, 2705], [2707, 2707, 2753, 2753, 3060], [3065, 3065, 3087, 3087, 3181], [3183, 3183, 3207, 3207, 3398], [3401, 3401, 3429, 3429, 3594], [3597, 3629, 3655, 3655, 4212], [4215, 4215, 4272, 4322, 5003]], "test": "untested"}
{"id": "7tlGzX", "name": "Geometric Polar Pattern", "author": "Shane", "description": "A simple polar pattern rendered in a faux 3D monochromatic ink sketch style.", "tags": ["2d", "repetition", "pattern", "polar", "faux"], "likes": 22, "viewed": 627, "published": 3, "date": "1622728123", "time_retrieved": "2024-07-30T19:17:37.856888", "image_code": "/*\n\n\tGeometric Polar Pattern\n\t-----------------------\n\n\tI'm sure people have seen variations on this particular faux 3D pattern all \n    over the place. Artsy folk producing tangle patterns and so forth sketch \n    these out on paper all the time. For anyone looking for a reference image,\n    I believe the pattern is referred to as an optical art (op art) bullseye.\n    \n    Anyway, here it is in 2D procedural form. Not a lot of effort went into it\n    at all, so I'm sure there'd be better ways to get the job done. In any case,\n    it works well enough and was very easy to make. In case it isn't obvious, \n    the background is partitioned into polar cells, then the stripes are rendered \n    using angular and radial coordinates. Fake shading is applied, etc, to finish \n    things off. I'll leave the shortened version to the code golfing crowd. :)\n    \n    By the way, you could render this pretty easily using 3D techniques too. I \n    might do that at some stage, just for the fun of it, unless someone else \n    feels like giving it a go. :)\n\n\n    Related examples:\n\n    // An unlisted bare bones polar coordinate example, for \n\t// anyone who's not quite sure how the polar thing works.\n    Polar Repetition - Shane\n\thttps://www.shadertoy.com/view/wdtGDM\n\n\n*/\n\n\n// Number of cells. Only intergers will work properly.\n#define CELL_NUM 10.\n\n// Monochrome or alternating color.\n#define MONOCHROME\n\n// Faux sunset styled colored lighting.\n#define COLORED_LIGHTING\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// Repeat 2x2 hash algorithm.\nvec2 hash22G(vec2 p, vec2 repScale) {\n\n    p = mod(p, repScale);\n    // Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(1, 113)));\n    return fract(vec2(2097152, 262144)*n)*2. - 1.;\n    \n    //p = fract(vec2(2097152, 262144)*n)*2. - 1.;\n    //return sin(p*6.283 + iTime*8.);\n\n}\n\n// Gradient noise: Ken Perlin came up with it, or a version of it. Either way, this is\n// based on IQ's implementation. It's a pretty simple process: Break space into squares, \n// attach random 2D vectors to each of the square's four vertices, then smoothly \n// interpolate the space between them.\nfloat gradN2D(in vec2 f, vec2 repScale){\n  \n   f *= repScale;\n    \n    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    // Set up the cubic grid.\n    // Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    // to them.\n    vec2 p = floor(f);\n    f -= p; // Fractional position within the cube.\n    \n\n    // Smoothing - for smooth interpolation. Use the last line see the difference.\n    vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    //vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. \n    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.\n    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.\n    //vec2 w = f; // No smoothing. Gives a blocky appearance.\n    \n    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    // grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    // operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22G(p + e.xx, repScale), f - e.xx), dot(hash22G(p + e.yx, repScale), f - e.yx), w.x),\n                  mix(dot(hash22G(p + e.xy, repScale), f - e.xy), dot(hash22G(p + e.yy, repScale), f - e.yy), w.x), w.y);\n    \n    // Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; // Range: [0, 1].\n}\n\n// Gradient noise fBm.\nfloat fBm(in vec2 p, vec2 repScale){\n    \n    // Four layers.\n    return gradN2D(p, repScale)*.57 + gradN2D(p, repScale*2.)*.28 + gradN2D(p, repScale*4.)*.15;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float iRes = iResolution.y;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5)/iRes;\n \n    // Falloff factor: Sometimes,  we might have to use \"fwidth(d),\" \n    // a numeric solution, or use a constant.\n    float sf = 1./iRes; \n    \n    // Scaling... Trivial in this case.\n    vec2 p = uv - vec2(-1./4., -1./16.) - vec2(cos(iTime/4.)/12., sin(iTime/3.)/16.);\n    \n     \n    // Canvas rotation.\n    p *= r2(-iTime/16.);\n    \n    // Slight noise coordinate perturbation for that sketchy look.\n    p += (vec2(gradN2D(p, vec2(40)), gradN2D(p + .36, vec2(40))) - .5)*.005;\n    \n    vec2 op = p;\n    \n    \n    // Background noise to be mixed in later.\n    float ns = fBm(p, vec2(128));\n\t\n    // Polar angle.\n    float a = atan(p.y, p.x);\n    \n    \n    // Partitioning the angle into the number of cells.\n    float ia = floor(a/6.2831853*CELL_NUM);\n \n    \n    // Variable to determine alternate cells... Only useful for even cell numbers.\n    float dir = mod(ia, 2.)<.5? -1. : 1.;\n\n    \n    // Converting square coordinates to polar ones. I.e. Angular and radial.\n    p *= r2(a);\n    // Above is equivalent to:\n    //p = vec2(p.x*cos(ia) + p.y*sin(ia), p.y*cos(ia) - p.x*sin(ia));\n    \n\n    // RENDERING  \n\n    \n    // Used for things like shading.\n    float sinFunc = sin(a*CELL_NUM/2.);\n    \n    // Radial rings.\n    const float rNum = 5.;\n    float wf = dir<0.? .1 : .05; // Ring warp factor.\n    //\n    // Cell stripes: There'd be other ways to do this, but this works well enough.\n    float ring = mod(p.x + sinFunc*length(p)*wf + .25/rNum*dir, 1./rNum) - 1./rNum/2.;\n    ring = abs(ring) - 1./rNum/4.;//*min(.65 + length(p)*.4, 1.5);\n    \n    \n    // Alternate cell shading.\n    vec3 col1 = vec3(1, .95, .9)/6., col2 = vec3(1, .95, .9);\n    //\n    // Black and white, or is it white and black? :)\n    if(dir>0.) {\n        col1 = vec3(1, .95, .9)/8.;\n        #ifdef MONOCHROME\n        col2 = vec3(1, .95, .9);\n        #else\n        col2 = mix(vec3(1, .3, .2), vec3(.3, .4, 1), p.x);\n        #endif\n    }\n\n    \n    // Rendering alternating stripes.\n    vec3 col = mix(col1, vec3(0),  (1. - smoothstep(0., sf*16., ring - .005))*.7);\n    col = mix(col, col2*1.5,  1. - smoothstep(0., sf*2., ring));\n    col = mix(col, col2,  1. - smoothstep(0., sf*2., ring + .008));\n    \n    // Tweaking.\n    col = col*.92 + .03;\n    \n    \n    // Angular shading between cells to give a fake rounded appearance.\n    col *= smoothstep(0., .25, abs(sinFunc));\n    col *= smoothstep(0., 1., abs(sinFunc))*.9 + .1;\n\n    // Polar noise.\n    vec2 pol = vec2(a/6.2831*32. - iTime/18., p.x*2.);\n    float pns = fBm(pol, vec2(32., 4));\n    pns = smoothstep(0., .05/clamp(length(p), .001, .5), pns - .49); \n    //\n    // Using the polar noise to put dark sketch noise at the cell edges and \n    // white in the centers.\n    col = mix(col, max(col - pns, 0.), 1. - smoothstep(0., 1., abs(sinFunc)));\n    col = mix(col, col + col*pns*2., 1. - smoothstep(0., .1, 1. - abs(sinFunc)));\n    \n    // More overall gradient FBM noise.\n    col *= smoothstep(0., .85, ns) + .4;\n   \n    // Extra coloring.\n    col *= vec3(1, .98, .95);\n    #ifdef COLORED_LIGHTING\n    // Colored blue and orange angular shading for the fake environmental sunset look.\n    col *= mix(vec3(.3, .6, 1), vec3(1, .5, .2), sin(a*CELL_NUM - .7))*.7 + .4;\n    #endif\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.) + .05;\n    // Colored variation.\n    //col = mix(col.xzy, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1474, 1507, 1527, 1527, 1585], [1588, 1618, 1655, 1655, 1949], [1951, 2249, 2289, 2289, 3900], [3902, 3925, 3961, 3986, 4085], [4087, 4087, 4141, 4189, 7818]], "test": "untested"}
{"id": "stX3DS", "name": "Toppling Dominoes", "author": "dr2", "description": "Dynamics of dominoes toppling (mouseable, new runs start automatically  or by clicking upper-right)", "tags": ["collision", "dynamics", "blocks", "physics"], "likes": 14, "viewed": 410, "published": 3, "date": "1622718899", "time_retrieved": "2024-07-30T19:17:38.967918", "image_code": "// \"Toppling Dominoes\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on \"Chocolate Dominoes\", with different visuals and more GPU parallelism\n// (as in \"Bouncing Sticks\")\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBox2Df (vec2 p, vec2 b);\nmat3 QtToRMat (vec4 q);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec3 blkGap, bSize, fcBlk, ltDir;\nvec2 qBlk;\nfloat tCur, dstFar, nRun;\nint idObj;\nconst float pi = 3.1415927;\n\n//#define BIG_SYS  1  // same in all shaders (or in COMMON)\n\n#if BIG_SYS\nconst ivec3 nSphObjD = ivec3 (8, 4, 2);\nconst int nObj = 112;\n#else\nconst ivec3 nSphObjD = ivec3 (5, 3, 2);\nconst int nObj = 56;\n#endif\n\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fId, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    u = (v + dn) * rd;\n    fId = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    qBlk = vec2 (dot (u.zxy, fId), dot (u.yzx, fId));\n  }\n  return vec4 (dMin, fId);\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) dMin = dn;\n  return dMin;\n}\n\nfloat ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  vec2 qBlkN;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = BlkHit (rom, rdm, bSize);\n    if (cdn4.x < dMin) {\n      dMin = cdn4.x;\n      fcBlk = cdn4.yzw;\n      qBlkN = qBlk;\n      idObj = n;\n    }\n  }\n  qBlk = qBlkN;\n  return dMin;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    dMin = min (dMin, BlkHitSh (rom, rdm, bSize));\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\nfloat Spots (vec2 q, int nSpot)\n{\n  float bSz, w;\n  bSz = 0.6 * bSize.x;\n  if (nSpot == 2 || nSpot == 3) q = Rot2D (q, 0.25 * pi);\n  else if (nSpot == 6) q = q.yx;\n  w = 1.;\n  if (nSpot == 1) w = length (q);\n  else if (nSpot == 2) w = length (abs (q) - vec2 (0.4 * bSz, 0.));\n  else if (nSpot == 3) w = length (vec2 (mod (q.x + 0.35 * bSz, 0.7 * bSz) - 0.35 * bSz, q.y));\n  else if (nSpot == 4) w = length (abs (q) - 0.4 * bSz);\n  else if (nSpot == 5) w = min (length (abs (q) - 0.4 * bSz), length (q));\n  else if (nSpot == 6) w = length (vec2 (mod (q.x + 0.26 * bSz, 0.52 * bSz) - 0.26 * bSz,\n     abs (q.y) - 0.4 * bSz));\n  return smoothstep (-0.02, 0., w - 0.2 * bSz);\n}\n\nvec3 ObjCol (vec3 rd, float sh)\n{\n  vec3 vn, col, q;\n  float rDir, sp, ep, em;\n  int ns1, ns2, n28;\n  col = HsvToRgb (vec3 (mod (float (idObj) / float (nObj) + 0.3 * (nRun - 1.), 1.), 0.9, 0.9));\n  ep = smoothstep (0., 0.2, PrBox2Df (qBlk,\n     ((abs (fcBlk.x) == 1.) ? bSize.zy : ((abs (fcBlk.y) == 1.) ? bSize.xz : bSize.yx)) - 0.2));\n  col *= 1. - 0.3 * ep;\n  rDir = sign (2. * mod (nRun, 2.) - 1.);\n  sp = 1.;\n  em = 1.;\n  if (fcBlk.z == - rDir) {\n    n28 = int (mod (float (idObj), 28.));\n    ns1 = int (0.5 * (-1. + sqrt (float (1 + 8 * n28))));\n    ns2 = n28 - ns1 * (ns1 + 1) / 2;\n    sp = Spots (vec2 (qBlk.x, qBlk.y - 0.5 * bSize.x * sign (qBlk.y)),\n       ((qBlk.y > 0.) ? ns1 : ns2));\n    col = mix (vec3 (1.), col, sp);\n    em = smoothstep (0., 0.02, 0.1 - abs (qBlk.y));\n    col *= 1. - 0.3 * em;\n  }\n  vn = fcBlk;\n  if (sp < 1. || max (ep, em) > 0.) {\n    q = vec3 (qBlk, 0.);\n    if (abs (fcBlk.x) == 1.) q = q.zxy;\n    else if (abs (fcBlk.y) == 1.) q = q.xzy;\n    vn = VaryNf (128. * q, vn, 0.2);\n  }\n  vn = QtToRMat (GetQ (idObj)) * vn;\n  col = col * (0.2 +  0.8 * sh * max (dot (vn, ltDir), 0.)) +\n     0.2 * sh * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 vn, float sh)\n{\n  vec3 col;\n  col = (mix (vec3 (0.7, 0.4, 0.2), vec3 (0.4, 0.2, 0.1), Fbm2 (ro.xz * vec2 (1., 0.15))) *\n     (0.8 + 0.2 * smoothstep (0.07, 0.15, mod (ro.x, 4.)))) * (0.2 + 0.8 * sh * max (ltDir.y, 0.));\n  col *= 0.5 + 0.5 * smoothstep (0.92, 0.96, dot (normalize (200. * ltDir - ro), ltDir));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float dstObj, sh;\n  bool isBg;\n  bSize = 0.5 * blkGap * (vec3 (nSphObjD) - 1.) + 0.4;\n  dstObj = ObjHit (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    isBg = false;\n  } else {\n    ro += ((0.5 - ro.y) / rd.y) * rd;\n    isBg = true;\n  }\n  sh = 0.6 + 0.4 * ObjHitSh (ro + 0.01 * ltDir, ltDir, 40.);\n  if (! isBg) col = ObjCol (rd, sh);\n  else col = BgCol (ro, vec3 (0., 1., 0.), sh);\n  if (isBg && rd.y < 0.) {\n    rd = reflect (rd, vec3 (0., 1., 0.));\n    ro += 0.01 * rd;\n    dstObj = ObjHit (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      col = mix (col, ObjCol (rd, 1.), 0.3);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA    0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  blkGap = stDat.yzw;\n  stDat = Loadv4 (1);\n  mPtr.xyz = stDat.xyz;\n  nRun = stDat.w;\n  dstFar = 250.;\n  az = -0.2 * pi;\n  el = -0.15 * pi;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, -0.1 * pi);\n#if BIG_SYS\n  zmFac = 5.;\n#else\n  zmFac = 9.;\n#endif\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -140.);\n  ltDir = vuMat * normalize (vec3 (-0.5, 0.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (0., 1., 1.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 256.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Toppling Dominoes\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 EulToQt (vec3 e);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n//#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst ivec3 nSphObjD = ivec3 (8, 4, 2);\nconst int nObj = 112;\n#else\nconst ivec3 nSphObjD = ivec3 (5, 3, 2);\nconst int nObj = 56;\n#endif\n\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float rOut, rDir, r, a;\n#if BIG_SYS\n  rOut = 38.;\n#else\n  rOut = 19.;\n#endif\n  rDir = sign (2. * mod (nRun, 2.) - 1.);\n  a = 0.;\n  for (int n = 0; n < nObj; n ++) {\n    r = rOut - rDir *  a;\n    if (n == mId) break;\n    a += rDir * 0.045 * pi * rOut / r;\n  }\n  rm.xz = r * sin (a + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * blkGap.x * (float (nSphObjD.x) - 1.) + 1.;\n  qm = EulToQt (vec3 (0.5 * pi, - a, 0.));\n  vm = vec3 (0.);\n  wm = vec3 (0.);\n  if (mId == 0) {\n    vm.x = rDir * 0.5 * (1. - 2. * Hashff (1.1 * todCur));\n    vm.z = rDir * (3. + 0.1 * Hashff (todCur));\n    wm.x = rDir * 2.;\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n#if BIG_SYS\n  mxStep = 20000.;\n#else\n  mxStep = 8000.;\n#endif\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (1., 1., 0.4);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Toppling Dominoes\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 EulToQt (vec3 e);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n//#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst ivec3 nSphObjD = ivec3 (8, 4, 2);\nconst int nObj = 112;\n#else\nconst ivec3 nSphObjD = ivec3 (5, 3, 2);\nconst int nObj = 56;\n#endif\n\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float rOut, rDir, r, a;\n#if BIG_SYS\n  rOut = 38.;\n#else\n  rOut = 19.;\n#endif\n  rDir = sign (2. * mod (nRun, 2.) - 1.);\n  a = 0.;\n  for (int n = 0; n < nObj; n ++) {\n    r = rOut - rDir *  a;\n    if (n == mId) break;\n    a += rDir * 0.045 * pi * rOut / r;\n  }\n  rm.xz = r * sin (a + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * blkGap.x * (float (nSphObjD.x) - 1.) + 1.;\n  qm = EulToQt (vec3 (0.5 * pi, - a, 0.));\n  vm = vec3 (0.);\n  wm = vec3 (0.);\n  if (mId == 0) {\n    vm.x = rDir * 0.5 * (1. - 2. * Hashff (1.1 * todCur));\n    vm.z = rDir * (3. + 0.1 * Hashff (todCur));\n    wm.x = rDir * 2.;\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n#if BIG_SYS\n  mxStep = 20000.;\n#else\n  mxStep = 8000.;\n#endif\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (1., 1., 0.4);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Toppling Dominoes\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 EulToQt (vec3 e);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 blkGap;\nfloat todCur, nStep, nRun, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n//#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst ivec3 nSphObjD = ivec3 (8, 4, 2);\nconst int nObj = 112;\n#else\nconst ivec3 nSphObjD = ivec3 (5, 3, 2);\nconst int nObj = 56;\n#endif\n\nconst int nSphObj = nSphObjD.x * nSphObjD.y * nSphObjD.z;\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  vec3 b;\n  b = vec3 (nSphObjD);\n  return blkGap * (floor (vec3 (mod (s, b.x), mod (s, b.x * b.y) / b.x,\n      s / (b.x * b.y))) - 0.5 * (b - 1.));\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float rOut, rDir, r, a;\n#if BIG_SYS\n  rOut = 38.;\n#else\n  rOut = 19.;\n#endif\n  rDir = sign (2. * mod (nRun, 2.) - 1.);\n  a = 0.;\n  for (int n = 0; n < nObj; n ++) {\n    r = rOut - rDir *  a;\n    if (n == mId) break;\n    a += rDir * 0.045 * pi * rOut / r;\n  }\n  rm.xz = r * sin (a + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * blkGap.x * (float (nSphObjD.x) - 1.) + 1.;\n  qm = EulToQt (vec3 (0.5 * pi, - a, 0.));\n  vm = vec3 (0.);\n  wm = vec3 (0.);\n  if (mId == 0) {\n    vm.x = rDir * 0.5 * (1. - 2. * Hashff (1.1 * todCur));\n    vm.z = rDir * (3. + 0.1 * Hashff (todCur));\n    wm.x = rDir * 2.;\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n#if BIG_SYS\n  mxStep = 20000.;\n#else\n  mxStep = 8000.;\n#endif\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    blkGap = vec3 (1., 1., 0.4);\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    blkGap = stDat.yzw;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = length (blkGap * (vec3 (nSphObjD) - 1.)) + 1.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, blkGap);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BIG_SYS  1  // same in all shaders\n", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stX3DS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1063, 1063, 1082, 1082, 1120], [1122, 1122, 1141, 1141, 1179], [1181, 1181, 1225, 1225, 1706], [1708, 1708, 1755, 1755, 2066], [2068, 2068, 2101, 2101, 2523], [2525, 2525, 2571, 2571, 2880], [2882, 2882, 2915, 2915, 3555], [3557, 3557, 3590, 3590, 4775], [4777, 4777, 4818, 4818, 5128], [5130, 5130, 5165, 5165, 5834], [5853, 5853, 5909, 5909, 7220], [7222, 7222, 7255, 7255, 7344], [7346, 7346, 7371, 7371, 7746], [7748, 7748, 7770, 7770, 7797], [7799, 7799, 7821, 7821, 7859], [7861, 7861, 7883, 7883, 7921], [7923, 7923, 7980, 7980, 8063], [8065, 8065, 8095, 8095, 8208], [8210, 8210, 8246, 8246, 8452], [8454, 8454, 8478, 8478, 8595], [8629, 8629, 8653, 8653, 8765], [8767, 8767, 8792, 8792, 8978], [8980, 8980, 9001, 9001, 9156], [9158, 9158, 9187, 9187, 9399], [9401, 9401, 9440, 9440, 9620], [9714, 9714, 9739, 9739, 9862]], "test": "untested"}
{"id": "stf3WS", "name": "Ray_baichuan", "author": "baichuan", "description": "a simple effect for Ph.D. application in Lund University", "tags": ["test"], "likes": 0, "viewed": 210, "published": 3, "date": "1622713966", "time_retrieved": "2024-07-30T19:17:39.789721", "image_code": "\n\n\nfloat Calculate_distance(vec3 point){\n\n    vec4 ball=vec4(1.,1.,5.,1.);\n    float distance_to_ball = length(point-ball.xyz)-ball.w;\n    float distance_to_plane = point.y;\n    float min_distance = min(distance_to_ball,distance_to_plane);\n    return min_distance;\n}\n\nvec3 Calculate_Normal(vec3 point){\nfloat distance_ = Calculate_distance(point);\n    vec2 disturb = vec2(.01,0.);\n    vec3 normal_point = vec3(distance_)-vec3(Calculate_distance(point-disturb.xyy),\n                                            Calculate_distance(point-disturb.yxy),\n                                            Calculate_distance(point-disturb.yyx)); \n    return normalize(normal_point);\n}\n\nfloat Raytrack(vec3 camera_center, vec3 ray_direction){\n    float distance_from_camera = 0.;\n    for(int i=0;i<100;i++){\n        vec3 point = camera_center+ray_direction*distance_from_camera;\n        float distance_to_ball = Calculate_distance(point);\n        distance_from_camera = distance_from_camera + distance_to_ball;\n        if(distance_from_camera>100.) break;\n    }\n    return distance_from_camera;\n}\n\n\nfloat Calculate_Light(vec3 point){\n    vec3 light_position = vec3(2.+4.0*sin(iTime),2.+1.0*sin(iTime),3.+3.0*cos(iTime));\n    vec3 light_to_point = normalize(light_position-point);\n    vec3 normal_point = Calculate_Normal(point);\n    float light_strength = clamp (dot(normal_point,light_to_point),0.,1.);\n    float point_to_light = Raytrack(point+normal_point*0.01*2.,light_to_point);\n    if(point_to_light<length(light_position-point)) light_strength=0.;\n    return light_strength;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    vec3 ball_center = vec3(0.,1.,0.);\n    vec3 ray_direction = normalize(vec3(uv.x,uv.y,1.));\n    float distance_from_camera = Raytrack(ball_center,ray_direction);\n    \n    vec3 point =  ball_center + distance_from_camera*ray_direction;\n    float light = Calculate_Light(point);\n\tvec3 col = vec3(light);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3WS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 40, 40, 266], [268, 268, 302, 302, 670], [672, 672, 727, 727, 1081], [1084, 1084, 1118, 1118, 1568], [1572, 1572, 1629, 1629, 2057]], "test": "untested"}
{"id": "NlX3DS", "name": "moon fun", "author": "zengqh", "description": "moon", "tags": ["moon"], "likes": 4, "viewed": 291, "published": 3, "date": "1622702787", "time_retrieved": "2024-07-30T19:17:40.823955", "image_code": "\nfloat rand(vec2 c) {\n  return fract(sin(dot(c.xy , vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat drawMoon(in vec2 p) {\n  const float r = .18;\n  float moon = smoothstep(r, r + 0.01 , dot(p, p) * 4.4 ) ;\n  vec2 lp = p - vec2(-0.05, 0.01);\n  float lightMoon = 1. - ( smoothstep(r - 0.01, r + 0.03 , dot(lp, lp) * 5.1 ) - moon );\n  return clamp(lightMoon, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n  float ratio = iResolution.y / iResolution.x;\n  vec2 uv = p;\n  uv.y *= ratio;\n\n  //bg sky\n  float lerp = smoothstep(.0, 1. , uv.y );\n  vec3 col = mix(vec3(.1, .2, .3), vec3(.1, .1, .1) , sqrt(uv.y)  );\n\n  vec2 moonPos = uv - vec2(.568, .29);\n  //bg stars\n  col.xyz += mix(vec3(0.) , sign ( vec3( clamp(rand(uv) - 0.9985, 0., 1. ) ) ) ,   clamp (sign (dot(moonPos, moonPos) - 0.05), 0., 1. ) );\n\n  vec3 moonCol = vec3(0.45, 0.3, 0.3);\n  col = mix (moonCol, col, drawMoon(moonPos ) );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlX3DS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 92], [94, 94, 121, 121, 367], [369, 369, 426, 426, 1012]], "test": "untested"}
{"id": "7llGzs", "name": "tubes v4", "author": "milkfat", "description": "Kind of a lot going on here. Lots of learning and lots of rough edges.", "tags": ["raymarching", "grid", "texture", "organic", "tubes"], "likes": 7, "viewed": 315, "published": 3, "date": "1622685460", "time_retrieved": "2024-07-30T19:17:41.930995", "image_code": "#define SCREEN_D -700.0\n#define RADIUS 500.0\n//#define NO_SHADOWS\n//#define MSAA\n//#define FAKE_NORM\n#define EXPOSURE 1.0\n\n#define MOVEMENT_SPEED 1000.0\n\n#define LIGHT vec3(5000.0+sin(iTime*.5)*100.0,000.0+cos(iTime*.4)*100.0,1000.0-iTime*MOVEMENT_SPEED-18000.0+sin(iTime*.5)*10000.0)\n//#define LIGHT vec3(0,000,-1000.0-iTime*MOVEMENT_SPEED)\n\nfloat hash(float n) {\n    return fract(n*fract(n*.133929));\n}\n\nvec2 rotate(vec2 p, float a) {    \n    return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);\n}\n\nvec2 irotate(vec2 p, float a) {\n    return rotate(p, -a);\n}\n\nvec3 iproject(vec3 p)\n{\n    p.x -= iResolution.x/2.0;\n    p.y -= iResolution.y/2.0;\n    \n    p.z -= 2000.0;\n    \n    p.x /= iResolution.x/1200.0;\n    p.y /= iResolution.y/675.0;\n    \n    p.x *= (SCREEN_D+p.z);\n    p.y *= (SCREEN_D+p.z);\n    \n    p.x /= (SCREEN_D);\n    p.y /= (SCREEN_D);\n      \n    p.z += 2000.0;\n    \n    //p.z += 1000.0;\n    //p.xy = irotate(p.xy, iTime);\n    p.z += SCREEN_D;\n    p.yz = irotate(vec2(p.y,p.z), 2.0*6.28*sin((-iMouse.y)/iResolution.y));\n    p.xz = irotate(vec2(p.x,p.z), 2.0*6.28*sin((-iMouse.x)/iResolution.x));\n    p.z -= SCREEN_D;\n    //p.z -= 1000.0;\n    p.z -= iTime*MOVEMENT_SPEED;\n    return p; \n}\n\nfloat effect_sin(float a, float cellnum) {\n    return sin(a*.001+iTime*(hash(cellnum)*2.0-1.0))*200.0;\n}\n\nfloat effect_cos(float a, float cellnum) {\n    return cos(a*.001+iTime*(hash(cellnum)*2.0-1.0))*200.0;\n}\n\n//lumpy tube crawler things\nfloat effect_thickness(float a,float cellnum) {\n    float b = sin(iTime*(hash(cellnum)-.5)*1.0+a*.0002);\n    b = b*10.0-9.0;\n    b = max(b,0.0);\n    b = b*b*b*b;\n    b = b*2.0 - 1.0;\n    return b*120.0;\n}\n\n//twisty funhouse effect\nvec3 effect_funhouse(vec3 p) {\n    p.x += sin(p.z*.0005 + iTime*1.0)*300.0;\n    p.y += cos(p.z*.0005 + iTime*1.0)*300.0;\n    return p;\n}\n\n//bulge effect around our light source (sort of unnoticeable at the moment)\nvec3 effect_bulge(vec3 p) {\n    float d = 10000.0-distance(p,LIGHT);\n    d*=.00001;\n    d = clamp(d,0.0,1.0);\n    d = smoothstep(0.0,1.0,d);\n    p.xy -= p.xy*d*.2;\n    return p;\n}\n\n//smooth union\nfloat sdf_union(float a, float b, float amount) {\n    float ab = clamp(amount - abs(a-b), 0.0, amount)/amount;\n    ab*=ab;\n    ab*=ab;\n    return min(a,b)-ab*(amount*.125);\n}\n\nfloat scene(vec3 p, vec3 p_orig) {\n\n    \n    p = effect_bulge(p);  \n    p = effect_funhouse(p);\n    \n    //find distance\n    vec3 cellnum = floor(p/4000.0);\n    \n    //vertical tubes\n    vec3 pa = vec3(mod(p.x,4000.0),p.y,mod(p.z,-4000.0)); //this is our relative position inside a cell                                      \n    vec3 aa = vec3(2000.0+effect_sin(p.y,cellnum.z+cellnum.x*10.0),p.y,-2000.0+effect_cos(p.y,cellnum.z+cellnum.x*10.0)); //this is the target position\n    float a = distance(pa,aa); //distance between us and the target\n    a += -RADIUS-effect_thickness(p.y,cellnum.z+cellnum.x*.8371); //modify thickness/radius\n    \n    //horizontal\n    vec3 pb = vec3(p.x,mod(p.y,4000.0),mod(p.z,-4000.0));\n    vec3 bb = vec3(p.x,2000.0+effect_sin(p.x,cellnum.y+cellnum.z*10.0),-2000.0+effect_cos(p.x,cellnum.y+cellnum.z*10.0)); \n    float b = distance(pb,bb);\n    b += -RADIUS-effect_thickness(p.x,cellnum.z*3.5931+cellnum.y);\n    \n    //z-axis\n    vec3 pc = vec3(mod(p.x,4000.0),mod(p.y,-4000.0),p.z);\n    vec3 cc = vec3(2000.0+effect_sin(p.z,cellnum.x+cellnum.y*10.0),-2000.0+effect_cos(p.z,cellnum.x+cellnum.y*10.0),p.z);\n    float c = distance(pc,cc);\n    c += -RADIUS-effect_thickness(p.z,cellnum.y+cellnum.x*1.037);\n    \n    //smooth union\n    const float fillet = 1200.0;\n    float ab = sdf_union(a,b,fillet);\n    float abc = sdf_union(ab,c,fillet);\n    return abc;\n    //return min(min(a,b),c);\n    \n}\n\n//march them rays\nfloat march(inout vec3 p, vec3 p_orig, vec3 ps) {\n    float dist = 1000.0;\n    for (int i = 0; i < 80; i++) {\n        dist = scene(p,p_orig);\n        if(dist<5.1)break;\n        p+=ps*max(dist*.8,5.1);\n    }\n    return dist;\n}\n\n//march back towards our light source\nfloat march_light(inout vec3 p, vec3 p_orig, vec3 ps, vec3 light, inout float min_dist) {\n    float dist = 1000.0;\n    float dist2 = 1000.0;\n    min_dist = 1000.0;\n    for (int i = 0; i < 50; i++) {\n        dist = scene(p,p_orig);\n        min_dist = min(min_dist, dist);\n        dist2 = length(p-light);\n        p+=ps*min(dist*.8, dist2);\n        if(dist < 15.1 || dist2 < 45.1)break;\n    }\n    return dist2;\n}\n\n\n//this function is one of my least favorite things\n//its purpose is to find:\n//our relative position between tubes (intersection to intersection) (0.0 - 1.0) (0.0 = at one intersection; 1.0 = at the other intersection)\nvec3 distance_from_intersect(vec3 p) {\n\n    p = effect_bulge(p);\n    p = effect_funhouse(p);\n    \n    //horizontal UV (based on the location between vertical and z-axis tubes)\n    vec3 pqa = p;\n        \n    pqa.x+=2000.0;\n    vec3 cellnuma = floor(pqa/4000.0);\n            \n    float pa = mod(pqa.x,4000.0);                                       \n    float aa = effect_sin(p.y,cellnuma.z+(cellnuma.x-1.0)*10.0);\n    float aah = effect_sin(p.z,cellnuma.x-1.0+cellnuma.y*10.0);\n    float a = abs(aa-pa);\n    float ah = abs(aah-pa);\n    a += -RADIUS-effect_thickness(p.y,cellnuma.z+(cellnuma.x-1.0)*.8371);\n    ah += -RADIUS-effect_thickness(p.z,cellnuma.y+(cellnuma.x-1.0)*1.037);\n    \n    float aa2 = effect_sin(p.y,cellnuma.z+cellnuma.x*10.0)+4000.0;\n    float aah2 = effect_sin(p.z,cellnuma.x+cellnuma.y*10.0)+4000.0;\n    float a2 = abs(aa2-pa);\n    float ah2 = abs(aah2-pa);\n    a2 += -RADIUS-effect_thickness(p.y,cellnuma.z+cellnuma.x*.8371);\n    ah2 += -RADIUS-effect_thickness(p.z,cellnuma.y+cellnuma.x*1.037);\n    a = sdf_union(a,ah,1200.0);\n    a2 = sdf_union(a2,ah2,1200.0);\n    \n    \n    //vertical UV (based on the location between horizontal and z-axis tubes)\n    vec3 pqb = p;\n        \n    pqb.y+=2000.0;\n    //pqb.x+=2000.0;\n    //pqb.z-=2000.0;\n    vec3 cellnumb = floor(pqb/4000.0);\n    \n    float pb = mod(pqb.y,4000.0);\n    float bb = effect_sin(p.x,cellnumb.y-1.0+cellnumb.z*10.0); \n    float bbh = effect_cos(p.z,cellnumb.x+(cellnumb.y-1.0)*10.0);\n    float b = abs(bb-pb);\n    float bh = abs(bbh-pb);\n    b += -RADIUS-effect_thickness(p.x,cellnumb.z*3.5931+cellnumb.y-1.0);\n    bh += -RADIUS-effect_thickness(p.z,cellnumb.y-1.0+cellnumb.x*1.037);\n    \n    \n    float bb2 = effect_sin(p.x,cellnumb.y+cellnumb.z*10.0)+4000.0; \n    float bbh2 = effect_cos(p.z,cellnumb.x+cellnumb.y*10.0)+4000.0;\n    float b2 = abs(bb2-pb);\n    float bh2 = abs(bbh2-pb);\n    b2 += -RADIUS-effect_thickness(p.x,cellnumb.z*3.5931+cellnumb.y);\n    bh2 += -RADIUS-effect_thickness(p.z,cellnumb.y+cellnumb.x*1.037);\n    b = sdf_union(b,bh,1200.0);\n    b2 = sdf_union(b2,bh2,1200.0);\n    \n    \n    //z-axis UV (based on the location between horizontal and vertical tubes)\n    vec3 pqc = p;\n        \n    pqc.z-=2000.0;\n    vec3 cellnumc = floor(pqc/4000.0);\n    \n    //z-axis\n    float pc = mod(pqc.z,4000.0);\n    float cc = effect_cos(p.x,cellnumc.y+cellnumc.z*10.0);\n    float cch = effect_cos(p.y,cellnumc.z+cellnumc.x*10.0);\n    float c = abs(cc-pc);\n    float ch = abs(cch-pc);\n    c += -RADIUS-effect_thickness(p.x,cellnumc.z*3.5931+cellnumc.y);\n    ch += -RADIUS-effect_thickness(p.y,cellnumc.z+cellnumc.x*.8371);\n    \n    float cc2 = effect_cos(p.x,cellnumc.y+(cellnumc.z-1.0)*10.0)+4000.0;\n    float cch2 = effect_cos(p.y,cellnumc.z+1.0+cellnumc.x*10.0)+4000.0;\n    float c2 = abs(cc2-pc);\n    float ch2 = abs(cch2-pc);\n    c2 += -RADIUS-effect_thickness(p.x,(cellnumc.z-1.0)*3.5931+cellnumc.y);\n    ch2 += -RADIUS-effect_thickness(p.y,cellnumc.z+1.0+cellnumc.x*.8371);\n    c = sdf_union(c,ch,1200.0);\n    c2 = sdf_union(c2,ch2,1200.0);\n    \n    return vec3(a/(a+a2),b/(b+b2),c/(c+c2));\n}\n\nvec3 cast_ray(vec2 coord) {\n\n    vec3 p = iproject(vec3(coord, 1300));\n    vec3 p_orig = p;\n    vec3 ps = normalize(iproject(vec3(coord, -1000))-p);\n    \n    float dist = march(p,p_orig,ps);\n    \n    vec3 light = LIGHT;\n    vec3 ps2 = normalize(light-p);\n    vec3 p2 = p+ps2*100.0;\n   \n    vec3 out_color = vec3(0,0,0);\n    \n    if(dist<5.1) {\n    \n        //march a few more rays to derive surface normal\n        vec3 pp;\n        pp.x = scene(vec3(p.x+10.0,p.y,p.z),p_orig);\n        pp.y = scene(vec3(p.x,p.y+10.0,p.z),p_orig);\n        pp.z = scene(vec3(p.x,p.y,p.z+10.0),p_orig);\n        vec3 norm = normalize(vec3(pp-dist));\n        \n        //the rotation angle around each axis\n        float rx = atan(norm.y,norm.z) * 1.15;\n        float ry = atan(norm.x,norm.z) * 1.15;\n        float rz = atan(norm.x,norm.y) * 1.15;\n        \n        //our relative position between tubes\n        vec3 rp = distance_from_intersect(p);\n        vec3 rpp = rp*4.0;\n        \n        //convert relative position (0.0 - 1.0 - 0.0) (0.0 = at an intersection; 1.0 = smack between intersections)\n        rp = abs(.5-rp)*2.0;\n        \n        vec3 col=vec3(0,0,0);\n        vec2 uv;\n        float thick;\n        vec3 cellnum = floor(p/4000.0);\n        \n        //apply our texture based on our relative position\n        if(rp.x < rp.y && rp.x < rp.z) {\n            //horizontal texture\n            uv = vec2(rpp.x , rx*1.0);\n            //thickness light amount (translucent effect)\n            thick = effect_thickness(p.x,cellnum.z*3.5931+cellnum.y);\n            //add light from intersecting tubes\n            thick += (1.0-(rp.y-rp.x))*max(effect_thickness(p.y,cellnum.z+cellnum.x*.8371),0.0)*2.0;\n            thick += (1.0-(rp.z-rp.x))*max(effect_thickness(p.z,cellnum.y+cellnum.x*1.037),0.0)*2.0;\n        } else if (rp.y < rp.z) {\n            //vertical texture\n            uv = vec2(rpp.y , ry*1.0);\n            thick = effect_thickness(p.y,cellnum.z+cellnum.x*.8371);\n            thick += (1.0-(rp.x-rp.y))*max(effect_thickness(p.x,cellnum.z*3.5931+cellnum.y),0.0)*2.0;\n            thick += (1.0-(rp.z-rp.y))*max(effect_thickness(p.z,cellnum.y+cellnum.x*1.037),0.0)*2.0;\n        } else  {\n            //z-axis texture\n            uv = vec2(rpp.z , rz*1.0);\n            thick = effect_thickness(p.z,cellnum.y+cellnum.x*1.037);\n            thick += (1.0-(rp.x-rp.z))*max(effect_thickness(p.x,cellnum.z*3.5931+cellnum.y),0.0)*2.0;\n            thick += (1.0-(rp.y-rp.z))*max(effect_thickness(p.y,cellnum.z+cellnum.x*.8371),0.0)*2.0;\n        }\n        \n        uv*=.5;\n        vec3 tex = texture(iChannel0, uv, -1.0).xyz;\n        \n        //normalize our thickness lighting\n        thick+=120.0;\n        thick /= 240.0;\n        thick = (thick < 1.0) ? thick * thick : thick;\n        \n        //find out how close we are to an intersection to \"share\" the thickness lighting\n        float diff = abs(tex.r-tex.g) + abs(tex.r-tex.b) + abs(tex.g-tex.b);\n        diff *= 4.0;\n        \n        if(diff > 1.0) col += tex*thick*0.5; //emissive/translucent glow\n       \n\n        vec3 l = normalize(light-p);\n        \n        #ifdef FAKE_NORM\n        //fake texture normal\n        norm.x -= (texture(iChannel0,uv).g - texture(iChannel0,vec2(uv.x,uv.y+.0003)).g)*80.0;\n        norm.y -= (texture(iChannel0,uv).g - texture(iChannel0,vec2(uv.x+.001,uv.y)).g)*80.0;\n        #endif\n        \n        float bri = clamp(dot(norm,l),0.0,1.0); //directional lighting\n        \n\n        float lbri = 100000.0-length(light-p); //distance to light\n        lbri /= 100000.0;\n        lbri = clamp(lbri,0.0,1.0);\n        lbri *= lbri;\n        \n        bri += lbri*.5; //exceedingly basic global illumination\n        bri *= lbri;\n        \n        bri += .3; //ambient light\n         \n        float dist_;\n        #ifndef NO_SHADOWS\n        float dist2 = march_light(p2,p_orig,ps2,light,dist_); //ray march back to light source\n        if(dist2 > 45.1) {\n            bri*=.7; //shadow hit//soft shadows\n        } else {\n            dist_ = clamp(dist_, 0.0, 65.0);\n            dist_ /= 65.0;\n            dist_ = 1.0 - dist_;\n            dist_ = smoothstep(0.0,1.0,dist_);\n            bri -= dist_*bri*.3;\n        }\n        #endif\n        \n        \n        out_color = col+(bri*tex);\n        \n        \n       \n    }\n    \n    return out_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord-.5;\n    vec3 col = cast_ray(coord);\n    \n    \n    #ifdef MSAA\n    col += cast_ray(vec2(coord.x+.5,coord.y));\n    col += cast_ray(vec2(coord.x,coord.y+.5));\n    col /= 3.0;\n    #endif\n    \n    fragColor = vec4(col,1.0);\n    fragColor *= EXPOSURE;\n    fragColor.r = pow(fragColor.r,2.2);\n    fragColor.g = pow(fragColor.g,2.2);\n    fragColor.b = pow(fragColor.b,2.2);\n    \n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llGzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[343, 343, 364, 364, 404], [406, 406, 436, 436, 510], [512, 512, 543, 543, 571], [573, 573, 596, 596, 1212], [1214, 1214, 1256, 1256, 1318], [1320, 1320, 1362, 1362, 1424], [1426, 1454, 1501, 1501, 1658], [1660, 1685, 1715, 1715, 1821], [1823, 1899, 1926, 1926, 2078], [2080, 2095, 2144, 2144, 2269], [2271, 2271, 2305, 2305, 3691], [3693, 3711, 3760, 3760, 3936], [3938, 3976, 4065, 4065, 4386], [4389, 4608, 4646, 4646, 7698], [7700, 7700, 7727, 7727, 11996], [11998, 11998, 12055, 12055, 12455]], "test": "untested"}
{"id": "sls3zs", "name": "Edited Audio Tunnel - nshelton", "author": "AlijahT", "description": "All Credit goes to https://www.shadertoy.com/view/lslfR7", "tags": ["dj"], "likes": 5, "viewed": 337, "published": 3, "date": "1622681049", "time_retrieved": "2024-07-30T19:17:42.864499", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 bloom = texture(iChannel0,  uv);\n    vec4 base = texture(iChannel1,  uv); \n    \n    fragColor = sqrt(bloom) + base; \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat time = 0.1;\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length( p.xz - c.xy ) - c.z;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\nvec2 map(vec3 p)\n{\n\n    vec3 q = p;\n\tp.z -= 0.1 * iTime + sin(iTime * 0.01)* 0.5;\n    vec3 c = vec3(0.53 / 4.0);\n    \n    p.z = mod(p.z,c.z)-0.5*c.z;\n         \n    vec4 noise = texture(iChannel1, floor(q.zz / 1.0));\n    \n    float freq =  atan(p.x, -p.y) / 3.1415 * 2.0 + fract(q.z) * 3.1415 * 2.0;\n    \n    float audio = texture(iChannel0, vec2((freq), 0.0)).r;\n    float audio2 = texture(iChannel0, vec2(fract(0.01*q.z), 0.0)).r;\n    \n  \tfloat r1 = 1.9 ;\n           \n    float r2 = r1 * (1.0 -  audio2);\n        \n    \n    float thickness = 0.02 * audio2;\n\n    \n    float inner = sdCappedCylinder(p.xzy , vec2(r2, 0.5));\n    float outer = sdCappedCylinder(p.xzy, vec2(r1, thickness));\n        \n    float result = opS(inner, outer);\n\n    float theta = iTime + q.z + audio2;\n    float r = 1.0;\n\tfloat ball = length(p + vec3(r * cos(theta), r * sin(theta), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);                  \n\n\tball = length(p + vec3(r * cos(-theta), r * sin(-theta), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n\tball = length(p + vec3(r * cos(theta + 3.1415), r * sin(theta + 3.1415), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n\tball = length(p + vec3(r * cos(-theta + 3.1415), r * sin(-theta + 3.1415), 0.0)) - audio2* 2.0;\n\tresult = opS(ball, result);   \n    \n    return vec2(result, audio2);\n    \n}\n\n\n// See https://iquilezles.org/articles/palettes for more information\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = iTime  ;\n  //  ro.x -= sin(iTime /5.7);\n  //  ro.y -= cos(iTime /  2.3);\n}\n\n vec3 gradient(vec3 p, float t) {\n\t\t\tvec2 e = vec2(0., t);\n\n\t\t\treturn normalize( \n\t\t\t\tvec3(\n\t\t\t\t\tmap(p+e.yxx).x - map(p-e.yxx).x,\n\t\t\t\t\tmap(p+e.xyx).x - map(p-e.xyx).x,\n\t\t\t\t\tmap(p+e.xxy).x - map(p-e.xxy).x\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n#define MAX_D 20.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime * 0.1;\n\n    vec2 _p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 noise = texture(iChannel0, _p).rg;\n\n    vec3 ray = normalize(vec3(_p + noise * 0.01, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);\n    \n    float depth = 0.0, iter = 0.0;\n    vec2 d; \n    vec3 p;\n    \n    for( int i = 0; i < 50; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d.x < 0.001 * pow(depth, 2.0)) {\n\t\t\thit = true;\n            break;\n        }\n        \n        if (depth > MAX_D)\n            break;\n                   \n\t\tdepth += d.x * 0.2; \n\t\titer++; \n    }\n    float ii = 1.0 - iter / 50.0;\n    vec3 col = vec3(ii); \n    if ( hit)\n    col *= pal(d.y, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.80,0.90,0.300));\n    \n    fragColor = vec4(sqrt(col),1.0);\n    \n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27285, "src": "https://soundcloud.com/dstroyerofficial/d-stroyer-dragostea-din-tei-free-download", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 total = vec4(0.0);\n\tvec2 delta = vec2(1.5, 0.0) / iResolution.x;\n    //const float weights[9] = float[9](0.091637,0.105358,0.1164,0.123573,0.126061,0.123573,0.1164,0.105358,0.091637);\n    const float weights[9] = float[9](1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n    \n    total += texture(iChannel0, uv - 4.0 * delta) * weights[0];\n    total += texture(iChannel0, uv - 3.0 * delta) * weights[1];\n    total += texture(iChannel0, uv - 2.0 * delta) * weights[2];\n    total += texture(iChannel0, uv - 1.0 * delta) * weights[3];\n    total += texture(iChannel0, uv - 0.0 * delta) * weights[4];\n    total += texture(iChannel0, uv + 1.0 * delta) * weights[5];\n    total += texture(iChannel0, uv + 2.0 * delta) * weights[6];\n    total += texture(iChannel0, uv + 3.0 * delta) * weights[7];\n    total += texture(iChannel0, uv + 4.0 * delta) * weights[8];\n    \n    fragColor = total/9.0;\n        \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 total = vec4(0.0);\n\tvec2 delta = vec2(0.0, 1.5) / iResolution.y;\n    //const float weights[9] = float[9](0.091637,0.105358,0.1164,0.123573,0.126061,0.123573,0.1164,0.105358,0.091637);\n    const float weights[9] = float[9](1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\n\n    \n    total += texture(iChannel0, uv - 4.0 * delta) * weights[0];\n    total += texture(iChannel0, uv - 3.0 * delta) * weights[1];\n    total += texture(iChannel0, uv - 2.0 * delta) * weights[2];\n    total += texture(iChannel0, uv - 1.0 * delta) * weights[3];\n    total += texture(iChannel0, uv - 0.0 * delta) * weights[4];\n    total += texture(iChannel0, uv + 1.0 * delta) * weights[5];\n    total += texture(iChannel0, uv + 2.0 * delta) * weights[6];\n    total += texture(iChannel0, uv + 3.0 * delta) * weights[7];\n    total += texture(iChannel0, uv + 4.0 * delta) * weights[8];\n    \n    fragColor = total/9.0;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sls3zs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 230]], "test": "untested"}
{"id": "sls3Rl", "name": "Hypno circle", "author": "avin", "description": "visual experiment", "tags": ["circle"], "likes": 3, "viewed": 302, "published": 3, "date": "1622661983", "time_retrieved": "2024-07-30T19:17:43.724201", "image_code": "#define PI 3.141592653589\n\n#define SF 1./min(iResolution.x,iResolution.y)*.5\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define tx(b) texture(iChannel0, b)\n#define snd(x) texture(iChannel0, vec2(x,.1)).r\n\n#define MOD3 vec3(.1031, .11369, .13787)\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x; \n    \n    float l = length(uv);\n    \n    float size = .15;\n    float width = .005;\n    \n    float v = SS(l,  size) * SS(size -width, l);\n    \n    // float v = (.1 / smoothstep(l, l-.1, size));\n    \n    float a = sin(atan(uv.y, uv.x)*3.);\n    \n    float sv = tx(vec2(0.5,0.75)).r;\n    float mf = abs(snoise(vec3(a*.01,a, iTime)))*.1;\n    float v2 = SS(l - mf - width,  size) * SS(size-width*2. - mf, l);\n    float v22 = SS(l - mf - width,  size); // + SS(size-width*10. - mf, l);\n    float vs = 1.025;\n    float v3 = SS(l*vs - mf - width,  size) * SS(size-width*2. - mf, l*vs);\n    \n    vec3 col = vec3(0.0 + SS(abs(fract((uv.x + uv.y)*iResolution.x*.1)-.5), .15)*.1);\n    \n    col = mix(col, vec3(.25).rgb, v2);\n    col = mix(col, vec3(.0).rgb, v3);\n    col = mix(col, vec3(.7).rgb, v22-v2);\n    col = mix(col, vec3(1.), v);            \n        \n    // vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*ouv.x*ouv.y*(1.0-ouv.x)*(1.0-ouv.y), 0.1 );\n    col = clamp(col,0.0,1.0);\n    col = col*0.6 + 0.4*col*col*(3.0-2.0*col) + vec3(0.0,0.0,0.04);\n    \n        \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sls3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 332, 332, 499], [501, 501, 523, 523, 1169], [1171, 1171, 1228, 1228, 2424]], "test": "untested"}
{"id": "7tlGzl", "name": "Fungants", "author": "WaifuFarmer", "description": "This is inspired by this video : watch?v=X-iSQQgOd1A\n\nI think I'm gonna move on to a custom software as the method I use for indexing particles creates some artifacts (I just copy pasted this principle : https://www.shadertoy.com/view/3ty3Dy )", "tags": ["fungus"], "likes": 21, "viewed": 674, "published": 3, "date": "1622659943", "time_retrieved": "2024-07-30T19:17:44.786361", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    //fragColor = vec4(pow(vec3(col.r * sin(iTime*0.28) + col.g * cos(iTime*0.27),col.g * sin(iTime*0.26) + col.b * cos(iTime*0.25),col.g * sin(iTime*0.24) + col.r * cos(iTime*0.23)), vec3(0.454545)), 1.0);\n    fragColor = vec4(col, 0.3);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ASPECT_RATIO iResolution.x / iResolution.y\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define RESET 0.00\n\n#define FRAGCOORD_HASH hash(uint(fragCoord.x * 10000. + fragCoord.y))\n#define FRAGCOORD_HASH_AND(RHS) hash(uint(mod(fragCoord.x * 10000., 4.) + mod(fragCoord.y, 4.)) + hash(uint(iFrame / 6))) & RHS\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nuint hash(uint n)\n{\n    n ^= 2747636419u;\n    n *= 2654435769u;\n    n ^= n >> 16;\n    n *= 2654435769u;\n    n ^= n >> 16;\n    n *= 2654435769u;\n    return (n);\n}\n\n/*\n    Cell(42bits -> 0x3ffffffffff) : {\n        position_x (14bits -> 0x3fff),\n        position_y (13bits -> 0x1fff),\n        direction  ( 9bits -> 0x01ff),\n        velocity   ( 6bits -> 0x003f)\n    }\n*/\n\nvoid vec4tocell3(vec4 data, out vec4 cell0, out vec4 cell1, out vec4 cell2)\n{\n    uint r = floatBitsToUint(data.r);\n    uint g = floatBitsToUint(data.g);\n    uint b = floatBitsToUint(data.b);\n    uint a = floatBitsToUint(data.a);\n    \n    float cell0_x = float(a & 0x3fffu) / float(0x3fff);\n    a >>= 14;\n    float cell0_y = float(a & 0x1fffu) / float(0x1fff);\n    a >>= 13;\n    float cell0_d = TAU * float((a & 0x001fu) + ((b & 0x000fu) << 5)) / float(0x01ff);\n    b >>= 4;\n    float cell0_v = float(b & 0x003fu) / float(0x003f);\n    b >>= 6;\n    float cell1_x = float(b & 0x3fffu) / float(0x3fff);\n    b >>= 14;\n    float cell1_y = float((b & 0x0fffu) + ((g & 0x0001u) << 12)) / float(0x1fff);\n    g >>= 1;\n    float cell1_d = TAU * float(b & 0x01ffu) / float(0x01ff);\n    g >>= 9;\n    float cell1_v = float(g & 0x003fu) / float(0x003f);\n    g >>= 6;\n    float cell2_x = float(g & 0x3fffu) / float(0x3fff);\n    g >>= 14;\n    float cell2_y = float((g & 0x0003u) + ((r & 0x007ffu) << 2)) / float(0x1fff);\n    r >>= 11;\n    float cell2_d = TAU * float(r & 0x01ffu) / float(0x01ff);\n    r >>= 9;\n    float cell2_v = float(r & 0x003fu) / float(0x003f);\n    \n    cell0 = vec4(cell0_x, cell0_y, cell0_d, cell0_v);\n    cell1 = vec4(cell1_x, cell1_y, cell1_d, cell1_v);\n    cell2 = vec4(cell2_x, cell2_y, cell2_d, cell2_v);\n}\n\n\n#define N 1. // use only 1/N % of the max Rx*Ry particles (for readability)\n\n// Buff B (1) store Voronoï tracking acceleration structure;\n//            xyzw: ids of 4 closest partics to buffer location\n// Buff A (0) stores particles: \n//            xy: position zw: velocity\n\n// --- translate particle id (in [1,Rx*Ry] ) to buffer pixel \n#define A(n) T0( vec2( (int(n)-1) % iR.x,      \\\n                       (int(n)-1) / iR.x ) +.5 )  // +.5 useless\n\n// --- utils\n                           \n#define R     iResolution.xy\n#define iR    ivec2(iResolution)\n#define T0(U) texelFetch( iChannel0, ivec2(U)   , 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U)%iR, 0 )\n#define T2(U) texelFetch( iChannel2, ivec2(U)   , 0 )\n\n#define l2(x) dot(x,x)\n\n                           \n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n                           \n// --- keyboard\n#define key(k,mode) ( texelFetch( iChannel3, ivec2(k,mode), 0 ).x > .5 )\n#define keyDown(k) key(k,0)\n#define  keyHit(k) key(k,1)\n#define keyFlip(k) key(k,2)\n\n\n// --- random numbers\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\n#define Hash(a) ( float(IHash(a)) / float(0x7FFFFFFF) ) // Uniform in [0,1]\n\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\n\n// --- normal law random generator\nvec2 randn(vec2 r){ // r: randuniform\n    r.x = sqrt( -2.* log(1e-9+abs(r.x)));\n    r.y *= TAU;\n    return r.x * vec2(cos(r.y),sin(r.y));\n}\n", "buffer_a_code": "#define MAGIC 3000\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint index = uint(fragCoord.y) * uint(iResolution.x) + uint(fragCoord.x);\n    vec2 uv = (fragCoord - 0.5) / iResolution.xy;\n    \n    //if (uint(mod(float(FRAGCOORD_HASH_AND(uint(MAGIC))), float(MAGIC))) == 0u)\n    \n    //if (iFrame <= 10 || iMouse.z > 0.5 || uint(mod(float(FRAGCOORD_HASH_AND(uint(MAGIC))), float(MAGIC))) == 0u)\n    //{\n    if (iFrame <= 10 || iMouse.z > 0.5)\n    {\n        uint size = uint(iResolution.x) * uint(iResolution.y);\n        //size = 342120u;\n        \n        uint hash_r = hash(0u * size + index + uint(iDate.w)) & 0xffffu;\n        uint hash_g = hash(1u * size + index + uint(iDate.w)) & 0xffffu;\n        float qqq = mod(fragCoord.x, iResolution.x / 3.) / (iResolution.x / 3.);\n        if (qqq < 0.2)\n        {\n            hash_r = 32768u;\n            hash_g = 32768u;\n        }\n        else if (qqq < 0.4)\n        {\n            hash_r = 16384u;\n            hash_g = 16384u;\n        }\n        else if (qqq < 0.6)\n        {\n            hash_r = 32768u+16384u;\n            hash_g = 16384u;\n        }\n        else if (qqq < 0.8)\n        {\n            hash_r = 16384u;\n            hash_g = 32768u+16384u;\n        }\n        else\n        {\n            hash_r = 32768u+16384u;\n            hash_g = 32768u+16384u;\n        }\n        uint hash_b = hash(10u * size + index + uint(iDate.w)) & 0xffffu;\n        uint hash_a = hash(3u * size + index + uint(iDate.w)) & 0xffffu;\n        //fragColor = vec4(uintBitsToFloat(hash_r), uintBitsToFloat(hash_g), uintBitsToFloat(hash_b), uintBitsToFloat(hash_a));\n        fragColor = vec4(float(hash_r) / 65536. * iResolution.x, float(hash_g) / 65536. * iResolution.y, TAU * float(hash_b) / 65536., 0.2 + 0.8 * rand(iTime + float(index * 10000u)));\n        //fragColor = vec4(fragCoord.xy, TAU * float(hash_b) / 65536., float(hash_a) / 65536. / 100.);\n        //fragColor = vec4(fragCoord.xyxy);\n        return;\n    }    \n    //vec4 data = texture(iChannel0, uv);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float x = data.r / iResolution.y; // 0->256\n    float y = data.g / iResolution.y; // 0->256\n    float d = data.b; // 0->TAU\n    float a = data.a; // 0->1\n    float v = 0.00025 + a * 0.0005 + RESET;\n    float lookup_distance = mod(iDate.w, 70.) < 50. ? 300. : 10.;\n    lookup_distance = mod(iDate.w, 60.) < 20. ? 100. : lookup_distance;\n    float vv = v * lookup_distance * (sin(iTime / 5.)*.5+.6);\n    \n    \n    vec2 aaa = vec2(cos(d) * vv, sin(d) * vv);\n    vec2 b = vec2(cos(d + PI / 6.) * vv, sin(d + PI / 6.) * vv);\n    vec2 c = vec2(cos(d - PI / 6.) * vv, sin(d - PI / 6.) * vv);\n    \n    vec3 aa = vec3(0.);\n    vec3 bb = vec3(0.);\n    vec3 cc = vec3(0.);\n    for (float i = 2.; i < 5.; i++)\n    {\n        ivec2 tmp = ivec2(mod((vec2(x, y) + aaa * i), vec2(ASPECT_RATIO, 1.)) * iResolution.yy);\n        aa += texelFetch(iChannel1, tmp, 0).rgb;\n        tmp = ivec2(mod((vec2(x, y) + b * i), vec2(ASPECT_RATIO, 1.)) * iResolution.yy);\n        bb += texelFetch(iChannel1, tmp, 0).rgb;\n        tmp = ivec2(mod((vec2(x, y) + c * i), vec2(ASPECT_RATIO, 1.)) * iResolution.yy);\n        cc += texelFetch(iChannel1, tmp, 0).rgb;\n    \n    }\n    \n    float fact = (0.8*(sin(iTime / 3.)*.5+.5)+.2);\n    float turn_speed = 0.0675 * (0.7 + 0.3 * (1.-fact));\n    if (fragCoord.x < iResolution.x / 3.)\n    {\n        if (bb.r > cc.r)\n        {\n            d += PI / 1. * turn_speed;\n        }\n        if (cc.r > bb.r)\n        {\n            d -= PI / 1. * turn_speed;\n        }\n        d += (rand(iTime+float(index)/10.)) * 0.03;\n    }\n    else if (fragCoord.x < 2. * iResolution.x / 3.)\n    {\n        if (bb.g > cc.g)\n        {\n            d += PI / 1. * turn_speed;\n        }\n        if (cc.g > bb.g)\n        {\n            d -= PI / 1. * turn_speed;\n        }\n    }\n    else\n    {\n        if (bb.b > cc.b)\n        {\n            d += PI / 1. * turn_speed;\n        }\n        if (cc.b > bb.b)\n        {\n            d -= PI / 1. * turn_speed;\n        }\n        \n        d -= (rand(iTime+float(index)/10.)) * 0.03;\n    }\n    \n    float fa = ((sin(iTime / 11.) + 1.));\n    float fb = ((1. - sin(iTime / 11.)));\n    \n    if (abs(fa) < 0.7 || abs(fb) < 0.7)\n    {\n        fa = 1.;\n        fb = 1.;\n    }\n    else\n    {\n        fa *= 1./0.7;\n        fa -= sign(fa) * 1.;\n        fb *= 1./0.7;\n        fb -= sign(fa) * 1.;\n    }\n    fa -= 1.;\n    fb -= 1.;\n    d += PI * turn_speed * bb.g * 2. * fa;\n    d -= PI * turn_speed * cc.g * 2. * fb;\n\n    \n    //d = bb;\n    d += fact * 0.2 * (rand(iTime + floor(float(index) / 30000.))-0.5);\n    //d += 0.05 * (smoothstep(0.95, 1., 2.*(sin(iTime * 10.)*.5+.5)*rand(float(index * 100u))) - 0.5);\n    fact -= 0.2;\n    x += cos(d) * (v + v * fact * 1.8);// * (aa.b + 0.5);\n    y += sin(d) * (v + v * fact * 1.8);// * (aa.b + 0.5);\n    //a += (rand(iTime + float(index * 10000u))-0.5) * 0.01;\n    x = mod(x, ASPECT_RATIO);\n    y = mod(y, 1.);\n    //x+=0.4;\n    \n    fragColor = vec4(vec2(x, y) * iResolution.y, mod(d, TAU), a);\n    //fragColor = vec4(data.xy, d, v);\n    //fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === Voronoï buffer: manage tracking of particles Ids\n\n// --- insert (i,d) and maintain the 4 closest (i_,d_) \nvoid list_insert(inout vec4 i, inout vec4 d, float i_, float d_){\t\n    if(i_ == 0.) return;           // not a particle : exit\n    if(any(equal(vec4(i_),i))) return; // already in top4 : exit\n    if     (d_ < d[0])             // closer to closest: insert here\n        i = vec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             // closer to 2nd closest: insert here\n        i = vec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])             // closer to 3rd closest: insert here\n        i = vec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])             // closer to 4th closest: insert here\n        i = vec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec4  i = vec4(0),\n         i0 = T1( I ),             // 4 closests particles here and around\n         ia = T1( I + vec2( 1, 0) ),  // NB: could use an array.\n         ib = T1( I + vec2( 0, 1) ),\n         ic = T1( I + vec2(-1, 0) ),\n         id = T1( I + vec2( 0,-1) );\n\n//#define dist(i) length( A(i).xy - I )\n//#define dist(i) length( mod( A(i).xy-I + R/2., R) - R/2. )  \nvec2 D;\n#define dist(i) ( D = mod( A(i).xy-I + R/2., R) - R/2., dot(D,D) )\n\n    vec4  d = vec4(1e9); \n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, i0[k], dist(i0[k]) );\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#if 1 // also checking diagonal (to test possibly axis bias)\n    ia = T1( I + vec2( 1, 1) ),\n    ib = T1( I + vec2(-1, 1) ),\n    ic = T1( I + vec2( 1,-1) ),\n    id = T1( I + vec2(-1,-1) );\n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#endif\n    \n    for(int k = 0; k < 4; k++){    // try to re-insert some random particle (possibly escaped from tracking)\n      //int r = IHash( int(I.x) + int(I.y)*2048 + iFrame*2048*2048 +k*11131); //deterministic\n        int r = IHash( int(I.x) + int(I.y)*2141 + iFrame*2141*2141 +k*11131); //without 2048 bias\n      //int r = IHash( int(I.x) + int(I.y)*2048 + (int(iTime*2048.)+iFrame)*2048 +k*11131);\n        int i_ =  1 + r % ( int(R.x*R.y)/int(N) ); // [ why /10? ]\n        list_insert(i, d, float(i_), dist(i_) );\n    }\n    O = vec4(i.wzyx);                   // stores 4 closest\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = T1(fragCoord);         // 4 particule id (supposed to be particles closest to I)\n    vec4 P;\n    \n    \n    //vec2 uv = ((fragCoord - 0.5) / iResolution.y) - 1.;\n    //vec3 data = texture(iChannel0, uv).rgb;\n    vec3 data = texelFetch(iChannel2, ivec2(fragCoord), 0).rgb;\n\n/*\n    float blue = 0.;\n    if (fragCoord.x > 10. && fragCoord.x < 1000. && fragCoord.y > 10. && fragCoord.y < 710.)\n    {\n        for (float i = -2.; i < 2.5; i++)\n        {\n            for (float j = -2.; j < 2.5; j++)\n            {\n                blue += texelFetch(iChannel2, ivec2(fragCoord + vec2(i, j)), 0).b;\n            }\n        }\n    }\n    */\n\n    //blue /= 18.;\n    //blue = 0.;\n    //data.b += blue;\n    //data.b /= 3.;\n    float scale = 0.13;// - 0.04 * (10. - min(iTime, 10.));\n    data.r -= scale *  0.048 + RESET;\n    if (data.r < 0.)\n        data.r = 0.;\n    data.g -= scale *  0.032 + RESET;\n    if (data.g < 0.)\n        data.g = 0.;\n    data.b -= scale * 0.032 + RESET;\n    if (data.b < 0.)\n        data.b = 0.;\n\n    //vec2 pos = texture(iChannel1, vec2(i, j) / iResolution.xy).xy;\n    //vec2 pos = texelFetch(iChannel1, ivec2(i, j), 0).xy;\n    for(int i = 0; i < 4; i++) // draw Gaussian blobs\n    {\n        P = A(a[i]);\n        if (distance(P.xy, fragCoord.xy) < 0.6)\n        {\n            data += 0.14 * vec3(abs(P.z-PI), 1., (1. * P.w + 0.5)) * pow(1. - data, vec3(4.));\n            break;\n        }\n    }\n    /*\n    if (data.b > 1.)\n        data.b = 1.;\n    if (data.r > 1.)\n        data.r = 1.;\n    if (data.g > 1.)\n        data.g = 1.;*/\n    fragColor = vec4(data, 1.0);\n    if (iFrame <= 10 || iMouse.z > 0.5)\n    {\n        fragColor = vec4(vec3(0.), 1.);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 361]], "test": "untested"}
{"id": "stlGzl", "name": "Combust", "author": "wyatt", "description": "Semi-physical model of combustion.", "tags": ["fluid", "automata"], "likes": 16, "viewed": 519, "published": 3, "date": "1622659742", "time_retrieved": "2024-07-30T19:17:45.661022", "image_code": "// Fork of \"Colors!\" by wyatt. https://shadertoy.com/view/7dX3z7\n// 2021-06-02 16:58:24\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-14 01:41:52\n\n// Display 🌵\nMain \n{\n    vec4 f = A(U), c = B(U);\n    Q = c*min(f.w,1.3);\n    Q = ((.5-.5*cos(5.*c.x+c.y*vec4(1.,2,3,4))))*atan(f.wwww);\n    Q += f.z*f.w*vec4(1,.5,0,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define dt .2\n#define _a .05\n#define _b .05\n\n", "buffer_a_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 b = B(U);\n    Q.w = b.w;\n    vec4 T = Q;\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        float f = dt*.25*(a.w*(a.w-1.+a.z));\n        Q.xy -= f*u.xy;\n        Q.z  += .5*.25*(a.z-T.z)-Q.w*f*dot(a.xy-T.xy+u.xy,u.xy); \n    }\n    float M = dt*Q.z*Q.w*b.x*b.y;\n    Q.z += 10.*M;\n    Q.y -= .1/R.y;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<50.)\n        Q.x = .5;\n    if (iFrame < 1)Q = vec4(0,0,.1,.1);\n    if (U.x < 4.||R.x-U.x<4.) Q.xyz *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xyz *= 0.;\n    Q = clamp(Q,vec4(-.5,-.5,0,0),vec4(.5,.5,2,Q.w));\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    \n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-5.*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-5.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n    if (U.x < 4.||R.x-U.x<4.) Q.xy *= 0.;\n    if (U.y < 4.||R.y-U.y<4.) Q.xy *= 0.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 Qb = B(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u),\n             qb = B(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;//+.2*max(1.-5.*Q.w*q.w,0.);\n       float k = .5;//+.2*max(1.-5.*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Qb.xyz*wa+qb.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Reaction 🔥\nMain {\n    Q = A(U);\n    vec4 b = B(U);\n    Q.w = b.w;\n    \n    float M = dt*b.z*b.w*Q.x*Q.y;\n    Q.x += -_a*M;\n    Q.y += -_b*M;\n    Q.z += M;\n    Q.w += (1.-_a-_b)*M;\n    \n    \n    if (iFrame<1) {\n        float l = length(U-vec2(.5,.1)*R);\n        Q = vec4(step(l,.1*R.y),\n                 1,\n                 0,.5);\n    }\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "sll3Rl", "name": "- Modified Julia Set -", "author": "Mihaha", "description": "Classic julia set with a slightly modified distance formula.", "tags": ["julia", "mandelbrot", "set"], "likes": 2, "viewed": 276, "published": 3, "date": "1622658051", "time_retrieved": "2024-07-30T19:17:46.478836", "image_code": "/*\n\n> by MihasGames, 02.06.2021 <\n(https://mihas-games.itch.io/)\n\n*/\n\nconst int MAX_ITERATIONS = 200;\n\nint julia(vec2 zz, vec2 c) \n{\n  vec2 z = zz;\n  float a = z.x;\n  float b = z.y;\n  int n = 0;\n  while (n < MAX_ITERATIONS) {\n    float aa = a*a;\n    float bb = b*b;\n    float twoab = 2.0 * a * b;\n\n    a = aa - bb + c.x;\n    b = twoab + c.y;\n\n    if (a*a*a*b + b*b*b*a > 3.0) break;\n    n++;\n  }\n  return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n  int juliaValue = julia((fragCoord.xy/iResolution.xy*4.0 - vec2(2, 2)) * vec2(iResolution.x / iResolution.y, 1), \n                          vec2(cos(iTime), sin(iTime/1.2)));\n  \n  float color = float(juliaValue) / float(MAX_ITERATIONS) * 7.0 + 0.1;\n  fragColor = vec4(color*0.2, color-0.3, color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3Rl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 132, 132, 409], [411, 411, 469, 469, 775]], "test": "untested"}
{"id": "stsGRl", "name": "Day 531", "author": "jeyko", "description": "potate", "tags": ["mdtmjvm"], "likes": 17, "viewed": 452, "published": 3, "date": "1622657102", "time_retrieved": "2024-07-30T19:17:47.286677", "image_code": "#define pmod(p,a) mod(p,a) - 0.5*a\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pi acos(-1.)\n#define iTime (iTime + 24.)\n// from inigo quilez\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    return vec3( t, u, v );\n}\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x)];\n    //char += 112. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1.);\n    col.x -= 0.1;\n    //col.xz -= sin(abs(dot(uv,uv))*1.)*0.1;\n    \n    float envb = sin(floor(iTime/2.));\n            \n    bool hit = false;\n    {\n        vec3 ro = vec3(0.4,0,-1.);\n        vec3 rd = normalize(vec3(uv + sin(envb*20.)*0.4,0.5));\n        vec3 rol = ro;\n        for(float i = 0.; i < 150.*(0.5 + 0.3*sin(envb*27.)); i++){\n            \n            float env = iTime + sin(iTime + i/40. + envb*20.);\n            \n            \n            \n            \n            vec3 rol = ro + vec3(sin(i*20.),cos(i),sin(i*20.))*0.2;\n            vec3 lrd = rd;\n            ro += 0.1*sin(i*0.4 + env);\n            lrd.yx *= rot(i*1.3 + env*0.1*sign(sin(envb*20.)));\n            lrd.xz *= rot(envb*.5);\n            vec3 a = vec3(0.,0.,-0.2);\n            vec3 b = vec3(0.2,-0.2,0);\n            vec3 c = vec3(0.1,0.2,0.);\n            //b *= 1. + sin(i);\n            //b *= 1. + sin(i);\n            a *= 1. + sin(i);\n            b *= 1. + sin(i + env*0.5);\n            b *= 1. + sin(i + env*0.3);\n            \n            vec3 tri = triIntersect( rol + vec3(0.+sin(i*20. + env)*0.1,0,0), lrd, a, b, c );\n        \n            if(tri.x >0.){\n                hit = true;\n                //col -= 0. + ;\n                col = mix(col,1.*pow(abs(envb),0.1)-col*0.5*sin(vec3(2,3.5,4) + i + tri.x*3. + env),1.);\n            }\n        }\n    }\n    \n    {\n        vec2 p = uv;\n        p = pmod(p,0.02);\n        float d = abs(p.x);\n        d = min(d,abs(p.y));\n        d -= 0.00;\n        \n        for(float j = 0.; j < 18.; j++){\n            vec2 luv = uv + vec2(sin(j*20.)*1.5,sin(j*20.)*1.5);\n            for(float i = 0.; i < 7. + sin(j)*9.; i++){\n                p = luv;\n                if(sin(i) < -0.9){\n                    p *= rot(0.5*pi);\n                }\n                p.x -= 0.4 + sin(i*11. + envb*120. )*0.1;\n                float ld = abs(p.x) - 0.005 + sin(i)*0.03;\n                float env = sin(i*1.1 + j*1.1 + envb);\n            \n                ld = max(ld,p.y + sin(i*20. + env));\n                //ld = abs(ld) - 0.001;\n                d = max(d,-ld + 0.1);\n\n            }\n        }\n        float od = d;\n        d = 10e5;\n        #define xor(a,b) min(max(a,-(b) + 0.5*sin(i)),max(b,-(a)))\n        \n        for(float j = 0.; j < 18.; j++){\n            vec2 luv = uv + vec2(sin(j*20.)*1.5,sin(j*20.)*1.5);\n            for(float i = 0.; i < 7. + sin(j)*9.; i++){\n                p = luv;\n                if(sin(i) < -0.9){\n                    p *= rot(0.5*pi);\n                }\n                p.x -= 0.4 + sin(i*11.+ envb*120. )*0.1;\n                \n                float s =  - 0.005 + sin(i)*0.2;\n                float ld = abs(p.x) + s;\n                float env = iTime + sin(iTime + i*0.1 + j*0.1);\n            \n                ld = max(ld,p.y + sin(i*20. + env*0.1 + envb*12.));\n                ld = max(abs(ld) - 0.001,-abs(p.x) - s);\n                d = xor(d,ld);\n\n            }\n        }\n            \n        d = min(d,od);\n        \n        \n        col = mix(col,vec3(1.,1. ,1.) - col*0.2 - 0.1,smoothstep(fwidth(uv.y),0.,d)*0.6);\n        \n        \n        \n    }\n    \n    {\n                float t = 10e5;\n            \n            for(float i = 0.; i < 14.; i++){\n                float m = sin(iTime*0.4 + sin(iTime)+i);\n                t = min(t,text(uv + vec2(0. + sin(envb + i),sin(i+ m)*0.1), float[8](135.,130.,121.,119.,120.,132.,117.,130.), 0.04 +m*0.5 , 0.5 , true, 0.004, 0.3 + 0.1*sin(iTime+i*0.4), false));\n                \n                \n            }\n            {\n                float m = sin(iTime*0.4 + sin(iTime));\n                vec2 p = uv + vec2(0.7,-0.2);\n                p *= rot(0.5*pi);\n                p.x += (iTime + sin(iTime))*0.3;\n                p.x = pmod(p.x,2.);\n                //t = min(t,text(p, float[8](128.,127.,132.,113.,132.,117.,1117.,1130.), 0.01 +m*0.4 , 0.4 , true, 0.0001, 0.4 + 0.*sin(iTime*0.3 + 0.4), true));\n            }   \n             \n            \n            col = mix(col,vec3(1.,1. ,1.) - col*0.2 - 0.1,smoothstep(fwidth(uv.y) + 0.04,0., t)*0.5);\n    }\n    \n    {\n        vec2 p = uv;\n        if( (abs(p.y) > 0.47 || abs(p.x) > 0.85)){\n            col = 1. - col*0.4;\n        }\n    \n    }\n    //col = vec3(1.,1.,1.) - col*vec3(1.,0.7,1.);\n    \n    //col = smoothstep(1.,0.,vec3(1,1.,1.)-col*vec3(1.,1.,1.));\n    if(sin(envb*12.) < 0.){\n        float m = sin(envb*6.7 + iTime*0.3 + sin(iTime) );\n        //m = max(abs(m),0.8)*sign(m);\n        //col = pow(smoothstep(0.6,1.2,col),vec3(1. + m*1.5 ,1.   ,.5 - m*1.4));\n        //col = pow(smoothstep(0.4,1.2,col),max(vec3(0.8 - m*4.,0.2   ,.5 + m*4.4),0.4));\n        if(sin(envb*250.) <0.){\n            col = 1. - col.xzy*vec3(0.1,0.5,0.5);\n            \n        } else {\n            col = 1. - col.xzy*vec3(0.1,0.5,0.5);\n            col = pow(col,vec3(2.,0.7,1.));\n            col = smoothstep(0.6,1.,col.x*vec3(1.,1.,1.4));\n        }\n    }\n    \n    //col = mix(col,1.-exp(-col*1.4),0.6);\n    \n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 155, 236, 236, 597], [599, 599, 617, 617, 690], [693, 693, 723, 723, 832], [1820, 1820, 1877, 1877, 6953]], "test": "untested"}
{"id": "flX3Rs", "name": "Camera controller", "author": "michael0884", "description": "just a camera controller with quaternions\nalso a fractal planet as a demo", "tags": ["camera"], "likes": 15, "viewed": 562, "published": 3, "date": "1622655106", "time_retrieved": "2024-07-30T19:17:48.226164", "image_code": "float sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nconst vec2 mp = vec2(-1.,1.);\n\nvoid mengerFold(inout vec3 z) \n{\n\tz.xy += min(z.x - z.y, 0.0)*mp;\n\tz.xz += min(z.x - z.z, 0.0)*mp;\n\tz.yz += min(z.y - z.z, 0.0)*mp;\n}\n\nfloat iFracScale, iFracAng1, iFracAng2;\nvec3 iFracShift, iFracCol;\n\nvec4 fractal(vec3 p)\n{\n    vec2 a1 = vec2(sin(iFracAng1), cos(iFracAng1));\n    vec2 a2 = vec2(sin(iFracAng2), cos(iFracAng2));\n\tmat2 rmZ = mat2(a1.y, a1.x, -a1.x, a1.y);\n\tmat2 rmX = mat2(a2.y, a2.x, -a2.x, a2.y);\n    float scale = 1.0;\n    vec3 orbit = vec3(0.); \n    for (int i = 0; i < 16; ++i) {\n\t\tp.xyz = abs(p.xyz);\n\t\tp.xy *= rmZ;\n\t\tmengerFold(p);\n\t\tp.yz *= rmX;\n\t\tp *= iFracScale; scale*=iFracScale;\n\t\tp.xyz += iFracShift;\n        orbit = max(orbit, p.xyz*iFracCol);\n\t}\n    return vec4(clamp(orbit, 0., 1.), sdBox(p, vec3(6.0))/scale);\n}\n\nstruct Level\n{\n    float FracScale, FracAng1, FracAng2;\n    vec3 FracShift, FracCol; \n    vec4 MarblePos, FlagPos;\n    bool isPlanet;\n};\n\nconst int levelnum = 12;\nconst Level[] Levels = Level[]( \n//Jump the crater\nLevel(1.8, -0.12, 0.5,vec3(-2.12, -2.75, 0.49),vec3(0.42, 0.38, 0.19),\n      vec4(-2.95862, 2.68825, -1.11868, 0.035),vec4(2.95227, 2.65057, 1.11848, 0.035),false),\n//Too many trees\nLevel(1.9073f, -9.83f, -1.16f, vec3(-3.508, -3.593, 3.295),vec3(-0.34, 0.12, -0.08),\n      vec4(-3.40191, 4.14347, -3.48312, 0.04),vec4(3.40191, 4.065, 3.48312, 0.04),false),\n//Hole in one\nLevel(2.02f, -1.57f, 1.62f, vec3(-3.31f, 6.19f, 1.53f),vec3(0.12f, -0.09f, -0.09f),\n      vec4(3.18387f, 5.99466f, 0.0f, 0.009f),vec4(0.0f, -6.25f, 0.0f, 0.009f),false),\n//Around the world\nLevel(1.65f, 0.37f, 5.26f, vec3(-1.41f, -0.22f, -0.77f),vec3(0.14f, -1.71f, 0.31f),\n      vec4(0.0f, 2.29418f, 0.0f, 0.01f),vec4(0.0f, -2.25f, 0.0f, 0.01f),true),\n//Beware Of Bumps     \nLevel(1.66f, 1.52f, 0.19f,vec3(-3.83f, -1.94f, -1.09f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(0.68147f, 2.80038f, 2.52778f,0.02f),vec4(0.0f, 2.84448f, -2.71705f, 0.02f),false),\n//Mountain Climbing\nLevel(1.58f, -1.45f, 3.95f,vec3(-1.55f, -0.13f, -2.52f),vec3(-1.17f, -0.4f, -1.0f),\n      vec4(0.0f, 3.36453f, 2.28284f, 0.02f),vec4(0.0f, 3.68893f, -0.604513f, 0.02f),false),\n//Mind the gap                        \nLevel(1.81,-4.84,-2.99,vec3(-2.905, 0.765, -4.165),vec3(0.251,0.337,0.161),\n      vec4(-4.63064f, 3.8365f, 0.0f, 0.022f),vec4(4.63f, 3.61f, 0.0f, 0.022f),false),\n//The Sponge\nLevel(1.88f, 1.52f, 4.91f,vec3(-4.54f, -1.26f, 0.1f),vec3(-1.0f, 0.3f, -0.43f),\n      vec4(-2.8896f, 3.76526f, 0.0f, 0.03f),vec4(2.88924f, 3.73f, 0.0f, 0.03f),false),\n//Build Up Speed\nLevel(2.08f, -4.79f, 3.16f,vec3(-7.43f, 5.96f, -6.23f),vec3(0.16f, 0.38f, 0.15f),\n      vec4(6.06325f, 6.32712f, 0.0f, 0.023f),vec4(0.0f, 6.72f, 0.0f, 0.023f),false),\n//Around The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.03543f, 1.06432f, 1.22698f, 0.01f),vec4(-1.39536f, 0.641835f, 0.0f, 0.01f),false),\n//Top Of The Citadel\nLevel(2.0773f, -9.66f, -1.34f,vec3(-1.238f, -1.533f, 1.085f),vec3(0.42f, 0.38f, 0.19f),\n      vec4(1.04172f, 1.41944f, 1.09742f, 0.005f),vec4(-1.04172f, 1.414f, -1.09742f, 0.005f),false),\n//Mega Citadel\nLevel(1.4731, 0.0f, 0.0f, vec3(-10.27, 3.28, -1.90),vec3(1.17, 0.07, 1.27),\n      vec4(-0.05, 14.69, 0.02, 0.009),vec4(-14.76, 0.01, -0.00, 0.009),false)\n );\n\nvoid LoadLevel(Level LVL)\n{\n    iFracScale = LVL.FracScale;\n    iFracAng1 = LVL.FracAng1;\n    iFracAng2 = LVL.FracAng2;\n    iFracShift = LVL.FracShift;\n    iFracCol = LVL.FracCol;\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 p )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    res = opU( res, vec2( fractal(p).w, 1.0) );\n    \n    return res;\n}\n\nvec3 normal(vec3 p) \n{\n    const float dx = 0.00001;\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  normalize(k.xyy*map(p + k.xyy*dx).x +\n                      k.yyx*map(p + k.yyx*dx).x +\n                      k.yxy*map(p + k.yxy*dx).x +\n                      k.xxx*map(p + k.xxx*dx).x);\n}\n\nbool trace(inout vec4 ro, vec3 rd)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float de = abs(map(ro.xyz).x); \n        float md = max(CAM_ANGLE*ro.w,MIN_DIST);\n        ro += vec4(rd, 1.0)*(de - 2.0*step(de, md)*md); \n        if(de < md) return true;\n        if(ro.w > MAX_DIST) return false;\n    }\n    return true;\n}\n\nfloat pow2(float x)\n{\n    return x*x;\n}\n\nvec3 fresnel(vec3 V, vec3 H, vec3 F0)\n{\n    return F0 + (1. - F0)*pow(1.0 - max(dot(V,H), 0.0), 5.0);\n}\n\nfloat NDF_ggx(vec3 m, vec3 n, float alpha)\n{\n    float alpha2 = alpha*alpha; \n    return alpha2/(PI*pow2( pow2(max(dot(n,m), 0.)) * (alpha2 - 1.0) + 1.0 ));\n}\n\nfloat G_ggx(float NdotV, float alpha)\n{\n    float alpha2 = alpha*alpha;\n    return 2.0*NdotV/(NdotV + sqrt( mix(NdotV*NdotV, 1.0, alpha2) ));\n}\n\nvec3 saturate(vec3 c)\n{\n    return tanh(pow(c,vec3(0.65)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    LoadLevel(Levels[3]);\n    init();\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 m = PI*iMouse.xy/iResolution.xy + 1e-3;\n    \n    mat3 cam = getCam(get(CamA));\n    \n    vec4 cp = get(CamP);\n    vec3 rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    vec4 ro = cp;\n    vec3 fcol;\n    if(trace(ro, rd))\n    {\n        const float roughness = 0.1;\n        vec3 N = normal(ro.xyz);\n        vec3 col = fractal(ro.xyz).xyz;\n        \n        vec3 V = -rd;\n        vec3 R = reflect(rd, N);\n        vec3 L = light;\n        vec3 H = normalize(V + L);\n        \n        vec3 kS = fresnel(V, N, vec3(0.1));\n        vec3 kD = 1.0 - kS;\n        \n        float NdotL = max(dot(N, L), 2e-3);\n        float NdotV = max(dot(N, V), 2e-3);\n        \n        float selfshadow = G_ggx(NdotL,roughness)*G_ggx(NdotV,roughness)/max(4.0*NdotL*NdotV,1e-3);\n        vec3 specular = selfshadow*kS*NDF_ggx(H, N, roughness);  \n        \n        vec3 direct = (kD * col / PI + specular) * NdotL;\n        fcol = 3.*direct + 0.5*col;\n        \n    }\n    else fcol = vec3(0.0);\n   \n    vec3 vis, inc;\n    vec3 c = atmo2(cp.xyz, rd, ro.w, vis, inc);\n    \n    fragColor = vec4(saturate(c + inc*vis*fcol), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//controller\n\n//Keyboard constants\nconst int keyLe = 37, keyUp = 38, keyRi = 39, keyDn = 40, keyA = 65, keyB = 66, keyC = 67, keyD = 68, keyE = 69, keyF = 70, keyG = 71, keyH = 72, keyI = 73, keyJ = 74, keyK = 75, keyL = 76, keyM = 77, keyN = 78, keyO = 79, keyP = 80, keyQ = 81, keyR = 82, keyS = 83, keyT = 84, keyU = 85, keyV = 86, keyW = 87, keyX = 88, keyY = 89, keyZ = 90;\n\nbool pressed(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5;\n}\n\nconst float force = 1.0;\nconst float mouse_sens = 100.0;\nconst float roll_speed = 0.5;\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    p = floor(p);\n    if(p.x > NAddr && p.y > 0.) discard;\n    \n    //get camera data\n    vec3 cp = get(CamP).xyz;\n    vec4 ca = get(CamA);\n    \n    //initialization\n    if(iFrame == 0)\n    {\n        cp = normalize(vec3(1))*(R + 3.*H);\n        ca = aa2q(vec3(0,1,0), PI*0.5);\n    }\n    \n    if(p.x == PrevCamP) o = vec4(cp, 0);\n    if(p.x == PrevCamA) o = ca;\n    \n    mat3 cam = getCam(ca);\n    \n    //get velocities\n    vec3 cv = get(CamV).xyz;\n    vec4 cav = get(CamAV);\n    \n    float dt = 1./60.0;\n    //update position\n    if(pressed(keyW)) cv += force*dt*cam*vec3(0,0,1);\n    if(pressed(keyS)) cv += force*dt*cam*vec3(0,0,-1);\n    if(pressed(keyA)) cv += force*dt*cam*vec3(-1,0,0);\n    if(pressed(keyD)) cv += force*dt*cam*vec3(1,0,0);\n    \n    cp += dt*cv;\n    cv += -cv*tanh(5.0*dt);\n    \n    //update camera orientation\n    vec2 dmouse = dt*mouse_sens*(iMouse.xy - get(PrevMouse).xy)/iResolution.x;\n    \n    if(length(dmouse) < 0.1)\n    {\n        //rotate around y ax\n        ca = qq2q(ca, aa2q(cam*vec3(0,1,0), -dmouse.x)); \n        //rotate around x ax\n        ca = qq2q(ca, aa2q(cam*vec3(1,0,0), dmouse.y));\n    }\n    \n    //roll camera\n    if(pressed(keyQ)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), -roll_speed*dt)); \n    if(pressed(keyE)) ca = qq2q(ca, aa2q(cam*vec3(0,0,1), roll_speed*dt)); \n    \n    if(p.x == CamP) o = vec4(cp, 0.0);\n    if(p.x == CamA) o = ca;\n    if(p.x == CamV) o = vec4(cv, 0.0);\n    if(p.x == CamAV) o = vec4(0.0);\n    if(p.x == PrevMouse) o = vec4(iMouse.xy, 0, 0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define FOV 1.25\n#define CAM_ANGLE 0.001\n#define MAX_STEPS 90\n#define MIN_DIST 1e-5\n#define MAX_DIST 60.0\n\n//(reused some of @ollj's code, made it more readible)\n\n// basic parameters\nfloat R = 2.1;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.1;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\n\n//specific controller buffer Addresses\nconst float CamP = 0.,     //camera position \n            CamA = 1.,     //camera rotation quaternion    \n            CamV = 2.,     //camera velocity\n            CamAV = 3.,    //camera rotation velocity\n            PrevCamP = 4., //previous frame camera position\n            PrevCamA = 5., //previous frame camera rotation quaternion\n            PrevMouse = 6.,//previous mouse pos\n            NAddr = 7.;    //max address count\n            \n#define get(i) texelFetch(iChannel2,ivec2(i,0),0)\n\n\n\n//ollj quaternionRotation math\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\n\n//quaternion Identity\nvec4 qid() \n{\n    return vec4(0, 0, 0, 1);\n}\n\n//return quaternion from axis and angle\nvec4 aa2q(vec3 axis, float ang) \n{\n    vec2 g = vec2(sin(ang), cos(ang)) * 0.5;\n    return normalize(vec4(axis * g.x, g.y));\n}\n\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q) \n{\n    return vec4(q.xyz / sqrt(1.0 - q.w * q.w), acos(q.w) * 2.);\n}\n\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2) \n{\n    return vec4(q1.xyz * q2.w + q2.xyz * q1.w + cross(q1.xyz, q2.xyz), (q1.w * q2.w) - dot(q1.xyz, q2.xyz));\n}\n\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f) \n{\n    float d = dot(a, b), t = acos(abs(d)), o = (1. / sin(t));\n    return normalize(a * sin(t * (1.0 - f)) * o * sign(d) + b * sin(t * f) * o);\n}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q) \n{\n    return q / dot(q,q);\n}\n\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\n//http://wiki.secondlife.com/wiki/LlRotBetween\nvec4 qBetween(vec3 a, vec3 b) \n{\n    float v = sqrt(dot(a,a) * dot(a,a));\n\n    if(v == 0.) return qid();\n    \n    v = dot(a, b) / v;\n    vec3 c = a.yzx * b.zxy - a.zxy * b.yzx / v;\n    float d = dot(c,c);\n    \n    if(d != 0.) \n    {\n        float s = (v > - 0.707107) ? 1. + v : d / (1. + sqrt(1. - d));\n        return vec4(c, s) / sqrt(d + s * s);\n    }\n    \n    if(v > 0.) return qid();\n    \n    float m = length(a.xy);\n    \n    return (m != 0.) ? vec4(a.y, - a.x, 0, 0) / m : vec4(1, 0, 0, 0);\n}\n\n//return inverse of quaternion\nvec4 qinv(vec4 q) \n{\n    return vec4(- q.xyz, q.w) / dot(q,q);\n}\n\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q, vec3 p) \n{\n    return qq2q(q, qq2q(vec4(p, .0), qinv(q))).xyz;\n}\n\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it is rotated by VECTOR p (as if it is a quaternion)\nvec3 vq2v(vec3 p, vec4 q) \n{\n    return qq2q(qinv(q), qq2q(vec4(p, 0.0), q)).xyz;\n}\n\nvec3 vq2v(vec4 a, vec3 b) \n{\n    return qv2v(a, b);\n}\n\n//in case of namespace confuction\nvec3 qv2v(vec3 a, vec4 b) \n{\n    return vq2v(a, b);\n}\n\n//return mat3 of quaternion (rotation matrix without translation)\n//https://www.shadertoy.com/view/WsGfWm\nmat3 q2m(vec4 q) \n{\n    vec3 a = vec3(-1, 1, 1);\n    vec3 u = q.zyz * a, v = q.xyx * a.xxy;\n    mat3 m = mat3(0.5) + mat3(0, u.x,u.y,u.z, 0, v.x,v.y,v.z, 0) * q.w + matrixCompMult(outerProduct(q.xyz, q.xyz), 1. - mat3(1));\n    q *= q; \n    m -= mat3(q.y + q.z, 0, 0, 0, q.x + q.z, 0, 0, 0, q.x + q.y);\n    return m * 2.0;\n}\n\n//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\nvec4 m2q(mat3 m) \n{\n#define m2f(a,b) m[a][b]-m[b][a]\n    //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    float q = 2. * sqrt(abs(1. + m[0][0] + m[1][1] + m[2][2]));\n    return vec4(vec3(m2f(2, 1), m2f(0, 1), m2f(1, 0)) / q / 4., q);\n#undef m2f\n}\n\nfloat at2e(vec2 a) \n{\n    a *= 2.;\n    return atan(a.x, 1. - a.y);\n}\n\n//return quaternion of Euler[yaw,pitch,roll]     \nvec4 eYPR2q(vec3 o) \n{\n    o *= .5;\n    vec3 s = sin(o);\n    //https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n    o = cos(o);\n    vec4 a = vec4(s.xz, o.xz);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(-1, 1, -1, 1);\n}\n\nvec4 eYPR2q(vec2 o) \n{\n    o *= .5;\n    vec2 s = sin(o);\n    o = cos(o);\n    vec4 a = vec4(s.x, 0., o.x, 0.);\n    return a.yyww * a.zxxz * o.y + a.wwyy * a.xzzx * s.y * vec4(- 1, 1, - 1, 1);\n}\n\nmat3 getCam(vec4 q) \n{\n    return q2m(q);\n}\n\n\n\n// Rayleigh extinction coefficients, \n// calculated for a nitrogen gas (polarizability 1.82e-30)\n// with temp 290 K, press 101300 Pa, wavelengths 655 (R), 540 (G) and 425 (B) nm,\n// and a scale of 1 unit = 6400 km (earth radius).\nvec3 beta =vec3( 38.05, 82.36, 214.65 );\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n// a small absobtion in the orange band is added\n// to simulate the effect of ozone\nvec3 absorb = vec3( 0.75, 0.85, 1. );\t\t\t\n\n// devrived values\nfloat LN2 = 0.693147181;\nfloat H50;\nvec3 beta50;\nfloat invH50;\nfloat X50;\n\nvoid init()\n{\n   H50 = H * LN2;\n   beta50 = beta * LN2;\n   invH50 = 1. / H50;\n   X50 = R / H50;\n}\n// --------------------------------------------------------\n\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(1e10); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// --------------------------------------------------------\n\nfloat chapman( float X, float h, float coschi )\n{\n\t// this is the approximate Chapman function,\n\t// corrected for transitive consistency \n\n\tfloat c = sqrt( X + h );    \n    \n\tif( coschi >= 0. )\n\t{\t\n \t\treturn c / ( c * coschi + 1. ) * exp2( -h );\n\t}\n\telse\n\t{\n\t\tfloat x0 = sqrt( 1. - coschi * coschi ) * ( X + h );\n\t\tfloat c0 = sqrt( x0 );    \n\t\treturn 2. * c0 * exp2( X - x0 ) - c / ( 1. - c * coschi ) * exp2( -h );\n\t}\n}\n\n// --------------------------------------------------------\n\nvec3 transmittance( vec3 r, vec3 viewdir )\n{\n\t// a quick function to get the transmittance\n\t// looking from point r into infinity\n\n\tfloat rsq = dot(r,r);\n\tfloat invrl = inversesqrt( rsq );\n\tfloat len = rsq * invrl;\n\tfloat x = len * invH50;\n\tfloat h = x - X50;\n\tfloat coschi = dot( r, viewdir ) * invrl;\n\t\n\treturn beta50 * H50 * chapman( X50, h, coschi ) ;\n}\n\nfloat density(vec3 r)\n{\n\tfloat rsq = dot(r,r);\n\tfloat invrl = inversesqrt( rsq );\n\tfloat len = rsq * invrl;\n\tfloat x = len * invH50;\n\tfloat h = x - X50;\n    return exp2(-h);\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\nfloat scatterAnisotropy(vec3 ri, vec3 ro)\n{\n    return mix(1.0, 4.*PI*HenyeyGreenstein(0.5, dot(ri, ro)), 0.33) + HenyeyGreenstein(0.9995, dot(ri, ro));\n}\n\nvec3 scatter(vec3 r, vec3 rd, vec3 ld)\n{\n    return beta50*scatterAnisotropy(rd, ld)*density(r);\n}\n\nvec4 atmo(vec3 r, vec3 rd, float td)\n{\n    float inv = sign(dot(rd,normalize(r)));\n    float hit = 1.0;\n   \n    vec3 depth = inv*(transmittance(r, rd*inv) - transmittance(r + rd*td, rd*inv));\n    \n    return vec4(exp2(-max(depth, 0.0)), hit);\n}\n\nconst float samp = 16.0;\n\n//atmosphere illuminated by a sun\nvec3 atmo2(vec3 r, vec3 rd, float d, out vec3 vis, out vec3 inc)\n{\n    vec2 si0 = sphIntersect(r, rd, vec3(0), R + H*10.0);\n    \n    //range between the start of the atmosphere and end/surface\n    vec2 range = vec2(max(si0.x,0.0), min(si0.y, d));\n    float dr = range.y - range.x;\n    vec3 L = vec3(0.0);\n    float dx = 1.0/samp;\n    for(float t = 0.0; t <= 1.0; t+=dx)\n    {\n        float td = mix(range.x, range.y, t);\n        vec3 p = r + rd*td;\n        vec3 shadow = exp2(-transmittance(p, light));\n        vec4 cam = atmo(r, rd, td);\n        inc = shadow;\n        vec3 scattering = scatter(p, rd, light)*inc;\n        vis = cam.xyz;\n        L += vis*scattering*dx;\n    }\n    \n    return light_bright*L*dr;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3Rs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 40], [42, 42, 77, 77, 103], [105, 105, 136, 136, 227], [260, 260, 292, 292, 393], [463, 463, 485, 485, 1006], [3493, 3493, 3520, 3520, 3674], [3677, 3677, 3707, 3707, 3740], [3742, 3742, 3765, 3765, 3871], [3873, 3873, 3895, 3895, 4154], [4156, 4156, 4192, 4192, 4483], [4485, 4485, 4506, 4506, 4524], [4526, 4526, 4565, 4565, 4629], [4631, 4631, 4675, 4675, 4789], [4791, 4791, 4830, 4830, 4934], [4936, 4936, 4959, 4959, 4997], [4999, 4999, 5056, 5056, 6257]], "test": "untested"}
{"id": "NllGzl", "name": "Procedural island Generation", "author": "MrNissenDK", "description": "based on my Perlin noise\nline 96 just make a \"random seed\" based on the Date", "tags": ["noise", "game", "terrain", "perlin", "smooth"], "likes": 1, "viewed": 338, "published": 3, "date": "1622640533", "time_retrieved": "2024-07-30T19:17:49.127753", "image_code": "float res = 5.;\nint seed = 524;\nint detail = 8; // keep less or equal to 62 and higher then 0;\nbool debug = false; // show the uv grid\n\nfloat[] heights =         float[](0. , 0.5, 0.7, 0.9, 1.5, 2., 3.);\nint[] heightColorRelation = int[](0  , 1  , 1  , 2, 3, 3, 4);\nvec3[] colors = vec3[](\n    vec3(0.3176470588235294, 0.3215686274509804, 0.2980392156862745), \n    vec3(0.9294117647058824, 0.788235294117647, 0.6862745098039216), \n    vec3(0, 0.6039215686274509, 0.09019607843137255),\n    vec3(0.6588235294117647, 0.6470588235294118, 0.611764705882353),\n    vec3(1, 0.9803921568627451, 0.9803921568627451)\n);\n\nfloat pixelSize = 0.;\n\nfloat[] digitsPi = float[](14.159265,35.897932,38.462643,38.327950,28.841971,69.399375,10.582097,49.445923,78.16406,28.620899,86.280348);\n\nfloat getDigit(float index){\n    return digitsPi[int(abs(mod(index, float(digitsPi.length()))))];\n}\nfloat getDigit(int index){\n    return getDigit(float(index));\n}\nfloat getRandom(vec2 index){\n    float _seed = mod(float(seed), 1000.);\n    index = mod(index, 65535.);\n    float id = length(index) * _seed + length(index) + _seed;\n    return fract(sin(dot(index, vec2(getDigit(id+265.), getDigit(id+159.))))* getDigit(id + 314.));\n}\nfloat getRandom(vec3 index){\n    float _seed = mod(float(seed), 1000.);\n    index = mod(index, 65535.);\n    float id = length(index) * _seed + length(index) + _seed;\n    return fract(sin(dot(index, vec3(getDigit(id+265.), getDigit(id+159.), getDigit(id+582.))))* getDigit(id + 314.));\n}\nfloat smoothMix(vec2 from, vec2 to, vec2 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(getRandom(from), getRandom(vec2(to.x, from.y)), t.x),\n        mix(getRandom(vec2(from.x, to.y)), getRandom(to), t.x),\n    t.y);\n}\nfloat smoothMix(vec3 from, vec3 to, vec3 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(\n            mix(getRandom(from), getRandom(vec3(to.x, from.yz)), t.x),\n            mix(getRandom(vec3(from.x, to.y, from.z)), getRandom(vec3(to.xy, from.z)), t.x),\n        t.y),\n\n        mix(\n            mix(getRandom(vec3(from.xy, to.z)), getRandom(vec3(to.x, from.y, to.z)), t.x),\n            mix(getRandom(vec3(from.x, to.yz)), getRandom(to), t.x),\n        t.y),\n\n    t.z);\n}\nfloat getNoise(vec2 index){\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec2 low = floor(index);\n        _output += smoothMix(low, low + vec2(1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += mod(float(seed), 50.) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\nfloat getNoise(vec3 index){\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec3 low = floor(index);\n        _output += smoothMix(low, low + vec3(1,1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += mod(float(seed), 50.) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\n\nvec3 getColor(float height){\n    for(int i = 0; i < heights.length(); i++){\n        if(height <= heights[i])\n            return mix(colors[heightColorRelation[i-1]], colors[heightColorRelation[i]], (height - heights[i - 1]) / (heights[i] - heights[i -1]));\n    }\n    return vec3(colors[heightColorRelation[heights.length()-1]]);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = int(iDate.x + iDate.y + iDate.z + iDate.w);\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    pixelSize = res / iResolution.y;\n    \n    \n    float height = ((getNoise(vec3(uv, 50)) * abs((getNoise(uv)-.5)*2.))/2.)  * (4./length(uv));\n    \n    \n    vec3 col = getColor(height);\n    \n    if(height < .65) col.b = 1.;\n    \n    if( debug && (\n        fract(uv.x) <= pixelSize || fract(uv.x) >= 1.-pixelSize || \n        fract(uv.y) <= pixelSize || fract(uv.y) >= 1.-pixelSize)\n    ) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[772, 772, 800, 800, 871], [872, 872, 898, 898, 935], [936, 936, 964, 964, 1203], [1204, 1204, 1232, 1232, 1490], [1491, 1491, 1535, 1535, 1722], [1723, 1723, 1767, 1767, 2204], [2952, 2952, 2980, 2980, 3282], [3283, 3283, 3340, 3340, 3930]], "test": "untested"}
{"id": "sdsXWf", "name": "Ukiyo-e Japanese Woodblock Print", "author": "ircss", "description": "A ukiyo a inspired shader. Inspired by a Shin hanga Kawase Hasui piece known as Road to Arayu, Shiobara. You can find the original here https://artsandculture.google.com/asset/road-to-arayu-shiobara-artist-kawase-hasui-publisher-s-watanabe-color-print-co/", "tags": ["2d", "landscape", "painting", "japanese", "reproduction", "ukiyoe"], "likes": 74, "viewed": 1368, "published": 3, "date": "1622628736", "time_retrieved": "2024-07-30T19:17:50.173956", "image_code": "#define sky_upper        vec3(0.76,  0.74,  0.64)\n#define sky_lower        vec3(0.81,  0.68,  0.53)\n#define mountain_color   vec3(0.25,  0.35,  0.45)\n#define mountain_outline vec3(0.24,  0.28,  0.31)*0.9\n#define hill_upper       vec3(0.71,0.53,0.26)\n#define hill_lower       vec3(0.71,0.53,0.26)\n#define hill_natural     vec3(0.77,0.61,0.37)\n#define hill_outline     vec3(0.57,0.37,0.14)\n#define cloud_upper      vec3(0.85,  0.79,  0.69)\n#define cloud_lower      vec3(0.72,  0.7,   0.63)\n#define cloud_outline    vec3(0.64,  0.6,   0.48) * 0.9\n#define border_color     vec3(0.250, 0.250, 0.250)\n#define bush_color_far   vec3(0.63,0.35,0.16)\n#define bush_color_far2  vec3(0.51,0.25,0.14)\n#define d_tree_outline   vec3(0.42,0.17,0.05)\n#define tree_close_trunk vec3(0.39,0.3,0.15)\n#define tree_leaves      vec3(0.56,0.26,0.11)\n#define tree_leaves2     vec3(0.61,0.4,0.22)\n#define leaves_outline   vec3(0.35,0.22,0.09)\n#define paper_color      vec3(0.84,0.79,0.66)\n#define paper_outline    vec3(0.61,0.58,0.47)\n#define paper_col_dark   vec3(0.78,0.72,0.6)\n\n#define TAU  6.28318530718\n#define PI   3.14159265359\n\n// -----------------------------------------------\n// From https://www.shadertoy.com/view/XdXGW8\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)b\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat rand(float seed) \n{\n  return fract(sin(mod(seed,1000.) *52.02) * 7632.2);\n}\n\nfloat rand2D(vec2 seed) \n{\n  return fract(sin(dot(mod(seed, vec2(1000.)), vec2(18.612, 52.624)) *52.02) * 842.2);\n}\n\n// From https://github.com/glslify/glsl-aastep/blob/master/index.glsl\nfloat aaStep(float threshold, float x)\n{\n    float afwidth = clamp(length(vec2(dFdx(x), dFdy(x))) * 0.70710678118654757, 0. ,0.05);\n    return smoothstep(threshold-afwidth, threshold+afwidth, x);\n}\n\nfloat tWave(float x, float amplitude, float frequency){\n      return abs((fract(x*frequency) *2.)-1.) * amplitude;   \n}\n\n\nfloat distanceWithAspectRatio(vec2 v1, vec2 v2, float aspectRatio)\n{\n   vec2 t = v2 - v1; \n   return sqrt(t.x* t.x*(aspectRatio*aspectRatio)  + t.y *t.y);\n}\n\nvoid DrawWithOutline(inout vec3 col, vec3 paintCol, vec3 outlineCol, float threshold, float value, float thickness)\n{\n       vec3 maskCol = mix(outlineCol, paintCol, aaStep(thickness, threshold - value));\n       col = mix(maskCol, col, aaStep(threshold, value));\n}\n\n\nfloat distanceOnNormalizedAngle(float angle, float refPoin)\n{\n  \n  float d =abs( angle - refPoin);\n  if(d> 0.5) d = 1. - d;\n  return d;\n}\n\n\nvoid DrawBetweenTwoPoints(vec2 origin, vec2 end, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n    \n    vec2 vector = end - origin;\n          uv  -= origin;\n    float len  = length(vector);\n       vector /= len;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * clamp(vUv, 0.,len) /v2;\n    float d    = distance(p, uv);\n\n    sceneColor = mix(lineColor, sceneColor, clamp(aaStep(size, d), 0. ,1.)); \n}\n\n// -----------------------------------------------\n\nvoid PaintSky(inout vec3 col, in vec2 uv)\n{\n\n   \n    col = mix( sky_lower, sky_upper, smoothstep(0.5, 0.70, uv.y));\n    col = mix(col, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n}\n\n\nfloat cloudsHeightFunction(float coord_x, float baseamplitude, float baseFrequency, float height, vec2 coord_i, float distanceToEdge)\n{\n\n   float upperPart = rand2D(coord_i + vec2(51.2, 82.58))*0.15;\n   \n   float upOrDown = step(0.,height);\n   \n   for(float f = 1.; f <6.0; f++)\n     {\n       upperPart += abs(sin(coord_x * baseFrequency * f + rand2D(coord_i + \n       vec2(f*51.2 +72.124, f*82.58+ 93.125))\n       + iTime*0.2)) * baseamplitude/f;\n     };\n     \n     float lowerPart = 0.0f;\n     \n      for(float f = 1.; f <4.0; f++)\n     {\n       lowerPart += abs(sin(coord_x * baseFrequency * f*0.5 + \n       rand2D(coord_i+ vec2(f*12.8231+53.838, f*62.61+ 12.09)))) * baseamplitude * 0.5/f;\n     };\n     \n     return mix(upperPart, lowerPart, mix(upOrDown, 1.,  1.-distanceToEdge));\n}\nvoid PaintMountain(inout vec3 col, in vec2 uv)\n{\n\n\n    float fogHeight = sin(uv.x*2.) *0.1;\n\n\n\n     float f  = 0.40;\n     float baseAmplitude = 0.12;\n     float baseFrequency = 1.;\n     \n     f += fogHeight;\n     \n     \n     for(float i = 1.; i<10. ; i++)\n     {\n        f += tWave(uv.x + rand(i), baseAmplitude / i,  baseFrequency * i);\n     }\n     \n     fogHeight += tWave(uv.x + 21.521, 0.1,  0.4);\n     \n    vec3 mountainAndFog = mix(mountain_color, sky_lower, smoothstep(0.1, 0.3 , fogHeight *0.5 + 0.6  - uv.y) ); \n     \n     \n     \n     \n     \n     float fracUV_y = uv.y;\n     \n     fracUV_y-= f;\n  \n     float uv_i_y = floor(fracUV_y *12.);\n     fracUV_y = fract(fracUV_y *12.);\n  \n     \n     float outline = aaStep(0.02 , \n                            abs(fracUV_y - 0.5 + sin(uv.x*20.) * 0.5)) - \n                            abs(sin(uv.x*8. + rand(uv_i_y*10.)*6.4)) *0.008 \n                      + abs(sin(uv.x *10. + rand((uv_i_y +24.12)*10.)*6.4)) ;\n           outline = clamp(outline, 0. , 1.);\n    \n        mountainAndFog = mix(mountain_outline, mountainAndFog, outline);\n        mountainAndFog = mix(mountainAndFog, paper_color ,  pow(texture(iChannel0,uv*5.).x,6.));\n        \n        DrawWithOutline(col, mountainAndFog, mountain_outline, f, uv.y, 0.004 + abs(sin(uv.x*5.)) *0.004);\n     \n}\n\nvoid DetermineHillHeights(inout vec3 col, in vec2 uv, out float hillHeight)\n{\n    hillHeight =   (sin(uv.x*7. +2.5) *0.5 + 0.5) *0.05  + 0.4 +\n          + sin(uv.x*3. + 2.3) *0.06+ (sin(uv.x*88.+ 7.) ) * 0.0025  + sin(uv.x*30. + 3.3 ) *0.01;\n}\n\nvoid PaintHills(inout vec3 col, in vec2 uv, in float hillHeight)\n{\n    vec3 hillWithGradient = mix(hill_upper, hill_lower, smoothstep(0.1, 0.5, sin(uv.x*8.) *0.05 + 0.3 - uv.y) ); \n\n\n    float innerLinesWave = (abs(sin(uv.x*2.) + 0.05))*( 1.-min(1., (hillHeight - uv.y)))* 0.25;\n    \n    vec2 coord   = uv - vec2(0., hillHeight + innerLinesWave); \n    vec2 coord_f = fract(coord* vec2(2., 10.) );\n    vec2 coord_i = floor(coord* vec2(2., 10.) );\n    \n    float sinWaveOne =  sin(uv.x* 13. + rand(coord_i.y*252.125 + 521.2)*612.21);\n    float outline = aaStep(0.0, \n    abs(coord_f.y - 0.5 +sinWaveOne*0.2) - 0.0025\n    + sin(uv.x* 15. + rand(coord_i.y*252.125)*612.21)*0.015 );\n    \n           \n           \n           \n     mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n     vec2 noiseUV = (coord +vec2(0., sinWaveOne)*0.03 ) * vec2(69., 80.);\n    float noisef  = noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.5*noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.25*noise(noiseUV); noiseUV = m* noiseUV;\n          noisef += 0.125*noise(noiseUV);\n          noisef += noise(coord * 5.);\n    float texturefactor = clamp(abs(noisef),0., 1.);\n    \n    hillWithGradient = mix(hillWithGradient, hill_natural, texturefactor);\n    \n    hillWithGradient = mix(hill_outline ,hillWithGradient,outline);\n    \n    hillWithGradient = mix(hillWithGradient, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n    \n    DrawWithOutline(col, hillWithGradient, hill_outline, 0.001,uv.y -hillHeight , 0.0025 + abs(sin(uv.x*5.)) *0.003);\n    \n}\n\nvoid PaintHClouds(inout vec3 col, in vec2 uv, float aspectRatio)\n{\n    vec2 uv_cloud_i = floor(uv * vec2(2., 8.)) ;\n    vec2 uv_cloud_f = fract(uv * vec2(2., 8.) + vec2( rand(uv_cloud_i.y*3.) * 0.5, 0.)) ;\n    vec2 uv_cloud_r = floor(uv * vec2(2., 8.) + vec2( rand(uv_cloud_i.y*3.) * 0.5, 0.)) ;\n     aspectRatio =  4./aspectRatio  ;\n    \n    vec2 center      = vec2(rand2D(uv_cloud_r + vec2(21.51,73.)), rand2D(uv_cloud_r + vec2(2., 51.51)));\n         center.x    = center.x *2. - 1.;\n         center      = vec2(0.5, 0.25) + center *vec2(0.3, 0.0); \n         \n         \n         // Determine cloud starting and ending point\n   float leftPoint   = 0.1       + (center.x - 0.1)  * rand2D(uv_cloud_r *vec2(572.21, 72.823) + vec2(94.1, 46.87));\n   float rightPoint  = center.x  + (0.9 - center.x ) * rand2D(uv_cloud_r *vec2(55.93, 287.23) + vec2(2.215,912.2));\n         \n   float endsAsdots  =  aaStep(0.02, min(distanceWithAspectRatio(vec2(leftPoint, center.y),uv_cloud_f, aspectRatio),\n                 distanceWithAspectRatio(vec2(rightPoint, center.y),uv_cloud_f, aspectRatio)));\n\n         // Determining the projection of the current pixel on the line between left and right points\n         \n    float projectionPos = min(max(leftPoint, uv_cloud_f.x), rightPoint);\n    float distanceToEdge =  min(uv_cloud_f.x - leftPoint , rightPoint - uv_cloud_f.x); \n\n\n    float distanceToLine  = distanceWithAspectRatio(vec2(projectionPos, center.y), uv_cloud_f,aspectRatio )*0.5;\n          distanceToLine -= cloudsHeightFunction(uv_cloud_f.x, 0.1, 10., \n          center.y - uv_cloud_f.y, uv_cloud_r* vec2(51.251, 72.21), smoothstep(0., 0.01, distanceToEdge)) \n          * smoothstep(-0.05, 0.05, distanceToEdge);\n\n    float maskCoord  = distanceToLine ;\n    float threshold  = 0.01;\n          threshold -= step(7., uv_cloud_i.y);\n          threshold -= step(0.5, rand2D(uv_cloud_r));\n          \n    vec3  cloudColGrad =mix(cloud_lower, cloud_upper, uv_cloud_f.y) ;\n        cloudColGrad = mix(cloudColGrad, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n    DrawWithOutline(col, cloudColGrad, cloud_outline, threshold, maskCoord, 0.004 + abs(sin(uv.x*12.)) *0.01);\n    \n}\n\nfloat GetFarTreeDisplacement(float Domain, float baseFrequency, float baseAmplitude, float seed)\n{\n  float d = 0.0;\n  \n\n\n        d += (sin((Domain + rand(seed*25.521 + 0.0)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        baseAmplitude *= 0.9;\n        baseFrequency *= 1.2;\n        \n        d += (sin((Domain + rand(seed*25.521 + 61.21)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        \n        baseAmplitude *= 0.9;\n        baseFrequency *= 1.5;\n        \n        d += (sin((Domain + rand(seed*25.521 + 21.6231)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        baseAmplitude *= 0.5;\n        baseFrequency *= 3.5;\n        \n        d += (sin((Domain + rand(seed*12.521 + 93.8236)) *baseFrequency ) *0.5 + 0.5)* baseAmplitude; \n        d += (sin((Domain + rand(seed*12.521 + 62.8787)) *120. ) *0.5 + 0.5)* 0.05; \n        \n  return d;\n}\n\n\nvoid PaintDistanceTrees(inout vec3 col, in vec2 uv, in float terrainHeight, float seed, float aspectRatio)\n{\n   vec2 uv_bush_i = floor(uv * vec2(15., 1.));\n   vec2 uv_bush_f = fract(uv * vec2(15., 1.));\n        uv_bush_f.y = uv_bush_f.y - terrainHeight;\n        uv_bush_f.y *= 15. * aspectRatio;\n  \n   float threshold = 0.3;\n   float shoulDraw = step(0.4, rand(uv_bush_i.x +1. + seed));\n         threshold-=  shoulDraw;\n         \n         float treeCenterY = (rand((uv_bush_i.x+seed)*65.)*2.0-1.0) * 0.4;\n         \n         vec2 toTreeCenter = vec2(0.5, treeCenterY) - uv_bush_f;\n         \n         float randOne = rand(seed*251.221 + uv_bush_i.x*2.521);\n   float f         = length(toTreeCenter);\n   float angle     = fract(atan(toTreeCenter.y, toTreeCenter.x) / TAU + 0.5 + 0.25);\n   float dis       = GetFarTreeDisplacement(angle, \n                     6.+randOne*10.,\n                     0.2,  seed + uv_bush_i.x);\n         f        -= dis * distanceOnNormalizedAngle(angle, 0.);\n   \n   float sinOne = sin((uv_bush_f.x + seed *82.12+ uv_bush_i.x*10.67) *35.);\n   float colorFactor = abs(noise(uv_bush_f*2.\n   + vec2(0., sinOne*0.1 )));\n   \n   colorFactor +=  smoothstep(treeCenterY+0.1, treeCenterY-0.3, uv_bush_f.y  + sinOne*0.01);\n   \n  vec3 bushColor  = mix( bush_color_far, bush_color_far2, colorFactor);\n  \n    // Draw trunk\n    \n    float thickness = abs(sin(angle*12. + seed*6.21 + uv_bush_i.x*5.214 + uv.y*30.));\n    \n    DrawBetweenTwoPoints(vec2(0.5, treeCenterY), vec2(0.5, treeCenterY-0.5),\n    uv_bush_f + vec2(0., 0.), 0.005 - shoulDraw + thickness*0.03 , mix(d_tree_outline, bush_color_far, 0.25), col);\n    \n    // Draw inner leaves\n    \n    \n    float coord_leaves =  distance(uv_bush_f, vec2(0.5, treeCenterY-0.5))*5.;\n    float coord_l_i    = floor(coord_leaves);\n          coord_leaves = fract(coord_leaves);\n    float sinTwo   = sin(uv_bush_f.x *82. + randOne *65.61+ coord_l_i*82.21);\n    float sinThree = sin(uv_bush_f.x *10. + randOne *65.61+ coord_l_i*52.21);\n          coord_leaves = abs(coord_leaves - 0.5 + sinTwo*0.05+ sinThree*0.4);\n          coord_leaves = aaStep(-0.031, coord_leaves  + sinThree*0.1);\n    bushColor = mix(bush_color_far2,bushColor, coord_leaves);\n    \n      bushColor = mix(bushColor, paper_color ,  pow(texture(iChannel0,uv*3.).x,6.));\n    \n   DrawWithOutline(col, bushColor, d_tree_outline, threshold, f,\n   0.008 + thickness*0.01);\n   \n   \n   \n}\n\n\n\nvec4 LineSegCoord(vec2 p1, vec2 p2, vec2 uv, out float segmentLength){\n    \n\n    vec2 vector = p2 - p1;                         // Find the vector between the two lines\n          uv   -= p1;                              // Move the entire coord system so that the point 1 sits on the origin, it is either that or always adding point 1 when you want to find your actual point\n    float len   = max(length(vector), 0.01);                  // Find the ditance between the two points\n       vector  /= len;                             // normalize the vector \n    float vUv   = dot(vector, uv);                 // Find out how far the projection of the current pixel on the line goes along the line using dot product\n    vec2  p     = vector * clamp(vUv, 0.,len) ;    // since vector is normalized, the if you multiplied it with the projection amount, you will get to the coordinate of where the current uv has the shortest distance on the line. The clamp there ensures that this point always remains between p1 and p2, take this out if you want an infinite line\n    vec2 ToLine = p - uv;                       \n    float d     = length(ToLine);                  // the actual distance between the current pixel and its projection on the line\n    \n    vec2 ortho    = vec2(vector.y, -vector.x);     // For 3D you would have to use cross product or something\n    float signedD = dot(ortho, ToLine);            // this gives you a signed distance between the current pixel and the line. in contrast to the value d, first this value is signed, so different on the different sides of the line, and second, for a line segment with finite ends, beyond the finit end, the magnitude of this value and d start to differ. This value will continue to get smaller, as you go around the corner on the finit edge and goes into negative\n    segmentLength = len;\n    \n                                                   // fourth component is used for drawing the branch thickness, is a noramlized value stating how far the pixel is between p1 nad p2\n    return vec4(vUv, d, signedD, clamp(vUv, 0.,len)/ len); \n}\n\nfloat determineBranchThickness(float size, vec4 branchCoord)\n{\n    size = mix(size, max(size, 0.8),  branchCoord.w);\n    return mix(0.05, 0., size);\n}\n\n\n\n\nfloat GetBranchDisplacement(vec2 uv, float seed)\n{\n  float d  =  (sin((uv.x + rand(seed*82.521 + 0.0)) *10. ) *0.5 + 0.5)* 0.1; \n        d  =  (sin((uv.y + rand(seed*82.521 + 0.0)) *10. ) *0.5 + 0.5)* 0.1; \n        d +=  (sin((uv.x + rand(seed*12.57 + 2.6123)) *15. ) *0.5 + 0.5)* 0.08;\n        d +=  (sin((uv.y + rand(seed*68.2146 + 5.84746)) *40. ) *0.5 + 0.5)* 0.025;\n        d +=  (sin((uv.y + rand(seed*90.572 + 73.232)) *60. ) *0.5 + 0.5)* 0.03;\n        return abs(d);\n}\n\nfloat GetLeaveShapes(vec4 branchCoord, float segmentLength, float treeShouldExist, float seed, out float randLeaveSpace)\n{\n   \n  vec2 leaveCoord_f = fract(vec2(branchCoord.x*4. + sign(branchCoord.z)*0.2, branchCoord.z));\n  vec2 leaveCoord_i = floor(vec2(branchCoord.x*4. + sign(branchCoord.z)*0.2, branchCoord.z));\n  \n  float leaveIsOnBranch = step( segmentLength, (leaveCoord_i.x +0.5)/4.);\n        leaveIsOnBranch += step((leaveCoord_i.x +0.5)/4., 0.);\n  \n  randLeaveSpace =  rand(seed + rand2D(leaveCoord_i + vec2(51.61,87.21)));\n  \n  float laeveShape = abs(leaveCoord_f.x - 0.5);\n        laeveShape = leaveIsOnBranch+ treeShouldExist\n        + laeveShape - mix(0., mix(0.2,0.25 + abs(sin(2.35* branchCoord.x/TAU\n        + rand(randLeaveSpace+2.731 + sign(branchCoord.y)*20.0231)))*0.2, randLeaveSpace),  \n        abs(sin(PI*clamp(branchCoord.z/mix(0.2, 0.35, rand(randLeaveSpace+52.731)), -1.,1.))));\n\n\n     \n  return laeveShape;  \n}\n\nvoid DrawLeaves(inout vec3 col, vec4 branchCoord, float segmentLength, float treeShouldExist, float seed, vec2 uv)\n{\n     float randLeaveSpace;\n\n   branchCoord.x += sin(branchCoord.z*5. + rand(seed) * 6.12)*0.05;\n\n   float leaveShape = GetLeaveShapes(branchCoord, segmentLength, treeShouldExist, seed , randLeaveSpace);\n   \n   float noiseMask = pow(texture(iChannel0,uv*3.).x,5.);\n   vec3 leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n   \n   float leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n   DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   branchCoord.x += /*sin(branchCoord.z*5. + rand(seed+62.721) * 6.12 )*0.05 + */\n                    sin(branchCoord.x*5. + rand(seed+62.721) * 6.12 )*0.05  ;\n   leaveShape = GetLeaveShapes(branchCoord + vec4(0.15,0.,0.,0.), segmentLength, treeShouldExist, seed +62.213, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n  \n  leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n  \n  DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   \n    leaveShape = GetLeaveShapes(branchCoord + vec4(-0.1521,0.,0.,0.), segmentLength, treeShouldExist, seed +9.213, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n   \n   leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n   \n   DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n   \n     leaveShape = GetLeaveShapes(branchCoord + vec4(0.1,0.,0.,0.), segmentLength, treeShouldExist, seed -24.173, randLeaveSpace);\n   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);\n  \n  leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);\n leaveColor = mix(leaveColor, paper_color ,  noiseMask);\n  \n  \n  DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));\n\n \n}\n\n#define trunkBorder 0.25\n#define branchStartRange 0.7\n#define treeEndPad 0.2\nvoid PaintCloseUpTrees(inout vec3 col, vec2 uv, float seed)\n{\n\n\n  uv.x += sin(uv.y*10. + uv.x + seed)*0.02 + sin(uv.y*20. + uv.x + seed)*0.01;\n\n  vec2 uv_trunk_i = floor(uv * vec2(10., 7.));\n  vec2 uv_trunk_f = fract(uv * vec2(10., 7.));\n  \n  float range_x_dis = 1. - trunkBorder*2.;\n  \n  vec2 p0 = vec2( rand2D(uv_trunk_i)                * range_x_dis + trunkBorder, 0.);\n  vec2 p1 = vec2( rand2D(uv_trunk_i + vec2(0., 1.)) * range_x_dis + trunkBorder, 1.);\n  \n  \n  vec2 p0To1  = normalize(p1 - p0);\n  vec2 p0Touv = uv_trunk_f - p0;\n  \n  float dot_x   = dot(p0Touv, p0To1);\n  float error_y = distance(uv_trunk_f- p0,  dot_x * p0To1);\n  \n\n  float treeShouldExist  = step(.15,rand(uv_trunk_i.x +52.12 + seed*5.213)) ;\n  float trunkHeight      = rand(uv_trunk_i.x)*4.0;\n        treeShouldExist  = max(treeShouldExist, step(trunkHeight, uv_trunk_i.y));\n  float thicknessControl = min(1., (uv_trunk_i.y + uv_trunk_f.y)/ trunkHeight); \n  \n  \n  // --- branches\n  // - left  \n  float cellRandOne = rand2D(uv_trunk_i + vec2(5.21 + seed, 1.2541 + seed));\n  float branchLeftStartf   =  cellRandOne\n                             * min(trunkHeight - uv_trunk_i.y, branchStartRange + treeEndPad);\n  vec2  branchLeftStartv   = p0 + p0To1 * branchLeftStartf;\n  vec2  branchLeftEndv     = vec2(treeEndPad + rand2D(uv_trunk_i + vec2(2.712,  16.41)) * (branchLeftStartv.x - treeEndPad), \n                                  rand2D(uv_trunk_i + vec2(93.221 + seed, 22.83 + seed))\n                                  * (1. - branchLeftStartv.y - treeEndPad) +  branchLeftStartv.y );  \n \n  float branchThickStart   = min(1., (uv_trunk_i.y + branchLeftStartv.y)/ trunkHeight); \n  \n  \n  float segmentLength = 0.0;\n  vec4 branchCoord = LineSegCoord(branchLeftStartv, branchLeftEndv, uv_trunk_f, segmentLength);\n  \n\n float  branch = aaStep(0.001, branchCoord.y - determineBranchThickness(branchThickStart, branchCoord));\n \n  \n   float randLeaveSpace;\n   DrawLeaves(col, branchCoord, segmentLength, treeShouldExist, seed + cellRandOne, uv);\n \n  // - right \n  \n  float branchRightStartf   = rand2D(uv_trunk_i + vec2(251.24, 7.1281)) \n  * min(trunkHeight - uv_trunk_i.y, branchStartRange + treeEndPad);\n  vec2  branchRightStartv   = p0 + p0To1 * branchRightStartf;\n  vec2  branchRightEndv     = vec2(rand2D(uv_trunk_i + vec2(71.22,  96.12)) * (1. - branchRightStartv.x - treeEndPad) +  branchRightStartv.x , \n                                   rand2D(uv_trunk_i + vec2(0.21, 83.16)) * (1. - branchRightStartv.y - treeEndPad) +  branchRightStartv.y);  \n  \n        branchThickStart    = min(1., (uv_trunk_i.y + branchRightStartv.y)/ trunkHeight); \n\n     \n     \n     branchCoord = LineSegCoord(branchRightStartv, branchRightEndv, uv_trunk_f, segmentLength);\n     \n        branch *= aaStep(0.001, branchCoord.y - determineBranchThickness(branchThickStart, branchCoord));\n       DrawLeaves(col, branchCoord, segmentLength, treeShouldExist, seed + cellRandOne, uv);\n      vec3 trunkCol = mix(tree_close_trunk, paper_color ,  pow(texture(iChannel0,uv*2.).x,5.));\n  col = mix(trunkCol, col, max(aaStep(0., error_y - mix(0.05, 0., thicknessControl))* branch,treeShouldExist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n         uv.y = 1.5 * uv.y  - 0.25;\n    vec3 col = vec3(0., 0., 0.);\n    uv.x += iTime*0.01;\n\n\n    float aspectRation = (iResolution.y / 1.5)/ iResolution.x;\n    PaintSky(col, uv);\n \n    PaintHClouds(col, uv, aspectRation);\n      uv.x += iTime*0.0065;\n      \n    PaintHClouds(col, uv * vec2(1., 0.8)+ vec2(7.213, 0.05 ), aspectRation);\n            uv.x += iTime*0.015;\n    PaintMountain(col, uv );\n    uv.x += iTime*0.1;\n    float hillHeights;\n    DetermineHillHeights(col, uv, hillHeights);\n    PaintDistanceTrees(col, uv*1.1, hillHeights+0.05, 0., aspectRation);\n    PaintHills(col, uv, hillHeights);\n    PaintDistanceTrees(col, (uv * 0.9) + vec2(5.2134, 0.), hillHeights-0.05, 51.613, aspectRation);\n    \n     uv.x += iTime*0.1;\n    \n    PaintCloseUpTrees(col, uv , -24.0);\n    \n     uv.x += iTime*0.1;\n    PaintCloseUpTrees(col, uv *0.95+ vec2(25.421, 0.05), 58.612);\n    \n    vec2 uvUnchanged = fragCoord/iResolution.xy;\n         uvUnchanged.x *= iResolution.x/iResolution.y;\n    \n     \n    vec2 shaderToyBorder      = vec2(0.0, 0.120 );\n    vec2 paperBorderThickness = vec2(0.045, 0.045);\n    float outlineThickness = 0.003 + abs(sin(uvUnchanged.x*5. +2.612) *0.1 + sin(uvUnchanged.y*5.)*0.1)*0.015;\n    \n    \n    vec3 outlineColor =  mix(paper_outline, paper_color ,  pow(texture(iChannel0,uvUnchanged*3.).x,3.));\n    \n    col = mix(outlineColor , col,  step(shaderToyBorder.y + paperBorderThickness.y + outlineThickness, uvUnchanged.y)\n              * (1.- step(1.- (shaderToyBorder.y + paperBorderThickness.y + outlineThickness), uvUnchanged.y)));\n    \n    col = mix(outlineColor , col,  step(shaderToyBorder.x + paperBorderThickness.x + outlineThickness, uvUnchanged.x)\n              * (1.- step((iResolution.x/iResolution.y) - (shaderToyBorder.x + paperBorderThickness.x + outlineThickness), uvUnchanged.x)));\n    \n    \n    vec3 pape = mix(paper_color, paper_col_dark ,  pow(texture(iChannel0,uvUnchanged*2.).x,2.)); \n    \n    \n    col = mix(pape , col,  step(shaderToyBorder.y + paperBorderThickness.y, uvUnchanged.y)\n              * (1.- step(1.- (shaderToyBorder.y + paperBorderThickness.y), uvUnchanged.y)));\n    \n    col = mix(pape , col,  step(shaderToyBorder.x + paperBorderThickness.x, uvUnchanged.x)\n              * (1.- step((iResolution.x/iResolution.y) - (shaderToyBorder.x + paperBorderThickness.x), uvUnchanged.x)));\n    \n    \n    \n    \n    \n    col = mix(border_color , col,  step(shaderToyBorder.x, uvUnchanged.x) \n    * (1.- step((iResolution.x/iResolution.y)- shaderToyBorder.x, uvUnchanged.x)));\n    \n    col = mix(border_color , col,  step(shaderToyBorder.y, uvUnchanged.y) \n    * (1.- step(1.-shaderToyBorder.y, uvUnchanged.y)));\n\n\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1206, 1206, 1283, 1338, 1818], [1820, 1820, 1846, 1846, 2287], [2290, 2290, 2315, 2315, 2371], [2373, 2373, 2399, 2399, 2488], [2490, 2560, 2600, 2600, 2757], [2759, 2759, 2814, 2814, 2878], [2881, 2881, 2949, 2949, 3037], [3039, 3039, 3156, 3156, 3303], [3306, 3306, 3367, 3367, 3443], [3446, 3446, 3555, 3555, 3914], [3968, 3968, 4011, 4011, 4156], [4159, 4159, 4294, 4294, 4946], [4947, 4947, 4995, 4995, 6252], [6254, 6254, 6331, 6331, 6497], [6499, 6499, 6565, 6565, 8038], [8040, 8040, 8106, 8106, 10207], [10209, 10209, 10307, 10307, 11059], [11062, 11062, 11170, 11170, 13464], [13468, 13468, 13538, 13538, 15559], [15561, 15561, 15623, 15623, 15711], [15716, 15716, 15766, 15766, 16192], [16194, 16194, 16316, 16316, 17131], [17133, 17133, 17249, 17249, 19303], [19382, 19382, 19443, 19443, 22518], [22521, 22521, 22578, 22628, 25395]], "test": "untested"}
{"id": "slfGRs", "name": "flag 2", "author": "sean1998", "description": "SHOW SIMPLE FLAG", "tags": ["2d", "flag"], "likes": 1, "viewed": 228, "published": 3, "date": "1622616296", "time_retrieved": "2024-07-30T19:17:51.036649", "image_code": "\nvec3 getcolor(vec2 uv, float a, float b, vec3 color){\n   float f = step(a, uv.x) * step(uv.x, b);\n   return color * f;\n}\n\nvec3 getcolor1(vec2 uv){\n    vec3 c1 = getcolor(uv, 0.0, 0.2, vec3(1.0,0.0,0.0));\n    vec3 c2 = getcolor(uv, 0.2, 0.4, vec3(0.0,1.0,0.0));\n    vec3 c3 = getcolor(uv, 0.4, 0.6, vec3(0.0,0.0,1.0));\n    vec3 c4 = getcolor(uv, 0.6, 0.8, vec3(1.0,0.0,1.0));\n    vec3 c5 = getcolor(uv, 0.8, 1.0, vec3(0.0,1.0,1.0));\n    return c1 + c2 + c3 + c4 + c5;\n}\n\nvec3 getcolor2(vec2 uv){\n    int i = int(5.0 * uv);\n    \n    return vec3(i==0||i == 3,i==1 || i==4, i>1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Output to screen\n    fragColor = vec4(getcolor2(uv) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 54, 54, 121], [123, 123, 147, 147, 469], [471, 471, 495, 495, 578], [580, 580, 637, 687, 800]], "test": "untested"}
{"id": "7tXGRs", "name": "Optimal Flow", "author": "wyatt", "description": "River Formation", "tags": ["fluid", "automata"], "likes": 17, "viewed": 485, "published": 3, "date": "1622611903", "time_retrieved": "2024-07-30T19:17:51.924276", "image_code": "// Fork of \"Aqua Vista\" by wyatt. https://shadertoy.com/view/ssXGDB\n// 2021-06-02 04:45:09\n\n// Fork of \"Temperatures\" by wyatt. https://shadertoy.com/view/fsf3zS\n// 2021-03-22 22:23:14\n\n// Fork of \"Transport Dynamics II\" by wyatt. https://shadertoy.com/view/sdl3RN\n// 2021-03-18 22:39:28\n\n// Display 🌵\nMain \n{\n    vec4 f = A(U), b = B(U);\n    Q = 1.-(.5-0.5*(sin(3.5-.3*(f.z)+vec4(1,2,3,4))))*f.w;\n    Q = 1.5*(vec4(.9,.7,1,1)-.8*Q)*vec4(1,.5,0,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n", "buffer_a_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 bb = B(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        vec4 b = B(U+u);\n        float f = 0.08*((b.x-bb.x)+a.w*((a.w-.5)+.3));\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q.xy -= Q.xy*.1*exp(-18.*Q.w*Q.w);\n    \n    Q.y -= 1e-3;\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(.1*normalize(iMouse.xy-0.5*R),-1,1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0);\n    if (U.x < 1.||R.x-U.x<2.) Q.xy *= 0.;\n    if (U.y < 1.||R.y-U.y<2.) Q.w *= 0.;\n    if (R.y-U.y<6.) Q = vec4(0,-.5,0,.1);\n    Q.xy = clamp(Q.xy,-.5,.5);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5+.5*max(1.-2.5*Q.w*q.w,0.);\n       float k = .5+.5*max(1.-2.5*Q.w*q.w,0.);\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .5;\n       float k = .5;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n        \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Land 🏔\nMain\n{\n    vec4 a = A(U);\n    Q = B(U);\n    vec4 \n         n = B(U+vec2(0,1)),\n         e = B(U+vec2(1,0)),\n         s = B(U-vec2(0,1)),\n         w = B(U-vec2(1,0)),\n         m = 0.25*(n+e+s+w);\n    float l = length(a.xy);\n    Q = Q+1e-2*(m-Q)- 5e-3*a.w*l+1e-4;\n    Q = clamp(Q,0.,1.);\n    if (iFrame < 1)\n        Q = vec4(1);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "slf3zl", "name": "Raymarched SDF \"bearings\"", "author": "Danimtz", "description": "Update on my first shader. Used smoothmax to combine torus and sphere and made little spheres rotate in the groove. Currently slow due to nested loops for the little subbearings/burgers. Change AA from 2 to 1 for better performance", "tags": ["raymarching", "combiningsdfs"], "likes": 3, "viewed": 258, "published": 3, "date": "1622610108", "time_retrieved": "2024-07-30T19:17:52.759044", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define SURF_DIST 0.001\n#define AA 2\n\n#define PI 3.1415926538\n\n#define SPHERECOUNT 4\n#define SPHERE3 4.0\n#define SPHERE2 3.0\n#define SPHERE1 2.0\n#define PLANE 1.0\nfloat sdSphere(vec3 p, float r)//Signed distance function of sphere\n{\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y); //outer and inner radius 2d\n    return length(q)-t.y; //two symetric circles 2d\n}\n\nvec2 minSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x<sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 maxSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x>sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 smax(vec2 sdf1, vec2 sdf2, float k)//smooth\n{\n    float h = max(k - abs(sdf1.x - sdf2.x), 0.0)/k;\n    float bf = h*h*0.5;// blend factor \n    float res = bf*k*(1.0/2.0);\n    \n    return (sdf1.x>sdf2.x) ? vec2(sdf1.x+res, sdf1.y/*mix(sdf1.y, sdf2.y, bf)*/) : \n    vec2(sdf2.x+res, sdf2.y/*mix(sdf1.y, sdf2.y, 1.0-bf)*/);\n}\n\n//Returns origin of rotating sphere\nvec3 calcRotSphereXZ(float ofset, vec3 o, float th)\n{\n    vec2 o_2d = o.xz;//ignore height\n    vec2 p = o_2d+vec2(ofset);\n\n    //translate to origin\n    p -= o.xz;\n\n    //calculate rotation\n    vec2 rot_p;\n    rot_p.x = p.x*cos(th) - p.y*sin(th);\n    rot_p.y = p.x*sin(th) + p.y*cos(th);\n\n    //translate back\n    vec3 res = o;\n    res.xz = rot_p + o_2d;\n\n    return res;\n}\n\n\nvec2 sdBurger(vec3 p, vec3 o, float r, float k, float colourID) // Sphere with torus cut out\n{\n    //torus modifiers\n    float t1 = 0.7; \n    float t2 = 0.3;\n\n    vec3 po = p-o;\n\n    vec2 sdf = vec2(sdSphere(po, r), colourID);\n    sdf = smax(sdf, vec2(-sdTorus(po, vec2(r*t1, r*t2)), colourID), k);\n    return sdf;\n} \n\n\nvec2 map(vec3 p) //Scene geometry information\n{\n    \n    vec2 cur_sdf = vec2(1e10, 0.0);\n\n    //Hollowed sphere\n    vec3 sph_o = vec3(0.0, 2.0, 10.0);\n    vec3 torus = vec3(0.0, 2.0, 10.0);\n    float rp = 2.0;\n    float k = 0.4;\n    float ratio = 0.287; //ratio\n    vec2 combined = vec2(1e10, 0.0);\n    \n    cur_sdf = sdBurger(p, sph_o, rp, k,SPHERE1);\n    \n    //Rotating spheres\n    float r = ratio*rp;\n    float rr = ratio*r;\n    float kk = ratio*k;\n    float kkk = ratio*kk;\n    float theta = 1.0*iTime;\n    int sph_count = SPHERECOUNT;\n    \n    //NOTE: these nested loops are very slow with increasing ammount of spheres. \n    //There are surely better ways to optimize this, but wanted to implement fractalike animation naively\n    for(int i = 0; i < sph_count; i++)\n    {\n        vec3 sph_or = calcRotSphereXZ(1.0, sph_o, theta+(2.0*PI*(float(i)/float(sph_count))));\n        cur_sdf = minSDF(cur_sdf,sdBurger(p, sph_or, r, kk,SPHERE2));\n\n        //Rotating spheres\n        float theta2 = 4.0*theta;\n        for(int j = 0; j < sph_count; j++)\n        {\n            vec3 sph_orr = calcRotSphereXZ(ratio, sph_or, theta2+(2.0*PI*(float(j)/float(sph_count))));\n            cur_sdf = minSDF(cur_sdf,sdBurger(p, sph_orr, rr, kkk,SPHERE3));\n        \n        }\n    \n    }\n    \n\n    //plane\n    cur_sdf = minSDF(cur_sdf, vec2(p.y, PLANE)); //plane\n    return cur_sdf;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.001;\n    vec2 res;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO*rd; //Go along ray\n        res = map(p); //Calc distance to surface, res.x\n        if(res.x < SURF_DIST || dO>MAX_DIST) break;\n        dO += res.x ;\n    }\n    if (dO > MAX_DIST) dO = -1.0;\n    return vec2(dO, res.y);\n}\n\nfloat calcSoftShdw(vec3 ro, vec3 rd, float k)\n{\n    //more info: https://iquilezles.org/articles/rmshadows\n    //Circle circle intersection: https://mathworld.wolfram.com/Circle-CircleIntersection.html\n\n    float res = 1.0; //1.0 if hard shadow\n    float prev_d = 1e10; //previous closest distance to surface\n    for(float t = 0.0; t<MAX_DIST;)\n    {\n        float d = map(ro + t*rd).x;\n        if(d < 0.001){ return 0.0; }\n        float y = d*d/(2.0*prev_d); //y: distance from curr pos to ray midpoint \n        float d_ys = sqrt(d*d-y*y); //d_ms: distance from y to closest surface\n        float sh =  clamp(k*d_ys/max(0.0, t-y),0.0,1.0);\n        \n        res = min(res, sh*sh*(3.0-2.0*sh));//apply smoothstep (3-2x)*x^2\n        prev_d = d;\n        t += d;\n    }\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    //float d = map(p).x; //get distance to surface\n    vec2 e = vec2(0.01, 0);//error bias for difference\n    vec3 n = normalize(vec3( //find normal using small difference\n            map(p+e.xyy).x-map(p-e.xyy).x,    \n            map(p+e.yxy).x-map(p-e.yxy).x,  \n            map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n    return n;\n}\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //Raymarch pixel\n    vec2 res = rayMarch(ro, rd); //distance to point p\n    float d = res.x;\n    //sky colour\n    vec3 col = vec3(0.4, 0.6, 0.8) - 0.7*rd.y;\n    if (d > 0.0){\n\n        vec3 p = ro + d*rd;\n        //colour and lights\n        vec3 mat = vec3(0.0);\n        if(res.y<=PLANE){ mat = vec3(0.017, 0.02, 0.03);}\n        else if(res.y<=SPHERE1){ mat = vec3(0.15);}\n        else if(res.y<=SPHERE2){ mat = vec3(0.05);}\n        else if(res.y<=SPHERE3){ mat = vec3(0.11, 0.07, 0.15);}\n        \n        \n\n        vec3 lpos = vec3(1.5, 1.5, -1.0);\n        float speed = 1.0;\n        //lpos.xz += vec2(sin(iTime*speed), cos(iTime*speed))*2.;\n\n        //light & normal vectors\n        vec3 l = normalize(lpos-0.0);\n        vec3 n = calcNormal(p);\n\n        //diffuse light\n        float dif = clamp(dot(n,l), 0.0, 1.0);\n        float sky_dif = clamp(0.5+0.5*dot(n,vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bounce_dif = clamp(0.2+0.2*dot(n,vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        float shdw = calcSoftShdw(p+n*0.05, l, 16.0); //step(rayMarch((p+n*SURF_DIST), l).x, 0.0);//hard shadows\n         \n\n\n        //specular light\n        vec3 h = normalize(l + normalize((ro-p)));\n        float spec = pow(max(0.0, dot(n,h)), 128.0);\n        \n\n        vec3 light_in = vec3(0.0);\n        light_in += vec3(7.0, 5.8, 3.6)*dif*shdw;\n        light_in += vec3(0.5, 0.8, 0.6)*sky_dif;\n        light_in += vec3(0.6, 0.3, 0.1)*bounce_dif;\n\n        col = mat*light_in;\n\n        col += mat*spec*shdw;\n    }\n    return (col);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera/Ray origin\n    vec3 ro = vec3(-cos(0.2*iTime), 2.7, -1.2*sin(0.2*iTime));\n\n    vec3 avrg_col = vec3(0.0);\n#if AA>1 //Supersampling AA\n    for(int i = 0; i < AA; i++)\n    for(int j = 0; j < AA; j++){\n        //Pixel coordinates\n        vec2 of = vec2(float(i),float(j)) / float(AA) - 0.5;\n        vec2 uv = ((fragCoord+of)- .5*iResolution.xy)/iResolution.y;\n#else\n        \n        vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n#endif\n        \n        //Ray direction\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n        \n        //Render scene\n        vec3 col = render(ro,rd);\n        \n        \n\n        avrg_col += col;\n\n#if AA>1      \n    }\n    avrg_col /= float(AA*AA);//Apply AA\n#endif\n    //gamma\n    avrg_col = pow(avrg_col, vec3(0.4545));\n\n    fragColor = vec4(avrg_col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slf3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 277, 277, 305], [307, 307, 340, 340, 463], [465, 465, 500, 500, 542], [544, 544, 579, 579, 621], [623, 623, 673, 673, 949], [951, 987, 1040, 1040, 1360], [1363, 1363, 1457, 1479, 1679], [3051, 3051, 3084, 3084, 3407], [3409, 3409, 3456, 3610, 4192], [4194, 4194, 4219, 4271, 4550], [4554, 4554, 4585, 4606, 6102]], "test": "untested"}
{"id": "7tf3zl", "name": "Decic Bezier Curve", "author": "oneshade", "description": "Wanted to know what higher degree bezier curves look like. I find it hard to believe thats a polynomial.", "tags": ["2d", "bezier", "plot", "dash", "parametric", "decic"], "likes": 8, "viewed": 223, "published": 3, "date": "1622609765", "time_retrieved": "2024-07-30T19:17:53.742415", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat anim(in float seed) {\n    float a = Hash11(seed * 193.84 + 673.48);\n    float b = Hash11(seed * 348.46 + 183.37);\n    float c = Hash11(seed * 275.35 + 741.69);\n    return 2.0 * sin(iTime * a + b) * c;\n}\n\nvec2 decicBezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 e, in vec2 f, in vec2 g, in vec2 h, in vec2 i, in vec2 j, in vec2 k, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv +\n           10.0 * b * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * t +\n           45.0 * c * tInv * tInv * tInv * tInv * tInv * tInv * tInv * tInv * t * t +\n           120.0 * d * tInv * tInv * tInv * tInv * tInv * tInv * tInv * t * t * t +\n           210.0 * e * tInv * tInv * tInv * tInv * tInv * tInv * t * t * t * t +\n           252.0 * f * tInv * tInv * tInv * tInv * tInv * t * t * t * t * t +\n           210.0 * g * tInv * tInv * tInv * tInv * t * t * t * t * t * t +\n           120.0 * h * tInv * tInv * tInv * t * t * t * t * t * t * t +\n           45.0 * i * tInv * tInv * t * t * t * t * t * t * t * t +\n           10.0 * j * tInv * t * t * t * t * t * t * t * t * t +\n           k * t * t * t * t * t * t * t * t * t * t;\n\n    /*\n    vec2 a1 = mix( a,  b, t), a2 = mix( b,  c, t), a3 = mix( c,  d, t), a4 = mix( d,  e, t), a5 = mix( e,  f, t), a6 = mix( f,  g, t), a7 = mix( g,  h, t), a8 = mix( h,  i, t), a9 = mix( i,  j, t), a10 = mix( j,  k, t);\n    vec2 b1 = mix(a1, a2, t), b2 = mix(a2, a3, t), b3 = mix(a3, a4, t), b4 = mix(a4, a5, t), b5 = mix(a5, a6, t), b6 = mix(a6, a7, t), b7 = mix(a7, a8, t), b8 = mix(a8, a9, t), b9 = mix(a9, a10, t);\n    vec2 c1 = mix(b1, b2, t), c2 = mix(b2, b3, t), c3 = mix(b3, b4, t), c4 = mix(b4, b5, t), c5 = mix(b5, b6, t), c6 = mix(b6, b7, t), c7 = mix(b7, b8, t), c8 = mix(b8, b9, t);\n    vec2 d1 = mix(c1, c2, t), d2 = mix(c2, c3, t), d3 = mix(c3, c4, t), d4 = mix(c4, c5, t), d5 = mix(c5, c6, t), d6 = mix(c6, c7, t), d7 = mix(c7, c8, t);\n    vec2 e1 = mix(d1, d2, t), e2 = mix(d2, d3, t), e3 = mix(d3, d4, t), e4 = mix(d4, d5, t), e5 = mix(d5, d6, t), e6 = mix(d6, d7, t);\n    vec2 f1 = mix(e1, e2, t), f2 = mix(e2, e3, t), f3 = mix(e3, e4, t), f4 = mix(e4, e5, t), f5 = mix(e5, e6, t);\n    vec2 g1 = mix(f1, f2, t), g2 = mix(f2, f3, t), g3 = mix(f3, f4, t), g4 = mix(f4, f5, t);\n    vec2 h1 = mix(g1, g2, t), h2 = mix(g2, g3, t), h3 = mix(g3, g4, t);\n    vec2 i1 = mix(h1, h2, t), i2 = mix(h2, h3, t);\n    return mix(i1, i2, t);\n    */\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    vec2 a = vec2(anim( 1.0) * 3.0, anim( 2.0));\n    vec2 b = vec2(anim( 3.0) * 3.0, anim( 4.0));\n    vec2 c = vec2(anim( 5.0) * 3.0, anim( 6.0));\n    vec2 d = vec2(anim( 7.0) * 3.0, anim( 8.0));\n    vec2 e = vec2(anim( 9.0) * 3.0, anim(10.0));\n    vec2 f = vec2(anim(11.0) * 3.0, anim(12.0));\n    vec2 g = vec2(anim(13.0) * 3.0, anim(14.0));\n    vec2 h = vec2(anim(15.0) * 3.0, anim(16.0));\n    vec2 i = vec2(anim(17.0) * 3.0, anim(18.0));\n    vec2 j = vec2(anim(19.0) * 3.0, anim(20.0));\n    vec2 k = vec2(anim(21.0) * 3.0, anim(22.0));\n\n    bool dash = true;\n    vec2 prevPos = a;\n    for (float t=0.01; t < 1.01; t += 0.01) {\n        vec2 curPos = decicBezier(a, b, c, d, e, f, g, h, i, j, k, t);\n        if (dash) color = mix(color, hue2rgb(t + iTime), smoothstep(unit, 0.0, sdLine(uv, prevPos, curPos)));\n        prevPos = curPos;\n        dash = !dash;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3zl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 184, 184, 309], [311, 400, 426, 426, 512], [514, 514, 541, 541, 722], [724, 724, 875, 875, 2999], [3001, 3001, 3056, 3056, 4097]], "test": "untested"}
{"id": "sll3Rj", "name": "flag 1", "author": "sean1998", "description": "show a simple flag", "tags": ["2d", "flag"], "likes": 1, "viewed": 268, "published": 3, "date": "1622609728", "time_retrieved": "2024-07-30T19:17:54.660959", "image_code": "#define PI 3.1415926;\n\nfloat plot(vec2 uv, float f, float offset, bool flag){\n   f *= 2.0;\n   float y = mix(0.0, 1.0, uv.y);\n   return smoothstep(flag ? 0.02 : -0.02, 0.0, y - 0.1*sin(iTime+f) - offset);\n}\n\n\nvec3 getcolor(vec2 uv, float y, float offset, vec3 c1, vec3 c2, bool flag){\n    y *= PI;\n    float f = plot(uv, y, offset, flag);\n    \n    return mix(c1, c2, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color1 = getcolor(uv, uv.x, 0.8, vec3(1,0,0),  vec3(0,0,0), false);\n    vec3 color2 = getcolor(uv, uv.x, 0.6, vec3(-1,1,0), vec3(0,0,0), false);\n    vec3 color3 = getcolor(uv, uv.x, 0.4, vec3(0,-1,1), vec3(0,0,0), false);\n    vec3 color4 = getcolor(uv, uv.x, 0.2, vec3(0,0,-1), vec3(0,0,0), false);\n\n    // Output to screen\n    fragColor = vec4(color1 + color2 + color3 + color4, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 77, 77, 205], [208, 208, 283, 283, 371], [373, 373, 430, 480, 918]], "test": "untested"}
{"id": "7lfGzl", "name": "🌎", "author": "ssartell", "description": "earth", "tags": ["earth"], "likes": 16, "viewed": 574, "published": 3, "date": "1622605486", "time_retrieved": "2024-07-30T19:17:55.665274", "image_code": "/*\n    Mostly just playing around with textures and displacement. Super fake atmosphere effect, but it works well enough\n*/\n\nfloat farClip = 30.0;\nfloat pi = 3.14159;\n\nfloat sphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 triplaner(vec3 n, sampler2D tex, float s) {\n  n = normalize(n);\n  vec3 xz = texture(tex, (n.xz * .5 + .5) * s).rgb;\n  vec3 xy = texture(tex, (n.xy * .5 + .5) * s).rgb;\n  vec3 zy = texture(tex, (n.yz * .5 + .5) * s).rgb;\n\n  vec3 tn = abs(n);\n  tn *= pow(abs(n), vec3(20.));\n  tn /= tn.x + tn.y + tn.z;\n  return tn.y * xz + tn.z * xy + tn.x * zy;\n}\n\nvec4 map(vec3 p) {\n  float d1 = sphere(p, vec3(0.), .25);\n\n  float roc = triplaner(p, iChannel1, .6).r * 2. - 1.;\n  float d3 = roc;\n\n  float gra = triplaner(p, iChannel0, 1.).g * 2. - 1.;\n  float gt = .3;\n  float d2 = max(roc, gt) + gra * .2;\n\n  float wat = gt;\n  float wt = .1;\n\n  float t1 = smoothstep(gt, gt , roc);\n  float t2 = smoothstep(wt, wt, roc);\n  float t = mix(wat, mix(d2, d3, t1), t2);\n  float dis = t * .05;\n  float d = .7 * (d1 - dis);\n\n  return vec4(d, t1 + t2, roc, d1);\n}\n\nvec3 calcNormal(vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x);\n\n  return normalize(n);\n}\n\nvec4 marchRay(vec3 ro, vec3 rd) {\n  float t = 0.;\n  vec4 res;\n  for(int i = 0; i < 100; i++) {\n    vec3 p = ro + t * rd;\n    res = map(p);\n    float h = res.x;\n    if (h < 0.0001) return vec4(t, res.yz, i);\n    t += h;\n    if (t > farClip) return vec4(0.0, res.yz, i);\n  }\n  return vec4(t, res.yz, 100.);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k) {\n  float res = 1.0;\n    float ph = 1e20;\n    for( float t = 0.; t<100.;)\n    {\n      float h = map(ro + rd*t).x;\n      if( h<0.001 )\n        return 0.0;\n      float y = h*h/(2.0*ph);\n      float d = sqrt(h*h-y*y);\n      res = min( res, k*d/max(0.0,t-y) );\n      ph = h;\n      t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n\n  float tx = iTime / 2.0 + 3.;\n  float ty = 0.2;\n  if (iMouse.z > 0.0) {\n    tx = iMouse.x / iResolution.x * 3.1416 * 3.0 + 3.14;\n    ty = iMouse.y / iResolution.y - .1;\n  }\n\n  vec3 ro = vec3(cos(tx * .7), ty, sin(tx * .7));\n  vec3 ta = vec3(0.0, 0.0, 0.0);\n\n  // camera axes\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  vec3 rd = normalize(uv.x*uu + uv.y*vv + .9*ww);\n\n    vec4 res = marchRay(ro, rd);\n    float t = res.x;\n    float mat = res.y;\n    float h = res.z;\n    float i = res.w;\n\n    vec3 l = normalize(vec3(1., .17, 1.));\n    float vdotl = max(dot(rd, l), 0.0);\n\n    vec3 fog = vec3(.01, .01, .02);\n    vec3 sun = vec3(1.6, 1.2, 1.);\n    float sunAmount = pow(vdotl, 256.);\n    fog = mix(fog, sun, sunAmount);\n    fog += pow(triplaner(rd, iChannel2, 2.), vec3(1.));\n    fog += pow(triplaner(rd, iChannel1, 1.), vec3(10.))\n    * vec3(.7, .5, .9);\n    vec3 col = fog;\n\n    if (t > 0.0) {\n        col = vec3(0.0);\n        vec3 p = ro + t * rd;\n\n        vec3 n = calcNormal(p);\n        vec3 np = normalize(p);\n        vec3 cNoise = triplaner(p, iChannel0, 2.) * 2. - 1.;\n        n = mix(mix(np, cNoise, .02), mix(n, cNoise, .3), step(1.5, mat));\n        n = mix(mix(n, cNoise, .02), n, step(.5, mat));\n        n = normalize(n);\n\n        vec3 r = reflect(-l, n);\n\n        float ndotl = clamp(dot(n, l), 0., 1.);\n        float rdotv = clamp(dot(-rd, r), 0., 1.);\n        float npdotl = clamp(dot(np, l), 0., 1.);\n\n        vec3 albedo;\n        vec3 water1 = vec3(.05, .1, .4);\n        vec3 water2 = vec3(.05, .25, .55);\n        vec3 water = mix(water1, water2, smoothstep(-.4, .2, h));\n\n        vec3 rock = mix(vec3(.3, .28, .25),\n          vec3(2.0), smoothstep(.5, .6, h));\n        albedo = mix(water, triplaner(n, iChannel0, 1.) * vec3(.5, 1., .6), clamp(mat, 0., 1.));\n        albedo = mix(albedo, rock, clamp(mat - 1., 0., 1.));\n\n        float sha = softShadow(p + .02 * n, l, 64.);\n        float diff = max(ndotl, .3 * npdotl);\n        float sp = pow(rdotv, 30.) * smoothstep(.9, 0., mat);\n        float sky = clamp(.5 + .5 * n.y, 0., 1.);\n        float ind = clamp(dot(n, normalize(l * vec3(-1., 0., -1.))), 0., 1.);\n\n        vec3 lin = (diff * sha) * .7 * sun + .02;\n        col = albedo * lin + sp * sun * .8;\n    }\n\n    // atmosphere\n    vec3 p = .9 * rd * length(ro) / dot(normalize(-ro), rd);\n    float sha = clamp(capsule(ro + p, vec3(0.), -l * 100., .24), 0., 1.);\n\n    float at = pow(i / 20., 2.);\n    col += mix(\n    vec3(.2, .5, 1.) * (pow(vdotl, 3.) * .5 + .1),\n    vec3(.7, .4, .3) * (pow(vdotl, 3.) * .5),\n    pow(vdotl, 10.)) * smoothstep(0., .05, sha) * at;\n\n    col = pow(col, vec3(1.0 / 2.2));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float random(vec2 p) {\n  return fract(sin(dot(p, vec2(12.75, 8.92))) * 53638.97582);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  float a = random(i);\n  float b = random(i + vec2(1., 0.));\n  float c = random(i + vec2(0., 1.));\n  float d = random(i + vec2(1., 1.));\n\n  f = f * f * (3.0 - 2.0 * f);\n\n  return mix(mix(a,b,f.x),mix(c,d,f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n  float a = .5;\n  float f = 1.;\n  float y = 0.;\n\n  for(int i = 0; i < 8; i++) {\n    y += a * noise(f * p);\n    f *= 2.;\n    a *= .5;\n  }\n\n  return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 uv = gl_FragCoord.xy / mx;\n  uv *= 20.;\n  vec3 color = vec3(0.);\n\n  color += fbm(uv);\n\n  fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "float random(vec2 p) {\n  return fract(sin(dot(p, vec2(124.75, 83.92))) * 53638.97582);\n}\n\nfloat noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  float a = random(i);\n  float b = random(i + vec2(1., 0.));\n  float c = random(i + vec2(0., 1.));\n  float d = random(i + vec2(1., 1.));\n\n  f = f * f * (3.0 - 2.0 * f);\n\n  return mix(mix(a,b,f.x),mix(c,d,f.x), f.y);\n}\n\nfloat fbm(vec2 p) {\n  float a = .5;\n  float f = 1.;\n  float y = 0.;\n\n  for(int i = 0; i < 8; i++) {\n    y += a * noise(f * p);\n    f *= 2.;\n    a *= .5;\n  }\n\n  return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 uv = gl_FragCoord.xy / mx;\n  uv *= 20.;\n  vec3 color = vec3(0.);\n\n  color += smoothstep(.995, 1., random(uv));\n\n  fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lfGzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 207, 207, 237], [239, 239, 289, 289, 410], [412, 412, 460, 460, 763], [765, 765, 783, 783, 1255], [1257, 1257, 1282, 1282, 1439], [1441, 1441, 1474, 1474, 1747], [1749, 1749, 1794, 1794, 2101], [2103, 2103, 2160, 2160, 4960]], "test": "untested"}
{"id": "ftXGRs", "name": "Ivean Polkka - Sound Shader", "author": "BigETI", "description": "You are free to play around the code and do something else.", "tags": ["sound", "music", "audio"], "likes": 14, "viewed": 639, "published": 3, "date": "1622579329", "time_retrieved": "2024-07-30T19:17:57.193189", "image_code": "// Ivean Polkka - loituma\n\n#ifdef LOW_RESOLUTION_MODE\nconst int imageWidth = 32;\n\nconst int imageHeight = 32;\n#else\nconst int imageWidth = 64;\n\nconst int imageHeight = 64;\n#endif\n\nconst int imageCount = 4;\n\nconst int indicesPerBitmapBitsElement = 8;\n\nconst int primaryBorderSize = 2;\n\nconst int primaryBorderColorIndex = 10;\n\nconst int secondaryBorderColorIndex = 12;\n\nconst vec3 bitmapPalette[] = vec3[]\n(\n        vec3(0.9215686274509803, 0.7215686274509804, 0.6352941176470588),\n        vec3(0.9490196078431372, 0.7843137254901961, 0.7058823529411765),\n        vec3(0.7058823529411765, 0.807843137254902, 0.792156862745098),\n        vec3(0.6196078431372549, 0.43529411764705883, 0.34509803921568627),\n        vec3(0.6274509803921569, 0.3803921568627451, 0.19215686274509805),\n        vec3(0.7686274509803922, 0.5294117647058824, 0.32941176470588235),\n        vec3(0.8392156862745098, 0.5372549019607843, 0.3058823529411765),\n        vec3(0.788235294117647, 0.47058823529411764, 0.23921568627450981),\n        vec3(0.9450980392156862, 0.8588235294117647, 0.8196078431372549),\n        vec3(0.6745098039215687, 0.6235294117647059, 0.6039215686274509),\n        vec3(0.4666666666666667, 0.611764705882353, 0.5607843137254902),\n        vec3(0.396078431372549, 0.38823529411764707, 0.38823529411764707),\n        vec3(0.3607843137254902, 0.5137254901960784, 0.42745098039215684),\n        vec3(0.38823529411764707, 0.23137254901960785, 0.2784313725490196),\n        vec3(0.4823529411764706, 0.3254901960784314, 0.5333333333333333),\n        vec3(0.5490196078431373, 0.37254901960784315, 0.596078431372549)\n);\n\nconst ivec4 bitmapBits[] = ivec4[]\n(\n#ifdef LOW_RESOLUTION_MODE\n    ivec4(0x01000000, 0x03000022, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34000012, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057646, 0x70674766),\n    ivec4(0x00100000, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x009222A2, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x10CA22CA, 0x74190000, 0x57893535, 0x67763335),\n    ivec4(0x00BC2ACC, 0x75150100, 0x80883035, 0x67779913),\n    ivec4(0x00CC9BCC, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x00CAACCC, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11C0BCBC, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11A1CC9C, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x1122CC29, 0x77151111, 0x88888888, 0x50461581),\n    ivec4(0x1181CC81, 0x45101111, 0x81881888, 0x52770588),\n    ivec4(0x11010B11, 0x45111111, 0xDDDDDD88, 0x92649588),\n    ivec4(0x11911911, 0x76111111, 0x3D333388, 0x92443788),\n    ivec4(0x11011011, 0x76111111, 0x18998843, 0x22473789),\n    ivec4(0x11801011, 0x57111811, 0x09114344, 0x824747D4),\n    ivec4(0x11898128, 0x67888888, 0x00304444, 0x184774DD),\n    ivec4(0x81811182, 0x64812282, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x81888888, 0x64812288, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x81882228, 0x54882282, 0xDDDDDDFF, 0x11BDDBB3),\n    ivec4(0x90882922, 0x5D812288, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x11889828, 0x3D818888, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x10882888, 0xBD898888, 0xFFEFFFFF, 0xF8FFFFDB),\n    ivec4(0x10881188, 0xFDEF8888, 0xFFFFFFFF, 0xF1FFEEDE),\n    ivec4(0x09888088, 0xEFFF8088, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88098888, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88088888, 0xFFFEDE01, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88088888, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x28288888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x98288888, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x21988288, 0xFF008888, 0xFFFFDDFE, 0x993B09AA),\n    ivec4(0x01000000, 0x03000022, 0x66776666, 0x00666666),\n    ivec4(0x01000000, 0x34000022, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057676, 0x70674766),\n    ivec4(0x00100011, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x00822282, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x11882222, 0x74190000, 0x57893535, 0x67663335),\n    ivec4(0x10882222, 0x75150011, 0x80883035, 0x67779913),\n    ivec4(0x11822222, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x01222822, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11112282, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11212282, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x11222222, 0x77151111, 0x88888888, 0x50461581),\n    ivec4(0x11118111, 0x45101111, 0x88888888, 0x52770588),\n    ivec4(0x11111111, 0x45111111, 0x18118188, 0x92649588),\n    ivec4(0x11111111, 0x76111111, 0x88888888, 0x92443788),\n    ivec4(0x11111111, 0x76111111, 0x88888849, 0x12473789),\n    ivec4(0x11111111, 0x57112818, 0x09014344, 0x814747D4),\n    ivec4(0x11111128, 0x67888888, 0x00404444, 0x184774DD),\n    ivec4(0x11111182, 0x64818282, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x18818888, 0x54889982, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x11812228, 0x54288888, 0xDDDDDDFF, 0x11BDDB33),\n    ivec4(0x90908822, 0x5D188888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x81882228, 0x3D118818, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x88880188, 0xBD898888, 0xFFFFFFFF, 0xF8FFFFDB),\n    ivec4(0x81881888, 0xFDEF8888, 0xFFFFFFFF, 0xF1FFEEDE),\n    ivec4(0x09881181, 0xFFFF8088, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88991118, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88808888, 0xFFFEDE08, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88818818, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x88888888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x28228888, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x21888288, 0xFF008888, 0xFFFFDDFE, 0x993B09AA),\n    ivec4(0x00000000, 0x03002012, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34001012, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000011, 0x66057676, 0x70674766),\n    ivec4(0x00111111, 0x77000000, 0x66056776, 0x75674466),\n    ivec4(0x10882282, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x11882222, 0x74100000, 0x53893535, 0x67763335),\n    ivec4(0x11822222, 0x75150010, 0x80883035, 0x67779913),\n    ivec4(0x11222222, 0x43050111, 0x88888880, 0x67469981),\n    ivec4(0x11212222, 0x75051111, 0x11881810, 0x67461388),\n    ivec4(0x11112282, 0x75051111, 0xB388B0BB, 0x654680DB),\n    ivec4(0x11212222, 0x75151111, 0x88888888, 0x75478982),\n    ivec4(0x11212228, 0x77101111, 0x88888818, 0x50461581),\n    ivec4(0x11111111, 0x45101111, 0x88888888, 0x52670588),\n    ivec4(0x11111111, 0x45111111, 0x18118188, 0x02649588),\n    ivec4(0x11111111, 0x76111111, 0x88888888, 0x02443788),\n    ivec4(0x11111111, 0x76118111, 0x88888843, 0x11473789),\n    ivec4(0x11111111, 0x56118218, 0x09014344, 0x184747D4),\n    ivec4(0x11111121, 0x67882288, 0x00404444, 0x114774DD),\n    ivec4(0x11118882, 0x64812282, 0xBDE044D4, 0x11444DDD),\n    ivec4(0x11118228, 0x64282288, 0xDDE3DDDD, 0x1144DDDB),\n    ivec4(0x18818822, 0x54882288, 0xDDDDDDFF, 0x11B4DBB3),\n    ivec4(0x18009922, 0x5D818888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x01888888, 0x3D818888, 0xEEDEEEFF, 0x08EEFF4D),\n    ivec4(0x80888810, 0xBD898888, 0xFFFFFFFF, 0xF8FFFFDB),\n    ivec4(0x89888888, 0xFDEF8801, 0xFFFFFFFF, 0xF1FFEEDF),\n    ivec4(0x99180188, 0xEFEF8888, 0xFFFFFEFF, 0xFFFFFE9F),\n    ivec4(0x88888888, 0xBBCC9981, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88198888, 0xCCEBDE01, 0xFFFFEFCB, 0xFF8F88EE),\n    ivec4(0x88818888, 0xCCEE9011, 0xFFFFBBCC, 0xFF818828),\n    ivec4(0x88228888, 0xCC3E109A, 0xFFBECCCC, 0xFF888898),\n    ivec4(0x28228888, 0xCC0388CC, 0xEFCCCCBB, 0xF9888898),\n    ivec4(0x21882288, 0xBC9098CC, 0xEFBBBCBB, 0x993B09AA),\n    ivec4(0x00000000, 0x03001011, 0x66776666, 0x00666666),\n    ivec4(0x00000000, 0x34001011, 0x66757677, 0x00664666),\n    ivec4(0x00000000, 0x47000010, 0x66057676, 0x70674766),\n    ivec4(0x00082211, 0x77000000, 0x66056776, 0x75664466),\n    ivec4(0x00DBAC22, 0x77000000, 0x36135577, 0x67664456),\n    ivec4(0x00BC9C22, 0x74100000, 0x53893535, 0x67763335),\n    ivec4(0x11CCAC22, 0x75150000, 0x80883035, 0x67779913),\n    ivec4(0x00CBAC22, 0x430300B5, 0x88888880, 0x67469981),\n    ivec4(0x3BCCCC82, 0x750500D3, 0x11881810, 0x67461A88),\n    ivec4(0xBBC9CC22, 0x470500C0, 0xB388B0BB, 0x654680DB),\n    ivec4(0xCCBCCC22, 0xBB030090, 0x88888888, 0x75478982),\n    ivec4(0xC9CCCC11, 0xBBBB0111, 0x88888891, 0x50461588),\n    ivec4(0x11CCBC11, 0xBBCC9311, 0x81881181, 0x52670588),\n    ivec4(0x11913C11, 0xB9CCBC11, 0xDDDDDD88, 0x02649588),\n    ivec4(0x11819B11, 0x44C9CC10, 0x3D333388, 0x12443788),\n    ivec4(0x11119B11, 0xBDBBCC9C, 0x189919D3, 0x11473789),\n    ivec4(0x11110011, 0xCCCCCCCC, 0x09014444, 0x114747D4),\n    ivec4(0x11110021, 0xBBCCACCA, 0x00304444, 0x114774DD),\n    ivec4(0x11018282, 0x44282292, 0xBDB044D4, 0x11444DDD),\n    ivec4(0x11212228, 0x74282228, 0xDDEFDDDD, 0x1144DDDB),\n    ivec4(0x11802222, 0x7D882288, 0xDDDDDDFF, 0x11B4DBB3),\n    ivec4(0x01818222, 0x5D818888, 0xDDDDDDFF, 0x81FEEF34),\n    ivec4(0x89882822, 0x3D818888, 0xEEDBEEFF, 0x08EEFF4D),\n    ivec4(0x19881888, 0xBD898888, 0xFFEFFFFF, 0xF8FFFFDB),\n    ivec4(0x18880888, 0xFDEF8888, 0xFFEFFFFF, 0xF1FFEEDF),\n    ivec4(0x99881188, 0xEFFF8188, 0xFFFFFFFF, 0xFFEFFE9F),\n    ivec4(0x88888188, 0xFFFF9E88, 0xFFFFEEFF, 0xFFFEE999),\n    ivec4(0x88008888, 0xFFFEDE08, 0xFFFFEFFF, 0xFF8F88EE),\n    ivec4(0x88888888, 0xFFEE9081, 0xFFFFEFFF, 0xFF818828),\n    ivec4(0x88888888, 0xFF3E1088, 0xFFFFEFFF, 0xFF888898),\n    ivec4(0x28828288, 0xFF038888, 0xFFFFEFFF, 0xF9888898),\n    ivec4(0x2289A288, 0xFF908888, 0xFFFFDDFE, 0x993B09AA)\n#else\n    ivec4(0x0, 0x12010000, 0x2122, 0x45030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x18010000, 0x2222, 0x76640000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x11000000, 0x2212, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x11000000, 0x1111, 0x77440000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x0, 0x1011, 0x77470500),\n    ivec4(0x70766446, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x0, 0x0, 0x0, 0x77770400),\n    ivec4(0x58667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x10000000, 0x10, 0x0, 0x77776400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757767),\n    ivec4(0x9001191, 0x1001, 0x0, 0x77575400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0xAB2222A2, 0x1192, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0xCC2222C9, 0x20C2, 0x0, 0x74743419),\n    ivec4(0x88350977, 0x59975185, 0x56446456, 0x677766),\n    ivec4(0xCC2222CA, 0x1022CA, 0x1000000, 0x43743719),\n    ivec4(0x88359535, 0x39573089, 0x56337335, 0x60677776),\n    ivec4(0xCC2292CC, 0xA2BC, 0x1000000, 0x45745415),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0xCC2AA2CC, 0xA2BC, 0x11010100, 0x35755715),\n    ivec4(0x88308835, 0x31809188, 0x36993913, 0x60677777),\n    ivec4(0xCC2CC2CC, 0x100A1BC, 0x11011011, 0x39455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0xCC9BC9CC, 0x110091CC, 0x11011011, 0x8435605),\n    ivec4(0x88888880, 0x88888888, 0x94991181, 0x60676746),\n    ivec4(0xCCACCCCC, 0x110021CC, 0x11010010, 0x88456605),\n    ivec4(0x88881188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0xCCACCCCC, 0x110011CA, 0x11111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x1677746),\n    ivec4(0xCCBCCCCC, 0x111111C9, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x1677746),\n    ivec4(0xCCBCCCBC, 0x111110C0, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x657746),\n    ivec4(0xCCBCCC3C, 0x111111C1, 0x10111111, 0x9B756715),\n    ivec4(0x88188831, 0x88088888, 0x5789B89D, 0x10667747),\n    ivec4(0xCCCCCC9C, 0x111111A1, 0x11111111, 0x59757715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x11757747),\n    ivec4(0xCCCCCC2C, 0x11111192, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57851188, 0x88707746),\n    ivec4(0xCACCCC29, 0x11112122, 0x11111111, 0x8777715),\n    ivec4(0x88888888, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0xBACC2C28, 0x11111122, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x54058888, 0x22507576),\n    ivec4(0xCACC1081, 0x11111181, 0x11111111, 0x88455710),\n    ivec4(0x88188188, 0x18818888, 0x54058888, 0x22527577),\n    ivec4(0xCC9C1111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x39331388, 0xB3333339, 0x74058888, 0x22527767),\n    ivec4(0xCC0B1111, 0x11111101, 0x11111111, 0x88455311),\n    ivec4(0xDDDD1B88, 0xD3DDDDDD, 0x77958888, 0x22927564),\n    ivec4(0xBB1A1111, 0x11111191, 0x11111111, 0x8550411),\n    ivec4(0x3DDD8988, 0xD9BDDDBB, 0x46558188, 0x22925574),\n    ivec4(0xAA191111, 0x11111191, 0x11111111, 0x50760411),\n    ivec4(0x33338188, 0x383D3333, 0x76378088, 0x82925544),\n    ivec4(0x88101111, 0x11111191, 0x11111111, 0x43760411),\n    ivec4(0x33198808, 0x18393353, 0x77371388, 0x88225544),\n    ivec4(0x88101111, 0x11111101, 0x11111111, 0x44760311),\n    ivec4(0x9881843, 0x88189099, 0x74373489, 0x88227547),\n    ivec4(0x88101111, 0x11111110, 0x11111811, 0x44761311),\n    ivec4(0x88084544, 0x80888888, 0x74474434, 0x28127047),\n    ivec4(0x18101111, 0x11111180, 0x81181811, 0x44571511),\n    ivec4(0x59434444, 0x93091111, 0x4D4744D4, 0x28825047),\n    ivec4(0x8811111, 0x11111189, 0x81288818, 0x44571511),\n    ivec4(0x4D444444, 0x9900030, 0xDD7444DD, 0x22885047),\n    ivec4(0x8811128, 0x11111189, 0x88888888, 0x44671588),\n    ivec4(0x4D444D44, 0x9B000030, 0xD474D4DD, 0x22185047),\n    ivec4(0x8818122, 0x11111889, 0x28228281, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4D4DD7DD, 0x82115047),\n    ivec4(0x8112182, 0x18810881, 0x28228882, 0x4D641581),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D44DD, 0x88115044),\n    ivec4(0x98812882, 0x88810888, 0x22228828, 0xDD640581),\n    ivec4(0xDDDD4D44, 0xDDDD9D30, 0x4DDD44DD, 0x11115143),\n    ivec4(0x98882888, 0x82810888, 0x22222288, 0xDD640581),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x22882888, 0x82180888, 0x22222282, 0xDB540328),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x22222228, 0x82819188, 0x22222282, 0xDE540388),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151BD),\n    ivec4(0xA9292822, 0x18999920, 0x22222282, 0xBF540381),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x28292822, 0x8908988, 0x28222288, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88982222, 0x8188188, 0x88888888, 0xEF3D0388),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x88988228, 0x8118188, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88988888, 0x18098888, 0x88888888, 0xEF3DEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDE4D, 0x1198FEEF),\n    ivec4(0x88288888, 0x88108888, 0x88888888, 0xEEBDEE89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFEF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88018888, 0x88818888, 0x88888888, 0xDFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88118888, 0x88108888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDE, 0x88F1FFFF),\n    ivec4(0x88108888, 0x88098888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88F9FFFF),\n    ivec4(0x88808888, 0x18098888, 0xFF808888, 0xFFEFFEFF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x8818888, 0x8088088, 0xEF8F8888, 0xFFFFFEFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x82E9FF9F, 0x98FFFFFF),\n    ivec4(0x10888888, 0x11889909, 0xFF9E8888, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x81888888, 0x80888998, 0xFFEF8918, 0xFFFFEFFF),\n    ivec4(0xFFEFFFFF, 0xF9FFFFFF, 0x1192EC9E, 0xE9FFFF9E),\n    ivec4(0x88888888, 0x88888808, 0xFFDE8001, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888888, 0x88888808, 0xFFBF8110, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888888, 0x88888808, 0x9E909981, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFEE81),\n    ivec4(0x88888888, 0x88188808, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x88888888, 0x88288828, 0x108088, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x82888888, 0x88288228, 0x118888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x29888888, 0x88988228, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x2A888888, 0x88988228, 0x888888, 0xFFFFEF03),\n    ivec4(0xFFDEFEFF, 0xE9FFFFFF, 0x888888A2, 0x1913B09),\n    ivec4(0x2A828888, 0x88218298, 0x10888888, 0xFFFFFE00),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990990AA, 0x1899993B),\n    ivec4(0x29828888, 0x88229929, 0x10888888, 0xEEEE0E88),\n    ivec4(0xDEDDEEEE, 0xE9FFFFEE, 0x9B9BBAC, 0x8199933),\n    ivec4(0x0, 0x12010000, 0x2222, 0x45030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x12010000, 0x102222, 0x76640000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x18010000, 0x2222, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x11010000, 0x1182, 0x77440000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x1000000, 0x1011, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x0, 0x0, 0x1000, 0x77770400),\n    ivec4(0x58667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x11000011, 0x10, 0x0, 0x77776400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757767),\n    ivec4(0x11011111, 0x1010, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0x28222282, 0x2182, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365913, 0x56447456, 0x677766),\n    ivec4(0x22222222, 0x102182, 0x0, 0x74743410),\n    ivec4(0x88350977, 0x59975185, 0x56446456, 0x677766),\n    ivec4(0x22222222, 0x112288, 0x1000000, 0x43743719),\n    ivec4(0x88359535, 0x39573089, 0x56335335, 0x60677766),\n    ivec4(0x22222222, 0x102288, 0x1000000, 0x45735715),\n    ivec4(0x88391035, 0x30153981, 0x56395553, 0x60677777),\n    ivec4(0x22222222, 0x10102288, 0x1001011, 0x35755715),\n    ivec4(0x88308835, 0x31809188, 0x36993913, 0x60677777),\n    ivec4(0x28222222, 0x11112182, 0x11111011, 0x39455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0x88222222, 0x11112182, 0x11011011, 0x8435605),\n    ivec4(0x88888880, 0x88888888, 0x94991181, 0x60676746),\n    ivec4(0x88282222, 0x11011122, 0x11011011, 0x88456605),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0x22282222, 0x11011122, 0x11111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x1676746),\n    ivec4(0x22222222, 0x11111121, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x677746),\n    ivec4(0x21222282, 0x11111111, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x657746),\n    ivec4(0x88822882, 0x11111111, 0x11111111, 0x9B756715),\n    ivec4(0x88188831, 0x88088888, 0x5789B89D, 0x11667747),\n    ivec4(0x88222882, 0x11111121, 0x11111111, 0x59757715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x81757747),\n    ivec4(0x88228822, 0x11111122, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57851188, 0x88707746),\n    ivec4(0x88228822, 0x11111122, 0x11111111, 0x8777715),\n    ivec4(0x88888888, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0x88221811, 0x11111111, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0x11811111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22527777),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x74058888, 0x22527767),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455311),\n    ivec4(0x818888, 0x88181011, 0x77958888, 0x22927564),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x8550411),\n    ivec4(0x11888888, 0x88881188, 0x46558188, 0x88925574),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x50760411),\n    ivec4(0x88888888, 0x88888888, 0x76378088, 0x88925544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x43760411),\n    ivec4(0x88888808, 0x88888888, 0x77371388, 0x88227544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x44760311),\n    ivec4(0x88881849, 0x88888888, 0x74373489, 0x28125047),\n    ivec4(0x11111111, 0x11111111, 0x81111811, 0x44761311),\n    ivec4(0x88014544, 0x80888888, 0x74474434, 0x28125047),\n    ivec4(0x11111111, 0x11111111, 0x81281818, 0x44571511),\n    ivec4(0x59434444, 0x93091101, 0x4D4744D4, 0x22815047),\n    ivec4(0x11111111, 0x11111111, 0x81888818, 0x44571581),\n    ivec4(0x4D444444, 0x9900030, 0x4D7444DD, 0x22885047),\n    ivec4(0x11111128, 0x11111111, 0x28888888, 0x44671588),\n    ivec4(0x4D44DD44, 0x9B000040, 0xD474D4DD, 0x82185047),\n    ivec4(0x11118122, 0x11111111, 0x28221281, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4444D7DD, 0x88115047),\n    ivec4(0x11112882, 0x18111111, 0x28828882, 0x4D640581),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D44DD, 0x18115144),\n    ivec4(0x21882888, 0x81111111, 0x22228228, 0xDD640581),\n    ivec4(0xDDDD4DD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115143),\n    ivec4(0x88882888, 0x81181181, 0x99999982, 0xDD540588),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x88882228, 0x82181881, 0x2A882822, 0xDB540528),\n    ivec4(0xDDDDEDB3, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x21222228, 0x2118881, 0x8A888888, 0xDF540528),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4D33, 0x111151BD),\n    ivec4(0x88882822, 0x88900010, 0x2A888888, 0xBF540508),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x81882222, 0x88901190, 0x99888888, 0xEF5D0318),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1881E0FE),\n    ivec4(0x90992222, 0x91898888, 0x10000012, 0xEF3D0308),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x98228228, 0x90818888, 0x88888818, 0xEF3D9D11),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x18822188, 0x8888888, 0x88888888, 0xEFBDEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDE4D, 0x8898FEEF),\n    ivec4(0x88010088, 0x8888888, 0x88888888, 0xEEBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFFF, 0xFEFFEDDB, 0x88F8FFFF),\n    ivec4(0x88181988, 0x8888888, 0x88888888, 0xBFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEEDE, 0x88F8FFFF),\n    ivec4(0x88188088, 0x18818888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDE, 0x88F1FFFF),\n    ivec4(0x88081988, 0x88108888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88F9FFFF),\n    ivec4(0x88111881, 0x88098188, 0xFF808888, 0xFFFFFFFF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x18898881, 0x8810188, 0xEF8F8888, 0xFFFFFEFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x82E9FF9F, 0x98FFFFFF),\n    ivec4(0x10118818, 0x11888899, 0xFF9E8888, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x88888188, 0x80888800, 0xFFEF8918, 0xFFFFEFFF),\n    ivec4(0xFFEEFFFF, 0xF9FFFFFF, 0x1192EC9E, 0xE9FFFF9E),\n    ivec4(0x88881888, 0x88888880, 0xFFDE8008, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888881, 0x88881881, 0xFFBF8110, 0xFFFFFFFE),\n    ivec4(0xFFEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888818, 0x88880881, 0x9E909981, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFEE81),\n    ivec4(0x88888888, 0x88880888, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x88888888, 0x88882288, 0x108088, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x82888888, 0x88882922, 0x818888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x22888888, 0x88282922, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x22828888, 0x88288888, 0x888888, 0xFFFFEF03),\n    ivec4(0xFFDEFEFF, 0xEFFFFFFF, 0x888888A2, 0x1913B09),\n    ivec4(0x28828888, 0x88218888, 0x10888888, 0xFFFFFE00),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990990AA, 0x1899993B),\n    ivec4(0x88128888, 0x88808888, 0x10888888, 0xEEEE0E88),\n    ivec4(0xEEDDEEEE, 0xE9FFFFEE, 0x9B9BBAC, 0x8199933),\n    ivec4(0x0, 0x1000000, 0x202212, 0x47030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x1000000, 0x202282, 0x76540000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x1000000, 0x102212, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6666),\n    ivec4(0x0, 0x1000000, 0x102112, 0x47470000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x606667),\n    ivec4(0x0, 0x1000000, 0x1111, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x1000000, 0x10, 0x0, 0x77770400),\n    ivec4(0x51667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x11111111, 0x1011, 0x0, 0x77770400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757667),\n    ivec4(0x22222288, 0x1182, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0x22222282, 0x102188, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0x22222222, 0x112228, 0x0, 0x74743410),\n    ivec4(0x88550977, 0x59575185, 0x56446456, 0x677766),\n    ivec4(0x22222222, 0x112288, 0x0, 0x43743710),\n    ivec4(0x88359535, 0x39533089, 0x56337335, 0x60677776),\n    ivec4(0x22222222, 0x10102288, 0x1000000, 0x45745715),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0x22222222, 0x11112282, 0x1000010, 0x39755715),\n    ivec4(0x88308835, 0x31809188, 0x35993913, 0x60677777),\n    ivec4(0x28222222, 0x11112182, 0x11111011, 0x30455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0x88222222, 0x11112122, 0x1011011, 0x98436605),\n    ivec4(0x88888880, 0x88888888, 0xA3991181, 0x60676746),\n    ivec4(0x82882222, 0x11011122, 0x1011011, 0x88756605),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0x22222222, 0x11111121, 0x1111111, 0x88756705),\n    ivec4(0x88189010, 0x1118888, 0xB3138888, 0x676746),\n    ivec4(0x22222282, 0x11111111, 0x11111111, 0x1756705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x676746),\n    ivec4(0x81222282, 0x11111111, 0x11111111, 0x9756705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x1657746),\n    ivec4(0x81228882, 0x11111111, 0x11111111, 0x9B755715),\n    ivec4(0x88188838, 0x88088888, 0x5789B89D, 0x11657747),\n    ivec4(0x82228822, 0x11111121, 0x11111111, 0x59755715),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x88757747),\n    ivec4(0x82228822, 0x11111121, 0x11111111, 0x8757715),\n    ivec4(0x88888888, 0x88888888, 0x57891188, 0x12707746),\n    ivec4(0x82228828, 0x11111121, 0x11111111, 0x1777710),\n    ivec4(0x88888818, 0x88888888, 0x54158881, 0x22507646),\n    ivec4(0x88281811, 0x11111111, 0x11111111, 0x18457710),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455510),\n    ivec4(0x88888888, 0x88888888, 0x64058888, 0x22527567),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455710),\n    ivec4(0x88888888, 0x88888888, 0x74958888, 0x22927767),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x88455311),\n    ivec4(0x1818888, 0x88181011, 0x77958888, 0x28027564),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x8550411),\n    ivec4(0x11888888, 0x88881188, 0x46558888, 0x28025574),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x50760411),\n    ivec4(0x88888888, 0x88888888, 0x76378088, 0x28025544),\n    ivec4(0x11111111, 0x11111111, 0x11111111, 0x43760411),\n    ivec4(0x88888808, 0x88888888, 0x77341388, 0x28127544),\n    ivec4(0x11111111, 0x11111111, 0x88811111, 0x44761311),\n    ivec4(0x88881843, 0x88888888, 0x74373489, 0x22117647),\n    ivec4(0x11111111, 0x11111111, 0x88821818, 0x44761311),\n    ivec4(0x88014544, 0x80888888, 0x74474434, 0x22185047),\n    ivec4(0x11111111, 0x11111111, 0x88828818, 0x44561311),\n    ivec4(0x59434444, 0x95091101, 0x4D4744D4, 0x82185047),\n    ivec4(0x11111111, 0x11111111, 0x82888818, 0x44571588),\n    ivec4(0x4D444444, 0x9990930, 0x4D7444DD, 0x88115047),\n    ivec4(0x11111121, 0x11111111, 0x22228888, 0x44671588),\n    ivec4(0x4D44DD44, 0x9B000040, 0xD474D4DD, 0x88115047),\n    ivec4(0x11118122, 0x18111111, 0x22828881, 0x4D671581),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4D4DD7DD, 0x11115047),\n    ivec4(0x88882882, 0x18111111, 0x22228882, 0x4D640581),\n    ivec4(0xDD444DD4, 0xDDBD19E0, 0x4D4D34DD, 0x11115144),\n    ivec4(0x88882288, 0x88111111, 0x22222288, 0xDD640588),\n    ivec4(0xDDDDDDD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115144),\n    ivec4(0x21822228, 0x88111111, 0x22222288, 0xDD640528),\n    ivec4(0xDDDDDDDD, 0xDDDDDDE3, 0xDDDD34DB, 0x11115144),\n    ivec4(0x28822228, 0x88111181, 0x22222288, 0xDB540588),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x88882222, 0x88181181, 0x22222288, 0xDF540588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151B4),\n    ivec4(0x88222222, 0x88181181, 0x88888888, 0xDF540388),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x99992222, 0x88181100, 0x88888888, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88222282, 0x88110081, 0x88888888, 0xEF3D0318),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9FE),\n    ivec4(0x88882988, 0x88018188, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDE, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88882288, 0x88108888, 0x88888888, 0xEF3DE380),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEF, 0xFEFFDB4D, 0x8898FEEF),\n    ivec4(0x88889810, 0x88808888, 0x88888888, 0xEFBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFFF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88889810, 0x18898888, 0x88888888, 0xBFEDFF9E),\n    ivec4(0xFEFFFFFF, 0xFBFFFFFF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88880188, 0x1898888, 0x80881801, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFFF, 0xEFEEFEDF, 0x88F1FFFF),\n    ivec4(0x88181088, 0x88118888, 0x9F101181, 0xEEEEFFEF),\n    ivec4(0xEFFFFFFF, 0xFEFFFFFF, 0xFFFEFFBF, 0x88E9FFFF),\n    ivec4(0x81018188, 0x88998818, 0x9B888888, 0xFFEFFEEF),\n    ivec4(0xEFFEFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFFF),\n    ivec4(0x99818888, 0x99000011, 0x2C888801, 0xFFEEBBCC),\n    ivec4(0xFFEEFEFF, 0x99FFFFFF, 0x89F9FF9F, 0x98FFFFFF),\n    ivec4(0x10888888, 0x880088, 0x9E991981, 0xEEBBCCCC),\n    ivec4(0xFFEEFEFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x81888888, 0x80880800, 0xEEBE8918, 0xCCCCBCBB),\n    ivec4(0xFFEEFFEE, 0xF9FFFFFF, 0x1192EE9E, 0xE9FFFF9E),\n    ivec4(0x88888888, 0x88881819, 0xFFDE8901, 0xCCCCBCEB),\n    ivec4(0xFFEFBECB, 0xFFFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x88888888, 0x81881880, 0xFFBF1200, 0xCCCCBCFE),\n    ivec4(0xFFBECBCC, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x88888888, 0x82880881, 0x9F909911, 0xCCCCECEE),\n    ivec4(0xEEBBCCCC, 0xFEFFFFFF, 0x19888828, 0xFFFFEF81),\n    ivec4(0x88888888, 0x88882888, 0x9102922, 0xBBCCEEEE),\n    ivec4(0xBBCCCCCC, 0xFEFFFFEF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x82888888, 0x18882222, 0x10819A, 0xCBCCFE3E),\n    ivec4(0xCCCCCCCC, 0xFEFFFFBE, 0x88888898, 0xFEFF9E88),\n    ivec4(0x22888888, 0x9882922, 0x8198AC, 0xCBCCFE9E),\n    ivec4(0xCCCCBCBB, 0xFEFFBECB, 0x88888898, 0xFFEFFE88),\n    ivec4(0x22888888, 0x8A282222, 0x88C2CC, 0xCCCCFE03),\n    ivec4(0xCCCCBCBB, 0xFFEFCBCC, 0x88888898, 0x9F93B88),\n    ivec4(0x28828888, 0x82288888, 0x1088CACC, 0xCCCCEE03),\n    ivec4(0xCCCCBBBB, 0xEFEFCBCC, 0x888888A2, 0x1191BB09),\n    ivec4(0x88228888, 0x82218888, 0x1098CCCC, 0xCCBCFE90),\n    ivec4(0xCCBCBDBB, 0xE9EFBBBB, 0x990992AA, 0x1899993B),\n    ivec4(0x88228888, 0x89222888, 0x10A8CCCC, 0xCCBC0B88),\n    ivec4(0xCCBBBBBB, 0xE9FFBBBB, 0x9B9BB9C, 0x819993B),\n    ivec4(0x0, 0x1000000, 0x102211, 0x47030000),\n    ivec4(0x66666666, 0x66666677, 0x66667766, 0x6066),\n    ivec4(0x0, 0x1000000, 0x102212, 0x76540000),\n    ivec4(0x66776667, 0x66666677, 0x66667766, 0x7666),\n    ivec4(0x0, 0x1000000, 0x101111, 0x77340000),\n    ivec4(0x67766777, 0x66666675, 0x66466466, 0x6766),\n    ivec4(0x0, 0x1000000, 0x1111, 0x47470000),\n    ivec4(0x65766777, 0x66666655, 0x66476466, 0x506667),\n    ivec4(0x1100, 0x0, 0x1010, 0x77470500),\n    ivec4(0x70766776, 0x66666605, 0x66476766, 0x707667),\n    ivec4(0x11111111, 0x1011, 0x0, 0x77770400),\n    ivec4(0x51667446, 0x76677705, 0x66446766, 0x767667),\n    ivec4(0x99228211, 0x1008, 0x0, 0x77770400),\n    ivec4(0x68677776, 0x47667705, 0x66447766, 0x757666),\n    ivec4(0xCC2A2288, 0x1020A2, 0x0, 0x77775400),\n    ivec4(0x8657576, 0x77565503, 0x66447766, 0x657766),\n    ivec4(0xBBAC2222, 0xC9DB, 0x0, 0x74773400),\n    ivec4(0x88555577, 0x55365013, 0x56447456, 0x677766),\n    ivec4(0xCBAB2222, 0x99BBDB, 0x0, 0x74743410),\n    ivec4(0x88550977, 0x59575185, 0x56446456, 0x677766),\n    ivec4(0xCB9C2222, 0xCABC, 0x0, 0x43743710),\n    ivec4(0x88359535, 0x39533089, 0x56337335, 0x677776),\n    ivec4(0xCB2C2222, 0x11C9BC, 0x1000000, 0x45745715),\n    ivec4(0x88391035, 0x30153981, 0x56395355, 0x60677777),\n    ivec4(0xCCAC2222, 0x1111C9CC, 0x0, 0x39755715),\n    ivec4(0x88308835, 0x31809188, 0x35993913, 0x60677777),\n    ivec4(0xCCAC2222, 0x1011C0CB, 0x190, 0x30455705),\n    ivec4(0x88188893, 0x1888888, 0x33993989, 0x60676776),\n    ivec4(0xCCAC2222, 0x9300B9CB, 0x1B5, 0x98435603),\n    ivec4(0x88888880, 0x88888888, 0xA3991181, 0x60676746),\n    ivec4(0xCCCC2222, 0xBB9390CC, 0x11B3, 0x88757703),\n    ivec4(0x88181188, 0x88888888, 0x93198888, 0x676746),\n    ivec4(0xCCCC2282, 0xBB3B21CC, 0x110011D3, 0x88757405),\n    ivec4(0x88189010, 0x1118888, 0xB31A8888, 0x676746),\n    ivec4(0xCCCC2282, 0xCBBB29CA, 0x111100B9, 0x1755705),\n    ivec4(0x8898DB93, 0x33938188, 0x35898890, 0x657746),\n    ivec4(0xCCCC8222, 0xBBBBABC9, 0x110000C0, 0x9476705),\n    ivec4(0x88B099BB, 0x9BB38088, 0x558008DB, 0x11657746),\n    ivec4(0xCCCC8222, 0xBDCBBCCC, 0x10010A1, 0x9B437405),\n    ivec4(0x88188838, 0x88088888, 0x5789B89D, 0x81657747),\n    ivec4(0xCCCC8222, 0xCACCCCBC, 0x1190, 0xBBBB4403),\n    ivec4(0x88888888, 0x88888888, 0x5789B982, 0x88757747),\n    ivec4(0xCCCC8218, 0x91CCCCCC, 0x9110010, 0xB9BBBB9B),\n    ivec4(0x88888888, 0x88888888, 0x57891188, 0x22707746),\n    ivec4(0xCCCC8911, 0x11C9CCCC, 0x3010011, 0xA1BBCCBB),\n    ivec4(0x88888891, 0x88888888, 0x54158888, 0x22507646),\n    ivec4(0xCCCC8011, 0x1191CCCC, 0x9B001011, 0x98BBBBBB),\n    ivec4(0x88888800, 0x88888888, 0x64058888, 0x22507576),\n    ivec4(0xCCBC8011, 0x1111C9CC, 0xBC931111, 0x98BBBCCC),\n    ivec4(0x88111181, 0x11818888, 0x64058888, 0x22527567),\n    ivec4(0xCC3C1011, 0x111191CA, 0xBC3B1111, 0x18B3BBCC),\n    ivec4(0x33339388, 0xB9333399, 0x74958888, 0x22527767),\n    ivec4(0xCC3C1111, 0x11111191, 0xCCBC1911, 0x18B9BDCC),\n    ivec4(0xDDDD1388, 0xD3DDDDDD, 0x77958888, 0x28025564),\n    ivec4(0xC93C1111, 0x11111111, 0xCBCC9B11, 0x843CBBC),\n    ivec4(0xBBDB8988, 0xD9DDDDB3, 0x46558888, 0x28025574),\n    ivec4(0xC99B1111, 0x11111181, 0xCCCC3C10, 0x50449BC9),\n    ivec4(0x33338188, 0x383D3333, 0x76378088, 0x28125544),\n    ivec4(0xC99B1111, 0x11111111, 0xC9CCBC03, 0x43449B99),\n    ivec4(0x33938808, 0x18393333, 0x77341388, 0x22117547),\n    ivec4(0xB99B1111, 0x11111111, 0xCCCCCC9C, 0xDDBDBBBB),\n    ivec4(0x1918D3, 0x88189099, 0x74373489, 0x22117647),\n    ivec4(0x99931111, 0x19111111, 0xCCCCCCBC, 0xBDCBBCCC),\n    ivec4(0x889945D4, 0x80888888, 0x7D474434, 0x82185047),\n    ivec4(0x80001111, 0x13111111, 0xCCCCCCCC, 0xBDCCBBCC),\n    ivec4(0x39444444, 0x95091101, 0x4D4744D4, 0x88115047),\n    ivec4(0x80011811, 0x9B111111, 0xCCCCCCCC, 0xDDBBBBCC),\n    ivec4(0xDD444444, 0x9900930, 0xDD7444DD, 0x88115047),\n    ivec4(0x81008821, 0x3C111111, 0xCCACAACA, 0xBDBBCDCC),\n    ivec4(0x4D44DD44, 0x9B000030, 0x4474D4DD, 0x11115047),\n    ivec4(0x88121822, 0xA101101, 0x222288C2, 0x4D449B92),\n    ivec4(0x4D44DD44, 0xDD0300B0, 0x4444D7DD, 0x11115047),\n    ivec4(0x88822282, 0x82111101, 0x22228292, 0xDD442328),\n    ivec4(0xDD444DD4, 0xDDBD19B0, 0x4D4D34DD, 0x11115144),\n    ivec4(0x88222288, 0x82181101, 0x22222228, 0xDD441322),\n    ivec4(0xDDDD4DD4, 0xDDDD9DE0, 0x4DDD44DD, 0x11115144),\n    ivec4(0x88228228, 0x10111121, 0x22222228, 0xDD740328),\n    ivec4(0xDDDDDDDD, 0xDDDDDDEF, 0xDDDD34DB, 0x11115144),\n    ivec4(0x28222222, 0x11111181, 0x22222288, 0xDB7D0528),\n    ivec4(0xDDDDED33, 0xDDDDDDDD, 0xDDDD44D3, 0x111151D4),\n    ivec4(0x28222222, 0x18118180, 0x28228288, 0xDE7D0588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xEEDB4DB3, 0x111151B4),\n    ivec4(0x92822222, 0x88880119, 0x88888888, 0xBF5D0588),\n    ivec4(0xDDDDFEFF, 0xDDDDDDDD, 0xFFBF4D34, 0x111131FB),\n    ivec4(0x92822222, 0x88010981, 0x88888888, 0xEF5D0381),\n    ivec4(0xDDDDFFFF, 0xDDDDDDDD, 0xFFEFDD34, 0x1181E0FE),\n    ivec4(0x88222822, 0x18908988, 0x88888888, 0xEF3D0318),\n    ivec4(0xDDEDFFFF, 0xEBEEDDDD, 0xFFEFDB3D, 0x8818E9EE),\n    ivec4(0x88288822, 0x18898088, 0x88888888, 0xEF3D9D81),\n    ivec4(0xEDEEFFFF, 0xEBEEEEDB, 0xFFFFDB4D, 0x8108FEEE),\n    ivec4(0x88188888, 0x18891088, 0x88888888, 0xEF3DEE80),\n    ivec4(0xFEFFFFFF, 0xE3EEFFEE, 0xFEFFDB4D, 0x8898FEEF),\n    ivec4(0x88188188, 0x18198088, 0x88888888, 0xEFBDEF89),\n    ivec4(0xFEFFFFFF, 0xFEFFFFEF, 0xFEFFBDDB, 0x88F8FFFF),\n    ivec4(0x88088188, 0x88008188, 0x88888888, 0xBFEDFF9F),\n    ivec4(0xFEFFFFFF, 0xFBFFFFEF, 0xEEEFEBDE, 0x88F8FFFF),\n    ivec4(0x88088188, 0x88188888, 0x80888888, 0xEFFDFFEF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFEF, 0xEFEEFEDF, 0x88F1FFFF),\n    ivec4(0x88088188, 0x88918888, 0xF888888, 0xEEEEFFFF),\n    ivec4(0xEEFFFFFF, 0xFEFFFFEF, 0xFFFEFFBF, 0x88E9FFFF),\n    ivec4(0x88118888, 0x88998888, 0xFE818888, 0xFFEFFEFF),\n    ivec4(0xEFFFFFFF, 0xF9FFFFFF, 0xEEFEFF9F, 0x88FFFFEF),\n    ivec4(0x88108888, 0x8118088, 0xFF198888, 0xFFFFEEFF),\n    ivec4(0xFEEEFEFF, 0x99FFFFFF, 0x89F9FF9F, 0x98FEFFFF),\n    ivec4(0x18818888, 0x11880988, 0xFF9E8188, 0xFFFFEFFF),\n    ivec4(0xFEEEFEFF, 0x99FFFFFF, 0x10E9EE99, 0xF8FFFFFE),\n    ivec4(0x19888888, 0x80889099, 0xFFBF8918, 0xFFFFEFFF),\n    ivec4(0xFEEFFFFF, 0xF9FFFFFF, 0x1192EE9E, 0xE9FFFF9E),\n    ivec4(0x89888888, 0x88889800, 0xFFDE8908, 0xFFFFFFFE),\n    ivec4(0xFEEFFFFF, 0xFFFFFFFF, 0x888892EE, 0xFFFFEF8F),\n    ivec4(0x81888888, 0x88889888, 0xFFBF1981, 0xFFFFFFFE),\n    ivec4(0xFEEFFFFF, 0xFFFFFFFF, 0x10888898, 0xFEFFEF89),\n    ivec4(0x18888888, 0x88889888, 0x9F909981, 0xFFFFFFEE),\n    ivec4(0xEFEFFFFF, 0xFEFFFFFF, 0x19888828, 0xFFFFFF81),\n    ivec4(0x28888888, 0x88889188, 0x9109988, 0xFFFFFFEE),\n    ivec4(0xEFEFFFFF, 0xFEFFFFFF, 0x80888828, 0xFFFFFE88),\n    ivec4(0x28888888, 0x88889988, 0x108188, 0xFFFFFF3E),\n    ivec4(0xFFEFFFFF, 0xFEFFFFFF, 0x88888898, 0xFEFF9E88),\n    ivec4(0x28828888, 0x88889988, 0x818888, 0xFFFFFF9E),\n    ivec4(0xFFEFFEFF, 0xFEFFFFFF, 0x88888898, 0xFFEFFE88),\n    ivec4(0x88828888, 0x88282282, 0x888888, 0xFFFFFF03),\n    ivec4(0xFFEFFEFF, 0xFFFFFFFF, 0x88888898, 0x9F93B88),\n    ivec4(0x88228888, 0x88288882, 0x10888888, 0xFFFFEF03),\n    ivec4(0xFFEEFEFF, 0xEFFFFFFF, 0x888888A2, 0x11913B09),\n    ivec4(0x88A28288, 0x88222889, 0x10888888, 0xFFFFFE90),\n    ivec4(0xEEDDEDFE, 0xE9FFFFFF, 0x990992AA, 0x1899993B),\n    ivec4(0x88A28288, 0x88222229, 0x10888888, 0xEEEE0E18),\n    ivec4(0xEEEDEEEE, 0xE9FFFFEE, 0x9B9BB9C, 0x819993B)\n#endif\n);\n\n\n#ifdef ENABLE_VIBING_CAT\n\nconst int vibingCatBorderWidth = 2;\n\nconst int vibingCatBorderHeight = 2;\n\nconst int vibingCatBorderColorIndex = 0;\n\nconst int vibingCatImageWidth = 16;\n\nconst int vibingCatImageHeight = 16;\n\nconst int vibingCatImageCount = 147;\n\nconst int vibingCatRepeatAtImageIndex = 74;\n\nconst int vibingCatRepeatingFrameCount = vibingCatImageCount - vibingCatRepeatAtImageIndex;\n\nconst int vibingCatAnimationFrameCount = vibingCatImageCount + (vibingCatImageCount - vibingCatRepeatAtImageIndex);\n\nconst vec3 vibingCatBitmapPalette[] = vec3[]\n(\n        vec3(0.15294117647058825, 0.1411764705882353, 0.1450980392156863),\n        vec3(0.27450980392156865, 0.23137254901960785, 0.2196078431372549),\n        vec3(0.24313725490196078, 0.25098039215686274, 0.24705882352941178),\n        vec3(0.3137254901960784, 0.25882352941176473, 0.23921568627450981),\n        vec3(0.2196078431372549, 0.23921568627450981, 0.25882352941176473),\n        vec3(0.28627450980392155, 0.24313725490196078, 0.2549019607843137),\n        vec3(0.23529411764705882, 0.25882352941176473, 0.27450980392156865),\n        vec3(0.403921568627451, 0.34509803921568627, 0.32941176470588235),\n        vec3(0.5882352941176471, 0.45098039215686275, 0.41568627450980394),\n        vec3(0.6392156862745098, 0.5215686274509804, 0.4823529411764706),\n        vec3(0.5764705882352941, 0.49019607843137253, 0.5058823529411764),\n        vec3(0.49019607843137253, 0.5019607843137255, 0.5058823529411764),\n        vec3(0.6901960784313725, 0.596078431372549, 0.5568627450980392),\n        vec3(0.7843137254901961, 0.6941176470588235, 0.6588235294117647),\n        vec3(0.8196078431372549, 0.7686274509803922, 0.7333333333333333),\n        vec3(0.8784313725490196, 0.8509803921568627, 0.8196078431372549)\n);\n\nconst ivec4 vibingCatBitmapBits[] = ivec4[]\n(\n        ivec4(0xFFDEFFDE, 0xDCCCEB, 0xDFDCFFFF, 0xDBDDFE),\n        ivec4(0xBCFCFFEF, 0xD1FDFF, 0x17F7FFEF, 0x80FE9F),\n        ivec4(0x67FCFFCD, 0x70FEBE, 0xEDFFEF8C, 0x70FFEF),\n        ivec4(0xFFFF9D88, 0xD2FFFF, 0xFFFF9E87, 0xE3FFFF),\n        ivec4(0xFFFFCE88, 0x11FBFFFF, 0xFFFFCD89, 0x10FCFFFF),\n        ivec4(0xEFDD9C89, 0x20FCEFFF, 0xEFCDCC89, 0x78FCEEFE),\n        ivec4(0xDECD9C89, 0xCCFDEDFE, 0xDDCC9988, 0xCCEDDEED),\n        ivec4(0xCDCC8888, 0x99D9DECD, 0xCCC99888, 0x89C9CDCC),\n        ivec4(0xDEDCFFEF, 0xD7DDFE, 0xACEAFFDF, 0xC1EDEF),\n        ivec4(0x17FBFFCD, 0x80FDCF, 0x8BFDEF9C, 0x30FD9F),\n        ivec4(0xFEFFCE88, 0x70FFEF, 0xFFFF9E88, 0x90FFFF),\n        ivec4(0xFFFF9D88, 0x20D3FFFF, 0xFFFFCD89, 0x10F7FFFF),\n        ivec4(0xEFDE9D88, 0xF9FFFF, 0xFFDD9C89, 0x30FCEFFF),\n        ivec4(0xDECC9C89, 0x36FADEFF, 0xDECC9C88, 0x7AFCEEFE),\n        ivec4(0xDDCC8988, 0xCCEDDEDD, 0xDDCC8988, 0xC9DCDECD),\n        ivec4(0xCC9C9989, 0x98CCCECC, 0xCC999C89, 0x9C99CDCC),\n        ivec4(0x8CC8FFCE, 0x90DDFE, 0x1AE3EF9C, 0x30EDDF),\n        ivec4(0xACFECF88, 0xFCDF, 0xFFFFCF88, 0x10FDFF),\n        ivec4(0xFFFFDE88, 0x71FFFF, 0xFFFFCD89, 0x71FFFF),\n        ivec4(0xEFDECD89, 0xD2FFFF, 0xFFDD9C89, 0xF7FFFE),\n        ivec4(0xDFCD9C88, 0x32E7EFFE, 0xDECC9988, 0xE3DFFE),\n        ivec4(0xDECC8988, 0x53F7DEDD, 0xCDCC8988, 0xA9D7DECD),\n        ivec4(0xCDCC9C99, 0xCCDCDECD, 0xCCCC9C9C, 0x99CCDECC),\n        ivec4(0xCCCC9C9C, 0x9999DD9C, 0xCC99999C, 0x9C98DCCC),\n        ivec4(0x79A3EF9C, 0x70DDEF, 0x79EBDF78, 0xDCDF),\n        ivec4(0xFFFFDF79, 0xE9FF, 0xFFFFDE89, 0x30FCFF),\n        ivec4(0xFFDECD89, 0x30FDFE, 0xFFDECC89, 0x30FFEE),\n        ivec4(0xEFCD9C89, 0xC2FFEE, 0xDFCD9C88, 0x10C3FFED),\n        ivec4(0xDECC8988, 0xA0DFED, 0xDDCC8988, 0x10D3DEDD),\n        ivec4(0xCCCC9988, 0x7C2DECC, 0xCC9C9999, 0x8A87DECC),\n        ivec4(0xCCCCCC9C, 0x9C9CEDCC, 0xCCC9CC99, 0x89C9DDCC),\n        ivec4(0x9C9CCC99, 0x8998DC9C, 0xCC999999, 0x9C88D9CC),\n        ivec4(0x39C3DF88, 0x70DDEF, 0xACFDCF77, 0xDCDF),\n        ivec4(0xFFFFDE89, 0xFAFF, 0xFFEFCE89, 0x10FCFF),\n        ivec4(0xFFDD9D89, 0x10FDFE, 0xEFCD9C89, 0x70FFEE),\n        ivec4(0xEFCD8988, 0xC1EFEE, 0xDE9D8988, 0xB1EFED),\n        ivec4(0xDDCC8888, 0xA0DFDD, 0xDCCC8988, 0x11C0DECD),\n        ivec4(0xCC9C9999, 0x193DECC, 0xCCC9CC99, 0x8A77DECC),\n        ivec4(0xC99CCC9C, 0xC989DDCC, 0xCCCCCC99, 0x89C9DCCC),\n        ivec4(0xC999C999, 0x8998DCCC, 0x9C999999, 0x9C88C9CD),\n        ivec4(0x39E79F87, 0x30DDEE, 0xCDFF9E87, 0xD9EF),\n        ivec4(0xFFFFCE88, 0x10FBFF, 0xFFEE9D89, 0x10F9EF),\n        ivec4(0xEFCD9C88, 0xFDFE, 0xEFCD9C88, 0x80FFEE),\n        ivec4(0xDFCC8878, 0xC2FFED, 0xDECC8878, 0x70EFDD),\n        ivec4(0xDD9C8888, 0x1092DFDD, 0xCC9C9988, 0x1C0DECC),\n        ivec4(0xCCC99999, 0x1083DECC, 0x9CCCCC9C, 0x7A33DDCC),\n        ivec4(0xCCC9CC9C, 0xCC89DCCC, 0x9CCC9C9C, 0x9899ECCC),\n        ivec4(0x9C999C99, 0x8899DCCC, 0x9C999999, 0x8C88C9CC),\n        ivec4(0x39E88F77, 0x10DDEF, 0xEEFFDF88, 0xD9EF),\n        ivec4(0xFFEFCD88, 0xFBFF, 0xFFDE9D88, 0x10F9EF),\n        ivec4(0xEFCD9C88, 0x20FCFE, 0xEFCD9988, 0x70FFFE),\n        ivec4(0xDE9C8878, 0xC3EFED, 0xDECC8888, 0x70EFDD),\n        ivec4(0xDD9C8888, 0x1095DFCD, 0xCC9C9C99, 0x1C0DECC),\n        ivec4(0x9C9CCC99, 0x3073DFCC, 0xCCCCCCC9, 0x7A11DDCC),\n        ivec4(0xC9C9CC9C, 0x9C8AECCC, 0xCCCC9C9C, 0x99C9DCCD),\n        ivec4(0xCCC9C999, 0x8899D9CD, 0x9C999999, 0x8C88C9CD),\n        ivec4(0x39E8CF77, 0x10DDEE, 0xFEFFDF89, 0x10D9FF),\n        ivec4(0xFFEFCE88, 0xF7FF, 0xFFDECC88, 0xF8EF),\n        ivec4(0xEFCE9C88, 0x20FCFE, 0xEFCD9988, 0x70FFEE),\n        ivec4(0xDECD8887, 0xA0FFED, 0xDDCC8888, 0x70DFDD),\n        ivec4(0xDCCC9998, 0x1082DFCD, 0xCC9C9999, 0xA1DFCC),\n        ivec4(0x9CCCCC9C, 0x1073EECC, 0xCCCCCCC9, 0x7A10ECCC),\n        ivec4(0xCCC9CC9C, 0xC98AE9CC, 0xCCCC9C9C, 0x99C9D9CD),\n        ivec4(0xCCC9C999, 0x8899DCCD, 0x9C999999, 0x8C88C9CD),\n        ivec4(0x7CE7CF78, 0x10DCFE, 0xFEFFDF8C, 0x10D9FF),\n        ivec4(0xFFEFCE89, 0xF7FF, 0xFFEECC88, 0xF8EF),\n        ivec4(0xEFCE9C88, 0xF9EF, 0xEFCD9C88, 0x30FFEF),\n        ivec4(0xDFCD8887, 0xB0EFDD, 0xDDCC8988, 0x70EEDD),\n        ivec4(0xDCCC9999, 0x1073DFCD, 0xCC9CC999, 0xA0DFCC),\n        ivec4(0x9CCCCC9C, 0x1033EECD, 0xCCCCCC9C, 0x7A11ECCC),\n        ivec4(0xC99CCCCC, 0x9C89E8CC, 0xCC9CCCC9, 0x99C9DCCD),\n        ivec4(0xCCCCC999, 0x8899D9DD, 0x9C999999, 0x9C88C9CD),\n        ivec4(0x7CFBDF78, 0xDCFE, 0xFFFFDF89, 0xD8FF),\n        ivec4(0xFFEFCD89, 0xE7FF, 0xFFDECC89, 0x10F7EF),\n        ivec4(0xFFDD9988, 0xF9EF, 0xEFCD9978, 0x30FEEF),\n        ivec4(0xDECD8888, 0x70EFDD, 0xDD9D9988, 0x70EEDD),\n        ivec4(0xCCCC9999, 0x1171DFCD, 0xCCCCCC9C, 0xB0EECC),\n        ivec4(0xCC9CCCCC, 0x1131EDCD, 0xCCCCCCCC, 0x8901E9CC),\n        ivec4(0xCCCCCCC9, 0xC999E8CD, 0xCCCCCCCC, 0x98C9DCCD),\n        ivec4(0xCC9CC999, 0x8998D9DD, 0x9C999999, 0x9C88C9CC),\n        ivec4(0xACFDEF89, 0x10DDFF, 0xFFFFCF89, 0xE9FF),\n        ivec4(0xFFEECD88, 0xF8FF, 0xFFDE9C89, 0x10FAEF),\n        ivec4(0xFFCD9C88, 0x10FDEF, 0xEFCD8988, 0x80FFEE),\n        ivec4(0xDECD8988, 0x70FFDD, 0xDDCC9998, 0xB1EFDD),\n        ivec4(0xCCCCC999, 0x1180DFCC, 0xCCCCCC9C, 0xB1EEDC),\n        ivec4(0xCCC9CCCC, 0x1331EECC, 0xCCCCCCCC, 0xA913ECCC),\n        ivec4(0xCCCCCCCC, 0x9C8CE9CD, 0xCCCCCCCC, 0x99C9DCCD),\n        ivec4(0xCCCCC999, 0x8C99D9DD, 0xCC999999, 0xCC88C9DC),\n        ivec4(0x7AF9DF79, 0x80EDDF, 0xFEFFEF8C, 0x70FDFF),\n        ivec4(0xFFFFDE8C, 0x71FEFF, 0xFFEFCD89, 0x71FEFF),\n        ivec4(0xFFDECC89, 0xB0FFFF, 0xFFCDCC89, 0xD3FFFE),\n        ivec4(0xEFCD8988, 0x20F7EFFE, 0xDECC9988, 0x10E7EFEE),\n        ivec4(0xDDCD9999, 0x23E7DFDD, 0xCCCCC999, 0xF8DECC),\n        ivec4(0xCCCCCCCC, 0x37C7DFDC, 0xCCCCCCCC, 0x9997DFCD),\n        ivec4(0xCCCCCCCC, 0xC9CCDECD, 0xCCCCCCCC, 0x99C9DDCD),\n        ivec4(0xCCCCCC99, 0x8C99DCCD, 0xCC999999, 0xCC89CCCD),\n        ivec4(0x89D8FFDF, 0xD8FDEF, 0x38E7FFCE, 0xD3FECF),\n        ivec4(0xEDFFEF8C, 0xC1FFDF, 0xFFFFFF8C, 0x10C1FFFF),\n        ivec4(0xFFFFEF9D, 0x40E3FFFF, 0xFFFFDE9C, 0x10E7FFFF),\n        ivec4(0xFFDEDD9C, 0x20FAFFFF, 0xFFDECC99, 0x71FDFFFE),\n        ivec4(0xEFDDCC99, 0x74FEEFFF, 0xEECD9C89, 0x71FDDFFE),\n        ivec4(0xDDCD9C89, 0x77FEDEDD, 0xDDCC9C99, 0xCCFEDEDD),\n        ivec4(0xCCCCCCC9, 0xCCFDDECC, 0xCDCCCCCC, 0x99ECDECC),\n        ivec4(0xCCCCCCCC, 0x9CC9DDCC, 0xCC999999, 0xCDC9DDCC),\n        ivec4(0x9DDCFFFF, 0xDDEDEF, 0x78C7FFFF, 0xD9FEDF),\n        ivec4(0x13F7FFDE, 0xE7FF8D, 0xECFFFF9D, 0xD3FFDF),\n        ivec4(0xFFFFEF79, 0xF7FFFF, 0xFFFFFFCE, 0x72FAFFFF),\n        ivec4(0xFFFFEFCD, 0x34FDFFFF, 0xFFFFDECD, 0x70FEFFFF),\n        ivec4(0xFFDEDD9C, 0xB2FFFFFF, 0xFFDECC9C, 0xC7FFEFFF),\n        ivec4(0xEFDDCC9C, 0xCBFFEEFF, 0xEECDCC99, 0xDCFFDEFE),\n        ivec4(0xDDCD9C89, 0xECEFDDED, 0xDDCD9C89, 0xC9EEDDDD),\n        ivec4(0xCC9C9C99, 0xCCEDDDCC, 0xCCC99999, 0xCDDCCDCC),\n        ivec4(0x7CC8FFEF, 0xD9FDEF, 0x17C7FFDF, 0xD7FF9F),\n        ivec4(0xB9FEFF9D, 0xD1FFCE, 0xFFFFFF8D, 0xD5FFFF),\n        ivec4(0xFFFFFFCD, 0x21F7FFFF, 0xFFFFFFCD, 0x31FAFFFF),\n        ivec4(0xFFEFDECD, 0x64FDFFFF, 0xFFEFDDCC, 0x70FEFFFF),\n        ivec4(0xEFDECD9C, 0xA2FFEFFF, 0xFFDDCC9C, 0xC7FFEFFF),\n        ivec4(0xDFDDCC9C, 0xCBFFEEFF, 0xDECD9C99, 0xDCFFDEFE),\n        ivec4(0xDECD9C89, 0xECEFDDDD, 0xDDCC9C89, 0xC9EEDDDD),\n        ivec4(0xCCCC9C99, 0xCDEDCDCC, 0xCC9C9989, 0xCDDDCDCC),\n        ivec4(0x78C7FFCE, 0x90EDDF, 0xDDFFFFCE, 0x80FDEF),\n        ivec4(0xFFFFFFDE, 0x1080FFFF, 0xFFFFEECD, 0x10A2FFFF),\n        ivec4(0xFFEFEDCC, 0x10C6FFFF, 0xFFEFDD9C, 0xE3FFFE),\n        ivec4(0xFFDDCC9C, 0x20FBFFFE, 0xFFDDCC9C, 0x31FCFFFD),\n        ivec4(0xEFDD9C99, 0x74FEEEFE, 0xDECD9C89, 0x75FDDFEE),\n        ivec4(0xDDCD9C89, 0xB8FEDEDD, 0xDCCC9C89, 0xCCFEDDDC),\n        ivec4(0xDCCC9C99, 0xC9EDDDCC, 0xCDCCC999, 0xC9ECDECC),\n        ivec4(0xC9C9999C, 0xCDD9CDCC, 0x99999999, 0xDCCCCDCC),\n        ivec4(0xEEFEEFDE, 0x10DCEE, 0xFFFFDECD, 0x10E9FF),\n        ivec4(0xFFEFDDCC, 0x20FCFE, 0xFFDECDAC, 0x30FDEE),\n        ivec4(0xFFDECC99, 0x70FEDE, 0xEFCDCCAA, 0xA1FFDE),\n        ivec4(0xEFCE9C88, 0xE7EFDD, 0xDDCD9C88, 0x10E7EFDD),\n        ivec4(0xCDCD9988, 0x62E7DECD, 0xCCCC9C88, 0x1F7DECC),\n        ivec4(0xCCCC9999, 0x7AEBCECC, 0xCC999999, 0xC9DCDECC),\n        ivec4(0x9C9C9999, 0x98C9DECC, 0x99999C9C, 0x89C8DDCC),\n        ivec4(0x9C999999, 0xCD98DC9C, 0x99999989, 0xCC8CC99C),\n        ivec4(0xFEEFDECD, 0xD8FE, 0xFFEFDDAC, 0xE7EF),\n        ivec4(0xFEDECD89, 0x10FBEE, 0xFEDEACA9, 0xF8DE),\n        ivec4(0xEEDD9C88, 0x60FEDE, 0xEECDA988, 0x80FFDD),\n        ivec4(0xDDCD8988, 0xB2DFDD, 0xCCCC8C88, 0x11B2DFCD),\n        ivec4(0xCCCC8988, 0xC1DECC, 0x9C9C9999, 0x10D3DECC),\n        ivec4(0x9C999899, 0x7873DECC, 0x99999999, 0x99B8DECC),\n        ivec4(0x9999C999, 0x8899DDCC, 0x99C99999, 0x8898DCCC),\n        ivec4(0x99999999, 0xCD88C9CC, 0x99999989, 0xCC9998CC),\n        ivec4(0xFEEFDD8C, 0xD3FE, 0xFEDECD8A, 0xE3EF),\n        ivec4(0xFEDD9C88, 0xE3EE, 0xEECDAC88, 0xF3DE),\n        ivec4(0xEECD8978, 0x70FDDE, 0xDDCC8987, 0x70EEDD),\n        ivec4(0xDC9C8988, 0x76DECD, 0xCCCC8988, 0x70DFCC),\n        ivec4(0x9C898888, 0xB1DE9C, 0x99899999, 0x171DE9C),\n        ivec4(0x99999999, 0x3710EDCC, 0x99999999, 0x9978DC9C),\n        ivec4(0x89999999, 0x8899DC9C, 0x99999999, 0x8888D9CC),\n        ivec4(0x99999898, 0x8C88C8CC, 0x99898988, 0xCC8998CC),\n        ivec4(0xFEEECD89, 0xC1FE, 0xFEDE9C8A, 0xC3EF),\n        ivec4(0xFEDDAC88, 0xC2DF, 0xEECD8A78, 0xE1DF),\n        ivec4(0xDECD8878, 0x20FCDE, 0xCDCC8887, 0x30EECD),\n        ivec4(0xCCCC8888, 0x24EDCD, 0xCC9C9888, 0x70DECC),\n        ivec4(0x99899899, 0x72DE9C, 0x99899999, 0x11ED9C),\n        ivec4(0x99999999, 0x710ECCC, 0x99999999, 0x8917D89C),\n        ivec4(0x99999999, 0x98A8D89C, 0x99999999, 0x8898C9CD),\n        ivec4(0x99999898, 0x898898CD, 0x99898988, 0xCC8888CC),\n        ivec4(0xFFEFCE89, 0x91FD, 0xFEDECC8A, 0xA0FF),\n        ivec4(0xFEDE9C88, 0xB0EF, 0xEECD8978, 0xD1DF),\n        ivec4(0xEDCD8987, 0xFBDF, 0xDCCC8988, 0x10FCDD),\n        ivec4(0xCCCD8988, 0x1020FACD, 0xCCA99899, 0x30EDCC),\n        ivec4(0x99899999, 0x32EECC, 0x9999C999, 0x10F9CD),\n        ivec4(0x9C999C9C, 0x300E8CD, 0x99C99999, 0x8907D39D),\n        ivec4(0x9CC9C999, 0x999997CD, 0x9C9C9999, 0x8898C9DD),\n        ivec4(0xCC999999, 0x898899CD, 0x9C999988, 0xCC8898C9),\n        ivec4(0xFFEFDE9C, 0x1080FD, 0xFFEFCD8A, 0x70FF),\n        ivec4(0xFEDFCC88, 0x70EF, 0xFDDEAC78, 0xA0FF),\n        ivec4(0xDDCD8C88, 0xF7EF, 0xDCCD8C88, 0xFBDE),\n        ivec4(0xCCCD8C99, 0x1E7CE, 0xCC999899, 0x10FCCD),\n        ivec4(0xCC99999C, 0x21ECCD, 0x9C99CC9C, 0xF7CE),\n        ivec4(0x9C9C9C9C, 0x1300E7CD, 0x9C9C9C9C, 0x8A03C1CD),\n        ivec4(0x9C9C9C9C, 0x998987CD, 0xCCCCC999, 0x889999DD),\n        ivec4(0xCC9C9999, 0x8888C8DC, 0xCC999999, 0xCC8898C9),\n        ivec4(0xFFFFDE9D, 0x1B0ED, 0xFFFFDEAC, 0x80FE),\n        ivec4(0xFFEFCD89, 0x30FF, 0xFEDFCC8A, 0x30FF),\n        ivec4(0xEDDE9C88, 0xE7FF, 0xDDCE9C88, 0xF7EF),\n        ivec4(0xCCDD9C99, 0x21E7DE, 0xCCCC9999, 0x100FBCE),\n        ivec4(0xCC9999CC, 0x31FCCD, 0xCCC9CCCC, 0x1F7CE),\n        ivec4(0xCC9CC9CC, 0x310E3CF, 0xCCC9CCC9, 0x7A07C1CE),\n        ivec4(0xCCC9CCC9, 0x9C8977CE, 0xCDCC9C9C, 0x989999DD),\n        ivec4(0xCC9C9C99, 0x8898C8DC, 0xCC9C9999, 0xCC8898D9),\n        ivec4(0xFFFFEFCD, 0xA0ED, 0xFFFFDFCC, 0x81FD),\n        ivec4(0xFFEFDE99, 0x70FF, 0xFEEFCD8A, 0xFF),\n        ivec4(0xFEEECC88, 0xD3FF, 0xEDDE9C88, 0xF7EF),\n        ivec4(0xDCDD9C99, 0x60F7EE, 0xCCDC9C99, 0x100F7DF),\n        ivec4(0xCC9999CC, 0x30F9DD, 0xCCCCCCCC, 0x11FBCE),\n        ivec4(0xCC9CCCCC, 0x100E3DF, 0xCCCCCCCC, 0x7803C1CE),\n        ivec4(0xCCCCCCC9, 0xCC8983CF, 0xCCCCCCCC, 0x9999A9DD),\n        ivec4(0xCDCCC999, 0x889899DD, 0xCD9C9999, 0x9D8898CC),\n        ivec4(0xEFFFFFCE, 0x90ED, 0xFFFFEFCC, 0x1181FE),\n        ivec4(0xFFEFCE9C, 0xB0FF, 0xFEFFCDAC, 0x30FF),\n        ivec4(0xFEDE9D88, 0xD2FF, 0xEEDE9C8A, 0xF7EF),\n        ivec4(0xDDDE9C98, 0x10FBDF, 0xCCCDCC99, 0x100F7DE),\n        ivec4(0xCC9C99CC, 0x20FCDD, 0xCCCCCCCC, 0x11FACE),\n        ivec4(0xCCCCCCCC, 0x1100E7DF, 0xCCCCCCCC, 0x7813D1CE),\n        ivec4(0xCCCCCCCC, 0xCC8983CF, 0xCDCCCCCC, 0x99999CDD),\n        ivec4(0xCD9C9C9C, 0x889899DD, 0xCC9C9C99, 0x9D8898DC),\n        ivec4(0xDFDDFFEF, 0xD1FD, 0xFFFFFFDF, 0xC1FE),\n        ivec4(0xFFFFEECD, 0x10C2FF, 0xFFFFDFCC, 0x91FF),\n        ivec4(0xFFEFCD9C, 0xE4FF, 0xFFEFCD9A, 0x30FAFF),\n        ivec4(0xFEDECC89, 0x20FDEF, 0xDDDDCD99, 0x1073FADF),\n        ivec4(0xDDCDCC9C, 0x130FEDE, 0xCCCCCCCC, 0x1073FEDD),\n        ivec4(0xCCCCCCCC, 0x3712FADE, 0xCCCCCCCC, 0x8917F7DE),\n        ivec4(0xCCCCCCCC, 0xC99CD8DE, 0xCCCCCCCC, 0x99CCDCDE),\n        ivec4(0xDDCCCCCC, 0x8C99C9DD, 0xCDC9CCC9, 0xCD89C9DC),\n        ivec4(0xEF79EBFF, 0x10ECFD, 0xDFA9FDFF, 0x10D8FE),\n        ivec4(0xFFFFFFFF, 0x10E7FF, 0xFFFFFFFF, 0x10E7FF),\n        ivec4(0xFFFFEFDE, 0x40F7FF, 0xFFFFEFDD, 0x11F7FF),\n        ivec4(0xFFFFDECC, 0x70FFFF, 0xFFFFDDCC, 0x10B0FFFF),\n        ivec4(0xFEEECD9C, 0x10B1FFEE, 0xEDDECD9C, 0x11B5FFEE),\n        ivec4(0xDDDDCC9C, 0x7793FFDD, 0xDCCCCCCC, 0x9CA8FEDE),\n        ivec4(0xDCCCCCCC, 0xCCCCFEDD, 0xCCCCCCCC, 0x99CCFDDE),\n        ivec4(0xCCCCCCCC, 0x9C99ECDD, 0xCCCCCCC9, 0xDD99D9CD),\n        ivec4(0xFFDECCFF, 0x90DDED, 0xEFACDAFF, 0x70DEFE),\n        ivec4(0xCE37E7FF, 0x10EDFF, 0xCE9BFDFF, 0xECFF),\n        ivec4(0xFFFFFFFF, 0x10FAFF, 0xFFFFFFFF, 0x1031FAFF),\n        ivec4(0xFFFFFFFF, 0x74FEFF, 0xFFFFFFEF, 0x71FFFF),\n        ivec4(0xFFFFEEDD, 0xC4FFFF, 0xFFFFDFCD, 0x11D7FFFF),\n        ivec4(0xFFEFDDCC, 0x37F7FFEE, 0xFEEFDDCC, 0x9CEAFFEE),\n        ivec4(0xDEDECDCC, 0xCCFDEFDD, 0xDDDDCDCC, 0x99ECEFDD),\n        ivec4(0xCCCCCCCC, 0x9DD9EEDD, 0xCCCC9C9C, 0xDDC9DDCD),\n        ivec4(0xFFDFCCFE, 0x90DEDD, 0xFFCCCCFF, 0x70DEFE),\n        ivec4(0xCF78D7FF, 0x30EDFF, 0xAD11D3FF, 0xEDFF),\n        ivec4(0xCDCBFFFF, 0xF9FF, 0xFFFFFFFF, 0x10FAFF),\n        ivec4(0xFFFFFFFF, 0x4075FFFF, 0xFFFFFFFF, 0x1071FFFF),\n        ivec4(0xFFFFFFEF, 0xA2FFFF, 0xFFFFEFEE, 0xD7FFFF),\n        ivec4(0xFFFFEEDD, 0x77FBFFFF, 0xFFFFDECC, 0xCCFCFFEF),\n        ivec4(0xFFEFDDCC, 0xC9FEEFED, 0xFEDECDCC, 0x99FDEFDE),\n        ivec4(0xDDDDCD9C, 0xCDECDEDD, 0xCCCDCC99, 0xDDCCDECD),\n        ivec4(0xFFCDCCFF, 0x70DDED, 0xDF7897FF, 0xEDFE),\n        ivec4(0x9E37D7FF, 0xDCFF, 0xCECAFEFF, 0xD8FF),\n        ivec4(0xFFFFFFFF, 0x1FBFF, 0xFFFFFFFF, 0x51FBFF),\n        ivec4(0xFFFFFFEF, 0x31FDFF, 0xFFFFFFDE, 0x30FEFF),\n        ivec4(0xFFFFDEDD, 0xA2FFFF, 0xFEFFDECD, 0x11C7FFEF),\n        ivec4(0xFFEFDDCC, 0x77F7FFEE, 0xFEEFCDCC, 0x99EAFFDE),\n        ivec4(0xEEDECDCC, 0xC9FDEFDD, 0xDDDDCD9C, 0x99ECEFDD),\n        ivec4(0xCDDCCC9C, 0xCDCCDECD, 0xCCCC9C99, 0xDDCCDDCD),\n        ivec4(0xEF7997FF, 0xDCED, 0x9E37D7FF, 0xD8FD),\n        ivec4(0xCFCCFEFF, 0xC7FE, 0xFFFFFFEF, 0xD3FF),\n        ivec4(0xFFFFEFEE, 0x40E3FF, 0xFEFFEFDD, 0x10F7FF),\n        ivec4(0xFEEFDECD, 0x10FBEF, 0xFEFFCECC, 0x30FDEF),\n        ivec4(0xFEEECD9C, 0xB4FFDE, 0xFDDECD9C, 0x181FFDE),\n        ivec4(0xEDDDCD99, 0x13A5FFDD, 0xDDDDCC99, 0x99CAFFDD),\n        ivec4(0xCCCCCC99, 0x99DCDFCD, 0xCCCCCC99, 0x98C9EECD),\n        ivec4(0xCCCC9999, 0x9D99DDCD, 0xC9999999, 0xDD9CD9CC),\n        ivec4(0xDE78D7EF, 0xDAEC, 0x9E37FCDF, 0xC7FD),\n        ivec4(0xEEFEEFEF, 0xC3FD, 0xFFFFEEDE, 0xD0FF),\n        ivec4(0xFFFFDECD, 0xD2FF, 0xFEEFDDAC, 0xE7EF),\n        ivec4(0xFDDFCD9C, 0xF7EF, 0xFDDECC9A, 0x10FDDF),\n        ivec4(0xEDDECC89, 0x70FEDE, 0xDCDDCC89, 0x70EEDD),\n        ivec4(0xCCCC9C89, 0x3772EFDD, 0xCCCC9C89, 0x7887DFCC),\n        ivec4(0xCC9C9999, 0x9999EDCC, 0xCC999999, 0x9899EDCD),\n        ivec4(0x99999999, 0x8988D9CD, 0x99999999, 0xCD89C89D),\n        ivec4(0xCF78FA8E, 0xCCDD, 0xAEB7FECE, 0xD8ED),\n        ivec4(0xEEFEEFCE, 0xC7FD, 0xFFFFDDAD, 0xD1FF),\n        ivec4(0xFEEFCD9C, 0x40D6FF, 0xFEDECD9A, 0xE1EF),\n        ivec4(0xFEDE9C89, 0xF7DF, 0xEEDDAC89, 0x10FDDE),\n        ivec4(0xDDCD8C88, 0x70FEDD, 0xDCCC9C88, 0x1031EECD),\n        ivec4(0xCCCC9988, 0x170EFCD, 0xC9999999, 0x3383DECC),\n        ivec4(0xCC999999, 0xA978ECCC, 0x9C999999, 0x9899ECCD),\n        ivec4(0x99999999, 0x8898D99D, 0x99898989, 0x8C88C8CC),\n        ivec4(0xCE78FE79, 0x10DCEC, 0xBDD7EFAD, 0xCCFD),\n        ivec4(0xEDFEEF9C, 0xDBFD, 0xFFEFDD9A, 0xD3FF),\n        ivec4(0xFFEECC89, 0x20E7EF, 0xFEDEAC89, 0xF1EF),\n        ivec4(0xEFCD8C88, 0xFBDF, 0xDECD8C78, 0x30FEDE),\n        ivec4(0xDDCC8988, 0x71EFDD, 0xCCCD8988, 0x1131EFCC),\n        ivec4(0xCC9C8989, 0x84DFCC, 0x9C999899, 0x1381DECC),\n        ivec4(0x9C999999, 0x7937EDCC, 0x9999C999, 0x9989ECCC),\n        ivec4(0x99999999, 0x8898DC9C, 0x99898989, 0x8888C9CC),\n        ivec4(0xCEB8EE78, 0xDCDC, 0xBDD7EF8C, 0xCCFD),\n        ivec4(0xEDFEDF8C, 0xDBFD, 0xFFEFCD8A, 0xD3FF),\n        ivec4(0xFFEECC8A, 0x40E7EF, 0xEFCEAC88, 0xF1EF),\n        ivec4(0xEFCD8978, 0x10FADE, 0xDECD8978, 0x10FEDE),\n        ivec4(0xDDCC8888, 0x72EFDD, 0xCCCC8988, 0x1130EFCC),\n        ivec4(0xCC998989, 0xB1DFCC, 0x9C999999, 0x3371DECC),\n        ivec4(0x9C99C999, 0x8837EDCC, 0x99999C99, 0x9989ECCC),\n        ivec4(0x99999999, 0x8898DC9C, 0x99899998, 0x8888C99C),\n        ivec4(0xEEBCFE9D, 0xDCDC, 0xAEA3EF7A, 0xC8ED),\n        ivec4(0xCEFCEF8C, 0xD7FD, 0xFFFFDE8C, 0xD0FF),\n        ivec4(0xFFEECD89, 0x10D6FF, 0xFFDEAC8A, 0xE1EF),\n        ivec4(0xFFCE9C78, 0xF7DF, 0xEECD8987, 0x10FCDF),\n        ivec4(0xDDCC8988, 0x70FEDD, 0xDCCC8988, 0x1011EECD),\n        ivec4(0xCC9C9998, 0x70EFCC, 0x9C999999, 0x3373EDCC),\n        ivec4(0xCCC9C99C, 0x9937E9CD, 0x99C9C999, 0x9999ECCD),\n        ivec4(0x99999999, 0x8898D9CC, 0x99999999, 0x8888C9CC),\n        ivec4(0xFDCDFDDE, 0xDCB9, 0xDEB8FEAD, 0xD9ED),\n        ivec4(0xBDC7EF79, 0xDBFD, 0xEFFFFF9C, 0xC3FE),\n        ivec4(0xFFFFDE89, 0xD2FF, 0xFFEFCD8A, 0xE3FF),\n        ivec4(0xFFDE9C89, 0xF2EF, 0xFFDDAC78, 0xF9EF),\n        ivec4(0xEECD8988, 0x20FDDE, 0xDDCD8988, 0x70FDDE),\n        ivec4(0xCCCD9989, 0x1310EECD, 0xCC9CC999, 0x3373EECC),\n        ivec4(0xCCC9C99C, 0x9978F9CD, 0xCCC9C99C, 0x999CECCD),\n        ivec4(0x99C99999, 0x8899D9CD, 0x99999999, 0x8888C9CC),\n        ivec4(0xFCDEFEEF, 0x30CD23, 0xEFCCFFCF, 0xDDDC),\n        ivec4(0xBDC7EF89, 0xDCFE, 0xADF9DF7A, 0xDAFE),\n        ivec4(0xFFFFDF8C, 0xE7FF, 0xFFFFDE8A, 0xE3FF),\n        ivec4(0xFFEECD89, 0x40F7FF, 0xFFDFAC88, 0xF8FF),\n        ivec4(0xEFCD8C78, 0x30FFEF, 0xEECD8988, 0x30FFDE),\n        ivec4(0xDDCD8988, 0x1072FEDD, 0xCCCCC999, 0x1770EFCD),\n        ivec4(0xCCC9C99C, 0x8888EDDC, 0xCCCCCC9C, 0xC99CFCCD),\n        ivec4(0xC9999C9C, 0x89C9DCCD, 0x99999999, 0x8898D9CC),\n        ivec4(0xECDFFFEF, 0x707D20, 0xEFDCFFCF, 0x70DDDC),\n        ivec4(0xBEE7EF8C, 0x60DDFE, 0x7CF8AF87, 0xDCEF),\n        ivec4(0xFFFFDF88, 0x10EBFF, 0xFFFFCE89, 0xF7FF),\n        ivec4(0xFFEFCD88, 0x10FBFF, 0xFFCF9C88, 0x10FCFF),\n        ivec4(0xEFCD8C88, 0x70FFFF, 0xEECD8978, 0xB0FFEE),\n        ivec4(0xDDCC8888, 0x81FFDD, 0xDDCC9999, 0x3780EFCD),\n        ivec4(0xCCCCC999, 0x8897DFCD, 0xCC9CCC9C, 0xCCACFDCC),\n        ivec4(0x9C9C9C9C, 0x9899EDCD, 0x99999999, 0x8898DC9C),\n        ivec4(0xFEEEFFEF, 0x907D70, 0xDFDCFFCE, 0xA0DDFC),\n        ivec4(0x7CFBDF89, 0xB0DDFE, 0x3AFD8D87, 0xECEF),\n        ivec4(0xFFFFCE78, 0x20FCFF, 0xFFFFCE88, 0x10FCFF),\n        ivec4(0xFFEE9C88, 0x40FDFF, 0xFFDE9C78, 0x30FEFF),\n        ivec4(0xEFCD8988, 0xC4FFFE, 0xEE9C8978, 0xC1FFFE),\n        ivec4(0xDD9C8888, 0xC6EFDD, 0xDDCC9989, 0x37D1DFCD),\n        ivec4(0xCC9C9C9C, 0x88D8DECC, 0xCC9CCC9C, 0xC99CEFCC),\n        ivec4(0x9C9C9C9C, 0x98C9EDCC, 0x99999999, 0x8898DCCC),\n        ivec4(0xFEEFFFEF, 0xD37CB0, 0xDFDCFFFF, 0xD1DDEC),\n        ivec4(0xADFAFFCE, 0xC0DDFF, 0x18FBEF9D, 0x70EEEF),\n        ivec4(0xCCFF9F88, 0x70FDDF, 0xFFFFCF88, 0x30FEFF),\n        ivec4(0xFFFFCE88, 0x74FFFF, 0xFFEF9D8A, 0x71FFFF),\n        ivec4(0xFFDD9C88, 0xE5FFFF, 0xFFCDAC88, 0x10F7FFFF),\n        ivec4(0xDECC8988, 0x3F7EFFE, 0xDDCC8988, 0x78F7DFDD),\n        ivec4(0xDDCC9998, 0xCCFCDEDD, 0xCC9C9C99, 0xC9ECDFCC),\n        ivec4(0xCCC9CC9C, 0x99C9DECC, 0x99999C99, 0x8999DDCC),\n        ivec4(0xDBFFEEEE, 0xCA0730, 0xFEEFFEEF, 0xDAADD7),\n        ivec4(0xEFDCFFFF, 0xDBDEFE, 0xADECFFFF, 0xD1EDFF),\n        ivec4(0x5BF7FFDF, 0xC0FEDF, 0xBBFCFFCE, 0x70FECF),\n        ivec4(0xFFFFDF89, 0xB0FFFF, 0xFFFFEF88, 0x91FFFF),\n        ivec4(0xFFFFDF89, 0xE6FFFF, 0xFFFFCE8C, 0x10F7FFFF),\n        ivec4(0xFFDECD89, 0x53FCFFFF, 0xFFCD9C89, 0xA8FCFFFE),\n        ivec4(0xEECD9C88, 0xCCFEEEFE, 0xDDCC9988, 0xC9FEDFDD),\n        ivec4(0xCDCC8988, 0x99ECDDDC, 0xCC999988, 0x9CD9DDCC),\n        ivec4(0x74ECFFFF, 0x10030000, 0xEBFFEFEE, 0xB0AC0370),\n        ivec4(0xFFEFFEEE, 0xB0DE7CDB, 0xFFCEFEFF, 0x80DDDDFE),\n        ivec4(0xCEDCFFFF, 0x60DDFDFF, 0x7ADBFFFF, 0xDAFEDF),\n        ivec4(0x17E6FFFF, 0xD7FF9F, 0xBCFDFFEF, 0xC0FFCF),\n        ivec4(0xFFFFFFCD, 0xE6FFFF, 0xFFFFFF8C, 0x1E7FFFF),\n        ivec4(0xFFFFEF89, 0x77FBFFFF, 0xFFFFEF9C, 0xA9FDFFFF),\n        ivec4(0xFFEFDE9C, 0xD9FFFFFF, 0xFFDECD9C, 0xC9FFEFFE),\n        ivec4(0xEEDDCC89, 0xC9FFDEFE, 0xDDCCAA8A, 0xCCEEDDED),\n        ivec4(0xDBFFFF, 0x0, 0xD7FFEEFE, 0x0),\n        ivec4(0xFEEFEEEE, 0xCC1700B7, 0xFFDFEEEF, 0xDCCD3BFC),\n        ivec4(0xEFCCFEFF, 0xEBDDDDFF, 0x9DCAFFFF, 0xD1DDFDFF),\n        ivec4(0x7BC6FFFF, 0x80DDFFCF, 0x7B1FFFF, 0x10DCFE8F),\n        ivec4(0xBAFDFFEF, 0xE8FFCF, 0xFFFFFFDF, 0xE3FFFF),\n        ivec4(0xFFFFEF9C, 0x37F7FFFF, 0xFFFFFF7C, 0x99FCFFFF),\n        ivec4(0xFFFFFFCD, 0xC9FFFFFF, 0xFFFFEFCD, 0xC8FFFFFE),\n        ivec4(0xFFDEDD9C, 0xC8FFEEFE, 0xEECDCCAC, 0xCCFFDDFD),\n        ivec4(0x60EBEFEE, 0x0, 0xD7FFEEEE, 0x10),\n        ivec4(0xFEEFDCFF, 0xAB1800B2, 0xFFCDFCFF, 0xDACD7BFA),\n        ivec4(0xDEBCFDFF, 0xD7DDDDFF, 0xBC77FDFF, 0xD0DDECFF),\n        ivec4(0x3874FEFF, 0x70DDFDDF, 0xBACBFFEF, 0xC9FDDF),\n        ivec4(0xFEFFFFDE, 0xC7FFEF, 0xFFFFFFCE, 0xC3FFFF),\n        ivec4(0xFFFFFFCE, 0x33D2FFFF, 0xFFFFFFDE, 0x88E7FFFF),\n        ivec4(0xFFEFEECD, 0xC9FCEFFF, 0xFFEFDECC, 0x98FDFFEE),\n        ivec4(0xEFDDCD9C, 0x88FDDFED, 0xEECDBC9A, 0x9CFDDEEC),\n        ivec4(0xB6FEDFFE, 0x50000, 0xFCEECDFF, 0x10CC2720),\n        ivec4(0xFFCEDBFF, 0x30DDACCB, 0xDFBBEBFF, 0x10DCCDFE),\n        ivec4(0x8E13F7FF, 0xDADCFE, 0xACB7FDEF, 0xC7DDFE),\n        ivec4(0xEEFEFFDF, 0x91ECFF, 0xFFFFFFEF, 0x70FCFF),\n        ivec4(0xFFFFFFDE, 0x70FDFF, 0xFFFFEFDE, 0x30FDFF),\n        ivec4(0xFFEFDDCD, 0x1130FFEF, 0xFEEFDECC, 0x77A7FFDF),\n        ivec4(0xFEDECD9C, 0x99E9FFDE, 0xFEDECCAA, 0x98E9FFDD),\n        ivec4(0xDDDDCC89, 0x88E9DFCD, 0xCCCCBC8A, 0x89D8DECC),\n        ivec4(0xEBDEDCFF, 0xC76A40, 0xFEBDEAFF, 0xD1CCAB),\n        ivec4(0xCF7BE7EF, 0xD1CDED, 0xAE77FCDF, 0x90CCFE),\n        ivec4(0xDEECFEDE, 0x70CDFE, 0xFFFFFFDE, 0x10DCFF),\n        ivec4(0xFFFFEEDE, 0xEBFF, 0xFEFFDECD, 0xF7FF),\n        ivec4(0xFEEFDD9C, 0x10FAEF, 0xFEDECC9B, 0x30FDDF),\n        ivec4(0xFDDECD89, 0x370FFDE, 0xEDDDAC8A, 0x7773FFDD),\n        ivec4(0xDCDCCC88, 0x99CAEFCD, 0xCCCC9C8A, 0x98C9EFCD),\n        ivec4(0xCCCC9988, 0x88C9DECC, 0xA9A98A8A, 0x8988DC9C),\n        ivec4(0xEEACFCDF, 0x90CDBB, 0xCF77FD9D, 0x80CDED),\n        ivec4(0x9DCBFE8D, 0x70CDFD, 0xFEFEEFCE, 0xCCFE),\n        ivec4(0xFFFFDE9D, 0xEAFF, 0xFFEFDDBC, 0xF7EF),\n        ivec4(0xFFEECC8C, 0xF7EF, 0xFEDEAC8A, 0xFCDF),\n        ivec4(0xEEDD9C88, 0x30FEDE, 0xEDCDAA78, 0x70FFDD),\n        ivec4(0xDCCD8988, 0x174EFCD, 0xCCCC9988, 0x7783EFCC),\n        ivec4(0x9C9C9989, 0x999AEFCC, 0x9C999A89, 0x98C9DECC),\n        ivec4(0x9999A999, 0x8898DC9C, 0x998B8A88, 0x8988D8CC),\n        ivec4(0x9EC7DE78, 0x70CDED, 0xACFCEF7A, 0x10CCFD),\n        ivec4(0xFEFFDE89, 0xD9FE, 0xFFEFCD8A, 0xE8FF),\n        ivec4(0xFFDE9C88, 0x10F7FF, 0xEFCDAC78, 0xF7EF),\n        ivec4(0xEFCD8978, 0x20FDEE, 0xDECC8B77, 0x70FEDE),\n        ivec4(0xDD9C8888, 0x72EFDD, 0xDC9C8988, 0x171EFCC),\n        ivec4(0xCC9C8988, 0x3B1DFCC, 0x999A9A99, 0x7887DECC),\n        ivec4(0x9C999999, 0x99A9EDCC, 0x9999C999, 0x9899ED9C),\n        ivec4(0x99A99999, 0x8888DC9C, 0xA998A888, 0x8988C89C),\n        ivec4(0xBDFA9F78, 0xDCFD, 0xEDFFCE7A, 0xC8FE),\n        ivec4(0xFFEF9D78, 0xD3FF, 0xFFDEAC88, 0x10F7FF),\n        ivec4(0xEFCD8978, 0xF7FF, 0xDFAD8A77, 0xFAEF),\n        ivec4(0xEE9C8877, 0x70FEEE, 0xDDAC8888, 0xB1FEDD),\n        ivec4(0xDC9C8888, 0x1170EECD, 0xCC9C8888, 0xB5DFCC),\n        ivec4(0x9C999C99, 0x17B1DECC, 0x99999C99, 0x7833EE9C),\n        ivec4(0x9999CC99, 0x9989ECCC, 0x999C9C99, 0x9899EC9C),\n        ivec4(0x99999999, 0x8898D9CC, 0x99A9A9A8, 0x8988C8CC),\n        ivec4(0xADFCDF78, 0xDBFD, 0xFEFFCE88, 0xC3FE),\n        ivec4(0xFFEF9D78, 0xD1FF, 0xFFDEAC78, 0x10E7FF),\n        ivec4(0xEFCD8C78, 0xF2FF, 0xEFAD8A77, 0x10FAFF),\n        ivec4(0xEE9C8887, 0x30FEEE, 0xDD9C8888, 0x73FDDD),\n        ivec4(0xDD9C8988, 0x170EECD, 0xCC999C99, 0x1075DFCC),\n        ivec4(0xC999CC99, 0x1332EECC, 0xC9C9CC99, 0x7833FCCD),\n        ivec4(0x9C9CCC9C, 0xC9B9E9CC, 0x99CC9C99, 0x9999DCCD),\n        ivec4(0x9C999C99, 0x8898C9CD, 0x9999A9A9, 0x8988C8CD),\n        ivec4(0xAEFCDF88, 0xD7FD, 0xFEFFCE89, 0xC1FD),\n        ivec4(0xFFFECD88, 0xC4FF, 0xFFDFAC78, 0xD7FF),\n        ivec4(0xEFCE9C78, 0xD4FF, 0xEFCD8A77, 0xF8EF),\n        ivec4(0xEE9D8888, 0xFDEE, 0xDD9C8A88, 0x73FCDE),\n        ivec4(0xDD9C9988, 0x160EDCD, 0xCC999C99, 0x1035EECD),\n        ivec4(0xC999CC9C, 0x1321ECCC, 0x9CCCCCC9, 0x8815FBCD),\n        ivec4(0xC9C9CC9C, 0xC989E8CD, 0x9CCC9C9C, 0x9899DC9D),\n        ivec4(0x9C9C9C99, 0x8898C9CD, 0x9C9C99A9, 0x898898CD),\n        ivec4(0xCEFDEF89, 0xD7FD, 0xFFFFCE8A, 0xC0FE),\n        ivec4(0xFFFFCD88, 0x10C2FF, 0xFFDFAC8A, 0xD3FF),\n        ivec4(0xFFCE8C78, 0xE0FF, 0xFFCD8A87, 0x10FBFF),\n        ivec4(0xDECD8888, 0x10FDEE, 0xDDCD9A88, 0x1033FADE),\n        ivec4(0xDC9D9C99, 0x34FDDD, 0xCC99CCC9, 0x1031EECD),\n        ivec4(0xCCCCCCCC, 0x1701FACD, 0xCCCCCC9C, 0x7833F7CD),\n        ivec4(0x9CCCCCCC, 0xC98CDBCD, 0xCCCCCC9C, 0x9999DCCD),\n        ivec4(0xCC9C9C9C, 0x8898C9CD, 0xCC999999, 0x8C8898DD),\n        ivec4(0xEEFFCF88, 0xD3FD, 0xFFFFCE8A, 0xC0FE),\n        ivec4(0xFFDE9C88, 0x10D7FF, 0xFFDFAC78, 0xC1FF),\n        ivec4(0xEFCD8978, 0xF7FF, 0xEFCD8A88, 0x10FCFF),\n        ivec4(0xEECC8888, 0x74FDDE, 0xDDCD9999, 0x1151FCDE),\n        ivec4(0xCC9CCC9C, 0x76EDCD, 0xCCCCCCC9, 0x1131EECD),\n        ivec4(0xCCCCCCCC, 0x1340FACD, 0xCCCCCCCC, 0x8937F7CD),\n        ivec4(0xCCCCCCCC, 0xC9ACD8CD, 0xCCCCCC9C, 0x9999CCDD),\n        ivec4(0xCCCC9C9C, 0x8898C9DD, 0xCC9C9999, 0x9C8898DD),\n        ivec4(0xFFFFCD78, 0xC7FE, 0xFFEFAC78, 0x1D1FF),\n        ivec4(0xFFDE9C78, 0x20F7FF, 0xFFCD8A78, 0xF5FF),\n        ivec4(0xEFCC8888, 0x50FCFF, 0xDFAD8A88, 0x70FEFF),\n        ivec4(0xDE9C9999, 0x51B3FEDE, 0xDDCC9C99, 0x71FEDD),\n        ivec4(0xCCC9CCCC, 0x5175EFCD, 0xCCCCCC9C, 0x1130EECD),\n        ivec4(0xCCDCCCCC, 0x1751F9CD, 0xCCCCCCCC, 0x9958F7CD),\n        ivec4(0xCCCCCCCC, 0x9C9CDACD, 0xCCCCCCCC, 0x9899CCDE),\n        ivec4(0xCDCCCC9C, 0x8999C9DD, 0xCC9C9C99, 0xCD88C9DD),\n        ivec4(0xEDFF9D78, 0x1DAEF, 0xFFFF9D88, 0x1E8FF),\n        ivec4(0xFFEF8C88, 0x61FAFF, 0xFFDEAC88, 0x51FDFF),\n        ivec4(0xEFCD8988, 0x20FFFF, 0xEF9C8A88, 0x10B1FFFF),\n        ivec4(0xDE9C8888, 0x10D7FFFF, 0xDECC9999, 0x35A3FFEE),\n        ivec4(0xDDCCCC99, 0x61C7EFDC, 0xCCCCCCCC, 0x53A2EFDC),\n        ivec4(0xCCCCCCCC, 0x7873EFCD, 0xCCDCCCCC, 0xCC89EECD),\n        ivec4(0xCCDCCCCC, 0x99CCEDCD, 0xDCCCCCCC, 0x9999DCCD),\n        ivec4(0xCCCCCCC9, 0x9C98D9DE, 0xCCCCC999, 0xCD9CC9CD),\n        ivec4(0xCEFDEF9C, 0x70DDFF, 0xB9FECE89, 0x10ECEF),\n        ivec4(0xEDFF8C88, 0x20FADF, 0xFFFF8D88, 0x31FCFF),\n        ivec4(0xFFEF8D88, 0x1B4FFFF, 0xFFEF9C88, 0xB1FFFF),\n        ivec4(0xEFCD8C88, 0x10D5FFFF, 0xEFCD8988, 0x11E7FFFF),\n        ivec4(0xDECC8988, 0x15FBFFFF, 0xDE9C8988, 0x77E7EFEE),\n        ivec4(0xCD9C9C99, 0x99FADFDD, 0xCDCCCC9C, 0xCCECDFCD),\n        ivec4(0xCCCDCCCC, 0xC9D9DFCD, 0xDCCCCCCC, 0x9CC9DECC),\n        ivec4(0xCCCCCCCC, 0xDD9CDCCD, 0xCCCCC999, 0xCCCCD9CD),\n        ivec4(0xFEFEFFDE, 0x809DCB, 0xDFFDFFEF, 0x70EEFE),\n        ivec4(0xCCFFDFCC, 0x50FDEF, 0xB7FFCE89, 0x10FD9F),\n        ivec4(0xFEDF9978, 0x40FDDF, 0xFFDF8978, 0x71FFFF),\n        ivec4(0xFFDF8988, 0x40D7FFFF, 0xFFDF8988, 0x11D3FFFF),\n        ivec4(0xFFCD8988, 0x27FBFFFF, 0xEFCD9988, 0x77FAFFFF),\n        ivec4(0xCECC8888, 0xCCFDFFFF, 0xCD9C8888, 0xCCFDFFFF),\n        ivec4(0xCD9C9988, 0x9CEDDEED, 0xCCCC9999, 0xDDDCDEDD),\n        ivec4(0xCCCCCC9C, 0xDDDDDDCC, 0xCC9C9C99, 0xDCDCDDCC),\n        ivec4(0xFBFFDFAC, 0x501730, 0xEFFEEFCD, 0x10CDDA),\n        ivec4(0xDEFFEFDE, 0x50EEFF, 0xCBFFDFAC, 0xFCDF),\n        ivec4(0xE7DF9C88, 0x40FC8E, 0xFECE8977, 0x10FCCF),\n        ivec4(0xFF7C8887, 0xB0FFFF, 0xFF9F8888, 0x57C7FFFF),\n        ivec4(0xFF9D8888, 0x77E6FFFF, 0xFF9C8888, 0x77FAFFFF),\n        ivec4(0xDE9C8888, 0x99FDFFFF, 0xCD9C8878, 0x98FCFFFF),\n        ivec4(0xCD898888, 0xDDFCEFEE, 0xCC898888, 0xEDDDDEDD),\n        ivec4(0xCC998888, 0xDDDDDECC, 0xCCC99999, 0xCCDCDDCC),\n        ivec4(0xD3FFDEA9, 0x100, 0xFDFEEF9C, 0xA8B7),\n        ivec4(0xDEFFEECD, 0xEBFD, 0xCAFFCD88, 0xE3EF),\n        ivec4(0xF7CE8978, 0xE3AF, 0xFF8C7887, 0xF7FF),\n        ivec4(0xFF8C8898, 0x554FEFF, 0xFF9D8888, 0x3871FEFF),\n        ivec4(0xEF8C8888, 0x77B5FFFF, 0xDF9C8888, 0x87C8FFFF),\n        ivec4(0xCD898887, 0x88E9FFEF, 0xCD897878, 0x9CDCEFEF),\n        ivec4(0xCC888888, 0xDDDDDEDD, 0xCC998988, 0xEDDEDDCD),\n        ivec4(0xCC9C9999, 0xDDDDDDCC, 0xCCC99989, 0xCCC9DCCC),\n        ivec4(0x70FDCFA9, 0x0, 0xE7FEDEA9, 0x7011),\n        ivec4(0xDEFFCE9C, 0xC0DC, 0xCCDF8987, 0xB0FE),\n        ivec4(0xEB8D7887, 0x70CF, 0xFF8D8788, 0xC0FF),\n        ivec4(0xEF8D8788, 0x540F7FF, 0xEF9C8888, 0x7801F7FF),\n        ivec4(0xDE898787, 0x7757FCFF, 0xCD898877, 0x7777FCFF),\n        ivec4(0x9D788888, 0x88C9EEDD, 0xCC898888, 0xCDC9ECCD),\n        ivec4(0xCC9C9998, 0xDDDDD9CD, 0xCC9C9C99, 0xDDDDDDCC),\n        ivec4(0xC99C9998, 0xCCCCDCCC, 0x9C999998, 0x999CC9CC),\n        ivec4(0xCBDE9A, 0x0, 0xA0EEAE8B, 0x0),\n        ivec4(0xECFE9D8A, 0x507C, 0xCDCE7888, 0x10ED),\n        ivec4(0xEC8C3888, 0xED, 0xFF8D8788, 0x50FE),\n        ivec4(0xEF8C7788, 0xB4FF, 0xDE898787, 0x7801D0FF),\n        ivec4(0xCD787877, 0x7813E5EE, 0x9D888888, 0x3787E7DD),\n        ivec4(0x9C888888, 0x8898D9CD, 0xCC9C8988, 0xDC89C8CD),\n        ivec4(0xC99C9998, 0xDCDD9CCD, 0xC9999999, 0xDCCCCDCC),\n        ivec4(0xC9998988, 0xC99CC9CC, 0x9C998888, 0x989998C9),\n        ivec4(0xB6DCDC, 0x1000000, 0x70EDBD7B, 0x0),\n        ivec4(0xEBEEAC79, 0x5B, 0xCDAD7788, 0xDA),\n        ivec4(0xFD897788, 0xFB, 0xEF8C8788, 0xFD),\n        ivec4(0xDF897787, 0x30FE, 0xCD887778, 0x8A00B0FF),\n        ivec4(0x8D887878, 0x7817A1DE, 0xCC888888, 0x7777A7DD),\n        ivec4(0xCC998888, 0x798899CD, 0xC9C98989, 0xDC8C98CD),\n        ivec4(0x9C9C9999, 0xCDDD8CCC, 0x9C9C9988, 0xCCCDCCCC),\n        ivec4(0x9D99A888, 0x99C99999, 0xCD898888, 0x888999C9),\n        ivec4(0xB6CCDC, 0x1000000, 0x30EEBD7B, 0x0),\n        ivec4(0xDBCE7888, 0x77, 0xDD7C7788, 0xD3),\n        ivec4(0xFE898787, 0xF7, 0xDF798787, 0xFC),\n        ivec4(0xCE787777, 0x40FE, 0x9D787878, 0x8A0070EE),\n        ivec4(0x9C888888, 0x781771CE, 0xCC998888, 0x377733CD),\n        ivec4(0xC9998988, 0x798889CC, 0xCC999998, 0xDC8C88CC),\n        ivec4(0x9C9C9989, 0xDDDD9CC9, 0xCC998988, 0xCCCCCCC9),\n        ivec4(0xCD898A88, 0x99999999, 0xCD898888, 0x889899C9),\n        ivec4(0xB7CDCA, 0x14000000, 0x30EEBC7B, 0x0),\n        ivec4(0xDA9D77A8, 0xA2, 0xEE7C8778, 0xD0),\n        ivec4(0xFF897788, 0xF7, 0xDE797778, 0xFA),\n        ivec4(0x9E887777, 0x40FD, 0x9D888888, 0x8A0130DD),\n        ivec4(0xCC898888, 0x781731CE, 0xCC9C8988, 0x777713CC),\n        ivec4(0xC99C9989, 0x89888AC9, 0xCC9C9988, 0xDC8C98D9),\n        ivec4(0x9C9C9989, 0xCDDD8CD9, 0xCD9C99A8, 0xCCCDCC99),\n        ivec4(0xCE998988, 0x9899C999, 0xCD998888, 0x888999C9),\n        ivec4(0xB6CDCA, 0x14000000, 0x70FDBC7B, 0x4000000),\n        ivec4(0xEB8D7788, 0xC0, 0xEF8D8778, 0xC0),\n        ivec4(0xEF8C7788, 0xF5, 0xDF797777, 0xF7),\n        ivec4(0xCE888778, 0x40ED, 0xCD898878, 0x8A0130DC),\n        ivec4(0xCC9C8888, 0x881711DC, 0xC99C9989, 0x777313D8),\n        ivec4(0xCCCC9989, 0x89888AD7, 0xCC9C9998, 0xDC8C98D9),\n        ivec4(0xCD9C9989, 0xDCDD9CC9, 0xCE999988, 0xCCCDCC99),\n        ivec4(0xDE99A888, 0x98999999, 0xDE9C8888, 0x888999C9),\n        ivec4(0xB6CDCC, 0x12000000, 0x10EDBC7B, 0x4000000),\n        ivec4(0xDB9E7788, 0x40000C0, 0xEF8E8778, 0x90),\n        ivec4(0xFF8C8787, 0xE2, 0xDF897777, 0xF3),\n        ivec4(0xCE888878, 0x20FA, 0xCD998888, 0x890510E9),\n        ivec4(0xCC9C8988, 0x881711DA, 0xCCCC9999, 0x777703D7),\n        ivec4(0xCCCC9C99, 0x898889D7, 0xCDCC9989, 0xDC8C98D9),\n        ivec4(0xCDCC99A9, 0xDDDD9CC9, 0xDE999989, 0xCCCDDC99),\n        ivec4(0xDE9CA989, 0x98999999, 0xDE9C8988, 0x888999C9),\n        ivec4(0xB6DCCC, 0x14010000, 0x50FEACBB, 0x4040000),\n        ivec4(0xEB9E77A8, 0xC0, 0xFF8E8888, 0xA0),\n        ivec4(0xFF8C7888, 0xE2, 0xEF897787, 0xF3),\n        ivec4(0xDE888888, 0x10020FA, 0xDD999988, 0x890510EC),\n        ivec4(0xCCCD99A9, 0x881701DA, 0xDCCDC999, 0x387713D7),\n        ivec4(0xCCCCC999, 0x8C9889D7, 0xCDCCCC99, 0xDC9C98D9),\n        ivec4(0xDD9C9C99, 0xDDDD9DC9, 0xDFCC9999, 0xDCCDCD9C),\n        ivec4(0xDECC9989, 0x99C9C99C, 0xEECD9988, 0x889999CC),\n        ivec4(0xB7CDCC, 0x16010000, 0x30EEBCBB, 0x44000000),\n        ivec4(0xEA8E87A8, 0xC0, 0xFF8D8888, 0xA0),\n        ivec4(0xFF8C7788, 0xE2, 0xDF798787, 0xF3),\n        ivec4(0xCF898887, 0x50020FA, 0xCD9C8989, 0xA90310E9),\n        ivec4(0xCCCD9989, 0x883701E8, 0xDCCDC999, 0x388703D7),\n        ivec4(0xCCCCCC99, 0x8C9889D7, 0xCDCC9C99, 0xDC9D98DC),\n        ivec4(0xCECC9C99, 0xDDDD9DC9, 0xDECC9999, 0xCCCDCD9C),\n        ivec4(0xEECC99A9, 0x99C9C9CC, 0xEECD9988, 0x889999C9),\n        ivec4(0xCBDDDC, 0x56100000, 0xB0EFBCBB, 0x44000010),\n        ivec4(0xFD8EA8C9, 0x440000C0, 0xFF8988BA, 0xD0),\n        ivec4(0xEF898888, 0xFB, 0xEF898788, 0xFA),\n        ivec4(0xCE888888, 0x70070FE, 0xDE9C9989, 0xAC0731ED),\n        ivec4(0xDCCD9C99, 0x893841E9, 0xDDCDCC9C, 0x788713D7),\n        ivec4(0xDDCCCC9C, 0x9D9899D7, 0xDDCCCC9C, 0xDDCDC9DC),\n        ivec4(0xDDCCCC9C, 0xEDDECDC9, 0xDFCCCC99, 0xDCCDDDCC),\n        ivec4(0xEFCD9C99, 0xC9CCCC9C, 0xEECD9999, 0x899999CC),\n        ivec4(0xCBEEEE, 0x55110000, 0xD5EFBCBB, 0x44000070),\n        ivec4(0xFEDE9CA9, 0x440000D4, 0xEF899BCC, 0xF3),\n        ivec4(0xCF88A8AA, 0x40FC, 0xDF889899, 0x74FF),\n        ivec4(0x9E8888A8, 0x3B00A4FF, 0x9D8888A9, 0x9957A3FF),\n        ivec4(0xCD9C9998, 0x897887EF, 0xDDCCCC99, 0x788877DD),\n        ivec4(0xDDCCCC9C, 0x9D999CDD, 0xDDCCCC9C, 0xDDDE99ED),\n        ivec4(0xCDCDCC9C, 0xDEDDCDD9, 0xDECCCC99, 0xCCDDDCCC),\n        ivec4(0xDFCCC999, 0x99CCCCCC, 0xEECC9999, 0x899999CC),\n        ivec4(0xB7EEFF, 0x55110000, 0xD7FFCDDD, 0x44000053),\n        ivec4(0xFFCFBABB, 0x440000CB, 0xFFCEBCC9, 0xFC),\n        ivec4(0xCFAACCCC, 0x70FF, 0x8D98C9C9, 0x40D1FF),\n        ivec4(0x8C999999, 0x7A40F7FF, 0x8D9999AC, 0xA958FBFF),\n        ivec4(0x89889999, 0x8878FADF, 0x9C999899, 0x8998ECDF),\n        ivec4(0xCDC99999, 0xDD9CDDDE, 0xCDCCCC9C, 0xDDDDCCDD),\n        ivec4(0xCDCDCC9C, 0xEDDDDDED, 0xCDCDCC9C, 0xCCDDDCDD),\n        ivec4(0xCECC9C9C, 0x99CCCCDC, 0xDD9C9999, 0x899999DC),\n        ivec4(0xB7EDEF, 0x55110000, 0xE7FFEEDE, 0x44000010),\n        ivec4(0xFFCCCBAA, 0x440040DA, 0xFFCC7BAB, 0x30FE),\n        ivec4(0xEFCDCCCC, 0xC4FF, 0x9CCACDCD, 0xF7EF),\n        ivec4(0x889A9CCC, 0x7A40FE9F, 0x9899C9C9, 0xA978FF9F),\n        ivec4(0x989CC999, 0x89C8FF9E, 0x9999999C, 0x89C8FF9F),\n        ivec4(0x88889999, 0xCDDCEE9D, 0x99989899, 0xDDDEECCD),\n        ivec4(0xCCCC9999, 0xEEDDDDDD, 0xCCCCCCC9, 0xCCDDDDDD),\n        ivec4(0xCDC9C999, 0x9CCCCCDD, 0xCCC99999, 0x8999C9DC),\n        ivec4(0x20EBFEEF, 0x15110000, 0xFDDFEDDD, 0x44000030),\n        ivec4(0xEF9CBBAB, 0x440040FC, 0xDFBC7BC9, 0x80FE),\n        ivec4(0xDECDCDCD, 0xE6FF, 0xA9C9CDCC, 0xFACF),\n        ivec4(0xA89CCCCC, 0x7A74FF8C, 0x9899C9C9, 0xA9A8FF8C),\n        ivec4(0x9999C999, 0x89EAFF89, 0x9999999C, 0x89D8FF89),\n        ivec4(0x88999999, 0xDDDDDF89, 0x88889899, 0xDDDEDD89),\n        ivec4(0x9989999A, 0xEEEDDD9D, 0xCC999999, 0xDCDDDDCD),\n        ivec4(0xCCCC9999, 0x99CCDCCD, 0xCC9999A9, 0x9999C9CC),\n        ivec4(0xB0FDFEEE, 0x55100000, 0xFFCDCAAB, 0x44000070),\n        ivec4(0xEF9C7BA8, 0x40010FC, 0xDECDCBCD, 0x70FE),\n        ivec4(0xA9C9CDCD, 0xE5DF, 0x88999CCC, 0xFA8D),\n        ivec4(0x989999C9, 0x7A74FF89, 0x989999C9, 0x89B8FF8C),\n        ivec4(0x98989999, 0x88D8FF8C, 0x88989999, 0x89D8EF89),\n        ivec4(0x88889899, 0xDDCCDD88, 0x89888899, 0xDDDDDD9C),\n        ivec4(0x9C999998, 0xEEDEDDCD, 0xCC9C9999, 0xCCCDDDCD),\n        ivec4(0xC9C99999, 0xC9CCCCCD, 0xCC9999A9, 0x89999CCC),\n        ivec4(0xB0EDDDDD, 0x15010000, 0xFE9DBABB, 0x4000031),\n        ivec4(0xEFCD78C8, 0xEB, 0x9CC9DCCC, 0x10FE),\n        ivec4(0x7898C9CC, 0xC0DF, 0x8899A9C9, 0xF79F),\n        ivec4(0x8889999A, 0x7A64FD8E, 0x88989899, 0x8978FD9F),\n        ivec4(0x88889899, 0x7887FE8D, 0x888888A9, 0x88C9DD8C),\n        ivec4(0x89888888, 0xCD99DC9D, 0x9C9C9999, 0xDDDDDCCD),\n        ivec4(0xCC9C9C99, 0xDEDDCDDD, 0xCCC99999, 0xCCDDDCDD),\n        ivec4(0xCCC99999, 0x9CCC9CCC, 0xCC9999A9, 0x899999DC),\n        ivec4(0x70EADDDD, 0x14010000, 0xFACE8BB7, 0x4000000),\n        ivec4(0xEFCD79C8, 0xAB, 0x9D88C9CC, 0xEC),\n        ivec4(0x78989A99, 0x70DF, 0x888898AA, 0xD0EF),\n        ivec4(0x888888A8, 0x4740F7DF, 0x888888A9, 0x8817FBDF),\n        ivec4(0x788788A8, 0x7877FA8D, 0x89888888, 0x7888E89D),\n        ivec4(0x99998888, 0x9D98D9CD, 0xCC999999, 0xDCCDC8CD),\n        ivec4(0xCC9C9C99, 0xDDDD9DDD, 0xCC9C9C99, 0xCCCCCCCD),\n        ivec4(0xCC99999A, 0x99C999CC, 0xCD998989, 0x889999CC),\n        ivec4(0xCBDEDE, 0x12000000, 0xE7CFBABB, 0x4000000),\n        ivec4(0xFDCE7998, 0xA7, 0xCE88C9CC, 0xF7),\n        ivec4(0x7988999A, 0x40EE, 0x8988889A, 0xB0FF),\n        ivec4(0x888888A8, 0x500E3EF, 0x898788A9, 0x8913E3EF),\n        ivec4(0x88878888, 0x8877E89E, 0x99888888, 0x788797CD),\n        ivec4(0xCC999988, 0x8998CCDD, 0xCDC99999, 0xDC9C99CD),\n        ivec4(0xCCC99C99, 0xDDDD9CDC, 0xCCCC9999, 0xDCCDCDCC),\n        ivec4(0xCD999999, 0x9999C9CC, 0xCD9989A8, 0x9899C9C9),\n        ivec4(0xB7DEDE, 0x5010000, 0xC1DFAABB, 0x4000000),\n        ivec4(0xFCCE89A7, 0xA2, 0xCE88CACC, 0xE1),\n        ivec4(0x8C87989A, 0xFC, 0x8D8888A8, 0x30FF),\n        ivec4(0x898888A8, 0xA2FF, 0x89778888, 0x8901C1EF),\n        ivec4(0x88888788, 0x8877C7CF, 0x9C888888, 0x387773DE),\n        ivec4(0xCD9C9989, 0x889889CD, 0xCD999999, 0xCD9999CD),\n        ivec4(0xCDCC9C99, 0xDDDD9CDC, 0xCCC99999, 0xDDDCCCC9),\n        ivec4(0xCD999999, 0x99CCCCC9, 0xCD9989A8, 0x989999CC),\n        ivec4(0x76EDEE, 0x15000000, 0xA0EFB9BA, 0x4000000),\n        ivec4(0xFBCE8CA7, 0x90, 0xDF88CACC, 0xD0),\n        ivec4(0x8D87889A, 0xFB, 0x8D8888A8, 0x10FE),\n        ivec4(0x8C8888A8, 0x70FF, 0x89778888, 0x7C01A0FF),\n        ivec4(0x89888788, 0x8837A7DF, 0x9C998888, 0x387733DD),\n        ivec4(0xCD999989, 0x889889CC, 0xCDCC9999, 0xCD8899DC),\n        ivec4(0xCDCC9C99, 0xDCDD99D9, 0xCDC99999, 0xDDDDCDC9),\n        ivec4(0xCE999999, 0xC99CCC99, 0xCE9989A8, 0x8999999C),\n        ivec4(0x74DCEE, 0x14010000, 0x70EEBCBA, 0x4000000),\n        ivec4(0xFBDF8C87, 0xA0, 0xDE89C8CC, 0xD0),\n        ivec4(0x8E87A89A, 0xF3, 0x8F888888, 0xFD),\n        ivec4(0x8D8888A8, 0x50FF, 0x8C777898, 0x790070FF),\n        ivec4(0x89888888, 0x883787DF, 0xCD898888, 0x787733DC),\n        ivec4(0xCD9C9989, 0x789888C9, 0xCDCC9999, 0x9D8899DC),\n        ivec4(0xCDCC9C99, 0xDCDD99D9, 0xCD9C9999, 0xDDDDCDC9),\n        ivec4(0xCE9C9999, 0xCC9CCC99, 0xDD9989A8, 0x8999999C),\n        ivec4(0x61ECEE, 0x14010000, 0x70EEACBA, 0x4000000),\n        ivec4(0xF7DF8C87, 0xA0, 0xEF8CCACC, 0xD0),\n        ivec4(0x9E87A8A9, 0xF3, 0x9F8888A8, 0xFC),\n        ivec4(0x8D8888A8, 0x70FF, 0x8D878798, 0x7C0070FF),\n        ivec4(0x89888888, 0x883783EF, 0xCD998888, 0x787733DC),\n        ivec4(0xDC9C9CA9, 0x789888D8, 0xDDCC9C99, 0x9D8899DC),\n        ivec4(0xCDCCCC9C, 0xDCDD89D9, 0xCDCC9999, 0xDDDDCDC9),\n        ivec4(0xCECC9999, 0xCCCCCC99, 0xDE999989, 0x9899999C),\n        ivec4(0x70EBEE, 0x12000000, 0x70FECCBC, 0x4000000),\n        ivec4(0xF7DF8B87, 0xB0, 0xEF8CC9CC, 0xE0),\n        ivec4(0x9E87989A, 0xF7, 0x8F8888A8, 0xFC),\n        ivec4(0x8E8888A8, 0x70FF, 0x8D788898, 0x7C0170FF),\n        ivec4(0x89888888, 0x883781EF, 0xCC998888, 0x787733DD),\n        ivec4(0xDD9C9CA9, 0x789889D9, 0xDCCC9C99, 0xCD9899D9),\n        ivec4(0xCDCCCC99, 0xDCDD99D9, 0xCDCC999C, 0xDDDDCDC9),\n        ivec4(0xDDC99999, 0xCC9CCC9C, 0xDD9C99A8, 0x9899999C),\n        ivec4(0x70ECEE, 0x14010000, 0x70EEBDCC, 0x4000000),\n        ivec4(0xFBCFB987, 0xB1, 0xEE9DCCCC, 0xE1),\n        ivec4(0x9E879A9C, 0xF7, 0x8E9898AA, 0xFD),\n        ivec4(0x8D8888A9, 0x70FF, 0x8E8888A9, 0x8C0070FF),\n        ivec4(0x89888888, 0x8838A3EF, 0xCD998989, 0x787737DD),\n        ivec4(0xCD9C9C99, 0x889889DC, 0xCDCCCC99, 0xCD99C9DC),\n        ivec4(0xDDCCCC9C, 0xDDDD9CD9, 0xCDCCCC99, 0xDDDDCDC9),\n        ivec4(0xDE9C9C99, 0xCCCDCC9C, 0xDE9999A9, 0x9999C99C),\n        ivec4(0xB0DDEF, 0x14010000, 0x90EFCCBC, 0x4000000),\n        ivec4(0xFCCE7B87, 0x77, 0xEFCC9CCD, 0xF7),\n        ivec4(0x9E87CA9C, 0xEC, 0x8C8899AA, 0xFF),\n        ivec4(0x8C8888A9, 0xB1FF, 0x8D8898A9, 0xAC01A1FF),\n        ivec4(0x88888889, 0x8838C3DF, 0x9C898888, 0x787777DE),\n        ivec4(0xCDCCCC99, 0x88988CDD, 0xCDCC9C99, 0xDD9999DC),\n        ivec4(0xDDCCCC9C, 0xDDDD9CDC, 0xCDCCCC99, 0xDDDDDDC9),\n        ivec4(0xCECC9999, 0xCCCCCC9C, 0xDE9C99A9, 0x999999CC),\n        ivec4(0x74DCEF, 0x14110000, 0x90EEEECE, 0x4000000),\n        ivec4(0xFEAEBB87, 0x6A, 0xFFCE8BC9, 0xFC),\n        ivec4(0xCE99CDCD, 0x20FE, 0x8998C9AC, 0x70FF),\n        ivec4(0x88A9A999, 0x500E6FF, 0x898999C9, 0xAC17E7FF),\n        ivec4(0x88889899, 0x8978F7DF, 0x998898A9, 0x7888DACF),\n        ivec4(0xCC9C9999, 0x8C99CCDE, 0xCDCCCC99, 0xDD9CC9DD),\n        ivec4(0xCDCCCC9C, 0xDDDE9DDC, 0xCDCCCC99, 0xDDDDDDDC),\n        ivec4(0xCECC9999, 0xCCCCCCCC, 0xDE9999A9, 0x999999CC),\n        ivec4(0x20CBDE, 0x15100000, 0x70FCFFEF, 0x4000000),\n        ivec4(0xFECECCAC, 0x4003063, 0xFFBC7BB7, 0x70ED),\n        ivec4(0xFFCDAACC, 0xB0FF, 0xCDC9CDCD, 0xD0FE),\n        ivec4(0x889A9C9C, 0x700F7DF, 0x8899999C, 0x9C57FADF),\n        ivec4(0x88999A99, 0x8978FECF, 0x88899999, 0x8997FDCF),\n        ivec4(0x88889899, 0x9DC9FDCD, 0x999999A9, 0xDDCDDCDD),\n        ivec4(0xCC9C9C99, 0xDDDDCDDD, 0xCCCCCC99, 0xDDDDDDDD),\n        ivec4(0xCDCCC999, 0xCCCCCCCC, 0xCD999989, 0x989999CC),\n        ivec4(0x40B7DC, 0x15100000, 0xDBFEFF, 0x4000000),\n        ivec4(0xEDEFEEDD, 0x40000040, 0xFFBCBABB, 0xC4EB),\n        ivec4(0xDFAC38A7, 0xE4FF, 0xEF9D9BDC, 0xF3FE),\n        ivec4(0xCDDCDDCC, 0x5B00FCFE, 0x88CACCCC, 0x9C58FECF),\n        ivec4(0x88A999C9, 0x89A8FF8D, 0x989999AC, 0x79A8FF8F),\n        ivec4(0x98999999, 0x9DD9FF8D, 0x88889999, 0xDDDDFE9C),\n        ivec4(0x89889899, 0xDEEDEE9C, 0x999999A8, 0xDDDDDDCD),\n        ivec4(0xCC9999A9, 0xCCCCCCCD, 0x9C9999A8, 0x989999CC),\n        ivec4(0x40CBED, 0x15100000, 0xECFEEF, 0x4000000),\n        ivec4(0xEEEFEEDD, 0x40000060, 0xEFBCBCBB, 0xA7EB),\n        ivec4(0xCFBC38A7, 0xE7FF, 0xDFBC87CC, 0xF7FE),\n        ivec4(0xDEDDDDCD, 0x5A40FEFE, 0x99C9CCCC, 0x9C78FFDE),\n        ivec4(0x88CACCCC, 0x89C7FF8D, 0x8899A999, 0x89D7FF8C),\n        ivec4(0x9999C999, 0xCDE9FF89, 0x98999999, 0xDDDEFF8C),\n        ivec4(0x88899999, 0xDEEDDF89, 0x888888A8, 0xDDDDDD89),\n        ivec4(0x888888A8, 0xC9DCCC9C, 0x99898888, 0x9999C9CC),\n        ivec4(0xB6FDFF, 0x14010000, 0xA7FFEEDE, 0x4000000),\n        ivec4(0xFFCDCCAB, 0x40070B0, 0xDFBC7BB7, 0xD0FC),\n        ivec4(0xEF9C78C9, 0xE4FF, 0xDECDDDCD, 0xF7FE),\n        ivec4(0xACCCCCCC, 0x7A00FDEE, 0x8898CCCC, 0x9C78FF9E),\n        ivec4(0x9799AAC9, 0x89C7FF8C, 0x98999999, 0x89C7FF8D),\n        ivec4(0x98989999, 0xCDDCFF8C, 0x889898A9, 0xDDDEEF8C),\n        ivec4(0x88888898, 0xEEEDDE89, 0x888888A8, 0xDDDDDD9C),\n        ivec4(0x89888888, 0x9CCCCC9C, 0x999988B8, 0x98999CCC),\n        ivec4(0x50EBEEDE, 0x11000000, 0xFACEACBC, 0x0),\n        ivec4(0xFFAC7B87, 0x70C7, 0xEFCC8BCC, 0xB0FE),\n        ivec4(0xCECCDCCC, 0xB0EF, 0x8988CCC9, 0xE2EE),\n        ivec4(0x87A8AA99, 0x7C00FA9F, 0x88888999, 0x8978FCCF),\n        ivec4(0x8888899A, 0x8987FE9E, 0x88888899, 0x7C88FD9E),\n        ivec4(0x888888A8, 0xDDC9FD8C, 0x88888788, 0xCDDDDC9C),\n        ivec4(0x89988888, 0xDEDDDE9C, 0x9C9989A9, 0xDCDDDCCD),\n        ivec4(0x99998988, 0x99C999CC, 0x99898888, 0x989999C9),\n        ivec4(0x70EADDCD, 0x1000000, 0xFA9E8B7B, 0x0),\n        ivec4(0xFF9D78C8, 0x20AC, 0xDEC9CCCC, 0x10FD),\n        ivec4(0x8CB7CAC9, 0xB0EF, 0x7888899A, 0xC0DF),\n        ivec4(0x888898A8, 0x7A00F7DF, 0x888888A8, 0x8958FBEF),\n        ivec4(0x78888888, 0x8877FACE, 0x88878788, 0x7988EC9D),\n        ivec4(0x89888888, 0xCD99D99D, 0x9C999888, 0xDDDDCCCC),\n        ivec4(0x9C999989, 0xDDDDDDCC, 0x9C998989, 0xCCCDCCCD),\n        ivec4(0x9C998988, 0x99C999C9, 0x9C898888, 0x88999999),\n        ivec4(0x30EBDDCD, 0x0, 0xF79EBAB7, 0x0),\n        ivec4(0xFECD78C8, 0xAC, 0xDEAACCCC, 0xEA),\n        ivec4(0x7C879A9A, 0x60EE, 0x888888A8, 0x70FF),\n        ivec4(0x78888888, 0x5A00E2EF, 0x89888888, 0x8917D3EF),\n        ivec4(0x78777888, 0x7877E7CE, 0x88888888, 0x7888C8CD),\n        ivec4(0x99888888, 0x9D88C9CD, 0x9C998988, 0xCCCD99CC),\n        ivec4(0x9C999989, 0xDDDDCDCC, 0x9C998989, 0xCCCDCCCC),\n        ivec4(0x9C998888, 0x89999999, 0xCD898888, 0x889899C8),\n        ivec4(0x10DBDDCD, 0x1000000, 0xD19E8BB7, 0x0),\n        ivec4(0xFECD8BCA, 0xC7, 0xCE88CC9C, 0xE3),\n        ivec4(0x7C87A8A9, 0xFC, 0x89888888, 0x20FF),\n        ivec4(0x88878888, 0x800A0FF, 0x89878788, 0x8907A1EF),\n        ivec4(0x88787888, 0x7877979F, 0x89888888, 0x788777CD),\n        ivec4(0x9C898988, 0x9C8899CD, 0xCC999998, 0xDC9D89C9),\n        ivec4(0xCC999989, 0xDDDDCDC9, 0x9C998988, 0xDCDCCC9C),\n        ivec4(0xCD999888, 0x99999999, 0xCD988888, 0x88989999),\n        ivec4(0xDBCDCD, 0x1000000, 0xD1CF8BB7, 0x0),\n        ivec4(0xEDCDB9CC, 0xC4, 0xCE87CAC9, 0xE0),\n        ivec4(0x8C8788A8, 0xFB, 0x8D8888B8, 0xFE),\n        ivec4(0x88878888, 0x70070FF, 0x89777888, 0x890771DF),\n        ivec4(0x88888888, 0x887783DD, 0x9C898888, 0x788737CC),\n        ivec4(0xCC998988, 0x8C8899D9, 0xCC9C9999, 0xDC9D98D9),\n        ivec4(0x9C9C8989, 0xCDDD9DC9, 0xCC9C9998, 0xDCCDCC9C),\n        ivec4(0xCD998888, 0x99C99999, 0xCD998888, 0x88989999),\n        ivec4(0xDBCDCD, 0x1000000, 0xC1CF8BB7, 0x10),\n        ivec4(0xEECDACCC, 0xC0, 0xCE8798AC, 0xC0),\n        ivec4(0x7D888BA8, 0xF7, 0x8E888888, 0xFC),\n        ivec4(0x8C778888, 0x170050FE, 0x89878788, 0x890771EE),\n        ivec4(0x99888888, 0x887771DC, 0xCC998888, 0x788737D8),\n        ivec4(0xCD9C9989, 0x8D8899C8, 0xCD9C9989, 0xCCCD88D9),\n        ivec4(0xCCCC99A9, 0xDDDD9D99, 0xDD999989, 0xDCCCCC9C),\n        ivec4(0xDC9C8989, 0x99C99999, 0xDD9C8888, 0x88989999),\n        ivec4(0xCBCECD, 0x10000000, 0xC0CF8BB7, 0x10),\n        ivec4(0xFDCDACCC, 0xB0, 0xCE879AAC, 0xC0),\n        ivec4(0x8E8788A8, 0xF3, 0x8E8888A8, 0xFA),\n        ivec4(0x8D878788, 0x1B0050FD, 0x8C878788, 0x890731ED),\n        ivec4(0x9C898888, 0x887733D9, 0xCC999988, 0x788737D7),\n        ivec4(0xDCCC99A9, 0x9D8899C8, 0xCDCC9999, 0xCCCD89D9),\n        ivec4(0xCDCC9CA9, 0xDDDD9D99, 0xDD9C9989, 0xCCCDCC9C),\n        ivec4(0xDC9C9989, 0x99999999, 0xDD9D8988, 0x88989999),\n        ivec4(0xCBDEDD, 0x14000000, 0xC0DF8BBB, 0x10),\n        ivec4(0xFDCE89CC, 0xB0, 0xCF78C9AC, 0xC0),\n        ivec4(0x8E88A8A9, 0xF5, 0x8F8888A8, 0xFA),\n        ivec4(0x8D888889, 0x1B0020FD, 0x8C788888, 0x891730FD),\n        ivec4(0x9C898888, 0x887733D9, 0xCD9C9C89, 0x798777D3),\n        ivec4(0xDDCCC999, 0xCD8899C8, 0xCDCCCC99, 0xCDDD99D9),\n        ivec4(0xCDCC9C9C, 0xDDDDCD99, 0xDDCC9999, 0xDCDDDC9C),\n        ivec4(0xECCC99A9, 0x99C9999C, 0xED9D9989, 0x88989999),\n        ivec4(0xDBEEDE, 0x14010000, 0xD1CFBBBB, 0x4000010),\n        ivec4(0xFDCE88CC, 0xC0, 0xDF9BDCCC, 0xD0),\n        ivec4(0x7D88AAA9, 0xF7, 0x8E888999, 0xFD),\n        ivec4(0x8C88A899, 0x7A0030FF, 0x898888A9, 0x991870FE),\n        ivec4(0x9C888988, 0x887777DC, 0xCDCC9989, 0x7C8878D7),\n        ivec4(0xDDCC9C9C, 0xCD8999C9, 0xCDCCCC99, 0xCDDD9CD9),\n        ivec4(0xCDCCCC9C, 0xDEDDCD99, 0xDDCC9999, 0xCCDDDC9C),\n        ivec4(0xECCC9C99, 0x99999CC9, 0xECCD99A9, 0x989899C9),\n        ivec4(0x40D7FEEE, 0x14010000, 0xE7CFCCCC, 0x4000001),\n        ivec4(0xFFADBBCA, 0xC7, 0xEFCDDCCD, 0xF7),\n        ivec4(0x8DCBCCCC, 0xFD, 0x889AA9AC, 0x30FF),\n        ivec4(0x8899999C, 0x7D04C4EF, 0x89899999, 0xA938A5FF),\n        ivec4(0x898898A9, 0x898797CF, 0xCC999989, 0x8C9889DD),\n        ivec4(0xCDCCCC99, 0xDD9CC9DC, 0xCDCCCC99, 0xDDDD9CD9),\n        ivec4(0xDDCCCC9C, 0xDDDDDDCC, 0xDDCC9C99, 0xCCDCCCCC),\n        ivec4(0xDD9C9C99, 0x99C99C9C, 0xDD9D9989, 0x99999999),\n        ivec4(0x40D7FEEF, 0x14010000, 0xEBEFEDCD, 0x4000001),\n        ivec4(0xEFACBBCB, 0x400000CC, 0xEFBCCBDC, 0xFE),\n        ivec4(0xCECDDDCC, 0x70FF, 0x8ACCCCCC, 0x400C0DF),\n        ivec4(0xA8A9AC9C, 0xBC05F78F, 0x9999C9C9, 0x9938F79F),\n        ivec4(0x9899999C, 0x8988FA9F, 0x88989999, 0x8C98DC9D),\n        ivec4(0x9C999999, 0xDD9CCCCD, 0xCCCCC999, 0xDEDD9DDD),\n        ivec4(0xCDCCCC9C, 0xEDDDDDDD, 0xCDCC9C99, 0xCCDCCCCD),\n        ivec4(0xDD9C9C99, 0x99C99CC9, 0xDD9999A9, 0x989998C9),\n        ivec4(0xDBFFEF, 0x11100000, 0xEAEFEECE, 0x4001010),\n        ivec4(0xEFCCCCCA, 0x440070EA, 0xCFBBBBCC, 0xB0FE),\n        ivec4(0xCEA9CCCD, 0xD0FF, 0xDCDDCDCD, 0x500F3DF),\n        ivec4(0xAACCCCCC, 0xAC05FC8D, 0x999CCCAC, 0x9978FE89),\n        ivec4(0x9C99C99C, 0x8C87FE99, 0x99C9CC9C, 0x9DC8EF9C),\n        ivec4(0x8999999C, 0xDDCDDD89, 0x99999999, 0xDEDDDDCC),\n        ivec4(0xCCCCCC9C, 0xDDDDDDDD, 0xCC9C9C99, 0xCCDCCCDD),\n        ivec4(0xCD9C9999, 0x99C9CCC9, 0xCD9999A9, 0x999998C9),\n        ivec4(0x70ECFFEF, 0x11010000, 0xFDEFEECD, 0x4001070),\n        ivec4(0xCFCCCCCB, 0x4000B0FA, 0xADBBBBCC, 0xA0FF),\n        ivec4(0xCDB8CDCD, 0xE6FF, 0xDDDDCCCC, 0x700FAEF),\n        ivec4(0xCACCCCCC, 0x9C27FEAC, 0xC9CCCCCC, 0x9978CF88),\n        ivec4(0x99999CCC, 0x8997CF98, 0x999CCC9C, 0xCDC9DF99),\n        ivec4(0x99C9C99C, 0xDDDECE99, 0x98989999, 0xDEEDDD89),\n        ivec4(0xC9999C9C, 0xDDDDDDCC, 0xCCC9C999, 0x9CDCCCCD),\n        ivec4(0xCC999999, 0x99C99CC9, 0x9C8999A9, 0x999898C9),\n        ivec4(0xD7EFEFDD, 0x14010000, 0xEFCDCDCC, 0x40030C3),\n        ivec4(0xCEAABBCA, 0x400B0FE, 0xAD8BC9CD, 0xC0FF),\n        ivec4(0xDDDCDDCC, 0xF7FF, 0xCCCDCCCC, 0xB00FCCD),\n        ivec4(0xCACCCCCC, 0xCC47DE88, 0x99C9CCAC, 0x8988CF88),\n        ivec4(0x99999C9C, 0x8C97CF99, 0x999CCC9C, 0xCDD9CF99),\n        ivec4(0x99C9999C, 0xDDDDCE89, 0x88989999, 0xEEEDCE89),\n        ivec4(0xC999C999, 0xDCDDDDCC, 0xCCC99999, 0x9CCCCCCC),\n        ivec4(0x9C999999, 0x99C9C9C9, 0x9C898989, 0x89899999),\n        ivec4(0xFDDECDCC, 0x5010010, 0xCFA9BBCA, 0x40010DA),\n        ivec4(0xCE8ACACC, 0x70FE, 0xDDDCDCDC, 0xA0FF),\n        ivec4(0xCADDCCCC, 0xF6CE, 0x989CCCCC, 0x1B00FB89),\n        ivec4(0x99A99C9C, 0x9C17ED88, 0x99999C9C, 0x8978EF98),\n        ivec4(0x9999C99C, 0x7C88DF89, 0x88989999, 0xDDC9DD88),\n        ivec4(0x89989999, 0xDDDDCC99, 0x9C999999, 0xEEDDDECC),\n        ivec4(0xCCCCC99C, 0xCDDDDDCD, 0xCC99C999, 0x99CC9CCC),\n        ivec4(0x9D9999A9, 0x99C99999, 0x9D988888, 0x89899899),\n        ivec4(0xFDCC9C9A, 0x11000010, 0xDFA9B7CC, 0x40000D9),\n        ivec4(0xDF9DDCCD, 0x40FD, 0x99DCCCCC, 0x70DF),\n        ivec4(0xA8C9CCCC, 0xD08E, 0x989899C9, 0x1B00F38D),\n        ivec4(0x9898999C, 0xAC57FA8C, 0x9899999C, 0x8978F98D),\n        ivec4(0x88889999, 0x8987EC89, 0x89889998, 0xCD99DC9C),\n        ivec4(0x9C9C9999, 0xDDDD99CD, 0xCC9C9C9C, 0xEEDDCDCD),\n        ivec4(0xCCC9C999, 0xDCDDDDDD, 0xCCC99999, 0xC9C99CCC),\n        ivec4(0xCD999999, 0x99C999C9, 0xCD898988, 0x89899999),\n        ivec4(0xF99D8AAB, 0x1000010, 0xEF8C97CC, 0xC7),\n        ivec4(0xCEDCDCCD, 0xFB, 0x88C9CCAC, 0xDE),\n        ivec4(0x87999A9C, 0xA09F, 0x88899899, 0x700E09F),\n        ivec4(0x88889999, 0x8C07E79E, 0x88889999, 0x8877E78D),\n        ivec4(0x888888A8, 0x7887989D, 0x99999999, 0x9D9899CD),\n        ivec4(0x9C9C9999, 0xDDCD99DC, 0xCC9C9C9C, 0xDEDDCDDC),\n        ivec4(0xCC9C9C99, 0xCCDDDCCC, 0xCD999999, 0x99CCCCCC),\n        ivec4(0xCD9999A8, 0x99999999, 0xCD9C8888, 0x88889999),\n        ivec4(0xF79EA9A8, 0x1000010, 0xFE9DB8DC, 0xC0),\n        ivec4(0xCEC9DCCC, 0xE6, 0x8898CC9C, 0xEC),\n        ivec4(0x8899A899, 0x50CF, 0x888898C9, 0x500B0DF),\n        ivec4(0x88889999, 0x8C05C1CF, 0x88888889, 0x8857939E),\n        ivec4(0x898998A8, 0x787877CD, 0xCC999999, 0x8C8889DC),\n        ivec4(0xCDCCC999, 0xDD9C99D9, 0xCCCCC999, 0xDDDD9DD9),\n        ivec4(0xCCCCC999, 0xDDDDDDCC, 0xDD999999, 0x99CCCC9C),\n        ivec4(0xDD9C99A8, 0x99C99999, 0xDD9C8998, 0x88889999),\n        ivec4(0xD1CFA9A8, 0x1000010, 0xFDCE88CC, 0x80),\n        ivec4(0xCECACDCD, 0xD0, 0x7998C9AC, 0xF3),\n        ivec4(0x88A9A899, 0xFD, 0x88889899, 0x50FF),\n        ivec4(0x88889899, 0x7C0071DF, 0x89888888, 0x883773CE),\n        ivec4(0x9C989989, 0x787737D9, 0xCC9C9C99, 0x898889D7),\n        ivec4(0xCDCCC999, 0xDC8C99D9, 0xCDCCC999, 0xDDDD8DD9),\n        ivec4(0xCDCCC999, 0xDDDDDD99, 0xDDCC9999, 0xCCDCCC9C),\n        ivec4(0xDD9C99A9, 0x99999C99, 0xDDCD9988, 0x88999999),\n        ivec4(0xA1DF99AA, 0x1000000, 0xFCCE8ACA, 0x70),\n        ivec4(0xDFC9DCCD, 0xB0, 0x7D889CAC, 0xE0),\n        ivec4(0x89899899, 0xFA, 0x8C889899, 0xFD),\n        ivec4(0x88889899, 0x790030EE, 0x89888888, 0x881773DD),\n        ivec4(0x9D9899A9, 0x887733D7, 0xCDCC9999, 0x798888C1),\n        ivec4(0xDDCCCC99, 0xCD8999C9, 0xCDCC9999, 0xCDDD9CC9),\n        ivec4(0xDDCCC999, 0xEEDDDD99, 0xDD9C9999, 0xCCDDCC9C),\n        ivec4(0xEDCD99A9, 0x99999C9C, 0xDDCD9989, 0x88999999),\n        ivec4(0x70EF9CAC, 0x11000000, 0xFCCF8ACB, 0x10),\n        ivec4(0xEFCCCCCD, 0x70, 0x8D98CCCC, 0xD0),\n        ivec4(0x8989A999, 0xF7, 0x8C889899, 0xFC),\n        ivec4(0x89889899, 0x7A0050FD, 0x89888889, 0x891771EC),\n        ivec4(0x9D9999A9, 0x887733D7, 0xCDCCC999, 0x798878C3),\n        ivec4(0xDDCCCC9C, 0xCD989999, 0xDDCCCC99, 0xCDDD9CC9),\n        ivec4(0xDDCC9C9C, 0xEEDDDD9C, 0xEDCD9999, 0xDCDDDC9C),\n        ivec4(0xEDCD9C99, 0x999C9C9C, 0xECDD9C89, 0x989999C9),\n        ivec4(0x20EDCDCC, 0x10000000, 0xEACF8ACB, 0x10),\n        ivec4(0xFECEC9DD, 0x70, 0x9E98CCCC, 0xC0),\n        ivec4(0x7C9A9999, 0xF3, 0x8C8999C9, 0xFA),\n        ivec4(0x89889899, 0x3A0020FD, 0x898898A9, 0x890870EC),\n        ivec4(0x9C9898A8, 0x887737D7, 0xCDCCC999, 0x788878C1),\n        ivec4(0xDDCCCC9C, 0xCD889999, 0xDDCCCC99, 0xDDDD9CC9),\n        ivec4(0xDDCC9C9C, 0xDEDDDD99, 0xEDCD9999, 0xCDDDDC9C),\n        ivec4(0xECCD9C99, 0x99C99CCC, 0xECDE9C99, 0x99C999C9),\n        ivec4(0x10ECEECE, 0x11000000, 0xE89FAACB, 0x10),\n        ivec4(0xFFCEC8DD, 0x70, 0xCFD9DDCC, 0xC0),\n        ivec4(0x889ACCCC, 0xF5, 0x989899AC, 0xFC),\n        ivec4(0x999899CC, 0x5A0020FD, 0x88889999, 0x890830ED),\n        ivec4(0x9C8999A9, 0x887777D8, 0xCD9C9C9C, 0x798878C1),\n        ivec4(0xDDCCCC9C, 0xCD989999, 0xDDCCCC9C, 0xDDDD9CC9),\n        ivec4(0xDCCDCC9C, 0xDEDDDDC9, 0xEDCD9C9C, 0xDDDDDC9C),\n        ivec4(0xECCD9C99, 0x99C9CCCC, 0xECDE9C99, 0x98C99999),\n        ivec4(0x20FCFEDE, 0x11000000, 0xF8CEC9CA, 0x4000070),\n        ivec4(0xFF8CCBDE, 0xA0, 0xDFDDDECD, 0xE0),\n        ivec4(0x88CCCCCC, 0xEB, 0x8899C9CC, 0xCE),\n        ivec4(0x999AC9CC, 0x5A0070CF, 0x8999C99C, 0x990871CF),\n        ivec4(0x89989999, 0x887777CD, 0xCCCCC9C9, 0x798878D7),\n        ivec4(0xCDCCCCCC, 0xCD9899C9, 0xDECCCC9C, 0xDDDD99D9),\n        ivec4(0xDDCDCC9C, 0xDEDDDD99, 0xEDCCCC99, 0xDDDDCD9D),\n        ivec4(0xFDCDC999, 0x99C99C9C, 0xECDD9C99, 0x98C999C9),\n        ivec4(0x50FCFFEE, 0x11000000, 0xFCDEDDDC, 0x4000070),\n        ivec4(0xDFB9CBDD, 0xE4, 0xDFCAEEDD, 0xF7),\n        ivec4(0xDCEEDDCC, 0x20EE, 0xC8CCCCCC, 0x708D),\n        ivec4(0x99C9CCCC, 0x7C00D49D, 0x99C9CCCC, 0x8918E39D),\n        ivec4(0x9999CC9C, 0x8978D79C, 0x9999CC99, 0x798899CC),\n        ivec4(0xCCCCCCCC, 0xCD99CCDD, 0xCDCDCC9C, 0xDDDD8CDC),\n        ivec4(0xDDCCCC9C, 0xEEDDDDC9, 0xDDCCCC9C, 0xDDDDDCCC),\n        ivec4(0xEDCDCC99, 0x99C99CCC, 0xEDCD9C99, 0x98C999C9),\n        ivec4(0x10DBFFEF, 0x11000000, 0xFAFFEFDE, 0x4000011),\n        ivec4(0xDFDCCCDC, 0x40000FA, 0xCDBBECCD, 0x10FE),\n        ivec4(0xCDECEECD, 0xA0FF, 0xEDDEDDCC, 0xE0DE),\n        ivec4(0xCCCCCCCC, 0x8C01E7A8, 0xCCCCDCCC, 0xA958DC98),\n        ivec4(0xC9CCCCCC, 0x8987DD9C, 0x99CCCCCC, 0x8C98DE99),\n        ivec4(0x99CCCCCC, 0xDD9CDC9C, 0xCCCCCC9C, 0xDDDDCDCC),\n        ivec4(0xDCCCCCCC, 0xEEDDDDDC, 0xCDCCCC9C, 0xCDDDDCCD),\n        ivec4(0xDECCCC9C, 0xC9C99CCC, 0xDDCC9989, 0x999999C9),\n        ivec4(0xC7EEEF, 0x11010000, 0xD7FFFFDF, 0x4000000),\n        ivec4(0xFFFFEEDD, 0x40030FC, 0xCDCDCCCD, 0xB0FF),\n        ivec4(0xBCBBDDCD, 0xE2DF, 0xBAEDDECC, 0xFADF),\n        ivec4(0xEEEEDDCC, 0xAC05FEEE, 0xDCDCCCCC, 0x8CA89ED9),\n        ivec4(0xCCCCCDCC, 0x89C88CC9, 0xCCCCCCCC, 0x8CD89C9C),\n        ivec4(0xCCCCCCCC, 0xDDEC9D9C, 0xC9CCCC9C, 0xDDEDCD99),\n        ivec4(0xCCCCCCCC, 0xEEDDDD9C, 0xCCCCCC9C, 0xDDDDCDCC),\n        ivec4(0xCCCCC99C, 0xC9C9CCDC, 0xCD9999A9, 0x999999C9),\n        ivec4(0x40B7DDEE, 0x11010000, 0xA3FDFFEE, 0x4000000),\n        ivec4(0xFFFFEFDD, 0x400070D7, 0xEEEEDEDC, 0xC4FF),\n        ivec4(0xCCBBCCCD, 0xF7DF, 0x7BDBDECC, 0x40FDCE),\n        ivec4(0xCAEEDECC, 0xAD76FFCE, 0xEEDECDCC, 0x99C8EFEE),\n        ivec4(0xCDCDCCCC, 0x8CF89CDC, 0xCCCCCCCC, 0x8CCC98CC),\n        ivec4(0xCCCDDDCC, 0xDDCDC9C9, 0xCCCCCCCC, 0xDDDF9CC9),\n        ivec4(0xCCCCCCCC, 0xEFDD9C9C, 0xCCCCC999, 0xDDDD9D99),\n        ivec4(0xC9CC9C99, 0xCCCCCC9C, 0x9C9999A9, 0x99C9C9C9),\n        ivec4(0x40C7EEEF, 0x11010000, 0xC7FEFFEF, 0x4000000),\n        ivec4(0xFFFFEFDD, 0x440070E7, 0xDEDECDCD, 0xC0FF),\n        ivec4(0xCCBBCCCD, 0x40F7CF, 0x7ACBDECC, 0x40FCCE),\n        ivec4(0xCAEEDECC, 0xAC76FFCE, 0xEEEECDCC, 0x9CC8EFEE),\n        ivec4(0xDDCCCCCC, 0x8CF8CCDC, 0xCCCCCCCC, 0x8CCC88CC),\n        ivec4(0xCCCDCDCC, 0xDD8DC999, 0xCCCCCCCC, 0xDDCF9CC9),\n        ivec4(0xCCCCCCCC, 0xEECECC99, 0xCC9C999C, 0xDDDE9999),\n        ivec4(0x99CC9999, 0xCCDC9C99, 0xC9C999A9, 0x99999999),\n        ivec4(0x50DBFFEF, 0x11010000, 0xF9FFEFDE, 0x4000010),\n        ivec4(0xDFEECDCD, 0x40FC, 0xCCBBCBCD, 0x70FF),\n        ivec4(0x9CB7DDCD, 0xD6CF, 0xBCFCDECC, 0xFADF),\n        ivec4(0xFEDEDDCC, 0x8C02FEDE, 0xCDCDCCCC, 0xACA8CEC9),\n        ivec4(0xCCCCCCCC, 0x8CD888C9, 0xCCCCCDCC, 0x8CD89899),\n        ivec4(0xC9CCCCCC, 0xDDDC9C99, 0xC9CCC9C9, 0xDDED9999),\n        ivec4(0xC9CC9999, 0xEEDD9C99, 0x999C9CC9, 0xDDDD9D99),\n        ivec4(0x999C9C99, 0xCCCCCC99, 0x9C9999AA, 0x99999999),\n        ivec4(0xB0FEFFDE, 0x1010000, 0xFEDDDDDC, 0x31),\n        ivec4(0xCEACBBCC, 0xFA, 0xAC78DCDD, 0x10FE),\n        ivec4(0x9DEADECD, 0xC0EF, 0xEEDECDCC, 0xF1DE),\n        ivec4(0xCDCCCCCC, 0x8C01CCA8, 0x9CCCCCCC, 0x89788C98),\n        ivec4(0x99C9CCCC, 0x89878D99, 0x99CCC999, 0x8CC89E99),\n        ivec4(0x99C9C999, 0xDDC99D88, 0x98999CC9, 0xDDDD9D89),\n        ivec4(0x99999C9C, 0xEEDDCD9C, 0xC9C99C9C, 0xDDDDCDCC),\n        ivec4(0x9C999999, 0xCCC99CC9, 0xCC9998A8, 0x99999999),\n        ivec4(0xC1EEEEDD, 0x1000000, 0xDFCCBCCC, 0x80),\n        ivec4(0x9E8BC7DD, 0xF6, 0xCE9BEDCD, 0xFC),\n        ivec4(0xDDEDCDCC, 0xB0DE, 0xC9CCCCCC, 0x400C089),\n        ivec4(0xC9C99CCC, 0x8C01C388, 0x9899C9C9, 0x8937DA88),\n        ivec4(0x8899CC99, 0x8977DC99, 0x88999C99, 0x8C87CD88),\n        ivec4(0x88989999, 0xDD99C989, 0x99C9999C, 0xCDDDCDCC),\n        ivec4(0xCCC99C9C, 0xEEDDDDCC, 0xCCC9999C, 0xCDDDCCCC),\n        ivec4(0xCC999999, 0x9CC99CC9, 0xCC9988A8, 0x98999999),\n        ivec4(0xD3DEDDCC, 0x1000000, 0xDFA978CC, 0x80),\n        ivec4(0xCF7AEBCE, 0xD0, 0xDDDDDECC, 0xEB),\n        ivec4(0xCACCCCCC, 0x308D, 0x98C9CC9C, 0x4007088),\n        ivec4(0x899A999C, 0x8C01D189, 0x9898CCC9, 0x8937E389),\n        ivec4(0x88989999, 0x8877D789, 0x88989999, 0x8C87C99C),\n        ivec4(0x9C99999C, 0xDD9999CC, 0x9CCC9CAC, 0xCDDD9CD9),\n        ivec4(0xCC9C9C9C, 0xEEDDDDC9, 0xDC999C99, 0xDCDDCCCC),\n        ivec4(0xDC999999, 0x99999C99, 0xDC9C8988, 0x98999999),\n        ivec4(0xE7CDCCCA, 0x1000000, 0xDFB987DD, 0x10),\n        ivec4(0xDE9CEDCD, 0xC0, 0xC9DDCCCC, 0xC7),\n        ivec4(0x9899CCC9, 0x8C, 0x889899C9, 0x100308D),\n        ivec4(0x889AC999, 0x7C01C08D, 0x889899C9, 0x8918C18C),\n        ivec4(0x8898999A, 0x7877839C, 0x9C9999C9, 0x7C8889C8),\n        ivec4(0xCC9CCC99, 0xDD8C99CC, 0xCDCC9CC9, 0xCDDD9CC9),\n        ivec4(0xCDCCC999, 0xDEDDDD99, 0xDC9C9999, 0xCCDDCC9C),\n        ivec4(0xECCC9999, 0x999999C9, 0xDCCD99A8, 0x98999999),\n        ivec4(0xE79DA9C9, 0x1000000, 0xEDBCC7DE, 0x0),\n        ivec4(0xDDDDDDCD, 0xA0, 0x98CCCCCC, 0x97),\n        ivec4(0x989AC999, 0x89, 0x8898C9CC, 0x400109E),\n        ivec4(0x88989999, 0x8900718E, 0x88989999, 0x8917719D),\n        ivec4(0x99999999, 0x787733D7, 0xCCCC9C9C, 0x89888993),\n        ivec4(0xCECC9C9C, 0xCD8C99CC, 0xCDCCCCC9, 0xCDDD8DC9),\n        ivec4(0xDDCC9C9C, 0xEDDDDD8C, 0xECCD999C, 0xCCDDCC9C),\n        ivec4(0xECCD9C99, 0x99999CC9, 0xECCE9CA9, 0x98989999),\n        ivec4(0xD3CEA9C9, 0x11000000, 0xFC8CC7DE, 0x0),\n        ivec4(0xCDDEDECD, 0xB0, 0x88CCCCCC, 0x91),\n        ivec4(0x98A8999C, 0x98, 0x8898CC9C, 0xCE),\n        ivec4(0x8898C999, 0x8C00309E, 0x8999999A, 0x891771DC),\n        ivec4(0x9CC9999C, 0x787713C1, 0xCDCCCC9C, 0x89888971),\n        ivec4(0xDECCCC9C, 0xDD8C9999, 0xDCCCCCC9, 0xCDDD9CC9),\n        ivec4(0xECCDC99C, 0xEDDDDD9C, 0xFCDDCC99, 0xCCDDCC9C),\n        ivec4(0xFCDECC99, 0x99999CCC, 0xECDECC99, 0x98999999),\n        ivec4(0xD3CEACDC, 0x11000000, 0xF9BCD7DE, 0x4000000),\n        ivec4(0xDDDEEECC, 0xB0, 0x98CCCCCC, 0x91),\n        ivec4(0x99999CCC, 0x98, 0x9898CC9C, 0xCE),\n        ivec4(0x8898C999, 0x7C00109E, 0x99999999, 0x891870D9),\n        ivec4(0xCCCCCC9C, 0x787713C1, 0xDDCCCC9C, 0x89888931),\n        ivec4(0xDDDCCCCC, 0xDD8C9989, 0xDCCDCCCC, 0xCDDD9DC9),\n        ivec4(0xFCCDCC9C, 0xEEDDDD9C, 0xFCDECC9C, 0xCCDDCC9D),\n        ivec4(0xFDDFCD9C, 0x99C99CCC, 0xECDECD99, 0x899999CC),\n        ivec4(0xE3CEACDD, 0x15000000, 0xEDBCE8DF, 0x4000000),\n        ivec4(0xEEDDEECC, 0xA0, 0xD8DCCCCC, 0x98),\n        ivec4(0x99C9CCCC, 0x89, 0x99C9CCCC, 0x10CE),\n        ivec4(0x88C9CC9C, 0x8C00709E, 0x999999AC, 0x890870DC),\n        ivec4(0xCCCCCCCC, 0x787733C3, 0xDDCCCC9C, 0x89888971),\n        ivec4(0xDDDDCCCC, 0xDD9C9989, 0xDCCDCCCC, 0xCDDD9CC9),\n        ivec4(0xEDCDCC9C, 0xEEDDDD9C, 0xFCDECC9C, 0xCCDDDC9D),\n        ivec4(0xFDDFCD9C, 0x99999CCC, 0xECDECD99, 0x8999999C),\n        ivec4(0xF8EEDDDE, 0x15010000, 0xCFB9FCCE, 0x4000080),\n        ivec4(0xDFECEFCD, 0xE2, 0xEEDECDCC, 0x30CD),\n        ivec4(0xCCDCDCCC, 0x9099, 0xC9CCCCCC, 0x400D19C),\n        ivec4(0x99DCCCCC, 0x8C01E79C, 0x99CCCCCC, 0x9918C19D),\n        ivec4(0xCCCCCCCC, 0x887783CD, 0xCDCCCCCC, 0x8C888C98),\n        ivec4(0xDEDDCDCC, 0xDD9CC9CC, 0xDDCDCCCC, 0xDDEDCDC9),\n        ivec4(0xEDCDCDCC, 0xEDDEDD9C, 0xFDDECCCC, 0xCCDDDDCD),\n        ivec4(0xFDDFCD9C, 0xC9C9CCCC, 0xECDECD9C, 0x9999C9C9),\n        ivec4(0xFEFFEEEE, 0x15111070, 0xDECDFECE, 0x440000F7),\n        ivec4(0xBCFCEFCC, 0x400410FE, 0xEDFFCECC, 0xA1EF),\n        ivec4(0xEEDEDDCD, 0xDCFD, 0xCDDDDCCC, 0x580C9CC),\n        ivec4(0xDCDCCDCD, 0x9D85CDCC, 0xCCCDCCCC, 0x99C8CDCC),\n        ivec4(0xCCCDDCCC, 0x8987CDCC, 0xDCCCCCCC, 0x8DC8DDCD),\n        ivec4(0xDDDDDDCC, 0xDDCDCCDD, 0xDDCDCCCC, 0xDEEECDDC),\n        ivec4(0xDDDDDDCC, 0xEEEEDDCD, 0xFDDDCCCC, 0xCCDDDDCD),\n        ivec4(0xFDDDCC9C, 0xCCCCCCCC, 0xFDDECCCC, 0x9999CCC9),\n        ivec4(0xFFFFEFDE, 0x551110A1, 0xFFEFEFDE, 0x440450FD),\n        ivec4(0xCCFDDECC, 0x4414D4DF, 0xFBFFCDCC, 0x4440F7AD),\n        ivec4(0xFFDEDCCC, 0x4070FEEE, 0xEEDDDCCC, 0x17E8FDEE),\n        ivec4(0xDDDDDDCD, 0xCD9CCDDD, 0xDDDDDCCC, 0x9CDDCCCC),\n        ivec4(0xCCCDCDCD, 0x99DDCCDC, 0xDCCCCDCC, 0x9DDDCCDC),\n        ivec4(0xCDCCDCCC, 0xEDDDCDCD, 0xCDCDCDCC, 0xDEEEDEDD),\n        ivec4(0xDDDDDCCC, 0xEEEEDDDD, 0xDDCCCCCC, 0xCCDDDDDD),\n        ivec4(0xDDCDCCCC, 0xCCCCCCDC, 0xEDCCCC99, 0x9999CCCC),\n        ivec4(0xFFFFEFDE, 0x551103C7, 0xFFFFEEDE, 0x440471FF),\n        ivec4(0xDDFEDECD, 0x404FBEE, 0xFBDFCCCC, 0x4414DFAC),\n        ivec4(0xFFDECDCC, 0x4B0DFCA, 0xEFCDCCCD, 0x57FCDFFE),\n        ivec4(0xDDDDDCCC, 0xEDDDEEEE, 0xCDCDDDCC, 0xCDDCDCCD),\n        ivec4(0xDDCDCDCD, 0xCCCCCCCD, 0xCDCCCCCC, 0xEECCCCDC),\n        ivec4(0xDDDCDCCC, 0xEECDDCCC, 0xCCDCCCCC, 0xEECDDCCC),\n        ivec4(0xCDCCCDCC, 0xEEDEDCCD, 0xCCDCCCCC, 0xDCDDDDCD),\n        ivec4(0xCCCCCCCC, 0xC9CCCCDC, 0xCDC9C999, 0x99C9C9CC),\n        ivec4(0xFFFFEEDE, 0x151111FC, 0xEFEEEECD, 0x4404D1FF),\n        ivec4(0xDAEFCDCC, 0x444FCDC, 0xFDDECCCC, 0x474CEBC),\n        ivec4(0xEFCDCDCC, 0x4E7CEFA, 0xDECDCDCC, 0xA7FEFEFF),\n        ivec4(0xCDCDDCCC, 0xDEDCDDDD, 0xCDCDDDCC, 0xCCDCDCCC),\n        ivec4(0xCDCDDCCC, 0xCDC9CCCD, 0xCCCCCCCC, 0xCFCCCCDC),\n        ivec4(0xDDCCCCCC, 0xDEC9CDDC, 0xCCCCCCCD, 0xDECCCCCC),\n        ivec4(0xDCCCCCCC, 0xEECDDCCC, 0xCCDC9C99, 0xDCCDDCCC),\n        ivec4(0xCCCCCC99, 0xC9CCCCCC, 0x9CC99C99, 0x9999C9CC),\n        ivec4(0xEFEDEECD, 0x550131FD, 0xACEECDCC, 0x4440E3DD),\n        ivec4(0xFBEFCCCC, 0x4444DC8C, 0xFFCDCCCC, 0x4B4DECB),\n        ivec4(0xDECCCCCC, 0x50EDEFFF, 0xCDCDCDCC, 0xDBDCDDCD),\n        ivec4(0xCCCDCCCC, 0x9CC9CCCC, 0xDCCCCCCC, 0xCC99C9CC),\n        ivec4(0xCCCCCDCC, 0xDD99C9CC, 0xCCCCCCCC, 0xDE9CCCCC),\n        ivec4(0x99CCCCCC, 0xDD9CCCCC, 0xC9CCCCCC, 0xEECDCCCC),\n        ivec4(0x9CCC9C9C, 0xDDDDCCCC, 0x9CCC9C9C, 0xCCCDCCCD),\n        ivec4(0x9C999C99, 0xC9CC99CC, 0x9C899999, 0x999999C9),\n        ivec4(0xCDECDDCC, 0x10131DD, 0xB8EECDC9, 0xD19D),\n        ivec4(0xF9DECCCC, 0x4400EBBC, 0xDFCDCCCC, 0xC2EFEE),\n        ivec4(0xCDCCCCCC, 0x50CCCDCD, 0xCCCCCCCC, 0x87C8C9CC),\n        ivec4(0xCCCCCCC9, 0xCCAC98C9, 0xCCCC9CCC, 0xD99C98CC),\n        ivec4(0x9C99CCCC, 0xC89C999C, 0x99999C9C, 0x9C9D999C),\n        ivec4(0x9CC9C9C9, 0xDDCDC9CC, 0xCCCC99C9, 0xDDDDCCCC),\n        ivec4(0xCCC9CC99, 0xDDDDCDCD, 0x9C9C9999, 0xCCCDCCCC),\n        ivec4(0x9C9999A9, 0x99CC9CCC, 0x9D898888, 0x89899999),\n        ivec4(0xCCDADE9C, 0x10000EA, 0x88EECDB9, 0x70CE),\n        ivec4(0xFADEC9CC, 0xE7CE, 0xDDCCCC9C, 0x94EDDD),\n        ivec4(0xCCCC9C9C, 0x8ACCCC, 0xCCC99999, 0x298889A),\n        ivec4(0xC9CC9C9C, 0x8C9D8899, 0x9C99C99C, 0x88CD9899),\n        ivec4(0x999899C9, 0x78C988C8, 0xC9999999, 0x79C99CC9),\n        ivec4(0xC9C99999, 0xDD9CCCCC, 0xCC9CC999, 0xCCDDCCCC),\n        ivec4(0xCCCC9999, 0xDEDDDCCC, 0xCC999999, 0xCCCDCCCC),\n        ivec4(0xCD999888, 0x9999999C, 0x9D898988, 0x88999999),\n        ivec4(0xCDCADEAC, 0x10000D7, 0x7AFDCDAA, 0xCD),\n        ivec4(0xECDE9C9C, 0xC7DF, 0xCDCC9C9C, 0x80D9DD),\n        ivec4(0xCCCC9C99, 0x909ACA, 0xC9C99999, 0xC18998),\n        ivec4(0x999CC999, 0x7CD88999, 0x9C989999, 0x88C88898),\n        ivec4(0x99889999, 0x38C79C98, 0xC99C9999, 0x7898CCC9),\n        ivec4(0xC99C9C99, 0x9D8899CC, 0xCC9C9C99, 0xDCDD99DC),\n        ivec4(0xCCCC9999, 0xDDDDCDC9, 0xCD999999, 0xDCCDCC9C),\n        ivec4(0xCD999988, 0x99999999, 0xCD998988, 0x88999999),\n        ivec4(0xCDC9DEAC, 0x10000C1, 0x8AEDCDA9, 0xD8),\n        ivec4(0xECDE9C99, 0xB4DE, 0xCDCC99A9, 0x30C9DD),\n        ivec4(0xC9C999A9, 0x70999A, 0xC9C99989, 0x908998),\n        ivec4(0x99999999, 0x7AD08C98, 0x99889999, 0x88878998),\n        ivec4(0x99889899, 0x38839C98, 0xC9999999, 0x7788C9CC),\n        ivec4(0xCCCC9998, 0x8C8899CC, 0xCCC99999, 0xDCCD89D9),\n        ivec4(0xCCCC9999, 0xDDDDCDC9, 0xCD9C9999, 0xDDCCCC8C),\n        ivec4(0xDD999988, 0x99CC998C, 0xDD998988, 0x88999899),\n        ivec4(0xDDDCDEAC, 0x1000070, 0x8CFCCDAA, 0xE1),\n        ivec4(0xECCE9C99, 0x70EE, 0xDCCCC9A9, 0xC9DE),\n        ivec4(0xA99C9989, 0x509999, 0xC99C9998, 0x708C98),\n        ivec4(0x99999999, 0x18808D98, 0x89889999, 0x88138D98),\n        ivec4(0x99889999, 0x7833C999, 0xCC999999, 0x7787C8CC),\n        ivec4(0xCCCC9999, 0x898899C9, 0xCD9C9999, 0xDC9D98C9),\n        ivec4(0xDCCC9C99, 0xCDDD9D99, 0xDD9C9999, 0xDDDDCC9C),\n        ivec4(0xDDCC9989, 0x99CCC989, 0xDDCD8988, 0x98999899),\n        ivec4(0xDDDDDFAC, 0x1000050, 0xBCFC9DA9, 0xD1),\n        ivec4(0xDCCE9C99, 0x70ED, 0xCDCC9CA9, 0xC8DD),\n        ivec4(0x9C9C9989, 0xC99A, 0xC99C9989, 0x109D98),\n        ivec4(0x99999999, 0x17309D99, 0x8988999C, 0x8803CC88),\n        ivec4(0x99999999, 0x7837C79C, 0xCC999999, 0x778788CC),\n        ivec4(0xCDCC9999, 0x88889988, 0xCDCCC999, 0xDD9C98C9),\n        ivec4(0xDCCCC999, 0xCCDD9D99, 0xEC9D9C99, 0xDDDDCC9C),\n        ivec4(0xECCD9999, 0xC9CC999C, 0xECCE9C89, 0x98999999),\n        ivec4(0xECEEEE9C, 0x10000010, 0xADFDCDAA, 0xC1),\n        ivec4(0xDCDE9999, 0x40EC, 0xDECCC9A9, 0xC7DE),\n        ivec4(0x9C9C9989, 0xCCCC, 0x999C9999, 0x9D98),\n        ivec4(0x99C99999, 0x7109DC9, 0x8988999C, 0x8807CC88),\n        ivec4(0x9C999999, 0x7817C79C, 0xCC999999, 0x778787CC),\n        ivec4(0xCDCC9C99, 0x88989C88, 0xCDCC9C9C, 0xDD999899),\n        ivec4(0xDCCC9C9C, 0xDCDD9CC9, 0xECCD9C9C, 0xDDDDDD99),\n        ivec4(0xECCD9C99, 0xCCCCC99C, 0xFCDE9C99, 0x98999999),\n        ivec4(0xFCEEEFCC, 0x11010110, 0xCDFDCE99, 0x40000C0),\n        ivec4(0xCCDE9C99, 0x10EB, 0xDECD9CA9, 0xD7EF),\n        ivec4(0xCCCC9C99, 0xCCCC, 0xCC9C9999, 0x9DC9),\n        ivec4(0xC9CCCC9C, 0x770CEC9, 0x89989C9C, 0x8907CC99),\n        ivec4(0x9C999C9C, 0x8817C89C, 0xCCCCC999, 0x388787CC),\n        ivec4(0xCDCCCC9C, 0x78989C88, 0xDDCC9C99, 0xDD9C999C),\n        ivec4(0xDCCCCC9C, 0xDCDD9C99, 0xFCCDCC99, 0xDEDDDD99),\n        ivec4(0xFCDD9C9C, 0xCCCDCC9C, 0xECDE9C99, 0x9899999C),\n        ivec4(0xFEFEEECD, 0x11110030, 0xDDFECDA9, 0x40000E3),\n        ivec4(0xEACE9999, 0x40000DD, 0xEECCCC99, 0xE7EF),\n        ivec4(0xCCCC9C99, 0x70DCDD, 0xCC9C9999, 0x80CCC9),\n        ivec4(0xC9CCCC9C, 0x7C0CC99, 0x99C99C9C, 0xA9879DC9),\n        ivec4(0x9999CC9C, 0x8877CDC9, 0xC99C9C9C, 0x7887C8DC),\n        ivec4(0xCDCC9C9C, 0x7898CCC9, 0xCDCCCC9C, 0xDD9C99CC),\n        ivec4(0xDDCCCC9C, 0xDCDD9CC9, 0xDDCDCC99, 0xDEDDDD99),\n        ivec4(0xFCCDCC99, 0xCCCDCC9C, 0xFCDE9C99, 0x9899999C),\n        ivec4(0xFEFFEFCD, 0x15111091, 0xEEEFCCCC, 0x460010EA),\n        ivec4(0xFDCE9C99, 0x4004B0CE, 0xEFCC9C9C, 0x4EADE),\n        ivec4(0xCDCC9C9C, 0xC5EEDE, 0xCCCCC999, 0xD7CDCC),\n        ivec4(0xCCCCCCCC, 0x3BD7CCCC, 0xCCCCCC9C, 0x99DCCCCC),\n        ivec4(0x99C9C9CC, 0x89D89C9C, 0xC9CCCC9C, 0x78C8CDCD),\n        ivec4(0xCCCCCC9C, 0x8998CDDC, 0xCDCCCC9C, 0xDD9DC9DC),\n        ivec4(0xDDCCCCCC, 0xDCEECDCC, 0xDDCCCC9C, 0xEEDDDD9C),\n        ivec4(0xEDCD9C9C, 0xDCCDCC9C, 0xEDCD9C99, 0x99C999CC),\n        ivec4(0xFFFFDECD, 0x151101E8, 0xFEDECCCC, 0x40080EF),\n        ivec4(0xFFCCC9CC, 0x4441E7DD, 0xCECCCC99, 0x450DEFD),\n        ivec4(0xCC9C9C9C, 0x60FAEFDE, 0xCCCC9C9C, 0x80ECCDCC),\n        ivec4(0xCC9CCCCC, 0xAACDCCCC, 0xCCCCCC9C, 0xD9CDC9CC),\n        ivec4(0x99CCCCCC, 0x99CDCC9C, 0xCCCCCC9C, 0x88DCCC99),\n        ivec4(0xCCCCCC9C, 0x8CCCCDCC, 0xCCCCCCC9, 0xEDCDCCDC),\n        ivec4(0xCDCCCC9C, 0xDDEDCDDC, 0xCDCCCC9C, 0xDEDDDDCC),\n        ivec4(0xDDCC9C9C, 0xCCCDCC9C, 0xDD9C9999, 0x99C999CC),\n        ivec4(0xFFEFDEAC, 0x151171FC, 0xFFDDDDCC, 0x4404E7FF),\n        ivec4(0xDE9CCCCD, 0x4462DEFD, 0xCDC9CCCC, 0x4C5CEEF),\n        ivec4(0xCCCC9C9C, 0x74FEFECE, 0xCC9C9C9C, 0xDADEDDCC),\n        ivec4(0xCCCC9CCC, 0xDDCDCCCC, 0xCC9CCCCC, 0xDDC9CCCC),\n        ivec4(0xC9CCCCCC, 0xDDCCCCCC, 0xCCCCCC9C, 0xD9CC9999),\n        ivec4(0xCCCCCC9C, 0xDDCDCCCC, 0xCCCC9C9C, 0xEDDECCCC),\n        ivec4(0xCCCCCC9C, 0xDDEDCDCD, 0xCCCC9999, 0xEDDDDDDD),\n        ivec4(0xCCCCC999, 0xCCCCCCCC, 0xCD999999, 0x99C999CC),\n        ivec4(0xFFEFCD9A, 0x151183FE, 0xEFDECDCC, 0x4610FCFF),\n        ivec4(0xCDCCCDCD, 0x44B4DEFE, 0xCC99CCCC, 0x14D7ECDF),\n        ivec4(0xCCC9CC9C, 0xB4EEEECD, 0xCCC99C9C, 0xEDEECECC),\n        ivec4(0xCC9CCCCC, 0xDDCDCCCC, 0x9CCCCC9C, 0xCCCCCCCC),\n        ivec4(0xCCCCCCCC, 0xCC9CCCC9, 0xCCCCCCC9, 0xCD999CC9),\n        ivec4(0x9CCCCC9C, 0xDE9C9999, 0xCCCC9C9C, 0xDDCCCC9C),\n        ivec4(0xC9C9CC9C, 0xDEDDCDCC, 0xCCC99999, 0xDDDDDCCC),\n        ivec4(0xC9999999, 0xCCCCC9CC, 0x99999998, 0x999999C9)\n);\n\n#endif\n\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    float minimal_side_resolution = min(iResolution.x, iResolution.y);\n    vec2 image_position = vec2((fragmentCoordinates.x - ((iResolution.x - minimal_side_resolution) * 0.5)) * float(imageWidth) / minimal_side_resolution, (fragmentCoordinates.y - ((iResolution.y - minimal_side_resolution) * 0.5)) * float(imageHeight) / minimal_side_resolution);\n    int x = int(floor(image_position.x));\n    int y = int(floor(image_position.y));\n    vec3 color;\n    if ((x >= 0) && (x < imageWidth) && (y >= 0) && (y < imageHeight))\n    {\n        int image_index = int(iTime * playbackSpeed / 0.075) % imageCount;\n        int index = x + ((imageHeight - 1 - y) * imageWidth) + ((imageWidth * imageHeight) * image_index);\n        color = bitmapPalette[(bitmapBits[index / (4 * indicesPerBitmapBitsElement)][(index / indicesPerBitmapBitsElement) % 4] >> (((((index % 2) == 0) ? (index + 1) : (index - 1)) % indicesPerBitmapBitsElement) * 4)) & 0xF];\n    }\n    else if (((x < 0) && (x >= -primaryBorderSize)) || ((x >= imageWidth) && (x < (imageWidth + primaryBorderSize))) || ((y < 0) && (y >= -primaryBorderSize)) || ((y >= imageHeight) && (y < (imageHeight + primaryBorderSize))))\n    {\n        color = bitmapPalette[primaryBorderColorIndex];\n    }\n    else if ((x == -(primaryBorderSize + 1)) || (x == (imageWidth + primaryBorderSize)) || (y == -(primaryBorderSize + 1)) || (y == (imageHeight + primaryBorderSize)))\n    {\n        color = bitmapPalette[secondaryBorderColorIndex];\n    }\n    else\n    {\n        float time = iTime * playbackSpeed / 0.6;\n        int palette_entry_index = int(time);\n        color = mix(bitmapPalette[palette_entry_index % bitmapPalette.length()], bitmapPalette[(palette_entry_index + 1) % bitmapPalette.length()], pow(fract(time), 0.25));        \n#ifdef ENABLE_VIBING_CAT\n        image_position = fragmentCoordinates * ((vec2(vibingCatImageWidth + vibingCatBorderWidth, vibingCatImageHeight + vibingCatBorderHeight) * 5.0) + vec2(vibingCatBorderWidth, vibingCatBorderHeight)) / minimal_side_resolution;\n        x = (int(floor(image_position.x)) % (vibingCatImageWidth + vibingCatBorderWidth)) - vibingCatBorderWidth;\n        y = (int(floor(image_position.y)) % (vibingCatImageHeight + vibingCatBorderHeight)) - vibingCatBorderHeight;\n        if ((x >= 0) && (x < vibingCatImageWidth) && (y >= 0) && (y < vibingCatImageHeight))\n        {\n            int animation_frame_index = int(floor(iTime * 30.0));\n            int image_index = 0;\n            if (animation_frame_index < vibingCatAnimationFrameCount)\n            {\n                image_index = (animation_frame_index < vibingCatImageCount) ? animation_frame_index : ((vibingCatImageCount + vibingCatImageCount) - animation_frame_index - 1);\n            }\n            else\n            {\n                image_index = (animation_frame_index - vibingCatAnimationFrameCount) % (vibingCatRepeatingFrameCount * 2);\n                image_index = ((image_index < vibingCatRepeatingFrameCount) ? image_index : ((vibingCatRepeatingFrameCount + vibingCatRepeatingFrameCount) - image_index - 1)) + vibingCatRepeatAtImageIndex;\n                \n            }\n            int index = x + ((vibingCatImageHeight - 1 - y) * vibingCatImageWidth) + ((vibingCatImageWidth * vibingCatImageHeight) * image_index);\n            color *= vibingCatBitmapPalette[(vibingCatBitmapBits[index / (4 * indicesPerBitmapBitsElement)][(index / indicesPerBitmapBitsElement) % 4] >> (((((index % 2) == 0) ? (index + 1) : (index - 1)) % indicesPerBitmapBitsElement) * 4)) & 0xF];\n        }\n        else\n        {\n            color *= vibingCatBitmapPalette[vibingCatBorderColorIndex];\n        }\n#endif\n    }\n    fragmentColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "sound_code": "// Ivean Polkka\n\nstruct Instrument\n{\n    uint waveType;\n    float waveRatio;\n    float attackTime;\n    float amplitude;\n    float decayTime;\n    float sustainAmplitude;\n    float releaseTime;\n    float leftRight;\n};\n\nstruct Note\n{\n    float playAtTime;\n    uint instrumentIndex;\n    float frequency;\n    float duration;\n    float velocity;\n};\n\nconst float volume = 0.75;\n\nconst float pitch = 1.0;\n\nconst float repeatMusicTime = 19.2;\n\nconst uint repeatMusic = 8U;\n\nconst float musicPlayTime = repeatMusicTime * float(repeatMusic);\n\nconst uint antiAliasing = 2U;\n\nconst float halfPi = 1.57079632679;\n\nconst float pi = 3.14159265359;\n\nconst float doublePi = 6.28318530718;\n\nconst uint squareWaveType = 0U;\n\nconst uint triangleWaveType = 1U;\n\nconst uint sineWaveType = 2U;\n\nconst uint whiteNoiseWaveType = 3U;\n\nconst Instrument[] instruments = Instrument[]\n(\n    //         Wave type           Wave ratio   Attack time    Amplitude    Decay time     Sustain amplitude   Release time   Left/Right\n    \n    // Piano\n    Instrument(triangleWaveType,   0.3125,      0.001953125,   0.21875,     0.0009765625,  0.125,              0.75,          0.5),\n    \n    // Piano\n    Instrument(sineWaveType,       0.25,        0.001953125,   0.013671875, 0.0009765625,  0.0078125,          0.75,          0.5),\n    \n    // Bass \n    Instrument(triangleWaveType,   0.0625,      0.00390625,    0.125,       0.00390625,    0.0625,             0.75,          0.5),\n    \n    // Left bell\n    Instrument(triangleWaveType,   0.125,       0.001953125,   0.046875,    0.001953125,   0.0234375,          0.75,          0.125),\n    \n    // Right bell\n    Instrument(triangleWaveType,   0.125,       0.001953125,   0.046875,    0.001953125,   0.0234375,          0.75,          0.875),\n    \n    // Primary drum\n    Instrument(sineWaveType,       1.0,         0.00048828125, 0.25,        0.00048828125, 0.1875,             0.75,          0.5),\n    \n    // Secondary drum\n    Instrument(triangleWaveType,   0.5,         0.0009765625,  0.375,       0.00048828125, 0.0625,             0.75,          0.5),\n    \n    // Left snare\n    Instrument(whiteNoiseWaveType, 1.0,         0.001953125,   0.0625,      0.001953125,   0.03125,            0.75,          0.25),\n    \n    // Right snare\n    Instrument(whiteNoiseWaveType, 1.0,         0.001953125,   0.0625,      0.001953125,   0.03125,            0.75,          0.75)\n    \n);\n\nconst uint primaryPianoInstrumentIndex = 0U;\n\nconst uint secondaryPianoInstrumentIndex = 1U;\n\nconst uint bassInstrumentIndex = 2U;\n\nconst uint leftBellInstrumentIndex = 3U;\n\nconst uint rightBellInstrumentIndex = 4U;\n\nconst uint primaryDrumInstrumentIndex = 5U;\n\nconst uint secondaryDrumInstrumentIndex = 6U;\n\nconst uint leftSnareInstrumentIndex = 7U;\n\nconst uint rightSnareInstrumentIndex = 8U;\n\nconst float c1 = 32.70319566257483;\n\nconst float cS1 = 34.64782887210902;\n\nconst float d1 = 36.70809598967594;\n\nconst float dS1 = 38.89087296526011;\n\nconst float e1 = 41.20344461410874;\n\nconst float f1 = 43.653528929125486;\n\nconst float fS1 = 46.24930283895431;\n\nconst float g1 = 48.999429497718666;\n\nconst float gS1 = 51.91308719749314;\n\nconst float a1 = 55.0;\n\nconst float aS1 = 58.27047018976124;\n\nconst float b1 = 61.7354126570155;\n\nconst float c2 = 65.40639132514966;\n\nconst float cS2 = 69.29565774421803;\n\nconst float d2 = 73.41619197935188;\n\nconst float dS2 = 77.78174593052022;\n\nconst float e2 = 82.40688922821748;\n\nconst float f2 = 87.30705785825097;\n\nconst float fS2 = 92.49860567790861;\n\nconst float g2 = 97.99885899543733;\n\nconst float gS2 = 103.82617439498628;\n\nconst float a2 = 110.0;\n\nconst float aS2 = 116.54094037952248;\n\nconst float b2 = 123.47082531403103;\n\nconst float c3 = 130.8127826502993;\n\nconst float cS3 = 138.59131548843604;\n\nconst float d3 = 146.8323839587038;\n\nconst float dS3 = 155.56349186104043;\n\nconst float e3 = 164.81377845643496;\n\nconst float f3 = 174.61411571650194;\n\nconst float fS3 = 184.99721135581723;\n\nconst float g3 = 195.99771799087463;\n\nconst float gS3 = 207.65234878997256;\n\nconst float a3 = 220.0;\n\nconst float aS3 = 233.08188075904496;\n\nconst float b3 = 246.94165062806206;\n\nconst float c4 = 261.6255653005986;\n\nconst float cS4 = 277.1826309768721;\n\nconst float d4 = 293.6647679174076;\n\nconst float dS4 = 311.12698372208087;\n\nconst float e4 = 329.6275569128699;\n\nconst float f4 = 349.2282314330039;\n\nconst float fS4 = 369.99442271163446;\n\nconst float g4 = 391.99543598174927;\n\nconst float gS4 = 415.3046975799451;\n\nconst float a4 = 440.0;\n\nconst float aS4 = 466.1637615180899;\n\nconst float b4 = 493.8833012561241;\n\nconst float c5 = 523.2511306011972;\n\nconst float cS5 = 554.3652619537442;\n\nconst float d5 = 587.3295358348151;\n\nconst float dS5 = 622.2539674441618;\n\nconst float e5 = 659.2551138257398;\n\nconst float f5 = 698.4564628660078;\n\nconst float fS5 = 739.9888454232689;\n\nconst float g5 = 783.9908719634986;\n\nconst float gS5 = 830.6093951598903;\n\nconst float a5 = 880.0;\n\nconst float aS5 = 932.3275230361799;\n\nconst float b5 = 987.7666025122483;\n\nconst Note[] notes = Note[]\n(\n    // Piano (primary)\n    Note(0.0 + 0.0,   primaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.05,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.5,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 2.25,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 2.7,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 3.6,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   primaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.05,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.5,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(4.8 + 2.25,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.7,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 1.0),\n    Note(4.8 + 3.6,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 3.9,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.15,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.3,   primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 1.5,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.95,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.55,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.7,   primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.9,   primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.15, primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.3,  primaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 1.5,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.95, primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  primaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.55, primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.7,  primaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  primaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.9,  primaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, primaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    // Piano (secondary)\n    Note(0.0 + 0.0,   secondaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.05,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.5,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 2.25,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(0.0 + 2.7,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(0.0 + 3.6,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   secondaryPianoInstrumentIndex, aS3, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.05,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.5,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 1.0),\n    Note(4.8 + 2.25,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.7,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 1.0),\n    Note(4.8 + 3.6,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(4.8 + 3.9,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.15,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.3,   secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 1.5,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.95,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.55,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.7,   secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.9,   secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.15, secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.3,  secondaryPianoInstrumentIndex, aS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 1.5,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.95, secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  secondaryPianoInstrumentIndex, cS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.55, secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.7,  secondaryPianoInstrumentIndex, gS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  secondaryPianoInstrumentIndex, fS4, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.9,  secondaryPianoInstrumentIndex, f4,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, secondaryPianoInstrumentIndex, dS4, 0.3 - 0.125, 0.75),\n    \n    // Bass\n    Note(0.0 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.4,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 2.7,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 2.85,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.0,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.3,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 3.6,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(0.0 + 3.9,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.05,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.2,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(0.0 + 4.5,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n     \n    Note(4.8 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.4,   bassInstrumentIndex, fS2, 0.3 - 0.125, 1.0),\n    Note(4.8 + 2.7,   bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 2.85,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.0,   bassInstrumentIndex, fS2, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.3,   bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(4.8 + 3.6,   bassInstrumentIndex, f2,  0.3 - 0.125, 1.0),\n    Note(4.8 + 3.9,   bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.05,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.2,   bassInstrumentIndex, f2,  0.3 - 0.125, 0.75),\n    Note(4.8 + 4.5,   bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n     \n    Note(9.6 + 0.0,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 0.3,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.45,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.6,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 0.9,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.2,   bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 1.5,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.65,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 1.8,   bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.1,   bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.4,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 2.7,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 2.85,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.0,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.3,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 3.6,   bassInstrumentIndex, cS2, 0.3 - 0.125, 1.0),\n    Note(9.6 + 3.9,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.05,  bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.2,   bassInstrumentIndex, cS2, 0.3 - 0.125, 0.75),\n    Note(9.6 + 4.5,   bassInstrumentIndex, cS3, 0.3 - 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 0.3,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.45, bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.6,  bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 0.9,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.2,  bassInstrumentIndex, dS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 1.5,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.65, bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 1.8,  bassInstrumentIndex, dS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.1,  bassInstrumentIndex, dS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.4,  bassInstrumentIndex, fS2, 0.3 - 0.125, 1.0),\n    Note(14.4 + 2.7,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 2.85, bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.0,  bassInstrumentIndex, fS2, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.3,  bassInstrumentIndex, fS3, 0.3 - 0.125, 0.75),\n    Note(14.4 + 3.6,  bassInstrumentIndex, f2,  0.3 - 0.125, 1.0),\n    Note(14.4 + 3.9,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.05, bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.2,  bassInstrumentIndex, f2,  0.3 - 0.125, 0.75),\n    Note(14.4 + 4.5,  bassInstrumentIndex, f3,  0.3 - 0.125, 0.75),\n    \n    // Bell\n    Note(0.0 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(0.0 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(0.0 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(0.0 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n     \n    Note(4.8 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(4.8 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(4.8 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(4.8 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n     \n    Note(9.6 + 0.0,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 0.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 0.45,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 0.6,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 0.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.2,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 1.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.65,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 1.8,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 2.1,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 2.4,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 2.7,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 2.85,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 3.0,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 3.3,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 3.6,   rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(9.6 + 3.9,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 4.05,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(9.6 + 4.2,   rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(9.6 + 4.5,   leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 0.3,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 0.45, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 0.6,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 0.9,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.2,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 1.5,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.65, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 1.8,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 2.1,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 2.4,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 2.7,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 2.85, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 3.0,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 3.3,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 3.6,  rightBellInstrumentIndex, dS5, 0.125, 1.0),\n    Note(14.4 + 3.9,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 4.05, leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    Note(14.4 + 4.2,  rightBellInstrumentIndex, dS5, 0.125, 0.75),\n    Note(14.4 + 4.5,  leftBellInstrumentIndex,  dS5, 0.125, 0.75),\n    \n    // Primary drum\n    Note(0.0 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 0.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.8,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 2.4,   primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 3.0,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 3.6,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 4.2,   primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 0.6,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.2,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.8,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 2.4,  primaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 3.0,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 3.6,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 4.2,  primaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    // Secondary drum\n    Note(0.0 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.0 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.0 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(4.8 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(4.8 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(4.8 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.6 + 0.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 0.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 1.8,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 2.4,   secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(9.6 + 3.0,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 3.6,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.6 + 4.2,   secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.4 + 0.0,  secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 0.6,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.2,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 1.8,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 2.4,  secondaryDrumInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(14.4 + 3.0,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 3.6,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.4 + 4.2,  secondaryDrumInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    // Snare\n    Note(0.3 + 0.0,   leftSnareInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.3 + 0.6,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 1.2,   leftSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.3 + 1.8,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 2.4,   leftSnareInstrumentIndex,  dS1, 0.125, 1.0),\n    Note(0.3 + 3.0,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    Note(0.3 + 3.6,   leftSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(0.3 + 4.2,   rightSnareInstrumentIndex, dS1, 0.125, 0.75),\n    \n    Note(5.1 + 0.0,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(5.1 + 0.6,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 1.2,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 1.8,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 2.4,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(5.1 + 3.0,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 3.6,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 3.75,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(5.1 + 4.05,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(5.1 + 4.2,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(9.9 + 0.0,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(9.9 + 0.6,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 1.2,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(9.9 + 1.8,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 2.4,   leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(9.9 + 3.0,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(9.9 + 3.6,   leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(9.9 + 4.2,   rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    \n    Note(14.7 + 0.0,  leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(14.7 + 0.6,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 1.2,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 1.8,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 2.4,  leftSnareInstrumentIndex,   dS1, 0.125, 1.0),\n    Note(14.7 + 3.0,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 3.6,  leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 3.75, rightSnareInstrumentIndex,  dS1, 0.125, 0.75),\n    Note(14.7 + 4.05, leftSnareInstrumentIndex,   dS1, 0.125, 0.75),\n    Note(14.7 + 4.2,  rightSnareInstrumentIndex,  dS1, 0.125, 0.75)\n);\n\nvec2 PlayNotes(const in float time)\n{\n    vec2 ret = vec2(0.0);\n    Note note;\n    Instrument instrument;\n    float sustain_time;\n    float duration;\n    float play_at_time;\n    float relative_time;\n    float scaled_relative_time;\n    float volume;\n    vec2 note_volume;\n    float beats_per_second;\n    float normalized_wave_time;\n    for (int note_index = 0; note_index < notes.length(); note_index++)\n    {\n        note = notes[note_index];\n        instrument = instruments[note.instrumentIndex];\n        sustain_time = max(note.duration - instrument.attackTime - instrument.decayTime, 0.0);\n        duration = (instrument.attackTime + instrument.decayTime + sustain_time + instrument.releaseTime) / playbackSpeed;\n        play_at_time = note.playAtTime / playbackSpeed;\n        relative_time = time - play_at_time;\n        scaled_relative_time = relative_time * playbackSpeed;\n        if ((time >= play_at_time) && ((time - duration) < play_at_time))\n        {\n            switch (instrument.waveType)\n            {\n            case squareWaveType:\n                beats_per_second = 1.0 / note.frequency;\n                normalized_wave_time = mod(relative_time * pitch, beats_per_second) / beats_per_second;\n                volume = (normalized_wave_time > instrument.waveRatio) ? -1.0 : 1.0;\n                break;\n            case triangleWaveType:\n                volume = 1.0;\n                beats_per_second = 1.0 / note.frequency;\n                normalized_wave_time = mod(relative_time * pitch, beats_per_second) / beats_per_second;\n                if (normalized_wave_time < instrument.waveRatio)\n                {\n                    volume = (clamp(normalized_wave_time / instrument.waveRatio, 0.0, 1.0) * 2.0) - 1.0;\n                }\n                else if (normalized_wave_time > instrument.waveRatio)\n                {\n                    volume = 1.0 - (clamp((normalized_wave_time - instrument.waveRatio) / (1.0 - instrument.waveRatio), 0.0, 1.0) * 2.0);\n                }\n                break;\n            case sineWaveType:\n                volume = sin(relative_time * pitch * doublePi * note.frequency);\n                break;\n            case whiteNoiseWaveType:\n                volume = (fract(sin(relative_time * pitch * 12865.9898) * 43758.5453) * 2.0) - 1.0;\n                break;\n            }\n            note_volume = vec2((instrument.leftRight > 0.5) ? cos((instrument.leftRight - 0.5) * pi) : 1.0, (instrument.leftRight < 0.5) ? cos((0.5 - instrument.leftRight) * pi) : 1.0) * volume * note.velocity;\n            if (scaled_relative_time < instrument.attackTime)\n            {\n                note_volume *= (scaled_relative_time / instrument.attackTime) * instrument.amplitude;\n            }\n            else if (scaled_relative_time < (instrument.attackTime + instrument.decayTime))\n            {\n                note_volume *= mix(instrument.amplitude, instrument.sustainAmplitude, (scaled_relative_time - instrument.attackTime) / instrument.decayTime);\n            }\n            else if (scaled_relative_time < (instrument.attackTime + instrument.decayTime + sustain_time))\n            {\n                note_volume *= instrument.sustainAmplitude;\n            }\n            else\n            {\n                note_volume *= mix(0.0, instrument.sustainAmplitude, exp((-(scaled_relative_time - instrument.attackTime - instrument.decayTime - sustain_time) * doublePi) / instrument.releaseTime));\n            }\n            ret += note_volume;\n        }\n    }\n    return ret;\n}\n\nvec2 mainSound(in int samp, float time)\n{\n    if (time >= musicPlayTime)\n    {\n        return vec2(0.0);\n    }\n    vec2 current_volume = vec2(0.0);\n    for (uint anti_aliasing_index = 0U; anti_aliasing_index != antiAliasing; anti_aliasing_index++)\n    {\n        float current_time = time - float(anti_aliasing_index) / (iSampleRate * float(antiAliasing));\n        current_volume += (current_time < 0.0) ? vec2(0.0, 0.0) : PlayNotes(mod(current_time, repeatMusicTime / playbackSpeed));\n    }\n    return current_volume * volume / float(antiAliasing);\n}\n", "sound_inputs": [], "common_code": "// User settings\n\n// Low-resolution mode is less taxing on your device\n// Uncomment the line below if you are watching this on a potato!\n//#define LOW_RESOLUTION_MODE\n\n// Uncomment to enable vibing cat\n// Warning: May not work on every machine!\n//#define ENABLE_VIBING_CAT\n\n// End of user settings\n\n\n\n#ifdef ENABLE_VIBING_CAT\nconst float playbackSpeed = 1.5;\n#else\nconst float playbackSpeed = 1.0;\n#endif\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXGRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7ls3RX", "name": "little terrain map like", "author": "MrNissenDK", "description": "based on my Perlin noise", "tags": ["noise", "game", "terrain", "perlin", "smooth"], "likes": 3, "viewed": 261, "published": 3, "date": "1622556477", "time_retrieved": "2024-07-30T19:17:58.010006", "image_code": "float res = 5.; // how many sqrs along the x axes\nint seed = 4294967295;\nint detail = 8; // keep less or equal to 62 and higher then 0;\nbool debug = false; // show the uv grid\n\nfloat[] heights =         float[](0. , 0.5, 0.6,  .7,  .8,  .85, 1.);\nint[] heightColorRelation = int[](0  , 1  , 1  , 2  , 3  , 3  , 4 );\nvec3[] colors = vec3[](\n    vec3(0.3176470588235294, 0.3215686274509804, 0.2980392156862745), \n    vec3(0.9294117647058824, 0.788235294117647, 0.6862745098039216), \n    vec3(0, 0.6039215686274509, 0.09019607843137255),\n    vec3(0.6588235294117647, 0.6470588235294118, 0.611764705882353),\n    vec3(1, 0.9803921568627451, 0.9803921568627451)\n);\n\nfloat pixelSize = 0.;\n\nfloat[] digitsPi = float[](14.159265,35.897932,38.462643,38.327950,28.841971,69.399375,10.582097,49.445923,78.16406,28.620899,86.280348);\n\nfloat getDigit(float index){\n    return digitsPi[int(abs(mod(index, float(digitsPi.length()))))];\n}\nfloat getDigit(int index){\n    return getDigit(float(index));\n}\nfloat getRandom(vec2 index){\n    float _seed = mod(float(seed), 1000.);\n    index = mod(index, 65535.);\n    float id = length(index) * _seed + length(index) + _seed;\n    return fract(sin(dot(index, vec2(getDigit(id+265.), getDigit(id+159.))))* getDigit(id + 314.));\n}\nfloat getRandom(vec3 index){\n    float _seed = mod(float(seed), 1000.);\n    index = mod(index, 65535.);\n    float id = length(index) * _seed + length(index) + _seed;\n    return fract(sin(dot(index, vec3(getDigit(id+265.), getDigit(id+159.), getDigit(id+582.))))* getDigit(id + 314.));\n}\nfloat smoothMix(vec2 from, vec2 to, vec2 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(getRandom(from), getRandom(vec2(to.x, from.y)), t.x),\n        mix(getRandom(vec2(from.x, to.y)), getRandom(to), t.x),\n    t.y);\n}\nfloat smoothMix(vec3 from, vec3 to, vec3 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(\n            mix(getRandom(from), getRandom(vec3(to.x, from.yz)), t.x),\n            mix(getRandom(vec3(from.x, to.y, from.z)), getRandom(vec3(to.xy, from.z)), t.x),\n        t.y),\n\n        mix(\n            mix(getRandom(vec3(from.xy, to.z)), getRandom(vec3(to.x, from.y, to.z)), t.x),\n            mix(getRandom(vec3(from.x, to.yz)), getRandom(to), t.x),\n        t.y),\n\n    t.z);\n}\nfloat getNoise(vec2 index){\n    vec2 low = floor(index);\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec2 low = floor(index);\n        _output += smoothMix(low, low + vec2(1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += mod(float(seed), 50.) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\nfloat getNoise(vec3 index){\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec3 low = floor(index);\n        _output += smoothMix(low, low + vec3(1,1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += mod(float(seed), 50.) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\n\nvec3 getColor(float height){\n    for(int i = 0; i < heights.length(); i++){\n        if(height <= heights[i])\n            return mix(colors[heightColorRelation[i-1]], colors[heightColorRelation[i]], (height - heights[i - 1]) / (heights[i] - heights[i -1]));\n    }\n    return vec3(colors[heightColorRelation[heights.length()-1]]);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    pixelSize = res / iResolution.y;\n    \n    float height = getNoise(vec3(uv, iTime/5.)) * 1.5;\n    \n    \n    vec3 col = getColor(height);\n    \n    if(height < .52) col.b = 1.;\n    \n    if( debug && (\n        fract(uv.x) <= pixelSize || fract(uv.x) >= 1.-pixelSize || \n        fract(uv.y) <= pixelSize || fract(uv.y) >= 1.-pixelSize)\n    ) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ls3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[822, 822, 850, 850, 921], [922, 922, 948, 948, 985], [986, 986, 1014, 1014, 1253], [1254, 1254, 1282, 1282, 1540], [1541, 1541, 1585, 1585, 1772], [1773, 1773, 1817, 1817, 2254], [3031, 3031, 3059, 3059, 3361], [3362, 3362, 3419, 3419, 3907]], "test": "untested"}
{"id": "7tl3RX", "name": "2D Rectangular Grid Traversal", "author": "pyBlob", "description": "Use mouse for custom rays.\nVisits cells in a rectangular grid that touch a ray:\n  - Interleaved: Sort cells by first intersection with ray\n  - Sequential: One run per dimension\n", "tags": ["visualization", "voxel", "rectangle"], "likes": 5, "viewed": 299, "published": 3, "date": "1622555605", "time_retrieved": "2024-07-30T19:17:58.908602", "image_code": "struct Line\n{\n    vec2 position;\n    vec2 tangent;\n    float a, b;\n};\n\nLine line(vec2 p1, vec2 p2);\nvec2 normal(vec2 tangent);\nvec2 normal(Line);\nfloat map(vec2 x, Line);\nvec4 blend(vec4 C, vec4 c, float f);\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    O = (O - iResolution.xy / 2.);\n    C = vec4(0);\n\n    vec2 c1 = vec2(-100., -50.); // lower left corner\n    vec2 c2 = vec2(100., 50.); // upper right corner\n    ivec2 n = ivec2(9, 9); // cells per dimension\n    vec2 grid = vec2(n) / (c2 - c1); // world-position to cell-id\n\n    {\n        vec2 f = vec2(10.);\n\n        Line ray = line(\n            mix(\n                vec2(-250., -100.),\n                vec2(250., -100.),\n                .5+.5*cos(iTime*.1)),\n            vec2(50., 55.));\n        if (iMouse.z > 0.)\n            ray = line(iMouse.xy - iResolution.xy / 2., abs(iMouse.zw) - iResolution.xy / 2.);\n        // special cases\n        //ray = line(vec2(0, -100), vec2(0, 100)); // up\n        //ray = line(vec2(0, 100), vec2(0, -100)); // down\n        //ray = line(vec2(-150, 0), vec2(150, 0)); // right\n        //ray = line(vec2(150, 0), vec2(-150, 0)); // left\n        \n        vec2 i = min(\n            sign(ray.tangent) * (c1 - ray.position) * grid,\n            sign(ray.tangent) * (c2 - ray.position) * grid\n        );\n        vec2 len = 1. / abs(ray.tangent) / grid;\n        vec2 vx = ray.tangent * len.x;\n        vec2 vy = ray.tangent * len.y;\n\n        if (true)\n        {\n            // interleave x-hits and y-hits\n            for (ivec2 j=ivec2(0,0) ; any(lessThan(j, n)) ; )\n            {\n                vec2 t = (i + vec2(j)) * len;\n                int k;\n                if (j.y == n.y || j.x < n.x && t.x < t.y)\n                    k = 0;\n                else\n                    k = 1;\n                vec2 x = ray.position + t[k] * ray.tangent;\n                j[k] += 1;\n                vec2 offset = vec2(0);\n                offset[k] = .5 * sign(ray.tangent)[k];\n                vec2 cell = floor((x - c1) * grid + offset);\n                vec2 center = c1 + (cell + .5) / grid;\n                vec2 connect = center;\n                connect[k] = x[k];\n                vec2 bar = vec2(.5) / grid;\n                bar[k] = 0.;\n                f[k] = min(f[k], length(O - center) - float(k + 1));\n                f[k] = min(f[k], map(O, line(connect, center)));\n                f[k] = min(f[k], map(O, line(x - bar, x + bar)));\n            }\n        } else {\n            // find x-hits, then y-hits\n            for (int j=0 ; j<n.x ; ++j)\n            {\n                vec2 x = ray.position + i.x * vx;\n                i.x += 1.;\n                vec2 cell = floor((x - c1) * grid + vec2(.5 * sign(ray.tangent).x, 0));\n                vec2 center = c1 + (cell + .5) / grid;\n                f.x = min(f.x, length(O - center) - 1.);\n                f.x = min(f.x, map(O, line(vec2(x.x, center.y), center)));\n                f.x = min(f.x, map(O, line(x - vec2(0,.5) / grid, x + vec2(0,.5) / grid)));\n            }\n\n            for (int j=0 ; j<n.y ; ++j)\n            {\n                vec2 x = ray.position + i.y * vy;\n                i.y += 1.;\n                vec2 cell = floor((x - c1) * grid + vec2(0, .5 * sign(ray.tangent).y));\n                vec2 center = c1 + (cell + .5) / grid;\n                f.y = min(f.y, length(O - center) - 2.);\n                f.y = min(f.y, map(O, line(vec2(center.x, x.y), center)));\n                f.y = min(f.y, map(O, line(x - vec2(.5,0) / grid, x + vec2(.5,0) / grid)));\n            }\n        }\n\n        C = blend(C, vec4(1.,.2,0,1), f.x);\n        C = blend(C, vec4(0,.2,1,1), f.y);\n        C = blend(C, vec4(0,.5,0,1), map(O, ray));\n    }\n    \n    // grid\n    {\n        float f = 10.;\n        for (int i=0 ; i<n.x+1 ; ++i)\n        {\n            float a = float(i) / float(n.x);\n            f = min(f, map(O, line(\n                vec2(mix(c1, c2, a).x, c1.y),\n                vec2(mix(c1, c2, a).x, c2.y) )));\n        }\n        for (int i=0 ; i<n.y+1 ; ++i)\n        {\n            float a = float(i) / float(n.y);\n            f = min(f, map(O, line(\n                vec2(c1.x, mix(c1, c2, a).y),\n                vec2(c2.x, mix(c1, c2, a).y) )));\n        }\n        C = blend(C, vec4(vec3(0),1), f);\n    }\n\n    C = blend(C, vec4(1), 0.);\n    C.xyz = pow(C.xyz, vec3(1./2.2));\n}\n\nLine line(vec2 p1, vec2 p2)\n{\n    return Line(p1, normalize(p2 - p1), 0., length(p2 - p1));\n}\n\nvec2 normal(vec2 tangent)\n{\n    return vec2(-tangent.y, tangent.x);\n}\n\nvec2 normal(Line l)\n{\n    return normal(l.tangent);\n}\n\nfloat map(vec2 x, Line l)\n{\n    x -= l.position + l.tangent * (l.a + l.b) / 2.;\n    float u = dot(x, l.tangent);\n    float v = dot(x, normal(l));\n    return length(vec2(max(0., abs(u) - (l.b - l.a) / 2.), v));\n}\n\nvec4 blend(vec4 C, vec4 c, float f)\n{\n    return C + c * smoothstep(1.5, 0., f) * (1. - C.w);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tl3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 248, 248, 4292], [4294, 4294, 4323, 4323, 4387], [4389, 4389, 4416, 4416, 4458], [4460, 4460, 4481, 4481, 4513], [4515, 4515, 4542, 4542, 4726], [4728, 4728, 4765, 4765, 4823]], "test": "untested"}
{"id": "flsGRf", "name": "Attempt at Perturbation theory", "author": "TheJimJames40", "description": "Attempting this: https://fractalwiki.org/wiki/Perturbation_theory\n\nrelative to the mouse. It kind of works, but when 'Z' escapes (so them mouse is outside the Mandelbrot set) we get errors. Not sure if I am doing this right.", "tags": ["mandelbrot", "attempt", "theory", "perturbation"], "likes": 3, "viewed": 331, "published": 3, "date": "1622543178", "time_retrieved": "2024-07-30T19:17:59.654608", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = vec2(-0.649033, 0.372347);\n    float scale = pow(0.5, 20.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.y)*2.0 - 1.0 - vec2(1.5, 0.0);\n    vec2 m  = (iMouse.xy/iResolution.y)*2.0 - 1.0 - vec2(1.5, 0.0);\n    \n    // m = round(uv*10.0) / 10.0;\n    \n    vec2 c = vec2((uv-m)*scale);\n    vec2 C = vec2(m*scale + offset);\n    vec2 z = vec2(0.0);\n    vec2 Z = vec2(0.0);\n    \n    float id = 0.0;\n    for(int i = 0; i < 900; ++i) {\n        // x+iy = 2*z_n*Z_n\n        float x = 2.0*(z.x*Z.x - z.y*Z.y);\n        float y = 2.0*(z.x*Z.y + z.y*Z.x);\n        \n        // z_n+1 = z_n^2 + c + 2*Z_n*z_n\n        float a = z.x*z.x - z.y*z.y + c.x + x;\n        float b = 2.0*z.x*z.y       + c.y + y;\n        z.x = a;\n        z.y = b;\n        \n        // Z_n+1 = Z_n^2 + C\n        {\n            float a = Z.x*Z.x - Z.y*Z.y + C.x;\n            float b = 2.0*Z.x*Z.y + C.y;\n            Z.x = a;\n            Z.y = b;\n        }\n        \n        // Actual coordinate is: z+Z\n        // The idea is to calculate only a few 'Z' in high precision\n        // and the 'z' in low precision.\n        float d = dot(z, z);\n        if (d > 256.0) {\n            // https://iquilezles.org/articles/msetsmooth\n            id = float(i) - log2(log2(d)) + 4.0;\n            break;\n        }\n    }\n    \n    // Sinebow coloring\n    float pi = 3.14159265358979;\n    float t = (0.5 - id*0.02)*pi;\n    \n    float r = cos(t + pi*0.0/3.0);\n    float g = cos(t + pi*1.0/3.0);\n    float b = cos(t + pi*2.0/3.0);\n    \n    vec3 col = vec3(r*r, g*g, b*b) * min(id, 1.0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1681]], "test": "untested"}
{"id": "NtsGD7", "name": "noise_MrNissenDK", "author": "MrNissenDK", "description": "This noise algorithm is based on Perlin noise to output a random yeat smooth looking map, such as terrain for games.", "tags": ["noise", "game", "terrain", "perlin", "smooth"], "likes": 2, "viewed": 279, "published": 3, "date": "1622506875", "time_retrieved": "2024-07-30T19:18:00.577141", "image_code": "float res = 10.; // how many sqrs along the x axes\nint seed = -5;\nint detail = 8;\nbool debug = false;\n\n\nfloat pixelSize = 0.;\n\nfloat[] digitsPi = float[](14.159265,35.897932,38.462643,38.327950,28.841971,69.399375,10.582097,49.445923,78.16406,28.620899,86.280348);\n\nfloat getDigit(float index){\n    return digitsPi[int(abs(mod(index, float(digitsPi.length()))))];\n}\nfloat getDigit(int index){\n    return getDigit(float(index));\n}\nfloat getRandom(vec2 index){\n    index = mod(index, 65535.);\n    float id = length(index) * float(seed) + length(index) + float(seed);\n    return fract(sin(dot(index, vec2(getDigit(id+265.), getDigit(id+159.))))* getDigit(id + 314.));\n}\nfloat getRandom(vec3 index){\n    index = mod(index, 65535.);\n    float id = length(index) * float(seed) + length(index) + float(seed);\n    return fract(sin(dot(index, vec3(getDigit(id+265.), getDigit(id+159.), getDigit(id+582.))))* getDigit(id + 314.));\n}\nfloat smoothMix(vec2 from, vec2 to, vec2 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(getRandom(from), getRandom(vec2(to.x, from.y)), t.x),\n        mix(getRandom(vec2(from.x, to.y)), getRandom(to), t.x),\n    t.y);\n}\nfloat smoothMix(vec3 from, vec3 to, vec3 t){\n    t = smoothstep(0.,1.,t);\n    return mix(\n        mix(\n            mix(getRandom(from), getRandom(vec3(to.x, from.yz)), t.x),\n            mix(getRandom(vec3(from.x, to.y, from.z)), getRandom(vec3(to.xy, from.z)), t.x),\n        t.y),\n\n        mix(\n            mix(getRandom(vec3(from.xy, to.z)), getRandom(vec3(to.x, from.y, to.z)), t.x),\n            mix(getRandom(vec3(from.x, to.yz)), getRandom(to), t.x),\n        t.y),\n\n    t.z);\n}\nfloat getNoise(vec2 index){\n    vec2 low = floor(index);\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec2 low = floor(index);\n        _output += smoothMix(low, low + vec2(1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += float(seed) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\nfloat getNoise(vec3 index){\n    float _output = 0.;\n    float h = 0.;\n    \n    for(float i = 1.; i <= float(detail); i ++){\n        vec3 low = floor(index);\n        _output += smoothMix(low, low + vec3(1,1,1), fract(index)) * (float(detail)/i);\n        h += (float(detail)/i);\n        index += float(seed) + i;\n        index *= 2.;\n    }\n    return _output / h;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / (iResolution.x/res));\n    pixelSize = res / iResolution.y;\n    \n    vec3 col = vec3(getNoise(vec3(uv, iTime/5.)));\n    \n    if( debug && (\n        fract(uv.x) <= pixelSize || fract(uv.x) >= 1.-pixelSize || \n        fract(uv.y) <= pixelSize || fract(uv.y) >= 1.-pixelSize)\n    ) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 294, 294, 365], [366, 366, 392, 392, 429], [430, 430, 458, 458, 666], [667, 667, 695, 695, 922], [923, 923, 967, 967, 1154], [1155, 1155, 1199, 1199, 1636], [2392, 2392, 2449, 2449, 2852]], "test": "untested"}
{"id": "7tf3zX", "name": "Fork Mauno mosaic 006", "author": "mosaic", "description": "A variation of the Mandelbrot fractal", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 236, "published": 3, "date": "1622501035", "time_retrieved": "2024-07-30T19:18:01.752000", "image_code": "vec4  fC ( in vec2 fragCoord ) // Change the void mainImage of your shader to this.\n\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st *= 0.072;\n    st -= vec2(0.200,-0.990);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec2 z = st;\n    \n    for (int i=0; i<109; i++) {\n    \tvec2 z2;\n        z2.x = z.x*z.x - z.y*z.y * 1.01 + 0.011 * cos(iTime*2.123);\n        z2.y = z.x*z.y * 2.0 + 0.02 * sin(iTime);\n        z = z2;\n        z += st;\n        float d = z.x*z.x + z.y*z.y * (0.15*z.y+0.85);\n        if (d > 4.0) {\n            float step = 1.0 / 30.0;\n\t\t    color = vec3(float(i) * step);\n            vec3 cc = vec3(\n                1.0-(sqrt(cos(0.3*d))-2.0),\n                1.0-(sqrt(cos(0.6*d))-2.0),\n                1.0-(sqrt(cos(0.3*d))-2.0)\n            );\n            color += 0.4 * (0.5 + 0.5 * sin(-3.0 * iTime + 150.0 * step * cc ));\n            break;\n        }\n    }\n\n\n   return vec4(color, 1); // At the end of your shader, replace the fragColor with this return. \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 4.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 86, 86, 1023], [1025, 1025, 1082, 1082, 1384]], "test": "untested"}
