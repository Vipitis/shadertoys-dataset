{"id": "tldyRB", "name": "Electron Monte-Carlo", "author": "wyatt", "description": "Artistic interpretation of Monte-Carlo Scattering simulation", "tags": ["physics"], "likes": 37, "viewed": 612, "published": 3, "date": "1609451590", "time_retrieved": "2024-07-30T20:27:15.275260", "image_code": "Main {\n    vec4 c = C(U);\n    Q = c;\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(i) texelFetch(iChannel0,ivec2(i,0),0);\n#define B(i) texelFetch(iChannel1,ivec2(i,0),0);\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U)\n#define N 100.\nvec3 hash33(vec3 p3)\n{ // Dave H\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat ln (vec2 p, vec2 a, vec2 b) {\n\treturn length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat absmin(float a, float b) {\n\tif (b>0.) return min(a,b);\n    return a;\n}\nfloat intersect (vec2 coes) {\n\tfloat i=1e4;\n    float det = coes.x*coes.x-4.*coes.y;\n    if (det < 0.) return i;\n    det =sqrt(det);\n    i = absmin(i,0.5*(-coes.x+det));\n    i = absmin(i,0.5*(-coes.x-det));\n    return i;\n}\nfloat plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n// dot(p+d*i-c,n) = 0\n// d.n i =-(p-c).n\n    return absmin(-dot(p-c,n)/dot(d,n),1e9);\n}\nfloat sphere (vec3 p, vec3 d, vec3 c, float r) {\n\tc = p-c;\n    return intersect(vec2(2.*dot(c,d),dot(c,c)-r*r));\n}\nvec3 tubenor (vec3 p, vec3 a, vec3 b) {\n    float d = dot(p-a,b-a)/dot(b-a,b-a);\n    vec3 q = a + (b-a)*d;\n    q = p-q;\n    if (length(q)>0.) return normalize(q);\n    else return vec3(0);\n}\nfloat tube (vec3 p, vec3 d, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a,\n         ap = p-a;\n    float \n        abd = dot(ab,d),\n        abab = dot(ab,ab),\n        apd = dot(ap,d),\n        abap = dot(ab,ap),\n        apap = dot(ap,ap),\n        l = sqrt(abab);\n   float x = intersect(vec2 (\n        2.*(apd-abap*abd/abab),\n        apap-r*r-abap*abap/abab\n    )/(1.-abd*abd/abab));\n    \n    vec3 i = p+d*x;\n    float t = dot(i-a,ab)/l;\n    if (t > 0. && t < l) return x;\n    else return 1e4;\n    \n}", "buffer_a_code": "// Position update\nMain {\n    if (U.x>N || U.y > 2.) discard;\n    Q = A(U.x);\n    vec4 v = B(U.x);\n    Q += v;\n    if (iFrame < 1) {\n        Q = vec4(U.x/R.x*1e-3,-1,0,0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// velocity update - random forces \nMain {\n    if (U.x>N || U.y > 2.) discard;\n    Q = B(U.x);\n    vec4 p = A(U.x);\n    vec3 f = vec3(0);\n    \n    Q.xyz += f;\n    Q.y += -2e-5;\n    vec3 h = hash33(floor(12000.*p.xyz))*2.-1.;\n    float hl = length(h);\n    float l = length(Q.xyz);\n    if (hl>0.&&l>0.) {\n        float d = min(0.,dot(normalize(h),normalize(Q.xyz)));\n        vec3 v = Q.xyz + .01*d*normalize(h)*pow(hl,2.);\n        if (length(v)>0.)\n        Q.xyz = .985*l*normalize(v);\n    }\n    if (iFrame < 1) {\n        Q = vec4(0,3.3e-2,0,0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// draw tubes and spheres and accumulate the image\nMain {\n\n    \n    vec3 p = vec3(0,0,-1.1),\n         d = normalize(vec3(2.*(U-0.5*R)/R.y,1));\n    if (iFrame < 1) {\n        Q = vec4(0,0,0,1e9);\n        float i = plane(p,d,vec3(0,0,2),vec3(-.5,0,1));\n        if (i > 0. && i < Q.w) Q = vec4(0,1,1,i);\n        i = plane(p,d,vec3(0,-1,0),vec3(0,1,0));\n        if (i > 0. && i < Q.w) Q = vec4(1,1,0,i);\n        return;\n    }\n    Q = C(U);\n    #define rad max(.1*exp(-float(iFrame)*3e-2),.001)\n    for (float n = 0.; n < N; n++) {\n        vec4 a = A(n);\n        vec4 b = B(n);\n        float i = tube(p,d,a.xyz,a.xyz+b.xyz,rad);\n        if (i>0.&&i<Q.w) {\n            vec3 q = p + d*i;\n            Q.xyz = (reflect(d,tubenor(q,a.xyz,a.xyz+b.xyz)).x*0.5+0.8)*(0.5+0.5*sin(float(iFrame)*.02+vec3(1,2,3)));\n            Q.w = i;\n        }\n        i = sphere(p,d,a.xyz,rad);\n        if (i>0.&&i<Q.w) {\n            vec3 q = p + d*i;\n            Q.xyz = (reflect(d,normalize(q-a.xyz)).x*0.2+0.8)*(0.5+0.5*sin(float(iFrame)*.02+vec3(1,2,3)));\n            Q.w = i;\n        }\n    }\n    p = p + d*Q.w;\n    d = normalize(vec3(1,1,-1)-p);\n    p += .01*d;\n    for (float n = 0.; n < N; n++) {\n        vec4 a = A(n);\n        vec4 b = B(n);\n        float i = tube(p,d,a.xyz,a.xyz+b.xyz,rad);\n        if (i>0.&&i<1e3) {Q.xyz *= .8;break;}\n        i = sphere(p,d,a.xyz,rad);\n        if (i>0.&&i<1e3) {Q.xyz *= .8;break;}\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3ldczS", "name": "By Molive, Aged 18", "author": "Molive", "description": "Hello demoscene, I did a drawing\nWould you like to put it on the fridge?\n\nHogmanay Party 2020(/2021)\n\nUses shapes from https://iquilezles.org/articles/distfunctions2d/distfunctions2d.htm\nUses Perlin noise from https://www.shadertoy.com/view/4lB3zz", "tags": ["2d", "drawing"], "likes": 16, "viewed": 391, "published": 3, "date": "1609447656", "time_retrieved": "2024-07-30T20:27:16.015281", "image_code": "#define offset floor((iTime+4.0)*10.0)*2.2\n#define pi acos(-1.)\n\nfloat sdCircle( vec2 p, float r, float r2 )\n{\n    return abs(length(p) - r) -r2;\n}\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - 0.04;\n}\n\nfloat child(vec2 p) {\nreturn min(min(min(min(min(\nsdSegment(p,vec2(0.25,0.075),vec2(0.35,0.28)),\nsdSegment(p,vec2(0.45,0.075),vec2(0.35,0.25))),\nsdSegment(p,vec2(0.34,0.4),vec2(0.35,0.25))),\nsdSegment(p,vec2(0.34,0.4),vec2(0.45,0.3))),\nsdSegment(p,vec2(0.34,0.4),vec2(0.25,0.3))),\nsdCircle(p-vec2(0.35,0.48),0.06,0.03));\n}\n\nfloat parent(vec2 p) {\nreturn min(min(min(min(min(\nsdSegment(p,vec2(0.65,0.1),vec2(0.76,0.4)),\nsdSegment(p,vec2(0.85,0.12),vec2(0.76,0.41))),\nsdSegment(p,vec2(0.75,0.6),vec2(0.76,0.43))),\nsdSegment(p,vec2(0.75,0.6),vec2(0.9,0.52))),\nsdSegment(p,vec2(0.75,0.6),vec2(0.6,0.56))),\nsdCircle(p-vec2(0.73),0.08,0.035));\n}\n\nfloat sun(vec2 p) {\nreturn min(min(min(\nsdSegment(p,vec2(0.35,0.45),vec2(0.5,0.43)),\nsdSegment(p,vec2(0.25,0.34),vec2(0.45,0.25))),\nsdSegment(p,vec2(0.13,0.23),vec2(0.2,0.1))),\nsdCircle(p-vec2(0.1,0.5),0.08,0.08));\n}\n\nfloat grass(vec2 p) {\nreturn sdSegment(p+(vec2(0.0,sin(p.x*60.0)+sin(p.x*23.0)*0.1+fract((p.x+1.0)*10.0/pi))*0.05),vec2(0.0,0.2),vec2(2.0,0.2))-0.04;\n}\n\nfloat house(vec2 p) {\nreturn min(min(min(min(min(min(min(min(\nsdSegment(p,vec2(0.02,0.0),vec2(0.0,0.58)),\nsdSegment(p,vec2(0.0,0.58),vec2(0.5,0.6))),\nsdSegment(p,vec2(0.5,0.6),vec2(0.48,0.05))),\nsdSegment(p,vec2(0.0,0.58),vec2(0.24,0.8))),\nsdSegment(p,vec2(0.24,0.8),vec2(0.5,0.6))),\nsdSegment(p,vec2(0.15,0.0),vec2(0.18,0.28))),\nsdSegment(p,vec2(0.18,0.28),vec2(0.3,0.3))),\nsdSegment(p,vec2(0.3),vec2(0.32,0.05))),\nsdSegment(p,vec2(0.0),vec2(0.52,0.05)));\n}\n\nvec2 distort (vec2 p) {\nreturn p+(vec2(sin(p.x*104.0+offset)+cos(p.y*113.0+offset))*0.0015);\n}\n\nfloat noise (vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat smoothNoise(vec2 p)\n{\n    return noise(p)/4.0+(noise(p+vec2(1.0,0.0))+noise(p-vec2(1.0,0.0))+noise(p+vec2(0.0,1.0))+noise(p-vec2(0.0,1.0)))/8.0+(noise(p+vec2(1.0,1.0))+noise(p+vec2(1.0,-1.0))+noise(p-vec2(1.0,-1.0))+noise(p-vec2(1.0,1.0)))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*pi;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(vec2 p)\n{\n    vec2 fracp = fract(p);    \n    vec2 florp = floor(p);\n    \n    float v1 = smoothNoise(florp);\n    float v2 = smoothNoise(florp+vec2(1.0,0.0));\n    float v3 = smoothNoise(florp+vec2(0.0,1.0));\n    float v4 = smoothNoise(florp+vec2(1.0,1.0));\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracp.x);\n    float i2 = COSInterpolation(v3,v4,fracp.x);\n    \n    return COSInterpolation(i1,i2,fracp.y);\n    \n}\n\nfloat PerlinNoise2D(vec2 p)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=3;i<9;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(0.6,float(i));\n        sum = sum + InterpolationNoise(p*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float grassv = min(min(min(\n    grass(distort(uv)+vec2(0.0,0.1)),\n    grass(distort(uv)+vec2(0.12,0.2))),\n    grass(distort(uv)+vec2(0.08))),\n    grass(distort(uv)+vec2(0.04)));\n    \n    float housev = house(distort(uv+vec2(0.03))-vec2(1.25,0.1));\n    \n    float childv = child(distort(uv-vec2(0.8,-0.06))+vec2(0.8,-0.06));\n    \n    float parent1 = parent(distort(uv-vec2(0.9,0.1))+vec2(0.9,0.1));\n    \n    float parent2 = parent(mat2(0.96,-0.1,0.1,0.96)*(distort(uv-vec2(0.22,-0.06))));\n    \n    float sunv = sun(distort(uv)+vec2(0.1,-0.5));\n    \n    fragColor = vec4(0.9,0.9,0.95,0.1)*PerlinNoise2D(uv+vec2(5.0))*2.0+0.5;\n    \n    fragColor = mix(fragColor,vec4(0.8,0.8,0.03,1.0),clamp(sunv*-80.0+0.2,0.0,1.0)*PerlinNoise2D(distort(uv+vec2(1.0)+offset))*5.0*(smoothNoise(distort(uv+vec2(17.0)+mod(offset,100.0)))*0.2+0.6));\n    fragColor = mix(fragColor,vec4(0.6,0.3,0.1,1.0),clamp(housev*-80.0+0.2,0.0,1.0)*PerlinNoise2D(distort(uv+vec2(2.0)+offset))*5.0*(smoothNoise(distort(uv+vec2(19.0)+mod(offset,100.0)))*0.2+0.6));\n    fragColor = mix(fragColor,vec4(0.1,0.7,0.6,1.0),clamp(childv*-80.0+0.2,0.0,1.0)*PerlinNoise2D(distort(uv+vec2(3.0)+offset))*5.0*(smoothNoise(distort(uv+vec2(21.0)+mod(offset,100.0)))*0.2+0.6));\n    fragColor = mix(fragColor,vec4(0.9,0.45,0.6,1.0),clamp(parent1*-80.0+0.2,0.0,1.0)*PerlinNoise2D(distort(uv+vec2(7.0)+offset))*5.0*(smoothNoise(distort(uv+vec2(23.0)+mod(offset,100.0)))*0.2+0.6));\n    fragColor = mix(fragColor,vec4(0.33,0.5,0.77,1.0),clamp(parent2*-80.0+0.2,0.0,1.0)*PerlinNoise2D(distort(uv+vec2(11.0)+offset))*5.0*(smoothNoise(distort(uv+vec2(29.0)+mod(offset,100.0)))*0.2+0.6));\n    fragColor = mix(fragColor,vec4(0.2,0.7,0.0,1.0),clamp(grassv*-30.0+0.2,0.0,1.0)*PerlinNoise2D(distort(uv+vec2(13.0)+offset))*5.0*(smoothNoise(distort(uv+vec2(31.0)+mod(offset,100.0)))*0.2+0.6));\n    fragColor = log(fragColor+1.0)+0.15;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 110, 110, 147], [149, 149, 192, 192, 318], [320, 320, 341, 341, 642], [644, 644, 666, 666, 959], [961, 961, 980, 980, 1177], [1179, 1179, 1200, 1200, 1330], [1332, 1332, 1353, 1353, 1790], [1792, 1792, 1815, 1815, 1886], [1888, 1888, 1910, 1910, 1976], [1978, 1978, 2005, 2005, 2231], [2233, 2233, 2282, 2282, 2367], [2369, 2369, 2403, 2403, 2805], [2807, 2807, 2836, 2836, 3111], [3113, 3113, 3170, 3170, 5122]], "test": "untested"}
{"id": "3l3cR2", "name": "Normalized Blinn Phong", "author": "iY0Yi", "description": "unnormalized Phong version:\nhttps://www.shadertoy.com/view/3ddBDn\n\nref:\nhttps://hanecci.hatenadiary.org/entry/20130505/p2\nhttp://www.project-asura.com/program/d3d11/d3d11_006.html", "tags": ["blinnphong", "normalized"], "likes": 31, "viewed": 1083, "published": 3, "date": "1609446276", "time_retrieved": "2024-07-30T20:27:16.955767", "image_code": "\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(.9));\n    col = ACESFilm(col);\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash / Noise by Anonymous:\n// I forgot where I found this...\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <5; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n            mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f = 0.5000 * noise(p);\n    p *= 2.01;\n    f += 0.2500 * noise(p);\n    p *= 2.02;\n    f += 0.1250 * noise(p);\n\n    return f;\n}\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n\n#define AMB_COL vec3(1., 0.7717, 0.6500)\n#define AMB_STRENGTH 0.9100\n#define FOG_COL vec3(1., 0.7717, 0.6500)\n#define FOG_START 0.5740\n\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "// \"init\": initialize camera and lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3  Camera_pos;\nvec4  Camera_quat;\nfloat Camera_fov;\nvec3  sdLight001_dir;\nvec3  sdLight001_col;\nfloat sdLight001_clip_start;\nfloat sdLight001_clip_end;\nfloat sdLight001_softness;\n#define L0_dir sdLight001_dir\n#define L0_col sdLight001_col\n#define L0_str sdLight001_clip_start\n#define L0_end sdLight001_clip_end\n#define L0_sft sdLight001_softness\nvec3  sdLight002_dir;\nvec3  sdLight002_col;\nfloat sdLight002_clip_start;\nfloat sdLight002_clip_end;\nfloat sdLight002_softness;\n#define L1_dir sdLight002_dir\n#define L1_col sdLight002_col\n#define L1_str sdLight002_clip_start\n#define L1_end sdLight002_clip_end\n#define L1_sft sdLight002_softness\n\nvoid init()\n{\n\tCamera_pos = vec3(-0.0913, 38.7396, 4.6344);\n\tCamera_quat = vec4(0.0205, 0.7140, 0.6996, 0.0200);\n\tCamera_fov = 0.1974;\n\tsdLight001_dir = normalize(vec3(-0.0538, 0.6674, 0.7427));\n\tsdLight001_col = vec3(1., 0.9681, 0.8761);\n\tsdLight001_clip_start = 0.0050;\n\tsdLight001_clip_end = 50.;\n\tsdLight001_softness = 2.2260;\n\tsdLight002_dir = normalize(vec3(0.0538, -0.6674, -0.7427));\n\tsdLight002_col = vec3(0.1523, 0.1523, 0.1523);\n\tsdLight002_clip_start = 0.0500;\n\tsdLight002_clip_end = 30.;\n\tsdLight002_softness = 50.;\n\n}\n\nvec3 ro = vec3(0), rd = vec3(0);\nvec3 col = vec3(0);\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid camera(vec2 uv)\n{\n    vec3 dir = quat_rotate(Camera_quat, vec3(0,0,-1)).xzy;\n    vec3 up = quat_rotate(Camera_quat, vec3(0,1,0)).xzy;\n    vec3 pos = Camera_pos.xzy;\n    float fov = Camera_fov;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdPlane(in vec3 p){\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p,in float r)\n{\n    return length(p)-r;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per)\n{\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r)\n{\n    float h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n    float res = mix(b.x,a.x,h)-r*h*(1.0-h);\n    return vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MAT_001 vec3(0.6415, 0.6584, 0.7382)\n#define MAT_002 vec3(0.9627, 0.8670, 0.7296)\n#define MAT_003 vec3(0.5510, 0.9288, 0.9146)\n#define MAT_004 vec3(0.8725, 0.6954, 0.7670)\n#define MAT_005 vec3(0.9622, 0.9396, 0.2231)\n#define MAT_006 vec3(0.9991, 1.0000, 0.8002)\n#define MAT_007 vec3(0.5713, 0.8689, 0.6389)\n\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n\n\td = sdBox(p+vec3(1.5245, -9.0242, 0.6086), vec3(1., 1., 1.))-0.0100;\n\tres = v4OpUnion(vec4(d, MAT_004), res);\n\n\td = sdCappedTorus(rot(p+vec3(3.9270, -5.4430, -1.0193), vec3(1.5708, 0., 0.)), vec2(5.3682, 0.0245), 3.1413);\n\tres = v4OpUnion(vec4(d, MAT_007), res);\n\n\td = sdCapsule(p+vec3(-1.5767, -6.2993, -0.6990), 2.0201, 0.);\n\td = fOpUnionSmooth(sdCapsule(rot(p+vec3(-0.5540, -4.9952, -2.5487), vec3(-0.0330, 0.0176, 0.6502)), 0.0125, 6.1996), d, 0.2800);\n\tres = v4OpUnionSmooth(vec4(d, MAT_006), res, 0.4000);\n\n\td = sdConeSection(p+vec3(5.0217, -5.8192, -0.8244), 1.1768, 1.5291, 0.)-0.0100;\n\tres = v4OpUnion(vec4(d, MAT_003), res);\n\n\td = sdEllipsoid(p+vec3(7.7937, -3.2336, 1.0291), vec3(1.1783, 1.1783, 1.1783));\n\tres = v4OpUnionSmooth(vec4(d, MAT_002), res, 0.0100);\n\n\td = sdPlane(p);\n\tres = v4OpUnionSmooth(vec4(d, MAT_001), res, 0.0100);\n\n\td = sdSphere(p+vec3(-3.8602, -3.7245, 0.8280), 1.);\n\tres = v4OpUnionSmooth(vec4(d, MAT_004), res, 0.0100);\n\n\td = sdEllipsoid(rot(p+vec3(-1.6491, -3.7357, -0.7067), vec3(0., 3.1416, 0.)), vec3(0.3514, 0.3514, 0.3514));\n\tres = v4OpUnionSmooth(vec4(d, MAT_005), res, 0.8072);\n\n\td = sdEllipsoid(p+vec3(4.1916, -3.8762, -2.3231), vec3(0.0480, 0.0480, 0.0480));\n\td = fOpUnionSmooth(sdEllipsoid(p+vec3(4.1916, -4.3946, -2.3231), vec3(0.0480, 0.0480, 0.0480)), d, 0.5279);\n\td = fOpUnionSmooth(sdEllipsoid(p+vec3(-0.0216, -4.2403, 0.2753), vec3(0.5796, 0.5796, 0.5796)), d, 1.8479);\n\tres = v4OpUnionSmooth(vec4(d, MAT_003), res, 0.5279);\n\n\td = sdEllipsoid(rot(p+vec3(1.3863, -4.7328, -1.8904), vec3(-0.3705, 0.4450, -2.3236)), vec3(0.7026, 0.7026, 0.7026));\n\tres = v4OpUnionSmooth(vec4(d, MAT_004), res, 2.0786);\n\n\td = sdEllipsoid(rot(p+vec3(-2.8616, -2.8558, -0.9923), vec3(-0.3705, 0.4450, -2.3236)), vec3(0.5893, 0.5893, 0.5893));\n\tres = v4OpUnionSmooth(vec4(d, MAT_003), res, 1.5842);\n\n\td = sdEllipsoid(rot(p+vec3(0.7289, -2.3445, -2.7742), vec3(-0.3705, 0.4450, -2.3236)), vec3(0.2146, 0.2146, 0.2146));\n\tres = v4OpUnionSmooth(vec4(d, MAT_004), res, 1.2901);\n\n    return res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = 1.;\n    vec3  m = MAT_VOID;\n\n    int i = 0;\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        m = res.yzw;\n        res.x *= .5;\n        if (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n        d += res.x;\n        if (d >= MAX_DIST) break;\n    }\n\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft;\n    float res = 1.;\n    float t=mint;\n    for( int i=0; i < ITERATION; i++)\n    {\n        float h = sdScene(o + L0_dir*t).x;\n        res = min( res, k*h/t);\n        t += h;\n        if( res<0.0001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n// Phong specular\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld)\n{\n    float power = 50.;\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\nfloat ref(vec3 p, vec3 n, vec3 ld)\n{\n    float power = 1.;\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(vec3 p, vec3 n, vec3 vd, vec3 ld){\n    float m = 300.;\n    float norm_factor = (m+1.) / (2.*PI);\n    vec3 h  = normalize(vd+ld);\n    return pow(max(0., dot(h, n)), m) * norm_factor;\n}\nfloat normalizedRef(vec3 p, vec3 n, vec3 vd, vec3 ld){\n    float m = 6.;\n    float norm_factor = (m+1.) / (2.*PI);\n    vec3 h  = normalize(vd+ld);\n    return pow(max(0., dot(h, n)), m) * norm_factor;\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    if (hit.x>=MAX_DIST)\n    {\n        col=AMB_COL;\n    }\n    else\n    {\n        vec3 n = normal(p);\n        vec3 offset = n * .00001;\n        float light1 = saturate(dot(n, L0_dir)) * (1./PI)*3.5;\n        float light2 = saturate(dot(n, L1_dir)) * (1./PI);\n        float shadow = shadow(p+offset, n);\n\n        float ao=0.;\n        ao = ambientOcclusion(p, n, .1, .5);\n        ao += ambientOcclusion(p, n, .5, .5);\n        ao += ambientOcclusion(p, n, 2., 2.);\n        ao += ambientOcclusion(p, n, 4., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        float shade = 0.;\n        shade = light1;\n\n        vec3 shadeLight1 = vec3(L0_col*light1);\n        vec3 shadeLight2 = vec3(L1_col*light2);\n\n        col = shadeLight1;\n        col *= shadow;\n        col+= shadeLight2*ao;\n        col+= AMB_COL*ao*AMB_STRENGTH*(1.-normalizedRef(p, n, -rd, L0_dir)*.45);\n        col*= base_col;\n        //col = mix(col, col+L0_col, specular(p, n, L0_dir)*shadow*1.);\n        col = mix(col, col+L0_col, normalizedBlinnPhong(p, n, -rd, L0_dir)*shadow*.025);\n        col = mix(col, FOG_COL, saturate(pow(distance(ro,p)/MAX_DIST+FOG_START, 3.5)));\n    }\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    uv += offset; //\n    \n    uv = (uv*2.-1.)*iResolution.y/iResolution.x;\n    uv.x *= iResolution.x / iResolution.y;\n\n    init();\n    camera(uv);\n    render();\n\n    fragColor = vec4(col, 1.);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "// AA: Mix a new color with the average color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 new = texture(iChannel0, uv);\n    \n    if(iFrame==0){\n        fragColor = new;\n        return;\n    }\n    \n    vec4 ave = texture(iChannel1, uv);\n    fragColor = mix(new, ave, .99);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 163], [165, 165, 222, 222, 397]], "test": "untested"}
{"id": "3tdyRS", "name": "Neural Net Learn Shader from t", "author": "FrickHazard", "description": "A buffer of a small Neural networks that learns the output of a 3s shader with a network per frag.  After 60 seconds the training stops and the left image is composed purely from neural-nt.  Feel free to write your own shader, using getT(iTime) in Buff A\n", "tags": ["video", "neuralnetwork", "deeplearning", "machinelearning"], "likes": 35, "viewed": 1002, "published": 3, "date": "1609439728", "time_retrieved": "2024-07-30T20:27:17.994988", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 w1_b1_w2_b2 = texture(iChannel1, uv);\n    vec4 w3_b3_w4_b4 = texture(iChannel2, uv);\n    vec4 w5_b5_w6_b6 = texture(iChannel3, uv);\n    float t = getT(iTime);\n    vec3 rgb = forwardPropagationPrediction(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6);\n    \n    fragColor = vec4(rgb, 1.);\n    // view weight layers un-comment\n    // fragColor = w1_b1_w2_b2;\n    // fragColor = w3_b3_w4_b4;\n    // fragColor = w5_b5_w6_b6;\n    vec2 mouseCoords = iMouse.xy/iResolution.xy;\n    if ((mouseCoords.x > 0.001 && uv.x > mouseCoords.x) || (mouseCoords.x == 0. && uv.x > 0.5)) {\n      fragColor = texture(iChannel0, uv);\n    }\n    \n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// example by iq, put any shader here\n// and switch out iTime with getT(iTime)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = getT(iTime);\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tuv.x *=  iResolution.x / iResolution.y;\n\n    // background\t \n\tvec3 color = vec3(0.8 + 0.2*uv.y);\n\n    // bubbles\t\n\tfor( int i=0; i<40; i++ )\n\t{\n        // bubble seeds\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n\n        // buble size, position and color\n\t\tfloat rad = 0.1 + 0.5*siz;\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*t*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv - pos );\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\n\t\t\n        // render\n\t\tfloat f = length(uv-pos)/rad;\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\n\t}\n\n    // vigneting\t\n\tcolor *= sqrt(1.5-0.5*length(uv));\n\n\tfragColor = vec4(color,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\tvec2 uv = fragCoord / iResolution.xy;\n \n    // init\n    if (iTime == 0. || iFrame == 0){\n        fragColor = vec4(rnd(uv + vec2(2., 2.)), 0., rnd(uv - vec2(2., 2.)), 0.);\n        return;\n    }\n    \n    \n      \n    // apply back propagation\n    vec4 w1_b1_w2_b2 = texture(iChannel1, uv);\n    vec4 w3_b3_w4_b4 = texture(iChannel2, uv);\n    vec4 w5_b5_w6_b6 = texture(iChannel3, uv);\n    vec4 Y = texture(iChannel0, uv);\n    \n    if (iTime > TRAIN_DURATION) {\n        fragColor = w1_b1_w2_b2;\n        return;\n    }\n    \n    float t = getT(iTime);\n    fragColor = updatedParametersBufferB(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6, Y.rgb);\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n \n    // init\n    if (iTime == 0.|| iFrame == 0){\n        fragColor = vec4(rnd(uv + vec2(4., 4.)), 0., rnd(uv - vec2(4., 4.)), 0.);\n        return;\n    }\n      \n    // apply back propagation\n    vec4 w1_b1_w2_b2 = texture(iChannel1, uv);\n    vec4 w3_b3_w4_b4 = texture(iChannel2, uv);\n    vec4 w5_b5_w6_b6 = texture(iChannel3, uv);\n    vec4 Y = texture(iChannel0, uv);\n    \n    if (iTime > TRAIN_DURATION) {\n        fragColor = w3_b3_w4_b4;\n        return;\n    }\n    \n    float t = getT(iTime);\n    fragColor = updatedParametersBufferC(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6, Y.rgb);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//MIT License\n\n//Copyright (c) [2020] [Ender Doe]\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n#define LEARNING_RATE 0.005\n#define CLIP_DURATION 3.\n#define TRAIN_DURATION (CLIP_DURATION * 20.)\n#define PI 3.1415926535897932384626433832\n\n// Each frag has an independent neural net composed\n// of relu -> reulu -> (relu, relu, relu); a shape of (1,1,3)\n// Buffer A is the shader being learned\n// Buffer B C D are the bias and weights for nodes per frag\n// There is some duplicated computation, trading storage for re compute\n// Layers are updated one at a time so training is very stochastic\n\nfloat getT(float iTime){\n return 0.5 + 0.5 * cos(iTime * PI);\n}\nfloat rnd(vec2 n) {\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// alternate getT which randomly samples t values, pretty interesting\n// float getT(float iTime){\n// return step(TRAIN_DURATION, iTime) * mod(iTime, CLIP_DURATION) +\n//     (1. - step(TRAIN_DURATION, iTime)) * rnd(vec2(iTime, iTime + 0.3));\n//}\n\n\nfloat relu(float x) {\n    return max(0., x);\n}\n\nfloat reluD(float x) {\n    return step(0., x);\n}\n\n\nfloat meanSquaredError (vec3 groundTruth, vec3 prediction) {\n    vec3 diff = groundTruth - prediction;\n    float loss = ((diff.x * diff.x)+(diff.y * diff.y)+(diff.z*diff.z)) * (1./3.);\n \n return loss;\n}\n\n// CIE XYZ, color space\n//https://arxiv.org/pdf/1902.00267.pdf\nmat3 CIE_XYZ_MAT = mat3(\n    0.489989, 0.310008, 0.2,\n    0.176962, 0.81240, 0.010,\n    0, 0.01, 0.99\n);\nvec3 meanSquaredErrorGrad (vec3 groundTruth, vec3 prediction) {\n    vec3 predXYZ = CIE_XYZ_MAT * prediction;\n    vec3 truthXYZ = CIE_XYZ_MAT * groundTruth;\n    return CIE_XYZ_MAT * vec3(\n        (predXYZ.r - truthXYZ.r),\n        (predXYZ.g - truthXYZ.g),\n        (predXYZ.b - truthXYZ.b) \n    ); \n}\n\n\nvec3 forwardPropagationPrediction(float t, vec4 w1_b1_w2_b2, vec4 w3_b3_w4_b4, vec4 w5_b5_w6_b6)\n{\n    float a1 = relu(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float a2 = relu(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a3 = relu(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    \n    float r = relu(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float g = relu(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float b = relu(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    \n    return vec3(r, g, b);\n}\n\nvec4 updatedParametersBufferB(float t, vec4 w1_b1_w2_b2, vec4 w3_b3_w4_b4, vec4 w5_b5_w6_b6, vec3 Y){\n    float a1 = relu(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float a2 = relu(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a3 = relu(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float r = relu(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float g = relu(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float b = relu(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    \n    vec3 prediction = forwardPropagationPrediction(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6);\n    vec3 lossGrad = meanSquaredErrorGrad(Y, prediction);\n    float bD =  reluD(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    float gD =  reluD(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float rD =  reluD(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float a3D =  reluD(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float a2D =  reluD(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a1D =  reluD(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float layer3D = dot(vec3(w3_b3_w4_b4.z, w5_b5_w6_b6.x, w5_b5_w6_b6.z), vec3(rD * lossGrad.r, gD * lossGrad.g, bD * lossGrad.z));\n    \n    return vec4(\n        w1_b1_w2_b2.x - LEARNING_RATE * (a1D * (a2D * w1_b1_w2_b2.z) * (a3D * w3_b3_w4_b4.x) * layer3D) * t,\n        w1_b1_w2_b2.y - LEARNING_RATE * (a1D * (a2D * w1_b1_w2_b2.z) * (a3D * w3_b3_w4_b4.x) * layer3D),\n        w1_b1_w2_b2.z - LEARNING_RATE * (a2D * (a3D * w3_b3_w4_b4.x) * layer3D) * a1,\n        w1_b1_w2_b2.w - LEARNING_RATE * (a2D * (a3D * w3_b3_w4_b4.x) * layer3D)\n    );\n}\nvec4 updatedParametersBufferC(float t, vec4 w1_b1_w2_b2, vec4 w3_b3_w4_b4, vec4 w5_b5_w6_b6, vec3 Y){\n    float a1 = relu(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float a2 = relu(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a3 = relu(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float r = relu(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float g = relu(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float b = relu(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    \n    vec3 prediction = forwardPropagationPrediction(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6);\n    vec3 lossGrad = meanSquaredErrorGrad(Y, prediction);\n    \n    float bD =  reluD(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    float gD =  reluD(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float rD =  reluD(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float a3D =  reluD(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float layer3D = dot(vec3(w3_b3_w4_b4.z, w5_b5_w6_b6.x, w5_b5_w6_b6.z), vec3(rD * lossGrad.r, gD * lossGrad.g, bD * lossGrad.b));\n    \n    return vec4(\n        w3_b3_w4_b4.x - LEARNING_RATE * (a3D * layer3D) * a2,\n        w3_b3_w4_b4.y - LEARNING_RATE * (a3D * layer3D),\n        w3_b3_w4_b4.z - LEARNING_RATE * (rD * lossGrad.r) * a3,\n        w3_b3_w4_b4.w - LEARNING_RATE * (rD * lossGrad.r)\n    );\n}\nvec4 updatedParametersBufferD(float t, vec4 w1_b1_w2_b2, vec4 w3_b3_w4_b4, vec4 w5_b5_w6_b6, vec3 Y){\n    float a1 = relu(w1_b1_w2_b2.x *  t + w1_b1_w2_b2.y);\n    float a2 = relu(w1_b1_w2_b2.z * a1 + w1_b1_w2_b2.w);\n    float a3 = relu(w3_b3_w4_b4.x * a2 + w3_b3_w4_b4.y);\n    float r  = relu(w3_b3_w4_b4.z * a3 + w3_b3_w4_b4.w);\n    float g  = relu(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n    float b  = relu(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    \n    vec3 prediction = forwardPropagationPrediction(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6);\n    vec3 lossGrad = meanSquaredErrorGrad(Y, prediction);\n    \n    float bD =  reluD(w5_b5_w6_b6.z * a3 + w5_b5_w6_b6.w);\n    float gD =  reluD(w5_b5_w6_b6.x * a3 + w5_b5_w6_b6.y);\n   \n    return vec4(\n        w5_b5_w6_b6.x - LEARNING_RATE * (gD * lossGrad.g) * a3,\n        w5_b5_w6_b6.y - LEARNING_RATE * (gD * lossGrad.g),\n        w5_b5_w6_b6.z - LEARNING_RATE * (bD * lossGrad.b) * a3,\n        w5_b5_w6_b6.w - LEARNING_RATE * (bD * lossGrad.b)\n    );\n}", "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n \n    // init\n    if (iTime == 0.|| iFrame == 0){\n        fragColor = vec4(rnd(uv + vec2(6., 6.)),0., rnd(uv - vec2(6., 6.)), 0.);\n        return;\n    }\n      \n    // apply back propagation\n    vec4 w1_b1_w2_b2 = texture(iChannel1, uv);\n    vec4 w3_b3_w4_b4 = texture(iChannel2, uv);\n    vec4 w5_b5_w6_b6 = texture(iChannel3, uv);\n    vec4 Y = texture(iChannel0, uv);\n    \n    if (iTime > TRAIN_DURATION) {\n        fragColor = w5_b5_w6_b6;\n        return;\n    }\n    \n    float t = getT(iTime);\n    fragColor = updatedParametersBufferD(t, w1_b1_w2_b2, w3_b3_w4_b4, w5_b5_w6_b6, Y.rgb);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 728]], "test": "untested"}
{"id": "Wlcyzj", "name": "5x3 Font demo", "author": "levonchic", "description": "5x3 Font bitmap with defined letter numbers & function for letter pixel access", "tags": ["bitmap", "font"], "likes": 6, "viewed": 459, "published": 3, "date": "1609438537", "time_retrieved": "2024-07-30T20:27:18.741991", "image_code": "// MIT License (c) bitrate16\n// Something went wrong in process, so \n//  here is minecraft enchantment list:\n// #define GLITCH\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#ifdef GLITCH\n    // Calculate what?\n    ivec2 res = ivec2(iResolution.xy / vec2(40, 60));\n    ivec2 px = ivec2(fragCoord.xy) / 10;\n    int letter = res.x * px.y + px.x + int(iTime * 4.0);\n    letter %= LETTERS;\n    px %= ivec2(4, 6);\n    fragColor = fontpix(px, letter);\n#else\n    // Scale to make pixels square\n    fragCoord *= iResolution.xy / vec2(max(iResolution.x, iResolution.y));\n    \n    // Scale resolution to fit 20 letters in a row\n    vec2 res = iResolution.xy / 79.0;\n    \n    // Calculate new frag coord to fot to calculated resolution\n    vec2 frag = fragCoord / res;\n    \n    // Calculate letter position\n    ivec2 pos = ivec2(frag / vec2(4.0, 6.0));\n    \n    // Calculate int pixel position in a single letter\n    ivec2 px = ivec2(frag.xy) % ivec2(4, 6);\n    \n    // Calculate letter number\n    int letter = pos.y * 10 + pos.x + int(iTime * 2.0);\n    \n    // Limit loop\n    letter %= LETTERS;\n    \n    // Color dat boi\n    fragColor = fontpix(px, letter);\n#endif\n}", "image_inputs": [], "common_code": "// Font data\n\n#define LETTERS 57\n\n// Letters\n// 0                        25 26       35 36  38  40  42  44 45  47 48 49 50  52 53 54  56\n// v                        v  v        v  v   v   v   v   v  v   v  v  v  v   v  v  v   v\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ  0123456789  []  <>  ()  {}  *  /\\  ,  -  .  '\"  +  =  :;  █\n\n#define A 0\n#define B 1\n#define C 2\n#define D 3\n#define E 4\n#define F 5\n#define G 6\n#define H 7\n#define I 8\n#define J 9\n#define K 10\n#define L 11\n#define M 12\n#define N 13\n#define O 14\n#define P 15\n#define Q 16\n#define R 17\n#define S 18\n#define T 19\n#define U 20\n#define V 21\n#define W 22\n#define X 23\n#define Y 24\n#define Z 25\n\n#define D0 26 // 0\n#define D1 27 // 1\n#define D2 28 // 2\n#define D3 29 // 3\n#define D4 30 // 4\n#define D5 31 // 5\n#define D6 32 // 6\n#define D7 33 // 7\n#define D8 34 // 8\n#define D9 35 // 9\n\n#define BRK0 36 // [\n#define BRK1 37 // ]\n\n#define ANG0 38 // <\n#define ANG1 39 // >\n\n#define PAR0 40 // (\n#define PAR1 41 // )\n\n#define BRC0 42 // {\n#define BRC1 43 // }\n\n#define MULT 44 // *\n\n#define SLASH0 45 // /\n#define SLASH1 46 // \\\n\n#define COMMA 47 // ,\n\n#define MINUS 48 // -\n\n#define DOT 49 // .\n\n#define QUOT 50 // '\n\n#define DQOUT 51 // \"\n\n#define PLUS 52 // +\n\n#define EQUALS 53 // =\n\n#define COLCOL 54 // :\n\n#define SEMCOL 55 // ;\n\n#define BLOCK 56 // █\n\nconst vec4[2] palette = vec4[2] (\n\tvec4(1.0, 1.0, 1.0, 1.0),\n\tvec4(0.0, 0.0, 0.0, 0.0)\n);\n\nconst int[27] matrix = int[27] (\n\t0x8a00160, 0x8b80e70, 0x45eb0394, 0xe06c097,\n\t0xd802e6b8, 0x2e0f7804, 0x7001100, 0x41d11ac0,\n\t0xed55a8b0, 0x183c0781, 0xc818047c, 0xa61f0726,\n\t0x2c0700c, 0xa70948f, 0x42840d8c, 0xf7a140,\n\t0x284050, 0xec0e739c, 0x3fdd5cea, 0x6ff173a,\n\t0x775d81ce, 0xc9bdf3e5, 0xef7bff7d, 0xe7f9ffef,\n\t0xaee3bf9f, 0x7dfafeb5, 0xfd\n);\n\nvec4 fontpix(ivec2 px, int letter) {\n    if (px.x < 0 || px.y < 0 || px.x >= 3 || px.y >= 5)\n        return palette[1];\n    \n    int pxv = px.y + px.x * 5 + letter * 15;\n    \n    if (pxv < 0 || pxv >= 15 * LETTERS)\n        return palette[1];\n    \n    int pind = pxv >> 5;\n    int bind = pxv & 31;\n\n    return palette[(matrix[pind] >> bind) & 1];\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wlcyzj.jpg", "access": "api", "license": "mit", "functions": [[128, 128, 183, 183, 1166]], "test": "untested"}
{"id": "WlcyRj", "name": "Day 379 - Wythoff & Dual Tilings", "author": "jeyko", "description": "potate", "tags": ["tiling", "wythoff", "mdtmjvm"], "likes": 12, "viewed": 343, "published": 3, "date": "1609437198", "time_retrieved": "2024-07-30T20:27:19.577756", "image_code": "// Black Lines are the main tiling\n// White lines are the dual \n\n// Honestly, the code isn't a very tidy read, so you might want to look at some other resources\n// if you'd like to do this yourself.\n\n// Here's some other takes on Wythoff tiling:\n// by fizzer: https://www.shadertoy.com/view/3tyXWw\n// by mla: https://www.shadertoy.com/view/ttGSRy\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\nfloat id = 0.;\n\nvec2 refl(vec2 p, vec2 reflectionPlane, float offs){\n    float dotReflectionPlane = dot(p + reflectionPlane*offs,reflectionPlane);\n    dotReflectionPlane = max(abs(dotReflectionPlane),0.)*sign(dotReflectionPlane);\n    p -= min(dotReflectionPlane,0.)*2.*reflectionPlane;\n    id+= float(dotReflectionPlane<0.)*4. + float(dotReflectionPlane<0.)*dotReflectionPlane*.84;\n    return p;\n}\n\nvec3 get(vec2 fragCoord){\n    vec3 col = vec3(0);\n    id = 0.;\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 3. + sin(iTime*0.4)*0.2;\n    float cntSides = 3.;\n    \n    if(iMouse.x/iResolution.x<0.33){\n        cntSides = 3.;\n    } else if(iMouse.x/iResolution.x<0.66){\n        cntSides = 4.;\n    } else {\n        cntSides = 6.;\n    } \n    \n    float cntIters = 20.;\n    \n    vec2 p = uv;\n    \n    \n    float radiusInscribedCircle = 0.4;\n    \n    for(float iter = 0.; iter < cntIters; iter++){\n        vec2 sidePlane = vec2(1.,0.);\n        \n        for(float side = 0.; side < cntSides; side++){\n            sidePlane *= rot(tau/cntSides);\n            \n            p = refl( p,sidePlane,radiusInscribedCircle);\n\n        }\n        vec2 reflectionPlane = vec2(1.,0.);\n        for(float side = 0.; side < cntSides; side++){\n            \n            \n            p = refl( p, reflectionPlane, 0.);\n            \n            \n            reflectionPlane *= rot(pi/cntSides);\n\n        }\n\n    }\n    \n    \n    float hexCircumCircleRadius = radiusInscribedCircle/(sqrt(3.)/2.);\n    float triangleRadius = radiusInscribedCircle*1.44;\n    \n    col += pal(0.5,vec3(0.5,.3,0.1),vec3(1.5,2.6,4.4),1.,id + iTime );\n    \n    float d = length(p.y - radiusInscribedCircle * (\n                + 1.*float(cntSides == 4.)\n                + triangleRadius*float(cntSides == 3.)\n                ) \n            );\n            \n    \n    vec2 dualness = mix(vec2(0),\n        0.7 + 0.1*vec2(sin(iTime), cos(iTime)),\n        0. + iMouse.y/iResolution.y\n    );\n\n    if (cntSides == 6.){\n        d = length((p*rot(pi/6.)).y - hexCircumCircleRadius*0.85);                \n    }\n\n    // Positioning duals\n    if(cntSides == 3.){\n        // some number crunching here\n        p.x += 0.175*triangleRadius;\n        p = refl( p, -vec2(0,1.), hexCircumCircleRadius*0.5 );\n        p.x -= 0.175*triangleRadius;\n        \n        \n        p.y -= dualness.y*0.5*hexCircumCircleRadius;\n        \n        p.x -= 0.5*dualness.x*0.7*triangleRadius;\n        \n        //p.x -= 0.01\n        //p.x -= 0.7*dualness.x*0.66*triangleRadius;\n        //p.y += -0.5*dualness.y*0.45*triangleRadius;\n        \n        \n    } else if(cntSides == 6.){    \n        p.y -= 1.5*dualness.y*0.6*hexCircumCircleRadius;\n        p.x -= 1.5*dualness.x*0.15*radiusInscribedCircle;\n    \n        p *= rot(0.666*pi*float(cntSides==6.));  // the number of the beast .-.\n\n    }  else if(cntSides == 4.) {\n        p.x -= dualness.x*0.4*radiusInscribedCircle;\n        p.y -= dualness.y*0.9*radiusInscribedCircle;\n    }\n    \n    \n    float dDual = max(length(p.x), - p.y );\n    dDual = min( dDual, \n            max( length(p.y), p.x)\n        );\n        \n    p *= rot(0.325*pi*float(cntSides==3. || cntSides==6.));\n    p *= rot(0.25*pi*float(cntSides==4.));\n    \n    \n    dDual = min( dDual, \n            max( length(p.y), -p.x)\n        );\n    if (cntSides == 6.){\n        //dDual = d + 0.*(d = dDual); // oh my, not the prettiest line of code, haha.  \n    }\n    \n    \n    d = min(d, length(p) - 0.03);\n    \n    d -= 0.01;\n    dDual -= 0.007;\n    \n    col = mix(col,vec3(1.), smoothstep(dFdx(uv.x), 0., dDual));\n    col = mix(col,vec3(0.), smoothstep(dFdx(uv.x), 0., d));\n    \n    \n    col = max(col,0.);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    float aa = 3.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + 0.66*vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;    \n    \n    //col = mix(col, smoothstep(0.,1.,col*vec3(1.6,1.2,1.4)),0.5);\n    \n    col = pow(col,vec3(0.8545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[511, 511, 563, 563, 892], [894, 894, 919, 919, 4165], [4166, 4166, 4223, 4223, 4583]], "test": "untested"}
{"id": "WdGGWh", "name": "Q321 Texture Sketchbook", "author": "adx", "description": "Procedural texture sketchbook used for my [url=https://twitter.com/andrei_drexler/status/1334224218565857288]Quake 3 demake[/url].\nUncomment individual textures in the Image tab to view them.\nNote: exclamation mark = WIP/placeholder.", "tags": ["procedural", "textures", "quake", "arena"], "likes": 27, "viewed": 834, "published": 3, "date": "1609434435", "time_retrieved": "2024-07-30T20:27:21.089713", "image_code": "/***************************************************************\nQ321 Texture Sketchbook / Andrei Drexler 2020\nhttps://github.com/andrei-drexler/q321\n\nUncomment one of the textures below (exclamation mark = WIP/placeholder)\n\nControls:\n  arrows, mouse drag  = pan\n  +-, Ctrl+mouse drag = zoom\n  Alt+mouse drag      = scrub time\n  /                   = reset zoom & pan\n  M                   = cycle RGB/alpha mode (checker/checker+alpha test/RGB/alpha/black matte)\n  T                   = toggle tiling\n  C                   = toggle center/left-aligned\n\nPoor-man's 'Go to definition': double-click to select word, Ctrl+F (search), Enter\nCtrl+G = next match, Shift+Ctrl+G = previous match\n***************************************************************/\n\n//#define SHOW_TEXTURE\t\tgcntr2trn,      256, 256 // gothic_floor/center2trn (texture)\n//#define SHOW_TEXTURE\t\tgcntr2trn_m,    256, 256 // gothic_floor/center2trn (map shader)\n//#define SHOW_TEXTURE\t\tglrgbk3b,       512, 512 // gothic_floor/largerblock3b\n//#define SHOW_TEXTURE\t\tglrgbk3bbld,    256, 256 // gothic_block/largerblock3blood (texture)\n//#define SHOW_TEXTURE\t\tglrgbk3bbld_m,  256, 256 // gothic_block/largerblock3blood (map shader)\n//#define SHOW_TEXTURE\t\tglrgbk3bow,\t    256, 256 // gothic_floor/largerblock3b_ow (texture)\n//#define SHOW_TEXTURE\t\tglrgbk3bow_m,   256, 256 // gothic_floor/largerblock3b_ow (map shader)\n//#define SHOW_TEXTURE\t\tgblks15,        256, 256 // ! gothic_block/blocks15\n//#define SHOW_TEXTURE\t\tgblks18c,       256, 256 // gothic_block/blocks18c\n//#define SHOW_TEXTURE\t\tgklblki,        256, 256 // gothic_block/killblock_i\n//#define SHOW_TEXTURE\t\tgklblki4,       256, 256 // ! gothic_block/killblock_i4\n//#define SHOW_TEXTURE\t\tgkblkgmtrn,     256, 256 // ! gothic_block/killblockgeomtrn\n//#define SHOW_TEXTURE\t\tgdmnblk15fx,    256, 256 // ! gothic_block/demon_block15fx\n//#define SHOW_TEXTURE\t\tgtbsbrd09e,     256, 128 // gothic_trim/baseboard09_e\n//#define SHOW_TEXTURE\t\tgtbsbrd09c3,    256, 128 // gothic_trim/baseboard09_c3\n//#define SHOW_TEXTURE\t\tgtbsbrd09o3,    256, 128 // ! gothic_trim/baseboard09_o3\n//#define SHOW_TEXTURE\t\tscmpblk17,      256, 256 // sfx/computer_blocks17 (texture)\n//#define SHOW_TEXTURE\t\tscmpblk17_m,    256, 256 // sfx/computer_blocks17 (map shader)\n//#define SHOW_TEXTURE\t\tgspbdrbb,        64, 256 // gothic_wall/supportborder_blue_b\n//#define SHOW_TEXTURE\t\tgmtlsp4b,       256, 256 // gothic_trim/metalsupport4b\n//#define SHOW_TEXTURE\t\tgwdclg1a,       256, 256 // gothic_ceiling/woodceiling1a\n//#define SHOW_TEXTURE\t\tgwdclg1bd,      256, 256 // gothic_ceiling/woodceiling1b_dark\n//#define SHOW_TEXTURE\t\tgiron01e,       256, 256 // gothic_wall/iron01_e\n//#define SHOW_TEXTURE\t\tgiron01nt3,     128, 256 // ! gothic_wall/iron01_ntech3\n//#define SHOW_TEXTURE\t\tgskull4,        256, 256 // gothic_wall/skull4\n//#define SHOW_TEXTURE\t\tskcpthrt,       256, 256 // skin/chapthroat\n//#define SHOW_TEXTURE\t\tskcpthrt2,      256, 256 // skin/chapthroat2\n//#define SHOW_TEXTURE\t\tskcpthrtooz,    256, 256 // skin/chapthroatooz\n//#define SHOW_TEXTURE\t\tsktongue,\t\t256, 256 // skin/tongue_trans\n//#define SHOW_TEXTURE\t\tcmet52,         256, 256 // base_wall/c_met5_2\n//#define SHOW_TEXTURE\t\tcmet72,         256, 256 // base_wall/c_met7_2\n//#define SHOW_TEXTURE\t\tsteed1gf,       128,  64 // base_wall/steed1gf\n//#define SHOW_TEXTURE\t\tdmnd2c,         256, 256 // base_floor/diamond2c\n//#define SHOW_TEXTURE\t\tdmnd2cjp,       256, 256 // ! sfx/diamond2cjumppad (texture)\n//#define SHOW_TEXTURE\t\tdmnd2cjp_m,     256, 256 // sfx/diamond2cjumppad (map shader)\n//#define SHOW_TEXTURE\t\tdmnd2cow,       256, 256 // base_floor/diamond2c_ow (texture)\n//#define SHOW_TEXTURE\t\tdmnd2cow_m,     256, 256 // base_floor/diamond2c_ow (map shader)\n//#define SHOW_TEXTURE\t\tdmnd2pnt,       256, 256 // ! sfx/pentfloor_diamond2c (texture)\n//#define SHOW_TEXTURE\t\tdmnd2pnt_m,     256, 256 // ! sfx/pentfloor_diamond2c (map shader)\n//#define SHOW_TEXTURE\t\tlpdmnd,         256, 256 // ! sfx/launchpad_diamond (texture)\n//#define SHOW_TEXTURE\t\tlpdmnd_m,       256, 256 // sfx/launchpad_diamond (map shader)\n//#define SHOW_TEXTURE\t\tbglogo,         512, 512 // sfx/logo512\n//#define SHOW_TEXTURE\t\tmenubnr,        256,  64 // main menu banner (texture)\n//#define SHOW_TEXTURE\t\tmenubnr_m,      256, 256 // main menu banner (menu shader)\n//#define SHOW_TEXTURE\t\tq3bnr,          256,  64 // base_wall/main_q3abanner\n//#define SHOW_TEXTURE\t\tbrdr11b,         64,  32 // base_trim/border11b\n//#define SHOW_TEXTURE\t\tcable,          128, 128 // base_support/cable\n//#define SHOW_TEXTURE\t\tgpntgmlt1k,      64,  64 // gothic_light/pentagram_light1_1k\n//#define SHOW_TEXTURE\t\tlt2,             64,  64 // base_light/lt2_2000\n//#define SHOW_TEXTURE\t\tlight5,          16, 128 // base_light/light5_5k\n//#define SHOW_TEXTURE\t\tblt414k,         64, 256 // ! base_light/baslt4_1_4k\n//#define SHOW_TEXTURE\t\tbmtsprt,        256, 128 // base_trim/basemetalsupport\n//#define SHOW_TEXTURE\t\tgmtlspsld,      256, 256 // gothic_trim/metalsupsolid\n//#define SHOW_TEXTURE\t\tmtlfb3,         256, 256 // ! base_wall/metfloor_block_3\n//#define SHOW_TEXTURE\t\tmtlfw10,        256, 256 // ! base_wall/metalfloor_wall_10\n//#define SHOW_TEXTURE\t\tmtlfw15,        256, 256 // ! base_wall/metalfloor_wall_15\n//#define SHOW_TEXTURE\t\tmtlfw15ow,      256, 256 // ! base_wall/metalfloor_wall_15ow (texture)\n//#define SHOW_TEXTURE\t\tmtlbk03,        256, 256 // base_wall/metalblack03\n//#define SHOW_TEXTURE\t\tmtlt6f,         256, 256 // ! base_wall/metaltech06final\n//#define SHOW_TEXTURE\t\tmtlt12f,        256, 256 // ! base_wall/metaltech12final\n//#define SHOW_TEXTURE\t\tgmtlbg6,        256, 256 // gothic_floor/metalbridge06\n//#define SHOW_TEXTURE\t\tgmtlbg6brk,     256, 256 // gothic_floor/metalbridge06broke\n//#define SHOW_TEXTURE\t\tgxstrtop4,      256,  32 // gothic_floor/xstairtop4\n//#define SHOW_TEXTURE\t\tgxstrtop4bbrn,  256,  32 // gothic_floor/xstairtop4bbrn\n//#define SHOW_TEXTURE\t\tgxstpbrdr3brn,  256,  16 // gothic_floor/xstepborder3brn\n//#define SHOW_TEXTURE\t\tgsltrfc,        256, 256 // ! gothic_wall/slateroofc\n//#define SHOW_TEXTURE\t\tgblks17f2,      256, 256 // gothic_floor/blocks17floor2\n//#define SHOW_TEXTURE\t\tgkarnarcfnl,    256, 576 // ! gothic_door/km_arena1archfinal* (composite)\n//#define SHOW_TEXTURE\t\tgkarnarcfnltp,  256,  64 // ! gothic_door/km_arena1archfinalc_top\n//#define SHOW_TEXTURE\t\tgkarnarcfnlmd,  256, 256 // ! gothic_door/km_arena1archfinald_mid\n//#define SHOW_TEXTURE\t\tgkarnarcfnlbt,  256, 256 // ! gothic_door/km_arena1archfinald_bot\n//#define SHOW_TEXTURE\t\tgkarnclma2r,     64, 512 // ! gothic_door/km_arena1columna2R\n//#define SHOW_TEXTURE\t\tflame,          128, 256 // sfx/flame2\n//#define SHOW_TEXTURE\t\ttimhel,         256, 256 // skies/tim_hell\n//#define SHOW_TEXTURE\t\tlava,           256, 256 // liquids/lavahellflat_400\n//#define SHOW_TEXTURE\t\tbwprtbnr,       128, 256 // base_wall/protobanner\n//#define SHOW_TEXTURE\t\tgsklvtg02b,     256, 256 // gothic_trim/skullsvertgray02b\n//#define SHOW_TEXTURE\t\tgskdr,          384, 384 // ! gothic_door/skull_door_* (composite)\n//#define SHOW_TEXTURE\t\tgskdr_a,         64, 256 // ! gothic_door/skull_door_a (bottom right)\n//#define SHOW_TEXTURE\t\tgskdr_b,        256, 256 // ! gothic_door/skull_door_b (bottom mid)\n//#define SHOW_TEXTURE\t\tgskdr_c,         64, 256 // ! gothic_door/skull_door_c (bottom left)\n//#define SHOW_TEXTURE\t\tgskdr_d,         64, 128 // ! gothic_door/skull_door_d (top right)\n//#define SHOW_TEXTURE\t\tgskdr_e,        256, 128 // ! gothic_door/skull_door_e (top mid)\n//#define SHOW_TEXTURE\t\tgskdr_f,         64, 128 // ! gothic_door/skull_door_f (top left)\n//#define SHOW_TEXTURE\t\tlion,\t        256, 256 // ? models/mapobjects/wallhead/lion.tga\n//#define SHOW_TEXTURE\t\tgr8torch2b,\t     32,  64 // models/mapobjects/gratelamp/gratetorch2b.tga\n//#define SHOW_TEXTURE\t\tflare03,        256, 256 // models/mapobjects/lamps/flare03\n//#define SHOW_TEXTURE\t\tbotflare,       256, 256 // models/mapobjects/lamps/bot_flare\n//#define SHOW_TEXTURE\t\ttlpnrg,          64, 128 // models/mapobjects/teleporter/energy.tga\n//#define SHOW_TEXTURE\t\ttlptrns,        256, 256 // models/mapobjects/teleporter/transparency.tga\n//#define SHOW_TEXTURE\t\tbotwing,        128,  64 // ! models/mapobjects/lamps/bot_wing.tga (texture)\n//#define SHOW_TEXTURE\t\tbotlamp,        256, 256 // ? models/mapobjects/lamps/bot_lamp.tga (texture)\n//#define SHOW_TEXTURE\t\trocketl,        256, 256 // \n//#define SHOW_TEXTURE\t\tplasma_glo,     256, 256 // models/weapons2/plasma/plasma_glo.tga\n//#define SHOW_TEXTURE\t\tarmornrg,       256, 256 // models/powerups/armor/energy_red1.tga\n//#define SHOW_TEXTURE\t\tbotflare2,       32, 128 // models/mapobjects/lamps/bot_flare2.tga\n//#define SHOW_TEXTURE\t\ticon_health,     64,  64 // icons/iconh_yellow.tga\n//#define SHOW_TEXTURE\t\ticon_shard,      64,  64 // icons/iconr_shard.tga\n//#define SHOW_TEXTURE\t\ticon_armor,      64,  64 // icons/iconr_yellow.tga\n//#define SHOW_TEXTURE\t\ticon_machinegun, 64,  64 // icons/iconw_machinegun.tga\n//#define SHOW_TEXTURE\t\ticon_shotgun,    64,  64 // icons/iconw_shotgun.tga\n//#define SHOW_TEXTURE\t\ticon_rocketl,    64,  64 // icons/iconw_rocket.tga\n//#define SHOW_TEXTURE\t\ticon_plasma,     64,  64 // icons/iconw_plasma.tga\n//#define SHOW_TEXTURE\t\ticon_railgun,    64,  64 // icons/iconw_railgun.tga\n//#define SHOW_TEXTURE\t\ticon_quad,       64,  64 // icons/quad.tga\n//#define SHOW_TEXTURE\t\tcrosshaira,\t\t 64,  64 // gfx/2d/crosshaira\n//#define SHOW_TEXTURE\t\tcrosshairb,\t\t 64,  64 // gfx/2d/crosshairb\n//#define SHOW_TEXTURE\t\tcrosshairc,\t\t 64,  64 // gfx/2d/crosshairc\n//#define SHOW_TEXTURE\t\tuiframe,        256, 256 // menu/art/addbotframe.tga\n//#define SHOW_TEXTURE\t\tmapselect,      256, 256 // menu/art/maps_select.tga\n//#define SHOW_TEXTURE\t\tslider2,        256,  32 // menu/art/slider2.tga\n//#define SHOW_TEXTURE\t\tsliderbutt1,     32,  64 // menu/art/sliderbutt_1.tga\n\n////////////////////////////////////////////////////////////////\n/***************************************************************\n\nMany thanks to:\n\n- id Software for the original Quake III artwork\n\n- Beautypi for Shadertoy\n\n- Inigo Quilez for articles and code covering noise, signed distance fields, and more\n  https://iquilezles.org/\n\n- @Dave_Hoskins for the \"Hash without Sine\" functions\n  https://www.shadertoy.com/view/4djSRW\n\n- @Shane for the 'Asymmetric Blocks' function\n  https://www.shadertoy.com/view/Ws3GRs\n\n- Dr Martin Roberts for the R-sequence\n  http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n***************************************************************/\n////////////////////////////////////////////////////////////////\n\n#ifndef SHOW_TEXTURE\n#define SHOW_TEXTURE\t\tslideshow, 256, 256\n#endif\n\n#define INITIAL_UV_SCALE\t1./1.\n#define INITIAL_UV_OFFSET\tvec2(0, 0)\n\n////////////////////////////////////////////////////////////////\n\n#undef TEX\n#undef TEXA\n#undef T0\n\nvec4 Time;\nvec4 FCol = vec4(0);\nvec2 UV;\n\nvec3 Light() \t\t\t{ return vec3(1); }\n\n#define TEX(name)\t\tvec3 name(vec2 uv); void name() { FCol = vec4(name(fract(UV)), 1); } vec3 name(vec2 uv)\n#define TEXA(name)\t\tvec4 name(vec2 uv); void name() { FCol = name(fract(UV)); } vec4 name(vec2 uv)\n\n#define NO_COPY_PASTE\t// use as a reminder\n\n////////////////////////////////////////////////////////////////\n\n// base_wall/c_met5_2\nTEX(cmet52) {\n    float\n        b = FBMT(uv, vec2(7), .9, 3., 4),\n        n = FBMT(uv, vec2(9), .9, 3., 4),\n        t = .7 + .6 * b\n    ;\n    return mix(RGB(77, 75, 73), RGB(77, 66, 55), ls(.4, .6, n)) * t;\n}\n\n// base_wall/c_met7_2\nTEX(cmet72) {\n    vec3 c = NO_COPY_PASTE cmet52(uv) NO_COPY_PASTE; // base texture\n\tuv.x = abs(uv.x - .515); // slightly off-center horizontal mirroring\n\tuv.y = abs(uv.y - .5); // vertical mirroring\n\tuv.y = abs(uv.y - .25); // vertical mirroring (again)\n\tfloat d = box(uv - vec2(0, .23), vec2(.5, .21)); // box SDF\n\tc *= 1.\n\t\t+ .3 * tri(.0, .01, -d) // edge highlight\n\t\t- .3 * ls(.0, .01, d) // darker part (grout?)\n\t;\n\treturn c;\n}\n\n// base_wall/steed1gf\nTEX(steed1gf) {\n    float\n        b = FBMT(uv -= .5, vec2(7, 3), .9, 3., 4),\n        n = FBMT(uv, vec2(5, 3), .7, 2., 4),\n        t = .85 + .3 * b,\n        d, m\n    ;\n\n    vec3 c = mix(RGB(88, 90, 72), RGB(60, 64, 50), length(uv) * 2.5 - .5) * t; // base color\n    uv.y *= .5; // correct aspect ratio\n    \n    d = box(uv, vec2(.5, .25)) + .01; // box SDF\n    c = mix(c, RGB(133, 144, 144) * t, tri(.0, .01, d) * n); // edge highlight\n    c *= 1.\n        - .5 * ls(.0, .01, d) // edge shadow\n    ;\n\n\tvec2 p = abs(uv) - vec2(.41, .16); // bolt position (mirrored x & y)\n\tm = ls(.035, .02, d = length(p *= sign(uv - .1))) * (.8 + .8 * b * b); // change p sign based on quadrant and generate bolt mask\n\tc *= 1.\n\t\t- .2 * sqr(tri(.04, .02, d)) // bolt shadow\n\t\t+ 3. * m * ls(-.01, .01, p.y) * ls(.02, -.01, p.x) // very bright top-left reflection\n\t\t+ .3 * m * ls(-.01, .01, -p.y) * ls(-.01, .02, p.x) // bright bottom-right reflection\n\t\t- .9 * m * ls(-.01, .01, p.y) * ls(-.01, .02, p.x) // dark top-right reflection\n\t\t- .3 * m * ls(-.01, .01, -p.y) * ls(.02, -.01, p.x) // dark bottom-left reflection\n\t;\n\n    return c;\n}\n\n// base_floor/diamond2c\nTEX(dmnd2c) {\n    float b = FBMT(uv, vec2(7), .9, 3., 4);\n    uv.x *= -1.5;\n    uv.y += uv.x * .5;\n    uv.x = 1. - uv.x + uv.y;\n    uv = fract(uv * 28.);\n    float f = sat(1. - length(.1 - uv));\n    f *= ls(.6, .2, length(.6 - uv));\n    f *= ls(.6, .8, length(.1 - uv));\n    f *= ls(.2, .6, b) * 2. + 1.;\n    float l = 1. - ls(.2, b + 2., mx(abs(uv - .5)));\n    return vec3((f + 1.) * mix(.21, .29, b * b) * l);\n}\n\n// p = offset from center\n// s = scale\n// k = number of spokes\n// n = noise\nfloat dmnd2cow_spokes(vec2 p, float s, float k, float n) {\n    return\n        ridged(fract(nang(p) * k + n))\n        * ls(.5, .3, length(p) / s + n - .5)\n    ;\n}\n\n// base_floor/diamond2c_ow (texture)\nTEXA(dmnd2cow) {\n\tvec3 c = NO_COPY_PASTE dmnd2c(uv) NO_COPY_PASTE; // base texture\n    float\n        b = FBMT(uv = wavy(uv, 7., .01), vec2(5), .7, 3., 4), // base FBM + slight UV distortion\n        n = FBMT(uv, vec2(7), .5, 2., 4), // smoother FBM\n        r = length(uv -= .5), // distance to center\n        a = nang(uv), // normalized angle\n        d = r + n * .8 - .33, // distorted distance\n        m = ls(.1, .15, d) // floor mask\n\t;\n    c = mix(c, mix(RGB(21, 17, 14), RGB(70, 59, 51), b), ls(.5, .3, r + b*b*b)); // base impact color\n    c *= 1.\n        - .7 * ls(.13, .1, d) // inner shadow\n        + 1.5 * pow(tri(.3, .15, .05, d), 4.) // edge highlight\n        + m * dmnd2cow_spokes(uv - vec2(-.05, .05), .44, 22., n) // top radial marks\n        + m * dmnd2cow_spokes(uv - vec2(.07, -.18), .3, 15., n) // bottom radial marks\n        ;\n\treturn vec4(c, 1. - sqrt(ls(.11, .05, d))); // color + alpha (including shadow)\n}\n\n// base_floor/diamond2c_ow (map shader)\nvoid dmnd2cow_m() {\n    vec4 c = NO_COPY_PASTE dmnd2cow(fract(UV)) NO_COPY_PASTE;\n    float b = FBMT(UV * .5 + Time.x * vec2(9, 5), vec2(7), .6, 2., 4);\n    b *= 1. + .5 * tri(.5, .05, b);\n    FCol = vec4(mix(RGB(66, 111, 155) * (.8 + 2. * b * b), c.xyz * Light(), c.w), 1);\n}\n\nvec2 knob(vec2 uv, float s) {\n    return vec2(1. - length(uv) / s, msk(length(uv) - s));\n}\n\nvec3 add_knob_gizmo(vec3 c, vec2 uv, float b) {\n    vec2 v = knob(uv, .02);\n    float d = length(uv);\n    c = mix(c, RGB(222, 155, 144) * (b * .4 + .3), tri(.03, .01, d)); // knob exterior bevel highlight\n    //c *= 1. - .5 * tri(.04, .03, .0, d) * clamp(u.y / .02, -1., 1.);\n    c *= 1. - .5 * tri(.02, .01, d); // sunken knob exterior\n    c = mix(c, RGB(111, 66, 44) * (v.x * 1.5 + .2), v.y); // knob interior\n    return c;\n}\n\n// infinite pie slice\n// a = normalized angle\n// s = angular extent\nfloat slice(float a, float s) {\n    return abs(fract(a - .5) - .5) - s;\n}\n\n// Basic clamp piece\n// c = background color\n// p = polar coordinates\n// u.x = angular position\n// u.y = angular extent\n// v.x = radial position\n// v.y = radial extent\n// k = clamp color\nvec3 dmnd2cjp_clamp(vec3 c, vec2 p, vec2 u, vec2 v, vec3 k) {\n    p.x = slice(p.x - u.x, u.y);\n    p.y = abs(p.y - v.x) - v.y;\n    c *= 1. - .4 * tri(.0, .004, p.x) * ls(.01, .0, p.y); // side shadow\n    c = mix(c, k, ls(.0, -.002, p.x) * ls(.01, .0, p.y)); // mix clamp color\n    c *= 1. + .3 * tri(-.003, .002, p.x) * ls(.0, -.01, p.y); // side highlights\n    return c;\n}\n\n// Two-piece metallic clamp\nvec3 dmnd2cjp_clamp(vec3 c, vec2 p, float v, vec3 k) {\n    c = dmnd2cjp_clamp(c, p, vec2(v, .015), vec2(.36, .04), k * (.3 + .5 * sqr(ls(.38, .33, p.y)) - .7 * ls(.33, .3, p.y)));\n    c = dmnd2cjp_clamp(c, p, vec2(v, .025), vec2(.43, .02), k * (.3 + .5 * sqr(tri(.43, .025, p.y))));\n    return c;\n}\n\n// c = background color\n// k = light color\n// l = light mask accum\n// p.x = normalized angle\n// p.y = radius\n// u.x = angular position\n// u.y = angular extent\nvec3 dmnd2cjp_led(vec3 c, vec3 k, inout float l, vec2 p, vec2 u, vec2 v) {\n\tp.x = 4. * max(0., slice(p.x - u.x, u.y)); // clamp & scale angle\n\tp.y -= v.x; // shift radius\n\tfloat d = circ(p, v.y); // SDF\n\tl += pow(ls(.1, -.01, d), 4.); // add glow\n\tc = mix(c, c * k, msk(d, .01)); // interior color\n\tc *= 1.\n\t\t- .3 * tri(.0, .01, d) // edge shadow\n\t\t+ .3 * tri(.01, .01, d) // edge highlight\n\t;\n\treturn c;\n}\n\n// sfx/diamond2cjumppad (texture)\nTEXA(dmnd2cjp) {\n\tvec3 c = NO_COPY_PASTE dmnd2c(uv) NO_COPY_PASTE;\n\n\tfloat\n\t\tb = FBMT(uv, vec2(7), .9, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n\t\ta = nang(uv - .5), // normalized angle\n\t\tr = length(uv - .5), // distance from center\n\t\tm = ls(.46, .45, r), // initial mask\n\t\tl = tri(.43, .01, r) * ls(.07, .0, abs(a - .11) - .03), // initial light mask\n\t\tg = greebles(uv * 3., b, .3).x,\n\t\td;\n\tvec2 p = vec2(a, r);\n\n\t// interior surface\n\tc = mix(c, RGB(199, 199, 166. + 33. * b) * (.1 + .1 * b + g), m); // base color\n\n\t// central knob\n\tc = add_knob_gizmo(c, uv - .5, b);\n\n\t// outer metal ring\n\tm *= ls(.31, .33, r);\n\tc = mix(c, RGB(144, 122, 99) * t, m) // base color\n\t\t+ .44 * tri(.335, .01, r) // small bevel highlight\n\t;\n\tc *= 1.\n\t\t+ .5 * tri(.43, .013, r) // large bevel highlight\n\t\t- .6 * tri(.41, .03, r) // large bevel shadow\n\t\t- .4 * tri(.35, .015, r) // small bevel shadow\n\t\t- sqr(tri(.315, .03, r)) // inner shadow\n\t\t- sqr(tri(.46, .03, r)) // outer shadow\n\t;\n\n\t// ring wires\n\tc = wire_ring(c, uv, .38, .02);\n\n\t// metal clamps\n\tvec3 k = vec3(.9, .9, .8) * t; // base color\n\tc = dmnd2cjp_clamp(c, p, .63, k); // bottom-left\n\tc = dmnd2cjp_clamp(c, p, .37, k); // top-left\n\tc = dmnd2cjp_clamp(c, p, vec2(.0, .1), vec2(.38, .03), k * (.25 + .6 * ls(.4, .33, p.y))); // right\n\tc = dmnd2cjp_clamp(c, p, vec2(.11, .06), vec2(.38, .03), k * (.3 + .5 * ls(.4, .33, p.y))); // top-right\n\tc = dmnd2cjp_clamp(c, p, vec2(.91, .05), vec2(.373, .035), k * (.5 + .4 * ls(.37, .36, p.y) - .7 * ls(.33, .3, p.y))); // bottom-right\n\tc = dmnd2cjp_clamp(c, p, vec2(.948, .003), vec2(.37, .04), k * (.5 + .4 * ls(.36, .35, p.y) - .7 * ls(.33, .3, p.y))); // above b-r\n\tc = dmnd2cjp_clamp(c, p, vec2(.965, .007), vec2(.37, .04), k * (.5 + .4 * ls(.36, .35, p.y) - .7 * ls(.33, .3, p.y))); // above \n\tc = dmnd2cjp_clamp(c, p, vec2(.02, .005), vec2(.36, .015), k * (.5 + .4 * ls(.36, .35, p.y) - .7 * ls(.33, .3, p.y))); // tiny right\n\n\t// lights\n\tk = vec3(1.5, .5, .5) * (g * 4. + .2);\n\tc = dmnd2cjp_led(c, k, l, p, vec2(.125, .02), vec2(.383, .017)); // large top-right\n\tc = dmnd2cjp_led(c, k, l, p, vec2(.075, .001), vec2(.383, .017)); // small top-right\n\tc = dmnd2cjp_led(c, k, l, p, vec2(.02, .001), vec2(.37, .0)); // tiny right\n\tc = dmnd2cjp_led(c, k, l, p, vec2(.63, .007), vec2(.44, .007)); // small bottom-left\n\n\t// inner ring glow (with offsets for the left clamps)\n\tl += tri(.32, .01, r + msk(min(slice(a - .63, .011), slice(a - .37, .011)), .005) * .005);\n\n\t// subtle floor reflection (lower-left)\n\tl += ls(.2, .8, c.x) * tri(.5, .6, .8, r) * sqr(tri(.63, .06, a));\n\n\treturn vec4(c, l);\n}\n\n// sfx/diamond2cjumppad (map shader)\nvoid dmnd2cjp_m() {\n\tvec4 c = NO_COPY_PASTE dmnd2cjp(fract(UV)) NO_COPY_PASTE;\n    vec2 uv = fract(UV) - .5;\n    float\n        r = length(uv),\n        v = fract(Time.x * 1.5),\n        s = mix(.4, 8., v),\n        b = NT(uv/s, vec2(255)),\n        t = .8 + .2 * b\n    ;\n\tFCol = vec4(\n        c.xyz * Light()\n        + RGB(240, 130, 5) * (tri(.1, .05, r / s) * ls(.34, .3, r) * t + .5 * c.w * ridged(v))\n    , 1);\n}\n\n// sfx/pentfloor_diamond2c (texture)\nTEXA(dmnd2pnt) {\n\tvec3 c = dmnd2cjp(uv).xyz;\n\tuv = fract(uv) - .5;\n\tfloat b = FBMT(uv, vec2(3), .9, 3., 4), d = min(abs(length(uv) - .4), pentagram(uv, .35));\n\treturn vec4(c, msk(d - .02 + b * .02, .01));\n}\n\n// sfx/pentfloor_diamond2c (map shader)\nTEXA(dmnd2pnt_m) {\n\tvec4 c = dmnd2pnt(uv);\n    c.xyz += RGB(111, 55, 0) * c.w * (sin(Time.x * PI) * .5 + .5);\n    return c;\n}\n\n// sfx/launchpad_diamond (texture)\nTEXA(lpdmnd) {\n    vec3 c = NO_COPY_PASTE dmnd2c(uv) NO_COPY_PASTE; // base texture\n    float\n        b = FBMT(uv, vec2(5), .9, 3., 4), // base FBM\n        t, o, k, r, h, d;\n    vec2 u;\n    u.x = abs(uv.x - .5);\n    u.y = uv.y;\n\n    // large middle panel underneath\n    c = mix(c, vec3(.2 + .3 * b * b), r = msk(k = box(u - vec2(0, .5), vec2(.33 - uv.y * .1, .15)) - .05, .004)); // base color\n    c *= 1.\n        - .5 * tri(.0, .01, k) // outer edge shadow\n        + .2 * tri(-.01, .01, k) // outer edge highlight\n\t;\n\n    // bottom attachment\n    c = mix(c, vec3(.22 + .22 * b * b), r = msk(k = box(u, vec2(.2)), .004)); // base color\n    c *= 1.\n        + .3 * tri(.0, .01, k) // outer edge highlight\n        + .5 * sqr(tri(.05, .03, uv.y)) * r // crease highlight\n\t;\n\n    // bottom slots\n    u = mirr(u, .11);\n    c *= 1.\n        - .3 * msk(k = box(u - vec2(.07, -.03), vec2(0, .05)) - .015, .004) // darken interior\n        - .3 * tri(.0, .007, k) // darken edges\n\t;\n\n    u.x = abs(uv.x - .5);\n    u.y = min(uv.y, .4);\n    r = length(u - vec2(0, .4)) - (.18 - .06 * ls(.4, 1., uv.y));\n    k = .25\n        - .15 * ls(.9, .96, uv.y)\n        + .03 * sqr(ls(.82, .86, uv.y))\n        + .07 * ls(.8, .2, uv.y)\n        + .07 * sqr(ls(.35, .22, uv.y))\n        - .07 * ls(.22, .0, uv.y)\n\t;\n    o = box(uv - vec2(.5, .5), vec2(k, .46));\n    o = max(o, -box(u, vec2(.15, .03)) + .06);\n    c = mix(c, vec3(.6, .55, .55) - uv.y * .3 + b * .2, msk(o, .004)); // base metal color\n    c *= 1. - .7 * tri(.0, .013, o); // black outer edge\n    c *= 1. - (r / .5 - .1) * msk(o, .004); // darken metal away from center\n    t = max(r, uv.y - .96);\n    o = abs(t - .02) - .03;\n    o = max(o, uv.y - 1. + u.x * .5);\n    o = max(o, uv.y - .96);\n    c = mix(c, vec3(1, 1, .9) - uv.y * .55, tri(-.01, .01, o)); // lane edge highlight\n    c = mix(c, mix(vec3(.2 * b + .1), .07 + greebles(uv * 3., b, .2), .6), msk(t, .01)); // inner lane color\n\n    // lane traces\n    k = .2 - .05 * ls(.8, .5, uv.y) - .15 * ls(.5, .3, uv.y);\n    d = msk(t, .004);\n    r = box(vec2(u.x, uv.y) - vec2(.25, .6), vec2(k, .2));\n    r = min(r, box(uv - vec2(.5, .21), vec2(.02, .05)) - .09);\n    c *= 1.\n        + .3 * d * tri(.01, .01, r) // light interior line\n        - .3 * d * tri(.0, .01, r) // dark interior line\n\t;\n    c *= 1. - .2 * tri(.0, .05, t) * msk(o, .004); // inner lane shadow\n\n    // central knob\n    c = add_knob_gizmo(c, u = uv - vec2(.5, .37), b);\n    \n    // metal clamps\n    d = length(u);\n    u.x = abs(uv.x - .5);\n    u.y = uv.y - .3;\n    u = u.x > .06 ? u * rot(50.) - vec2(.08, -.11) : u + vec2(0, .07);\n    h = sat(u.y / .09 + .5); // vertical clamp coordinate, normalized [0..1]\n    r = box(u, vec2(.04 - .02 * h, .04)) - .01;\n    c = mix(c, vec3(.6, .55, .55) * (1. + .4 * b - .5 * h), msk(r, .007) * ls(.21, .18, d)); // base clamp color\n    c *= 1. - .5 * h * tri(.02, .008, .0, r); // clamp shadow\n\n/*\n    d = length(u = uv - vec2(.5, .4)) - .25;\n    k = box((uv - vec2(.5, -.0)) * rot(45.), vec2(.22));\n    k = smax(-d, k, .05);\n    c *= 1. - .5 * msk(k, .01);\n*/\n\n    return vec4(c, msk(t - .025, .03));\n}\n\n// sfx/launchpad_diamond (map shader)\nTEX(lpdmnd_m) {\n    float b = FBMT(uv, vec2(7), .9, 3., 4);\n\tvec4 c = lpdmnd(uv);\n    uv.x = abs(.5 - uv.x);\n    float\n        t = fract(-Time.x),\n        r = length(uv - vec2(0, .4)),\n    \tl = t * pow(max(0., 1. - r), 4.) * c.w;\n   \tif (t > .75)\n    \tl += ls(.03, .01, abs(fract(uv.y + uv.x * .5 + t * 2.) - .45)) * ls(.1, .08, uv.x);\n    c.xyz += RGB(180, 150, 5) * l;\n    return c.xyz;\n}\n\n// base_wall/metfloor_block_3\nTEX(mtlfb3) {\n    float b = FBMT(uv, vec2(5), .9, 3., 4);\n    vec3 pt = pattern(uv, 8., .31);\n    vec3 c = mix(RGB(66, 58, 55), RGB(118, 107, 105), b);\n    float l = 1. - .5 * ls(.034, .036, pt.x);\n    l = mix(l, 1.4, tri(.033, .004, pt.x));\n\treturn c * l;\n}\n\n// base_support/cable\nTEX(cable) {\n    float\n        b = FBMT(uv, vec2(5), .9, 3., 4),\n        h = fract(uv.y * 10.);\n    vec3 c = mix(RGB(53, 48, 42), RGB(38, 38, 36), b) * (.6 + b * .8);\n    c *= 1.\n        + .5 * sqr(tri(.25, .25, h))\n        + .5 * sqr(tri(.65, .35, h))\n        - .6 * sqr(tri(.5, .5, h))\n\t;\n\treturn c;\n}\n\n// base_trim/border11b\nTEX(brdr11b) {\n\tfloat b = FBMT(uv, vec2(5, 3), .9, 3., 4);\n\tvec3 c = mix(RGB(74, 66, 55), RGB(99, 90, 78), b*b);\n\tuv.x *= 2.;\n\tvec2 p = seg(uv, vec2(.5, .625), vec2(1.5, .625));\n\tfloat\n\t\td = length(p - uv),\n\t\tm = ls(.22, .20, d),\n\t\tl = 1.\n\t\t- .15 * m\n\t\t- .5 * ls(.7, .9, uv.y) * m\n\t\t- .3 * (grad(d).y - .5) * tri(.2, .03, d)\n\t\t- .3 * sqr(tri(.17, .03, d))\n\t\t- .5 * ls(.05, 0., uv.y)\n\t\t- .3 * tri(.33, .05, uv.y)\n\t\t+ .7 * ls(.93, 1., uv.y)\n\t\t+ .7 * tri(.31, .04, uv.y)\n\t\t;\n\treturn c * l;\n}\n\n// base_wall/metalblack03\nTEX(mtlbk03) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 3., 4),\n\t\td, l;\n\tuv = wavy(uv, 13., .007);\n\tEVAL_TOP_LIGHT(\n\t\tuv, .004, d, l,\n\t\tsqr(ls(.3 + b * .2, .9, FBMT(p, vec2(23), .5, 2., 4)))\n\t);\n\treturn vec3(.18 * (.7 + b * b) * (1. - .05 * l * d));\n}\n\n// gothic_wall/iron01_e\nTEX(giron01e) {\n\tfloat b = FBMT(uv, vec2(5), .9, 3., 4);\n\tvec3\n        c = mix(RGB(77, 55, 53), RGB(62, 48, 48), NT(uv, vec2(128, 13))) * (.7 + b * b),\n        g;\n\tuv = wavy(uv, 13., .007);\n\tEVAL_GRAD(\n\t\tg, uv,\n\t\tsqr(ls(.4 + b * .4, .95, NT(p[i], vec2(63, 43))))\n\t);\n    c *= ls(1.3, .9, g.z);\n\treturn vec3(c * (1. + g.y * g.z));\n}\n\nfloat fender(vec2 uv, vec2 s) {\n    uv.y = max(uv.y, 0.);\n    return elips(uv, s);\n}\n\nvec3 add_techpipe(vec3 c, vec3 b, vec2 uv, float h, float s) {\n    float\n        y = (uv.y - h) / s,\n        p = 1. - y * y;\n    c *= 1. - tri(-1., 1., y);\n    if (p > 0.)\n        c = b * (p * (.8 + .2 * tri(.5, .25, fract(uv.x / s)))) *\n        \t(.7 + sqr(tri(.2, .7, y)));\n    return c;\n}\n\nvec3 add_all_techpipes(vec3 c, vec2 uv, float b) {\n    vec2 p = uv, q = p;\n    \n    c *= 1.\n        - .5 * tri(.2, .01, uv.y) // shadow above top silver pipe\n        - .9 * tri(.155, .007, uv.y) // shadow above top copper pipe\n    ;\n\n    q.y += tri(.1, .01, mod(q.x, .33)) / 2e2;\n    c = add_techpipe(c, 2. * b * RGB(93, 84, 79), uv, .185, .015); // silver\n    c = add_techpipe(c, 2. * b * RGB(138, 77, 48), uv, .13, .025); // copper (top)\n    c = add_techpipe(c, 2. * b * RGB(112, 71, 51), uv, .09, .015); // copper (mid)\n    c = add_techpipe(c, 2. * b * RGB(138, 77, 48), q, .05, .015); // copper (bottom)\n\n    // rectangular gizmos on top of cables\n    p.x = abs(fract(uv.x * 6. - .5) - .5) / 6.;\n    c *= 1.+ .5 * ls(.04, .03, p.x) * tri(.18, .03, p.y);\n    float r = box1(p - vec2(0, .12), vec2(.03, .01));\n    r = exclude(r, box1(p - vec2(0, .11), vec2(.01)));\n    c *= 1. - sqr(tri(.0, .04, r));\n    c = mix(c, RGB(166, 99, 77) * 2. * b * (.75 + .5 * sqr(tri(.125, .01, uv.y))), msk(r, .004));\n\n    // transformer coils?\n    q = p;\n    q.y -= .07;\n    r = circ(q, .03);\n    c *= 1. - sqr(tri(.0, .07, r)); // outer shadow\n    c = mix(c, RGB(127, 83, 72) * b * 2. * ls(.01, -.005, r), ls(.005, .0, r));\n    q.y -= .004;\n    r = circ(q, .015);\n    c *= sqr(ls(-.01, .01, r)); // inner shadow\n    q.y += .013;\n    r = circ(q, .05);\n\tc += RGB(67, 38, 30) * 4. * sqrt(b) * sqr(tri(-.02, .015, r) * tri(.023, .02, uv.y)); // specular?\n\n    return c;\n}\n\n// gothic_wall/iron01_ntech3\nTEX(giron01nt3) {\n\tuv.x *= .5; // fix aspect ratio (texture is 128 x 256)\n\n\tfloat\n\t\tb = FBMT(uv * vec2(2, 1), vec2(3, 5), .9, 3., 4), // base FBM, tileable\n\t\tn = .75 + b * b, // texture intensity\n\t\tt = uv.y + .2 * min(.4, tri(.5, .33, fract(uv.x * 4.))), // top alternating pattern\n\t\tf1 = fender(uv - vec2(.25, .62), vec2(3, 2) / 32.),\n\t\tf2 = fender(uv - vec2(.25, .55), vec2(3, 2) / 48.),\n\t\tr;\n        \n\tvec3\n\t\tc = mix(RGB(66, 50, 51), RGB(111, 66, 44), sqrt(tri(.31, .01, uv.y))),\n\t\tc2;\n\n\tvec2 p = uv, q;\n\tp.x = fract(p.x * 4.);\n\tif (uv.y > .3)\n\t\tc = add_rivet(c, vec2(4. * abs(p.x - .5) - 1.6, fract(uv.y * 16.) - .5), .07);\n\tr = abs(p.x - .5);\n\t// panel shadow/highlight\n\tc *= 1. - .3 * ls(.31, .32, uv.y) * ls(.87, .86, uv.y) *\n\t\t(ls(.035, .03, .5 - r) + tri(.48, .01, r) - tri(.46, .02, r));\n\n\t// greebles\n\tc = mix(c * n, greebles(uv * 2., b, .1), max(ls(.31, .3, uv.y), msk(f2)));\n\tc *= ls(1.5, .7, uv.y);\n\tif (uv.y < .306)\n\t\tc *= 1. - tri(.3, .05, uv.y) * msk(-f2 + 10., 20.); // panel shadow\n\tc *= 1. - tri(.316, .004, uv.y) * msk(-f2);\n\n    // bottom part - cables?\n    if (uv.y < .1)\n        c *= .0;\n    c = add_all_techpipes(c, uv, b);\n\n\t// fender?\n\tr = exclude(f1, f2);\n\tr = exclude(r, (uv.y - .3) * 3e2);\n\tc *= 1. - .5 * tri(-2., 17., f2) * ls(.26, .3, uv.y); // inner fender shadow\n\n\tc2 = RGB(67, 39, 17) * n;\n\tc2 = mix(c2, vec3(n * .2), tri(0., 4., r) * b); // desaturate edges\n\tc2 *= 1. - .4 * pow(tri(.0, 3., r), 4.); // darken outer edge\n\tc2 += (c2 + .6) * sqrt(b) * sqr(tri(-6., 8., r) * tri(.66, .04, uv.y)) * msk(r); // specular\n\tif (uv.y < .56)\n\t\tc2 = add_rivet(c2, vec2(24. * abs(uv.x - .25) - 1.85, fract(uv.y * 24. + .5) - .5), .15);\n\n    // top part - we also fill in the bottom row to avoid bilinear artifacts\n    // (even if the original texture doesn't)\n    c = mix(c, NO_COPY_PASTE giron01e(uv) NO_COPY_PASTE, ls(.85, .9, t) + step(uv.y, 1./256.));\n\tc *= 1. + tri(.88, .015, t) - sqr(tri(.87, .03, t));\n\n    return mix(c, c2, ls(1., .1, r));\n}\n\nvec3 gmtlbg6_layer(vec3 c, vec3 k, vec2 uv, int w, int h) {\n    float b = FBMT(uv, vec2(w, h), .5, 2., 2);\n    c *= .9 - .3 * ls(.15, .1, abs(b - .5));\n    return mix(c, k, tri(.5, .1, b));\n}\n\n// gothic_floor/metalbridge06\nTEX(gmtlbg6) {\n    uv = wavy(uv, 9., .005);\n    int i = 0, l[] = int[](13, 43, 17, 47, 23, 59, 27, 63);\n\tfloat b = FBMT(uv, vec2(19), .7, 2., 4);\n    vec3 c = mix(RGB(40, 50, 60), RGB(46, 33, 27), b) * (.5 + b);\n    for (/**/; i < 8; i += 2)\n        c = gmtlbg6_layer(c, mix(RGB(145, 140, 137), RGB(132, 123, 116), b), uv, l[i], l[i+1]);\n    return c;\n}\n\n// gothic_floor/metalbridge06broke\nTEX(gmtlbg6brk) {\n    vec3 c = gmtlbg6(uv); // base texture; differs in the actual shader - don't copy/paste!\n    float\n        b = FBMT(uv, vec2(7), .7, 2., 4), // base FBM\n        n = NT(uv, vec2(33)) - .5, // distortion noise\n        d = circ(uv - vec2(.7, .5), .13); // big right disk\n    d = min(d, circ(uv - vec2(.44, .66), .08)); // add smaller center disk\n    d = min(d, circ(uv - vec2(.33, .4), .06)); // add smaller left disk\n\td += .04 * n; // SDF distortion\n    c += b * b * tri(.0, .03, d); // bright edges\n    c *= 1.\n        - b * tri(.03, .02, d) // outer edge shadow\n        - b * tri(-.04, .05, d) * .5 // inner edge shadow\n        - b * ls(.0, .02, -d) // interior shadow\n\t;\n    return c;\n}\n\nvec3 gblks17f2_layer(vec3 c, vec3 k, vec2 uv, int w, int h) {\n    float b = FBMT(uv, vec2(w, h), .5, 2., 2);\n    c *= 1. - .15 * sqr(ls(.15, .1, abs(b - .5)));\n    return mix(c, k, tri(.5, .1, b));\n}\n\n// gothic_floor/blocks17floor2\nTEX(gblks17f2) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4),\n        n = FBMT(uv, vec2(7), .9, 3., 4);\n    vec3\n        c = mix(RGB(111, 66, 55), RGB(80, 55, 52), sqr(ls(.8, .2, n))) * (.8 + .8 * b * b),\n        k = c; // layer color\n    uv = wavy(uv, 13., .01);\n    int i = 0, l[] = int[](13, 43, 17, 47, 23, 59, 27, 63);\n\tb = FBMT(uv, vec2(19), .7, 2., 4);\n    for (/**/; i < 8; i += 2)\n        c = gblks17f2_layer(c, k, uv, l[i], l[i+1]);\n    return c;\n}\n\n\nvec3 gkarnclma2r_layer(vec3 c, vec3 k, vec2 uv, int w, int h) {\n    float b = FBMT(uv, vec2(w, h), .5, 2., 1);\n    c *= .9 - .3 * sqr(ls(.15, .1, abs(b - .5)));\n    return mix(c, k, tri(.5, .1, b));\n}\n\n// gothic_door/km_arena1columna2R\nTEX(gkarnclma2r) {\n\tfloat\n        b = FBMT(uv, vec2(3,29), .9, 2., 4), // base FBM\n        t = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        d = abs(uv.y - .61), // distance from vertical center of helixy part\n        o = ls(.25, .24, d), // mask for flat part\n        m; // mask for threads\n    vec3\n        c = RGB(140, 127, 127), // base color\n        k = c; // branchy layer color\n    vec2\n        p = uv;\n\n    c *= 1. - .1 * ls(.85, .86, uv.y); // darken top part\n    c = t * mix(c, RGB(110, 55, 50), ls(.33, .32, uv.y)); // vary intensity, colorize bottom\n\n    p.y += p.x * .11 + b * .007; // skew\n    p.y = fract(p.y * 9.) - .5; // repeat vertically\n    m = ls(.0, .1, abs(p.y) - .2); // mask\n\n    // branchy part between the threads\n    int i = 0, l[] = int[](3, 29, 5, 37, 9, 63, 27, 63);\n    for (/**/; i < 6; i += 2)\n        c = mix(c, gkarnclma2r_layer(c, k, uv, l[i], l[i+1]), m * o); // branchy layer\n\n    c *= 1. + t * o * (\n        + .6 * tri(.1, .1, p.y) // helix highlight\n        - .7 * tri(-.25, .3, p.y) // shadow underneath helix\n        - .5 * tri(.2, .1, p.y) // shadow above helix\n\t);\n    c = mix(c, RGB(99, 66, 51) * t, tri(-.15, .1, p.y) * o); // colored reflection\n\n    // bevels at both ends of the helixy part\n    c *= 1.\n        + tri(.36, .005, uv.y) // highlight\n        + tri(.34, .005, uv.y) // highlight\n        + tri(.865, .005, uv.y) // highlight\n        + tri(.89, .01, uv.y) // highlight\n        - .5 * sqr(tri(.245, .01, d)) // shadow\n        - .7 * sqr(tri(.35, .01, uv.y)) // shadow\n        - .5 * sqr(tri(.325, .02, uv.y)) // shadow\n        - .8 * sqr(tri(.875, .02, uv.y)) // shadow\n        - .3 * sqr(tri(.9, .02, uv.y)) // shadow\n        ;\n\n    c *= .3 + sqrt(ridged(uv.x)); // darken left/right sides\n\n    return c;\n}\n\n/*\nHelpers\nvvvvvvv\n*/\n// distance, angle\nvec2 circ2(vec2 p, float r, float t) {\n    return vec2((length(p) - r) / t * .5 + .5, fract(atan(p.y, p.x) / TAU));\n}\n\nvoid xxsnake_seg(inout vec2 old, vec2 uv, inout vec2 c, float r, float t, float angle) {\n    c += sc(angle * TAU).yx * r * 2.;\n    if ((fract(angle) - old.y) * sign(angle) < 0.)\n    \told = circ2(uv - c, r, t);\n    //old = circ2(uv - c, r, t);\n}\n\nfloat cross2d(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nvoid snake_seg(inout vec3 s, inout float r, vec2 p, vec2 a, vec2 b, vec2 c) {\n    r = length(b - a) - r;\n    a = normalize(a - b);\n    c = normalize(c - b);\n    p = safe_normalize(p - b);\n    if (cross2d(a, c) > cross2d(p, a)) {\n        s.xy = p;\n        s.z = length(p) - r;\n    }\n}\n\n/*\n^^^^^^^^\n*/\n\nvec3 gkarnarcfnl_layer(vec3 c, vec2 p, float s, float m) {\n    s = voro1(p, vec2(s)).z / s * 1e2;\n    c *= 1.\n        + .5 * m * ls(.9, .2, s)\n        - .5 * m * tri(2.5, .5, .3, s)\n        ;\n    return c;\n}\n\nvec3 gothic_metal(float b) {\n    return RGB(133, 100, 100. - 12. * b) * (.8 + .8 * b * b);\n}\n\n// Used by\n// - gothic_door/km_arena1archfinald_mid\n// - gothic_block/killblockgeomtrn\n// - gothic_block/demon_block15fx\nvec3 gkarnarcfnl_inner_gear(vec3 c, vec2 uv, float shadow_bias) {\n\tfloat\n\t\tb = FBMT(uv, vec2(4, 9), .9, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        a, // angle\n\t\td, // distance\n        m, // mask\n        s, // segment\n        k, i, v, r, z; // ugh...\n\tvec3\n        mt = gothic_metal(b); // metal color\n\tvec2\n\t\tp, q;\n\n    p = q = uv;\n    q.x = abs(q.x); // symmetry\n    d = circ(p, .31);\n    v = nang(q); // relative angle; note: uses symmetric coords!\n    m = ls(.01, .0, d);\n    c = mix(c * ls(.0, .05, d + shadow_bias), vec3(.13 * t), m); // background color + outer shadow\n    c = gkarnarcfnl_layer(c, p, 37., ls(.04, .02, abs(d + .07))); // random lines\n    a = v * 22.;\n    i = floor(a); // segment id\n    s = a - i; // segment fraction\n    k = ls(.23, .22, abs(v - .25)) + R1(i) * ls(.0, .1, q.y);\n    d -= r = (d * .3 + .005) * k; // extra thickness for top part\n    m = ls(.0, .1, q.y) * msk(abs(d + .015) - .015);\n    c = mix(c, mt, sat(1.5 * tri(-.015, .0, .01 - .003 * k, d))); // highlight\n    c = mix(c, RGB(130, 75, 44) * t, tri(-.02, .005, d) * ls(.0, .1, q.y)); // colored reflection\n    c *= 1.\n        - .3 * ls(.025, .03, -d) // darken interior\n        - .5 * ls(.4, .5, abs(s - .5)) * m // dark edge between top segments\n        + .2 * tri(.5, .3, abs(s - .5)) * m // top segment edge highlight\n        - .5 * tri(-.015, .007, d) // dark edge\n        - .5 * tri(-.03, .007, d) // dark edge\n        - .5 * tri(-.1, .005, d + r) // dark edge\n        - .5 * tri(-.115, .005, d + r) // dark edge\n        - .5 * tri(-.125, .015, d + r) // dark edge\n        - .5 * tri(-.145, .005, d + r) // dark edge\n        + .9 * tri(-.11, .007, d + r) // highlight\n        + .5 * tri(-.14, .005, d + r) // highlight\n        - b * tri(.225, .005, abs(v - .25)) * msk(abs(d + .015) - .015) // dark edge\n        ;\n    a = v * 72.;\n    i = floor(a); // segment id\n    s = a - i; // segment fraction\n    k = step(.7, H(i)) // 30% of segments\n        * step(q.y, .0) // below horizon\n        * ls(.02, .0, abs(d + .02)) // distance from circle between [-0.4 and 0]\n        ;\n    c = mix(c, vec3(mt * .6), k * ls(.4, .3, abs(s - .5))); // background color\n    c *= 1.\n        - .7 * k * tri(.4, .1, abs(s - .5)) // dark segment edge\n        ;\n\n    return c;\n}\n\n// (256 x 576) Combination of:\n// - gothic_door/km_arena1archfinalc_top (256 x 64)\n// - gothic_door/km_arena1archfinald_mid (256 x 256)\n// - gothic_door/km_arena1archfinald_bot (256 x 256)\nTEX(gkarnarcfnl) {\n\tfloat\n\t\tb = FBMT(uv, vec2(4, 9), .9, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        a, // angle\n\t\td, // distance\n        m, // mask\n        s, // segment\n        k, i, v, r, z; // ugh...\n\tvec3\n        mt = gothic_metal(b), // metal color\n\t\tc = vec3(.3 * b); // base color\n\tvec2\n\t\tp, q;\n\n    /* bottom arch */\n    p.x = uv.x - .5;\n\tp.y = max(uv.y - .2, 0.) * 1.89;\n    v = atan(p.y, abs(p.x)) / PI; // relative angle [-1..1]\n\td = circ(p, .48); // arch distance\n    k = ls(.3, .31, v); // mid mask\n    d *= 1. - .2 * ls(.3, .31, v) - .1 * ls(.43, .44, v); // thicken middle parts\n\ta = v * (v > .44 ? 2. : v > .3 ? 63. : 31.); // number of segments\n    c = mix(c, mt, ls(.03, .01, abs(d))); // arch background color\n    m = msk(abs(d - .01) - .02);\n    i = floor(a);\n    s = a - i;\n    if (v > .33 && v < .44)\n        s = fract(s + H(i) * .6 - .3); // non-uniform segments\n    c *= 1.\n        //- .5 * m * tri(.435, .005, v) // dark edge\n        - .5 * m * tri(.307, .01, v) // dark edge\n        - t * m * tri(.5, .1 + k * .2, s) // dark edge between segments\n        + b * m * tri(.52, .2 + k * .2, s) // segment edge highlight\n        ;\n    c *= 1.\n        - .9 * tri(-.015, .015, d) // black inner edge\n        - .5 * tri(.0, .01, d) // dark inner edge\n        - .7 * tri(.03, .02, d) // black outer edge\n        + tri(.01, .015, d) // highlight\n        ;\n\n    /* top gothic arch */\n    q = p;\n    q.y -= .5;\n    q.x = abs(q.x) + .6;\n    d = circ(q, 1.13);\n    m = ls(.03, .02, abs(d)) * ls(.5, .6, q.y);\n    c = mix(c, mt * sat(1. - abs(d - .015) / .03), m); // background color\n    c *= 1.\n        - .5 * m * tri(.005, .01, d)\n        + .5 * m * tri(.017, .005, d)\n        ;\n\n    /* small top gears */\n    q.x = abs(uv.x - .5) - .35;\n    q.y = uv.y * 9./4. - 2.1;\n    d = circ(q, .13) * 10.;\n    a = nang(q) * 49.;\n    i = floor(a);\n    s = a - i;\n    v = ls(.85, .9, H(i));\n    for (int j = 0; j < 2; ++j, d += .3) {\n        c = mix(c, mt * (b * .5 + .2), ls(.09, .03, abs(d)));\n        c *= 1.\n\t\t\t+ .7 * sqr(tri(.01, .05, d))\n            ;\n    }\n\n    /* large outer gear above arch */\n    p.y = (uv.y - .7) * 9./4.;\n    d = circ(p, .43);\n    a = atan(p.y, abs(p.x)) / PI; // relative angle [-1..1]\n    a = max(a, -.48); // remove lower mid space spoke\n    r = a;\n    i = floor(a *= 23.); // segment id\n    s = a - i; // segment fraction\n    k = R1(i) * .2 - .1 * ls(.0, .1, -d);\n    v = ls(.1, .2, abs(s - .5) - k);\n    d += v * .007; // offset spokes\n    r = (1. - v) * sqr(tri(.5, .3, r)) * ls(.25, .05, abs(s - .5)); // top spikes\n    d -= .17 * r;\n    m = tri(.04, .0, -.4, d); // mask\n    c = mix(c, mt * (b * .4 + .4), m); // background color\n    c = gkarnarcfnl_layer(c, p, 31., ls(.1, .05, abs(d + .15)) * v); // random lines between spokes\n    c *= mix(1., 1. - tri(.1, .2, .4, abs(s - .5) - k), m * b); // spoke shadows\n    c *= 1.\n        - .7 * sqr(tri(.03, .03, d)) // black outer edge\n        - .7 * sqr(tri(.03, .03, d + .05)) * v // dark shadow between 1st and 2nd circles\n        - .7 * sqr(tri(.0, .02, d + .05)) * v // dark shadow under 2nd circle\n        - .3 * ls(.04, .06, -d) * v // darken space between spokes\n        + .5 * tri(.02, .0, -.1, d) // smooth highlight\n        + tri(.0, .01 + .07 * r, d) // sharp highlight\n        + tri(.0, .01, d + .03) * v // sharp highlight\n        ;\n\n    /* smaller inner gear above arch */\n    p.y -= .05;\n    c = gkarnarcfnl_inner_gear(c, p, 0.);\n\n    return c;\n}\n\n// gothic_door/km_arena1archfinalc_top\nTEX(gkarnarcfnltp) {\n\tuv.y = (uv.y + 8.) / 9.;\n\treturn gkarnarcfnl(uv);\n}\n\n// gothic_door/km_arena1archfinald_mid\nTEX(gkarnarcfnlmd) {\n\tuv.y = (uv.y * 4. + 4.) / 9.;\n\treturn gkarnarcfnl(uv);\n}\n\n// gothic_door/km_arena1archfinald_bot\nTEX(gkarnarcfnlbt) {\n    // Hack: reduce bilinear artifacts at the top by changing\n    // the bottom row of pixels to match the bottom row in _mid\n    if (uv.y < .01)\n        ++uv.y;\n\tuv.y = uv.y * 4. / 9.;\n\treturn gkarnarcfnl(uv);\n}\n\n// gothic_floor/largerblock3b\nTEX(glrgbk3b) {\n\tuv.y -= 1./32.; // hack to avoid storing UV offsets for this texture in the map...\n\tvec2\n\t\tp = brick(uv.yx, vec2(8)), // brick layout\n\t\tq = fract(p), // position inside brick [0..1]\n\t\tv = wavy(uv, 31., .002), // wavy uv, for bumps\n\t\tid = p - q; // brick id\n\tfloat\n\t\tb = FBMT(wavy(uv, 5., .02), vec2(7), 1., 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base intensity (remapped FBM)\n\t\tn = NT(uv + R2(H(id) * 64.), vec2(23)), // smooth noise, for brick edge size variation\n\t\tm = FBMT(uv, vec2(9), .7, 3., 4), // another FBM, for dark splotches\n\t\td = FBMT(v, vec2(63), .7, 3., 4), // bump FBM\n\t\tr = FBMT(v - vec2(0, .002), vec2(63), .7, 3., 4), // offset bump FBM, for lighting\n\t\tl = d - r, // lighting\n\t\te = brick_edge(q, .03 + .03 * ridged(n)).z, // edge intensity: 1 = on edge, 0 = inside brick\n        h = H(id); // hashed brick id\n\tvec3 c = mix(RGB(91, 61, 42), RGB(70, 30, 15), e * b); // base colors\n\tc = mix(c, RGB(70, 48, 35), ls(.5, .6, m)) // add dark splotches\n        * t // and vary intensity\n        ;\n\tc *= 1.\n\t\t+ l * (.1 + n + tri(.6, .1, m)) * (1. - e) // bump lighting\n\t\t- t * ls(.7, 1., e) * NT(uv, vec2(13)) // dark brick edges\n\t\t+ .5 * b * tri(.3, .3, e) // brick edge highlights\n\t\t;\n    d = FBMT(v, vec2(23), .5, 2., 4); // hole FBM\n    c *= 1.\n        - .2 * ls(.6, .7, d) * h // darken interior\n        + .3 * tri(.6, .05, d) * h * n // highlight edges\n        ;\n\tc *= .9 + .2 * h * (1. - e); // vary intensity per brick\n\tc *= .9 + .4 * pow(FBMT_ridged(uv - H(id / 8.), vec2(5), .6, 2., 4), 4.); // some ridge-like intensity variation\n\treturn c;\n}\n\n// gothic_floor/largerblock3b_ow (texture)\nTEXA(glrgbk3bow) {\n    vec3 c = glrgbk3b(uv * .5); // differs from the actual shader - don't copy!\n    float\n    \tn = NT(uv, vec2(19)),\n        m, r\n\t;\n    vec2\n        p = uv - .5,\n        q = vec2(3, 17) * vec2(nang(p), length(p) + (n - .5) * .03),\n        e\n\t;\n    q.x += floor(q.y) * PHI;\n    q.x *= floor(q.y);\n    r = length(e = fract(q) - .5);\n    m = tri(.5, 1., 4.5, q.y) * n;\n\tc *= 1.\n        - m * sqr(tri(.3, .2, r)) * 5. * e.y // cell bevel\n        - m * ls(.4, .5, r) // dark edge borders\n\t\t;\n    c *= ls(.9, 1.2, q.y);\n\treturn ls(.5, 1.1, q.y) * vec4(c, 1);\n}\n\n// gothic_floor/largerblock3b_ow (map shader)\nvoid glrgbk3bow_m() {\n    vec2 p = UV - H2(Time.x * vec2(3, 5));\n\tfloat b = FBMT(p, vec2(13), .6, 2., 4);\n\tvec4 c = glrgbk3bow(UV); // texture(Texture0, UV);\n\tFCol = vec4(mix(b * b * vec3(3, .4, 0), c.xyz, c.w) * Light(), 1);\n}\n\n// gothic_block/largerblock3blood (texture)\nTEXA(glrgbk3bbld) {\n    vec3 c = glrgbk3b(uv * .5); // differs from the actual shader - don't copy!\n    float\n        b = FBMT(uv, vec2(5), .6, 3., 4),\n        r = length(uv - .5) + b * b,\n        m = ls(.2, .6, r)\n\t;\n    return vec4(mix(b * vec3(.5, .2, .0), c, m), m);\n}\n\n// gothic_block/largerblock3blood (map shader)\nvoid glrgbk3bbld_m() {\n\tvec4 c = glrgbk3bbld(UV); // texture(Texture0, UV);\n    float b = FBMT(wavy(UV - Time.x * vec2(1, 3) / 2e2, Time.x * .4, 4., .03), vec2(7), .6, 3., 4);\n    c.xyz = mix(b * RGB(99, 9, 5) + ls(.78, 1.5, b), c.xyz, c.w);\n\tFCol = vec4((c.xyz/* + (1. - c.w) * env(Ref) * .2*/) * Light() , 1);\n}\n\n// gothic_block/blocks15\nTEX(gblks15) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 3., 4), // base FBM\n\t\tt = FBMT_ridged(wavy(uv, 4., .01), vec2(7), .5, 3., 5), // ridged FBM\n\t\tn = NT(wavy(uv, 4., .05), vec2(9)), // smooth noise\n\t\tid, e;\n\tvec3\n\t\tc = RGB(74, 65, 62) * (.8 + .8 * b * b), // base color\n\t\tpt = pattern(uv, 4., .07 + b * .04); // asymmetric block pattern\n\tvec2 d = grad(pt.x);\n\tid = H(fract(pt.yz)); // tile id\n\tc += tri(.6, .3, n) * ls(.3, .9, b * t) * .2; // bright splotches\n\tc *= 1. - tri(.5, .4, n) * ls(.5, .7, t) * .1; // some medium-frequency variation\n\tc = mix(c, RGB(86, 74, 78), tri(.5, .1, b) * tri(.7, .3, id) * .7); // subtle splash of color\n\tc = mix(c, RGB(105, 90, 70), tri(.3, .1, t) * tri(.3, .3, id) * .3); // another subtle splash of color\n\te = tri(.015, .015 * b, pt.x) + tri(.4, .1, n * t) * .4; // edge size\n\tc *= 1. - .2 * t * ls(.015, .017, pt.x); // mortar\n\tc *= 1. + e * b * (d.y - .3); // bevel\n\tc *= .9 + .2 * id; // per-tile brightness variation\n\tc *= .9 + .2 * ridged(NT(uv - pt.yx, vec2(5))); // some medium-frequency variation\n\n\tvec3 g;\n\tEVAL_GRAD(\n\t\tg, uv,\n\t\ttri(.7, .5, NT(p[i], vec2(23))) *\n\t\tsat(tri(.7, .4, NT(p[i], vec2(53))) * 4.);\n\t);\n\tc *= 1.\n\t\t+ g.y * g.z * b * b * (.8 - id) // scratches\n\t\t- pow(ls(.5, .0, b), 3.) // dirt/mold\n\t;\n\n\treturn c;\n}\n\n/*\nTEX(gblks15) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 3., 4),\n\t\tt = FBMT_ridged(wavy(uv, 4., .01), vec2(7), .5, 3., 5),\n\t\tn = NT(wavy(uv, 4., .05), vec2(9)),\n\t\tid, e;\n\tvec3\n\t\tpt = pattern(uv, 4., .1 + n * t * .05),\n\t\tc;\n\tvec2 d = grad(pt.x);\n\tid = H(fract(pt.yz));\n\tc = RGB(74, 65, 62) * (.8 + .8 * b * b);\n\tc += tri(.6, .3, n) * ls(.3, .9, b * t) * .2;\n\tc *= 1. - tri(.5, .4, n) * ls(.5, .7, t) * .1;\n\tc = mix(c, RGB(86, 74, 78), tri(.5, .1, b) * tri(.7, .3, id) * .7);\n\tc = mix(c, RGB(105, 90, 70), tri(.3, .1, t) * tri(.3, .3, id) * .3);\n\te = tri(.015, .005 + .015 * n, pt.x) + tri(.4, .1, n * t) * .4;\n\tc *= 1. - b * ls(.015, .05, pt.x) * .7;\n\tc *= 1. + e * b * (d.y - .5) * .7;\n\tc *= .9 + .2 * id;\n\tc *= .9 + .2 * ridged(NT(uv - pt.yx, vec2(5)));\n\tvec3 g;\n\tEVAL_GRAD(\n\t\tg, uv,\n\t\ttri(.5, .2, FBMT(p[i], vec2(23), .5, 2., 2)) *\n\t\ttri(.7, .3, NT(p[i], vec2(13)));\n\t);\n\tc *= 1. + g.y * g.z * b * b;\n\treturn c;\n}\n*/\n\n// gothic_block/killblockgeomtrn\nTEX(gkblkgmtrn) {\n\tvec3 c = gblks15(uv); // differs from actual shader; don't copy/paste!\n    uv -= .5;\n\tc = gkarnarcfnl_inner_gear(c, uv * .9, .02);\n\treturn c;\n}\n\n// Simple skull shape\n// x = light intensity\n// y = SDF\nvec2 skull(vec2 p) {\n\tp.x = abs(p.x); // symmetry\n\tvec2 q = p, v;\n\tq.y -= .5;\n\tfloat\n\t\td = circ(q, .35),\n\t\te, // secondary sdf\n\t\tc; // light intensity\n    v = q / .35;\n\tq.y += .22;\n\tq.x -= .15; // eye offset\n\td = min(d, box(q, vec2(.09, .05)) - .1); // cheekbones\n\te = elips(q, vec2(.15, .1)) / 5e1; // eye socket sdf\n    c = .1\n        + dot(vec2(v.y, sqrt(sat(1. - lsq(v)))), vec2(.3))  // base intensity\n        - .05 * tri(.44, .1, p.y) // slight eyebrow indentation\n        - .1 * smoothstep(.3, .22, length(p - .5)) // darken temples\n\t;\n\tq.y += .2;\n\tq.x = p.x; // recenter\n\tc = max(c, sat(.4 - length(q))); // brigten up bottom\n\tc +=\n        .15 * tri(.0, .1, e) // highlight eye socket edge\n        - .1 * msk(e + .12, .15) // darken eye socket interior\n        ;\n\td = min(d, box(q, vec2(.15 - ls(-.15, .15, q.y) * .07, .03)) - .09); // nose\n    c *= 1. - ls(.05, .25, q.x) * ls(.2, .1, abs(q.y + .12)); // maxilla gradient\n\tq.y -= .06;\n\tc -= .5 * msk(elips(q, vec2(.05 - ls(-.1, .1, q.y) * .03, .06)) / 1e3 + .03, .05); // darken nose\n\t//q.y += .15;\n\t//d = min(d, box(q, vec2(.1 - sqr(ls(.1, -.1, q.y)) * .03, .05)) - .05);\n\treturn vec2(sat(c), d);\n}\n\n// gothic_block/demon_block15fx\nTEX(gdmnblk15fx) {\n\tvec3 c = gblks15(uv); // differs from actual shader; don't copy/paste!\n\n    uv -= vec2(.5, .66);\n    float\n        b = FBMT(uv, vec2(5), .5, 3., 4),\n        t = .8 + .8 * b * b,\n        k = sqr(1. - tri(-.35, .2, uv.y)),\n        r, d, l;\n\n    EVAL_TOP_LIGHT(uv, .02, d, l, min(seg(p, vec2(0), vec2(0, -.44), .12), circ(p, .25)));\n    c = mix(c, mix(RGB(188, 133, 66), RGB(133, 127, 119), ls(.6, .2, -uv.y)) * t, msk(d, .01)); // base metal color\n    c *= 1.\n        + .6 * (l * .6 - .4) * sat(1.5 * tri(.2 + .1 * k, -.1 * k, -.2 * k - .03, d * 10.)) // outer bevel\n        + 1.5 * tri(.0, .08, uv.x) * tri(.02, .01, -d) // lower edge highlight\n\t;\n    //c = mix(c, vec3(.27), tri(.0, .15, uv.x) * tri(.0, .01, d) * sat(-l)); // grey bottom edge reflection; too subtle?\n\n    /* skull */\n    vec2\n        p = uv * 8. + vec2(0, 2.5),\n        q = skull(p);\n    l = (skull(p + vec2(0, .2)).y - q.y) / .2;\n    c *= 1.\n        - (l * .6 + .2) * tri(.05, .1, q.y) // skull bevel\n        - (.5 - 2. * q.x) * msk(q.y, .05) // skull interior\n\t;\n\n    /* crescent under skull */\n    EVAL_TOP_LIGHT(uv, .01, r, l, exclude(circ(p + vec2(0, .26), .09), circ(p, .255)));\n    c *= 1. - (l * .6 + .2) * tri(.0, .01, r) * msk(.1 - q.y, .1);\n\n    c = mix(c, gkarnarcfnl_inner_gear(c, uv * 1.4, .05), msk(.15 - q.y, .05));\n\n    p.x = abs(uv.x);\n    p.y = repeat(uv.y + .37, .06, -1., 1.);\n    c = add_rivet(c, p - vec2(.095, .015), .011, .2, .4); // knobs\n\n\treturn c;\n}\n\n// (384 x 384) Combination of:\n// - gothic_door/skull_door_a ( 64 x 256 - bottom right)\n// - gothic_door/skull_door_b (256 x 256 - bottom mid)\n// - gothic_door/skull_door_c ( 64 x 256 - bottom left)\n// - gothic_door/skull_door_d ( 64 x 128 - top right)\n// - gothic_door/skull_door_e (256 x 128 - top mid)\n// - gothic_door/skull_door_f ( 64 x 128 - top left)\nTEX(gskdr) {\n    uv *= 1.5;\n\n    float\n\t\tb = FBMT(wavy(uv, 7., .02), vec2(9), .7, 3., 2), // base FBM\n\t\tt = b, // base texture intensity (remapped FBM)\n        n = NT(uv, vec2(13)), // smooth noise\n        a, // angle\n        s, // segment fraction [0..1]\n        d; // SDF\n    vec3 c = gblks15(uv);\n    vec2 p;\n\n    p.x = abs(uv.x - .75);\n    p.y = max(uv.y - .58, 0.) * 1.15;\n    a = atan(p.x, p.y) / PI; // angle [-1..1]\n    s = fract(a * 7. + .5); // segments\n    d = circ(p, .45); // base arch\n    d -= .06 * ls(.4, .33, uv.y); // outer buttress\n    d -= .05 * ls(.15, .07, abs(s - .5)) * step(.63, uv.y);\n    d = exclude(d, uv.y - .107); // bilinear filtering hack: exclude bottom pixel row\n    if (uv.y < .6)\n\t\td = exclude(d, abs(p.x - .493) - .113); // bilinear filtering hack\n\td = exclude(d,\n\t\tcirc(p, .6) // carve out interior\n\t\t+ .044 * ls(.48, .43, uv.y) // inner buttress\n\t);\n    c = mix(c, RGB(144, 125, 115) * t, msk(d - .1, .005));\n    c *= 1.\n        - .3 * tri(.12, .11, .1, d) // outer shadow\n        + .5 * tri(.1, .005 + .015 * n * n, d) // highlight\n        ;\n\n    return c;\n}\n\n// gothic_door/skull_door_a ( 64 x 256 - bottom right)\nTEX(gskdr_a) {\n    return gskdr(vec2(5, 0) / 6. + uv * vec2(1, 4) / 6.);\n}\n\n// gothic_door/skull_door_b (256 x 256 - bottom mid)\nTEX(gskdr_b) {\n    return gskdr(vec2(1, 0) / 6. + uv * vec2(4) / 6.);\n}\n\n// gothic_door/skull_door_c ( 64 x 256 - bottom left)\nTEX(gskdr_c) {\n    return gskdr(uv * vec2(1, 4) / 6.);\n}\n\n// gothic_door/skull_door_d ( 64 x 128 - top right)\nTEX(gskdr_d) {\n    return gskdr(vec2(5, 4) / 6. + uv * vec2(1, 2) / 6.);\n}\n\n// gothic_door/skull_door_e (256 x 128 - top mid)\nTEX(gskdr_e) {\n    return gskdr(vec2(1, 4) / 6. + uv * vec2(4, 2) / 6.);\n}\n\n// gothic_door/skull_door_f ( 64 x 128 - top left)\nTEX(gskdr_f) {\n    return gskdr(vec2(0, 4) / 6. + uv * vec2(1, 2) / 6.);\n}\n\n// gothic_block/blocks18c\nTEX(gblks18c) {\n\tfloat b = FBMT(uv, vec2(13, 1), .7, 2., 3); // mostly vertical noise\n\tvec3 c = gblks15(uv) * .7; // base texture, slightly darkened\n\tc *= 1. - sqr(ls(.4, 1., b)); // dark drip stains\n\treturn c;\n}\n\n// s.x = specular size\n// s.y = specular intensity\nvec3 gklblki_base(vec2 uv, vec2 s) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 3., 4), // base FBM\n        n = FBMT(uv, vec2(31, 3), .5, 3., 3), // mostly vertical noise (for drip stains)\n        t = .75 + b * b; // base texture intensity (remapped FBM)\n\n    vec2 p = uv;\n    vec3 c = gblks15(uv); // differs from the actual shader; don't copy/paste!\n\n    if (uv.y < .38)\n        c = mix(RGB(92, 43, 15), RGB(66, 44, 33), ls(.1, .05, uv.y)) // base color\n            * t * (.5 + .5 * ls(.0, .35, uv.y)) // intensity\n            ;\n    c +=\n        b * s.y * sqr(tri(.32, s.x * .015, uv.y)) // highlight edge\n        + .3 * b * tri(.34, .05, uv.y) // highlight top\n        ;\n    c *= 1.\n        - tri(.38, .005 + b * b * .03, uv.y) // shadow under blocks\n        + 3. * tri(.15, .2, uv.y) * (n - .5) // dark drip stains\n        ;\n\n    return c;\n}\n\nvec3 gklblki_vent(vec3 c, vec2 uv, float b) {\n\tfloat\n        t = .75 + b * b, // base texture intensity (remapped FBM)\n        d, o, i;\n\n    vec2 p = uv;\n    p.y -= .21;\n\n   \td = circ(vec2(.75 * p.x, elongate(p.y, .1)), .033);\n    o = msk(d, .005); // outer part\n    d = circ(vec2(.75 * p.x, elongate(p.y + .005, .09)), .033);\n    i = msk(d + .015, .004); // inner part\n    c = mix(c, RGB(83, 81, 66) * t, (o - i) * ls(.1, .3, uv.y)); // base metallic color\n    c *= 1. - ls(.17, .25, uv.y) * i; // inner shadow\n    c += sqr(tri(.0, .015, d)) * tri(.32, .03, uv.y); // top specular\n    c *= 1. + 3. * pow(tri(-.01, .03, d), 4.) * tri(.09, .03, uv.y); // bottom specular\n\n    d = circ(vec2(.75 * p.x, elongate(p.y + .03, .1)), .033); // shadow distance\n    c *= 1. - msk(d + .01, .02) * (1. - o); // outer shadow\n\n    if (uv.y > .09 && uv.y < .3)\n    \tc = add_rivet(c, vec2((abs(p.x) - .035) * 36., fract(uv.y * 36.) - .5), .1);\n\n    return c;\n}\n\n// gothic_block/killblock_i\nTEX(gklblki) {\n\tfloat b = FBMT(uv, vec2(5), .9, 3., 4); // base FBM\n    vec3 c = gklblki_base(uv, vec2(1));\n    uv.x = mod(uv.x, 1./7.) - .07; // repeat 7x horizontally\n    return gklblki_vent(c, uv, b);\n}\n\n// gothic_block/killblock_i4\nTEX(gklblki4) {\n\tfloat\n\t\tb = FBMT(uv, vec2(9), .7, 2., 4), // base FBM\n\t\tt = .75 + b * b, // base texture intensity (remapped FBM)\n        l;\n\tvec3 c = gklblki_base(uv, vec2(4, .3));\n\tvec2 p = uv, s;\n\tp.x = mod(p.x, .2); // repeat x5 horizontally\n\tp -= .1;\n\ts = skull(p * 5.); // skull grayscale intensity + SDF\n    l = (skull(p * 5. + vec2(0, .1)) - s).y / .1; // skull light/shadow\n    c = mix(c, mix(vec3(.5, .4, .3), vec3(.95, .8, .55), t) * t * s.x, msk(s.y, .02)); // skulls\n    c *= 1. - (.5 - l * .3) * tri(.03, .07 + .13 * sat(-l), s.y); // skull shadows, larger below\n\treturn c;\n}\n\n// gothic_trim/baseboard09_e\nTEX(gtbsbrd09e) {\n    float\n\t\tb = FBMT(uv, vec2(9, 3), .9, 3., 4), // base FBM\n        n = FBMT(uv, vec2(11, 5), .5, 3., 4), // slightly smoother FBM\n\t\tt = .75 + b * b, // base texture intensity (remapped noisy FBM)\n        l, m;\n    vec3 c = mix(RGB(48, 44, 44), RGB(77, 55, 44), ls(.3, .7, n)) * t;\n    vec2 p, q, s;\n\n    p.x = mod(uv.x + .14, .28) - .22;\n    p.y = uv.y * .4 - .09;\n\n    // top slots\n    q.x = mod(uv.x - .014, .14);\n\tq.y = uv.y;\n    c = mix(c, RGB(133, 122, 122) * t, tri(.9, .91, 1., uv.y) * ls(.03, .033, abs(q.x - .07)));\n    c = mix(c, RGB(88, 73, 70) * t * ls(1., .96, uv.y), ls(.86, .87, uv.y) * ls(.033, .03, abs(q.x - .07)));\n\n    // stadium-shaped vents between skulls\n    c = gklblki_vent(c, p * 1.2, b);\n\n    // cables\n    c *= ls(.2, .3, uv.y);\n    c = add_all_techpipes(c, uv * vec2(1.5, .75), b);\n\n    // skulls\n    t = .8 + .8 * n * n; // smoother base texture intensity\n    p.x += .133;\n    p.y = p.y * 1.1 - .09;\n    m = step(abs(uv.x - .5), .4); // 3 skull limit\n    s = skull(p * 5.); // skull grayscale intensity + SDF\n    l = (skull(p * 5. + vec2(0, .1)) - s).y / .1; // skull light/shadow\n    c = mix(c, 2.5 * mix(RGB(122, 99, 95), RGB(99, 66, 50), b) * t * s.x, msk(s.y, .02) * m); // skulls\n    c *= 1. - (.5 - l * .3) * tri(.02, .07 + .13 * sat(-l), s.y) * m; // skull shadows, larger below\n\n    return c;\n}\n\n// gothic_trim/baseboard09_c3\nTEX(gtbsbrd09c3) {\n    float\n        b = FBMT(uv, vec2(9, 3), .9, 3., 4), // base FBM\n\t\tt = .65 + 1.4 * b * b; // base texture intensity (remapped FBM)\n    vec3\n        c = RGB(60, 50, 44) * t, // base color\n        k; // secondary color\n    vec2 p, q;\n\n    p.x = mod(uv.x + .14, .28) - .22;\n    p.y = uv.y * .4 - .09;\n\n    // panels\n    c *= 1.\n        + b * tri(-.13, .006, p.x) // panel edge highlight\n        - tri(-.135, .004, p.x) // panel edge shadow\n    ;\n    c = add_rivet(c, vec2(abs(p.x + .135) - .02, mod(uv.y * .5 - .02, .07) - .05), .006, .4, .7);\n\n    // vent interior\n    k = RGB(77, 55, 33) * t * (.7 + .3 * ridged(fract(uv.x * 66.)));\n    q.x = p.x;\n    q.y = elongate(p.y - .16, .07);\n    c = mix(c, k, msk(circ(q, .02), .03));\n\n    // top slots\n    q.x = mod(uv.x - .014, .14);\n\tq.y = uv.y;\n    c = mix(c, RGB(122, 99, 88) * t, tri(.9, .91, 1., uv.y) * ls(.03, .033, abs(q.x - .07)));\n    c = mix(c, RGB(88, 77, 66) * t * ls(1., .96, uv.y), ls(.86, .87, uv.y) * ls(.033, .03, abs(q.x - .07)));\n\n    // stadium-shaped vents\n    c = gklblki_vent(c, p * 1.2, b);\n\n    // bottom panel\n    c = mix(c, t * mix(RGB(45, 77, 66), RGB(99, 55, 22), NT(uv.x * 55., 55.)), ls(.25, .23, uv.y)); // base color\n\n    c *= 1.\n        //+ b * tri(.5, .3, fract(uv.x * 99.)) * tri(.23, .025, uv.y) // bottom panel edge ridges\n        + .7 * sqr(tri(.23, .03, uv.y)) // bottom panel edge highlight\n        - .4 * tri(.22, .18, .12, uv.y) // bottom panel edge shadow\n        - .5 * ls(.23, .21, uv.y) // darken bottom panel\n        - .5 * ls(.1, .0, uv.y) // black bottom\n    ;\n\n    return c;\n}\n\n// gothic_trim/baseboard09_o3\nTEX(gtbsbrd09o3) {\n    uv.y *= .5; // correct aspect ratio\n    float\n        b = FBMT(uv, vec2(7), .9, 3., 4),\n        d, m\n    ;\n    vec3 c = vec3(.6 * b);\n    vec2 p, q;\n    p.x = mod(uv.x + .15, .33) - .15;\n    p.y = uv.y - .5;\n    p.x *= 2.;\n    c = mix(c, RGB(111, 99, 77) * b, m = ls(.0, -.01, d = box(p, vec2(.14, .05)) - .05)); // top slots\n\n    c *= 1.\n        + 2. * tri(.46, .033, uv.y) // top specular\n        + tri(.0, .01, d) // slot edge highlight\n        - .9 * sqr(tri(.13, .03, uv.y)) // dark groove\n        - .7 * tri(-.01, .01, d) // inner slot shadow\n        - ridged(fract(p.x * 44.)) * sat(-d * 44.) * b // top pipe ridges\n        //- ls(.08, .0, uv.y - .02 * NT(uv.x * 15., 15.)) // jagged bottom shadow\n        - ls(.1, .0, uv.y) // bottom shadow\n        - ls(.03, .01, abs(uv.y - .33)) // shadow behind top third pipes\n    ;\n\n    vec3 k = mix(RGB(122, 88, 66), RGB(133, 77, 44), b) * (.5 + 1.5 * b * b); // copper-ish color\n    c = mix(c, c * 8. * greebles(uv * 2., b, .3), ls(.35, .3, uv.y)); // greeble up\n/*\n    c *= 1.\n        - (.4 - b) * ls(.4, .2, uv.y) // amplify noise and brighten up a bit\n    ;\n*/\n/*\n    // thin twin middle pipes (90-degree corners)\n    p = mod(uv, .63) - vec2(.21, .3);\n    d = circ(q = min(p, vec2(0)), .02);\n    d = onion(d, .01);\n    d = onion(d, .005);\n    d = max(d, uv.y - .33);\n    d = max(d, p.x - .1);\n    c = mix(c, k, ls(.0, -.005, d));\n    c *= 1.\n        - .7 * tri(-.005, .0, .02, d)\n    ;\n\n    p.x = mod(uv.x, .62) - .3;\n    p.y += .02;\n    c = mix(c, k * .5, ls(.0, -.005, d = box(p, vec2(.04, .02))));\n    c *= 1.\n        - .7 * tri(-.005, .0, .02, d)\n    ;\n*/\n\n    // top third pipes and covers\n    p.x = abs(uv.x - .5); // horizontal symmetry\n    p.y = uv.y - .33;\n    d = abs(p.y) - .03;\n    d = max(d, -box(p - vec2(.16, 0), vec2(.02, 0)) + .01); // inner slots\n    d = max(d, -box(p - vec2(.55, 0), vec2(.01, 0)) + .08);\n    d = max(d, -box(p - vec2(.33, 0), vec2(.01, 0)) + .08);\n    c = mix(c, k, ls(.0, -.005, abs(p.y) - .013)); // top third pipes\n    c *= 1.\n        + .5 * tri(.004, .006, p.y) // bright pipe reflection\n        - .7 * tri(-.004, .006, p.y) // dark pipe reflection\n    ;\n    c *= 1.\n        - .7 * tri(.5, .05, fract(p.x * 11.)) * tri(.0, .02, p.y) // pipe segments\n    ;\n    c = mix(c, k, m = ls(.0, -.005, d));\n    c *= 1.\n        + .5 * tri(-.004, .004, d) // edge highlight\n        - .7 * tri(-.004, .0, .01 + .07 * ls(.02, .2, -p.y), d) * ls(.04, .0, p.y) // outer shadow\n    ;\n\n    c = mix(c, c * k * 2., ls(.05 + .5 * sqr(NT(uv.x * 99., 99.)), -.1, .3 - uv.y) * ls(.35, .28, uv.y)); // grime\n\n    // bottom third pipes\n    p.y = uv.y - .117;\n    c = mix(c, k * .4 * b, ls(.0, -.005, abs(p.y) - .013));\n    c *= 1.\n        + 1.5 * tri(.001, .007, p.y) // bright reflection\n        + 1.5 * tri(.5, .3, fract(uv.x * 77. + .2)) * tri(.0, .01, p.y) // ridges\n    ;\n\n    // vertical pipes (bottom third)\n    //p.x = mod(mod(uv.x, .33) - .02, .1) - .05;\n    p.x = mod(elongate(mod(uv.x, .33), .03), .1) - .05; // slightly uneven repetition\n    p.y = uv.y - .13;\n    c = mix(c, RGB(144, 99, 77) * b, m = ls(.0, -.01, d = box(p, vec2(0, .05)) - .025));\n    c *= 1.\n        - .9 * pow(tri(-.005, .03, d), 4.) // edge shadow\n        + 1.5 * tri(.0, .015, p.x) * tri(.0, .055, p.y) // specular\n    ;\n    p.y += sqr(p.x) * 555. * p.y; // distortion: make ridges appear curved\n    c *= 1.\n        - b * tri(.3, .7, .9, fract(p.y * 55.)) * m // ridges\n        - sqr(tri(.5, .01, uv.y)) // bilinear filtering hack: darken top\n    ;\n\n    // vertical pipe fittings\n    p.y = uv.y - .13;\n    d = abs(d - .005) - .01 * ls(-.05, .05, p.y);\n    c = mix(c, RGB(188, 155, 133) * b * 2. * ls(.06, .01, length(p - vec2(0, .06))), m = ls(.0, -.01, d = max(d, -p.y)));\n\n    c *= 1.\n        - sqr(tri(-.01, .0, .012, d)) // pipe fitting outer shadow\n        //+ .5 * tri(.007, .007, d) // pipe fitting edge highlight\n    ;\n\n    // small rectangular flaps\n    d = box(p - vec2(0, .1), vec2(.025, .007));\n    c *= 1.\n        - .7 * sqr(ls(.02, .005, d)) // shadow\n    ;\n    d = max(d, -box(p - vec2(0, .082), vec2(.015, .02)));\n    c = mix(c, k * b * 1.5, ls(.004, .0, d));\n    c *= 1.\n        + .5 * tri(.0, .004, d) // edge highlight\n    ;\n\n    return c;\n}\n\n// gothic_floor/center2trn (texture)\nTEXA(gcntr2trn) {\n\tfloat\n        b = FBMT(uv -= .5, vec2(5), .9, 3., 4), // base fbm\n        t = .75 + b * b, // base texture intensity (remapped fbm)\n        n = NT(wavy(uv, 7., .02), vec2(17)), // low-frequency variation\n        r = length(uv), // distance from center\n        k = r > .4 ? 38. : r > .32 ? 28. : 16., // number of bricks in circle\n        a = fract(atan(uv.y, uv.x) / TAU), // angle [0..1]\n        i = floor(a * k), // brick number [0..k)\n        r2 = abs(abs(r - .41 - n * .002) * 1e2 - 6.),\n        m = ls(1.5, 1.4, r2), // mask\n\t\trl[] = float[](1., 3., -.145, -1., 2., .166), // 2 rhombus lines: x0, y0, dist0, x1, y1, dist1\n\t\td, ld, s;\n\n    vec2 p = uv;\n    vec3 c = RGB(78, 68, 63); // outer color\n    c *= 1. + .5 * sqr(tri(.49, .005 + .015 * n * n + .015 * b, r)); // highlight outer edge\n\tc = mix(c, RGB(83, 52, 47) * (.6 + .4 * n * n), m) * t;\n\n    c *= 1.\n        - .5 * tri(1.5, .5, r2) // dark outer edge\n        + b * tri(1., .5 + .5 * n, abs(r - .418) * 1e2 - 5.) // edge highlight\n        - b * tri(.5, .08, fract(a * k + .5)) * m // dark edge between bricks in circle\n        + b * tri(.5, .1, fract(a * k + .55)) * m // lit edge between bricks in circle\n        ;\n\n    // inner 3 brick rows\n    m = ls(.34, .33, r); // mask\n    c = mix(c * (1. - .5 * m), RGB(83, 52, 47) * t, n * b * m); // base color\n    c = mix(c, RGB(112, 86, 31) * t, m * sqr(tri(.1, .15, .45, b)));\n    c = mix(c, RGB(77, 66, 77) * t, m * ls(.5, .8, b) * .5);\n    c *= 1. - .7 * tri(.27, .34, .35, r); // soft shadow\n\n    r2 = r + n * .004; // slight distortion\n    m = r > .21 && r < .31 ? 1. : 0.;\n    c *= 1.\n        - tri(.325, .005, r2) // dark edge\n    \t- tri(.31, .005, r2) // dark edge\n        - b * sqr(tri(.29, .005, r2)) // dark edge\n        - b * sqr(tri(.23, .01, r2)) // dark edge\n        - .5 * sqr(tri(.21, .02, r2)) // dark edge\n        + sqr(tri(.3, .01, r2)) * b // highlight\n        + sqr(tri(.22, .01, r2)) * b // highlight\n        - b * tri(.5, .07, fract(a * k + .5)) * m // dark edge between bricks in circle\n        ;\n    // separate ids for each row of bricks\n    if (r < .23) i += 37.;\n    if (r < .31) i += 73.;\n    if (r < .31) i += 91.;\n    c *= mix(1., .9 + .2 * R1(i), m); // vary intensity based on brick id\n\n    // rhombus ring\n    m = ls(.01, .0, abs(r - .411) - .039); // mask\n    i = floor(a * 72.); // base id\n    p *= rot(i * 5.); // polar mod: 360/72 = 5\n    s = 0.;\n    d = 1e6;\n    int j = 0;\n    for (/**/; j < 6; j += 3) { // for each line\n        d = minabs(d, ld = dot(p, normalize(vec2(rl[j], rl[j+1]))) + rl[j+2]); // distance to line\n        s += s + float(ld > 0.); // which side of line 1 we're on\n    }\n    // find rhombus id\n    if (s == 3.)\n        ++i;\n    else\n        i += 66. * s;\n    i = R1(i);\n    c = mix(c, t * RGB(90, 80, 75), m);\n    c = mix(c, t * RGB(127, 111, 88), i * b * m);\n    c *= mix(1., .7 + .6 * H(i), m); // per-tile variation\n    c *= 1.\n        - m * sqr(tri(.0, .006, d)) * b // shadow\n        + m * sqr(tri(.006, .006, abs(d))) * b * .5 // highlight\n        ;\n\n    // inner grill\n    i = floor(a * 4.); // base id\n    p = abs(uv * rot(i * 90. + 45.)); // polar mod + reflection\n    d = 1e6;\n    for (j = 0; j < 2; ++j, p = abs(p * rot(45.)))\n        d = minabs(d, abs(length(p - vec2(0, .12)) - .16));\n    m = ls(.21, .2, r);\n    r2 = onion(onion(d, .012), .001); // grill outline\n    c *= 1.\n        - ls(.21, .2, r) * msk(.012 - d) // dark void under grill\n        + b * m * sqr(tri(.005, .005, d)) // highlight\n        - .5 * m * sqr(msk(r2 - .001, .001)) // darken grill edges\n        ;\n\n    // note: last factor tapers alpha a bit to avoid some ugly aliased corners\n    return vec4(c, (1. - ls(.21, .15, r) * msk(.028 - d, .02)) * ls(.07, .087, r));\n}\n\n// gothic_floor/center2trn (map shader)\nTEXA(gcntr2trn_m) {\n    vec2 p = uv - .5;\n\tfloat b = FBMT(p * rot(Time.x * 333.) * (.8 + .2 * sin(Time.x * 61.)), vec2(53), .7, 2., 4); // 61 ~= TAU * 9.7\n\tvec4\n        c = vec4(1. - b * vec3(0, .3, 1), 1),\n        c2 = gcntr2trn((p * rot(Time.x * 30.) * (.8 + .2 * sin(Time.x * 1.26))) + .5); // 1.26 ~= TAU * .2\n    c.xyz = mix(c.xyz, c2.xyz, c2.w);\n    c2 = gcntr2trn(uv);\n    c.xyz = mix(c.xyz, c2.xyz, c2.w);\n    return c;\n}\n\nfloat scmpblk17_sdf(vec2 p) {\n    p = pmod(p, 8.);\n    float d = circ(p, .41);\n    d = min(d, box((p - vec2(.34, 0)) * rot(45.), vec2(.1)));\n    d = max(d, p.x - .45);\n    return d;\n}\n\n// sfx/computer_blocks17 (texture)\nTEX(scmpblk17) {\n    vec2\n        p = uv - .5,\n        q;\n    float\n\t\tb = FBMT(uv, vec2(9), .7, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        r = circ(p, .41), // outer ring SDF\n        d = scmpblk17_sdf(p), // base SDF\n        l = dFdy(d) / .004, // top light\n        m = msk(d + .01, .007), // SDF mask\n        a = nang(p), // normalized angle\n\t\te, n, x, z;\n    vec3\n        c = NO_COPY_PASTE gblks15(uv) NO_COPY_PASTE, // base color (stone blocks)\n        k = RGB(155, 135, 115) * t; // metallic color\n    c *= 1.\n        - (.5 * -l + .5) * ls(.03, .0, d) // outer shadow\n        ;\n    c = mix(c, k, m); // metallic background\n    e = length(p) * 9.;\n    q.x = a * floor(e + 1.) * 3.;\n    q.y = fract(e);\n    n = tri(.5, .2, NT(wavy(uv, 7., .03), vec2(41)));\n    n = FBMT(q, vec2(3, 9), .5, 2., 4) * tri(.5, .5 + .5 * n, q.y); // polar noise\n    c = mix(c, RGB(100, 85, 80) * ridged(n) * b, msk(r + .15, .02)); // inner vortex\n\n    q = p;\n    q.x = abs(p.x);\n    e = max(max(d, half_plane(q, -vec2(.08, .4))), abs(r + .06) - .09); // top clamp\n    z = box(q - vec2(0, .3), vec2(.01, .03));\n    e = exclude(e, z - .02);\n    x = msk(-e, .01); // mask that excludes the top clamp\n\n    /* ring wires */\n    c = mix(c, wire_ring(c, uv, .32, .025), x);\n\n    c *= 1.\n        + l * m * ls(.02, .0, -d) * ls(.01, .0, -r) // outer edge lighting\n        + x * tri(.035, .015, -r) // outer ring highlight\n        + .5 * x * tri(.13, .01, -r) // inner ring highlight\n        + .7 * tri(.08, .007, z) * (1. - x) // top clamp highlight\n        - .7 * x * sqr(tri(.01, .04, -r)) // outer ring outer shadow\n        - .6 * x * sqr(tri(.13, .06, .03, -r)) // outer ring inner shadow\n        - .5 * x * sqr(tri(.12, .02, -r)) * m // inner ring outer shadow\n        - .9 * sqr(tri(.12, .15, .2, -r)) * m // inner ring inner shadow\n        - .5 * sqr(tri(.0, .05, e)) // top clamp outer shadow\n        ;\n\n    c += vec3(.8, .8, 1) * pow(sat(1. - length(uv - vec2(.41, .59)) / .35), 8.); // specular\n\n\n    /* bottom clamp */\n    e = box(p + vec2(0, .33), vec2(.01, .03)) - .03; // SDF\n    l = dFdy(e) / .004; // top light\n    c = mix(c, k * (.4 + .8 * ls(.25, .41, -p.y)), z = msk(e, .01)); // base color\n    c *= 1.\n        + .7 * tri(.005, .01, e) * l // edge lighting\n\t\t- .5 * tri(.0, .01, .05, e) // outer shadow\n        ;\n\n    /* led box */\n    e = box(q = p + vec2(0, .35), vec2(.01, .015)) - .01; // SDF\n    l = dFdy(e) / .004; // top light\n    c *= 1.\n        + .5 * tri(.005, .01, e)\n        - .5 * sqr(tri(.0, .01, e))\n        ;\n    c += vec3(1, .7, .5) * pow(sat(1. - length(q) / .11), 8.); // light glow\n\n    return c;\n}\n\n// sfx/computer_blocks17 (map shader)\nvoid scmpblk17_m() {\n    vec3 c = scmpblk17(fract(UV)); // actual shader applies lightmap here\n\n    vec2\n        uv = fract(UV) - .5,\n        p = uv;\n    float\n        t = mod(Time.x * 2., 7.),\n        i = floor(t),\n        d = 1e6;\n\n    if (i == 0.)\n\t\td = sdf_Q(p * 2.4 + vec2(0, .05));\n\n    if (i == 1.) {\n        p.x = repeat(p.x, .1, -1., 1.); // repeat x3\n        d = box(p, vec2(.02, .15)) * 2.;\n    }\n\n    if (i == 2.) {\n        // A\n        d = min(d, box(mirr(p, .0) + vec2(.13 - ls(-.3, .3, uv.y) * .17, 0), vec2(.02, .15)));\n        d = min(d, box(p + vec2(0, .07), vec2(.07, .02))) * 2.;\n    }\n\n    if (i == 4.)\n\t\td = icon_sdf(p * 1.8, .5);\n\telse\n        d = onion(d, .005);\n\n    FCol = vec4(c + msk(d, .02) * fract(-t) * vec3(.5, .05, .05), 1);\n}\n\n// gothic_wall/slateroofc\nTEX(gsltrfc) {\n    vec2\n        p = brick(uv, vec2(6, 4)),\n        q = fract(p),\n        u = q;\n\tfloat\n        b = FBMT(wavy(uv -= .5, 5., .03), vec2(13), .9, 2., 3), // base fbm\n        n = NT(uv, vec2(73, 7)),\n        t = (.75 + b * b) * (.8 + .4 * SR1(uv.x * 93.)), // base texture intensity (remapped fbm)\n        r\n        ;\n\n    vec3 c = vec3(.25 * t);\n    u.y += u.y * 2. -.01 - .03 * n;\n    r = length(u -= clamp(u, vec2(.49, .5), vec2(.51, 3)));\n    c *= 1.\n        - .7 * b * sqr(ls(.07, .03, abs(r - .5)))\n        + .5 * b * tri(.35, .1, r) * sqr(ls(.2, .1, q.y))\n        - .3 * sqr(ls(.8, 1., q.y))\n        - .3 * (ls(.3, .1, q.y)) * ls(.4, .6, r)\n        + .2 * sqr(ls(.5, .1, q.y)) * ls(.45, .4, r)\n        ;\n    \n    return c;\n}\n\n// gothic_trim/pitted_rust3\nTEX(gtprst3) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4),\n        n = FBMT(uv, vec2(7), .9, 3., 4);\n    vec3\n        c = mix(RGB(60, 50, 50), RGB(87, 47, 37), sqr(ls(.7, .25, n))) * (.7 + .8 * b * b),\n        g;\n    \n    uv = wavy(uv, 31., .003);\n    EVAL_GRAD(\n        g, uv,\n        sqrt(ls(.0, .9, NT(p[i], vec2(93))))\n\t);\n\n    c *= 1. - (g.y + .4) * sqr(b * g.z) * g.z;\n\n    return c;\n}\n\n\n// gothic_trim/skullsvertgray02b\nTEX(gsklvtg02b) {\n\tfloat\n        b = FBMT(uv, vec2(5), .9, 3., 4);\n    vec3\n        c = RGB(67, 64, 63) * (.6 + .5 * b),\n        g;\n\n    uv = wavy(uv, 31., .003);\n    EVAL_GRAD(\n        g, uv,\n        sqrt(NT(p[i], vec2(53, 93)))\n\t);\n\n    c *= 1. - .3 * g.y * g.z * g.z;\n\n    return c;\n}\n\n// skin/chapthroat\nTEXA(skcpthrt) {\n    uv = wavy(uv, 7., .01);\n\tfloat\n        b = FBMT(uv, vec2(9), .7, 2., 4),\n        n = FBMT(uv, vec2(13), .5, 2., 4),\n        m = ls(.6, .9, FBMT(wavy(uv, 5., .03), vec2(11), .6, 2., 4))\n        ;\n\tvec3 c = RGB(127, 70, 55) * (.85 + .3 * b);\n\tc *= 1.\n        - .2 * sqr(ls(.3, .0, b * b))\n        - .2 * m\n        - .3 * ls(.6, .77, n)\n        + .3 * ls(.5, .9, b)\n        ;\n    c += .5 * sqr(ls(.5, 1., FBMT(uv, vec2(17), 1., 2., 3)));\n\treturn vec4(c, 1. - m);\n}\n\n// skin/chapthroatooz\nTEX(skcpthrtooz) {\n    vec4 c = skcpthrt(uv);\n    uv.y -= .2 * Time.x;\n    float b = FBMT(wavy(uv, 7., .02), vec2(5), .9, 2., 4);\n    return mix(RGB(25, 10, 8) * b, c.xyz, c.w);\n}\n\n// skin/chapthroat2\nTEX(skcpthrt2) {\n    vec2 p = uv - .5;\n    p = wavy(p, 17., .007);\n    p.x *= 2. - uv.y * 1.5;\n    float\n\t\tb = FBMT(uv, vec2(9), .7, 2., 4),\n    \tn = NT(uv, vec2(7)),\n        d = length(p),\n        s;\n    vec3 c = skcpthrt(uv).xyz;\n    s = fract(d *= 13.);\n    if (d <= 6.) {\n        c *= 1.\n            - pow(ls(6., .5, d + b * b), 6.) // darken interior\n            ;\n        n = ls(.3, .7, n); // remap noise\n        c *= 1.\n\t\t\t- n * b * tri(.4, .2, s) // darken edges\n\t\t\t+ n * b * tri(.6, .4, s) // highlight edges\n            ;\n    }\n    return c;\n}\n\n// skin/tongue_trans\nTEX(sktongue) {\n    uv = wavy(uv, 13., .003);\n\tfloat\n        b = FBMT(uv, vec2(7), .9, 3., 4), // base FBM\n        n = FBMT(uv, vec2(5), .5, 2., 4), // smoother FBM\n        t = .5 + b // base texture intensity (remapped fbm)\n        ;\n\tvec3\n        c = RGB(80, 38, 34), // base color\n        v = voro(uv, vec2(23));\n    c = mix(c, mix(RGB(180, 125, 118), RGB(165, 78, 51), n), b * tri(.0, .4 + n * .4, v.z)) * t;\n\treturn c;\n}\n\n// skin/surface8\nTEX(gsksurf8) {\n\tfloat\n        b = FBMT(uv, vec2(7), .9, 3., 4), // base FBM\n        t = .8 +.4 * b, // base texture intensity (remapped FBM)\n        i, // cell ID\n        r = .7, // radius\n        l, // light intensity\n        m // mask\n        ;\n\tvec3\n        c, // base color\n        v = voro(uv, vec2(23)); // voronoi diagram\n    vec2\n        p = v.xy / r,\n        q = uv + v.xy / 23.;\n\n    i = H(fract(q) * 3.3);\n    c = mix(RGB(155, 55, 55), RGB(200, 166, 155), ls(.75, .45, q.y)) * t;\n    m = tri(.5, .5, length(p));\n    l = dot(vec2(-p.y, sqrt(sat(1. - lsq(p)))), vec2(.6 + i * .3, .3));\n    c *= 1.\n        - b * .8 * ls(.5, .1, v.z)\n    \t+ b * m * l\n        ;\n    c *= t * t * t * t; // add some noise\n\n\treturn c;\n}\n\n// gothic_wall/skull4\nTEX(gskull4) {\n\tfloat\n\t\tb = FBMT(uv, vec2(13), .9, 3., 4), // base FBM\n\t\tt = .4 + b * b, // base texture intensity (remapped FBM)\n\t\tn = ridged(NT(wavy(uv, 12., .02), vec2(48))),\n\t\ti, r, l, m;\n\tvec3\n\t\tc = RGB(60, 50, 46) * t, // base color\n\t\tv = voro(uv, vec2(17)); // voronoi diagram\n\n\ti = H(fract(uv + v.xy / 17.)); // cell ID\n\tr = .4 + .3 * i; // skull size (varies per cell)\n\tvec2 p = v.xy / r; // normalized offset from skull center\n    m = min(ls(1.1, 1., length(p)), ls(.0, .15, v.z)); // skull region mask\n\tl = dot(vec2(-p.y, sqrt(sat(1. - lsq(p)))), vec2(.1 + i * .2, .3)); // light intensity (varies per cell)\n\tc += b * m * l * n;\n\n\tn = ridged(FBMT(wavy(uv, 13., .01), vec2(23, 43), .5, 2., 3)); // stretched, wavy noise\n    c *= 1. + (1. - m) * tri(.4, .4, n); // light variation between skulls (simulating bones)\n\n    return c;\n}\n\n/*\nTEX(gskull4) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4), // base FBM\n        t = .4 + b * b, // base texture intensity (remapped FBM)\n        n = ridged(NT(wavy(uv, 12., .02), vec2(48))),\n        i, // cell ID\n        r, // skull size (varies per cell)\n        l, // light intensity\n        m // skull mask\n        ;\n\tvec3\n        c = RGB(60, 50, 46) * t, // base color\n        v = voro(uv, vec2(17)); // voronoi diagram\n\n    i = H(fract(uv + v.xy / 17.));\n    r = .4 + .2 * i;\n    vec2 p = v.xy / r;\n    m = min(ls(1.1, 1., length(p)), ls(.0, .5 * i, v.z));\n    l = dot(vec2(-p.y, sqrt(sat(1. - lsq(p)))), vec2(.1 + i * .3, .3));\n    c += b * m * l * n;\n    \n\tn = FBMT(wavy(uv, 13., .01), vec2(23, 43), .5, 2., 3);\n    c *= 1. - (1. - m) * ls(.0, .4, abs(n - .5));\n\n\treturn c;\n}\n*/\n\n// base_trim/basemetalsupport\nTEX(bmtsprt) {\n\tfloat\n\t\tb = FBMT(uv, vec2(7, 3), .9, 3., 4),\n\t\th = uv.y + b * .04;\n\tvec3 c = mix(RGB(50, 40, 34), RGB(93, 92, 88), b * b);\n\tc *= 1.\n\t\t+ .9 * ls(.07, .04, abs(uv.y - .44))\n\t\t- .4 * ls(.08, .05, abs(uv.y - .7))\n\t\t- .5 * tri(.34, .05, uv.y)\n\t\t- .3 * tri(.7, .04, uv.y)\n\t\t+ .7 * tri(.01, .03, uv.y)\n\t\t+ 1.5 * tri(.89, .1, h)\n\t\t+ 1.3 * tri(.5, .04, h)\n\t\t+ .9 * tri(.18, .04, h)\n\t\t;\n\treturn c;\n}\n\n// gothic_trim/metalsupsolid\nTEX(gmtlspsld) {\n\tfloat\n        b = FBMT(uv, vec2(7), .9, 3., 4),\n    \tn = FBMT(uv, vec2(3), .5, 3., 4);\n\tvec3 c = mix(RGB(103, 56, 53), RGB(73, 58, 71), ls(.1, .7, n)) * (.75 + b * b);\n\treturn c;\n}\n\n// gothic_trim/metalsupport4b\nTEX(gmtlsp4b) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4),\n    \tn = NT(wavy(uv, 5., .05), vec2(9)),\n        d = ridged(fract(uv.x * 4.)),\n        m = ls(.1, .15, d) * ls(1., .99, uv.y);\n\tvec3 c = RGB(51, 44, 44);\n    c = mix(c, RGB(73, 55, 52), ls(.2, .2, b) * n * m);\n    c = mix(c, RGB(69, 60, 66), ls(.7, .1, b) * b * m);\n    c = mix(c, RGB(99, 77, 77), ls(.1, .5, n) * n * m * b * b * .3);\n    c *= .6 + .3 * b + .3 * b * b;\n    c *= 1. + .9 * sqr(tri(.21, .02 + .1 * n, d + b * .05)) * m * b;\n    c *= 1. - sqr(ls(.49, .5, abs(uv.y - .5)));\n    c *= 1. - ls(.05, .2, d) * ls(.16, .1, d);\n    c *= 1. + tri(.99, .007, uv.y);\n    return add_rivet(c, vec2(d - .4, fract(uv.y * 8.) - .5), .07);\n}\n\nvec3 gspbdrbb_v(vec2 uv, float s)  {\n\tfloat\n\t\tb = FBMT(uv, vec2(3, 1. + s + s), .7, 2., 4),\n\t\td = ridged(uv.x),\n\t\tm;\n\tuv.y *= 2.;\n\tvec3 c = mix(RGB(71, 60, 58), RGB(110, 88, 77), ls(.1, .05, d)) * (.7 + .6 * b);\n\tc *= 1. - ls(.05, .0, uv.x) * (1. - b * b);\n\tc *= 1. + .5 * tri(.05, .02, uv.x);\n\tvec2 p = vec2(d - .35, fract(uv.y * s) - .5);\n\tvec4 k = rivet(p, .11);\n\tm = msk(k.w);\n\tc *= 1. - .7 * rivet_shadow(p, 1.1) * (1. - m);\n\tc = mix(c,\n\t\t\t(k.y > .0 ? RGB(128, 105, 88) : RGB(200,111,66) * ls(-.2, .7, k.z)) *\n\t\t\t(.4 + 2. * b * pow(sat(sum(k.yz * .7)), 4.)) *\n\t\t\t(1. - .6 * tri(-.1, .4, k.y)),\n\t\t\tm);\n\treturn c;\n}\n\n// gothic_wall/supportborder_blue_b\nTEX(gspbdrbb) {\n\treturn gspbdrbb_v(uv, 4.);\n}\n\n// gothic_trim/km_arena1tower4_a\nTEX(gkarntwr4a) {\n\treturn gspbdrbb(uv.yx);\n}\n\n// gothic_trim/km_arena1tower_short\nTEX(gkarntwrst) {\n\treturn gspbdrbb_v(uv, 1.);\n}\n\n// gothic_floor/xstairtop4\nTEX(gxstrtop4) {\n\tfloat b = FBMT(uv, vec2(40, 5), .9, 3., 4);\n\tvec3 c = RGB(110, 110, 98) * (.8 + .8 * b * b);\n    if (uv.y < 1./4.)\n        c *= .5;\n    c *= 1.\n        - .4 * ls(.4, .0, b)\n        + .5 * ls(.02, .0, uv.y)\n        + .2 * tri(.24, .01, uv.y)\n        ;\n\treturn c;\n}\n\n// gothic_floor/xstairtop4bbrn\nTEX(gxstrtop4bbrn) {\n\tfloat\n        e = step(.25, uv.y),\n        b = FBMT(uv, vec2(40, 5), .7 + .2 * e, 2. + e, 4);\n\tvec3 c = (RGB(96, 64, 44) - e * RGB(8, 4, 4)) * mix(.5, 1.5, b);\n\tc *= 1.\n        + 1.5 * ls(.03, .01, uv.y) // highlight\n        - .7 * sqr(tri(.24, .25, .35, uv.y)) // shadow\n\t;\n\treturn c;\n}\n\n// gothic_floor/xstepborder3brn\nTEX(gxstpbrdr3brn) {\n\tfloat b = FBMT(uv, vec2(40, 5), .7, 2., 4);\n\tvec3 c = RGB(88, 60, 40) * mix(.5, 1.5, b);\n\tc *= 1.\n        + 3. * sqr(ls(.9, .99, uv.y)) // strong top highlight\n        + .2 * tri(.04, .02, uv.y) // subtle bottom highlight\n        - .3 * ls(.03, .0, uv.y) // bottom shadow\n\t;\n\treturn c;\n}\n\n// gothic_ceiling/woodceiling1a\nTEX(gwdclg1a) {\n    vec2 p = uv, q;\n    p.y *= 22.;\n    q = fract(p);\n    float\n        b = FBMT(uv, vec2(3, 23), 1., 2., 6),\n        n = FBMT(uv, vec2(3, 33), .7, 3., 4),\n        id = H(p.y - q.y);\n    vec3 c = RGB(92, 67, 53) * (.8 + .8 * b * b);\n    c *= 1. - sqr(ls(.1, .0, min(q.y, 1. - q.y))) * b;\n    c *= 1. - .2 * smoothstep(.3, .7, n);\n    //c *= 1. - .5 * sqr(tri(.5, .01, fract(p.x + id))) * b;\n    c *= .8 + .3 * b * id;\n    return c;\n}\n\n// gothic_ceiling/woodceiling1b_dark\nTEX(gwdclg1bd) {\n\tfloat\n        b = FBMT(uv, vec2(13), .9, 3., 4),\n        x = uv.x * 16./3.;\n    vec3 c = gwdclg1a(uv) * ls(.15, .21, uv.x);\n    if (x < 1.)\n        c = RGB(59, 48, 49) * (.7 + .6 * b);\n    c *= 1. + .5 * tri(.05, .05, ridged(x));\n    return add_rivet(c, vec2(abs(uv.x - 3./32.) - .07, mod(uv.y, .1) - .05), .004);\n}\n\n// base_light/baslt4_1_4k\nTEXA(blt414k) {\n\tfloat b = FBMT(uv, vec2(1, 5), .4, 3., 4); // base FBM\n\tvec3 c = mix(RGB(56, 49, 43), RGB(142, 136, 136), b); // base color\n\tuv = .5 - abs(uv - .5); // mirror horizontally and vertically\n\tuv.y *= 4.; // aspect ratio correction\n\tfloat\n\t\ta = tri(.0, .1, length(uv - seg(uv, vec2(.41, .5), vec2(.42, 3.5)))), // neon light mask\n\t\td = mn(uv), // edge distance\n\t\tl = 1. - .7 * max(0., 1. - d / .15); // darken edges\n\tl *= 1. - .8 * ls(.24, .31, min(d, uv.y - .1)); // darken inner area around neons\n\tuv.y = mod(uv.y, .875); // repeat vertically\n\tc = add_rivet(c, uv - vec2(.17, .25), .04, .2, .5) // knobs\n\t\t+ RGB(80, 80, 20) * a // yellow neon lights\n\t\t;\n\treturn vec4(c * mix(l, 2.7, a), a);\n}\n\n// base_light/light5_5k\nTEXA(light5) {\n\tfloat b = FBMT(uv, vec2(1, 5), .4, 3., 4);\n\tvec3 c = mix(RGB(56, 49, 43), RGB(142, 136, 136), b);\n\tuv = .5 - abs(uv - .5);\n\tuv.y *= 8.;\n\tfloat\n\t\td = length(uv - seg(uv, vec2(.27, .3), vec2(.27, 7.7))),\n\t\ta = tri(.0, .17, d),\n\t\tl = 1. - .5 * tri(.17, .07, d);\n\tc += RGB(80, 80, 20) * a;\n\treturn vec4(c * mix(l, 2.7, a), a);\n}\n\n// base_light/lt2_2000\n// base_light/lt2_8000\nTEXA(lt2) {\n    float b = FBMT(uv, vec2(1), .4, 3., 4);\n    vec3 c = mix(RGB(56, 49, 43), RGB(142, 136, 136), b);\n    vec2 p = abs(uv - .5);\n    float r = length(p);\n    float a = ls(.37, .33, r) * (.5 + 2. * b);\n    float l = 1. + .0 * ls(.08, .03, abs(r - .41));\n    l = mix(l, 7., ls(.44, .1 * b, r));\n    l *= 1. - .5 * sqr(tri(.46, .04, r));\n    l *= 1. - .4 * sqr(tri(.36, .04, r));\n    return vec4(c * l, a);\n}\n\n// gothic_light/pentagram_light1_1k\nTEXA(gpntgmlt1k) {\n    float\n        b = FBMT(uv, vec2(5), .9, 3., 4),\n        d = smin(pentagram(uv-=.5, .35), abs(circ(uv, .4)), .02),\n        a = pow(msk(d - .02, .15), 8.),\n        o = min(max(box(uv, vec2(.46)), -circ(uv, .51)), abs(circ(uv, .44)));\n    vec3 c = RGB(76, 62, 47) * (.8 + .8 * b * b);\n    c *= 1. + (b + .5) * msk(abs(o) - .01, .01);\n    c *= 1. - ls(.1, .05, d) * msk(circ(uv, .4));\n    return vec4(c + 1.*vec3(1, 1, .3) * a, a);\n}\n\nfloat mtltech(vec2 uv) {\n    float b = NT(uv, vec2(64)), f = 0., d = 1e6;\n    for (/**/; f < 11.; ++f)\n        d = smin(d, abs(length(.5 - abs(uv - R2(f))) - mix(.36, .29, R1(f + .7))) - mix(.015, .03, b), .01);\n    return d * 1e2;\n}\n\nvec3 mtltech_d(vec2 uv) {\n    vec3 s, p;\n    for (int i=0; i<3; ++i) {\n        p = vec3(uv, 0);\n        p[i] += 1e-4;\n        s[i] = mtltech(p.xy);\n    }\n    return vec3(normalize(s.xy - s.z), s.z);\n}\n\n\n// base_wall/metalfloor_wall_10\nTEX(mtlfw10) {\n\tfloat b = FBMT(uv, vec2(5), .9, 3., 4);\n\tvec3 c = mix(RGB(44, 14, 16), RGB(93, 63, 63), b * b);\n\treturn c;\n}\n\n// base_wall/metaltech12final\nTEX(mtlt12f) {\n\tfloat b = FBMT(uv, vec2(5), .9, 3., 4), l;\n\tvec3 c = mix(RGB(51, 46, 43), RGB(165, 147, 143), b * b), d = mtltech_d(uv);\n\tl = 1. - .5 * (d.y - d.x) * tri(.5, 3., d.z) * ls(1., .0, d.z);\n\treturn c * l * .8;\n}\n\n// base_wall/metaltech06final\nTEX(mtlt6f) {\n    float b = FBMT(uv, vec2(3), 1.1, 3., 4), l;\n    vec3 c = mix(RGB(51, 46, 43), RGB(165, 147, 143), b * b);\n    vec3 d = mtltech_d(uv);\n    //d *= 1e1;\n    //d /= 2.;\n    l = 1. - .5 * (d.y - d.x) * tri(.5, 3., d.z) * ls(1., .0, d.z);\n    l -= .5 * tri(-1.5, 1.5, d.z);\n    return c * l;\n    //!return c * (.9 - .3 * (n.y - n.x) * tri(.5, .5, d) - .5 * b * (n.y - n.x));\n\t//return c * (.9 - 3. * (n.y - n.x) * tri(-.5, .5, d) + 2. * b * (n.y - n.x) * tri(1., .5, d));\n/*    l = 1. + tri(.5, 1., d) * max(n.x, 0.) * b;\n    l -= b * b * 8. * tri(-4., 4., d * d * sign(d));\n    return c * l;\n*/\n}\n\n// xy = tile id, z = edge\nvec3 mtlfw15_d(vec2 uv) {\n    float e = 2e-3, a = 0.;\n    vec2 g = vec2(6), r = voro1(uv, g).xy;\n    for (int i=0; i<9; ++i)\n        a += sum(abs(voro1(vec2(i % 3 - 1, i / 3 - 1) * e + uv, g).xy - r));\n    return vec3(uv + r.xy / g, a);\n}\n\n// base_wall/metalfloor_wall_15\nTEX(mtlfw15) {\n    float b = FBMT(uv, vec2(3), .9, 3., 4);\n    vec3 c = mix(RGB(80, 70, 72), RGB(128, 120, 120), b * b);\n    vec3 v = mtlfw15_d(uv);\n    c *= mix(.95, 1.1, NT(v.xy, vec2(6)));\n    c = mix(c, RGB(168, 128, 120), ls(.5, 1., v.z) * b * .7);\n\treturn c;\n}\n\n// base_wall/metalfloor_wall_15ow (texture)\nTEXA(mtlfw15ow) {\n    float b = FBMT(uv, vec2(3), .9, 3., 4);\n    vec3 c = mix(RGB(80, 70, 72), RGB(128, 120, 120), b * b);\n    vec3 v = mtlfw15_d(uv);\n    float m = ls(.5, 1., v.z);\n    float r = ls(.4, .2, length(.5 - fract(v.xy)));\n    c *= mix(.95, 1.1, NT(v.xy, vec2(6))) - 2. * r * b * b;\n    c = mix(c, RGB(168, 128, 120), m * b * .7);\n\treturn vec4(c, m * r);\n}\n\n// Window icon\nTEXA(icon) {\n    uv -= vec2(.48, .5);\n    float\n        d = icon_sdf(uv, 0.),\n        b = length(uv) - .47;\n    vec3 c = 1. - vec3(.5, 1, 1) * msk(max(.007 - d, b + .04));\n    return vec4(c, 1) * msk(b);\n}\n\n// sfx/logo512\nTEX(bglogo) {\n    uv -= .5;\n\n    float\n\t\tx = abs(uv.x),\n\t\tb = FBMT(uv, vec2(31, 5), .7, 2., 3), // base FBM - mostly vertical noise\n\t\tt = .8 + .8 * b * b, // intensity variation (remapped FBM)\n\t\td = icon_sdf(uv, 1.), // logo SDF\n\t\te = icon_sdf(uv + vec2(0, .002), 1.), // offset logo SDF, for lighting\n\t\tl = (e - d) * 5e2 + .5 // lighting\n\t\t;\n\tvec3 c = vec3(.3 * t, 0, 0) * msk(d, .004); // base color\n\tc *= 1.\n\t\t- sqr(ls(.0, .3, x)) // horizontal gradient\n\t\t- .5 * ls(.1, .3, abs(uv.y - .1)) // vertical gradient\n\t\t;\n\tc +=\n\t\t+ t * .2 * tri(.0, .01 - .01 * x, d) * tri(.1, .2, uv.y) * ls(.3, .2, x) * l // top light\n\t\t+ t * .5 * ls(.004, .0, d) * ls(.07, .1, uv.y) * tri(.23, .1, x) * vec3(.9, .9, 1) // back light\n\t\t+ t * .4 * tri(.005, .005, d) * ls(.2, -.1, uv.y) * ls(.3, .2, x) * sat(-l) // bottom light\n\t\t;\n        \n    return c;\n}\n\nfloat banner_fold(vec2 uv, float s, float i, float amp) {\n    i = (uv.y - sqr(abs(uv.x - .5)) * amp) * s - i;\n    return 2. * tri(.5, .4, i) * (fract(i) - .5);\n}\n\n// base_wall/protobanner (texture)\nTEXA(bwprtbnr) {\n\tfloat\n\t\tb = FBMT(uv, vec2(5, 9), .9, 3., 4), // base FBM\n\t\tt = .8 + .8 * b * b, // base texture intensity (remapped FBM)\n        n = FBMT(uv, vec2(5, 9), .9, 3., 2), // noise (for ragged edges)\n        x = abs(uv.x - .5), // distance from center\n        d, // sdf\n        f;\n\tvec3 c = RGB(77, 60, 44) * t; // base color\n    vec2 p = uv * vec2(1, 2) - vec2(.5, .7);\n    c *= 1. - .55 * msk(exclude(circ(p, .3), icon_sdf(rot(45.) * p * .8, 0.) - .01)); // logo\n    c *= 1.\n        + sqr(ls(.6, .9, b)) // noisy highlights\n        + tri(.2, .5, uv.y) * tri(.2, .3, x) * banner_fold(uv, 4., .2, 4.) // bottom fold\n        ;\n    // TODO: eliminate loop\n    for (f = 6.; f < 9.; ++f)\n       \tc *= 1. + tri(.8, .5, uv.y) * tri(.2, .3, x) * banner_fold(uv, 12., f, 1.); // top fold\n    d = uv.y - .81 - sqr(sat(x * 4.)) * .09;\n    c = mix(c, RGB(82, 66, 60) * t, ls(.0, .01, d));\n    c *= 1.\n        - .5 * (tri(.01, .02, d)) // support shadow\n        + .5 * (tri(.02, .01, d)) // support highlight\n        ;\n    d = .15 * (1. - uv.y); // corner rounding amount; it should be 0.3, but the lightmapper doesn't do alpha testing\n    d = box(uv - .5, vec2(.49) - d) + n * .1 * sqrt(1. - uv.y) - d; // box with y-varying raggedness\n    return vec4(c * sqr(msk(d + .01, .05)), msk(d));\n}\n\n// QUAKE III sdf\nfloat quakeiii_sdf(vec2 uv) {\n\tuv *= vec2(256, 64);\n\t// Q\n\tfloat d = circ(uv - vec2(81, 30), 11.);\n\td = max(d, uv.x - 80.);\n\td = max(d, -circ(uv - vec2(84, 26), 9.));\n\td = min(d, box(uv - vec2(73, 37), vec2(4, 9)) - 4.);\n\td = max(d, -box(uv - vec2(73, 37), vec2(0, 7)) + 1.);\n\t// U\n\td = min(d, box(uv - vec2(91.5, 47), vec2(4, 19)) - 4.);\n\td = max(d, -box(uv - vec2(91.5, 47), vec2(0, 17.5)) + 1.);\n\t// A\n\td = min(d, box1(mirr(uv, 111.) - vec2(105. + ls(23., 50., uv.y) * 3., 43), vec2(3.5, 19)));\n\td = min(d, box1(uv - vec2(111, 32), vec2(6, 3)));\n\t// K\n\td = min(d, box1(uv - vec2(126, 37), vec2(3, 13)));\n\td = min(d, box1(uv - vec2(125.5 + ls(23., 50., uv.y) * 10., 44), vec2(3.5, 6)));\n\td = min(d, box1(uv - vec2(136.5 - ls(23., 50., uv.y) * 9., 32), vec2(3.5, 8)));\n\t// E\n\td = min(d, box1(uv - vec2(148.5, 37), vec2(7, 13)));\n\td = max(d, -box1(uv - vec2(155, 33), vec2(6, 3)));\n\td = max(d, -box1(uv - vec2(155, 43), vec2(6, 2)));\n\t// III\n\td = min(d, box1(uv - vec2(168, 37), vec2(3.5, 13)));\n\td = min(d, box1(uv - vec2(178, 37), vec2(3.5, 13)));\n\td = min(d, box1(uv - vec2(188, 37), vec2(3.5, 13)));\n\n\treturn max(d, uv.y - 50.);\n}\n\n// ARENA sdf\n// s = scale\nfloat arena_sdf(vec2 uv, float s) {\n\tuv *= vec2(256. * s, 64);\n\tfloat d = 1e6;\n\t// R\n\tuv.x -= s * 106.;\n\td = min(d, max(-uv.x - 1., onion(box(uv - vec2(-.5, 19.25), vec2(2, .5)) - .75, .5)));\n\td = min(d, box1(uv - vec2(1. + (18. - uv.y) * .5, 16.5), vec2(.5, 1.5)));\n\td = min(d, box1(uv - vec2(-1, 18), vec2(.5, 3)));\n\t// E\n\tuv.x -= s * 24.;\n\td = min(d, box1(uv - vec2(0, 18), vec2(2, 3)));\n\td = max(d, -box1(uv - vec2(1.5, 19.5), vec2(2.5, 1)));\n\td = max(d, -box1(uv - vec2(1.5, 17), vec2(2.5, 1)));\n\t// N\n\tuv.x -= s * 24.;\n\td = min(d, box1(uv - vec2(-2, 18), vec2(.5, 3)));\n\td = min(d, box1(uv - vec2(2, 18), vec2(.5, 3)));\n\td = min(d, box1(uv - vec2((18. - uv.y) * .5, 18), vec2(.7, 3)));\n\t// A\n\tuv.x = mirr(uv.x + s * 68., s * 46.);\n\td = min(d, box1(mirr(uv, 0.) - vec2((uv.y - 21.) * .33, 18), vec2(.5, 3)));\n\td = min(d, box1(uv - vec2(0, 16.5), vec2(1, .25)));\n\treturn d;\n}\n\n// base_wall/main_q3abanner\nTEXA(q3bnr) {\n    return vec4(msk(min(quakeiii_sdf(uv), arena_sdf(uv, 1.)), .8), 0, 0, H(uv * 511.));\n}\n\n// main menu banner (texture)\nTEXA(menubnr) {\n    return vec4(sat(1. - 1.4 * abs(quakeiii_sdf(uv))) * (NT(uv, vec2(256, 64)) * .7 + .3), 0, 0, sat(3. - 6. * arena_sdf(uv, .7)));\n}\n\n// main menu banner (menu shader)\nvoid menubnr_m() {\n    vec2 uv = UV - .5;\n\tuv.y = (uv.y - .16) * 7.;\n    FCol = mx(abs(uv + vec2(0, .23)) / vec2(.55, .2)) > .4 ?\n            vec4(0) :\n            menubnr(uv + .51).w\n        \t* FBMT(uv - vec2(.2 * N(Time.x), Time.x), vec2(7, 3), .7, 2., 4)\n        \t* vec4(2, 1, .3, 0);\n    if (mx(abs(uv - vec2(0, .15)) / vec2(.77, 1)) > .4)\n        return;\n\n    float\n        n = H(uv * 133.7 + Time.x),\n        k = 1./48.,\n        s = pow(1.2, k),\n        i = n * k\n\t;\n    vec2 p;\n    uv /= mix(1., s, n);\n    for (; i < 1.; i += k) {\n\t\tuv.x += (N(.37 * Time.x) - .5) * k / 48.;\n\t\tuv.y += (N(.21 * Time.x) - .5) * k / 32.;\n        p = uv /= s;\n        p.y -= i * .15;\n        p.x *= 1. + p.y * .15;\n        vec4 c = menubnr(p + .5);\n\t\tFCol += c.x * (1. - i) * k * vec4(32, 16, 4, 0);\n\t}\n}\n\n// skies/tim_hell\nvoid timhel() {\n\tvec2 uv = UV;\n\tfloat b = ls(.2, 1., FBMT(uv - Time.x * vec2(.1, .2), vec2(5), .5, 2., 6));\n\tuv.y *= 1.5;\n\tfloat s = ls(.3, 1., FBMT(uv - Time.x * vec2(.1, .18), vec2(5), .6, 2., 6));\n\tFCol = vec4(vec3(b, 0, 0) + RGB(80, 30, 8) * s * s * 2., 1);\n}\n\n// liquids/lavahellflat_400\n// liquids/lavahell_750\nvoid lava() {\n\tvec2 uv = wavy(UV / 8., Time.x * .5, 2., .05);\n\tfloat b = FBMT(uv, vec2(7), .9, 2., 4);\n\tvec3 c = RGB(91, 22, 14) * (.2 + 1.6 * b);\n\tc = mix(c, RGB(144, 44, 0), tri(.6, .2, FBMT(uv, vec2(3), .7, 3., 4)));\n\tc = mix(c, RGB(244, 144, 66) * b * 2., sqr(tri(.55, .25, FBMT(uv, vec2(11), .5, 2., 4))));\n\tFCol = vec4(c * sat(mx(Light())), 1);\n}\n\n// Single-speed flame layer (s = speed)\nfloat simple_flame(vec2 uv, float s) {\n\tvec2 p = uv;\n\tp.y += p.y - Time.x * s;\n\tuv.x += (N(p.y * 5.) - .5) * 1.5 * sqr(uv.y);\n\tfloat\n\t\tn = FBMT(wavy(p, 7., .02), vec2(9), .7, 2., 4),\n\t\th = ls(.9, .03, uv.y),\n\t\tb = box(uv - vec2(.5, .15), vec2(0, .3));\n\treturn sqr(msk(b + n * sqr(1.2 - h) - .13, .15));\n}\n\nvoid complex_flame(float s) {\n\tvec2 uv = fract(UV);\n\tFCol = (simple_flame(uv, s * .6) + simple_flame(uv, s)) * vec4(2.5, 1, .35, 0);\n}\n\nvoid flame() {\n    complex_flame(1.);\n}\n\n// models/mapobjects/lamps/flare03\nvoid flare03() {\n\tFCol = vec4(2, 2, 2, 0) * pow(flare(UV, vec2(.5), 1., .6), 2.);}\n\n// models/mapobjects/lamps/bot_flare\nvoid botflare() {\n    vec2 uv = (UV - .5) * rot(20. * Time.x);\n    float\n        b = NT(uv, vec2(256)),\n        k = 2.2 - length(uv) * 3.;\n\tFCol = vec4(k, k, 2, 0) * pow(flare(uv, vec2(0), 1.5, .4) + b * .01, 2.2);\n}\n\n// models/mapobjects/teleporter/energy.tga\nvoid tlpnrg() {\n    NO_COPY_PASTE\n    vec2 uv = fract(UV) * vec2(2, 3);\n    NO_COPY_PASTE\n\n\tvec2 p = uv;\n    p.x = fract(uv.x - Time.x * 3.);\n    float f =\n        (wrapped_flare(p, vec2(0, .3), 1., .6) + flare(p, vec2(.5, .4), 2., .66))\n    \t* ls(.1, .2, uv.y) * (.5 + abs(fract(Time.x * 5.3) - .5))\n\t;\n\tFCol = f * f * vec4(.9, .77, .77, 0);\n\n    p.x = fract(uv.x * .5 - Time.x * 4.4);\n    p.y = mod(uv.y * .5 - Time.x * 2.6, 3.);\n\tf = wrapped_flare(p, vec2(0, .5), 1.1, .5) + flare(p, vec2(.5, .6), 1., .6);\n\tFCol += f * f * vec4(.9, .77, .77, 0);\n\n    p.x = fract(uv.x * .5 + Time.x * 2.);\n    p.y = mod(uv.y * .5 - Time.x * 2., 3.);\n\tf = wrapped_flare(p, vec2(0, .5), 1.1, .5) + flare(p, vec2(.5, .6), 1., .6);\n\tFCol += f * f * vec4(.9, .77, .77, 0);\n\n    //f += .5 * smoothen(tri(1., 1., .01 * sin(uv.x * TAU) + mod(uv.y - Time.x * 5.2, 4.)));\n    //f += .3 * smoothen(tri(.7, .7, .01 * sin(uv.x * TAU) + mod(uv.y + .2 - Time.x * 2.3, 4.)));\n}\n\n// models/mapobjects/teleporter/transparency.tga\nTEXA(tlptrns) {\n\tfloat b = FBMT(wavy(uv, 5., .03), vec2(7), .5, 3., 2);\n\treturn\n\t\t(b * 1.4 + .3) * vec4(1.2, .54, .06, 0)\n\t\t+ tri(.7, .2, b) * .5 * vec4(1, 1, 1, 0)\n\t;\n}\n\nvoid poly(vec2 uv, inout float d, inout vec2 p, vec2 q, float s) {\n    d = -smin(-d, dot(uv - p, rot(90.) * normalize(p - q)), s);\n    p = q;\n}\n\n// models/mapobjects/lamps/bot_wing.tga (texture)\nTEXA(botwing) {\n\tuv.y *= .5; // correct aspect ratio\n\tfloat\n\t\tb = FBMT(uv, vec2(7), .7, 2., 4),\n\t\tt = .8 + .8 * b * b,\n\t\td = -1e6,\n\t\tm, l, v, k;\n\n\tvec2 p = vec2(.19, .42); // top-left (highest point)\n\tpoly(uv, d, p, vec2(.55, .42), .02);\n\tpoly(uv, d, p, vec2(.74, .34), .03);\n\tpoly(uv, d, p, vec2(.74, .29), .02);\n\tpoly(uv, d, p, vec2(.63, .1), .01);\n\tpoly(uv, d, p, vec2(.31, .04), .06);\n\tpoly(uv, d, p, vec2(.12, .1), .01);\n\tpoly(uv, d, p, vec2(.02, .29), .01);\n\tpoly(uv, d, p, vec2(.19, .42), .03); // close loop\n\n\td = min(d, box(p = rot(22.5) * (uv - vec2(.7, .22)), vec2(.17, .065))); // connecting box\n\td = max(d, -box(p - vec2(.04, .0), vec2(.03, .01))); // cut off box interior\n\td = max(d, -max(d + .07, box(uv - vec2(.4 - uv.y * .5, .23), vec2(.033, .2)))); // left slit\n\td = max(d, -max(d + .07, box(uv - vec2(.52 - uv.y * .5, .23), vec2(.033, .2)))); // middle slit\n\td = max(d, -max(d + .07, box(uv - vec2(.65 - uv.y * .5, .23), vec2(.033, .2)))); // right slit\n\td = min(d, k = circ(uv - vec2(.86, .18), .09)); // disk\n\n\tl = grad(d).y; // lighting [-1..1]\n\n\tvec3 c = RGB(44, 33, 30) * t * t * t; // base color\n\tc *= 1.\n\t\t+ 2.5 * sqr(ls(.1, .0, length(uv - vec2(.18, .4)))) // brighten top-left corner\n\t\t+ 2.5 * sqr(ls(.2, .0, length(uv - vec2(.64, .4)))) // brighten top-right corner\n\t;\n\n\tc *= 1.\n\t\t+ tri(-.01, .007, d) * (l + .5) // bevel lighting\n\t\t+ 6. * pow(ls(.15, .01, length(p = (uv - vec2(.5, .26)) * rot(7.) * vec2(.14, 1))), 6.) * sqr(ls(.04, .02, p.x)) // mid specular\n\t;\n\n\tl = grad(k += .05).y; // inner disk lighting\n\tc *= 1.\n\t\t+ 1.5 * tri(.0, .01, k) * sqr(abs(l + .3)) // edge highlight\n\t\t- .9 * tri(.01, .01, k) * sat(.3 - l) // edge shadow down below\n\t\t+ .7 * tri(-.03, .01, k) * l // axle lighting/shadow\n\t\t+ 2.5 * ls(-.03, -.04, k) // bright axle interior\n\t\t//-.9 * ls(-.002, .01, d) // darken edges\n\t;\n\n\treturn msk(d) * vec4(c, 1);\n}\n\n// models/mapobjects/lamps/bot_lamp.tga (texture)\nTEXA(botlamp) {\n\t//uv.y *= 2.; // correct aspect ratio\n\n\tfloat\n\t\tb = FBMT(uv, vec2(7), .7, 2., 4),\n\t\tt = .7 + 1.2 * b * b,\n\t\td, l\n\t;\n\tuv.x = abs(uv.x - .5); // mirror\n\tvec3 c = RGB(44, 33, 30) * t; // base color\n\tvec2 p = uv - vec2(.17, .37);\n\n\tl = grad(d = length(p * vec2(.85, 1))).y;\n\tc *= 1.\n\t\t+ 4. * pow(ls(.5, .05, length(uv - vec2(0, .6))), 5.) // large specular highlight\n\t\t+ tri(.0, .075, .1, d) * (.2 - l) // eye socket edge\n\t;\n\n\t// pupils\n\tl = grad(d = length(p += vec2(.02, 0))).y;\n\tc *= 1.\n\t\t- .5 * sqr(tri(.03, .02, d)) // darken pupil exterior\n\t\t- .9 * sqr(tri(.04, .09, d)) * tri(.1, .2, p.y) // darken eye socket\n\t\t- ls(.02, .01, d) * (.2 + .7 * ls(.0, .01, p.y)) // darken interior\n\t\t+ tri(.02, .01, d) * (.4 + tri(.0, .015, p.x)) // edge highlight\n\t;\n\n\t// forehead\n\td = box(p = uv - vec2(0, .5), vec2(.08 - .7 * p.y, .05));\n\tc *= 1.\n\t\t+ .5 * tri(.05, .02, d) * ls(.0, .1, p.y) // edge highlight\n\t\t- .9 * tri(.05, .03, -.1, d) * ls(-.1, .05, p.y) // inner shadow\n\t;\n\n\td = box(p = uv - vec2(0, .4), vec2(.02, .03));\n\tc *= 1.\n\t\t+ .7 * tri(.05, .02, d) * ls(.0, .1, p.y) // edge highlight\n\t\t- .7 * tri(.05, .03, -.2, d) * ls(-.1, .05, p.y) // inner shadow\n\t;\n\n\td = box(p = uv - vec2(0, .34), vec2(.025 - .5 * p.y, .007));\n\tc *= 1.\n\t\t+ .7 * tri(.02, .02, d) * ls(-.05, .05, p.y) // edge highlight\n\t\t- .7 * tri(.02, .0, -.1, d) * ls(-.05, .02, p.y) // inner shadow\n\t;\n\n\t// nasal cavity\n\td = length(p = (uv - vec2(0, .22)) * vec2(1.4, 1)) - .1;\n\td = max(d, length(uv - vec2(.1, .25)) - .15);\n\tc *= 1.\n\t\t+ .4 * tri(.0, .03 + p.y * .05, d) // edge highlight\n\t\t- .9 * ls(.0, -.08, d) // darken nasal cavity interior\n\t;\n\n    // ridge\n    d = seg(wavy(uv, 5., .05), vec2(.09, .63), vec2(.3, .9), .0);\n    c *= 1.\n        + ls(.03, .0, d) * (.2 + .3 * tri(.6, .05, uv.y))\n    ;\n\n    //return vec4(c, b);\n    return vec4(c, 1);\n}\n\n// models/weapons2/plasma/plasma_glo.tga\nTEX(plasma_glo) {\n    float\n        b = FBMT(uv, vec2(7), .5, 2., 4),\n        t = .8 + .8 * b * b,\n        n = NT(uv, vec2(2))\n\t;\n    return\n        mix(RGB(5, 77, 55), RGB(8, 122, 188), ls(.5, .1, n))\n        * sqr(1. - n) * t * 2. *\n        (1. + tri(.2, .05, b * b));\n}\n\n// models/weapons2/rocketl/rocketl.tga\nTEX(rocketl) {\n    uv = wavy(uv, 5., .02);\n\tfloat\n\t\tb = FBMT(uv, vec2(6), .8, 2., 4), // base FBM, tileable\n        m = FBMT(uv, vec2(2), .6, 2., 4),\n\t\tt = .8 + .6 * b * b // texture intensity\n\t\t;\n\tvec3 c = mix(RGB(36, 33, 30), RGB(168, 177, 168), .3 + .7 * m) * t;\n    c *= 1.\n        + .2 * ls(.4, .6, m)\n        - .2 * tri(.3, .1, m)\n        ;\n    return c;\n}\n\n// models/powerups/armor/energy_red1.tga\nTEX(armornrg) {\n    const vec3 CLR = vec3(1, 0, 0);\n    return tri(.5 + (FBMT(uv.x + H(Time.x * 133.7), 13., .6, 2., 4) - .5) * .1, .03, uv.y) * CLR;\n}\n\n// models/mapobjects/lamps/bot_flare2.tga\nTEXA(botflare2) {\n    float\n        b = FBMT(uv, vec2(3, 4), .5, 2., 4),\n        d;\n    uv.x = abs(uv.x - .5) * 1.7;\n    d = lsq(uv - vec2(0, 1)) + b * .3;\n    return vec4(.44, .3, .3, 0) / (333. * d * d * d + .1) * ls(.5, .4, d);\n}\n\n// models/mapobjects/gratelamp/gratetorch2b.tga\nTEXA(gr8torch2b) {\n\tuv.y *= 2.;\n\tfloat\n\t\tb = FBMT(uv, vec2(5), .9, 2., 4), // base FBM, tileable\n        k = .5 + b, // remapped b with 1.0 mean\n\t\tt = .8 + b * .4, // texture intensity\n\t\td = uv.y - 1.05; // distance field\n\tvec3 c = RGB(55, 44, 37) * t; // base color\n\tvec2 p = uv;\n\n\td = smin(d, box((uv - vec2(.5, 1.5)) * rot(45.), vec2(.2)) - .1, .3); // smin with rotated rounded square\n    d = max(d, .03 - p.y); // bilinear hack: cut off bottom\n\n\tc = mix(c, add_rivet(c, uv - vec2(.5, 1.5), .1), 8. * b); // large knob on rotated square\n\n\tp.x = min(p.x, 1. - p.x); // mirror around center\n\tif (p.y > .5)\n\t\tp.y -= .5; // repeat once vertically\n\tc = mix(c, add_rivet(c, p - vec2(.22, .31), .04), 2. * t); // smaller knobs\n\n\tc *= 1.\n        + sqr(ls(.5, 1., b)) // ligher dirt\n\t\t+ grad(d).y * tri(.0, .05, d) * (1. + 11. * ls(1.5, 2., uv.y)) * b // edge lighting\n\t\t+ k * tri(.93, .05, uv.y)\n\t\t+ k * tri(.4, .05, uv.y)\n\t\t+ k * tri(.1, .05, uv.y)\n\t\t- .5 * tri(.97, .05, uv.y)\n\t\t- .5 * sqr(tri(.7, .05, uv.y))\n\t\t- .5 * sqr(tri(.2, .05, uv.y))\n\t\t- .5 * tri(.66, .1, uv.y)\n\t\t- .5 * tri(.45, .03, uv.y)\n\t\t- .5 * tri(.15, .1, uv.y)\n\t\t- tri(.01, .03, uv.y)\n\t\t;\n\treturn vec4(c, msk(d, .03));\n}\n\n// models/mapobjects/wallhead/lion.tga\nTEX(lion) {\n\tvec2 p = uv, q;\n\tp.x = abs(p.x - .5); // mirror\n\n\tfloat\n\t\tb = FBMT(uv, vec2(7), .9, 3., 4), // base FBM\n\t\tt = .5 + b, // base texture intensity\n\t\tv = msk(-elips(p - vec2(.1, .57), vec2(.18, .2)), 1.), // hair mask\n\t\td, r, n, i, f, m,\n\t\tj = 0.\n\t;\n\n\tvec3 c = RGB(66, 55, 55) * t; // base color\n\n\t// hair layers\n\tfor (; j < 16.; ++j) {\n\t\tvec2 o = (R2(j) - .5) * vec2(.15, .1); // random offset\n\t\tq = p - o;\n\t\tq.x += .1 * sin(11. * q.y) * sqr(1. - q.y); // hair waviness\n\t\tr = elips(q - vec2(.1, .4), vec2(.22, .3));\n\t\tn = FBMT(wavy(uv + o * .5, .7, .01), vec2(5), .3, 2., 4); // smooth noise\n\t\td = r * .5 + n; // distorted distance\n\t\ti = floor(d); // strand id\n\t\tf = abs(fract(d) - .5); // location within strand\n\t\tm = v * sat(d) * step(H(i + j * PHI) * .9 + .1, .5); // strand mask\n\t\tc *= 1.\n\t\t\t+ .25 * m * ls(.2, .0, f) // highlight\n\t\t\t- .25 * m * tri(.3, .2, f) // shadow\n\t\t;\n\t}\n\n\t// eyes + eyebrows + cheekbones\n\tr = length(q = p - vec2(.13, .595));\n\tq *= rot(11.); // eye/eyebrow angle\n\tq.y = abs(q.y) + .025;\n\tm = ls(.0, -.2, d = elips(q, vec2(.06, .039)) * .07); // eye interior mask\n\tc *= 1.\n\t\t+ .4 * ls(.05, .0, length((p - vec2(.21, .53)) * vec2(.8, 1))) // cheekbone highlight\n\t\t- .4 * ls(.07, .0, length((p - vec2(.19, .42)))) // cheekbone shadow\n\t\t- .5 * tri(3.5, .9, d) * tri(.7, .05, p.y) * tri(.07, .15, p.x) // frown\n\t\t+ .9 * tri(1.9, .9, d) * ls(.15, .0, length(p - vec2(.06, .66))) // eyebrow highlight\n\t\t- .7 * tri(.4, .9, d) * ls(.15, .0, length(p - vec2(.09, .64))) // eyebrow shadow\n\t\t- .9 * tri(.05, .02, length(p - vec2(.05, .64))) * sat(1. - length(p - vec2(0, .6)) * 15.)\n\t\t+ .9 * sqr(ls(.03, .005, r)) * m // brighten eye interior\n\t\t- .4 * sqr(tri(.0, .5, d)) // darken contour\n\t\t- .6 * ls(.0, .05, r) * m // darken interior\n\t\t- 1.5 * ls(.5, .2, r * 50.) // darken pupil\n\t;\n\n\t// nose\n\td = length((p - vec2(0, .51)) * vec2(1.5, 2.5));\n\tr = length((p - vec2(.05, .46)));\n\tc *= 1.\n\t\t+ .6 * ls(.1, .03, d) * ls(.03, .06, r) // nose specular\n\t\t- .9 * ls(.05, .02, r) * ls(.06, .09, length(p - vec2(.08, .41))) // nostrils\n\t\t- .4 * tri(.1, .05, length((p - vec2(.06, .47)) * vec2(1.3, 1.1))) // snout shadow\n\t;\n\n\t// teeth\n\tq = p - vec2(.09, .29);\n\td = seg(q, vec2(0), vec2(0, .07), .02 * ls(.0, .1, q.y));\n\tc *= 1.\n\t\t+ sqr(ls(.02, .0, d)) // upper canines\n\t;\n\n    return c;\n}\n\n////////////////////////////////////////////////////////////////\n// Item icons\n////////////////////////////////////////////////////////////////\n\n// icons/iconh_yellow.tga\nvoid icon_health() {\n\tvec2 uv = pmod(UV - .5, 4.);\n\tFCol = vec4(1, 1, 0, 1) * msk(min(onion(length(uv) - .4, .04), box(uv, vec2(.25, .06))), .01);\n}\n\n// icons/iconr_shard.tga\nvoid icon_shard() {\n\tFCol = vec4(.4, .7, .3, 1) * msk(dot(abs(UV - .5), vec2(4, 3) / 5.) - .2, .01);\n}\n\n// icons/iconr_yellow.tga\nvoid icon_armor() {\n\tvec2 uv = UV - .5;\n\tuv.x = abs(uv.x);\n\tfloat\n\t\tw = .15 * sqrt(ls(-.32, -.29, uv.y))\n\t\t\t+ .05 * ls(-.3, -.12, uv.y)\n\t\t\t+ .1 * sqrt(ls(-.12, .07, uv.y))\n\t\t\t+ .14 * step(.07, uv.y)\n\t\t\t- .1 * sqr(ls(.07, .31, uv.y)),\n\t\td = exclude(box(uv, vec2(w, .3)), circ(uv - vec2(0, .777), .5))\n\t;\n\tFCol = vec4(1, 1, 0, 1) * msk(d - .01, .01);\n}\n\n// icons/iconw_machinegun.tga\nvoid icon_machinegun() {\n\tvec2 uv = UV;\n\tfloat d = box(uv - vec2(.35, .5), vec2(.1, .4));\n\tuv.y = mod(uv.y - .06, .28) - .16;\n\td = min(d, box(uv - vec2(.51, 0), vec2(.34, .04 * ls(.85, .7, uv.x))));\n\td = exclude(d, box(uv - vec2(.65, 0), vec2(.02, 1)));\n\tFCol = vec4(1, 1, 0, 1) * msk(d, .01);\n}\n\n// icons/iconw_shotgun.tga\nvoid icon_shotgun() {\n\tvec2 uv = UV;\n\tuv.x = mod(uv.x, .33) - .16;\n\tfloat d = box(uv - vec2(0, .52), vec2(.1, .4));\n\td = exclude(d, box(uv - vec2(0, .65), vec2(.05, .23)));\n\td = exclude(d, abs(uv.y - .2) - .02);\n\tFCol = vec4(1, .5, 0, 1) * msk(d, .01);\n}\n\n// icons/iconw_rocket.tga\nvoid icon_rocketl() {\n\tvec2\n\t\tuv = (UV - vec2(.55, .45)) * rot(-45.);\n\tfloat\n\t\td = seg(uv, vec2(-.4, 0), vec2(.2, 0), .1);\n\td = max(d, -.3 - uv.x);\n\tuv.y = abs(uv.y);\n\td = min(d, box(uv + vec2(.37, 0), vec2(.05, .005)));\n\td = min(d, box(uv + vec2(uv.y + .1, -.18), vec2(.1, .05)));\n\tFCol = vec4(1, 0, 0, 1) * msk(d, .01);\n}\n\n// icons/iconw_railgun.tga\nvoid icon_railgun() {\n\tvec2 uv = (UV - .5) * rot(45.);\n\tfloat\n\t\td = box(uv, vec2(.6, .03)),\n\t\tp = uv.x * 12.6 + 1.55,\n\t\th = sin(p) * .15,\n\t\tq = ridged(fract(h))\n\t\t;\n\td = min(d, max(onion(uv.y - h, .05 - .1 * q) * (1. + q + q), abs(uv.x) - .6));\n\tFCol = vec4(0, 1, 0, 1) * msk(d, .01);\n}\n\n// icons/iconw_plasma.tga\nvoid icon_plasma() {\n\tvec2 uv = pmod(UV - .5, 5.);\n\tfloat\n\t\td = length(uv) - .18,\n\t\tr = uv.x - .33,\n\t\th = .04 * tri(.0, .3, r);\n\tuv.x -= .33;\n\tuv *= rot(-15.);\n\td = min(d, box(uv, vec2(.04, 2. * h)));\n\td = min(d, box(uv - vec2(0, h * sign(r)), vec2(.14, h)));\n\tFCol = vec4(.77, 0, 1, 1) * msk(d + .01, .01);\n}\n\n// icons/quad.tga\nvoid icon_quad() {\n\tvec2 uv = UV - .5;\n\tfloat d = icon_sdf(uv + vec2(0, .05), 0.) - .01;\n\td = min(d, box(pmod(uv * rot(45.), 4.) - vec2(.45 , .0), vec2(.11, .02)));\n\tFCol = vec4(0, .88, .95, 1) * msk(d, .01);\n}\n\n// gfx/2d/crosshaira\nvoid crosshaira() {\n    float d = length(UV - .5) * 32.;\n\tFCol = vec4(.5 * ls(.5, .0, abs(d - 15.)) + ls(1., .5, d));\n}\n\n// gfx/2d/crosshairb\nvoid crosshairb() {\n    vec2 uv = abs(UV - .5) * 32.;\n\tFCol = vec4(step(mn(uv), 1.) * step(mx(uv), 6.));\n}\n\n// gfx/2d/crosshairc\nvoid crosshairc() {\n    vec2 uv = abs(UV - .5) * 32.;\n\tFCol = vec4(step(mn(uv), 1.) * step(mx(uv), 6.) * step(3., mx(uv)));\n}\n\n// menu/art/addbotframe.tga\nvoid uiframe() {\n    vec2 uv = UV - .5;\n    float\n        n = NT(uv, vec2(7)) * .8 + .6,\n        d = circ(uv, .48),\n        m = msk(d, .005),\n        i = msk(elips(uv, vec2(.42, .47)), .03);\n    vec3 c = RGB(144, 88, 66) * n;\n    m *= 1. - i * .5;\n    c *= 1. - i;\n    c *= 1.\n        - 2. * sqrt(tri(.0, .45, uv.y))\n        + 4. * (uv.y + .5)\n        + .5 * tri(.0, .01, d) * uv.x\n        ;\n    FCol = vec4(c * m, m);\n}\n\n// menu/art/maps_select.tga\nvoid mapselect() {\n\tfloat d = box((UV - .5) * 256., vec2(98));\n\tFCol = vec4(1, 0, 0, 1) * (.3 * ls(24., .0, d) * step(.0, d)  + step(abs(d + 1.), 1.));\n}\n\n// menu/art/slider2.tga\nvoid slider2() {\n\tfloat d = dot(UV, vec2(-.4, .5)) - .1;\n\tFCol = vec4(msk(d, .02) * ls(-.1, .9, UV.x) * step(mx(abs(UV - .5)), .45));\n}\n\n// menu/art/sliderbutt_1.tga\nvoid sliderbutt1() {\n    float d = circ(UV - .5, .45);\n    FCol = vec4(.7 * ls(.1, -.3, d), 0, 0, msk(d, .02))\n        + vec4(1, 1, 1, 0) * ls(.25, -.25, length(UV - vec2(.25, .75))) * tri(-.1, .1, d) // specular\n    ;\n}\n\n////////////////////////////////////////////////////////////////\n// Preview slideshow ///////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define SLIDES(x)\\\n    x(dmnd2cow_m)\\\n    x(gskull4)\\\n    x(skcpthrt_opaque)\\\n    x(gcntr2trn_m)\\\n    x(bglogo)\\\n    \nconst float NUM_SLIDES =\n    #define COUNT(x) +1.\n    SLIDES(COUNT)\n    #undef COUNT\n    ;\n\n////////////////////////////////////////////////////////////////\n\nvoid giron01nt3_square() {\n    UV.x *= 2.;\n    giron01nt3();\n    UV.x /= 2.;\n}\n\nvoid skcpthrt_opaque() {\n    skcpthrt();\n    FCol.a = 1.;\n}\n\nvoid logo_solo() {\n    bglogo();\n    if (mx(abs(UV - .5)) >= .5)\n        FCol.rgb = vec3(0);\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat slide_alpha(float slide, float t, float current, float next) {\n    if (slide == current) return 1. - t;\n    if (slide == next) return t;\n    return 0.;\n}\n\nvoid slideshow() {\n    float b = FBMT(gl_FragCoord.xy / iResolution.y, vec2(7), .7, 2., 4);\n    float t = dot(gl_FragCoord.xy / iResolution.xy, vec2(1, -.375)) / 8. + .125 + Time.x / 1.5 + b * .125;\n    \n    const bool DUPLICATE_LAST_SLIDE = false;\n    if (DUPLICATE_LAST_SLIDE) {\n        t = mod(t, NUM_SLIDES + 1.);\n        t -= sat(t - NUM_SLIDES + 1.);\n    } else {\n        t = mod(t, NUM_SLIDES);\n    }\n    \n    float current = floor(t);\n    float next = current + 1.;\n    if (next == NUM_SLIDES)\n        next = 0.;\n    t -= current;\n    t = smoothstep(.875, 1., t);\n   \n    vec4 c = vec4(0);\n    float slide_index = 0., alpha = 0.;\n\n    #define DRAW_SLIDE(name)\\\n        alpha = slide_alpha(slide_index++, t, current, next);\\\n        if (alpha > 0.) {\\\n            name();\\\n            c += FCol * alpha;\\\n        }\n    \n    SLIDES(DRAW_SLIDE)\n    \n    #undef DRAW_SLIDE\n    \n    FCol = c;\n}\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define ARG0_(a,b,c)\t\ta\n#define ARG1_(a,b,c)\t\tb\n#define ARG2_(a,b,c)\t\tc\n\n#define ARG0(x)\t\t\t\tARG0_(x) // force x macro evaluation\n#define ARG1(x)\t\t\t\tARG1_(x) // force x macro evaluation\n#define ARG2(x)\t\t\t\tARG2_(x) // force x macro evaluation\n\n#define TEXTURE_NAME\t\tARG0(SHOW_TEXTURE)\n#define TEXTURE_SIZE\t\tvec2(ARG1(SHOW_TEXTURE), ARG2(SHOW_TEXTURE))\n#define ASPECT\t\t\t\t(float(ARG2(SHOW_TEXTURE)) / float(ARG1(SHOW_TEXTURE)))\n\n////////////////////////////////////////////////////////////////\n\nvec3 checker() {\n    ivec2 addr = (ivec2(gl_FragCoord.xy) >> 3) & 1;\n    return (addr.x ^ addr.y) == 1 ? vec3(.5) : vec3(.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    State state;\n    load(iChannel0, state);\n    \n    Time = vec4(iTime,0,0,0);\n    Time.x += state.time_offset;\n    \n    vec2 coord = fragCoord;\n    vec2 screen_center = iResolution.xy * .5;\n    coord -= screen_center;\n    coord *= state.zoom;\n    if (!state.center)\n    \tcoord += screen_center;\n    \n    vec2 scale_ratio = iResolution.xy / TEXTURE_SIZE;\n    scale_ratio /= mn(scale_ratio);\n    \n    vec2 uv = coord / iResolution.xy + state.offset;\n    uv *= scale_ratio;\n    \n    uv = uv * INITIAL_UV_SCALE + INITIAL_UV_OFFSET;\n    if (state.center)\n    \tuv += .5;\n    UV = uv;\n    \n    TEXTURE_NAME();\n    \n    if (!state.tile && mx(abs(uv - .5)) > .5)\n        FCol = vec4(0);\n\n    switch (state.alpha_mode) {\n\tdefault:\n\tcase VIEW_BASE_COLOR:\n    \tfragColor = FCol;\n       \tbreak;\n\n\tcase VIEW_ALPHA:\n        fragColor = vec4(FCol.aaa, 1);\n        break;\n\n\tcase VIEW_BLACK_MATTE:\n        fragColor = vec4(FCol.rgb * FCol.a, 1);\n        break;\n\n\tcase VIEW_CHECKER:\n        // premultiplied alpha\n        fragColor = vec4(checker() * (1. - FCol.a) + FCol.rgb, 1);\n        break;\n\n\tcase VIEW_CHECKER_TEST:\n        fragColor = vec4(FCol.a < 0.5 ? checker() : FCol.rgb, 1);\n        break;\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////\n\n#define smoothen(x)\t((x)*(x)*(3.-2.*(x)))\n#define sqr(x)\t\t((x)*(x))\n#define lsq(x)\t\tdot(x, x)\n#define sat(x)\t\tclamp(x, 0., 1.)\n#define RGB(r,g,b)\t(vec3(r,g,b)/255.)\n\n#define ridged(v)\ttri(.5,.5,v)\n\n// $protect ^void[ \\t]+([_a-zA-Z][_a-zA-Z0-9]*)\\(\\)\n// $protect ^TEX[A]?\\(([a-z][_a-z0-9]*)\\)\n#define TEX(name)\tvec3 name(vec2); void name() { FCol = vec4(name(UV), 1); } vec3 name(vec2 uv)\n#define TEXA(name)\tvec4 name(vec2); void name() { FCol = name(UV); } vec4 name(vec2 uv)\n\n#define T0(x)\t\ttexture(Texture0, x)\n\n////////////////////////////////////////////////////////////////\n\n// Hardware derivates are computed at half resolution (pixel quads).\n// To get full-resolution results, we need to evaluate 3 taps.\n// The macro below helps automate that process a bit.\n//\n// Arguments:\n// - res = name of vec3 output variable to receive the results:\n//   .xy = normalized gradient\n//   .z  = function value\n// - uv  = 2d point where function is to be evaluated\n\n#define EVAL_GRAD(res, uv, code)\t\t\t\t\t\t\t\t \t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec2 p[3];\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t \tfloat r[3];\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tp[0] = uv;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tp[1] = uv + dFdx(uv);\t\t\t\t\t\t\t\t\t\t\\\n\t\tp[2] = uv + dFdy(uv);\t\t\t\t\t\t\t\t\t\t\\\n\tfor (int i = 0; i < 3; ++i)\t\t\t\t\t\t\t\t\t\t\\\n\t\tr[i] = code;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tres = vec3(safe_normalize(vec2(r[1], r[2]) - r[0]), r[0]);\t\\\n\t}\n\n////////////////////////////////////////////////////////////////\n\n// Computes a SDF and a top light/shadow value\n//\n// Arguments:\n// - uv = 2d point where function is to be evaluated\n// - s  = shadow size\n// - d  = name of float distance output variable\n// - l  = name of float light output variable\n\n#define EVAL_TOP_LIGHT(uv,s,d,l,code)\t\\\n\t{\t\t\t\t\t\t\t\t\t\\\n\t\tvec2 p = uv;\t\t\t\t\t\\\n\t\td = code;\t\t\t\t\t\t\\\n\t\tp.y -= s;\t\t\t\t\t\t\\\n\t\tl = (d - code) / s;\t\t\t\t\\\n\t}\n\n////////////////////////////////////////////////////////////////\n\n#if 0\nuniform sampler2D Texture0, Texture1;\nuniform vec4 Cam, Time, Extra, LightColor, Ambient, LightDir;\n\nin vec3 Pos, Nor, WNor, Ref;\nin vec2 UV, LUV;\nin vec4 Clr;\n\nout vec4 FCol;\n#endif\n\n////////////////////////////////////////////////////////////////\n\nconst float\n\tPI\t\t= 3.1415927,\n\tTAU\t\t= 2. * PI,\n\tPHI\t\t= 1.618034;\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 R2(float i) {\n\tfloat G = 1.324718;\n\treturn fract(.5 + i / vec2(G, G * G));\n}\n\nfloat R1(float i) {\n\treturn fract(.5 + i * PHI);\n}\n\n// smooth R1\nfloat SR1(float f) {\n\tfloat i = floor(f);\n\treturn mix(R1(i), R1(i+1.), smoothen(f - i));\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat mn(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat mn(vec3 v) {\n\treturn min(v.x, min(v.y, v.z));\n}\n\nfloat mn(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\nfloat mx(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat mx(vec3 v) {\n\treturn max(v.x, max(v.y, v.z));\n}\n\nfloat mx(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat sum(vec2 v) {\n\treturn v.x + v.y;\n}\n\nfloat sum(vec3 v) {\n\treturn v.x + v.y + v.z;\n}\n\nfloat minabs(float a, float b) {\n\treturn abs(a) < abs(b) ? a : b;\n}\n\nfloat onion(float x, float s) {\n\treturn abs(x) - s;\n}\n\nfloat elongate(float x, float s) {\n\treturn sign(x) * max(0., abs(x) - s);\n}\n\n////////////////////////////////////////////////////////////////\n\nvec2 safe_normalize(vec2 v) {\n\tfloat l = dot(v, v);\n\treturn l > 0. ? v/sqrt(l) : v;\n}\n\n////////////////////////////////////////////////////////////////\n\n// tent\nfloat tri(float center, float max_dist, float x) {\n\treturn 1. - sat(abs(x - center) / max_dist);\n}\n\n// antialiased tent funtion\nfloat triaa(float c, float s, float x) {\n\tfloat a = max(fwidth(x) * 2. / s, 1.);\n\treturn tri(c, s * a, x) / a;\n}\n\n// linear step (like smoothstep, but linear)\nfloat ls(float lo, float hi, float x) {\n\treturn sat((x - lo) / (hi - lo));\n}\n\n// asymmetric tent\nfloat tri(float a, float b, float c, float x) {\n\treturn min(ls(a, b, x), ls(c, b, x));\n}\n\n////////////////////////////////////////////////////////////////\n\nvec2 sc(float x) {\n\treturn vec2(sin(x), cos(x));\n}\n\nmat2 rot(float x) {\n\tvec2 v = sc(radians(x));\n\treturn mat2(v.y, v.x, -v.x, v.y);\n}\n\n// Normalized angle [0..1]\nfloat nang(vec2 p) {\n\treturn fract(atan(p.y, p.x) / TAU);\n}\n\n// Polar mod\nvec2 pmod(vec2 p, float n) {\n\treturn p * rot(360. / n * (floor(nang(p) * n + 1.5) - 1.));\n}\n\n// UV distortions //////////////////////////////////////////////\n\n// p = integral number of half periods\n// s = scale\nvec2 wavy(vec2 uv, float p, float s) {\n\treturn uv + sin(uv.yx * PI * p) * s;\n}\n\n// t = time offset\nvec2 wavy(vec2 uv, float t, float p, float s) {\n\treturn uv + sin(uv.yx * PI * p + t) * s;\n}\n\nfloat mirr(float v, float m) {\n\treturn m - abs(v - m);\n}\n\nvec2 mirr(vec2 v, float m) {\n\tv.x = mirr(v.x, m);\n\treturn v;\n}\n\n// x = variable to repeat\n// p = period\n// l = low limit\n// h = high limit\nfloat repeat(float x, float p, float l, float h) {\n\treturn x - p * clamp(floor(x / p + .5), l, h);\n}\n\n// Running bond: s = (rows, columns)\nvec2 brick(vec2 uv, vec2 s) {\n\tuv.x += floor(uv.y * s.y) * (.5 / s.x);\n\treturn fract(uv) * s;\n}\n\n// Inputs:\n//   - uv in [0..1]\n//   - r = radius, in [0..1]\n// Output:\n//   - xy = offset\n//   - z  = edge ratio in [0..1]\nvec3 brick_edge(vec2 uv, float r) {\n\treturn vec3(uv -= clamp(uv, r, 1. - r), length(uv) / r);\n}\n\n// Inputs:\n//   - uv in [0..1]\n//   - s = (rows, columns)\n//   - r = radius, in [0..1]\n// Output:\n//   - xy = offset\n//   - z  = edge ratio in [0..1]\nvec3 brick_edge(vec2 uv, vec2 s, float r) {\n\ts = s.yx / mn(s);\n\tuv *= s;\n\treturn vec3(uv -= clamp(uv, vec2(r), s - r), length(uv) / r);\n}\n\n////////////////////////////////////////////////////////////////\n// Noise ///////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n// Dave Hoskins/Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\n\nfloat H(vec2 p) {\n\tvec3 q = fract(p.xyx * .09153);\n\tq += dot(q, q.yzx + 19.19);\n\treturn fract((q.x + q.y) * q.z);\n}\n\nfloat H(float p) {\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\nvec3 H3(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec2 H2(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 H4(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy + 33.33);\n\treturn fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 H4(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy+33.33);\n\treturn fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat HT(float p, float s) {\n\treturn H(mod(p, s));\n}\n\nfloat HT(vec2 p, vec2 s) {\n\treturn H(mod(p, s));\n}\n\n// FIXME: 1D noise should take a normalized value, like its 2D counterpart!\nfloat N(float p) {\n\tfloat i;\n\treturn mix(H(i = floor(p)), H(i + 1.), smoothen(p - i));\n}\n\n// FIXME: 1D noise should take a normalized value, like its 2D counterpart!\nfloat NT(float p, float s) {\n\tfloat i;\n\t// FIXME: linear, not smooth\n\treturn mix(HT(i = floor(p), s), HT(i + 1., s), p - i);\n}\n\nfloat NT(vec2 p, vec2 s) {\n\tp *= s;\n\tvec2 i = floor(p);\n\tp -= i;\n\tp *= p * (3. - 2. * p);\n\tfloat s00 = HT(i + vec2(0, 0), s);\n\tfloat s01 = HT(i + vec2(0, 1), s);\n\tfloat s11 = HT(i + vec2(1, 1), s);\n\tfloat s10 = HT(i + vec2(1, 0), s);\n\treturn mix(mix(s00, s10, p.x), mix(s01, s11, p.x), p.y);\n}\n\nfloat FBMT(vec2 p, vec2 scale, float gain, float lac, int lyrs) {\n\tfloat acc = NT(p, scale), ow = 1., tw = 1.;\n\tfor (int i=0; i<lyrs; ++i) {\n\t\tp = fract(p + PHI);\n\t\tscale *= lac; ow *= gain;\n\t\tacc += NT(p, scale) * ow;\n\t\ttw += ow;\n\t}\n\treturn acc / tw;\n}\n\n// FIXME: 1D noise should take a normalized value, like its 2D counterpart!\nfloat FBMT(float p, float scale, float gain, float lac, int lyrs) {\n\tfloat acc = NT(p * scale, scale), ow = 1., tw = 1.;\n\tfor (int i=0; i<lyrs; ++i) {\n\t\tp = fract(p + PHI);\n\t\tscale *= lac; ow *= gain;\n\t\tacc += NT(p * scale, scale) * ow;\n\t\ttw += ow;\n\t}\n\treturn acc / tw;\n}\n\nfloat FBMT_ridged(vec2 p, vec2 scale, float gain, float lac, int lyrs) {\n\tfloat acc = ridged(NT(p, scale)), ow = 1., tw = 1.;\n\tfor (int i=0; i<lyrs; ++i) {\n\t\tp = fract(p + PHI);\n\t\tscale *= lac; ow *= gain;\n\t\tacc += ridged(NT(p, scale)) * ow;\n\t\ttw += ow;\n\t}\n\treturn acc / tw;\n}\n\n// Env mapping /////////////////////////////////////////////////\n\n// s = detail scale (integral values only)\n// 45.0 is very shiny, 9.0 less so\nfloat env(vec3 p, float s) {\n\tp = normalize(p);\n\tvec3 a = fract(degrees(atan(p, p.yzx)) / 360.);\n\treturn NT(a.x * s, s) * ls(.9, .0, abs(p.z)) + NT(a.y * s, s) * ls(.7, .0, abs(p.x));\n}\n\nfloat env(vec3 p) {\n\treturn env(p, 45.);\n}\n\n////////////////////////////////////////////////////////////////\n\n#if 0\nvec3 Light() {\n\tvec3 d = Cam.xyz - Pos;\n\tfloat\n\t\tb = FBMT(d.xy/256.*rot(Cam.w), vec2(3), .7, 3., 4),\n\t\tl = 1. - ls(14., -6., length(d.xy) - b * 8.) * ls(128., 48., d.z) * step(.1, Nor.z);\n\treturn texture(Texture1, LUV).xyz * 2. * l;\n}\n#endif\n\n////////////////////////////////////////////////////////////////\n\nvec2 seg(vec2 p, vec2 a, vec2 b) {\n\tvec2 ab = b-a, ap = p-a;\n\tfloat t = sat(dot(ap, ab)/dot(ab, ab));\n\treturn ab*t + a;\n}\n\nfloat half_plane(vec2 uv, vec2 d) {\n\treturn dot(uv, rot(90.) * normalize(d));\n}\n\nfloat box(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat box1(vec2 p, vec2 b) {\n\treturn mx(abs(p) - b);\n}\n\nfloat circ(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat seg(vec2 p, vec2 a, vec2 b, float r) {\n\treturn circ(p - seg(p, a, b), r);\n}\n\nfloat elips(vec2 p, vec2 r) {\n\treturn circ(p/r, 1.) / min(r.x, r.y);\n}\n\nfloat exclude(float a, float b) {\n\treturn max(a, -b);\n}\n\n// polynomial smooth min\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nvec2 grad(float x) {\n\tvec2 d = vec2(dFdx(x), dFdy(x));\n\treturn d / max(length(d), 1e-8);\n}\n\nfloat msk(float s, float d) {\n\treturn sat(1. - s/d);\n}\n\nfloat msk(float s) {\n\treturn sat(1. - s/fwidth(s));\n}\n\n////////////////////////////////////////////////////////////////\n\n// Output: xyz = normal, w = unclamped normalized distance\nvec4 rivet(vec2 uv, float s) {\n\treturn vec4(uv/=s, sqrt(sat(1.-lsq(uv))), length(uv) - 1.);\n}\n\nfloat top_light(vec3 n) {\n\tfloat l = sum(n.yz) * .7;\n\treturn pow(sat(l), 4.) + l;\n}\n\nfloat rivet_shadow(vec2 uv, float s) {\n\tuv /= s;\n\tuv.y += .06;\n\tuv.x *= 2.;\n\treturn ls(.3, .0, length(uv));\n}\n\n// c = base color\n// l = light intensity (default: 0.5)\n// d = shadow intensity (default 0.3)\nvec3 add_rivet(vec3 c, vec2 uv, float s, float l, float d) {\n\tvec4 b = rivet(uv, s);\n\tc *= 1. + top_light(b.xyz) * msk(b.w, s + s) * l;\n\tc *= 1. - sqr(rivet_shadow(uv, 20. * s)) * (1. - msk(b.w, s + s)) * d;\n\treturn c;\n}\n\nvec3 add_rivet(vec3 c, vec2 uv, float s) {\n\treturn add_rivet(c, uv, s, .5, .3);\n}\n\n////////////////////////////////////////////////////////////////\n\n// p = point\n// c = center\n// s = size\n// i = core intensity\nfloat flare(vec2 p, vec2 c, float s, float i) {\n    p -= c;\n    float a = ls(.2, .5, abs(fract(nang(p /= s) * 8. + H(fract(c))) - .5));\n    return ls(.9, i, pow(lsq(p), .0625) - a * a * .006);\n}\n\nfloat wrapped_flare(vec2 p, vec2 c, float s, float i) {\n    float d = flare(p, c, s, i);\n    c.x += p.x < c.x ? -1. : 1.;\n    return d + flare(p, c, s, i);\n}\n\n// uv in [-0.5..0.5]\nfloat pentagram(vec2 uv, float s) {\n\tfloat d = 1e6, i = 0.;\n\tfor (/**/; i < 5.; ++i) {\n\t\tvec2 p = vec2(0, -s) * rot(i * 72.);\n\t\td = min(d, length(uv - seg(uv, p, p * rot(144.))));\n\t}\n\treturn d;\n}\n\n////////////////////////////////////////////////////////////////\n//#pragma section patterns\n////////////////////////////////////////////////////////////////\n\n// Quake 3 logo SDF\n// t = 0.0 : app icon (chunky)\n// t = 1.0 : background logo (slim)\nfloat icon_sdf(vec2 uv, float t) {\n\tuv.x = abs(uv.x);\n\tuv.y -= .07;\n\tfloat d = elips(uv, vec2(.31, .12 - t * .02)) / 50.; // base ellipse\n\td = max(d, -elips(uv - vec2(0, .01 + .01 * t), vec2(.28 + t * .01, .07)) / 75.); // negative inner ellipse\n\td = max(d, -box(uv - vec2(0, .1), vec2(.22 - .02 * t, .12))); // cut off far part\n\td = max(d, -box(uv - vec2(0, .1), vec2(.084 - .012 * t, .31))); // cut off mid part\n\td = min(d, box1(uv - vec2(0, -.09), vec2(tri(-.09, .32, uv.y)*(.04 - .015 * t), .32))); // middle rhombus\n\td = min(d, box1(uv - vec2(.11 - .02 * t, -.21 + .01 * t), vec2(tri(-.07, .3, uv.y)*(.03 - .01 * t), .15))); // outer rhombi\n\treturn d;\n}\n\n// Quake 1 logo SDF\nfloat sdf_Q(vec2 uv) {\n\tfloat d = circ(uv - vec2(0, .17), .32);\n\td = exclude(d, circ(uv - vec2(0, .235), .27));\n\td = exclude(d, circ(uv - vec2(0, .5), .15));\n\n\t// nail\n\tuv.y -= .09;\n\tvec2 s = vec2(.09, .52);\n\tfloat h = sat(-uv.y / s.y);\n\ts *= .5;\n\ts.x *= ls(1.05, .6, h) + sqr(ls(.1, .02, h));\n\tuv.y += s.y;\n\td = min(d, box(uv, s));\n\n\treturn d;\n}\n\n////////////////////////////////////////////////////////////////\n\n// several layers of boxes with faint grid connectors over a noisy background\n// uv = evaluation point [0..1]\n// b = FBM\n// f = fraction of boxes with horizontal/vertical slats (default 0.2)\nvec3 greebles(vec2 uv, float b, float f) {\n\tfloat\n\t\ti = 5., // initial grid size\n\t\tt = b * b * .3 + .05, // background value\n\t\td, m;\n\n\tfor (; i < 9.; i += 3.) {\n\t\tvec2 p = uv * i, q = floor(p); // grid\n\t\tvec4 h = H4(q + i); // 4 random values per cell\n\t\tp -= q; // relative grid position\n\t\tt = mix(t, .2, .2 * ls(.05, .02, mn(abs(p - .5)))); // overlay grid (connectors)\n\t\tq = h.xy * .4 + .15; // box size\n\t\td = box(p -= mix(q, 1.-q, h.zw), q - .05); // box within cell bounds\n\t\tt = mix(t, b * h.z * .2 + .1, m = msk(d, .01)); // add random-intensity box\n\t\tt *= 1.\n\t\t\t+ .7 * tri(.82, .08, abs(p.y / q.y)) * m * h.x * sign(p.y) // top/bottom edge lighting\n            //+ .5 * tri(-.03, .03, d) * h.x // edge highlight\n\t\t\t- .3 * tri(.1, .0, -.05, d) // outer shadow\n\t\t\t- .5 * tri(.05, .05, mod(p.y, .1)) * m * float(h.z < f) // horizontal slats for some objects\n\t\t\t- .5 * tri(.05, .05, mod(p.x, .1)) * m * float(h.z > 1. - f) // vertical slats for some objects\n\t\t;\n\t}\n\n\treturn vec3(t);\n}\n\n////////////////////////////////////////////////////////////////\n\n// \"Asymmetric Blocks\" by Shane\n// https://www.shadertoy.com/view/Ws3GRs\n\nvec3 pattern(vec2 p, float sc, float bv) {\n\tvec3 e = vec3(-1, 0, 1), r = vec3(1e5);\n\tvec2 ip = floor(p*sc), tileID = e.yy;\n\tp -= (ip + .5) / sc;\n\n\tfloat\n\t\th11 = .5 * HT(ip + e.yy, vec2(sc)),\n\t\th10 = .5 * HT(ip + e.xy, vec2(sc)),\n\t\th01 = .5 * HT(ip + e.yz, vec2(sc)),\n\t\th12 = .5 * HT(ip + e.zy, vec2(sc)),\n\t\th21 = .5 * HT(ip + e.yx, vec2(sc)),\n\t\th00 = .5 * HT(ip + e.xz, vec2(sc)),\n\t\th02 = .5 * HT(ip + e.zz, vec2(sc)),\n\t\th22 = .5 * HT(ip + e.zx, vec2(sc)),\n\t\th20 = .5 * HT(ip + e.xx, vec2(sc));\n\n\tvec2[4] ctr, l;\n\tif (mod(ip.x + ip.y, 2.) < .5) {\n\t\tl[0] = 1. + vec2(h21 - h10, h11 - h20);\n\t\tl[1] = 1. + vec2(h12 - h21, h11 - h22);\n\t\tl[2] = 1. + vec2(h01 - h10, h00 - h11);\n\t\tl[3] = 1. + vec2(h12 - h01, h02 - h11);\n\t\tctr[0] = vec2(h21, h11);\n\t\tctr[1] = vec2(h21, h11);\n\t\tctr[2] = vec2(h01, h11);\n\t\tctr[3] = vec2(h01, h11);\n\t} else {\n\t\tl[0] = 1. + vec2(h11 - h20, h10 - h21);\n\t\tl[1] = 1. + vec2(h22 - h11, h12 - h21);\n\t\tl[2] = 1. + vec2(h11 - h00, h01 - h10);\n\t\tl[3] = 1. + vec2(h02 - h11, h01 - h12);\n\t\tctr[0] = vec2(h11, h10);\n\t\tctr[1] = vec2(h11, h12);\n\t\tctr[2] = vec2(h11, h10);\n\t\tctr[3] = vec2(h11, h12);\n\t}\n\n\tfor (int i=0; i<4; i++) {\n\t\tctr[i] += l[i] * (vec2(i&1, i/2) - .5);\n\t\tl[i] /= sc;\n\t\tfloat bx = box1(p - ctr[i]/sc, l[i]/2. - bv/sc);\n\t\tif (bx < r.x)\n\t\t\tr = vec3(bx, ip + ctr[i]);\n\t}\n\n\treturn r;\n}\n\n////////////////////////////////////////////////////////////////\n\n// Voronoi diagram\n// xy = offset; z = edge distance\n#define VORO_FUNC(name, norm)\t\t\t\t\t\t\t\t\t\t\\\n\tvec3 name(vec2 p, vec2 grid) {\t\t\t\t\t\t\t\t\t\\\n\t\tp *= grid;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tvec2 n = floor(p), f = p - n, mr, g, o, r;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfloat md = 8., sd = md, d;\t\t\t\t\t\t\t\t\t\\\n\t\tfor (int i = 0; i < 9; ++i) {\t\t\t\t\t\t\t\t\\\n\t\t\tg = vec2(i % 3 - 1, i / 3 - 1);\t\t\t\t\t\t\t\\\n\t\t\to = H2(mod(n + g, grid));\t\t\t\t\t\t\t\t\\\n\t\t\tr = g + o - f;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\td = norm;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (d < md) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tsd = md;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmd = d;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tmr = r;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (d < sd) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tsd = d;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn vec3(mr, sd - md);\t\t\t\t\t\t\t\t\t\\\n\t}\n\nVORO_FUNC(voro1, sum(abs(r))) // L1 (Manhattan) norm\nVORO_FUNC(voro, length(r)) // L2 norm\n\n////////////////////////////////////////////////////////////////\n\n// Ring of wires\n// c = background color\n// uv = evaluation point\n// p = ring center radius\n// s = radial ring extent\nvec3 wire_ring(vec3 c, vec2 uv, float p, float s) {\n    float\n        n = NT(uv, vec2(13)) - .5, // smooth angular distortion\n        k = NT(uv, vec2(17)) - .5, // smooth radial distortion\n        r = length(uv -= .5), // radius\n        d, m\n    ;\n    vec2 q = fract(vec2(nang(uv) * 22. + k * .1, r * 55. + n * .6)); // scaled/distorted polar coordinates\n    d = mn(abs(q - .5) * vec2(2, .5 + n * .3)); // wire distance\n    m = ls(.01, .0, abs(r - p) - s); // interior mask\n    c *= 1.\n        + .3 * m * tri(.0, .2, d) // wire highlight\n        - .5 * m * tri(.3, .3, d) // wire shadow\n    ;\n    return c;\n}\n\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\nconst int\n    VIEW_BASE_COLOR\t\t= 0,\n    VIEW_ALPHA\t\t\t= 1,\n    VIEW_BLACK_MATTE\t= 2,\n    VIEW_CHECKER\t\t= 3,\n    VIEW_CHECKER_TEST\t= 4,\n    ALPHA_MODE_COUNT\t= 5\n;\n\nstruct State {\n    float zoom;\n    float time_offset;\n    vec2 offset;\n    vec2 prev_mouse;\n    int alpha_mode;\n    bool tile;\n    bool center;\n};\n\nvoid reset(out State state) {\n    state.zoom = 1.;\n    state.time_offset = 0.;\n    state.offset = vec2(0);\n    state.prev_mouse = vec2(0);\n    state.alpha_mode = VIEW_CHECKER;\n    state.tile = true;\n    state.center = false;\n}\n    \nvoid load(sampler2D tex, out State state) {\n    vec4 v0 = texelFetch(tex, ivec2(0, 0), 0);\n    vec4 v1 = texelFetch(tex, ivec2(1, 0), 0);\n\n    state.zoom = v0.x;\n    state.time_offset = v0.y;\n    state.offset = v0.zw;\n\n    state.prev_mouse = v1.xy;\n    state.alpha_mode = int(v1.z);\n    int flags = int(v1.w);\n    state.tile = (flags & 1) != 0;\n    state.center = (flags & 2) != 0;\n}\n\nvoid store(inout vec4 fragColor, vec2 fragCoord, State state) {\n\t#define ON(x,y) all(equal(ivec2(fragCoord), ivec2(x, y)))\n    \n    if (ON(0, 0))\n        fragColor = vec4(state.zoom, state.time_offset, state.offset);\n    if (ON(1, 0))\n        fragColor = vec4(state.prev_mouse, state.alpha_mode, int(state.tile) | (int(state.center) << 1));\n    \n\t#undef ON\n}\n", "buffer_a_code": "const int\n\tKEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70, KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74,\n\tKEY_K = 75, KEY_L = 76, KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82, KEY_S = 83, KEY_T = 84,\n\tKEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90,\n\n    KEY_0 = 48, KEY_1 = 49, KEY_2 = 50, KEY_3 = 51, KEY_4 = 52, KEY_5 = 53, KEY_6 = 54, KEY_7 = 55, KEY_8 = 56, KEY_9 = 57,\n\n\tKEY_PLUS\t\t= 187,\n\tKEY_MINUS\t\t= 189,\n\tKEY_EQUAL\t\t= KEY_PLUS,\n    \n    // firefox...\n    KEY_PLUS_FF\t\t= 61,\n    KEY_MINUS_FF\t= 173, \n\n\tKEY_SHIFT\t\t= 16,\n\tKEY_CTRL\t\t= 17,\n\tKEY_ALT\t\t\t= 18,\n    \n    KEY_ESC\t\t\t= 27,\n\t\n    KEY_BKSP \t\t=  8,\n    KEY_TAB\t\t\t=  9,\n\tKEY_END\t\t\t= 35,\n\tKEY_HOME\t\t= 36,\n\tKEY_INS\t\t\t= 45,\n\tKEY_DEL\t\t\t= 46,\n\tKEY_INSERT\t\t= KEY_INS,\n\tKEY_DELETE\t\t= KEY_DEL,\n\n\tKEY_ENTER\t\t= 13,\n\tKEY_SPACE \t\t= 32,\n\tKEY_PAGE_UP \t= 33,\n\tKEY_PAGE_DOWN \t= 34,\n\tKEY_PGUP \t\t= KEY_PAGE_UP,\n\tKEY_PGDN \t\t= KEY_PAGE_DOWN,\n\n\tKEY_LEFT\t\t= 37,\n\tKEY_UP\t\t\t= 38,\n\tKEY_RIGHT\t\t= 39,\n\tKEY_DOWN\t\t= 40,\n\n    KEY_PAD_PLUS\t= 107,\n    KEY_PAD_MINUS\t= 109,\n    KEY_PAD_SLASH\t= 111,\n    KEY_SLASH\t\t= 191\n;\n\nfloat key_down(int key) { return texelFetch(iChannel1, ivec2(key, 0), 0).x; }\nfloat key_pressed(int key) { return texelFetch(iChannel1, ivec2(key, 1), 0).x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 addr = ivec2(fragCoord);\n\n\tState state;\n    if (iFrame == 0) {\n        reset(state);\n        if (iTime > 5.) { // thumbnail\n            state.time_offset -= 10.;\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, addr, 0);\n        load(iChannel0, state);\n    }\n\n    float alt = key_down(KEY_ALT);\n    float zoom =\n        key_down(KEY_PAD_PLUS) - key_down(KEY_PAD_MINUS) +\n        max(key_down(KEY_PLUS), key_down(KEY_PLUS_FF)) - max(key_down(KEY_MINUS), key_down(KEY_MINUS_FF));\n    zoom = exp2(-zoom * iTimeDelta * 3.);\n\n    state.zoom *= zoom;\n\n    if (max(key_pressed(KEY_PAD_SLASH), key_pressed(KEY_SLASH)) > 0.) {\n        state.zoom = 1.;\n        state.offset = vec2(0);\n    }\n    \n    //if (key_pressed(KEY_HOME) > 0.)\n    //    state.offset = vec2(0);\n\n    for (int i = 1; i < 9; ++i)\n        if (key_pressed(KEY_0 + i) > 0.)\n\t        state.zoom = alt > 0. ? float(i) : 1. / float(i);\n       \n\tif (key_pressed(KEY_M) > 0.)\n        state.alpha_mode = (state.alpha_mode + 1) % ALPHA_MODE_COUNT;\n\t\n\tif (key_pressed(KEY_T) > 0.)\n        state.tile = !state.tile;\n\t\n\tif (key_pressed(KEY_C) > 0.)\n        state.center = !state.center;\n\n    if (iMouse.z > 0. && state.time_offset == 0.) {\n        vec2 moved = iMouse.xy - abs(iMouse.zw);\n        vec2 delta = moved - state.prev_mouse;\n        if (key_down(KEY_CTRL) > 0.)\n            state.zoom *= exp2(-delta.y / iResolution.y * 2.);\n        else if (key_down(KEY_ALT) > 0.)\n        \tstate.time_offset += delta.x / iResolution.x;\n        else\n        \tstate.offset -= delta / iResolution.xy * state.zoom;\n    \tstate.prev_mouse = moved;\n    } else {\n        state.prev_mouse = vec2(0);\n    }\n\n    state.offset.x += (key_down(KEY_RIGHT) - key_down(KEY_LEFT)) * iTimeDelta * state.zoom;\n    state.offset.y += (key_down(KEY_UP) - key_down(KEY_DOWN)) * iTimeDelta * state.zoom;\n\n    store(fragColor, fragCoord, state);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGGWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10889, 10889, 10906, 10906, 10924], [11243, 11265, 11278, 11278, 11473], [11930, 11952, 11967, 11967, 13067], [13069, 13093, 13106, 13106, 13506], [13508, 13584, 13642, 13642, 13745], [15030, 15030, 15059, 15059, 15120], [15122, 15122, 15169, 15169, 15549], [15551, 15619, 15650, 15650, 15692], [15694, 15881, 15942, 15942, 16254], [16256, 16284, 16338, 16338, 16582], [16584, 16743, 16817, 16817, 17149], [20264, 20301, 20317, 20317, 20507], [20509, 20549, 20567, 20567, 20674], [23809, 23847, 23862, 23862, 24237], [24239, 24269, 24282, 24282, 24527], [24529, 24551, 24563, 24563, 24854], [24856, 24879, 24893, 24893, 25367], [25369, 25395, 25409, 25409, 25640], [25642, 25666, 25681, 25681, 25997], [25999, 25999, 26030, 26030, 26083], [26085, 26085, 26147, 26147, 26375], [26377, 26377, 26427, 26427, 27829], [29837, 29837, 29896, 29896, 30028], [30415, 30450, 30467, 30467, 31158], [31160, 31160, 31221, 31221, 31359], [31858, 31858, 31921, 31921, 32058], [33881, 33922, 33960, 33960, 34039], [34041, 34041, 34129, 34129, 34285], [34287, 34287, 34318, 34318, 34354], [34356, 34356, 34433, 34433, 34639], [34657, 34657, 34715, 34715, 34864], [34866, 34866, 34894, 34894, 34958], [34960, 35081, 35146, 35146, 37383], [37385, 37574, 37592, 37592, 41068], [41070, 41109, 41129, 41129, 41182], [41184, 41223, 41243, 41243, 41301], [41303, 41342, 41362, 41488, 41575], [41577, 41607, 41622, 41622, 43194], [43196, 43239, 43257, 43257, 43813], [43815, 43861, 43882, 43882, 44088], [44090, 44134, 44153, 44153, 44406], [44408, 44455, 44477, 44477, 44768], [46981, 47014, 47031, 47031, 47176], [47178, 47234, 47254, 47254, 48392], [48394, 48426, 48444, 48444, 49892], [49894, 50252, 50264, 50264, 51350], [51352, 51407, 51421, 51421, 51481], [51483, 51536, 51550, 51550, 51607], [51609, 51663, 51677, 51677, 51719], [51721, 51773, 51787, 51787, 51847], [51849, 51899, 51913, 51913, 51973], [51975, 52026, 52040, 52040, 52100], [52102, 52128, 52143, 52143, 52340], [52342, 52393, 52429, 52429, 53230], [53232, 53232, 53277, 53277, 54176], [54178, 54206, 54220, 54220, 54411], [54413, 54442, 54457, 54457, 55032], [55034, 55063, 55080, 55080, 56415], [56417, 56447, 56465, 56465, 58039], [58041, 58071, 58089, 58089, 62304], [66088, 66128, 66147, 66147, 66557], [66559, 66559, 66588, 66588, 66742], [69438, 69476, 69496, 69496, 70235], [70237, 70263, 70277, 70277, 71006], [71008, 71036, 71050, 71050, 71433], [71436, 71469, 71486, 71486, 71756], [71758, 71777, 71793, 71793, 72259], [72261, 72283, 72301, 72301, 72462], [72464, 72484, 72500, 72500, 73038], [73040, 73061, 73076, 73076, 73486], [73488, 73505, 73520, 73520, 74230], [74232, 74254, 74268, 74268, 75094], [75891, 75921, 75935, 75935, 76326], [76328, 76357, 76373, 76373, 76555], [76557, 76587, 76602, 76602, 77291], [77293, 77293, 77329, 77329, 77911], [77913, 77949, 77964, 77964, 77994], [77996, 78029, 78046, 78046, 78073], [78075, 78111, 78128, 78128, 78158], [78160, 78187, 78203, 78203, 78468], [78470, 78501, 78521, 78521, 78810], [78812, 78844, 78864, 78864, 79153], [79155, 79187, 79202, 79202, 79636], [79638, 79675, 79691, 79691, 80008], [80010, 80036, 80051, 80051, 80742], [80744, 80768, 80782, 80782, 81108], [81110, 81156, 81167, 81167, 81573], [81575, 81611, 81629, 81629, 82063], [82065, 82065, 82089, 82089, 82298], [82300, 82300, 82325, 82325, 82500], [82503, 82535, 82549, 82549, 82659], [82661, 82691, 82705, 82705, 82914], [82916, 82946, 82959, 82959, 83555], [83557, 83583, 83608, 83608, 83821], [83823, 83855, 83869, 83869, 84121], [84123, 84167, 84184, 84184, 84535], [84537, 84552, 84564, 84564, 84757], [84759, 84774, 84787, 84787, 85611], [85613, 85613, 85670, 85670, 85774], [85776, 85811, 85827, 85827, 87102], [87104, 87121, 87150, 87150, 88255], [88257, 88283, 88318, 88318, 89162], [89164, 89192, 89205, 89205, 89295], [89297, 89327, 89342, 89342, 89476], [89478, 89512, 89530, 89530, 90304], [90306, 90324, 90339, 90339, 90587], [90589, 90641, 90654, 90654, 90993], [90995, 91035, 91073, 91073, 91339], [91341, 91341, 91370, 91370, 91475], [91477, 91477, 91491, 91491, 91516], [91518, 91553, 91569, 91569, 91635], [91637, 91674, 91691, 91691, 91890], [92885, 92934, 92949, 92949, 93103], [93105, 93105, 93171, 93171, 93248], [93250, 93300, 93315, 93315, 95164], [95166, 95216, 95231, 95270, 97050], [97052, 97093, 97110, 97110, 97365], [97367, 97406, 97420, 97420, 97768], [97770, 97811, 97826, 97826, 97962], [97964, 98006, 98023, 98023, 98238], [98240, 98288, 98306, 98306, 99473], [99475, 99514, 99525, 99525, 101821], [101968, 101994, 102014, 102014, 102142], [102144, 102169, 102188, 102188, 102271], [102273, 102299, 102318, 102318, 102649], [102651, 102681, 102705, 102705, 102976], [102978, 103005, 103026, 103026, 103259], [103261, 103287, 103308, 103308, 103610], [103612, 103639, 103660, 103660, 103925], [103927, 103953, 103973, 103973, 104262], [104264, 104282, 104300, 104300, 104492], [104494, 104515, 104534, 104534, 104634], [104636, 104657, 104676, 104676, 104763], [104765, 104786, 104805, 104805, 104911], [104913, 104941, 104957, 104957, 105361], [105363, 105391, 105409, 105409, 105544], [105546, 105570, 105586, 105586, 105705], [105707, 105736, 105756, 105756, 105956], [106430, 106430, 106456, 106456, 106508], [106510, 106510, 106534, 106534, 106569], [106571, 106571, 106589, 106589, 106665], [106733, 106733, 106801, 106801, 106892], [108480, 108480, 108496, 108496, 108608], [108610, 108610, 108667, 108667, 109861]], "test": "untested"}
{"id": "tttczB", "name": "Complete Graph in Colour", "author": "mla", "description": "Version of [url]https://www.shadertoy.com/view/tstfzs[/url], now with colour.\n\nBest viewed full screen. Mouse zooms in.", "tags": ["graph", "complete"], "likes": 13, "viewed": 331, "published": 3, "date": "1609422008", "time_retrieved": "2024-07-30T20:27:21.828737", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Complete Graph II\n// Matthew Arcus, mla, 2020\n//\n// Now with colours.\n//\n// Take N points in a circle, draw a line between each pair of\n// points. The obvious way to do this in a fragment shader is to test\n// the pixel against every point pair, but this gets slow for larger\n// number of points. A better way is to maintain two indexes into the\n// points, i and j, and each time around the loop, after testing for\n// proximity to the line between i and j, increment the index that\n// will move the line towards the pixel rather than away (draw a\n// diagram if this isn't clear).\n//\n// We can also draw the lines selectively, for example, for a\n// complete bipartite graph.\n// \n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 63;  // number of nodes\nconst int P = 21;  // bipartite block size\nint Q;             // sub block size\nconst float T = 15.0; // Cycle time\nconst float X = 6.0; //0.1*float(N);  // Speed (N/X should be 10 seconds or so)\nbool triangular = false; // Colour to show triangular numbers\n\nbool select(int i, int j, int cycle) {\n  if (Q == 0) return true; // Complete graph\n  // For a bipartite graph, divide up into blocks of P points, the\n  // first Q points of each block are connected to every point in the\n  // last P-Q of each block.\n  return (i%P < Q) != (j%P < Q);\n}\n\nvec3 diagram(vec2 p) {\n  p = rotate(p,0.01); // Rotate slightly to reduce artefacts\n  float lwidth = fwidth(p.x);\n  vec3 col = vec3(0); //1.0-vec3(1,1,0.8);\n  if (dot(p,p) > 1.0+lwidth) return col;\n  int cycle = int(iTime/T);\n  Q = cycle%(P/2+1);\n  float k = float(N);\n  k *= smoothstep(0.0,k,min(k,X*mod(iTime,T)));\n  float d2min = 1e8, rmin;\n  float offset = 0.0;\n  if (Q != 0) offset = 0.5*float(Q-1); // Centre on Q block\n  for (float i = 0.0, j = 1.0; j < k; ) {\n    float ii = 2.0*PI/k*(i-offset);\n    float ij = 2.0*PI/k*(j-offset);\n    vec2 q = vec2(sin(ii),cos(ii));\n    vec2 r = vec2(sin(ij),cos(ij));\n    if (select(int(i),int(j),cycle)) {\n      float d2 = segment2(p,q,r);\n      if (d2 < d2min) {\n        d2min = d2;\n        if (!triangular) rmin = 1.0-0.25*dot(r-q,r-q);\n        else rmin = (abs(i-j)-1.0)/k;\n      }\n    }\n    vec2 n = r-q;\n    if (dot(p-q,vec2(-n.y,n.x)) > 0.0) i++;\n    else j++;\n  }\n  col = mix(hsv2rgb(0.0*iTime+pow(rmin,1.0),1.0,1.0),col,smoothstep(0.0,lwidth,sqrt(d2min)));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  if (iMouse.z > 0.0) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p -= mouse; // Centre on mouse\n    p *= 0.55*iResolution.y/iResolution.x; // And zoom\n  }\n  vec3 col = diagram(p);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.14159265;\n\n// Distance squared of p from line segment qr.\nfloat segment2(vec2 p, vec2 q, vec2 r) {\n  p -= q; r -= q;\n  float h = dot(p,r)/dot(r,r);\n  h = clamp(h,0.0,1.0);\n  p -= h*r;\n  return dot(p,p);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1143, 1143, 1181, 1181, 1427], [1429, 1429, 1451, 1451, 2454], [2456, 2456, 2509, 2509, 2819]], "test": "untested"}
{"id": "tttyzB", "name": "Energy Temple", "author": "dr2", "description": "Electric voodoo (known to the ancients) - mouseable", "tags": ["lightning", "helix", "architecture", "lightbeam"], "likes": 19, "viewed": 575, "published": 3, "date": "1609419079", "time_retrieved": "2024-07-30T20:27:22.801138", "image_code": "// \"Energy Temple\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv3 (vec3 p);\nfloat Noiseff (float p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 flPth[4];\nvec3 ltDir, qHit;\nfloat tCur, dstFar, domeRd, oculRd, ringWd, psgWd, psgHt, psgLen, pcGap, wThk, rTor, torScl,\n   rTorEx, nSegTor, aRotTor, crExt, torzFac, illum[4], flRad, flLen;\nint idObj;\nconst int idDom = 1, idPsg = 2, idPil = 3, idPilB = 4, idDomB = 5, idEnt = 6, idFlor = 7,\n   idTorL = 8, idTorR = 9, idTorC = 10, idTorS = 11, idSpkEx = 12, idSpk = 13;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec2 SphGrid (vec3 p)\n{\n  vec3 q;\n  vec2 a, sc, nSeg;\n  float dMin, d1, d2, r;\n  nSeg = vec2 (16., 19.);\n  sc = sin (0.07 * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n  q = p.yxz;\n  r = length (q.yz);\n  a = 2. * pi * (floor (nSeg * atan (q.zx, - vec2 (q.y, r)) / (2. * pi)) + 0.5) / nSeg;\n  q.yz = Rot2D (q.yz, a.x);\n  d1 = dot (vec2 (q.y, abs (q.z)), sc);\n  q.yz = Rot2D (vec2 (r, q.x), a.y);\n  d2 = dot (vec2 (q.y, abs (q.z)), sc);\n  return vec2 (d1, d2);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 d2;\n  float dMin, d, dh, s, zp, rh, cvOrd, a, flshLen;\n  dMin = dstFar;\n  q = p;\n  rh = length (q.xz);\n  q.y -= 2. * psgHt + psgWd + 2. * ringWd;\n  d2 = SphGrid (q);\n  s = abs (domeRd - length (q));\n  d = max (SmoothMax (s - wThk, min (max (d2.x, oculRd - rh), d2.y), 0.02), - q.y);\n  d = min (d, max (max (s - 0.3 * wThk, oculRd - rh), - q.y));\n  DMINQ (idDom);\n  q.xz = mix (q.xz, q.zx, step (abs (q.z), abs (q.x)));\n  q.z = abs (q.z);\n  q.y -= - psgWd - 2. * ringWd;\n  zp = abs (mod (q.z + pcGap, 2. * pcGap) - pcGap);\n  d = max (max (abs (abs (q.x) - psgWd + 3. * wThk) - 4.5 * wThk,\n     abs (abs (q.y + psgHt) - psgHt) - 0.5 * wThk), q.z - psgLen);\n  DMINQ (idPilB);\n  qq = q;\n  q = vec3 (abs (q.x) - psgWd + 5. * wThk, q.y + psgHt, abs (zp) - pcGap);\n  d = max (PrCylDf (q.xzy, 1.5 * wThk, psgHt), qq.z - psgLen);\n  DMINQ (idPil);\n  q = qq;\n  dh = length (vec2 (q.x, max (q.y, 0.))) - psgWd;\n  d = max (SmoothMin (abs (dh) - wThk, max (abs (dh) - 1.7 * wThk, pcGap - zp - 0.02), 0.02),\n     domeRd - rh);\n  d = max (max (d, min (min (0.1 - length (vec2 (max (q.y + 0.4 * psgHt, 0.), zp)), q.y + 1.6 * psgHt),\n     0.3 * psgLen - abs (q.z - 0.6 * psgLen))), max (q.z - psgLen, - 2. * psgHt - q.y));\n  DMINQ (idPsg);\n  d = max (dh - 4. * wThk, abs (q.z - psgLen - 2. * wThk) - 2. * wThk);\n  d = max (max (d, - dh - 7.5 * wThk), - 2. * psgHt - 0.5 * wThk  - q.y);\n  DMINQ (idEnt);\n  d = max (abs (q.x) - psgWd + 7.5 * wThk, 0.);\n  d = max (d, max (q.z - psgLen - 4. * wThk, 0.));\n  d = max (d, max (abs (q.y + 2. * psgHt + 0.25 * wThk) - 0.25 * wThk, 0.));\n  DMINQ (idFlor);\n  d = max (max (abs (domeRd - rh) - wThk, abs (q.y - 4. * ringWd) - 2. * ringWd - wThk), - wThk - dh);\n  d = max (d, 0.7 * ringWd - length (vec2 (q.x, q.y - 5. * ringWd - wThk)));\n  DMINQ (idDomB);\n  d = PrSphDf (q - vec3 (0., 4. * ringWd + 2. * wThk, domeRd - wThk), 0.5 * wThk);\n  DMINQ (idSpkEx);\n  q = p;\n  q.y -= 6. * torScl + 2.5 * wThk;\n  d = PrCylDf (q.xzy, rTor + 6. * torScl, 9. * torScl);\n  if (d < 0.05) { // from \"Plasma Coil\"\n    d = length (abs (abs (vec2 (rh - rTor, q.y)) - 4.5 * torScl)) - 0.5 * torScl;\n    DMINQ (idTorL);\n    qq = q;\n    qq.xz = Rot2D (q.xz, 0.25 * pi);\n    d = PrSphDf (vec3 (abs (qq.xz) - rTor + 1.41 * rTorEx, q.y - 4.5 * torScl), 0.8 * torScl);\n    DMINQ (idSpkEx);\n    d = length (vec2 (rh - rTor, q.y)) - 1.5 * torScl;\n    DMINQ (idTorR);\n    d = PrCylDf (vec3 (abs (qq.xz) - rTor + 0.11 * rTorEx, q.y + 8. * torScl),\n       (0.6 - 1.6 * (q.y + 8. * torScl)) * torScl, 3.5 * torScl);\n    DMINQ (idTorL);\n    q.xz = mix (qq.xz, qq.zx, step (abs (qq.z), abs (qq.x)));\n    q.z = abs (q.z) - rTor;\n    d = (length (vec2 (length (q.yz) - rTorEx, q.x)) - torScl * (1. + crExt));\n    DMINQ (idTorS);\n    q = qq;\n    q.xy = vec2 (q.y, - q.x);\n    q.yz = vec2 (atan (q.y, q.z) * rTor, length (q.yz) - rTor);\n    cvOrd = 7.;\n    a = atan (q.z, q.x) / (2. * pi);\n    q.xz = Rot2D (vec2 (length (q.xz) - 2. * torScl, mod (q.y + (2. * a + 1.) * torScl,\n       2. * torScl) - torScl), 2. * pi * (cvOrd - 1.) * a);\n    d = 0.8 * (length (Rot2D (q.xz, - (floor ((0.5 * pi - atan (q.x, q.z)) + pi / cvOrd))) -\n       vec2 (0.6 * torScl, 0.)) - 0.2 * torScl);\n    DMINQ (idTorC);\n    \n  } else dMin = min (dMin, d);\n  dh = dstFar; // from \"Tesla's Laboratory\"\n  d = dh;\n  flshLen = 1.1;\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    if (illum[k] > 0.) {\n      q = p;\n      q.xz = Rot2D (q.xz, float (k) * 0.5 * pi);\n      q.y -= flshLen + 0.39 + 2. * wThk;\n      q.z -= -0.71;\n      q.yz = Rot2D (q.yz, -0.38 * pi);\n      d = PrCylDf (q, 0.1, flshLen);\n      if (d < dMin) {\n        q.xy -= 0.15 * smoothstep (0., 0.1, flshLen - abs (q.z)) * (2. *\n           vec2 (Fbm2 (8. * (vec2 (0.4 * q.z, 0.) + flPth[k].xy)),\n           Fbm2 (8. * (vec2 (0.3 * q.z, 0.) + flPth[k].zw))) - 1.);\n        dh = min (dh, PrCylDf (q, 0.001, flshLen));\n      }\n    }\n    d = 0.7 * dh;\n  }\n  DMINQ (idSpk);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  q = p;\n  q.y -= 6. * torScl + 2.5 * wThk;\n  q.xz = Rot2D (q.xz, 2. * pi * aRotTor / nSegTor);\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (nSegTor * atan (q.z, - q.x) / (2. * pi)) +\n     0.5) / nSegTor));\n  return (length (vec2 (length (vec2 (abs (q.x) - rTor, q.y)) - 2.5 * torScl,\n     q.z * torzFac)) - 2. * torScl);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec2 CapsHit (vec3 ro, vec3 rd, float cRad, float cLen)\n{\n  float dIn, dOut, d, a, b, bs, w, s, ws, roz;\n  dIn = dstFar;\n  dOut = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cRad * cRad);\n  if (w > 0. && a > 0.) {\n    ws = sqrt (w);\n    d = - (b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (d > 0. && abs (s) < cLen) dIn = d;\n    else {\n      roz = ro.z;\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) {\n        d = - bs - sqrt (w);\n        if (d > 0.) dIn = d;\n      }\n      ro.z = roz;\n    }\n  }\n  if (dIn < dstFar) {\n    d = (- b + ws) / a;\n    s = ro.z + d * rd.z;\n    if (abs (s) < cLen) dOut = d;\n    else {\n      ro.z -= cLen * sign (s);\n      bs = dot (rd, ro);\n      w = bs * bs - (dot (ro, ro) - cRad * cRad);\n      if (w > 0.) dOut = - bs + sqrt (w);\n    }\n  }\n  return vec2 (dIn, dOut);\n}\n\nfloat FlmDens (vec3 p)\n{\n  float c;\n  c = max (0., 1.1 * BumpFbm3 (0.2 * vec3 (p.xy / flRad, p.z + 4. * tCur)) - 0.1 +\n     0.4 * smoothstep (-0.5 * flRad, 0.1 * flRad, p.z));\n  return c * (1. - smoothstep (-0.3 * flRad, 0., length (vec3 (p.xy,\n     p.z - clamp (p.z, - 2. * flLen, 0.))) - flRad * (1. + 0.8 * p.z / (2. * flLen)))) *\n     smoothstep (0., flRad, p.z + 2. * flLen);\n}\n\nvec3 FlmCol (vec3 ro, vec3 rd, vec2 dCyl2, float dstObj)\n{   // from \"Cloud Computing\", with mods and color\n  vec4 col4;\n  vec3 q, c;\n  float s, ds, f, fn, r;\n  const float sMax = 20.;\n  ds = min (2. * flRad, dCyl2.y - dCyl2.x) / sMax;\n  s = dCyl2.x;\n  ro.z -= flLen;\n  q = ro + s * rd;\n  r = length (q.xy) / flRad;\n  q.xy = Rot2D (q.xy, 0.5 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n  f = FlmDens (q);\n  col4 = vec4 (0.);\n  for (float j = float (VAR_ZERO); j < sMax; j ++) {\n    s += ds;\n    q = ro + (s + ds * Hashfv3 (16. * rd)) * rd;\n    r = length (q.xy) / flRad;\n    q.xy = Rot2D (q.xy, 0.5 * r * (2. * smoothstep (0.4, 0.8, r) - 1.) * q.z);\n    fn = FlmDens (q);\n    c = mix (mix (vec3 (0.1, 0.3, 1.), vec3 (0., 0.8, 1.), clamp ((0.3 / ds) * (f - fn), 0., 1.)),\n       vec3 (1.), smoothstep (-0.5 * flRad, 0.5 * flRad, q.z)) *\n       (1. - smoothstep (-0.1, 0., s - dstObj));\n    col4 += (1. - col4.a) * vec4 (c, 1.) * f / sMax;\n    f = fn;\n    if (s > dstObj || col4.a > 1.) break;\n  }\n  return clamp (col4.rgb, 0., 1.);\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{   // from \"Star Globe\"\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 5. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  vec3 col, mDir, vn;\n  float mRad, bs, ts;\n  mDir = normalize (vec3 (0.03, 0.08, 1.));\n  mRad = 0.015;\n  col = vec3 (0.06, 0.06, 0.03) * pow (clamp (dot (rd, mDir), 0., 1.), 16.);\n  bs = dot (rd, mDir);\n  ts = bs * bs - 1. + mRad * mRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - mDir) / mRad);\n      col += vec3 (1., 0.9, 0.5) * clamp (dot (normalize (vec3 (-0.9, 0.4, 0.5)), vn) *\n         (1. - 0.3 * Noisefv3 (8. * vn)), 0., 1.);\n    }\n  } else col += StarPat (rd, 16.);\n  return col;\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 sp, ss;\n  if (2. * floor (0.5 * floor (p.y)) != floor (p.y)) p.x += 0.5;\n  sp = smoothstep (0.03, 0.07, abs (fract (p + 0.5) - 0.5));\n  p = fract (p) - 0.5;\n  ss = 0.5 * smoothstep (0.4, 0.5, abs (p.xy)) * sign (p.xy);\n  if (abs (p.x) < abs (p.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sp.x * sp.y, ss.y);\n}\n\nvec4 ShStagGrid3d (vec3 p, vec3 vn)\n{\n  vec3 rg;\n  rg = ShStagGrid ((abs (vn.x) > 0.99) ? p.zy : ((abs (vn.y) > 0.99) ? p.zx : p.xy));\n  if (abs (vn.x) > 0.99) {\n    rg.xz *= sign (vn.x);\n    if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n    else vn.xz = Rot2D (vn.xz, rg.x);\n  } else if (abs (vn.y) > 0.99) {\n    rg.xz *= sign (vn.y);\n    if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n    else vn.yz = Rot2D (vn.yz, rg.x);\n  } else if (abs (vn.z) > 0.99) {\n    rg.xz *= sign (vn.z);\n    if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n    else vn.zx = Rot2D (vn.zx, rg.x);\n  }\n  return vec4 (vn, rg.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, rg4, a1, a2, b1, b2;\n  vec3 col, vn, roo, glCol, ltPos, ltDirL, stg, q;\n  vec2 vf, dCyl2, w;\n  float dstObj, dstTrObj, dstGrnd, s, att, nDotL, dSum, sSum, tLitCyc, t, tm, st, sp, f,\n     illTot, fBot, a;\n  bool inBldg, psgDir, isMet;\n  psgWd = 1.;\n  wThk = 0.05;\n  domeRd = psgWd + 0.18;\n  ringWd = 0.25;\n  psgLen = 4.;\n  psgHt = 0.75;\n  pcGap = 0.25;\n  oculRd = 0.28 * psgWd;\n  torScl = 0.04;\n  rTor = (80. / (2. * pi)) * torScl;\n  rTorEx = 5. * torScl;\n  nSegTor = 12.;\n  flRad = oculRd;\n  flLen = 30. * flRad;\n  t = 0.5 * tCur;\n  a1 = vec4 (0.1, 0.17, 0.15, 0.12);\n  a2 = vec4 (0.1, 0.5, -0.2, 0.2);\n  b1 = vec4 (0.8, 0.3, 0.5, 0.4);\n  b2 = vec4 (-1., 0.2, 0.3, -0.2);\n  for (int k = 0; k < 4; k ++) {\n    f = 0.1 * float (k);\n    flPth[k] = vec4 (4. + f + (1.5 + f) * t, sin ((0.11 + 0.1 * f) * t),\n       5. + 2. * f + (1.3 - f) * t, sin ((0.12 - 0.1 * f) * t));\n    for (int j = 0; j < 4; j ++) flPth[k][j] += (b1[j] + b2[j] * f) * sin (a1[j] + a2[j] * f * t);\n  }\n  tLitCyc = 50.;\n  t = 2. * pi * tCur / tLitCyc;\n  tm = mod (tCur / tLitCyc, 1.);\n  aRotTor = -1. * (0.01 * tLitCyc * t + 30. * (sin (t) - t));\n  torzFac = 0.8 + 0.2 * cos (t);\n  crExt = 0.05 * (-1. + sin (512. * tCur)) * SmoothBump (0.2, 0.8, 0.1, tm);\n  illTot = 0.;\n  for (int k = 0; k < 4; k ++) {\n    f = float (k);\n    illum[k] = step (torzFac, 0.95) * step (0.05, Noiseff (16. * tCur + f)) *\n       (0.3 + 0.7 * smoothstep (0.3, 0.9, Fbm1 (4. * tCur + f)));\n    illTot += illum[k];\n  }\n  st = mod (nSegTor * atan (ro.z, - ro.x) / (2. * pi) - aRotTor, 1.);\n  roo = ro;\n  glCol = mix (vec3 (0.9, 0.9, 0.3) * (0.97 + 0.03 * sin (64. * tCur)), vec3 (1., 1., 0.9),\n     SmoothBump (0.3, 0.7, 0.1, tm)) * (0.2 + 0.8 * SmoothBump (0.2, 0.8, 0.15, tm));\n  dstTrObj = TrObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    stg = vec3 (0.);\n    sp = length (vec2 (qHit.x, max (qHit.y, 0.))) - psgWd;\n    psgDir = (abs (ro.x) < abs (ro.z));\n    if (idObj == idDom) inBldg = (length (qHit) < domeRd);\n    else if (idObj == idDomB) inBldg = (sp < wThk || length (qHit.xz) < domeRd);\n    else if (idObj == idPsg) inBldg = (sp < 0.5 * wThk);\n    else if (idObj == idPilB) inBldg = (abs (qHit.x) < psgWd);\n    else if (idObj == idEnt) inBldg = (abs (qHit.z) < psgLen + 3.5 * wThk && sp < 0.);\n    else inBldg = true;\n    vf = vec2 (0.);\n    if (idObj == idDom) {\n      col4 = vec4 (0.7, 0.7, 0., 0.2) * (0.7 + 0.3 * step (0.5 * wThk,\n         abs (length (qHit) - domeRd)));\n    } else if (idObj == idDomB) {\n      if (qHit.y < 4. * ringWd + wThk) col4 = 0.7 * vec4 (0.8, 0.5, 0., 0.2);\n      else col4 = vec4 (0.8, 0.7, 0., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.05,\n         abs (mod (16. * qHit.y, 1.) - 0.5)));\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idPsg) {\n      col4 = vec4 (0.8, 0.5, 0., 0.05);\n      if (abs (sp) < wThk + 0.005) {\n        col4 *= 0.7;\n        if (abs (qHit.y + psgHt) < psgHt) {\n          if (abs (sp) > wThk - 0.005) stg = ro;\n          else col4 *= 0.7;\n        } else if (inBldg) col4 *= 0.9 + 0.1 * step (0.1, mod (32. * atan (ro.y - 2. * psgHt,\n           (psgDir ? ro.x : ro.z)) / pi, 1.));\n      } else col4.a = 0.2;\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idPilB) {\n      col4 = vec4 (0.55, 0.55, 0.6, 0.2);\n      vf = vec2 (64., 1.);\n    } else if (idObj == idPil) {\n      col4 = vec4 (0.55, 0.55, 0.6, 0.2);\n      a = mod (32. * (atan (qHit.z, - qHit.x) / (2. * pi)), 1.);\n      vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a * a));\n      vf = vec2 (128., 0.25);\n    } else if (idObj == idEnt) {\n      if (abs (abs (qHit.y + psgHt) - psgHt) < 0.5 * wThk) col4 = vec4 (0.5, 0.5, 0.6, 0.2);\n      else {\n        col4 = 0.7 * vec4 (0.8, 0.5, 0., 0.2);\n        if (abs (qHit.y + psgHt) < psgHt - 0.02) stg = ro;\n      }\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idFlor) {\n      col4 = vec4 (0.2, 0.2, 0.22, 0.1);\n      if (qHit.z > psgWd - 0.305) stg = vec3 ((psgDir ? ro.zx : ro.xz), ro.y).xzy;\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idSpkEx) {\n      col4 = mix (vec4 (0.5, 0.5, 0.6, 0.2), vec4 (0.8, 0.8, 0.2, -1.), step (0.05, illTot));\n    } else if (idObj == idTorL) {\n      col4 = vec4 (0.45, 0.5, 0.45, 0.2);\n      if (ro.y > 0.17) col4 *= (0.9 + 0.1 * sin (256. * atan (ro.z, - ro.x)));\n      else col4 *= (0.8 + 0.2 * sin (512. * ro.y));\n    } else if (idObj == idTorR) {\n      col4 = mix (vec4 (0.7, 0.7, 0., 0.), vec4 (1., 1., 1., 0.), 0.5 + 0.5 * sin (t)) *\n         (0.4 + 0.6 * SmoothBump (0.35, 0.65, 0.05, st * torzFac));\n    } else if (idObj == idTorC) {\n      col4 = mix (vec4 (0.6, 0.5, 0.5, 0.), mix (vec4 (1., 0., 0., 0.), vec4 (1., 1., 1., 0.),\n         0.5 + 0.5 * cos (t)), SmoothBump (0.25, 0.75, 0.1, st));\n    } else if (idObj == idTorS) {\n      col4 = vec4 (0.7, 0.6, 0.6, 0.) * (0.9 + 0.1 * sin (128. * atan (qHit.z, - qHit.y)));\n    } else if (idObj == idSpk) {\n      col4 = vec4 (vec3 (1., 1., 0.9) * clamp (2. * (0.1 + 0.9 * illTot) *\n         (1. - 0.3 * Fbm1 (5. * qHit.z)) - 0.2, 0., 1.), -1.);\n    } else {\n      col4 = vec4 (1., 1., 0., 0.2);\n    }\n    if (stg != vec3 (0.)) {\n      rg4 = ShStagGrid3d (10. * stg, vn);\n      vn = rg4.xyz;\n      col4.rgb *= 0.8 + 0.2 * rg4.w;\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (inBldg) {\n        dSum = 0.;\n        sSum = 0.;\n        for (int k = 0; k < 7; k ++) {\n          if (k < 6) {\n            ltPos = vec3 (0., 0.5 * psgHt, 0.8 * rTor);\n            ltPos.xz = Rot2D (ltPos.xz, 2. * pi * (- aRotTor + float (k) / 6.));\n            ltDirL = normalize (ltPos);\n            s = length (ltPos - ro);\n            att = 0.6 * max (dot (ltDirL, ltPos - ro) / s, 0.) / (1. + 0.1 * s * s);\n          } else {\n            ltDirL = - ltDir;\n            att = 0.5;\n          }\n          isMet = (idObj == idTorL || idObj == idTorR || idObj == idSpkEx);\n          nDotL = max (dot (vn, ltDirL), 0.);\n          if (isMet) nDotL *= nDotL;\n          dSum += att * nDotL;\n          sSum += att * pow (max (dot (normalize (ltDirL - rd), vn), 0.), 16.);\n        }\n        col = col4.rgb * (0.1 + 0.5 * dSum) + 0.5 * col4.a * sSum;\n        col = mix (col, vec3 (0.3, 0.3, 1.), 0.1 * (1. - smoothstep (0.7, 0.95, torzFac)));\n        if (idObj == idTorC || idObj == idTorS) col.r += ((idObj == idTorC) ? 0.5 : 0.2) *\n           max (- dot (rd, vn), 0.) * SmoothBump (0.3, 0.7, 0.1, tm);\n        if (idObj == idFlor || idObj == idDom) {\n          w = Rot2D (ro.xz, 2. * pi * aRotTor / nSegTor);\n          w = vec2 (abs (dot (w, sin (2. * pi * (floor (nSegTor * atan (w.y, - w.x) / (2. * pi)) +\n             0.5) / nSegTor + vec2 (0., 0.5 * pi)))), 0.5 * abs (length (ro.xz) - rTor - 0.1));\n          col += 0.2 * glCol * (1. - smoothstep (0.03, 0.12, length (w)));\n        }\n      } else {\n        col = col4.rgb * (0.2 + 0.4 * max (dot (vn, ltDir), 0.)) +\n           col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n      }\n    } else col = col4.rgb * (0.6 + 0.4 * max (- dot (rd, vn), 0.));\n  } else {\n    dstGrnd = - ro.y / rd.y;\n    if (rd.y < 0. && dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      psgDir = (abs (ro.x) < abs (ro.z));\n      f = smoothstep (0.1, 1., dstGrnd / dstFar);\n      col = vec3 (0.05, 0.07, 0.05) * (0.7 + 0.3 * Fbm2 (8. * ro.xz)) * (1. - f);\n      s = length (vec2 (abs (psgDir ? ro.xz : ro.zx) - vec2 (0., psgLen + 4. * wThk)));\n      col += (1. - smoothstep (-0.3, 0., s - 0.8 * psgWd)) * vec3 (0.2, 0.2, 0.3);\n      dstObj = dstGrnd;\n    } else {\n      f = 1.;\n      col = vec3 (0.);\n    }\n    col = mix (col, SkyCol (rd), f);\n  }\n  dstObj = min (dstObj, dstFar);\n  if (dstTrObj < dstObj) col += glCol * smoothstep (0., 0.1, dstObj - dstTrObj) *\n     (0.05 + 0.4 * clamp (- dot (TrObjNf (roo + dstTrObj * rd), rd), 0., 1.));\n  f = 1. - smoothstep (0.7, 0.95, torzFac);\n  if (f > 0.) {\n    ro = roo;\n    ro.yz = Rot2D (ro.yz, -0.5 * pi);\n    rd.yz = Rot2D (rd.yz, -0.5 * pi);\n    fBot = flLen - flRad + 0.4;\n    ro.z += fBot;\n    dCyl2 = CapsHit (ro, rd, flRad, flLen);\n    if (inBldg && col4.a >= 0.) col = clamp (col * vec3 (1. - 0.2 * f, 1. + 0.2 * f,\n       1. + 0.3 * f), 0., 1.);\n    if (dCyl2.x < dstObj && ro.z + dCyl2.x * rd.z < fBot - 0.1)\n       col += 3. * f * FlmCol (ro, rd, dCyl2, dstObj);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv, mMid[2], ut[2], mSize, msw;\n  float el, az, zmFac, asp, vuId, regId, s, t, sr;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./7.) * vec2 (asp, 1.);\n  mMid[0] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., -1.);\n  mMid[1] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (-1., -1.);\n  for (int k = 0; k < 2; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1.;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 2; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  vuId = 0.;\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = float (k + 1);\n      break;\n    }\n  }\n  if (regId > 0. && (vuId == 0. || vuId == regId)) vuId = regId - vuId;\n  vuMode = int (vuId) + 1;\n  if (vuMode == 1) {\n    t = mod (tCur / 30., 1.);\n    s = SmoothBump (0.25, 0.75, 0.2, t) - 0.5;\n    ro = vec3 (1.6 * sign (t - 0.5) * (0.5 - abs (s)), 1., 8. * s);\n    vd = normalize (vec3 (0., 0.5, 0.) - ro);\n    az = atan (vd.x, vd.z);\n    el = asin (vd.y);\n    if (t > 0.5) el += 0.35 * pi * (1. - smoothstep (0.05, 0.12, abs (abs (t - 0.5) - 0.25)));\n    zmFac = 3.;\n  } else if (vuMode == 2) {\n    az = 0.;\n    el = -0.05 * pi;\n    ro = vec3 (0., 1., -1.5);\n    zmFac = 1.5;\n  } else if (vuMode == 3) {\n    az = 0.02 * pi;\n    el = -0.05 * pi;\n    ro = vec3 (0., 1.5, -20.);\n    zmFac = 6.;\n  }\n  if (mPtr.z > 0.) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  el = clamp (el, -0.35 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  if (vuMode == 3) {\n    ro = vuMat * ro;\n    ro.y = max (0.5, ro.y);\n  }\n  dstFar = 60.;\n  ltDir = normalize (vec3 (0., 1., 0.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 2.) col = vec3 (0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{  // variation of triangular noise in \"Misty Flight\", adapted from nimitz's \"Oblivion\"\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 0.5;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttyzB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1166, 1166, 1189, 1189, 1621], [1623, 1623, 1645, 1645, 5573], [5575, 5575, 5608, 5608, 5792], [5794, 5794, 5815, 5815, 6070], [6072, 6072, 6096, 6096, 6426], [6428, 6428, 6463, 6463, 6648], [6650, 6650, 6673, 6673, 6930], [6932, 6932, 6989, 6989, 7864], [7866, 7866, 7890, 7890, 8248], [8250, 8250, 8308, 8357, 9289], [9291, 9291, 9326, 9349, 9802], [9804, 9804, 9827, 9827, 10371], [10373, 10373, 10399, 10399, 10726], [10728, 10728, 10765, 10765, 11328], [11330, 11330, 11365, 11365, 19686], [19730, 19730, 19786, 19786, 22454], [22456, 22456, 22488, 22488, 22588], [22590, 22590, 22623, 22623, 22650], [22652, 22652, 22694, 22694, 22745], [22747, 22747, 22769, 22769, 22796], [22798, 22798, 22820, 22820, 22847], [22849, 22849, 22871, 22871, 22909], [22911, 22911, 22956, 22956, 23059], [23061, 23061, 23106, 23106, 23144], [23146, 23146, 23203, 23203, 23286], [23288, 23288, 23324, 23324, 23530], [23532, 23532, 23562, 23562, 23675], [23677, 23677, 23703, 23703, 23765], [23767, 23767, 23792, 23792, 23854], [23856, 23856, 23881, 23967, 24231], [24265, 24265, 24289, 24289, 24349], [24351, 24351, 24375, 24375, 24440], [24442, 24442, 24466, 24466, 24519], [24521, 24521, 24545, 24545, 24657], [24659, 24659, 24683, 24683, 24802], [24804, 24804, 24829, 24829, 24975], [24977, 24977, 25002, 25002, 25188], [25190, 25190, 25215, 25215, 25440], [25442, 25442, 25464, 25464, 25618], [25620, 25620, 25641, 25641, 25796], [25798, 25798, 25827, 25827, 26039], [26041, 26041, 26080, 26080, 26260]], "test": "untested"}
{"id": "wttyRB", "name": "camera broke", "author": "jackwitherell", "description": "not a very good glitch shader just trying to figure out a few things and understand what i'm doin.", "tags": ["glitch", "webcam", "periodic"], "likes": 4, "viewed": 580, "published": 3, "date": "1609409008", "time_retrieved": "2024-07-30T20:27:23.610973", "image_code": "vec2 shift_uv(vec2 uv, vec2 range, float amount, bool range_horizontal, bool direction_horizontal){\n    vec2 diff;\n    if(range_horizontal && uv.y>range.x && uv.y<range.y){\n        if(direction_horizontal){\n            diff = vec2(amount, 0.0);\n        }\n        else{\n            diff = vec2(0.0, amount);\n        }\n    }\n    else if((!range_horizontal) && uv.x>range.x && uv.x<range.y){\n        if(direction_horizontal){\n            diff = vec2(amount, 0.0);\n        }\n        else{\n            diff = vec2(0.0, amount);\n        }\n    }\n    else{\n        diff = vec2(0.0, 0.0);\n    }\n    return diff;\n}\n\nbool randcheck(float a, float b, float c, float cap){\n    return mod(iDate.w, a)+mod(iDate.w, b)+mod(iDate.w, c)<cap;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ruv = uv;\n    vec3 col;\n    \n    if(mod(iTime,10.0)<0.3){ // 0.3s for every 10s blocker\n        \n        // some 'random' shifts\n        if(randcheck(1.7, 0.3, 2.6, 1.4)){\n            ruv += shift_uv(uv, vec2(0.5, 1.0), -mod(iTime,1800.0)*21.0, true, true);\n        }\n        if(randcheck(0.2, 0.7, 1.6, 1.0)){\n            ruv += shift_uv(uv, vec2(0.0, 0.3), mod(iTime,1800.0)*10.0, true, true);\n        }\n        if(randcheck(0.3, 0.1, 0.6, 0.5)){\n            ruv += shift_uv(uv, vec2(mod(iTime,1.0)-0.3, mod(iTime,1.0)), mod(iTime,1800.0)*10.0, false, true);\n        }\n        \n        // drop vertically occasionally\n        if(randcheck(0.2,0.3,0.5,0.3)){\n            ruv += shift_uv(uv, vec2(0.0,1.0), 0.3, true, false);\n        }\n        \n        col = texture(iChannel0, mod(ruv.xy,1.0)).rgb;\n        \n        // lighter zone\n        if(randcheck(0.5, 0.7, 0.9, 1.5)){\n            if(mod(uv.x+iTime,1.0)>0.3&&mod(uv.x+iTime,1.0)<0.5){\n                col+=0.5;\n            }\n        }\n        \n        // invert occasionally\n        if(randcheck(1.3, 2.1, 1.1, 1.8)){\n            col = 1.0-col;\n        }\n        \n    }\n    else{\n        col = texture(iChannel0, uv.xy).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 99, 99, 604], [606, 606, 659, 659, 725], [727, 727, 783, 783, 2078]], "test": "untested"}
{"id": "3l3yD7", "name": "Layers ball", "author": "z0rg", "description": "A raymarched ball :)", "tags": ["raymarching", "antialiasing", "mod"], "likes": 7, "viewed": 248, "published": 3, "date": "1609407005", "time_retrieved": "2024-07-30T20:27:24.364956", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// I used to develop it on my smartphone with ShaderEditor app\n// I just tweaked it to add a bit of antialising\n\nvec4 ppoo = vec4(1.0,1.0,0.0,0.0);\nvec4 EPS = vec4(0.01,0.0,0.0,0.0);\nfloat PI = 3.1415927;\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\n#define sat(a) clamp(a, 0., 1.)\n\nvec3  _repeat(vec3 p, vec3 sp)\n{\n  return mod(p,sp)-0.5*sp;\n}\n\nfloat sdf_sph(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nfloat sdf_rect(vec3 p, vec3 sz)\n{\n  vec3 diff = abs(p)-sz;\n  return max(diff.x, max(diff.y,diff.z));\n}\n\nvec3 lookAt(vec3 dir, vec2 uv)\n{\n  dir = normalize(dir);\n  vec3 right = cross(dir, ppoo.xzx);\n  vec3 up = cross(dir, right);\n\n  return dir+right*uv.x+up*uv.y;\n}\n\nfloat map(vec3 p)\n{\n  float s = sdf_sph(p,3.0);\n  float ss = sdf_sph(p,3.5);\n  p+= ppoo.zxz*sin(iTime*0.2)*4.0;\n  p= _repeat(p, vec3(2));\n  float tranche = max(sdf_rect(p, vec3(10,0.5,10)),ss);\n  return min(s,tranche);\n}\n\nvec3 normal(vec3 p)\n{\n  return vec3(map(p+EPS.xyy)-map(p-EPS.xyy),\n    map(p+EPS.yxy)-map(p-EPS.yxy),\n    map(p+EPS.yyx)-map(p-EPS.yyx));\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 p;\n  int steps = 256;\n  float maxD = 20.0;\n  vec3 pos;\n  float totD;\n  float r = 10.0;\n  vec3 orig = vec3(0.0,r*cos(1.0),r*sin(1.0));\n  vec3 dir = lookAt(vec3(0.0)-orig,uv);\n  p = orig;\n  for (int i = 0; i< steps&&totD <maxD;++i)\n  {\n    float d = map(p);\n    p += dir*d;\n    totD += d;\n    if (d < EPS.x)\n    {\n      vec3 norm = normalize(normal(p));\n      float isFlat = dot(abs(norm),ppoo.zxz);\n      if (isFlat + EPS.x>1.0)\n         return vec3(0.93,0.11,0.78);//0.5*norm +0.5;\n      vec3 light = vec3(-5,10.0*sin(iTime),10);\n      vec3 ldir = normalize(light-p);\n      vec3 h = normalize(dir+ldir);\n      vec3 lcol = vec3(0.67,0.56,0.68)*2.0;\n      return vec3(0.1,0.1,0.15)+lcol*pow(sat(dot(ldir,norm)),95.0)+pow(sat(dot(norm,h)),2.0)*lcol;\n    }\n  }\n  return vec3(-1.0);\n}\n\nvec3 rdrMain(vec2 uv)\n{\n  vec2 ntouch = 0.5*vec2(sin(iTime*0.4),cos(iTime*0.3));\n  float factCirc = float(1.0-float(sat(length(uv-ntouch)*5.5)));\n  uv -= factCirc*normalize(uv)*pow(length(uv),0.1)*0.5;\n  uv *= 2.0;\n  vec3 col = rdr(uv);\n  float isScene = float(col.x < 0.0);\n  col = sat(col);\n  float lstp = PI*0.2;\n  float hlstp = lstp*0.5;\n  float lines = mod(atan(uv.y,uv.x)+iTime*0.3,lstp);\n  float coef = float(lines < hlstp);\n  vec3 colLines =pow(length(uv)*2.0,0.5)*mix(vec3(0.53,0.64,0.89), vec3(0.1),coef);\n  col = mix(col, colLines, isScene);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  vec2 center = vec2(0.5)*iResolution.xy/iResolution.xx;\n  uv = uv - center;\n\n    vec3 col = rdrMain(uv);\n    \n        \n    float diff = pow(fwidth(col.z), .6);\n    //if (diff > 0.3) // No need to the shader is light enough to avoid it \n    { // Not so cheap antialiasing SSAA x4\n        //col = vec3(1.,0.,0.); // debug\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdrMain(uv-off.xx*rot);\n        acc += rdrMain(uv-off.xy*rot);\n        acc += rdrMain(uv-off.yy*rot);\n        acc += rdrMain(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[603, 603, 622, 622, 679], [714, 714, 746, 746, 775], [777, 777, 809, 809, 833], [835, 835, 868, 868, 937], [939, 939, 971, 971, 1099], [1101, 1101, 1120, 1120, 1321], [1323, 1323, 1344, 1344, 1462], [1464, 1464, 1483, 1483, 2270], [2272, 2272, 2295, 2295, 2840], [2842, 2842, 2899, 2899, 3717]], "test": "untested"}
{"id": "ttdczS", "name": "gaming chikuwa", "author": "bigdra50", "description": "ちくわ", "tags": ["3d", "gaming"], "likes": 2, "viewed": 238, "published": 3, "date": "1609404678", "time_retrieved": "2024-07-30T20:27:25.280508", "image_code": "#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define EPS 0.0001\n\nvec3 lightDir = vec3(1, 2, 3);\nfloat dSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\n\nfloat dRing(vec3 p, float inR, float exR, float height){\n    float sdf2d = abs(length(p.xy) - inR)-exR;\n    float d = abs(p.z)-height;\n    return max(sdf2d, d);\n}\n\n    \nfloat map(vec3 p){\n    p.xy *= rot(iTime*.5);\n    p.yz *= rot(iTime*.3);\n    return dRing(p, .2, .1, 1.);\n    return dSphere(p, .3);\n}\n\nvec3 getNormal(vec3 p){\n    return normalize(vec3(\n        map(p)-map(vec3(p.x-EPS, p.yz)),\n        map(p)-map(vec3(p.x, p.y-EPS, p.z)),\n        map(p)-map(vec3(p.xy, p.z-EPS))\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv  = (fragCoord*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 col = vec3(.2);\n    vec2 st = uv;\n\n    st*= rot(iTime*1.5);\n    col.xy += sin(st)+.8;\n    col.z += cos(st.y)*.6;\n    vec3 ro = vec3(0,0,10);\n    vec3 rd = normalize(vec3(uv, 0)-ro);\n    vec3 cur = ro;\n    for(int i = 0; i < 99; i++){\n        float d = map(cur);\n        if(d < EPS){\n            vec3 normal = getNormal(cur);\n            col += dot(normal, lightDir)+vec3(.1);\n            col *= vec3(cur.zxy+(sin(iTime*5.)+1.)*.05);\n            break;\n        }\n        cur += rd*d;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 135, 135, 161], [164, 164, 220, 220, 326], [333, 333, 351, 351, 467], [469, 469, 492, 492, 659], [661, 661, 718, 718, 1335]], "test": "untested"}
{"id": "tldcRS", "name": "Fractal Graffiti 3", "author": "jarble", "description": "An edit of one of my [url=https://www.shadertoy.com/view/tltcRS]\"Fractal graffiti\"[/url] shaders.", "tags": ["fractal"], "likes": 3, "viewed": 192, "published": 3, "date": "1609391181", "time_retrieved": "2024-07-30T20:27:26.030503", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y/10.0;\n        uv += iTime/10.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.0;\n        float scale1 = 1.4;\n        for(int i=0;i<20;i++)\n        {\n            \n            uv=sin(uv-(uv.yx/(2.0+sin((uv.x+uv.y)*(2.0)))/2.0)/scale)*scale/2.0+scale1*scale;\n            uv /= scale1;\n        \t//uv += cos(uv/100.0);\n        \tuv=uv.yx+col.xy;\n        }\n     col[c] = fract((uv.x)/(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 626]], "test": "untested"}
{"id": "wtdcRS", "name": "Nebula++", "author": "michael0884", "description": "nebula uh oh", "tags": ["nebula"], "likes": 30, "viewed": 1045, "published": 3, "date": "1609390662", "time_retrieved": "2024-07-30T20:27:27.007890", "image_code": "\n// FIXED Fork of \"Spectral Volumetric Nebula\" by Zi7ar21. https://shadertoy.com/view/tl3yD7\n// 2020-12-31 04:56:29\n\n// Fork of \"Fluffy Cloud\" by Zi7ar21. https://shadertoy.com/view/WlcyDn\n// 2020-12-29 04:35:14\n\n// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// Common is for Settings and Global Functions\n// Buffer A is for Rendering\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Spectral Volumetric Nebula --- December 28th, 2020\n// Updated December 28th, 2020 22:15 Mountain Time\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/tl3yD7\n// \n// Fork of \"Fluffy Cloud\" by Zi7ar21.\n// https://www.shadertoy.com/view/WlcyDn\n// December 27th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- August 8th, 2020\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- October 11th, 2020 / December 28th, 2020\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Rendering\n\n// Oof ugly mess below watch out lol\n\n//blue in screen, white in time\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\n// ##### NOISE #####\n// Cyclic Noise from https://www.shadertoy.com/view/wl3czN\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.1;\nvoid cyclicOctave(inout vec3 p, inout float rz, inout float z, inout float trk, inout float dspAmp){\n    p += sin(p.yzx*0.25*trk - trk*6.1 + cos(p*0.1 + 0.5)*1.0)*dspAmp;\n    float ofst = 4.6;\n    vec3 s = sin(p*1.3);\n    rz += smoothstep(-1.1, 0.5, dot(s, cos(p.yzx*0.95+s.xyz+ofst)))*z;\n    dspAmp *= 0.65;\n    z *= 0.45;\n    trk *= 1.45;\n    p *= m3;}\nfloat cyclic3D(vec3 p){\n    vec3 bp = p;\n    float rz = 0.0;\n    vec3 drv = vec3(0.0);  \n    float z = 1.44;\n    float trk= 1.0;\n    float dspAmp = 1.;\n    for (int i = 0; i<=NUM_OCTAVES; i++){\n        cyclicOctave(p, rz, z, trk, dspAmp);}\n    rz -= 1.1;\n    return rz;}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float density = max(0.0, cyclic3D(raypos)-distance(raypos, vec3(0.0, 0.0, 0.0)));\n   // vec3 rgb = vec3(clamp(-distance(raypos, vec3(0.0))+1.0, 0.0, 1.0));\n    return vec3(0.239,0.569,1.000)*density;\n}\n\n// ##### RAYMARCHING #####\nvec3 directLight(vec3 raypos, float dither){\n    vec3 LightColor = vec3(0.5);\n    vec3 LightDirection = normalize(vec3(sin(1.),cos(1.), 1.0));\n    float distorigin = 0.0;\n    vec3 density = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    raypos += dither*LightDirection*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++)\n    {\n        density = nebulanoise(raypos);\n        vec3 absorbance = exp(-ABSORPTION*density*STEP_SIZE);\n        attenuation *= absorbance;\n        if(length(attenuation) < 0.05) {attenuation *= 0.5; break;}\n        raypos = raypos+(LightDirection*STEP_SIZE);\n     }\n    return LightColor*attenuation;\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    //vec3 densityadd = vec3(0.0);\n    //vec3 density = vec3(0.0);\n    vec4 bnoise = rand4blue();\n    vec3 raypos = camerapos + raydir*bnoise.x*STEP_SIZE;\n    vec3 outCol = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+(raydir*STEP_SIZE);\n        // LoicVDB: don't use this, the density doesn't accumulate, its\n        // only purpose is to compute absorbance and transmittance\n        //densityadd = vec3(fractal(raypos)*DENSITY);\n        //density = vec3(density+densityadd);\n\n        // LoicVDB: just use this for density instead:\n        vec3 density = nebulanoise(raypos);\n        vec3 absorbance = exp(-ABSORPTION*density*STEP_SIZE);\n        vec3 transmittance = 1.0-exp(-SCATTERING*density*STEP_SIZE);\n        vec3 directlighting = attenuation*transmittance;\n        if(length(density) > 0.01){\n            directlighting *= directLight(raypos, bnoise.y);\n        }\n        else directlighting *= 0.1;\n        outCol += directlighting;\n        attenuation *= absorbance;\n        distorigin = distance(raypos, camerapos);\n        if(distorigin>MAX_DISTANCE || length(attenuation) < 0.1) break;\n    }\n    return outCol;//*attenuation;\n}\n\n// ##### RENDERING #####\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = TEMPORAL_ACCUMULATION*oldFragColor;\n\n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\n    // Start RNG\n    rng_initialize(fragCoord, iFrame);\n\n    // Camera Orientation\n    vec3 camerapos = vec3(0.0);\n    #ifdef ROTATION_MATRIX\n\t    // Dumb rotation matrix hecking Michael(yeet) made me make\n\t    float xrot = 0.5*iTime+atan(sqrt(2.0));\n\t    float yrot = pi;\n\t    float zrot = -pi/4.0 +2.*pi*iMouse.x/iResolution.x;\n\t    // Camera Orientation (Cursed)\n        mat3 dir;\n\t    dir[0] = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\t    dir[1] = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\t    dir[2] = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,1.0,0.0);\n        vec3 zdir = vec3(0.0,0.0,1.0);\n    #endif\n    camerapos -=6.*dir*vec3(0,0,1);\n    \n    for(int i = 0; i < SPP; i++)\n    {\n        // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n        vec2 fragCoordDithered = fragCoord+(rand4blue().xy-0.5);\n        vec2 uv = (fragCoordDithered-0.5*iResolution.xy)/iResolution.x;\n        #ifdef ROTATION_MATRIX\n            vec3 raydir = normalize(FOV*(uv.x*dir[0]+uv.y*dir[1])+dir[2]);\n        #endif\n        #ifndef ROTATION_MATRIX\n            vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n        #endif\n        vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n        // Output\n        fragColor += vec4(raymarched, 1.0);\n    }\n   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Settings and Global Functions\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 24\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 8.0\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.35\n\n// Camera's FOV\n#define FOV 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n#define ROTATION_MATRIX\n\n// Density of the volume. Changes how much light it scatters.\n#define SCATTERING 64.0\n#define ABSORPTION 15.0\n\n// Cyclic Noise Octaves, more is more detailed with exponentially deminishing return.\n#define NUM_OCTAVES 8\n\n// Tiles, more means easier on the Hardware\n#define TILES 1 // Set to 1 if you have a computer that can handle it so it will render faster\n// So kindly made by LoicVDB uwu\n\n//SPP\n#define SPP 1\n\n#define TEMPORAL_ACCUMULATION 0.1\n\n// Yummy, Pi! 32-Bit Floating Point Precision limits us to 3.14159265, but hey one day Shadertoy\n// may support double precision so why not throw in 3589793.\n#define pi 3.141592653589793\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1);\n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n    \n// Spectral Coloration\nfloat saturate(float x){\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate(vec3 x){\n    return min(vec3(1.0,1.0,1.0), max(vec3(0.0,0.0,0.0),x));\n}\nvec3 bump3y(vec3 x, vec3 yoffset){\n\tvec3 y = vec3(1.0,1.0,1.0) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi6(float w){\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1380, 1380, 1436, 1486, 1593]], "test": "untested"}
{"id": "wltcRS", "name": "RNG utilities", "author": "michael0884", "description": "Should be pretty high quality RNG.\nMight be useful.", "tags": ["rng"], "likes": 28, "viewed": 1234, "published": 3, "date": "1609389088", "time_retrieved": "2024-07-30T20:27:27.936407", "image_code": "//blue in screen, white in time\nvec4 rand4blue()\n{\n    return texelFetch(iChannel0, shift2(), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    \n    // Output to screen\n    fragColor = (fragCoord.x < iResolution.x*0.5)?rand4():rand4blue();\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 32, 50, 50, 99], [101, 101, 158, 158, 299]], "test": "untested"}
{"id": "tltcRS", "name": "Fractal Graffiti 2", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/wt3cW7#]\"Fractal Graffiti\"[/url] shader.", "tags": ["fractal"], "likes": 2, "viewed": 326, "published": 3, "date": "1609388719", "time_retrieved": "2024-07-30T20:27:28.993581", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y/10.0;\n        uv += iTime/10.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.0;\n        float scale1 = 1.4;\n        for(int i=0;i<20;i++)\n        {\n            \n            uv=sin(uv-(uv.yx/(2.0+sin((uv.x+uv.y)*(2.0)))/2.0)/scale)*scale/2.0+scale1*scale;\n            uv /= scale1;\n        \t//uv += cos(uv/100.0);\n        \tuv=uv+col.xy;\n        }\n     col[c] = fract((uv.x)/(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "sound_code": "vec2 sound1(int t)\n{\n    //t = t|t/2/4096;\n    //t = (t>>(t/(2+(t/4096)%3+(t/4096)%2)))|t>>4&t>>5|t>>6|t/2/4096;\n    \n    t = (t>>(t/(2+(t/4096)%3+(t/4096)%2)))|t/2/4096|t/3/4096;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltcRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 623]], "test": "untested"}
{"id": "3ltyRB", "name": "Joe Gardner (Soul Pixar)", "author": "leon", "description": "Joe Gardner from Soul (Pixar 2020)\nSpent the night building this little guy after watching the movie", "tags": ["pixar", "soul"], "likes": 76, "viewed": 2570, "published": 3, "date": "1609385636", "time_retrieved": "2024-07-30T20:27:29.844306", "image_code": "// Joe Gardner from Soul (Pixar 2020)\n//\n// by Leon Denise 2020.12.31\n// \n// thanks to Inigo Quilez, Dave Hoskins, Koltes, NuSan\n// for sharing useful lines of code\n//\n// Licensed under hippie love conspiracy\n\nbool ao_pass = false;\n\n// volumes description\nVolume map(vec3 pos)\n{\n    float shape = 100.;\n\n    // global twist animation\n    pos.zy *= rot(sin(pos.y*.2 + time) * .1 + .2);\n    pos.yx *= rot(0.1 * sin(pos.y * .3 + time));\n    vec3 p = pos;\n\n    Volume ghost;\n    ghost.mat = 0;\n    ghost.density = 0.05;\n    ghost.space = 0.12;\n    \n    Volume opaque;\n    opaque.mat = 0;\n    opaque.density = 1.;\n    opaque.space = 0.;\n    \n    Volume hair;\n    hair.mat = mat_eyebrows;\n    hair.density = .2;\n    hair.space = 0.1;\n    \n    Volume glass;\n    glass.mat = mat_glass;\n    glass.density = .15;\n    glass.space = 0.1;\n\n    // head\n    ghost.dist = length(p*vec3(1,0.9,1))-1.0;\n    ghost.dist = opSmoothUnion(ghost.dist, length(p-vec3(0,1.2,0))-0.55, 0.35);\n    \n    // mouth\n    p.z += 1.3;\n    p.yz *= rot(p.z * .5 + 0.1*sin(time+p.z*4.));\n    shape = sdBox(p, vec3(1,0.01,1.));\n    shape = max(shape, -length(pos.xz)+.99);\n    ghost.dist = opSmoothSubtraction(shape, ghost.dist, 0.1);\n\n    // hat\n    p = pos-vec3(0,1.6,0);\n    shape = sdRoundedCylinder(p + sin(p.z*4.)*.03, .4, .01, .01);\n    shape = min(shape, sdCappedCone(p+.05*sin(p.z*8.), vec3(0,.5,0), vec3(0), .3, .445));\n    ghost.dist = min(ghost.dist, shape);\n\n    // eyes globes\n    p = pos-vec3(0,1.,-.55);\n    float s = sign(p.x);\n    p.xz *= rot(-pos.x*1.);\n    p.x = abs(p.x)-.15;\n    opaque.dist = max(length(p*vec3(1,1.,1.3))-0.18, -ghost.dist);\n    opaque.mat = mat_eye_globe;\n\n    // eyebrows\n    p -= vec3(0.05,.3,-.03);\n    p.y -= 0.01*sin(time*3.);\n    p.xy *= rot(0.2 + sin(pos.x * 2. + time)*.5);\n    shape = sdBox(p, vec3(.15,0.02-p.x*.1,.03));\n    hair.dist = shape;\n\n    // body\n    p = pos;\n    ghost.dist = opSmoothUnion(ghost.dist, length(p+vec3(0,1.8,0))-.5, 0.6);\n\n    // legs\n    p.x = abs(p.x)-.2;\n    p.z += 0.1*sin(p.x*4. + time);\n    ghost.dist = opSmoothUnion(ghost.dist, sdVerticalCapsule(p+vec3(0,2.8,0), 0.6, 0.01+max(0.,p.y+3.)*0.3), 0.2);\n\n    // arms\n    p = pos;\n    p.x = abs(p.x)-.4;\n    p.xy *= rot(3.14/2.);\n    p.x += pos.x*0.2*sin(pos.x + time);\n    ghost.dist = opSmoothUnion(ghost.dist, sdVerticalCapsule(p+vec3(-1.5,0,0), 0.6, 0.2), 0.2);\n    \n    Volume volume = select(select(ghost, opaque), hair);\n\n    // glass\n    if (!ao_pass)\n    {\n        p = pos-vec3(0,1.,-.65);\n        p.x = abs(p.x)-.18;\n        glass.dist = sdRoundBox(p+vec3(-0.1,0,.1), vec3(0.2+p.y*0.1, 0.15+p.x*.05, 0.001), 0.05);\n        glass.dist = max(glass.dist, -sdRoundBox(p+vec3(-0.1,0,.1), vec3(0.18+p.y*0.1, 0.14+p.x*.05, 0.1), 0.05));\n        glass.dist = max(glass.dist, abs(p.z)-.1);\n        volume = select(volume, glass);\n    }\n\n    return volume;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p).dist-vec3(map(p-off.xyy).dist, map(p-off.yxy).dist, map(p-off.yyx).dist));\n}\n\n// Inigo Quilez\n// https://www.shadertoy.com/view/Xds3zN\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        Volume volume = map( pos + h*nor );\n        float d = volume.dist;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    color = vec4(0,0,0,0);\n    \n    // coordinates\n    vec2 uv = coordinate / iResolution.xy;\n    vec2 p = 2.*(coordinate - 0.5 * iResolution.xy)/iResolution.y;\n    \n    // camera\n    vec3 pos = vec3(-5,0,-8);\n    \n    // look at\n    vec3 z = normalize(vec3(0,-0.3,0)-pos);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(z * 3. + x * p.x + y * p.y);\n    \n    // background gradient\n    color.rgb += vec3(0.2235, 0.3804, 0.5882) * uv.y;\n    \n    // render variables\n    float shade = 0.0;\n    vec3 normal = vec3(0,1,0);\n    float ao = 1.0;\n    float rng = hash12(coordinate + time);\n    const int count = 30;\n    \n    // raymarch iteration\n    for (int index = 0; index < count; ++index)\n    {\n        Volume volume = map(pos);\n        if (volume.dist < 0.01)\n        {\n            // sample ao when first hit\n            if (shade < 0.001)\n            {\n                ao_pass = true;\n                ao = getAO(pos, normal);\n                ao_pass = false;\n            }\n            \n            // accumulate fullness\n            shade += volume.density;\n            \n            // step further on edge of volume\n            normal = getNormal(pos);\n            float fresnel = pow(dot(ray, normal)*.5+.5, 1.2);\n            volume.dist = volume.space * fresnel;\n            \n            // coloring\n            vec3 col = vec3(0);\n            switch (volume.mat)\n            {\n                // eye globes color\n                case mat_eye_globe:\n                float globe = dot(normal, vec3(0,1,0))*0.5+0.5;\n                vec3 look = vec3(0,0,-1);\n                look.xz *= rot(sin(time)*0.2-.2);\n                look.yz *= rot(sin(time*2.)*0.1+.5);\n                float pupils = smoothstep(0.01, 0.0, dot(normal, look)-.95);\n                col += vec3(1)*globe*pupils;\n                break;\n\n                // eyebrows color\n                case mat_eyebrows:\n                col += vec3(0.3451, 0.2314, 0.5255);\n                break;\n\n                // glass color\n                case mat_glass:\n                col += vec3(.2);\n                break;\n\n                // ghost color\n                default:\n                vec3 leftlight = normalize(vec3(6,-5,1));\n                vec3 rightlight = normalize(vec3(-3,1,1));\n                vec3 frontlight = normalize(vec3(-1,1,-2));\n                vec3 blue = vec3(0,0,1) * pow(dot(normal, leftlight)*0.5+0.5, 0.2);\n                vec3 green = vec3(0,1,0) * pow(dot(normal, frontlight)*0.5+0.5, 2.);\n                vec3 red = vec3(0.8941, 0.2039, 0.0824) * pow(dot(normal, rightlight)*0.5+0.5, .5);\n                col += blue + green + red;\n                col *= ao*0.5+0.3;\n                break;\n            }\n            \n            // accumulate color\n            color.rgb += col * volume.density;\n        }\n        \n        // stop when fullness reached\n        if (shade >=  1.0)\n        {\n            break;\n        }\n        \n        // dithering trick inspired by Duke\n        volume.dist *= 0.9 + 0.1 * rng;\n        \n        // keep marching\n        pos += ray * volume.dist;\n    }\n}", "image_inputs": [], "common_code": "\n#define time iTime\n#define repeat(p,r) (mod(p+r/2.,r)-r/2.)\n\n// details about sdf volumes\nstruct Volume\n{\n    float dist;\n    int mat;\n    float density;\n    float space;\n};\n\n// union operation between two volume\nVolume select(Volume a, Volume b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n// materials\nconst int mat_eye_globe = 1;\nconst int mat_pupils = 2;\nconst int mat_eyebrows = 3;\nconst int mat_iris = 4;\nconst int mat_glass = 5;\n\n// Rotation 2D matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltyRB.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[233, 256, 278, 278, 2846], [2848, 2898, 2922, 2922, 3049], [3051, 3108, 3149, 3149, 3490], [3492, 3492, 3546, 3546, 6684]], "test": "untested"}
{"id": "3ttyzB", "name": "Alien skull fractal", "author": "jarble", "description": "An edit of [url=https://www.shadertoy.com/view/WlcczS]\"Fractal radio base.\"[/url] I edited the [code]farctal[/code] function in the \"Common\" buffer to make this structure.", "tags": ["fractal", "skull"], "likes": 16, "viewed": 632, "published": 3, "date": "1609376437", "time_retrieved": "2024-07-30T20:27:30.823688", "image_code": "float map(vec3 p){\n\tp.xy *= rot(sin(iTime*.3)/.3);\n    p.yz *= rot(sin(iTime*.4)/.4);\n    return farctal(p,iTime);\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1)*.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<150;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth=march(light,ld,.01,len);\t\n\treturn step(len-depth,.01);\n}\n\nvec4 depth_map(vec2 coord)\n{\n    return texelFetch(iChannel0,ivec2(coord/image_scale),0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 ro = camera;\n    vec3 rd = normalize(vec3(uv,-2.));\n    vec3 col = vec3(0);\n    // get depth from depth map.\n    // place the ray start position just before the primitive\n    float t = march(ro,rd,max(0.,depth_map(fragCoord).x-3.),maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=vec3(.9,.5,.2)*1.5;\n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=vec3(20);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),.5,1.);\n        // get shadow from depth map\n        //float sha=depth_map(fragCoord).y;\n        float sha=calcShadow(lightPos,-li,len);\n        col*=max(sha*dif,.4);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.9;\n        col*=max(.5+.5*n.y,0.);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.3)/.3),2.));\n        col+=vec3(.5,.9,.9)*pow(clamp(dot(reflect(rd,n),li),0.,1.),8.);\n    }\n    fragColor=vec4(col,1);\n    \n    //fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n}", "image_inputs": [], "common_code": "#define image_scale 4.0\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define camera vec3(0,0,6)\n#define maxd 30.0\n\nfloat farctal(vec3 p,float iTime){\n\tfloat s=4.;\n\tp=abs(p);\n\tvec3 off=p*4.6;\n\tfor (float i=0.; i<8.; i++){\n        p=1.-abs(abs(p-2.+sin(p))-1.); \n    \tfloat r=-(12.)*clamp(.38*max(1.3/dot(p,p),.7),0.,3.3);\n        s*=r;\n\t\tp*=r;\n        p+=off;\n    }\n    //s=abs(s);\n\treturn length(cross(p,normalize(vec3(1,3,3))))/s-.006;\n}\n", "buffer_a_code": "float map(vec3 p){\n\tp.xy *= rot(sin(iTime*.3)/.3);\n    p.yz *= rot(sin(iTime*.4)/.4);\n    return farctal(p,iTime);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<200;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth=march(light,ld,.01,len);\t\n\treturn step(len-depth,.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Reduce the size of the depth buffer texture\n    //fragCoord*=image_scale;\n    //if (any(greaterThan(fragCoord,iResolution.xy)))discard;\n\n    fragCoord*=image_scale;\n    if (all(lessThanEqual(fragCoord,iResolution.xy)))\n    {\n    \n        vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        vec3 ro = camera;\n        vec3 rd = normalize(vec3(uv,-2.));\n        vec3 col = vec3(0);\n        float t = march(ro,rd,.0,maxd);\n        \n        fragColor.x=t;\n        /*\n        if(t<maxd)\n        {\n            vec3 p=ro+rd*t;\n            vec3 lightPos=vec3(20);\n            vec3 li=lightPos-p;\n            float len=length(li);\n            li/=len;\n            float sha=calcShadow(lightPos,-li,len);\n            fragColor.x=t;\n            fragColor.y=sha;\n        }\n        */\n    }\n}", "buffer_a_inputs": [], "sound_code": "vec2 sound1(int t)\n{\n    //t = t|t>>2/4096|t>>3/4096;\n    t = (t>>(t/(2+(t/4096)%3+(t/4096)%2)))|t/2/4096|t/3/4096;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttyzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 116], [118, 118, 144, 144, 293], [295, 295, 349, 349, 515], [517, 517, 569, 569, 639], [641, 641, 669, 669, 732], [734, 734, 791, 791, 1870]], "test": "untested"}
{"id": "WttcRB", "name": "4D Fractal Noise", "author": "oneshade", "description": "Why would anyone need 4D noise?", "tags": ["noise", "4d", "fractalnoise"], "likes": 11, "viewed": 459, "published": 3, "date": "1609375685", "time_retrieved": "2024-07-30T20:27:31.754200", "image_code": "#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\n// New hash based on hash13() from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat noise(in vec4 p) {\n\tp = fract(p * 0.1031);\n    p += dot(p, p.zwyx + 31.32);\n    return fract((p.x + p.y) * p.z - p.x * p.w);\n}\n\nfloat snoise(in vec4 p) {\n    vec4 cell = floor(p);\n    vec4 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldbq = noise(cell);\n    float rdbq = noise(cell + vec4(1.0, 0.0, 0.0, 0.0));\n    float ldfq = noise(cell + vec4(0.0, 0.0, 1.0, 0.0));\n    float rdfq = noise(cell + vec4(1.0, 0.0, 1.0, 0.0));\n    float lubq = noise(cell + vec4(0.0, 1.0, 0.0, 0.0));\n    float rubq = noise(cell + vec4(1.0, 1.0, 0.0, 0.0));\n    float lufq = noise(cell + vec4(0.0, 1.0, 1.0, 0.0));\n    float rufq = noise(cell + vec4(1.0, 1.0, 1.0, 0.0));\n    float ldbw = noise(cell + vec4(0.0, 0.0, 0.0, 1.0));\n    float rdbw = noise(cell + vec4(1.0, 0.0, 0.0, 1.0));\n    float ldfw = noise(cell + vec4(0.0, 0.0, 1.0, 1.0));\n    float rdfw = noise(cell + vec4(1.0, 0.0, 1.0, 1.0));\n    float lubw = noise(cell + vec4(0.0, 1.0, 0.0, 1.0));\n    float rubw = noise(cell + vec4(1.0, 1.0, 0.0, 1.0));\n    float lufw = noise(cell + vec4(0.0, 1.0, 1.0, 1.0));\n    float rufw = noise(cell + 1.0);\n\n    return mix(mix(mix(mix(ldbq, rdbq, local.x),\n                       mix(lubq, rubq, local.x),\n                       local.y),\n\n                   mix(mix(ldfq, rdfq, local.x),\n                       mix(lufq, rufq, local.x),\n                       local.y),\n\n                   local.z),\n\n               mix(mix(mix(ldbw, rdbw, local.x),\n                       mix(lubw, rubw, local.x),\n                       local.y),\n\n                   mix(mix(ldfw, rdfw, local.x),\n                       mix(lufw, rufw, local.x),\n                       local.y),\n\n                   local.z),\n\n               local.w);\n}\n\nfloat fnoise(in vec4 p, in float scale, in float octaves) {\n    p *= scale;\n    float nscale = 1.0;\n    float tscale = 0.0;\n    float value = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    float octaves = 4.0;\n    float threshold = 0.4;\n\n    if (iMouse.z > 0.0) {\n        octaves = iMouse.y / iResolution.y * 4.0;\n        threshold = iMouse.x / iResolution.x * 0.9;\n    }\n\n    vec3 q = abs(p) - 1.5;\n    float bbox = max(q.x, max(q.y, q.z));\n\n    return max(fnoise(vec4(p, iTime * 0.5), 2.0, octaves) - threshold, bbox);\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0), rd = normalize(vec3(uv, -1.0)), p;\n    float t = 0.0, d;\n    bool hit = false;\n\n    for (int iter=0; iter < 100; iter++) {\n        p = ro + rd * t;\n\n        p.y -= 0.3;\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        d = mapScene(p);\n        if (d < 0.001) {\n            hit = true;\n            break;\n        }\n\n        if (t > 10.0) {\n            break;\n        }\n\n        t += d;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p);\n        fragColor.rgb += 0.5 + 0.5 * n;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttcRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 169, 193, 193, 301], [303, 303, 328, 328, 1904], [1906, 1906, 1965, 1965, 2250], [2252, 2252, 2279, 2279, 2617], [2619, 2619, 2646, 2646, 2893], [2895, 2895, 2950, 2950, 3675]], "test": "untested"}
{"id": "WldyRB", "name": "counteraction", "author": "gschian0", "description": "shader experiments", "tags": ["warping", "psychedelic", "cosine"], "likes": 1, "viewed": 301, "published": 3, "date": "1609371504", "time_retrieved": "2024-07-30T20:27:32.921080", "image_code": "#define PI 3.1415926535897932384626433832795\n#define TWOPI 6.283185307179586\n\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n    \n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = abs((2.*fragCoord.xy/iResolution.xy*2.-2.));\n    //vec2 st = fragCoord.xy/iResolution.xy;\n    st *= vec2(length(0.1*st),atan(st.y,st.x/iTime));\n    float noise1 = noise(st+0.3*iTime);\n    st.x *= iResolution.x/iResolution.y;\n    st.x += sin(1.0*st.y+iTime)*0.5+0.5;\n   // st.y = sin(2.0*st.x-u_time);\n    st *= vec2(length(st.x*st.y*noise1+sin(st.y*iTime)*0.5+0.5),atan(st.y+sin(st.x*iTime*.003)*0.5+-0.5,st.x-sin(iTime*.03*noise1)*0.5+0.5)/PI/8.*noise1);\n    float d = length(st-vec2(0.003*(1.*sin(sin(st.y+sin(iTime)*0.01*noise1)))*0.5+0.5,0.18*(sin(st.x+sin(iTime)*0.5+0.5*.01*noise1+0.3*0.5))));\n    st.y+= log(abs(sin(iTime*.3)));\n    st.x += log(abs(sin(iTime*0.3)));\n    float circle = 1.-smoothstep(0.6,0.99,d);\n    \n//    for(float i = 0.07; i < 1.0; i += .1){\n//    \n//        circle += smoothstep(0.06+i, 0.061,d+i);\n//    }\n    vec3 color = vec3(abs(cos(1.0*st.y/d+iTime)),abs(sin(1.0*st.x/d-iTime)),abs(cos(10.0*st.y-st.x/d-iTime)));\n    //white\n    fragColor = 1.-vec4(vec3(circle)*color,1.0);\n    //black\n     // gl_FragColor = vec4(vec3(circle)*color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 100, 100, 170], [172, 172, 192, 192, 431], [433, 433, 487, 487, 1576]], "test": "untested"}
{"id": "3tdyRB", "name": "Nebula and Plexus are friends", "author": "Nabuki", "description": "Quik and dirty combination of these two shaders: \nhttps://www.shadertoy.com/view/MtcGDf\nhttps://www.shadertoy.com/view/wtcXWr", "tags": ["nebulaplexus"], "likes": 37, "viewed": 1396, "published": 3, "date": "1609370204", "time_retrieved": "2024-07-30T20:27:33.833640", "image_code": "const float FLIGHT_SPEED = 6.0;\n\nconst float FIELD_OF_VIEW = 1.05;\n\n\nvec3 getRayDirection(vec2 fragCoord, vec3 cameraDirection) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \n    const float screenWidth = 1.0;\n    float originToScreen = screenWidth / 2.0 / tan(FIELD_OF_VIEW / 2.0);\n    \n    vec3 screenCenter = originToScreen * cameraDirection;\n    vec3 baseX = normalize(cross(screenCenter, vec3(0, -1.0, 0)));\n    vec3 baseY = normalize(cross(screenCenter, baseX));\n    \n    return normalize(screenCenter + (uv.x - 0.5) * baseX + (uv.y - 0.5) * iResolution.y / iResolution.x * baseY);\n}\n\nvec4 getNebulaColor(vec3 globalPosition, vec3 rayDirection) {\n    vec3 color = vec3(0.0);\n    float spaceLeft = 1.0;\n    \n    const float layerDistance = 10.0;\n    float rayLayerStep = rayDirection.z / layerDistance;\n    \n    const int steps = 4;\n    for (int i = 0; i <= steps; i++) {\n      vec3 noiseeval = globalPosition + rayDirection * ((1.0 - fract(globalPosition.z / layerDistance) + float(i)) * layerDistance / rayDirection.z);\n      noiseeval.xy += noiseeval.z;\n        \n        \n        float value = 0.06 * texture(iChannel0, fract(noiseeval.xy / 60.0)).r;\n         \n        if (i == 0) {\n            value *= 1.0 - fract(globalPosition.z / layerDistance);\n        } else if (i == steps) {\n            value *= fract(globalPosition.z / layerDistance);\n        }\n                \n        color += spaceLeft * 2. * vec3(value, value, value) * vec3(.5, .3, 0.1);\n        spaceLeft = max(0.0, spaceLeft - value * 2.0);\n    }\n    return vec4(color, 1.0);\n}\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n  vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n  float d = distLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n  vec2 e0 = p1 - p0;\n  vec2 e1 = p2 - p1;\n  vec2 e2 = p0 - p2;\n\n  vec2 v0 = p - p0;\n  vec2 v1 = p - p1;\n  vec2 v2 = p - p2;\n\n  vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n  vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n  vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n  return -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c){\n  float d = distTriangle(p, a, b, c);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat N21(vec2 p){\n  p = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p){\n  float n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset){\n    vec2 n = N22(id + offset) * iTime;\n    return offset + sin(n) * 0.4;\n}\n\nfloat layer(vec2 uv){\n  vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++){\n      for(float x = -1.0; x <= 1.0; x++){\n          p[i++] = getPos(id, vec2(x, y));\n      }    \n    }\n    \n    \n    float t = iTime * 10.0;\n    float m = 0.0;\n    for(int i = 0; i < 9; i++){\n      m += line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) * 20.0;\n        float sparkle = 1.0 / dot(j, j);\n        \n        m += sparkle * (sin(t + fract(p[i].x) * 10.0) * 0.5 + 0.5);\n        \n        for(int yi= i + 1; yi < 9; yi++){\n        for(int zi= yi + 1; zi < 9; zi++){\n                \n                float len1 = abs(length(p[i] - p[yi]));\n                float len2 = abs(length(p[yi] - p[zi]));\n                float len3 = abs(length(p[i] - p[zi]));\n                \n                if((len1 + len2 + len3) < 2.8){\n                  m += triangle(gv, p[i], p[yi], p[zi]) * 0.8;\n                }\n        }\n      }\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[7], p[3]);\n    m += line(gv, p[7], p[5]);\n\n    return m;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //nebula\n    vec3 movementDirection = normalize(vec3(0.01, 0.0, 1.0));\n    \n    vec3 rayDirection = getRayDirection(fragCoord, movementDirection);\n    \n    vec3 globalPosition = vec3(3.14159, 3.14159, 0.0) + (iTime + 1000.0) * FLIGHT_SPEED * movementDirection;\n    \n    fragColor = getNebulaColor(globalPosition, rayDirection);\n    \n    // plexus\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float m = 0.0;\n    float t = iTime * 0.1;\n        \n    for(float i = 0.0; i < 1.0; i += 1.0 / 4.0){\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0.0, 0.1, z) * S(1.0, 0.8, z);\n        \n        m += layer(uv * size + i * 20.0) * fade;\n    }\n    \n    \n    vec3 base = vec3(0.5, 0.3, 0.1);\n    vec3 col = m * base * 0.1;\n    \n    col -= uv.y * 0.5 * base;\n        \n    fragColor += vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n\n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    float snoise(vec3 v)\n      { \n      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n      vec3 i  = floor(v + dot(v, C.yyy) );\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n\n      //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n      //   x1 = x0 - i1  + 1.0 * C.xxx;\n      //   x2 = x0 - i2  + 2.0 * C.xxx;\n      //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n      vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n      i = mod289(i); \n      vec4 p = permute( permute( permute( \n                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n      float n_ = 0.142857142857; // 1.0/7.0\n      vec3  ns = n_ * D.wyz - D.xzx;\n\n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n\n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n\n      //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n      //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n\n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n\n    // Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                    dot(p2,x2), dot(p3,x3)));\n\t}\n\nfloat tilingNoise(vec2 position, float size) {\n    float value = snoise(vec3(position * size, 0.0));\n    \n    float wrapx = snoise(vec3(position * size - vec2(size, 0.0), 0.0));    \n    value = mix(value, wrapx, max(0.0, position.x * size - (size - 1.0)));\n\n    float wrapy = snoise(vec3(position * size - vec2(0.0, size), 0.0));\n    float wrapxy = snoise(vec3(position * size - vec2(size, size), 0.0)); \n    wrapy = mix(wrapy, wrapxy, max(0.0, position.x * size - (size - 1.0)));\n\treturn mix(value, wrapy, max(0.0, position.y * size - (size - 1.0)));\n}\n\nvoid initialize(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    const int octaves = 6;\n    \n    float value = 0.0;\n  \tfloat maxValue = 0.0; \n    for (float octave = 0.0; octave < float(octaves); octave++) {\n    \tvalue += pow(2.0, -octave) * tilingNoise(uv, 8.0 * pow(2.0, octave));\n        maxValue += pow(2.0, -octave);\n    }\n    \n    maxValue *= 0.5;\n    \n    fragColor = vec4(0.5 * (1.0 + value / maxValue) * vec3(1.0), 1.0);\n    fragColor.g = iResolution.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    if (fragColor.g != iResolution.x) {\n    \tinitialize(fragColor, fragCoord);\n    }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 129, 129, 592], [594, 594, 655, 655, 1556], [1598, 1598, 1637, 1637, 1767], [1769, 1769, 1804, 1804, 1978], [1980, 1980, 2048, 2048, 2667], [2669, 2669, 2716, 2716, 2897], [2899, 2899, 2917, 2917, 3015], [3017, 3017, 3034, 3034, 3088], [3090, 3090, 3124, 3124, 3199], [3201, 3201, 3222, 3222, 4326], [4329, 4329, 4384, 4397, 5256]], "test": "untested"}
{"id": "WttczS", "name": "Test Turned Demo?!?", "author": "oneshade", "description": "Messing with point lights turned into this?!?", "tags": ["glow", "neon", "cool", "happyaccident"], "likes": 3, "viewed": 200, "published": 3, "date": "1609363207", "time_retrieved": "2024-07-30T20:27:34.885829", "image_code": "struct Light {\n    vec3 pos; // Position of the light\n    vec3 col; // Color of the light\n};\n\nmat2 Rotate(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat noise(in float x) {\n    return fract(sin(x * 12.5673) * 573.123);\n}\n\nfloat snoise(in float x) {\n    float r = 2.735;\n\n    float y1 = noise(floor(x / r) * r);\n    float y2 = noise(ceil(x / r) * r);\n    float i = fract(x / r);\n    i *= i * (3.0 - 2.0 * i);\n\n    return mix(y1, y2, i);\n}\n\nfloat mapScene(in vec3 p) {\n    p.xz = mod(p.xz - 2.0, 4.0) - 2.0;\n    p.yz *= Rotate(-60.0);\n    p.xz *= Rotate(iTime);\n\n    vec3 q1 = abs(p) - 1.2;\n    float box = max(q1.x, max(q1.y, q1.z));\n\n    vec2 q2 = abs(p.xy) - 0.8;\n    vec2 q3 = abs(p.xz) - 0.8;\n    vec2 q4 = abs(p.yz) - 0.8;\n\n    float tube1 = max(q2.x, q2.y);\n    float tube2 = max(q3.x, q3.y);\n    float tube3 = max(q4.x, q4.y);\n\n    float sphere = length(p) - 2.0;\n\n    float scene = max(mix(box, sphere, 0.5), -mix(min(tube1, min(tube2, tube3)), sphere, 0.5)) - 0.1;\n    return scene * 0.6;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float t1 = 0.5 * iTime;\n    float t3 = 1.5 * iTime;\n\n    float c1 = cos(t1) * 2.0, s1 = sin(t1) * 2.0;\n    float c2 = cos(iTime) * 2.0, s2 = sin(iTime) * 2.0;\n    float c3 = cos(t3) * 2.0, s3 = sin(t3) * 2.0;\n\n    Light lights[4] = Light[](Light(vec3(c1, c3, s2), vec3(1.0, 0.0, 0.0)),\n                              Light(vec3(s2, c1, s3), vec3(0.0, 1.0, 0.0)),\n                              Light(vec3(s2, s3, c1), vec3(0.0, 0.0, 1.0)),\n                              Light(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0) * snoise(iTime * 15.0)));\n\n    vec3 ro = vec3(s1, s2, c3) * 3.0;\n    vec3 f = -normalize(ro);\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x));\n    vec3 u = normalize(cross(r, f));\n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            fragColor.b += 0.25;\n            break;\n        }\n\n        for (int l=0; l < lights.length(); l++) {\n            fragColor.rgb += 0.005 * lights[l].col * length(ro + f * dot(lights[l].pos - ro, f) - lights[l].pos);\n        }\n\n        if (t > 50.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 119, 119, 185], [187, 187, 212, 212, 260], [262, 262, 288, 288, 477], [479, 479, 506, 506, 1038]], "test": "untested"}
{"id": "wlcyRB", "name": "Day 378", "author": "jeyko", "description": "potato", "tags": ["terrain", "fog", "trees", "fall", "leaves", "mdtmjvm", "evening"], "likes": 55, "viewed": 1048, "published": 3, "date": "1609361866", "time_retrieved": "2024-07-30T20:27:36.034755", "image_code": "// Fork of \"Day 378\" by jeyko. https://shadertoy.com/view/WttyD7\n// 2020-12-30 10:41:15\n\n\n// Cyclic noise from nimitz\n// smooth ops & sdfs from IQ\n// pModPolar from hgSDF\n// FXAA maybe from mudlord\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    col *= vec3(0.9,0.9,0.66);\n    col *= exposure;\n    \n    col = mix(col*1.5,smoothstep(0.,1.,col*vec3(1.,1.1,1.4 ))*1.8,0.6);\n    col = mix(acesFilm(col), col, 0.);\n    col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool hit = false;\n\n// General\n#define exposure 1.3\n#define groundOffs vec3(0,1.3,0)\n\n#define marchSteps 300\n#define marchEps  (mix(0.004,0.26,smoothstep(0.,1.,t*0.1 - 2.)))\n#define distScale 0.6\n\n// Path\n#define pathW 1.2\n\n// Trees\n#define treesSeperation 6.\n\n#define treeBranchSeperation 1.2\n\n#define trunkW 0.2\n\n// Clouds\n\n#define cloudsLowerLimit 7.\n#define cloudsHigherLimit 14.\n\n#define cloudSteps 60.\n#define volumetricDithAmt .05\n\n// Wind\n#define windSteps 40.\n#define maxWindD 30.\n\n// Atmosphere\n#define sunCol vec3(0.7,0.9,0.9)*1.\n#define sunPos (vec3(-0.01,1.22 ,2.)*2300.)\n\n#define planetSz 2984.\n#define atmoSz (planetSz/63.)\n\n\n#define ambianceScale 0.4\n\n#define itersAtmo 3.\n#define itersOptic 3.\nconst float redLightLen = 640.;\nconst float greenLightLen = 550.;\nconst float blueLightLen = 450.;\n\nconst float transStrength = 0.02;\n\nfloat densFalloff = 1.9;\n\n\n#define sss(a) clamp(map(p + sunDir*a).x/a,0., 1.)\n#define ao(a) clamp(map(p + mix(n, sunDir, 0.5)*a).x/a,0., 1.)\n#define aoVol(p, a, dir) smoothstep(0.,1.,map(p + dir*a).x/a*1.5)\n\n#define pi acos(-1.)\n\n#define pal(a,b,c,d,e) ((a + (b)*sin((c)*(d) + (e))))\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\nfloat valueNoise(vec3 p, float pw);\nvec3 acesFilm(const vec3 x);\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\nfloat turbulentNoise(vec3 p);\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\nfloat atmosphericDensity( vec3 p);\nfloat opticalDepth(vec3 p, vec3 rd, float len);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView);\nmat3 getRd(vec3 ro, vec3 lookAt);\nvec3 getRdSpherical(vec3 ro, inout vec2 uv);\nvec3 hash3(vec3 p);\nfloat r21(vec2 p);\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p );\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n/*\nfloat r24(vec2 p){\n    return texture(iChannel0,)[ int(mod(p.x))];\n}*/\n\n \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoiseWind(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseGround(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 2.;\n    const float gain = 0.5;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.9;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseTrees(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.4;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.5;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseAlley(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.8;\n    const float lacunarity = 1.5;\n    const int octaves = 4;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.4 ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,2.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy  + sin(p + 4.))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n/*\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}*/\n\n\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    //p = smoothstep(0.,1.,p);\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec3 hash3(vec3 p) {\n\tp = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 r23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat turbulentNoise(vec3 p, bool md) {\n\tp += 8.;\n    vec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    //f = u;\n\tfloat n0 = dot(hash3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat n1 = dot(hash3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat n2 = dot(hash3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat n3 = dot(hash3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat n4 = dot(hash3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat n5 = dot(hash3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat n6 = dot(hash3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat n7 = dot(hash3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\tfloat ix2 = mix(n4, n5, u.x);\n\tfloat ix3 = mix(n6, n7, u.x);\n\n\tfloat ret = mix(mix(ix0, ix1, u.y), mix(ix2, ix3, u.y), u.z) * 0.5 + 0.5;\n\tret = ret * 1.;\n    \n    //ret = 1.- ret;\n    //ret = abs(ret);\n    if (md)\n        ret = mix(ret,smoothstep(0.3,1.,ret*0.8),0.6);\n    return ret;\n}\n\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )/atmoSz;\n    fact = max(fact, 0.0001);\n    return exp(-fact*densFalloff)*pow(max(1. - fact,0.),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    vec3 sunPosAtmo = sunPos + offs;\n    \n    p += offs*1.;\n    \n    \n    float lenViewDirToEndOfAtmosphere = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    \n    if(hit){\n        atmoMarchLen = mix(t,lenViewDirToEndOfAtmosphere,smoothstep(0.,1.,t/50. - 1.));\n    } else {\n        atmoMarchLen = lenViewDirToEndOfAtmosphere;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPosAtmo - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\nmat3 getRd(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return mat3(right,up,dir); \n}\n\nvec3 getRdUV(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return normalize(dir + right*uv.x + up*uv.y); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 getRdSpherical(inout vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    \n    vec2 ouv = uv;\n    uv += 0.5;\n    uv.y *= pi;\n    \n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    //vec3 lookAt = ro + offs;\n    //vec3 v = normalize(lookAt - ro);\n    vec3 v = offs;\n    //uv = ouv;\n    //uv.x = v.x;\n    //uv.y = v.y;\n    \n    return v;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n#define opRepLim(p,c,l) (p-(c)*clamp(round((p)/(c)),-(l),(l)))\n\nfloat pModPolar(inout vec2 p, out float id, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n    id = floor(a/angle);\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}", "buffer_a_code": "\n#define TAA false\n\nvec3 getNormal(vec3 p);\nvec3 getSun(vec2 uv, vec2 sunPosU, vec3 ro, mat3 vp);\nfloat t = 0.;\nfloat invisibleWall = 10e4;\n\nfloat groundNoise = 0.;\nfloat alleyNoise = 0.;\nfloat treebarkNoise = 0.;\nvec3 alleyUv = vec3(0);\n\nfloat fp(float z){return sin(z*0.15 + cos(z*0.05 + sin(z*0.04)));}\n\nvec3 getPath(vec3 p){\n    return vec3(fp(p.z),0.,0.)*7.;\n    //return vec3(sin(p.z*0.2),0.,0.)*3.;\n\n}\n\n\nvec2 getGround(vec3 p){\n    \n    float d = p.y;\n    float noise = groundNoise = cyclicNoiseGround(vec3(p)*0.2, false);\n    \n    d -= noise*0.2;\n    \n    return vec2(d,1.);\n}   \n\n\n\nvec2 getAlley(vec3 p){\n    p -= getPath(p);\n    \n    \n    p.y -= (alleyNoise = cyclicNoiseAlley(vec3(p)*62.2, true))*0.05*0.325;\n    p.y -= 0. + groundNoise*0.4 + 0.09;\n    p.y += smoothstep(0.0,0.9, abs(p.x) - pathW + sin(p.z*0.2)*0.2)*0.4;\n    \n    alleyUv = p;\n    \n    float d = p.y;\n    \n    \n    \n    return vec2(d,2.);\n}\nvec2 getTrees(vec3 po){\n    float d = 10e5;\n    float noise = cyclicNoiseTrees(vec3(po)*0.4, false);\n    float noiseb = cyclicNoiseTrees(vec3(po.x,po.y*0.2,po.z)*24.4, false);\n    treebarkNoise = noiseb;\n    \n    po.xz += noise*.5;\n    vec3 p = po;\n    \n    \n    vec3 id = floor((p)/vec3(treesSeperation, treeBranchSeperation, treesSeperation));\n    \n    p -= getPath(vec3(0.,0.,id.z*treesSeperation + treesSeperation*0.5));\n    id = floor((p)/vec3(treesSeperation, treeBranchSeperation, treesSeperation));\n    \n    \n    \n    p.z = pmod(p.z,treesSeperation);\n    \n    p.x = pmod(p.x,treesSeperation);\n    \n    invisibleWall = abs(abs(p.z) - treesSeperation*0.5) + 0.3;\n    \n    \n    float lpxz = length(p.xz);\n    \n    d = lpxz - trunkW  - noiseb*0.11*(1. + smoothstep(1.1,0.,p.y)*2.);\n    \n    //p.y -= smoothstep(0.,0.2,(lpxz + 0.2))*0.5;\n    \n    \n    p.y = opRepLim( p.y - treeBranchSeperation*11.  + 0.75*treeBranchSeperation, treeBranchSeperation, 9. );\n    //p.y = pmod( p.y, treeBranchSeperation);\n    \n    \n    //p.y += 0.25*treeBranchSeperation;\n    \n    p.xz *= rot(sin(id.x*40.0 + id.z*1.4 + id.x*id.y*20. + id.y*229. + id.y * id.z*200.)*pi*222.);\n    //p.xz *= rot(sin(id.z)*pi*2.);\n    \n    \n    float polarId;\n    \n    pModPolar(p.xz, polarId, 4.);\n    \n    invisibleWall = min(invisibleWall, abs(abs(p.y) - treeBranchSeperation*0.5) + 0.03);\n    \n    p.yx *= rot(0.5*pi);\n    float mdBranchLen = sin(id.x + id.y + 20.*id.y*id.z +20.*polarId);\n    mdBranchLen = mix(mdBranchLen*0.3, abs(mdBranchLen)*0.9,smoothstep(0.,1.,id.y*0.5 - 0.8));\n    float branchLen = (1.1  + mdBranchLen)*( 0.1 + smoothstep(0.4,1.,id.y*0.4 - 0.5)) ;\n    \n    float branchWidth = abs(sin(branchLen*200.  + polarId*10.));\n    \n    branchLen = max(branchLen, 0.);\n    \n    \n    \n    p.y += branchLen - 0.5;\n    p.x -= pow(smoothstep(0.,2.9,(lpxz - 0.)*1.)/branchLen*1.6,1.)*0.9;\n    \n    \n    //p.x -= noiseb*0.04 + noise*0.0;\n    //branchWidth *= 0.5 + noiseb;\n    \n    //d = opSmoothUnion( d,  sdRoundCone( p, 0.01 + branchWidth*0.02, 0.05 + branchWidth*0.04, branchLen ), 0.09 ) ;\n    \n    //d = min( d,  sdRoundCone( p, 0.03 + branchWidth*0.04, 0.00 + branchWidth*0.0, branchLen )*1.) ;\n    \n    d = min( d,  max(length(p.xz) - 0.01 - 0.05*smoothstep(0.,1.,p.y/branchLen*0.6), - p.y - branchLen*0.5)*0.7 ) ;\n    \n    \n    return vec2(d,3.);\n}\nfloat getLeaf(vec3 p, float sz, vec3 op, vec2 id){ \n    p.z -= sin(5.*abs(p.x)/sz)*sz*.575;\n    \n    p.x *= 0.75;\n    p.xy *= rot(0. + sin(id.x*10. + id.y)*0.5);\n    \n    float d = length(p.xz) - sz ; \n    \n    d = max(d,abs(p.y) - 0.01);\n    return d;//max(, - abs(p.y) + 0.03);\n\n}\nfloat getLeavesLayer(vec3 op, float md, float sz){\n    vec3 p = op; \n    vec2 id = floor(p.xz/md);\n    p.xz = pmod(p.xz, md);\n    return getLeaf(p, sz, op, id);\n}\n\nvec2 getLeaves(vec3 p, float dTrees){\n    vec2 d = vec2(10e4);\n    p.y -= smoothstep(0.4,0.,dTrees)*0.1;\n    \n    p.y -= groundNoise*0.4;\n    p.xz *= rot(0.25);\n    \n    d = dmin(d, getLeavesLayer(p, 0.25, 0.05), 20.);\n    p.xz *= rot(0.25);\n    p.y -= 0.04;\n    d = dmin(d, getLeavesLayer(p, 0.5, 0.05), 21.);\n    \n    p.xz *= rot(0.25);\n    p.y -= 0.005;\n    d = dmin(d, getLeavesLayer(p, 0.45, 0.05), 22.);\n\n    p.xz *= rot(0.25);\n    p.y += 0.025;\n    d = dmin(d, getLeavesLayer(p, 0.35, 0.05), 23.);\n\n    p.xz *= rot(0.25);\n    p.y -= 0.002;\n    d = dmin(d, getLeavesLayer(p, 0.25, 0.05), 24.);\n    \n    p.xz *= rot(0.25);\n    p.y += 0.04;\n    d = dmin(d, getLeavesLayer(p, 0.25, 0.15), 24.);\n\n\n    return d;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    vec2 dGround = getGround(p);\n    vec2 dAlley = getAlley(p);\n    vec2 dTrees = getTrees(p);\n    vec2 dLeaves = getLeaves(p,dTrees.x);\n   \n   \n   \n    d = dmin(d, dAlley.x,dAlley.y);\n    \n    \n    dGround.x = opSmoothSubtraction( -dGround.x, -dAlley.x, 0.1 );\n    \n    \n    \n    //dLeaves.x = opSmoothSubtraction( -dLeaves.x, -dAlley.x + 0.05, 0.01 );\n    \n    //dLeaves.x = mix(dLeaves.x, max(dLeaves.x, -dGround.x + 0.03),smoothstep(0.05,0.,abs(dLeaves.x - dAlley.x) - 0.04 ));\n    \n    d = dmin(d, dGround.x,dGround.y);\n    dTrees.x = opSmoothUnion( dTrees.x, dGround.x, 0.4 );\n    \n    \n    d = dmin(d, dTrees.x,dTrees.y);\n    \n    d = dmin(d, dLeaves.x,dLeaves.y);\n    \n        \n    \n    \n    return d;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevFrame = texture(iChannel2,fragCoord/iResolution.xy);\n    if(TAA){\n        vec2 taaidx = r23(vec3(fragCoord,float(iFrame)))*4.;\n        fragCoord += float(iMouse.z>0.)*.6*vec2(sin(float(taaidx.x)*pi/4.),cos(float(taaidx.x)*pi/4.))*taaidx.y/4.;\n\n    }\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = iMouse.xy/iResolution.xy - 0.5;\n    vec3 col = vec3(0);\n    float T = iTime*1.4;\n    \n    vec3 sunDir = normalize(sunPos);\n    vec3 ro = vec3(0);\n    ro.z += T;\n    \n    //ro.y -= getGround(ro).x;\n    ro += groundOffs;\n    ro += getPath(ro);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 6.51);\n    //lookAt.y -= getGround(lookAt).x;\n    lookAt += groundOffs;\n    lookAt += getPath(lookAt);\n    \n    \n    if(iMouse.z > 0.){\n        lookAt = vec3(\n            ro.x + sin(muv.x*tau - pi),\n            lookAt.y + muv.y*3. + 0.5,\n            ro.z + cos(muv.x*tau - pi)\n        );\n    \n    }\n\n    mat3 vp = getRd(ro,lookAt);    \n    //vec3 rd = normalize(vec3(uv,1.))*vp;\n    vec3 rd = getRdUV(ro, lookAt, uv);\n    \n    \n    // Marching\n    \n    vec3 p = ro;\n    vec2 d;\n    for(int i = 0; i < marchSteps ; i++){\n        d = map(p);\n        \n        if(d.x < marchEps){\n            hit = true;\n            break;\n        } else if (t > 24.){\n            break;\n        }\n        \n        d = dmin(d,invisibleWall, 10.);\n        \n        p = ro + rd*(t += d.x * distScale);\n    }\n    \n    float depthView;\n    vec3 atmosphere = getAtmosphere(vec3(0,ro.y - 0.,0), rd, t, depthView);\n    \n\n    \n    // Wind\n    float volumetricDith = r21(fragCoord + sin(iTime*20.)*20.)*volumetricDithAmt;\n    \n    vec3 windP = ro + rd*volumetricDith*0.00 ;\n    float windStepSz = min(t,maxWindD)/windSteps;\n    \n    vec3 windAccum = vec3(0);\n    float windDensTotal = 0.;\n    //vec3 windAccum = vec3(0.);\n    \n    for(float i = 0.; i < windSteps ; i++){\n        vec3 wp = windP*0.51 - vec3(-iTime*0.5,smoothstep(0.,1.,windP.y*0.5 - 1.9),0.);\n        float dens = max(cyclicNoiseWind(wp,false,iTime),0.05)*0.461;\n        dens *= smoothstep(1.,0.,windP.y*0.01 + 0.4);\n        \n        vec3 c = mix(\n            vec3(1.4,1.1,0.67)*0.4,\n            vec3(0.2,0.44,0.47)*0.3,\n            //smoothstep( 0., 1., abs(windP.x)*0.9 - 0.5)\n            smoothstep( 0., 1., length(rd.xy - sunDir.xy)*0.75 + 0.4)\n            \n            );\n        \n        c = mix( c*c*0.4, c, smoothstep(0.,1.,windP.y*0.15 + 0.1));\n        \n        //dens *= aoVol(windP,1.,sunDir)*aoVol(windP,0.6,sunDir)*aoVol(windP,0.2,sunDir)*aoVol(windP,2.2,sunDir)*2.;\n        //dens *= aoVol(windP,1.,sunDir)*aoVol(windP,0.6,sunDir)*aoVol(windP,0.2,sunDir)*aoVol(windP,2.2,sunDir)*2.;\n        \n        \n        dens = dens*(1.-windDensTotal);\n        windAccum += dens*windStepSz*c*1.;\n        windDensTotal += dens*windStepSz;\n        \n        \n        if( windDensTotal > 0.97){\n            break;\n        }\n        windP += rd*windStepSz;\n    }\n    \n\n    // Coloring\n    \n    vec3 hitCol = vec3(0);\n    vec3 ambientCol = atmosphere*1.;\n    if(hit){\n        vec3 n = getNormal(p);\n        if(d.y == 2.){\n            n = normalize(n + texture(iChannel3,p.xz).xyz)*0.7;\n            \n            n = normalize(n + texture(iChannel3,p.xz*0.2 + 3.).xyz);\n        }\n        \n        vec3 prevFrameMip = pow(max(texture(iChannel2,vec2(uv.x,-uv.y),7.).xyz, 0.),vec3(2.)) * float(iFrame > 0);\n        \n        vec3 hf = normalize(sunDir - rd);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),29.);\n        float fres = pow( 1. - max(dot( n, -rd),0.001),5.);\n        fres = max(fres,0.);\n        \n        float AO = ao(2.9)*ao(0.2)*ao(1.)*ao(0.4)*2.;\n        float SSS = sss(.3)*sss(0.04)*sss(.1)*5.;\n        float shad = diff;\n        \n        vec3 albedo = vec3(0);\n        \n        vec3 treesCol = vec3(0);\n        {\n            albedo = 1.2*vec3(0.22,0.22,0.21)*(sunCol + atmosphere*0.4);\n            vec3 ambCol = albedo*(sunCol*0.2 + atmosphere*5.)*0.4;\n            vec3 aoCol = 0.4*albedo*albedo*(sunCol*0.3 + atmosphere*1.4);\n            \n            treesCol = mix(ambCol, albedo, shad);\n            treesCol = mix(aoCol, albedo, (AO - treebarkNoise*0.1));\n        }\n        vec3 groundCol = vec3(0.);\n        {\n            albedo = vec3(0.8,0.42,0.2)*0.1*(sunCol + prevFrameMip*224.4);\n            vec3 ambCol = albedo*(sunCol*0.2 + atmosphere*5.)*0.4;\n            vec3 aoCol = albedo*albedo*(sunCol*0.3 + atmosphere*1.4);\n            \n            groundCol = mix(ambCol, albedo, shad);\n            groundCol = mix(aoCol, albedo, AO);\n        }\n        vec3 leavesCol = vec3(0.);\n        {\n            //albedo = vec3(0.8,0.42,0.2)*0.1;\n            \n            //albedo = pal(0.5,0.5,vec3(1,2,1),1.,d.y);\n            \n            albedo = vec3(1.,0.1,0.2)*0.8;\n            \n            albedo += 1.;\n            \n            albedo.yz *= rot(-sin(d.y*20.)*0.1);\n            \n            albedo.xy *= rot(-sin(d.y)*0.1);\n            \n            albedo.xz *= rot(-sin(d.y*40.)*0.02);\n            \n            albedo -= 1.;\n            albedo *= sunCol + prevFrameMip;\n            albedo *= vec3(0.9,0.95,0.7);\n            \n            albedo *= 1. - smoothstep(0.5,0., abs(alleyUv.x) - pathW*1.1 )*vec3(1.,0.9,0.8)*0.76;\n            \n            vec3 ambCol = albedo*(sunCol*0.2 + prevFrameMip*2.)*0.4;\n            vec3 aoCol = albedo*albedo*albedo*(sunCol*0.1 + prevFrameMip*9.);\n            \n            leavesCol = mix(ambCol, albedo, shad);\n            leavesCol = mix(aoCol, albedo, AO);\n        }\n        \n        vec3 pathCol = vec3(0.);\n        {\n             \n            albedo = .6*vec3(0.11,0.1,0.1);\n            \n            float darkened = smoothstep(0.4,0., -abs(alleyUv.x) + pathW*0.5  + 0.05+ texture(iChannel1,alleyUv.xz).x*texture(iChannel1,alleyUv.xz*vec2(0.,0.05)).x*2.);\n            \n            albedo = mix(\n                albedo,\n                albedo*texture(iChannel1,alleyUv.xz).xyz + albedo*0.5,\n                darkened\n            );\n            //albedo += ;\n            \n            vec3 ambCol = albedo*(sunCol*0.2  + prevFrameMip*24.4)*0.1;\n            vec3 aoCol = albedo*albedo*(sunCol*0.3 +  + prevFrameMip*24.4);\n            \n            \n            \n            pathCol = mix(ambCol, albedo, shad);\n            pathCol = mix(aoCol, albedo, AO*1.2);\n            pathCol += (smoothstep(0.4, 1.,alleyNoise) + 0.9)\n                *(spec*1.5 + fres*0.9)*3.9*(clamp(prevFrameMip,0.,.00) + vec3(0.,0.2,0.3)*0.008)*(1. - darkened*0.7);\n        }\n        \n        hitCol += groundCol*float(d.y == 1.);\n        hitCol += pathCol*float(d.y == 2.);\n        hitCol += treesCol*float(d.y == 3.);\n        hitCol += leavesCol*float(d.y >= 20.);\n        \n        \n        hitCol -= hitCol*float(d.y == 10.);\n        \n    }\n    \n\n    // Compositing\n    \n    col += hitCol;\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t)*.04 ),2.);\n    }\n    \n    //atmosphere += getSun(rd.xy, sunDir.xy, ro, vp);\n    \n    atmosphere*=0.04;\n    float depthViewFac = smoothstep(0.,1.,exp(-depthView*0.02) + exp(-t*0.4));\n    \n    col = col * depthViewFac + atmosphere; \n    \n    /*\n    if (!hit  && lowerCloudLimitDist > 0.){\n        cloudAccum = mix(cloudAccum,col,clamp(1.-exp(-lowerCloudLimitDist*0.01 + 0.4),0.,1.));\n        col = mix(col,cloudAccum*1. , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),4.));\n    }\n    */\n    //windAccum *= smoothstep(0.,1.,t*0.2 - 1.);\n    col = mix(col, windAccum, pow(windDensTotal,1.));\n    \n    //col = (col - windDensTotal) + 1.*windAccum;\n    \n    if(TAA && iFrame >1 && iMouse.z < 1.){\n        fragColor = mix(prevFrame, col.xyzz,0.4);\n    } else {\n        fragColor = col.xyzz;\n    }\n    \n    \n    \n    \n    //fragColor.w = cloudDensTotal + float(hit)*1.;\n    fragColor.w = 1.;\n\n}\n\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.02).x;\n    }\n    return normalize(n);\n}\n\n\nvec3 getSun(vec2 uv, vec2 sunPosU, vec3 ro, mat3 vp){\n    \n    vec3 sunPosW = sunPos;\n    vec2 sunUVOriginal = uv;\n    vec2 sunUV = uv - sunPosU;\n    //float cloudDensPrevFrame = texture(iChannel2, ((sunUV*iResolution.y + 0.5*iResolution.xy)/iResolution.xy)).w;\n    \n    //vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(getRd(ro,sunPosW))).xy;\n    vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(vp)).xy;\n    \n    sunUvPrevFrame = (sunUvPrevFrame*iResolution.y)/iResolution.xy + 0.5;\n    \n    float deltaUV = 0.04;\n    float cloudDensPrevFrame = \n        texture(iChannel2, sunUvPrevFrame + deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame - deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(-deltaUV,deltaUV)).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(deltaUV,-deltaUV)).w\n        ; \n    \n    cloudDensPrevFrame /= 4.;\n    \n    cloudDensPrevFrame = clamp(cloudDensPrevFrame,0.,1.);\n    // sun\n    vec3 sun = sunCol*smoothstep(0.07,0.,length(sunUV));\n    sun += sunCol*vec3(1.,0.4,0.6)*smoothstep(0.1,0.,length(sunUV));\n    sun += sunCol*vec3(0.7,0.4,0.6)*smoothstep(0.3,0.,length(sunUV))*0.5;\n    sun += sunCol*vec3(0.3,0.4,0.6)*smoothstep(0.6,0.,length(sunUV))*0.35;\n    \n    \n    // rays\n    \n    \n    vec3 sunRays = 0.4*sunCol * smoothstep(0.015*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n    \n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi/8./1.);\n        float mda = sin(i*pi/4.);\n        float mdb = sin(i*pi/2.);\n        float w = 0.03;\n        float l = 0.1;\n        sunRays += (sunCol) *\n            mix(.8,.1,smoothstep(0.,0.25 +  sin(i*pi/ 4. + iTime)*0.1,length(sunUV))) *\n            smoothstep(w + mda*w/4.,0.,abs(sunUV.y))*smoothstep((l + mdb*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVOriginal - sunPosU;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunPosU;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    // flares\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return (sun + sunRays + flares*3.*sunCol) * (1. - cloudDensPrevFrame*1.);\n}\n\n", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat FXAAamt = 0.5;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 257, 257, 690]], "test": "untested"}
{"id": "WltyzS", "name": "A taste of the physically base", "author": "iY0Yi", "description": "I wanted to know taste of physically based lighting, so I copied from romainguy's shader.\nhttps://www.shadertoy.com/view/XlKSDR\nIt's not enough. (I couldn't get some of the functions to work...)\nBut the taste is not so bad.", "tags": ["pbr", "physicallybasedl", "ighting"], "likes": 7, "viewed": 402, "published": 3, "date": "1609361012", "time_retrieved": "2024-07-30T20:27:37.123843", "image_code": "// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 Tonemap_ACES(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// https://www.shadertoy.com/view/3ssSz2\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat originalSigmoidContrast(float color, float contrast, float mid){\n    contrast = contrast < 1.0 ? 0.5 + contrast * 0.5 : contrast;\n    float scale_l = 1.0 / mid;\n    float scale_h = 1.0 / (1.0 - mid);\n    float lower = mid * pow(scale_l * color, contrast);\n    float upper = 1.0 - (1.0 - mid) * pow(scale_h - scale_h * color, contrast);\n    return color < mid ? lower : upper;\n}\nvec3 originalSigmoidContrast(vec3 color, float contrast, float mid){\n\tcolor.r = originalSigmoidContrast(color.r, contrast, mid);\n\tcolor.g = originalSigmoidContrast(color.g, contrast, mid);\n\tcolor.b = originalSigmoidContrast(color.b, contrast, mid);\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 col = texture(iChannel0, uv).rgb;\n\tcol = Tonemap_ACES(col);\n\tcol = sat(col);\n\tcol = originalSigmoidContrast(col, 2.5, .2);\n\tcol = pow(col, vec3(1./2.2));\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define MIN_DIST 0.001\n#define MAX_DIST 1500.0\n#define ITERATION 200\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0 vec3(0.6619, 0.3542, 0.3158)\n#define MAT_ERNST0_006 vec3(0.6619, 0.6108, 0.5172)\n#define MAT_ERNST0_002 vec3(0.3324, 0.6921, 0.5215)\n#define MAT_ERNST0_003 vec3(0.6982, 0.4874, 0.0414)\n#define MAT_ERNST0_001 vec3(0.1334, 0.42, 0.1273)\n#define MAT_ERNST0_005 vec3(0.1025, 0.0915, 0.0915)\n#define MAT_ERNST0_004 vec3(0.2306, 0.2807, 0.6619)\n\n#define AMB_COL vec3(0.6921, 0.8636, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL vec3(1.0, 1.0, 1.0)\n#define FOG_START 0.0\n#define FOG_POW 1.0\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_a_code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\n    cam0.position = vec3(-26.9963, 88.0527, -48.4978);\n\tcam0.quaternion = vec4(0.2949, -0.0793, -0.2473, 0.9196);\n\tcam0.fov = 0.08;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = normalize(vec3(-0.5875, 0.7071, -0.3935));\n\tlit0.color = vec3(2.5372, 2.3575, 1.8639);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(0.5875, -0.7071, 0.3935));\n\tlit1.color = vec3(0.214, 0.1892, 0.1329);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}void perspectiveCam(vec2 uv){\n\tvec3 dir = quat_rotate(cam0.quaternion, vec3(0,0,-1)).xzy;\n\tvec3 up = quat_rotate(cam0.quaternion, vec3(0,1,0)).xzy;\n\tvec3 pos = cam0.position;\n\tfloat fov = cam0.fov;\n\tvec3 target = pos-dir;\n\n\tvec3 cw = normalize(target - pos);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));;\n}\nvoid camera(vec2 uv){\n\tperspectiveCam(uv);\n}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v){\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\treturn (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCapsule(vec3 p, float r, float c){\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per){\n\tp.x = abs(p.x);\n\tvec2 sc = vec2(sin(per),cos(per));\n\tfloat k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n\treturn sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\nfloat sdPieCylinder( vec3 p, float r, float h, float per ){\n\tper = mod(per, PI);\n\tvec2 c = vec2(sin(per),cos(per));\n\n\tp.xz=c.y*p.xz+c.x*vec2(p.z,-p.x); // rotation\n\tp.x = abs(p.x);\n\n\tfloat l = length(p.xz) - r;\n\tfloat m = length(p.xz-c*clamp(dot(p.xz,c),0.0, r));\n\tfloat x = max(l,m*sign(c.y*p.x-c.x*p.z));\n\n\tfloat y = abs(p.y) - h;\n\n\treturn ((min(max(x,y),0.0) + length(max(vec2(x,y),0.0))));\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 ){\n\tvec2 q = vec2( length(p.xz), p.y );\n\tvec2 k1 = vec2(r2,h);\n\tvec2 k2 = vec2(r2-r1,2.0*h);\n\tvec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n\tvec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n\tfloat s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n\treturn s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdRoundCone( vec3 p, float h, float r1, float r2 ){\n\tvec2 q = vec2( length(p.xz), p.y+h*.5 );\n\n\tfloat b = (r1-r2)/h;\n\tfloat a = sqrt(1.0-b*b);\n\tfloat k = dot(q,vec2(-b,a));\n\n\tif( k < 0.0 ) return length(q) - r1;\n\tif( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n\n\treturn dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 d=abs(p)-b;\n\treturn length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n\n\t// iq:\n\t//float h = max(r-abs(a-b),0.0);\n\t//return min(a, b) - h*h*0.25/r;\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\nvec4 v4OpSubstraction(in vec4 a,in vec4 b){\n\tfloat res = max(-a.x, b.x);\n\treturn (res==-a.x)?vec4(-a.x, a.yzw):b;\n}\n\nvec4 v4OpSubstractionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x, r + -a.x), vec2(0));\n\tfloat res = min(-r, max(b.x, -a.x))+length(u);\n\tvec3 m = mix(b.yzw, a.yzw, clamp(abs(-b.x)+abs(res),0.0,1.0)*clamp(r,0.,1.));\n\treturn vec4(res, m);\n}\n\nvec4 v4OpIntersection(in vec4 a,in vec4 b){\n\tfloat res = max(a.x, b.x);\n\treturn (res==a.x)?a:b;\n}\n\nvec4 v4OpIntersectionSmooth( vec4 a,vec4 b,float r){\n\tvec2 u = max(vec2(r + b.x,r + a.x), vec2(0));\n\tfloat res =  min(-r, max(b.x, a.x)) + length(u);\n\tvec3 m = mix(a.yzw, b.yzw, clamp(a.x-res,0.0,1.0)*r);\n\treturn vec4(res, m);\n}\n\n// \"Limited Repetition SDF\" by iq:\n// https://www.shadertoy.com/view/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el/s);\n\tfloat half_num = (repetitions-1.)/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el/s);\n\tfloat half_rep = ceil(repetitions/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 sd002(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=10.0;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, -4.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0), res);\n\n\td = sdBox(p+vec3(-12.0, -1.0, -5.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\tres = v4OpSubstractionSmooth(vec4(d, MAT_ERNST0_001), res, 0.02);\n\treturn res;\n}\nvec4 sd001(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\tfloat bsd = length(p), bsr=15.0;\n\tif (bsd > 2.*bsr) return vec4(bsd-bsr,MAT_VOID);\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, -8.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0_005), res);\n\n\td = sdBox(p+vec3(-12.0, -1.0, -9.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\tres = v4OpIntersectionSmooth(vec4(d, MAT_ERNST0_001), res, 0.02);\n\treturn res;\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp001 = p;\n\tcp001.xyz += vec3(-8.0856, -4.9245, -10.7845);\n\tpRepLimited(cp001.y, 2.5, 3.);\n\tpRepLimited(cp001.z, 1.25, 4.);\n\tpRepLimited(cp001.x, 1.25, 4.);\n\n\tres = sd001(p);\n\n\tres = v4OpUnionSmooth(sd002(p), res, 0.01);\n\n\td = sdBox(p+vec3(0.0, -1.0, -6.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01;\n\td = fOpUnionSmooth(sdBox(p+vec3(3.0, -1.0, -6.0), vec3(1.0, 1.0, 1.0)-0.3)-0.3, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_003), res, 0.01);\n\n\td = sdCappedCylinder(p+vec3(0.0, -1.0, -9.0), vec2(1.0, 1.0)-0.01)-0.01;\n\td = fOpUnionSmooth(sdCappedCylinder(p+vec3(3.0, -1.0, -9.0), vec2(1.0, 1.0)-0.3)-0.3, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdCappedTorus(p+vec3(-3.0, -0.5, -12.0), vec2(1.0, 0.5), 2.356);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_004), res, 0.01);\n\n\td = sdCapsule(p+vec3(-3.0, -2.0, 0.0), 1., 1.);\n\td = fOpUnionSmooth(sdConeSection(p+vec3(0.0, -1.021, -3.0), 1.0-0.01, 1.02-0.01, 0.0)-0.01, d, 0.01);\n\td = fOpUnionSmooth(sdConeSection(p+vec3(3.0, -1.021, -3.0), 1.0-0.1, 1.02-0.1, 0.0)-0.1, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdEllipsoid(p+vec3(0.0, -1.0, 0.0), vec3(1.0, 1.0, 1.0));\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.01);\n\n\td = sdEllipsoid(p+vec3(-12.0, -1.0, 0.0), vec3(0.99, 0.99, 0.99));\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdEllipsoid(p+vec3(-3.0, -1.5, -3.0), vec3(1.0, 1.5, 1.0));\n\td = fOpUnionSmooth(sdPieCylinder(p+vec3(0.0, -1.0, -12.0), 1.0-0.01, 1.0-0.01, 2.356)-0.01, d, 0.01);\n\td = fOpUnionSmooth(sdPieCylinder(p+vec3(3.0, -1.0, -12.0), 1.0-0.3, 1.0-0.3, 2.356)-0.3, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.01);\n\n\td = sdPlane(p);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_002), res, 0.01);\n\n\t{\n        // sdHex\n\t\tvec3 tp = p+vec3(-6.0, -1.1, 0.0);\n\t\tvec3 trp = rot(p+vec3(-6.0, -1.1, 0.0), vec3(1.5708, 0.0, 0.0));\n\t\tvec3 dim = vec3(0.75, 0.75, 1.0);\n\t\tfloat td = MAX_DIST;\n        \n\t\tconst vec3 k = vec3(-0.866254, 0.5, 0.57735);\n\t\tvec2 h = dim.xz;\n\t\ttrp = abs(trp);\n\t\ttrp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n\t\tvec2 d2 = vec2(\n\t\t\t length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),\n\t\t\t trp.z-h.y );\n\t\ttd = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0))-.01;\n\t\td=td;\n\t}\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_005), res, 0.01);\n\n\t{\n        // sdFakeCapsule\n\t\tvec3 tp = cp001;\n\t\tvec3 trp = cp001;\n\t\tvec3 dim = vec3(0.6342, 1.0, 0.6342);\n\t\tfloat td = MAX_DIST;\n\t\t\n\t\tfloat r = max(dim.x, dim.z);\n\t\tfloat c = dim.y*.5;\n\t\tfloat elg = c-min(.5,c);\n\t\ttrp.y -= clamp(trp.y,-elg,elg); // Elongation: https://www.shadertoy.com/view/Ml3fWj\n\t\t\n\t\tfloat a = .5*trp.y*trp.y+.5;\n\t\tfloat b = abs(trp.y);\n\t\ttrp.y = b<1. ? a : b; // Smooth abs\n\t\t\n\t\ttrp.y -= min(.5,c); // Offset\n\t\ttd = length(trp)-r;\n\t\td=td;\n\t}\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_006), res, 0.01);\n\n\td = sdRoundCone(p+vec3(-3.0, -2., -6.0), 2., 1., 0.0);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0), res, 0.01);\n\n\td = sdTorus(p+vec3(-3.0, -0.5, -9.0), vec2(1.0, 0.5));\n\td = fOpUnionSmooth(sdBox(p+vec3(-12.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0)-0.01)-0.01, d, 0.01);\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.01);\n\n\treturn res;\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = ZERO; i < ITERATION+ZERO; i++){\n\t\tvec4 res = sdScene(ray.origin + d * ray.direction);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    // Copy from iq shader.\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4+ZERO; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; // big, such that y = 0 on the first iteration\n\tfor( int i=ZERO; i < ITERATION+ZERO; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n#if 1\n\t\tres = min( res, k*h/t);\n#else\n\t\tfloat y = h*h/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 12;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n\tfloat ao = 0.0;\n\n\tfor( int i=ZERO; i<nbIte+ZERO; i++ ){\n\t\tfloat l = hash11(float(i)+maxDist*falloff)*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l+maxDist+falloff )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n// \"Physically-based SDF\" by romainguy:\n//https://www.shadertoy.com/view/XlKSDR\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat pow5(float x) {\n\tfloat x2 = x * x;\n\treturn x2 * x2 * x;\n}\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n\tfloat oneMinusNoHSquared = 1.0 - NoH * NoH;\n\tfloat a = NoH * linearRoughness;\n\tfloat k = linearRoughness / (oneMinusNoHSquared + a * a);\n\tfloat d = k * k * (1.0 / PI);\n\treturn d;\n}\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\nvec3 F_Schlick(const vec3 f0, float VoH) {\n\treturn f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n#define specular(lr, noV, noL) D_GGX(lr, noV, noL)\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n\n        // I wanted to know taste of physically based lighting,\n        // so I copied from romainguy's shader.\n        // https://www.shadertoy.com/view/XlKSDR\n\t\tvec3 h = normalize(-ray.direction + lit0.direction);\n\t\tfloat NoV = abs(dot(renDat.normal, -ray.direction)) + 1e-5;\n\t\tfloat NoL = sat(dot(renDat.normal, lit0.direction));\n\t\tfloat NoH = sat(dot(renDat.normal, h));\n\t\tfloat LoH = sat(dot(lit0.direction, h));\n\t\tfloat roughness = .5;\n\t\tfloat metallic = .0;\n\t\tfloat intensity = .01;\n\t\t\n        if(distance(MAT_ERNST0, renDat.albedo)<.1){\n            roughness = .3;\n            intensity = .0;\n        }\n        if(distance(MAT_ERNST0_002, renDat.albedo)<.1){\n            roughness = .3;\n            intensity = .0;\n            const float CSIZE = .5;\n            renDat.albedo += .05*max(step(.5, fract(p.x*CSIZE)), step(.5, fract(p.z*CSIZE)))*max(step(.5, fract(p.x*CSIZE+.5)), step(.5, fract(p.z*CSIZE+.5)));\n        }\n        if(distance(MAT_ERNST0_003, renDat.albedo)<.1){\n            roughness = .3;\n            intensity = .1;\n        }\n        if(distance(MAT_ERNST0_001, renDat.albedo)<.1){\n            roughness = .2;\n            intensity = .05;\n        }\n        float linearRoughness = roughness * roughness;\n        \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1./PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1./PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .1, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, .5, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 2., 2.);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 4., 2.);\n\t\trenDat.ao = smoothstep(0., 4., renDat.ao);\n\n\t\trenDat.diffuse = lamb1;//Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH);\n\t\trenDat.result*= renDat.albedo;\n\n\t\tvec3 f0 = .5*(1. - metallic) + renDat.albedo * metallic;\n\t\tvec3  F = F_Schlick(f0, LoH);\n\t\tfloat V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n\t\trenDat.specular = specular(linearRoughness, NoH, h)*intensity;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow*1.)*F;\n\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    uv += offset; //\n    \n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n\n\tfragColor = vec4(renDat.result, 1.);\n}", "buffer_a_inputs": [], "buffer_b_code": "// AA: Mix a new color with the average color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 new = texture(iChannel0, uv);\n    \n    if(iFrame==0){\n        fragColor = new;\n        return;\n    }\n    \n    vec4 ave = texture(iChannel1, uv);\n    fragColor = mix(new, ave, .99);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 152, 184, 184, 370], [372, 485, 555, 555, 868], [869, 869, 937, 937, 1134], [1136, 1136, 1192, 1192, 1424]], "test": "untested"}
{"id": "wl3cD7", "name": "Rubik's 3-ring", "author": "FabriceNeyret2", "description": "sort the balls !   ( variant of [url]https://shadertoy.com/view/ttdcD4[/url] ).\nclick to restart\n- up/down key to roll the balls in the current ring.\n- space to change current ring.\nPS: Still pretty trivial, though :-/", "tags": ["game", "puzzle", "short"], "likes": 9, "viewed": 342, "published": 3, "date": "1609358838", "time_retrieved": "2024-07-30T20:27:38.172040", "image_code": "// more challenging variant of https://shadertoy.com/view/ttdcD4\n\n#define S(v)         smoothstep( 15./R.y, 0., v )                    // antialiasing\n#define sR(U,w,h,r)  length(max( abs(U) - vec2(w,h)/2. +r , 0.)) - r // smooth rectangle\n#define ds(s,x)      U * mat2(cos(s 3.14/6. +vec4(0,-1.57,1.57,0))) + vec2( 3. s -x*.6, 0 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 12.* ( u - .5*R ) / R.y + vec2(0,.7), P;\n    float a = 3.*fract(atan(U.y,U.x)/6.28+.25),  v0,v1, m=1., M,M0;\n    int r0 = int(a), r1 = (r0+1)%3, r; \n/*\n    if (U.x>8.) { U = 17.*(u-vec2(R.x,0))/R.y; U.x+=3.;              // debug: show balls state\n                  P = T(int(U.y)+17*int(U.x)).yz;\n                  if(U.x>0.) r = int(P.x), U = fract(U)-.5,\n                             O[r%3] += S(length(U)-.3) * (r<3?.5:1.) * float(P.y==14.&&U.x<0. || P.y==17.&&U.x>0. || P.y!=14.&&P.y!=17.); \n                  return;}\n*/\n    U = length(U) * cos( (fract(a)-.5)*6.28/3. + vec2(0,33) );\n    M  = S(length(U)-6.6);                                           // main body\n    U.x -= 3.5;                                                      // --- draw board\n    P = ds(-,0.); v0 = S(sR(P,3.3,1, .1));                           // central hole\n    P = ds(+,0.); v1 = S(sR(P,3.3,1, .1));\n    M -= v0+v1;\n    if (v0+v1>.9)                                                    // central body\n      P = ds(-, T(r0).w), M  = S(sR(P,2,1, .1)), m  = M *S( .35 - abs(P.x) ), \n      P = ds(+, T(r1).w), M0 = S(sR(P,2,1, .1)), m += M0*S( .35 - abs(P.x) ), // m: central rail chunk \n      M+=M0;                            \n    else                                                             // ring rails\n      m = S( .3 - abs( length(U)-2.5)  ); \n    O = m * M * texture( iChannel1, U/12.);\n    \n    for( int i=0; i < 51; i++ )  {                                   // --- draw balls\n        vec4 B = T(i);\n        r = int(B.y);\n#define C(o,s)   2.* cos((B.z+o)/10.*6.28+vec2(0,33)) s vec2(0,2.5) \n        if ( r==r0  ||  r-3==r0   ||  r-3==r1 ) {                    // if current ring or gate  \n            a = r-3!=r0 ? B.z : 31.-B.z;\n            P = 2.5 * cos(a/18.*6.28 + 1.4+2.6 + vec2(0,33));\n            if(r-3==r0) v0 >.9 ? P += .53* (T(r0).w+1.)/1. *vec2(-.87,.5) : P-=P;// on gate: offset\n            if(r-3==r1) v1 >.9 ? P += .53* (T(r1).w-1.)/1. *vec2( .87,.5) : P-=P;\n            O[int(B.x)] += sqrt(max( 1.-length( P - U )/.3*.8 , 0.)) * (1.-m);   // draw sphere\n                      // * sqrt((3.+B.z)/18.);\n        }\n    }\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(i) texelFetch(iChannel0, ivec2(i,0), 0 )", "buffer_a_code": "                                                            // autodemo before click\n#define K(a,c) ( iMouse.xy==vec2(0) ? fract(1e4*sin(1e4*(float(a)+iTime))) > .95 ? 1. : 0. \\\n                                    : texelFetch( iChannel3, ivec2(a,c), 0 ).x )\n#define keyDown(a)     K(a,1)                               // https://www.shadertoy.com/view/llySRh\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( U.y > 1. || U.x > 51. ) return;                    // use only 32 pixels for states\n    int i = int(U.x), c = int(T(3).w), r;\n    \n    if ( iFrame < 1 || iMouse.z>0.) {                       // --- init state\n        O = vec4( ( (i*7)^int(iTime*99.) )%3,               // color = 0, 1 or 2\n                  i/17,                                           // ring  = 0, 1 or 2\n                  i%17,                                           // rank in ring\n                  i==0 ? -1. : i ==1 ? 1. : i==2 ? 1./16. : 0. ); // gates\n        if (i==17+17+14) O = vec4(2,0,17,0);\n        if (i==17+14)    O = vec4(1,5,14,0);\n        return;\n     }\n     \n     O = T(i);                                              // previous state\n     bool k = abs( abs(T(0)).w+abs(T(1).w)+abs(T(2).w) - 2. ) < .1 && T(4).w==0. , // true if all still\n          g = keyDown(32)>0.;\n     if(i==5) O.w=float(k); k = k && T(5).w==1.;            // ... and still at previous frame (for autodemo)\n     if (i==3 && g && k ) O.w = mod( O.w + 1. , 3. );       // choose selector\n     if ( i<3 && c!=(i+1)%3 ) O.w = abs(O.w) < 1.           // selector anim ( start only if balls are not moving )\n                                      ? O.w + sign(O.w)/16. \n                                      : g && k ? c==i ? 1./16. : -1./16. : O.w;\n     if (i==4) O.w = abs(O.w) > .01                         // balls motion \n                     ? O.w - sign(O.w)/16.                  // selector anim ( start only if balls are not moving )\n                     : k && !g ? keyDown(38) - keyDown(40) : 0.;  // keypressed direction ( up down arrows )\n\n                                                            // --- rotate balls in the selected ring\n     float s = T(3).w, d = T(4).w;                          // balls direction\n     if ( O.y == s  ) O.y = s, O.z = mod( O.z + sign(d)/16., 18.);\n     \n     if ( O.z==14.||O.z==17. ) {                            // --- balls in gates\n         r = O.y < 3. ? ( int(O.y) + int(O.z==14.) ) % 3 : int(O.y)-3 ; // gate id\n         s = T(r).w;                                                    // gate side\n         if ( O.y < 3.) { if ( abs(s)< 1.) O.z = 31.-O.z, O.y = float(r+3); }   // not in gate while moving: set in gate + swap rank id\n         else           { if ( abs(s)>=1.) O.y = float( s>0. ? (r+2)%3 : r ); } // in gate while stopped: set in ring\n      // if ( O.y < 3.) { if ( abs(s)< 1.) O.y = float(r+3); }                  // not in gate while moving: set in gate\n      // else           { if ( abs(s)>=1.) O.yz = s>0. ? vec2((r+2)%3,14) : vec2(r,17); } // in gate while stopped: set in ring\n     }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3cD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtcyW7", "name": "voxel Bunny Test", "author": "XutXtuX", "description": "Rotate camera by mouse\nPure voxel casting", "tags": ["voxel"], "likes": 2, "viewed": 266, "published": 3, "date": "1609352589", "time_retrieved": "2024-07-30T20:27:38.926024", "image_code": "//Local version on https://github.com/SirSeruju/voxelShaderVisualisation\n//It support png slices of voxel volume\n//With samplers it faster a lot\n\n#define MAX_DISTANCE 600.0\n\n\n#define VOLUME_SIZE_X 32\n#define VOLUME_SIZE_Y 32\n#define VOLUME_SIZE_Z 32\n// 32x32x32\n// from https://www.shadertoy.com/view/MdlyDs\nconst uint volume[1024] = uint[1024](0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,917504u,917504u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1966080u,12531712u,16742400u,16742400u,16723968u,16711680u,8323072u,4128768u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,6144u,2063360u,16776704u,33553920u,33553920u,33553920u,33553920u,33520640u,16711680u,8323072u,8323072u,2031616u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,268435456u,402653184u,134217728u,201326592u,67108864u,0u,0u,7168u,2031104u,16776960u,33554176u,33554176u,33554304u,33554176u,33554176u,33554176u,33553920u,16744448u,8323072u,4128768u,1572864u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,939524096u,402653184u,478150656u,260046848u,260046848u,260046848u,125832192u,130055680u,67108608u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554304u,33554176u,16776704u,8355840u,4128768u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,805306368u,1056964608u,1056964608u,528482304u,528482304u,260046848u,260046848u,260046848u,130039296u,130154240u,67108739u,67108807u,33554375u,33554375u,33554370u,33554368u,33554368u,33554304u,33554304u,16776960u,8330240u,4128768u,393216u,0u,0u,0u,0u,0u,0u,0u,0u,939524096u,1040187392u,1040187392u,520093696u,251658240u,251658240u,260046848u,125829120u,125829120u,130088704u,63045504u,33554375u,33554375u,33554375u,33554407u,33554407u,33554370u,33554370u,33554374u,33554310u,16776966u,4144642u,917504u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,15360u,130816u,262017u,4194247u,33554383u,67108847u,33554415u,33554407u,33554407u,33554375u,33554375u,33554318u,2031502u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,262019u,2097151u,134217727u,134217727u,67108863u,33554415u,33554407u,33554415u,33554383u,2097102u,982926u,32262u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,31744u,130816u,524263u,117964799u,127926271u,134217727u,67108863u,16777215u,4194303u,4194303u,2097151u,1048574u,65422u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,31751u,130951u,524287u,252182527u,261095423u,261095423u,59768830u,2097150u,1048574u,1048575u,262143u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,7u,31751u,130959u,503840767u,520617982u,529530879u,261095423u,1048575u,1048574u,1048574u,524286u,524287u,131070u,65534u,16134u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3u,1799u,32527u,134348750u,1040449534u,1057488894u,520617982u,51380223u,1048575u,1048575u,524287u,524287u,524287u,131070u,65534u,15886u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1536u,3968u,8175u,65535u,1006764030u,1040449534u,1057488894u,50855934u,524286u,524286u,524287u,524287u,524286u,262142u,131070u,65534u,32270u,14u,6u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8160u,8191u,805371903u,2080505854u,2114191358u,101187582u,34078718u,524286u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,32766u,8078u,3590u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8176u,16383u,2013331455u,2080505854u,235143166u,101187582u,524286u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,131070u,32766u,16382u,8070u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8160u,8184u,1879064574u,2013331455u,470024190u,67371006u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,262142u,65534u,16382u,8160u,1024u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8128u,8184u,805322750u,402718719u,134479870u,524286u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,8184u,16382u,131071u,262142u,524286u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16382u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,1792u,8184u,16380u,65535u,262143u,524286u,524286u,1048574u,1048574u,1048575u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,65534u,16376u,16368u,1792u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8176u,16376u,32767u,262143u,524286u,1048574u,1048574u,1048575u,1048575u,1048575u,1048575u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4032u,8184u,32766u,262142u,524286u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,262142u,32766u,16376u,8176u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,384u,8184u,32766u,131070u,262142u,524286u,1048575u,1048574u,1048574u,1048574u,1048574u,1048574u,524286u,524286u,131070u,32766u,16368u,1920u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,4080u,32764u,65534u,262142u,524286u,524286u,524286u,1048574u,1048574u,524286u,524286u,524286u,262142u,131070u,32764u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,256u,16376u,32760u,131068u,262140u,262142u,524286u,524286u,524286u,524286u,524286u,262142u,131070u,65532u,16368u,3840u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3968u,32752u,65528u,131068u,262142u,262142u,262142u,262142u,262142u,262142u,262140u,131064u,32752u,7936u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,8064u,32736u,65528u,131070u,131070u,131070u,131070u,131070u,131070u,65532u,32752u,8160u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,3456u,16376u,32764u,65534u,65534u,65534u,32766u,32764u,16380u,4048u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,48u,2680u,8188u,8188u,8188u,8188u,4092u,120u,16u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,120u,248u,508u,508u,508u,248u,240u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,96u,240u,504u,504u,504u,240u,96u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,224u,224u,224u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u,0u);\n\n\n/*\n#define VOLUME_SIZE_X 15\n#define VOLUME_SIZE_Y 5\n#define VOLUME_SIZE_Z 1\nconst uint volume[VOLUME_SIZE_X * VOLUME_SIZE_Y] = uint[VOLUME_SIZE_X * VOLUME_SIZE_Y](\n    1u, 1u, 1u, 0u, 1u, 0u, 0u, 0u, 1u, 1u, 1u, 0u, 1u, 0u, 0u,\n    1u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 1u, 0u, 1u, 0u, 1u, 0u, 0u,\n    1u, 1u, 1u, 0u, 1u, 0u, 0u, 0u, 1u, 0u, 1u, 0u, 1u, 1u, 1u,\n    1u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 1u, 0u, 1u, 0u, 1u, 0u, 1u,\n    1u, 1u, 1u, 0u, 1u, 1u, 1u, 0u, 1u, 1u, 1u, 0u, 1u, 1u, 1u);\n*/\n\n\nuint getVoxel(ivec3 c){\n    /*\n    if (c.x < 0 ||\n        c.y < 0 ||\n        c.z < 0) return 0u;\n    if (c.x > VOLUME_SIZE_X - 1 ||\n        c.y > VOLUME_SIZE_Y - 1 ||\n        c.z > VOLUME_SIZE_Z - 1) return 0u;\n    */\n    \n    c %= 32;    \n    int index = c.x * VOLUME_SIZE_X + c.z;\n    return volume[index] & (1u << c.y);\n}\n\n\n// alhorithm from http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\nfloat voxelCast(vec3 ro, vec3 rd, float maxDist){\n    float t = 0.0;\n\tvec3 ic = floor(ro);\n\tvec3 stepC = sign(rd);\n    vec3 tDelta = abs(vec3(1) / rd);\n    vec3 dist = (ic - ro) * stepC + max(vec3(0), stepC);\n\tvec3 tMax = tDelta * dist;\n    \n    while (getVoxel(ivec3(ic)) == 0u && t < maxDist) {\n        float tMin = min(min(tMax.x, tMax.y), tMax.z);\n        t = tMin;\n        vec3 s = sign(vec3(tMin) - tMax) + vec3(1);\n        ic += stepC * s;\n        tMax += tDelta * s;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    //vec3 ro = texture(iChannel0, vec2(0, 0)).xyz + vec3(0, 30, 0);\n    vec3 ro = vec3(32, 32, 32);\n    vec3 rd = vec3(-1, 0, 0);\n    rd.y = m.y * 2.0 - 1.0;\n    rd.xz = vec2(1, 0) * rot(-m.x * 6.28) * sin(m.y * 3.14);\n    rd = normalize(rd);\n    rd = rotCam(uv, ro, rd, 1.0);\n\n    vec3 col = vec3(0.7, 0.7, 0.3) * (1.0 - voxelCast(ro, rd, MAX_DISTANCE) / MAX_DISTANCE);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "#define MAX_STEPS 128\n#define SURFACE_DIST 0.01\n#define MAX_DIST 3000.0\n#define NORMAL_EPSILON 0.01\n\nmat2 rot(float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotCam(vec2 uv, vec3 p, vec3 f, float z) {;\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = p + f * z;\n    vec3 i = c + uv.x * r + uv.y * u;\n    vec3 d = normalize(i - p);\n    return d;\n}", "buffer_a_code": "#define KEY_LEFT 65\n#define KEY_FORWARD 87\n#define KEY_RIGHT 68\n#define KEY_BACKWARD 83\n#define KEY_DASH 16\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    if (floor(fragCoord) == vec2(0, 0)) {\n        vec3 rd;\n        rd.y = m.y * 2.0 - 1.0;\n        rd.xz = vec2(1, 0) * rot(-m.x * 6.28) * sin(m.y * 3.14);\n        rd = normalize(rd);\n\n        float dash = texelFetch(iChannel1, ivec2(KEY_DASH,0), 0).x * 10.0 + 1.0;\n        float forward = texelFetch(iChannel1, ivec2(KEY_FORWARD,0), 0).x;\n        float backward = texelFetch(iChannel1, ivec2(KEY_BACKWARD,0), 0).x;\n        float right = texelFetch(iChannel1, ivec2(KEY_RIGHT,0), 0).x;\n        float left = texelFetch(iChannel1, ivec2(KEY_LEFT,0), 0).x;\n        vec3 pos = vec3(0, 0, 0);\n        if (iTime > 1.0)\n            pos = texture(iChannel0, vec2(0, 0)).xyz;\n            \n        pos += (forward - backward) * rd * 0.1 * dash;\n        pos += (right - left) * normalize(cross(vec3(0, 1, 0), rd)) * 0.1 * dash;\n        //pos += texture(iChannel0, vec2(1, 0)).xyz;\n        fragColor = vec4(pos, 0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6520, 6520, 6543, 6737, 6844], [6847, 6929, 6978, 6978, 7425], [7427, 7427, 7484, 7484, 7994]], "test": "untested"}
{"id": "wl3cRS", "name": "Nicolas ████", "author": "levonchic", "description": "[DATA EXPUNGED]", "tags": ["noise", "bitmap", "buffer", "creepy", "nicolascage"], "likes": 10, "viewed": 450, "published": 3, "date": "1609334575", "time_retrieved": "2024-07-30T20:27:39.683998", "image_code": "// MIT License (c) bitrate16\n\n// Ref: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Rotate cage\n    float s = sin(0.1);\n    float c = cos(0.1);\n    mat2 rot = mat2(c, -s, s, c);\n    fragCoord *= rot * 0.5;\n    fragCoord += iResolution.xy * 0.1;\n    \n    float SCALE = 57.6 / iResolution.y;\n\n    if (rand(fragCoord + iTime * 0.05) > 0.9)\n        fragColor += vec4(rand(fragCoord + iTime), rand(fragCoord + iTime * 1.1) * 1.1, rand(fragCoord + iTime * 1.2) * 1.1, 1.0);\n    \n    vec2 baseCoord = fragCoord * SCALE;\n    vec4 cage = vec4(\n        texelFetch(iChannel0, ivec2(baseCoord + vec2(sin(fract(-iTime * 2.8)), cos(fract(-iTime * 1.9))) * 0.5), 0).r,\n        texelFetch(iChannel0, ivec2(baseCoord + vec2(sin(fract(-iTime * 1.1)), sin(fract(iTime * 2.3))) * 0.4), 0).g,\n        texelFetch(iChannel0, ivec2(baseCoord + vec2(cos(fract(iTime * 2.1)), cos(fract(-iTime * 4.3))) * 0.65), 0).b,\n        1.0\n    );\n    \n    vec4 cageBase = texelFetch(iChannel0, ivec2(baseCoord), 0);\n    cage.r *= 1.1;\n    \n    fragColor += (cageBase * 0.5 + cage * 0.5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// MIT License (c) bitrate16\n// Texture, no buffering\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 frag = ivec2(fragCoord);\n    \n    if (frag.x >= WIDTH || frag.y >= HEIGHT)\n        return;\n    else {           \n\n        int px = frag.y * WIDTH + frag.x;\n        int pind = px / POINTS4INT;\n        int bind = px % POINTS4INT;\n\n        fragColor = palette[(matrix[pind] >> (bind * COLORBITS)) & COLORMASK];\n        fragColor *= fragColor.a;\n    }\n}", "buffer_a_inputs": [], "common_code": "// MIT License (c) bitrate16\n#define WIDTH 40\n#define HEIGHT 52\n#define COLORS 16\n#define COLORBITS 4\n#define COLORMASK 15\n#define POINTS4INT 8\n#define INTPERFRAME 260\n#define FRAMES 1\n\nvec4[16] palette = vec4[16] (\n\tvec4(0.9098039215686274, 0.592156862745098, 0.4, 1.0),\n\tvec4(0.6039215686274509, 0.32941176470588235, 0.17254901960784313, 1.0),\n\tvec4(0.3764705882352941, 0.17254901960784313, 0.043137254901960784, 1.0),\n\tvec4(0.996078431372549, 0.807843137254902, 0.5803921568627451, 1.0),\n\tvec4(0.18823529411764706, 0.08627450980392157, 0.00784313725490196, 1.0),\n\tvec4(0.8, 0.4588235294117647, 0.28627450980392155, 1.0),\n\tvec4(0.4117647058823529, 0.2901960784313726, 0.1450980392156863, 1.0),\n\tvec4(0.6745098039215687, 0.44313725490196076, 0.2823529411764706, 1.0),\n\tvec4(0.9607843137254902, 0.7215686274509804, 0.5215686274509804, 1.0),\n\tvec4(0.5294117647058824, 0.19215686274509805, 0.06274509803921569, 1.0),\n\tvec4(0.7176470588235294, 0.5450980392156862, 0.36470588235294116, 1.0),\n\tvec4(0.7803921568627451, 0.3686274509803922, 0.22745098039215686, 1.0),\n\tvec4(0.403921568627451, 0.3686274509803922, 0.25882352941176473, 1.0),\n\tvec4(1.0, 1.0, 0.9294117647058824, 1.0),\n\tvec4(1.0, 1.0, 0.0, 0.0),\n\tvec4(0.027450980392156862, 0.0, 0.0, 1.0)\n);\n\nint[260] matrix = int[260] (\n\n\n// Frame 0\n\t0x266eeeee,\n\t0xeeeeee42,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x17116eee,\n\t0xeee24266,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x75a776ee,\n\t0xe2442661,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x55000ace,\n\t0x22226617,\n\t0xeeeeeee2,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x5000007e,\n\t0x22661777,\n\t0xeeeee222,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xe,\n\t0x22611500,\n\t0xeeee2226,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0xae,\n\t0x21771000,\n\t0xeee22612,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x50000ae,\n\t0x6a770000,\n\t0xe2226162,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x705000ae,\n\t0x77507115,\n\t0x22621666,\n\t0xeeeeeee2,\n\t0xeeeeeeee,\n\t0x500000ae,\n\t0x1115b,\n\t0x22211617,\n\t0xee21e422,\n\t0xeeeeeeee,\n\t0xb00000a6,\n\t0x11991b,\n\t0x22211610,\n\t0xe9112422,\n\t0xeeeeeeee,\n\t0x915b080c,\n\t0x51f2111,\n\t0x22111118,\n\t0x92992222,\n\t0xeeeeeee2,\n\t0x91210806,\n\t0x741a222,\n\t0x26611151,\n\t0x29112222,\n\t0xeeeeeee2,\n\t0xd7f10007,\n\t0x7122a003,\n\t0x22111557,\n\t0x49911222,\n\t0xeeeeee92,\n\t0x33325807,\n\t0x71119108,\n\t0x62117001,\n\t0x29112222,\n\t0xeeeeee99,\n\t0x5039000a,\n\t0x71175555,\n\t0x61115001,\n\t0x22112222,\n\t0xeeeeef91,\n\t0x512100a,\n\t0x7115000,\n\t0x11150000,\n\t0x11162222,\n\t0xeeeeef99,\n\t0x7170a,\n\t0x5177700,\n\t0x11550000,\n\t0x912f2211,\n\t0xeeeef221,\n\t0x500a,\n\t0x99122170,\n\t0x11000083,\n\t0x24ff9211,\n\t0xeeeff211,\n\t0x55000200,\n\t0x22924221,\n\t0x15008330,\n\t0xfff21111,\n\t0xeeefffff,\n\t0x55000100,\n\t0x79157290,\n\t0x7b000300,\n\t0xfff21211,\n\t0xeeffffff,\n\t0x2009500,\n\t0x9b51150,\n\t0x15500030,\n\t0xfff21111,\n\t0xeeffffff,\n\t0x550000,\n\t0x11111b03,\n\t0x10000000,\n\t0xff411111,\n\t0xefffffff,\n\t0x333303,\n\t0x511b500,\n\t0x11115000,\n\t0xff211111,\n\t0xefffffff,\n\t0x833330e,\n\t0x1115000,\n\t0x22115100,\n\t0xf4211111,\n\t0xefffffff,\n\t0x3333338e,\n\t0x71110800,\n\t0x21172007,\n\t0xf2211111,\n\t0xefffffff,\n\t0x3388308e,\n\t0x11158003,\n\t0x2286f210,\n\t0xf4212211,\n\t0xffffffff,\n\t0x308880ee,\n\t0x11108003,\n\t0x1273ad17,\n\t0xf2212211,\n\t0xffffffff,\n\t0x38ee,\n\t0x11580000,\n\t0x1221111,\n\t0xf221262b,\n\t0xffffffff,\n\t0x50000eee,\n\t0x15830111,\n\t0x50522171,\n\t0xf22121f2,\n\t0xffffffff,\n\t0x60008eee,\n\t0x300134,\n\t0xf2777770,\n\t0x2221112f,\n\t0xfffffff4,\n\t0x63106eee,\n\t0x300136,\n\t0x4fff4217,\n\t0x22111172,\n\t0xffffff42,\n\t0x86106eee,\n\t0x800128,\n\t0x7644610,\n\t0x21111710,\n\t0xfffffff4,\n\t0x1102eeee,\n\t0x33317011,\n\t0x800303,\n\t0x21115550,\n\t0xff4ff422,\n\t0x82eeee,\n\t0x33301200,\n\t0x883333,\n\t0x21111550,\n\t0xfff4ff42,\n\t0xa66eeee,\n\t0x33381490,\n\t0x3333,\n\t0x21115550,\n\t0xfff44ff2,\n\t0x6446eeee,\n\t0x33338644,\n\t0x3333,\n\t0x21111500,\n\t0xef444ff4,\n\t0x284aeeee,\n\t0x3333306f,\n\t0x833333,\n\t0x21111500,\n\t0xef442fff,\n\t0x876eeeee,\n\t0x33333330,\n\t0x383333,\n\t0x42211550,\n\t0xeef42f4f,\n\t0x866eeeee,\n\t0x33333300,\n\t0x833333,\n\t0x42221150,\n\t0xeee424ff,\n\t0x74eeeeee,\n\t0x33333800,\n\t0x33333,\n\t0xfff44210,\n\t0xeeee444f,\n\t0x46eeeeee,\n\t0x33333888,\n\t0x833333,\n\t0xff4ff421,\n\t0xeeeeef4f,\n\t0x6eeeeeee,\n\t0x38308886,\n\t0x15083338,\n\t0xfff4f442,\n\t0xeeeeeeff,\n\t0xeeeeeeee,\n\t0x83a64,\n\t0x42100000,\n\t0xff4f4ff4,\n\t0xeeeeee44,\n\t0xeeeeeeee,\n\t0x7aa72646,\n\t0xf4222111,\n\t0xfffff4f4,\n\t0xeeeeeeef,\n\t0xeeeeeeee,\n\t0x2666624e,\n\t0xf4f44222,\n\t0x4f4f22ff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x244664ee,\n\t0x4444fff4,\n\t0xeef444ff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x22444eee,\n\t0x444f2f4f,\n\t0xee4f444f,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x24644eee,\n\t0xf4444f24,\n\t0xeeee4fff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x4644eeee,\n\t0xf4422442,\n\t0xeeeee4ff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x4cfeeeee,\n\t0xff44f24f,\n\t0xeeeeeeff,\n\t0xeeeeeeee,\n\t0xeeeeeeee,\n\t0x4eeeeeee,\n\t0xeeee4444,\n\t0xeeeeeeee,\n\t0xeeeeeeee\n);", "sound_code": "// MIT License (c) bitrate16\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec2 mainSound(int samp, float time) {\n    if (time > 8.)\n        return vec2(sin(6.2831 * 440.0 * fract(time))) * 0.05 * exp(-time + 8.)\n               +\n               vec2(sin(6.2831 * 430.0 * fract(time)) * exp(cos(fract(time) * 6.2831)) * 0.5\n                    +\n                    sin(6.2831 * 450.0 * fract(time * 0.1 + 0.7))\n                    +\n                    sin(6.2831 * 350.0 * fract(time * 0.75 + 0.1))\n                    +\n                    sin(6.2831 * 550.0 * fract(time * 0.25 + 0.25))\n                    +\n                    sin(6.2831 * 250.0 * fract(time * 0.25 + 0.75))\n                    +\n                    sin(6.2831 * 2250.0 * fract(0.5 + time * 0.01)) * 0.1) * 0.005 * (1.0 - exp(-time + 8.));\n    return vec2(sin(6.2831 * 440.0 * fract(time))) * 0.05 * step(0.5, fract(time) * 1.0);\n}", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3cRS.jpg", "access": "api", "license": "mit", "functions": [[30, 104, 124, 124, 191], [193, 193, 248, 267, 1224]], "test": "untested"}
{"id": "ttcyRS", "name": "oklab - optimized color mix", "author": "iq", "description": "Mixing linear-rgb colors in oklab space, but skipping 3 unnecessary 3x3 matrix transformations. Left: optimized oklab interpolation. Right: rgb interpolation. More info here: [url]https://bottosson.github.io/posts/oklab[/url]", "tags": ["2d", "color", "colorspace", "oklab"], "likes": 102, "viewed": 5305, "published": 3, "date": "1609332893", "time_retrieved": "2024-07-30T20:27:40.463913", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Optimized linear-rgb color mix in oklab space, useful\n// when our software operates in rgb space but we still\n// we want to have intuitive color mixing.\n//\n// Left: oaklab,\n// Right: rgb.\n//\n// Now, when mixing linear rgb colors in oklab space, the\n// linear transform from cone to Lab space and back can be\n// omitted, saving three 3x3 transformation per blend!\n//\n// oklab was invented by Björn Ottosson: https://bottosson.github.io/posts/oklab\n//\n// More oklab on Shadertoy: https://www.shadertoy.com/view/WtccD7\n\n\n\nvec3 oklab_mix( vec3 colA, vec3 colB, float h )\n{\n    // https://bottosson.github.io/posts/oklab\n    const mat3 kCONEtoLMS = mat3(                \n         0.4121656120,  0.2118591070,  0.0883097947,\n         0.5362752080,  0.6807189584,  0.2818474174,\n         0.0514575653,  0.1074065790,  0.6302613616);\n    const mat3 kLMStoCONE = mat3(\n         4.0767245293, -1.2681437731, -0.0041119885,\n        -3.3072168827,  2.6093323231, -0.7034763098,\n         0.2307590544, -0.3411344290,  1.7068625689);\n                    \n    // rgb to cone (arg of pow can't be negative)\n    vec3 lmsA = pow( kCONEtoLMS*colA, vec3(1.0/3.0) );\n    vec3 lmsB = pow( kCONEtoLMS*colB, vec3(1.0/3.0) );\n    // lerp\n    vec3 lms = mix( lmsA, lmsB, h );\n    // gain in the middle (no oaklab anymore, but looks better?)\n // lms *= 1.0+0.2*h*(1.0-h);\n    // cone to rgb\n    return kLMStoCONE*(lms*lms*lms);\n}\n\n//====================================================\n\n// example colors\nconst vec3 kCols[6] = vec3[6]( \n    vec3(1.00,1.00,1.00), vec3(0.00,0.00,1.00),\n    vec3(0.00,0.00,1.00), vec3(1.00,0.70,0.01),\n    vec3(0.91,0.14,0.01), vec3(0.01,0.20,1.00) );\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n\n    // choose colors to lerp\n    int id = int(floor(p.x*6.0));\n    int ba = id & 6; // yes, AND!\n    vec3 colA = kCols[ba+0];\n    vec3 colB = kCols[ba+1];\n\n    // approx srgb to linear (gamma to linear really)\n    colA = pow(colA,vec3(2.2));\n    colB = pow(colB,vec3(2.2));\n    \n    // oklab vs rgb\n    vec3 col = ((id&1)==0) ? oklab_mix( colA, colB, p.y ) :\n                                   mix( colA, colB, p.y );\n    \n    // approx linear to srgb (linear to gamma really)\n    col = pow(col,vec3(1.0/2.2) );\n\n    // black separators\n    col *= smoothstep(0.004,0.005,abs(fract(p.x*3.0+0.5)-0.5));\n   \n  \n    // output\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyRS.jpg", "access": "api", "license": "mit", "functions": [[1601, 1601, 1650, 1697, 2484], [2743, 2743, 2800, 2850, 3548]], "test": "untested"}
{"id": "3lcczB", "name": "Faster RayMarching", "author": "Ric3cir121", "description": "faster raymarching using a low resolution buffer as ai\ntry it with a low resolution texture like nyancat or with a video", "tags": ["raymarching", "optimization", "buffer", "faster"], "likes": 0, "viewed": 463, "published": 3, "date": "1609329707", "time_retrieved": "2024-07-30T20:27:41.353534", "image_code": "mat2 rotate(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec3 rotate(vec3 c,float r){return vec3(rotate(r)*c.xz,c.y).xzy;}\nfloat de(vec3 c){\n    vec2 r = iChannelResolution[1].xy;\n    float p = length(texelFetch(iChannel1,ivec2(mod(c.xz/2.,vec2(r.x/r.y,1.))*r.y),0))/300.;\n    return min(c.y+1.,length(c-vec3(0,0,3))-.3)+p;\n}\nvec4 doMarch(vec3 pos,vec3 cam){\n    int i = 0;\n    vec3 march = vec3(0);\n    float d = 1.;\n    \n    for(;i<100&&d>0.02&&length(march)<100.;i++){\n        d = de(pos+march);\n        march += d*cam;\n    }\n    return vec4(march+pos,i);\n}\nvec3 getnormal(vec3 n){\n    vec2 e = vec2(1.0,-1.0)*(n.y<0.002-1.?.002:.002);\n    return normalize(e.xyy*de(n+e.xyy)+e.yyx*de(n+e.yyx)+e.yxy*de(n+e.yxy)+e.xxx*de(n+e.xxx));\n}\nvoid mn(out vec4 o,vec2 u,float mmin){\n    vec2 uv = (u-iResolution.xy/2.)/iResolution.y;\n    vec3 pos = vec3(0);\n    vec2 look = vec2(0,0);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,-look.y).yxz,look.x);\n    \n    vec4 march = doMarch(mmin*cam,cam);\n    \n    if(length(march.xyz)<100.){\n        vec2 r = iChannelResolution[1].xy;\n        o = texelFetch(iChannel1,ivec2(mod(march.xz/2.,vec2(r.x/r.y,1.))*r.y),0);\n        o *= texture(iChannel3,reflect(cam,getnormal(march.xyz)));\n    } else \n        o = texture(iChannel2,cam);\n    \n}\nvoid mainImage(out vec4 o,vec2 u){\n    float m1 = length(texelFetch(iChannel0,ivec2(u/4.),0).xyz);\n    float m2 = length(texelFetch(iChannel0,ivec2(u/4.)+ivec2(0,1),0).xyz);\n    float m3 = length(texelFetch(iChannel0,ivec2(u/4.)+ivec2(0,-1),0).xyz);\n    float m4 = length(texelFetch(iChannel0,ivec2(u/4.)+ivec2(1,0),0).xyz);\n    float m5 = length(texelFetch(iChannel0,ivec2(u/4.)+ivec2(-1,0),0).xyz);\n    float mmin = min(min(m1,m2),min(m3,min(m4,m5)));\n    \n    o = vec4(0);\n    vec4 O = vec4(0);\n    int a = 3;\n    for(int ix = 0;ix < a;ix++){\n        for(int iy = 0;iy < a;iy++){\n            O = vec4(0);if(mmin != 0.)mn(O,u+vec2(ix,iy)/float(a),mmin);o += O;\n        }\n    }\n    o /= float(a*a);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rotate(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec3 rotate(vec3 c,float r){return vec3(rotate(r)*c.xz,c.y).xzy;}\nfloat de(vec3 c){\n    return min(c.y+1.,length(c-vec3(0,0,3))-.3);\n}\nvec4 doMarch(vec3 pos,vec3 cam){\n    int i = 0;\n    vec3 march = vec3(0);\n    float d = 1.;\n    \n    for(;i<200&&d>0.1&&length(march)<50.;i++){\n        d = de(pos+march);\n        march += d*cam;\n    }\n    return vec4(march+pos,i);\n}\nvoid mainImage(out vec4 o, in vec2 u){\n    if(u.x*4.>iResolution.x||u.y*4.>iResolution.y)return;\n    vec2 uv = (u*4.-iResolution.xy/2.)/iResolution.y;\n    \n    vec3 pos = vec3(0);\n    vec2 look = vec2(0);\n    vec3 cam = rotate(rotate(normalize(vec3(uv,1)).yxz,-look.y).yxz,look.x);\n    \n    vec4 march = doMarch(pos,cam);\n    \n    o = vec4(march);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcczB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 64], [65, 65, 93, 93, 130], [131, 131, 148, 148, 333], [334, 334, 366, 366, 568], [569, 569, 592, 592, 743], [744, 744, 782, 782, 1290], [1291, 1291, 1325, 1325, 1992]], "test": "untested"}
{"id": "Wt3yzB", "name": "Lichen Growth V2", "author": "andrinr", "description": "Updated version of: https://www.shadertoy.com/view/ttdcWM\nsome finetuning", "tags": ["automata", "cells", "gameoflife", "growth", "lichen"], "likes": 7, "viewed": 362, "published": 3, "date": "1609318697", "time_retrieved": "2024-07-30T20:27:42.184313", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 buffer = texture(iChannel0,uv).xyz;\n    fragColor = vec4(vec3((buffer.x)),1.);\n    //fragColor = vec4(buffer,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Andrin Rehmann\n// 2020\n// andrinrehmann.ch\n// andrinrehmann@gmail.com\n\n#define EXPANSION 2.5\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat rand( vec2 uv )\n{\n\tfloat t = fract( iTime );\n\treturn nrand( uv + 0.07*t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    // Cell\n\tfloat y = texture(iChannel0,uv).x;\n    // food\n    float f = texture(iChannel0,uv).z;\n    \n    // sum of surrounding y's\n    float s = 1./16. * texture(iChannel0,uv + vec2(-du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(-du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(-du,dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,-dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,dv)).x +\n              1./16. * texture(iChannel0,uv + vec2(du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(du,dv)).x;\n\n    // Grow cell when either enough food and enough cell material\n    // or enough food and enough cell material un surrounding pixels\n    if ((s > 0.5 || y > 0.5) && f > 0.8){\n        y += 0.1;\n    }\n    \n    // Cell eats food\n    if (y > 0.5){\n        f -= 0.01;\n    }\n    \n    // Cell dies when not enough food or to many surrounding cells\n    // Similar rule to game of life\n    if (f < 0.5 || s > 0.99){\n        y -= y * 0.1;\n    \n    }\n    \n    // Food regrows\n    f += 0.002;\n    \n    // Mouse interaction\n    if (distance(iMouse.xy, fragCoord) < 15. && iMouse.z > 0.){\n        f = rand(uv+vec2(0.2));\n        y = rand(uv);\n    }\n    \n    // Init\n    if (iFrame < 1){\n        y = rand(uv)*0.9;\n        f = 0.8;\n    }\n    \n    fragColor = vec4(y, 0, f, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3yzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 272]], "test": "untested"}
{"id": "3t3yzB", "name": "rot rings", "author": "bigdra50", "description": "rings", "tags": ["3d"], "likes": 4, "viewed": 255, "published": 3, "date": "1609316780", "time_retrieved": "2024-07-30T20:27:42.929321", "image_code": "\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define resolution iResolution \n#define  time iTime\n#define mouse iMouse \n\n\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define EPS 0.0001\n\nvec3 lightDir = normalize(vec3(1.,1., 1));\n\nfloat dRing(vec3 p, float exR, float inR, float thick){\n\tfloat sdf2d = abs(length(p.xy)-exR)-inR;\n\tfloat d = abs(p.z)-thick;\n\treturn max(sdf2d, d);\n}\nfloat map(vec3 p){\n\tvec3 q=p,r = p;\n\tp.xy *= rot(time*.5);\n\tp.xz *= rot(time*.3);\n\tfloat ring1 = dRing(p, .8, .09, .1);\n\tq.xy *= rot(time*-1.3);\n\tq.xz *= rot(time*-1.);\n\tfloat ring2 = dRing(q, .62, .07, .1);\n\tr.yz *= rot(time*2.);\n\tr.xz *= rot(time*-2.);\n\tfloat ring3 = dRing(r, .47, .06, .1);\n\treturn min(ring1, min(ring2, ring3));\n}\n\nvec3 getNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmap(p)-map(vec3(p.x-EPS, p.yz)),\n\t\tmap(p)-map(vec3(p.x, p.y-EPS, p.z)),\n\t\tmap(p)-map(vec3(p.xy, p.z-EPS))\n\t\t));\n}\n\t\n\nvec4 render(vec2 coord ) {\n\n\tvec2 uv = (gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x, resolution.y);\n\tvec3 col = vec3(.1);\n\tvec3 ro = vec3(0.,0,10.);\n\tvec3 rd = normalize(vec3(uv, 0)-ro);\n\tvec3 cur = ro;\n\n\tfor(int i = 0; i <99;i++){\n\t\tfloat d = map(cur);\n\t\tif(d < EPS){\n\t\t\tvec3 normal = getNormal(cur);\n\t\t\tcol = vec3(.6, .68, .8);\n\t\t\tcol+= dot(normal, lightDir)+vec3(.1);\n\t\t\tbreak;\n\t\t}\n\t\tcur += rd*d;\n\t}\n\n\treturn vec4( col, 1.0 );\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = render(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 316, 316, 410], [411, 411, 429, 429, 745], [747, 747, 770, 770, 910], [914, 914, 940, 940, 1353], [1355, 1355, 1409, 1409, 1446]], "test": "untested"}
{"id": "WtccRB", "name": "Alchemy Circles Generator", "author": "IWBTShyGuy", "description": "The based algorithm is referred from [url]https://github.com/CiaccoDavide/Alchemy-Circles-Generator[/url]", "tags": ["alchemy"], "likes": 8, "viewed": 430, "published": 3, "date": "1609315236", "time_retrieved": "2024-07-30T20:27:43.797001", "image_code": "// The MIT License\n// Copyright © 2020 IWBTShyGuy\n\nconst float PI = 3.141592653;\n\nconst float THICK = 0.015;\nconst float RADIUS = 0.75;\n\nconst vec3 LINE_COLOR = vec3(1.0);\nconst vec3 BACK_COLOR = vec3(0.0);\n\nconst int GEN_LENGTH = 8;\nvec2[GEN_LENGTH] generators() {\n    float year = floor(iDate.x + iTime);\n    float month = floor(iDate.y + iTime);\n    float day = floor(iDate.z + iTime);\n    float hour = floor(floor(iDate.w / 3600.0) + iTime);\n    float minute = floor(floor((iDate.w - hour * 3600.0) / 60.0) + iTime);\n\n    return vec2[](\n        vec2(year, day),\n        vec2(month, year),\n        vec2(month, day),\n        vec2(hour, minute),\n        vec2(year, minute),\n        vec2(month, hour),\n        vec2(minute, month),\n        vec2(year, hour)\n    );\n}\n\nfloat random(in vec2 c) {\n    const vec3 gen = vec3(114.514, 191.9810, 334.8040);\n    return fract(gen.x * sin(dot(gen.yz, c)));\n}\n\nvec4 drawLine(in vec2 p, in vec2 q, in vec2 uv, in vec4 fragColor) {\n    vec2 a = q - p;\n    vec2 b = uv - p;\n    float t = dot(b, a) / dot(a, a);\n    if (t < 0.0 || 1.0 < t) return fragColor;\n    vec2 h = b - t * a;\n    float irr = clamp(1.0 - dot(h, h) / (THICK * THICK), 0.0, 1.0);\n    return max(fragColor, vec4(irr * LINE_COLOR, 1.0));\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nCircle newCircle(in vec2 center, in float radius) {\n    Circle c;\n    c.center = center;\n    c.radius = radius;\n    return c;\n}\n\nvec4 drawCircle(in Circle circle, in vec2 uv, in vec4 fragColor) {\n    float dist = distance(uv, circle.center);\n    float irr = (dist - circle.radius) / THICK;\n    irr *= irr;\n    irr = clamp(1.0 - irr, 0.0, 1.0);\n    return max(fragColor, vec4(LINE_COLOR * irr, 1.0));\n}\n\nvec4 fillCircle(in Circle circle, in vec2 uv, in vec4 fragColor) {\n    float dist = distance(uv, circle.center);\n    if (dist < circle.radius) return vec4(BACK_COLOR, 1.0);\n    else return fragColor;\n}\n\nstruct Polygon {\n    vec2 center;\n    float radius;\n    float rotation;\n    int n_gon;\n};\n\nPolygon newPolygon(vec2 center, float radius, float rotation, int n_gon) {\n    Polygon poly;\n    poly.center = center;\n    poly.radius = radius;\n    poly.rotation = rotation;\n    poly.n_gon = n_gon;\n    return poly;\n}\n\nvec4 drawPolygon(in Polygon poly, in vec2 uv, in vec4 fragColor) {\n    for (int i = 0; i < poly.n_gon; i++) {\n        float t0 = poly.rotation + float(i) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p0 = poly.center + poly.radius * vec2(cos(t0), sin(t0));\n        float t1 = poly.rotation + float(i + 1) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p1 = poly.center + poly.radius * vec2(cos(t1), sin(t1));\n        fragColor = drawLine(p0, p1, uv, fragColor);\n    }\n    return fragColor;\n}\n\nvec4 fillPolygon(in Polygon poly, in vec2 uv, in vec4 fragColor) {\n    int counter = 0;\n    for (int i = 0; i < poly.n_gon; i++) {\n        float t0 = poly.rotation + float(i) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p0 = poly.center + poly.radius * vec2(cos(t0), sin(t0));\n        float t1 = poly.rotation + float(i + 1) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p1 = poly.center + poly.radius * vec2(cos(t1), sin(t1));\n        vec2 a = p0 - uv;\n        vec2 b = p1 - uv;\n        if (a.y >= 0.0 && b.y < 0.0) {\n            float x = a.x - a.y / b.y * b.x;\n            if (x > 0.0) counter -= 1;\n        } else if (a.y <= 0.0 && b.y > 0.0) {\n            float x = a.x - a.y / b.y * b.x;\n            if (x > 0.0) counter += 1;\n        }\n    }\n    if (counter > 0) return vec4(BACK_COLOR, 1.0);\n    else return fragColor;\n}\n\nvec4 drawRadial(in Polygon poly, in vec2 uv, in vec4 fragColor) {\n    for (int i = 0; i < poly.n_gon; i++) {\n        float t = poly.rotation + float(i) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p = poly.center + poly.radius * vec2(cos(t), sin(t));\n        fragColor = drawLine(poly.center, p, uv, fragColor);\n    }\n    return fragColor;\n}\n\nvec4 drawPartialRadial(in Polygon poly, in float inner_radius, in vec2 uv, in vec4 fragColor) {\n    for (int i = 0; i < poly.n_gon; i++) {\n        float t = poly.rotation + float(i) / float(poly.n_gon) * 2.0 * PI;\n        vec2 p = poly.center + inner_radius * vec2(cos(t), sin(t));\n        vec2 q = poly.center + poly.radius * vec2(cos(t), sin(t));\n        fragColor = drawLine(p, q, uv, fragColor);\n    }\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 generators[GEN_LENGTH] = generators();\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    fragColor = vec4(BACK_COLOR, 1.0);\n\n    Circle c0 = newCircle(vec2(0.0), RADIUS);\n    fragColor = drawCircle(c0, uv, fragColor);\n    \n    int n = int(4.0 + 4.999 * random(generators[0])), n0;\n    Polygon poly = newPolygon(vec2(0.0), RADIUS, 0.0, n);\n    fragColor = drawPolygon(poly, uv, fragColor);\n    fragColor = drawRadial(poly, uv, fragColor);\n\n    float r = random(generators[1]);\n    if (poly.n_gon % 2 == 0) {\n        n0 = 0.6 < r ? 6 : 0.2 < r ? 4 : 2;\n        Polygon poly = newPolygon(vec2(0.0), RADIUS, 0.0, n0);\n        fragColor = fillPolygon(poly, uv, fragColor);\n        fragColor = drawPolygon(poly, uv, fragColor);\n        fragColor = drawRadial(poly, uv, fragColor);\n    } else {\n        n0 = r < 0.5 ? 4 : 6;\n        Polygon poly = newPolygon(vec2(0.0), RADIUS, 0.0, n0);\n        fragColor = fillPolygon(poly, uv, fragColor);\n        fragColor = drawPolygon(poly, uv, fragColor);\n    }\n\n    r = random(generators[2]);\n    if (r < 0.5) {\n        float r = random(generators[3]);\n        if (r < 0.5) {\n            Polygon poly = newPolygon(vec2(0.0), RADIUS * 0.625, 0.0, n + 4);\n            fragColor = drawRadial(poly, uv, fragColor);\n            poly.radius = RADIUS * 0.5;\n            fragColor = fillPolygon(poly, uv, fragColor);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        } else if (n > 5) {\n            Polygon poly = newPolygon(vec2(0.0), RADIUS * 0.625, 0.0, n - 2);\n            fragColor = drawRadial(poly, uv, fragColor);\n            poly.radius = RADIUS * 0.25;\n            fragColor = fillPolygon(poly, uv, fragColor);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        }\n    }\n\n    r = random(generators[4]);\n    if (r < 0.6) {\n        Circle c = newCircle(vec2(0.0), RADIUS * 0.6875);\n        fragColor = drawCircle(c, uv, fragColor);\n        float r = random(generators[5]);\n        if (n % 2 == 0) {\n            float r7 = 7.0 * r;\n            n0 = 5.0 < r7 ? 8 : 3.0 < r ? 6 : 1.0 < r7 ? 4 : 2;\n            Polygon poly = newPolygon(vec2(0.0), RADIUS / 1.5, 0.0, n0);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        } else {\n            float r3 = 3.0 * r;\n            n0 = 2.0 < r3 ? 3 : 1.0 < r3 ? 5 : 7;\n            Polygon poly = newPolygon(vec2(0.0), RADIUS / 1.5, PI, n0);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        }\n    }\n\n    r = random(generators[6]);\n    if (r < 0.25) {\n        for (int i = 0; i < n0; i++) {\n            float theta = float(i) / float(n0) * 2.0 * PI;\n            vec2 center = vec2(cos(theta), sin(theta)) * 11.0 / 18.0 * RADIUS;\n            Circle c = newCircle(center, RADIUS * 3.0 / 22.0);\n            fragColor = fillCircle(c, uv, fragColor);\n            fragColor = drawCircle(c, uv, fragColor);\n        }\n    } else if (r < 0.5) {\n        for (int i = 0; i < n0; i++) {\n            float theta = float(i) / float(n0) * 2.0 * PI;\n            vec2 center = vec2(cos(theta), sin(theta)) * RADIUS;\n            Circle c = newCircle(center, RADIUS * 3.0 / 22.0);\n            fragColor = fillCircle(c, uv, fragColor);\n            fragColor = drawCircle(c, uv, fragColor);\n        }\n    } else if (r < 0.75) {\n        Circle c = newCircle(vec2(0.0), RADIUS / 3.0);\n        fragColor = drawCircle(c, uv, fragColor);\n        c.radius = 3.0 / 11.0 * RADIUS;\n        fragColor = fillCircle(c, uv, fragColor);\n        fragColor = drawCircle(c, uv, fragColor);\n    } else {\n        Polygon poly = newPolygon(vec2(0.0), RADIUS, 0.0, n0);\n        fragColor = drawPartialRadial(poly, RADIUS / 1.5, uv, fragColor);\n        if (n != n0) {\n            Circle c = newCircle(vec2(0.0), RADIUS / 1.5);\n            fragColor = fillCircle(c, uv, fragColor);\n            fragColor = drawCircle(c, uv, fragColor);\n            r = random(generators[7]);\n            int n = r < 0.25 ? 3 : r < 0.5 ? 4 : r < 0.75 ? 5 : 6;\n            Polygon poly = newPolygon(vec2(0.0), RADIUS * 1.25, 0.0, n);\n            fragColor = drawPolygon(poly, uv, fragColor);\n            poly = newPolygon(vec2(0.0), RADIUS / 1.5, PI, n);\n            fragColor = drawPolygon(poly, uv, fragColor);\n        }\n    }\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtccRB.jpg", "access": "api", "license": "mit", "functions": [[767, 767, 792, 792, 897], [899, 899, 967, 967, 1241], [1298, 1298, 1349, 1349, 1425], [1427, 1427, 1493, 1493, 1699], [1701, 1701, 1767, 1767, 1902], [1995, 1995, 2069, 2069, 2212], [2214, 2214, 2280, 2280, 2702], [2704, 2704, 2770, 2770, 3531], [3533, 3533, 3598, 3598, 3874], [3876, 3876, 3971, 3971, 4305], [4307, 4307, 4362, 4362, 8604]], "test": "untested"}
{"id": "WtcyRB", "name": "Vraymtl_GLSL", "author": "unrealwilson", "description": "A reference GLSL implementation of the VRayMtl material", "tags": ["vraymaterialshadervrayglsl"], "likes": 1, "viewed": 256, "published": 3, "date": "1609308863", "time_retrieved": "2024-07-30T20:27:45.329902", "image_code": "//********************************************************************\n// V-Ray Material Shader\n//\n// Copyright (c) 2020 Chaos Software Ltd\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//********************************************************************\n\nprecision highp float;\n\n#define PI 3.1415926535897932384626433832795\n#define INV_PI 0.31830988618\n#define INV_2PI 0.15915494309\n// A spherical env map affects how the LOD is computed based on normal\n#define ENV_MAP_SPHERICAL 0\n// How many env samples to take - increase for rougher surfaces\n#define NUM_ENV_SAMPLES 8\n// Additional samples added for rough reflection & refraction\n#define NUM_ENV_SAMPLES_ROUGH 16\n// Set to 1 to use a procedural checker environment (useful for local testing)\n#define PROCEDURAL_ENV 1\n\n// Conductor Fresnel values for sheen\n#define SHEEN_N 2.9114\n#define SHEEN_K 3.0893\n\n// color conversion\nvec3 srgb_from_rgb(vec3 rgb) {\n\tvec3 a = vec3(0.055, 0.055, 0.055);\n\tvec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n\tvec3 g = vec3(2.4, 2.4, 2.4);\n\tvec3 ginv = 1.0 / g;\n\tvec3 select = step(vec3(0.0031308, 0.0031308, 0.0031308), rgb);\n\tvec3 lo = rgb * 12.92;\n\tvec3 hi = ap1 * pow(rgb, ginv) - a;\n\treturn mix(lo, hi, select);\n}\n\nvec3 rgb_from_srgb(vec3 srgb) {\n\tvec3 a = vec3(0.055, 0.055, 0.055);\n\tvec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n\tvec3 g = vec3(2.4, 2.4, 2.4);\n\tvec3 select = step(vec3(0.04045, 0.04045, 0.04045), srgb);\n\tvec3 lo = srgb / 12.92;\n\tvec3 hi = pow((srgb + a) / ap1, g);\n\treturn mix(lo, hi, select);\n}\n\n\n// Engine-specific functions {{{\n// These must be implemented depending on your engine\n// The implementation here is for use in ShaderToy, with env map in iChannel0\n// Note that the TextureEnvMapLOD and EnvIrradiance functions must return linear rgb\n\n// Get maximum lod for texture env\nfloat engGetMaxEnvLOD() {\n\tivec2 envSize = textureSize(iChannel0, 0);\n\tfloat minsz = float(max(envSize.x, envSize.y));\n\treturn log2(minsz);\n}\n\n// Convert Cartesian vector to spherical coordinates\nvec2 toSpherical(vec3 dir) {\n\tfloat alpha, beta;\n\tif (dir.z * dir.z + dir.x * dir.x < 1e-12) {\n\t\talpha = 0.0;\n\t\tbeta = (dir.y > 0.0) ? 0.0 : 1.0;\n\t} else {\n\t\talpha = atan(dir.z, dir.x) * INV_PI;\n\t\tbeta = acos(clamp(dir.y, -1.0, 1.0)) * INV_PI;\n\t}\n\n\tfloat u = alpha * 0.5 + 0.5;\n\tfloat v = beta;\n\treturn vec2(u, v);\n}\n\nvec3 sampleCheckerEnv(vec3 dir) {\n\tvec2 uv = toSpherical(dir);\n\tfloat size = 0.1;\n\tint x = int(floor(uv.x / size));\n\tint y = int(floor(uv.y / size));\n\treturn vec3(1.0 - float((x + y) & 1));\n}\n\n// Sample environment with LOD\nvec3 engTextureEnvMapLOD(vec3 dir, float lod) {\n#if PROCEDURAL_ENV == 1\n\treturn sampleCheckerEnv(dir);\n#else\n    vec3 color;\n#   if ENV_MAP_SPHERICAL\n    vec2 texcoord = toSpherical(dir);\n    texcoord.y = 1.0 - texcoord.y;\n    color = textureLod(iChannel0, texcoord, lod).xyz;\n#   else\n    color = textureLod(iChannel0, dir, lod).xyz;\n#   endif\n    return rgb_from_srgb(color);\n#endif\n}\n\n// Diffuse environment light (averaged over the hemisphere)\nvec3 engEnvIrradiance(vec3 dir) {\n#if PROCEDURAL_ENV == 1\n\treturn sampleCheckerEnv(dir);\n#else\n\tfloat lod = max(0.0, engGetMaxEnvLOD() - 1.0);\n\treturn rgb_from_srgb(textureLod(iChannel0, dir, lod).xyz);\n#endif\n}\n\n/// Get the LOD for sampling the environment\n/// @param Wn World-space normal\n/// @param p Probability of this direction (from sampleBRDF)\n/// @param numSamples Number of environment samples for the BRDF\nfloat computeEnvLOD(vec3 Wn, float p, int numSamples) {\n#if ENV_MAP_SPHERICAL\n\tfloat distortion = sqrt(max(0.0, 1.0 - Wn.y * Wn.y));\n#else\n\tfloat distortion = 1.0;\n#endif\n\tif (numSamples < 2) {\n\t\treturn 0.0;\n\t} else {\n\t\treturn max(0.0, (engGetMaxEnvLOD() - 0.5 * log2(1.0 + float(numSamples) * p * INV_2PI * distortion)));\n\t}\n}\n\n// }}} engine-specific functions\n\nstruct VRayMtlInitParams {\n\tvec3 Vw;\n\tvec3 geomNormal;\n\tvec3 diffuseColor;\n\tfloat diffuseAmount;\n\tfloat roughness;\n\tvec3 selfIllum;\n\tvec3 reflColor;\n\tfloat reflAmount;\n\tfloat reflGloss;\n\tbool traceReflections;\n\tfloat metalness;\n\tfloat aniso;\n\tfloat anisoRotation;\n\tint anisoAxis;\n\tvec3 opacity;\n\tvec3 refractionColor;\n\tfloat refractionAmount;\n\tfloat refrGloss;\n\tbool traceRefractions;\n\tfloat refractionIOR;\n\tbool useFresnel;\n\tfloat fresnelIOR;\n\tbool lockFresnelIOR;\n\tbool doubleSided;\n\tbool useRoughness;\n\tfloat gtrGamma;\n\tint brdfType;\n\tvec3 fogColor;\n\tfloat fogMult;\n\tfloat fogBias;\n\tbool sssOn;\n\tvec3 translucencyColor;\n\tfloat sssFwdBackCoeff;\n\tfloat sssScatterCoeff;\n\tfloat thickness;\n\tfloat distToCamera;\n\tvec3 sheenColor;\n\tfloat sheenAmount;\n\tfloat sheenGlossiness;\n\tvec3 coatColor;\n\tfloat coatAmount;\n\tfloat coatGlossiness;\n\tfloat coatIOR;\n};\n\nstruct VRayMtlContext {\n\tvec3 geomNormal;\n\tfloat gloss1;\n\tfloat roughnessSqr;\n\tfloat reflGloss;\n\tvec3 e;\n\tvec3 diff;\n\tfloat fresnel;\n\tvec3 refl;\n\tvec3 refr;\n\tvec3 illum;\n\tvec3 opacity;\n\tfloat rtermA;\n\tfloat rtermB;\n\tfloat gtrGamma;\n\tfloat fragmentNoise; // per-fragment noise value\n\tmat3 nm;\n\tmat3 inm;\n\tvec3 sheen;\n\tbool hasSheen;\n\tfloat sheenGloss;\n\tvec3 coat;\n\tmat3 coatNM;\n\tfloat coatRoughnessSqr;\n\tbool hasCoat;\n};\n\nvec3 sampleBRDF(VRayMtlInitParams params, VRayMtlContext ctx,\n\t\tint sampleIdx, int nbSamples, out float brdfContrib);\nvec3 sampleRefractBRDF(VRayMtlInitParams params, VRayMtlContext ctx,\n\t\tint sampleIdx, int nbSamples, out bool totalInternalReflection);\n\nVRayMtlContext initVRayMtlContext(VRayMtlInitParams initParams);\n\nvec3 computeDirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\nvec3 computeDirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\nvec3 computeDirectSheenContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\nvec3 computeDirectCoatContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir);\n\nvec3 computeIndirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx);\nvec3 computeIndirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx);\nvec3 computeIndirectRefractionContribution(VRayMtlInitParams params, VRayMtlContext ctx, float alpha, vec3 alphaDir);\nvec3 computeIndirectSheenContribution(VRayMtlInitParams params, VRayMtlContext ctx);\nvec3 computeIndirectCoatContribution(VRayMtlInitParams params, VRayMtlContext ctx);\n\nvec3 computeRefractFogContrib(VRayMtlInitParams params, VRayMtlContext ctx, vec3 diffuseContrib);\n\n// utility functions {{{\n\nfloat sqr(float x) {\n\treturn x * x;\n}\n\n// return random number in [0, 1)\nfloat hashRand(vec2 co) {\n\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// return random vector in [0, 1)\nvec2 rand(VRayMtlContext ctx, int sampleIdx, int nbSamples) {\n\t// fibonacci spiral distribution using the plastic constant\n\tconst float plast = 1.324717957244746;\n\tconst float invPlast = 1.0/plast;\n\treturn vec2(\n\t\tfract(float(sampleIdx + 1) * invPlast),\n\t\tfloat(sampleIdx) / float(nbSamples) + ctx.fragmentNoise\n\t);\n}\n\nfloat intensity(vec3 v) {\n\treturn (v.x + v.y + v.z) / 3.0;\n}\n\nvec3 whiteComplement(vec3 x) {\n\treturn clamp(1.0 - x, 0.0, 1.0);\n}\n\n// }}} end utility functions\n\n/// Compute the two orthogonal vectors to a given input vector\n/// @param n Input vector\n/// @param[out] u The first orthogonal vector\n/// @param[out] v The second orthogonal vector\nvoid computeTangentVectors(vec3 n, out vec3 u, out vec3 v) {\n\t// It doesn't matter what these vectors are, the result vectors just need to be perpendicular to the normal and to\n\t// each other\n\tu = cross(n, vec3(0.643782, 0.98432, 0.324632));\n\tif (length(u) < 1e-6)\n\t\tu = cross(n, vec3(0.432902, 0.43223, 0.908953));\n\tu = normalize(u);\n\tv = normalize(cross(n, u));\n}\n\n/// Make an orthogonal matrix given a surface normal\n/// @param n The normal vector\n/// @param[out] m The output orthogonal matrix with n in the third column\nvoid makeNormalMatrix(in vec3 n, out mat3 m) {\n\tcomputeTangentVectors(n, m[0], m[1]);\n\tm[2] = n;\n}\n\n/// Get the Fresnel reflectance for a dielectric.\n/// @param fresnelIOR Surface index of refraction\n/// @param e View direction\n/// @param n Surface normal\n/// @param refractDir Refracted view direction\n/// @return Fresnel reflectance\nfloat getFresnelCoeff(float fresnelIOR, vec3 e, vec3 n, vec3 refractDir) {\n\tif (abs(fresnelIOR - 1.0) < 1e-6)\n\t\treturn 0.0;\n\n\tfloat cosIn = -dot(e, n);\n\tfloat cosR = -dot(refractDir, n);\n\n\tif (cosIn > 1.0 - 1e-12 || cosR > 1.0 - 1e-12) { // View direction is perpendicular to the surface\n\t\tfloat f = (fresnelIOR - 1.0) / (fresnelIOR + 1.0);\n\t\treturn f * f;\n\t}\n\n\tfloat ks = (cosR / cosIn) * fresnelIOR;\n\tfloat fs2 = (ks - 1.0) / (ks + 1.0);\n\tfloat Fs = fs2 * fs2;\n\n\tfloat kp = (cosIn / cosR) * fresnelIOR;\n\tfloat fp2 = (kp - 1.0) / (kp + 1.0);\n\tfloat Fp = fp2 * fp2;\n\n\treturn 0.5 * (Fs + Fp);\n}\n\n/// Get the Fresnel reflectance for a conductor.\n/// Accurate values for n and k can be obtained from https://refractiveindex.info/\n/// For some conductors the n and k parameters vary with the light wavelength so the\n/// Fresnel reflectance should be computed separately for R,G and B.\n/// @param cosTheta Cosine of the angle between the view direction and the normal\n/// @param n Refractive index\n/// @param k Extinction coefficient\n/// @return Fresnel reflectance.\nfloat getConductorFresnel(float cosTheta, float n, float k) {\n\tfloat c2 = cosTheta * cosTheta;\n\tfloat n2k2 = n * n + k * k;\n\tfloat nc2 = 2.0f * n * cosTheta;\n\tfloat rsa = n2k2 + c2;\n\tfloat rpa = n2k2 * c2 + 1.0f;\n\tfloat rs = (rsa - nc2) / (rsa + nc2);\n\tfloat rp = (rpa - nc2) / (rpa + nc2);\n\treturn 0.5f * (rs + rp);\n}\n\nvec3 getSpecularDir(float u, float v, float k) {\n\tfloat thetaSin = clamp(pow(u, 1.0 / (k + 1.0)), 0.0, 1.0);\n\tfloat thetaCos = sqrt(1.0 - thetaSin * thetaSin);\n\tfloat phi = 2.0 * PI * v;\n\treturn vec3(cos(phi) * thetaCos, sin(phi) * thetaCos, thetaSin);\n}\n\nvec3 getPhongDir(float uc, float vc, float glossiness, vec3 view, mat3 nm) {\n\tvec3 reflectDir = reflect(-view, nm[2]);\n\tvec3 s = cross(vec3(0, 1, 0), reflectDir);\n\tvec3 s1 = cross(reflectDir, s);\n\tmat3 m;\n\tm[0] = normalize(s);\n\tm[1] = normalize(s1);\n\tm[2] = normalize(reflectDir);\n\tvec3 sampleDir = getSpecularDir(uc, vc, glossiness);\n\treturn m * sampleDir;\n}\n\nvec3 getBlinnDir(float uc, float vc, float glossiness, vec3 view, mat3 nm) {\n\tvec3 nn = getSpecularDir(uc, vc, glossiness);\n\tvec3 h = normalize(nm * nn);\n\tfloat cs = 2.0 * dot(h, view);\n\tvec3 dir = normalize(-view + cs * h);\n\treturn dir;\n}\n\nvec3 getSphereDir(float u, float v) {\n\tfloat thetaSin = u;\n\tfloat thetaCos = sqrt(1.0 - thetaSin * thetaSin);\n\tfloat phi = 2.0 * PI * v;\n\treturn vec3(cos(phi) * thetaCos, sin(phi) * thetaCos, thetaSin);\n}\n\nvec3 getDiffuseDir(float u, float v) {\n\tfloat thetaSin = sqrt(u);\n\tfloat thetaCos = sqrt(1.0 - u);\n\tfloat phi = 2.0 * PI * v;\n\treturn vec3(cos(phi) * thetaCos, sin(phi) * thetaCos, thetaSin);\n}\n\nvec3 getWardDir(float u, float v, float glossiness, vec3 view, mat3 nm) {\n\tif (u >= 1.0)\n\t\tu -= 1.0;\n\n\tfloat k = -log(1.0 - u);\n\tif (k < 0.0)\n\t\tk = 0.0;\n\n\tfloat thetaCos = sqrt(1.0 / (glossiness * k + 1.0));\n\tvec3 hn = getSphereDir(thetaCos, v);\n\tvec3 hw = normalize(nm * hn);\n\tvec3 dir = reflect(-view, hw);\n\treturn dir;\n}\n\nvec3 getGTR1MicroNormal(float uc, float vc, float sharpness) {\n\tfloat sharpness2 = min(sharpness * sharpness, 0.999);\n\tfloat thetaCosSqr = (1.0 - pow(sharpness2, 1.0 - uc)) / (1.0 - sharpness2);\n\tfloat thetaCos = sqrt(thetaCosSqr);\n\tfloat thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n\n\tfloat phi = 2.0 * PI * vc;\n\treturn vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n}\n\n// Specific implementation when gamma == 2. See section B.2 Physically-Based Shading at Disney from SIGGRAPH 2012\nvec3 getGTR2MicroNormal(float uc, float vc, float sharpness) {\n\tfloat thetaCosSqr = (1.0 - uc) / (1.0 + (sharpness * sharpness - 1.0) * uc);\n\tfloat thetaCos = sqrt(thetaCosSqr);\n\tfloat thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n\n\tfloat phi = 2.0 * PI * vc;\n\treturn vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n}\n\n// General implementation  when gamma != 1 and != 2. See section B.2 Physically-Based Shading at Disney from SIGGRAPH 2012\nvec3 getGTRMicroNormal(float uc, float vc, float sharpness, float gtrGamma) {\n\tfloat sharpness2 = min(sharpness * sharpness, 0.999);\n\tfloat thetaCosSqr =\n\t\t(1.0 - pow(pow(sharpness2, 1.0 - gtrGamma) * (1.0 - uc) + uc, 1.0 / (1.0 - gtrGamma))) / (1.0 - sharpness2);\n\tfloat thetaCos = sqrt(thetaCosSqr);\n\tfloat thetaSin = sqrt(max(1.0 - thetaCosSqr, 0.0));\n\n\tfloat phi = 2.0 * PI * vc;\n\treturn vec3(cos(phi) * thetaSin, sin(phi) * thetaSin, thetaCos);\n}\n\nvec3 getGGXMicroNormal(float uc, float vc, float sharpness, float gtrGamma) {\n\tif (abs(gtrGamma - 1.0) < 1e-3)\n\t\treturn getGTR1MicroNormal(uc, vc, sharpness);\n\telse if (abs(gtrGamma - 2.0) < 1e-3)\n\t\treturn getGTR2MicroNormal(uc, vc, sharpness);\n\telse // if (gtrLowerLimit <= gtrGamma && gtrGamma <= gtrUpperLimit)\n\t\treturn getGTRMicroNormal(uc, vc, sharpness, gtrGamma);\n}\n\nfloat getGTR1MicrofacetDistribution(float mz, float sharpness) {\n\tfloat cosThetaM = mz; // dotf(microNormal, normal);\n\tif (cosThetaM <= 1e-3)\n\t\treturn 0.0;\n\n\tfloat cosThetaM2 = sqr(cosThetaM);\n\tfloat tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n\tfloat sharpness2 = sqr(sharpness);\n\tfloat div = PI * log(sharpness2) * cosThetaM2 * (sharpness2 + tanThetaM2);\n\t// when div<(sharpness2-1.0)*1e-6 no division by zero will occur (the dividend and the divisor are always negative);\n\t// div can get 0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n\t// and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n\tfloat res = (div < (sharpness2 - 1.0) * 1e-6) ? (sharpness2 - 1.0) / div : 0.0;\n\n\treturn res;\n}\n\nfloat getGTR2MicrofacetDistribution(float mz, float sharpness) {\n\tfloat cosThetaM = mz; // dotf(microNormal, normal);\n\tif (cosThetaM <= 1e-3)\n\t\treturn 0.0;\n\n\tfloat cosThetaM2 = sqr(cosThetaM);\n\tfloat tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n\tfloat sharpness2 = sqr(sharpness);\n\tfloat div = PI * sqr(cosThetaM2 * (sharpness2 + tanThetaM2));\n\t// when div>sharpness2*1e-6 no division by zero will occur (the dividend and the divisor are always positive);\n\t// div canget0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n\t// and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n\tfloat res = (div > sharpness2 * 1e-6) ? sharpness2 / div : 0.0;\n\n\treturn res;\n}\n\nfloat getGTRMicrofacetDistribution(float mz, float sharpness, float gtrGamma) {\n\tfloat cosThetaM = mz; // dotf(microNormal, normal);\n\tif (cosThetaM <= 1e-3)\n\t\treturn 0.0;\n\n\tfloat cosThetaM2 = sqr(cosThetaM);\n\tfloat tanThetaM2 = (1.0 / cosThetaM2) - 1.0;\n\tfloat sharpness2 = sqr(sharpness);\n\tfloat divisor =\n\t\tPI * (1.0 - pow(sharpness2, 1.0 - gtrGamma)) * pow(cosThetaM2 * (sharpness2 + tanThetaM2), gtrGamma);\n\tfloat dividend = (gtrGamma - 1.0) * (sharpness2 - 1.0);\n\t// when fabsf(divisor)>fabsf(dividend)*1e-6 no division by zero will occur\n\t// (the dividend and the divisor are always either both positive or both negative);\n\t// divisor canget0 in rare situation when the sharpness read from texture mapped in reflection glossines is 0\n\t// and cosThetaM is 1 (and consequently tanThetaM2 is 0);\n\tfloat res = (abs(divisor) > abs(dividend) * 1e-6) ? dividend / divisor : 0.0;\n\n\treturn res;\n}\n\nfloat getGGXMicrofacetDistribution(float cosNH, float sharpness, float gtrGamma) {\n\tif (abs(gtrGamma - 1.0) < 1e-3)\n\t\treturn getGTR1MicrofacetDistribution(cosNH, sharpness);\n\telse if (abs(gtrGamma - 2.0) < 1e-3)\n\t\treturn getGTR2MicrofacetDistribution(cosNH, sharpness);\n\telse // if (gtrLowerLimit <= gtrGamma && gtrGamma <= gtrUpperLimit)\n\t\treturn getGTRMicrofacetDistribution(cosNH, sharpness, gtrGamma);\n}\n\nfloat getGTRMonodirectionalShadowing0(float cotThetaV) {\n\treturn 2.0 / (1.0 + sqrt(1.0 + 1.0 / (cotThetaV * cotThetaV)));\n}\n\nfloat getGTRMonodirectionalShadowing1(float sharpness, float cotThetaV) {\n\tfloat cotThetaV2 = sqr(cotThetaV);\n\tfloat sharpness2 = min(0.999, sqr(sharpness));\n\tfloat a = sqrt(cotThetaV2 + sharpness2);\n\tfloat b = sqrt(cotThetaV2 + 1.0);\n\treturn cotThetaV * log(sharpness2) / (a - b + cotThetaV * log(sharpness2 * (cotThetaV + b) / (cotThetaV + a)));\n}\n\nfloat getGTRMonodirectionalShadowing2(float sharpness, float cotThetaV) {\n\treturn 2.0 / (1.0 + sqrt(1.0 + sqr(sharpness / cotThetaV)));\n}\n\nfloat getGTRMonodirectionalShadowing3(float sharpness, float cotThetaV) {\n\tfloat cotThetaV2 = sqr(cotThetaV);\n\tfloat sharpness2 = min(0.999, sqr(sharpness));\n\tfloat a = sqrt(cotThetaV2 + sharpness2);\n\tfloat b = sharpness2 + 1.0;\n\treturn 4.0 * cotThetaV * a * b / (2.0 * cotThetaV * b * (cotThetaV + a) + sharpness2 * (3.0 * sharpness2 + 1.0));\n}\n\nfloat getGTRMonodirectionalShadowing4(float sharpness, float cotThetaV) {\n\tfloat cotThetaV2 = cotThetaV * cotThetaV;\n\tfloat sharpness2 = min(0.999, sqr(sharpness));\n\tfloat sharpness4 = sharpness2 * sharpness2;\n\tfloat a = 8.0 * (sharpness4 + sharpness2 + 1.0);\n\tfloat b = sqrt(cotThetaV2 + sharpness2);\n\tfloat b3 = b * (cotThetaV2 + sharpness2);\n\treturn 2.0 * cotThetaV * a * b3\n\t\t/ (a * cotThetaV * (b3 + cotThetaV * cotThetaV2)\n\t\t   + 3.0 * sharpness2\n\t\t\t   * (4.0 * cotThetaV2 * (2.0 * sharpness4 + sharpness2 + 1.0)\n\t\t\t\t  + sharpness2 * (5.0 * sharpness4 + 2.0 * sharpness2 + 1.0)));\n}\n\nfloat getGGXMonodirectionalShadowing(vec3 dir, vec3 hw, vec3 normal, float sharpness, float gtrGamma) {\n\tfloat cosThetaV = dot(dir, normal);\n\n\tif (cosThetaV <= 1e-3)\n\t\treturn 0.0;\n\n\tif (dot(dir, hw) * cosThetaV <= 0.0) // Note: technically this is a division, but since we are only interested in\n\t\t\t\t\t\t\t\t\t\t // the sign, we can do multiplication\n\t\treturn 0.0;\n\n\t// when direction is collinear to the normal there is no shadowing\n\t// moreover if this case is not handled a division by zero will happen on the next line\n\tif (cosThetaV >= 1.0 - 1e-6)\n\t\treturn 1.0;\n\n\tfloat cotThetaV = cosThetaV / sqrt(1.0 - sqr(cosThetaV));\n\n\tfloat res = 0.0;\n\n\t// when gamma is any of the integer values 0, 1, 2, 3, 4 apply analytical solution\n\tif (gtrGamma <= 0.01)\n\t\tres = getGTRMonodirectionalShadowing0(cotThetaV);\n\telse if (abs(gtrGamma - 1.0) <= 1e-2)\n\t\tres = getGTRMonodirectionalShadowing1(sharpness, cotThetaV);\n\telse if (abs(gtrGamma - 2.0) <= 1e-2)\n\t\tres = getGTRMonodirectionalShadowing2(sharpness, cotThetaV);\n\telse if (abs(gtrGamma - 3.0) <= 1e-2)\n\t\tres = getGTRMonodirectionalShadowing3(sharpness, cotThetaV);\n\telse if (gtrGamma >= 4.0 - 1e-2)\n\t\tres = getGTRMonodirectionalShadowing4(sharpness, cotThetaV);\n\telse {\n\t\t// gamma is not an integer. interpolate\n\t\t// gtrGamma is not an integer. interpolate\n\t\t// If we get here gtrGamma is in (0.01, 3.99).\n\n\t\t// We use a cubic spline curve with 5 knots to evaluate the shadowing, based on the results for integer values.\n\t\t// The original code used a CubicSpline<5> object to construct and evaluate the spline, but Vladimir Nedev\n\t\t// derived a simplified version for Lavina, which is used below.\n\n\t\t// knots[i].x is implicit and is equal to 'i', so we store only knots[i].y in knots[i].\n\t\tfloat knots[5];\n\t\tknots[0]=getGTRMonodirectionalShadowing0(cotThetaV);\n\t\tknots[1]=getGTRMonodirectionalShadowing1(sharpness, cotThetaV);\n\t\tknots[2]=getGTRMonodirectionalShadowing2(sharpness, cotThetaV);\n\t\tknots[3]=getGTRMonodirectionalShadowing3(sharpness, cotThetaV);\n\t\tknots[4]=getGTRMonodirectionalShadowing4(sharpness, cotThetaV);\n\n\t\t// The code that follows is a simplified version of the code for CubicSpline<5> that constructs the spline,\n\t\t// using the fact that the distance between the spline knots in x is always 1.\n\t\t// We also directly compute which polynomial we are going to use instead of binary searching.\n\t\t// From CubicSpline::construct: h[i] = 1\n\t\t// From evalMomentsNatural: m[i] = 4\n\t\t// We compute f, instead of 'c', since 'f' is the argument name of solveTridiagonal.\n\t\t// From solveTridiagonal:\n\t\t// a[i] = h[i] = 1\n\t\t// b[i] = h[i+1] = 1\n\t\t// c[i] = m[i+1] = 4;\n\t\tfloat f[3];\n\t\tf[0]=knots[2]-knots[1]-knots[1]+knots[0];\n\t\tf[1]=knots[3]-knots[2]-knots[2]+knots[1];\n\t\tf[2]=knots[4]-knots[3]-knots[3]+knots[2];\n\n\t\tf[1]-=0.25*f[0];\n\t\tf[2]-=0.26666666666666666666666666666667*f[1];\n\n\t\t// Reuse 'f'.\n\t\tf[2]=f[2]*0.26785714285714285714285714285715;\n\t\tf[1]=(f[1]-f[2])*0.26666666666666666666666666666667;\n\t\tf[0]=(f[0]-f[1])*0.25;\n\n\t\tint i=int(floor(gtrGamma));\n\n\t\tfloat mi=(i>0 ? f[i-1] : 0.0);\n\t\tfloat mi1=(i<3 ? f[i] : 0.0);\n\t\tfloat a=(mi1-mi);\n\t\tfloat b=(3.0*mi);\n\t\tfloat c=(knots[i+1]-knots[i])-(2.0*mi+mi1);\n\t\tfloat d=knots[i];\n\n\t\tfloat x=gtrGamma-float(i);\n\t\tres=((a*x+b)*x+c)*x+d;\n\t}\n\n\treturn clamp(res, 0.0, 1.0);\n}\n\nfloat getGGXBidirectionalShadowingMasking(\n\tvec3 view, vec3 dir, vec3 hw, vec3 normal, float sharpness, float gtrGamma) {\n\treturn getGGXMonodirectionalShadowing(view, hw, normal, sharpness, gtrGamma)\n\t\t* getGGXMonodirectionalShadowing(dir, hw, normal, sharpness, gtrGamma);\n}\n\nfloat getGGXContribution(\n\tvec3 view,\n\tvec3 dir,\n\tvec3 hw,\n\tvec3 hl,\n\tfloat sharpness,\n\tfloat gtrGamma,\n\tvec3 normal,\n\tout float partialProb,\n\tout float D) {\n\tfloat cosIN = abs(dot(view, normal));\n\tfloat cosON = abs(dot(dir, normal));\n\n\tif (cosIN <= 1e-6 || cosON <= 1e-6)\n\t\treturn 0.0;\n\n\tfloat partialBrdf = 0.0;\n\n\tfloat hn = hl.z;\n\tD = getGGXMicrofacetDistribution(hn, sharpness, gtrGamma);\n\t// division by cosON is omitted because we would have to multiply by the same below\n\tpartialBrdf =\n\t\t0.25 * getGGXBidirectionalShadowingMasking(view, dir, hw, normal, sharpness, gtrGamma) / cosIN;\n\n\tif (hn > 0.0) {\n\t\tpartialProb = hn;\n\n\t\tfloat ho = dot(hw, dir);\n\t\tpartialProb *= ho > 0.0 ? 0.25 / ho : 0.0;\n\t}\n\n\t// reduce some multiplications in the final version\n\t// partialBrdf *= cosON; - omitted\n\n\treturn partialBrdf;\n}\n\nvec3 getGGXDir(\n\tfloat u, float v, float sharpness, float gtrGamma, vec3 view, mat3 nm, out float prob, out float brdfDivByProb) {\n\tvec3 microNormalLocal = getGGXMicroNormal(u, v, sharpness, gtrGamma);\n\tif (microNormalLocal.z < 0.0)\n\t\treturn nm[2];\n\n\tvec3 microNormal = nm * microNormalLocal;\n\n\t// Compute and keep the length of the half-vector in local space; needed for anisotropy correction\n\tfloat L2 = dot(microNormal, microNormal);\n\tfloat L = sqrt(L2);\n\tmicroNormal /= L;\n\n\tvec3 dir = reflect(-view, microNormal);\n\n\tfloat Dval = 0.0;\n\tfloat partialProb = 0.0;\n\tfloat partialBrdf =\n\t\tgetGGXContribution(view, dir, microNormal, microNormalLocal, sharpness, gtrGamma, nm[2], partialProb, Dval);\n\tpartialProb *= L * L2; // take anisotropy in consideration\n\tprob = (Dval >= 1e-6) ? partialProb * Dval * 2.0 * PI\n\t\t\t\t\t\t  : 1e18; // compute full probability and apply vray specific corrections\n\tbrdfDivByProb = (partialProb >= 1e-6) ? partialBrdf / partialProb : 0.0;\n\treturn dir;\n}\n\nvec3 sampleBRDF(\n\tVRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out float rayProb, out float brdfContrib) {\n\tvec3 geomNormal = params.geomNormal;\n\tfloat ggxTail = params.gtrGamma;\n\tint brdfType = params.brdfType;\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tfloat u = uv.x, v = uv.y;\n\n\tvec3 dir = vec3(0.0);\n\trayProb = 1.0;\n\tbrdfContrib = 1.0;\n\tif (brdfType == 0) {\n\t\tdir = getPhongDir(u, v, ctx.gloss1, -ctx.e, ctx.nm);\n\t} else if (brdfType == 1) {\n\t\tdir = getBlinnDir(u, v, ctx.gloss1, -ctx.e, ctx.nm);\n\t} else if (brdfType == 2) {\n\t\tdir = getWardDir(u, v, ctx.roughnessSqr, -ctx.e, ctx.nm);\n\t} else /* brdfType==3 */ {\n\t\tdir = getGGXDir(u, v, ctx.roughnessSqr, ctx.gtrGamma, -ctx.e, ctx.nm, rayProb, brdfContrib);\n\t}\n\n\tif (dot(dir, geomNormal) < 0.0) {\n\t\tbrdfContrib = 0.0;\n\t}\n\treturn dir;\n}\n\nvec3 sampleCoatBRDF(\n\tVRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out float rayProb, out float brdfContrib) {\n\tvec3 geomNormal = params.geomNormal;\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tfloat u = uv.x, v = uv.y;\n\n\tvec3 dir = vec3(0.0);\n\trayProb = 1.0;\n\tbrdfContrib = 1.0;\n\tdir = getGGXDir(u, v, ctx.coatRoughnessSqr, 2.0, -ctx.e, ctx.coatNM, rayProb, brdfContrib);\n\n\tif (dot(dir, geomNormal) < 0.0) {\n\t\tbrdfContrib = 0.0;\n\t}\n\treturn dir;\n}\n\nvec3 sampleRefractBRDF(\n\tVRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out bool totalInternalReflection) {\n\tvec3 geomNormal = params.geomNormal;\n\tvec3 refractDir = refract(ctx.e, geomNormal, 1.0 / params.refractionIOR);\n\ttotalInternalReflection = false;\n\tif (refractDir == vec3(0.0)) {\n\t\trefractDir = reflect(ctx.e, geomNormal);\n\t\ttotalInternalReflection = true;\n\t}\n\n\tvec3 s = cross(vec3(0, 1, 0), refractDir);\n\tvec3 s1 = cross(refractDir, s);\n\tmat3 m;\n\tm[0] = normalize(s);\n\tm[1] = normalize(s1);\n\tm[2] = normalize(refractDir);\n\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tfloat u = uv.x, v = uv.y;\n\tfloat gloss = 1.0 / pow(max(1.0 - params.refrGloss, 1e-4), 3.5) - 1.0;\n\tvec3 sampleDir = getSpecularDir(u, v, gloss);\n\n\treturn m * sampleDir;\n}\n\n/// Sheen BRDF functions based on the Production Friendly Microfacet Sheen BRDF paper\n/// Implementation of the curve fitting polynomial (Table 1 and Section 3)\nfloat sheenP(float a, float b, float c, float d, float e, float x) {\n\treturn a / (1.0 + b * pow(x, c)) + d * x + e;\n}\n\n/// Implementation of the lambda curve fitting and interpolation (Table 1 and Section 3)\nfloat sheenL(float x, float roughness) {\n\tfloat a0 = 25.3245;\n\tfloat b0 = 3.32435;\n\tfloat c0 = 0.16801;\n\tfloat d0 = -1.27393;\n\tfloat e0 = -4.85967;\n\tfloat a1 = 21.5473;\n\tfloat b1 = 3.82987;\n\tfloat c1 = 0.19823;\n\tfloat d1 = -1.97760;\n\tfloat e1 = -4.32054;\n\n\tfloat t = (1.0 - roughness) * (1.0 - roughness);\n\tfloat p0 = sheenP(a0, b0, c0, d0, e0, x);\n\tfloat p1 = sheenP(a1, b1, c1, d1, e1, x);\n\treturn t * p0 + (1.0 - t) * p1;\n}\n\n/// Implementation of the lambda term (Section 3)\nfloat sheenLambda(float cosTheta, float roughness) {\n\tif (cosTheta < 0.5) {\n\t\treturn exp(sheenL(cosTheta, roughness));\n\t} else {\n\t\treturn exp(2.0 * sheenL(0.5, roughness) - sheenL(1.0 - cosTheta, roughness));\n\t}\n}\n\n/// Implementation of the full shadowing term (Section 3 and Section 4)\nfloat sheenShadowingMasking(float cosIN, float cosON, float roughness) {\n\tfloat c1 = 1.0 - cosON;\n\tfloat c2 = c1 * c1;\n\tfloat c4 = c2 * c2;\n\tfloat c8 = c4 * c4;\n\tfloat lambdaON = pow(sheenLambda(cosON, roughness), 1.0 + 2.0 * c8);\n\tfloat lambdaIN = sheenLambda(cosIN, roughness);\n\treturn 1.0 / (1.0 + lambdaIN + lambdaON);\n}\n\n/// Implementation of the full sheen BRDF including the cos(N,L) multiplication and \n/// VRay's probability transformation (2pi multiplication)\n/// Glossiness must be in the [0, 1) range. In theory the result is undefined for glossiness = 1\n/// but in practice the highlight disappears and we check for that as soon as we read the glossiness texture.\nfloat sheenProbability(vec3 viewDir, vec3 lightDir, vec3 normal, float glossiness) {\n\tvec3 incomingDir = -viewDir;\n\n\tfloat cosIN = min(1.0, dot(incomingDir, normal));\n\tfloat cosON = min(1.0, dot(lightDir, normal));\n\tif (cosIN <= 1e-6 || cosON <= 1e-6)\n\t\treturn 0.0;\n\n\tfloat roughness = 1.0 - glossiness;\n\tvec3 halfVector = normalize(lightDir - viewDir);\n\n\tfloat cosTheta = clamp(dot(halfVector, normal), 0.0, 1.0);\n\t// This should be fine because we expect theta in [0, pi/2] range and both \n\t// sin(theta) and cos(theta) are non-negative in this case\n\tfloat sinThetaSq = clamp(1.0 - cosTheta * cosTheta, 0.0, 1.0);\n\t// Compute the microfacet distribution (Section 2)\n\t// The 2pi divide is cancelled by VRay's probability transformation\n\tfloat invRoughness = 1.0 / roughness;\n\tfloat D = (2.0 + invRoughness) * pow(sinThetaSq, 0.5 * invRoughness);\n\tfloat G = sheenShadowingMasking(cosIN, cosON, roughness);\n\t// cosON divide will be cancelled by cosON multiplication later so just skip both.\n\tfloat res = 0.25 * D * G / cosIN;\n\treturn res;\n}\n\n/// Size of the sheen albedo LUT\n#define SHEEN_LUT_SIZE 16\n\n/// Directional sheen albedo LUT where the row index corresponds to roughness and the column index corresponds to cosTheta\n/// Conductor Fresnel for wavelength 650nm with n=2.9114 and k=3.0893 (Iron) is used instead of the usual dielectric Fresnel.\n/// Conductor Fresnel inputs taken from https://refractiveindex.info/\n/// It's computed according to Section 2.1.5. in the paper\n/// \"A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling\"\nfloat sheenAlbedoLUT[SHEEN_LUT_SIZE * SHEEN_LUT_SIZE] = float[] (\n\t0.64503, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000, 0.00000,\n\t0.44977, 0.26630, 0.18104, 0.12713, 0.08979, 0.06302, 0.04360, 0.02954, 0.01947, 0.01245, 0.00762, 0.00438, 0.00229, 0.00103, 0.00035, 0.00005,\n\t0.38310, 0.26927, 0.20305, 0.15812, 0.12440, 0.09790, 0.07660, 0.05932, 0.04531, 0.03419, 0.02527, 0.01810, 0.01234, 0.00780, 0.00429, 0.00170,\n\t0.36921, 0.27749, 0.21857, 0.17769, 0.14612, 0.12046, 0.09902, 0.08085, 0.06543, 0.05263, 0.04182, 0.03255, 0.02453, 0.01759, 0.01161, 0.00650,\n\t0.37188, 0.28926, 0.23348, 0.19442, 0.16387, 0.13861, 0.11709, 0.09843, 0.08221, 0.06847, 0.05657, 0.04605, 0.03662, 0.02811, 0.02040, 0.01344,\n\t0.38180, 0.30284, 0.24825, 0.20989, 0.17968, 0.15446, 0.13273, 0.11365, 0.09683, 0.08242, 0.06979, 0.05843, 0.04806, 0.03849, 0.02961, 0.02137,\n\t0.39514, 0.31710, 0.26267, 0.22437, 0.19410, 0.16870, 0.14666, 0.12715, 0.10981, 0.09488, 0.08168, 0.06971, 0.05867, 0.04836, 0.03868, 0.02957,\n\t0.40983, 0.33122, 0.27639, 0.23780, 0.20725, 0.18153, 0.15912, 0.13919, 0.12140, 0.10601, 0.09236, 0.07993, 0.06839, 0.05755, 0.04731, 0.03762,\n\t0.42452, 0.34459, 0.28906, 0.25001, 0.21907, 0.19299, 0.17020, 0.14987, 0.13168, 0.11592, 0.10191, 0.08911, 0.07719, 0.06598, 0.05535, 0.04527,\n\t0.43822, 0.35667, 0.30038, 0.26082, 0.22948, 0.20304, 0.17990, 0.15923, 0.14070, 0.12464, 0.11035, 0.09727, 0.08509, 0.07361, 0.06272, 0.05239,\n\t0.45014, 0.36703, 0.31005, 0.27004, 0.23836, 0.21161, 0.18820, 0.16726, 0.14848, 0.13220, 0.11771, 0.10444, 0.09208, 0.08043, 0.06937, 0.05890,\n\t0.45964, 0.37532, 0.31783, 0.27751, 0.24559, 0.21866, 0.19507, 0.17397, 0.15503, 0.13861, 0.12400, 0.11064, 0.09818, 0.08643, 0.07530, 0.06476,\n\t0.46621, 0.38123, 0.32352, 0.28309, 0.25111, 0.22412, 0.20048, 0.17933, 0.16034, 0.14389, 0.12926, 0.11587, 0.10340, 0.09164, 0.08050, 0.06997,\n\t0.46947, 0.38454, 0.32698, 0.28669, 0.25484, 0.22796, 0.20442, 0.18335, 0.16443, 0.14805, 0.13348, 0.12016, 0.10775, 0.09606, 0.08499, 0.07452,\n\t0.46915, 0.38511, 0.32810, 0.28824, 0.25674, 0.23016, 0.20687, 0.18602, 0.16730, 0.15109, 0.13670, 0.12353, 0.11127, 0.09971, 0.08876, 0.07842,\n\t0.46510, 0.38285, 0.32683, 0.28769, 0.25679, 0.23070, 0.20784, 0.18736, 0.16896, 0.15304, 0.13891, 0.12599, 0.11395, 0.10260, 0.09184, 0.08168\n);\n\n/// Average sheen albedo LUT used to normalize the diffuse scaling factor.\n/// Each element corresponds to a roughness value.\n/// Check Section 2.2. in the paper \"A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling\"\n/// The LUT stores 1 - average albedo as a small optimization for the renderer\nfloat sheenAlbedoAvg[SHEEN_LUT_SIZE] = float[] (\n\t1.00000,\n\t0.97841,\n\t0.96276,\n\t0.94874,\n\t0.93569,\n\t0.92349,\n\t0.91217,\n\t0.90178,\n\t0.89235,\n\t0.88392,\n\t0.87652,\n\t0.87017,\n\t0.86488,\n\t0.86065,\n\t0.85749,\n\t0.85538\n);\n\n/// Sample the sheen albedo LUT for a given incident angle and glossiness\n/// @param cosTheta Cosine of the angle between the incident direction and the surface normal\n/// @param glossiness Sheen glossiness\n/// @return Directional sheen albedo for the given incident angle and glossiness.\nfloat sheenDirectionalAlbedo(float cosTheta, float glossiness) {\n\tfloat roughness = (1.0 - glossiness);\n\tfloat x = cosTheta * float(SHEEN_LUT_SIZE - 1);\n\tfloat y = roughness * float(SHEEN_LUT_SIZE - 1);\n\tint ix = int(x);\n\tint iy = int(y);\n\tint ix2 = clamp(ix + 1, 0, SHEEN_LUT_SIZE - 1);\n\tint iy2 = clamp(iy + 1, 0, SHEEN_LUT_SIZE - 1);\n\tfloat fx = x - float(ix);\n\tfloat fy = y - float(iy);\n\n\tfloat v1 = (1.0 - fx) * sheenAlbedoLUT[iy  * SHEEN_LUT_SIZE + ix] + fx * sheenAlbedoLUT[iy  * SHEEN_LUT_SIZE + ix2];\n\tfloat v2 = (1.0 - fx) * sheenAlbedoLUT[iy2 * SHEEN_LUT_SIZE + ix] + fx * sheenAlbedoLUT[iy2 * SHEEN_LUT_SIZE + ix2];\n\tfloat albedo = (1.0 - fy) * v1 + fy * v2;\n\n\treturn clamp(albedo, 0.0, 1.0);\n}\n\n/// Sample the average sheen albedo from the LUT for a given glossiness value\n/// @param glossiness Sheen glossiness\n/// @return Average sheen albedo for the given glossiness\nfloat getSheenAlbedoAverage(float glossiness) {\n\tfloat roughness = 1.0 - glossiness;\n\tfloat y = roughness * float(SHEEN_LUT_SIZE - 1);\n\tint iy0 = int(y);\n\tint iy1 = clamp(iy0 + 1, 0, SHEEN_LUT_SIZE - 1);\n\tfloat fy = y - float(iy0);\n\tfloat avg0 = sheenAlbedoAvg[iy0];\n\tfloat avg1 = sheenAlbedoAvg[iy1];\n\tfloat albedoAvg = (1.0 - fy) * avg0 + fy * avg1;\n\treturn albedoAvg;\n}\n\n/// Get the partial sheen albedo scaling factor (without the view direction albedo).\n/// Used to dim the diffuse according to section 2.2. in the paper\n/// \"A Microfacet Based Coupled Specular-Matte BRDF Model with Importance Sampling\"\n/// The light direction albedo needs to be computed per light direction but\n/// the view direction albedo can be computed earlier and used to split the samples \n/// between the diffuse and the sheen layer.\n/// @param sheenColor Sheen color\n/// @param cosTheta Cosine of the angle between the light direction and the normal\n/// @param glossiness Sheen glossiness\n/// @return Partial albedo scaling factor\nvec3 getSheenAlbedoLightDim(vec3 sheenColor, float cosTheta, float glossiness) {\n\tfloat albedoLight = sheenDirectionalAlbedo(max(0.0, cosTheta), glossiness);\n\tfloat avgAlbedo = getSheenAlbedoAverage(glossiness); // This is 1 - average albedo\n\t// No need to check the divisor because it's always large enough for this BRDF\n\treturn (1.0 - sheenColor * albedoLight) / avgAlbedo;\n}\n\nvec3 sampleSheenBRDF(VRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out float rayProb, out float brdfContrib) {\n\t// Sample the hemisphere uniformly\n\tmat3 localToWorld;\n\tmakeNormalMatrix(ctx.geomNormal, localToWorld);\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tvec3 dir = localToWorld * getSphereDir(uv.x, uv.y);\n\trayProb = INV_2PI;\n\tfloat glossyFresnelCoeff = getConductorFresnel(-dot(ctx.e, normalize(dir - ctx.e)), SHEEN_N, SHEEN_K);\n\tbrdfContrib = sheenProbability(ctx.e, dir, ctx.geomNormal, ctx.sheenGloss);\n\tbrdfContrib *= glossyFresnelCoeff;\n\treturn dir;\n}\n\nvec3 sampleDiffuseBRDF(VRayMtlInitParams params, VRayMtlContext ctx, int sampleIdx, int nbSamples, out float rayProb, out float brdfContrib) {\n\t// Sample the hemisphere with cosine distribution\n\tmat3 localToWorld;\n\tmakeNormalMatrix(ctx.geomNormal, localToWorld);\n\tvec2 uv = rand(ctx, sampleIdx, nbSamples);\n\tvec3 dir = localToWorld * getDiffuseDir(uv.x, uv.y);\n\trayProb = INV_2PI;\n\tbrdfContrib = 1.0;\n\treturn dir;\n}\n\nfloat pow35(float x) {\n\treturn x * x * x * sqrt(x);\n}\n\n/// Blend between a metal color and reflection color based on a dielectric Fresnel value\n/// This approximates the tinted reflection visible in some conductors\n/// @param metalColor Metallic color, currently derived from the diffuse (base) color and the metalness value.\n/// @param reflectionColor The color of the specular highlight\n/// @param fresnel Dielectric fresnel coefficient\n/// @return Blended reflection color.\nvec3 computeMetallicReflection(vec3 metalColor, vec3 reflectionColor, float fresnel) {\n\tvec3 reflectionDim = reflectionColor * fresnel;\n\treturn metalColor * (1.0 - reflectionDim) + reflectionDim;\n}\n\nVRayMtlContext initVRayMtlContext(VRayMtlInitParams initParams) {\n\tfloat reflGloss = initParams.reflGloss;\n\tvec3 Vw = initParams.Vw;\n\tvec3 geomNormal = initParams.geomNormal;\n\tvec3 selfIllum = initParams.selfIllum;\n\tvec3 diffuseColor = initParams.diffuseColor;\n\tfloat diffuseAmount = initParams.diffuseAmount;\n\tvec3 reflColor = initParams.reflColor;\n\tfloat reflAmount = initParams.reflAmount;\n\tbool traceReflections = initParams.traceReflections;\n\tfloat metalness = initParams.metalness;\n\tfloat aniso = initParams.aniso;\n\tfloat anisoRotation = initParams.anisoRotation;\n\tint anisoAxis = initParams.anisoAxis;\n\tvec3 opacity = initParams.opacity;\n\tfloat roughness = initParams.roughness;\n\tvec3 refractionColor = initParams.refractionColor;\n\tfloat refractionAmount = initParams.refractionAmount;\n\tbool traceRefractions = initParams.traceRefractions;\n\tfloat refractionIOR = initParams.refractionIOR;\n\tbool useFresnel = initParams.useFresnel;\n\tfloat fresnelIOR = initParams.fresnelIOR;\n\tbool lockFresnelIOR = initParams.lockFresnelIOR;\n\tbool doubleSided = initParams.doubleSided;\n\tbool useRoughness = initParams.useRoughness;\n\tfloat gtrGamma = initParams.gtrGamma;\n\tint brdfType = initParams.brdfType;\n\tfloat sheenGloss = initParams.sheenGlossiness;\n\tfloat coatGloss = initParams.coatGlossiness;\n\n\tVRayMtlContext result;\n\tif (initParams.lockFresnelIOR)\n\t\tinitParams.fresnelIOR = initParams.refractionIOR;\n\n\tresult.e = -normalize(Vw);\n\t // Invert glossiness (turn it into roughness)\n\tif (useRoughness) {\n\t\treflGloss = 1.0 - reflGloss;\n\t\tcoatGloss = 1.0 - coatGloss;\n\t\tsheenGloss = 1.0 - sheenGloss;\n\t}\n\n\tresult.reflGloss = reflGloss;\n\tresult.opacity = opacity;\n\tresult.diff = diffuseColor * diffuseAmount * result.opacity;\n\tresult.illum = selfIllum * result.opacity;\n\t// roughness\n\tfloat sqrRough = roughness * roughness;\n\tresult.rtermA = 1.0 - 0.5 * (sqrRough / (sqrRough + 0.33));\n\tresult.rtermB = 0.45 * (sqrRough / (sqrRough + 0.09));\n\n\tif (doubleSided && dot(geomNormal, result.e) > 0.0)\n\t\tgeomNormal = -geomNormal;\n\n\tvec3 reflectDir = reflect(result.e, geomNormal);\n\tresult.geomNormal = geomNormal;\n\n\t// check for internal reflection\n\tbool internalReflection;\n\tvec3 refractDir;\n\tbool outToIn = (dot(geomNormal, result.e) < 0.0);\n\tfloat ior = (outToIn ? 1.0 / refractionIOR : refractionIOR);\n\tvec3 normal = (outToIn ? geomNormal : -geomNormal);\n\n\tfloat cost = -dot(result.e, normal);\n\tfloat sintSqr = 1.0 - ior * ior * (1.0 - cost * cost);\n\tif (sintSqr > 1e-6) {\n\t\tinternalReflection = false;\n\t\trefractDir = ior * result.e + (ior * cost - sqrt(sintSqr)) * normal;\n\t} else {\n\t\tinternalReflection = true;\n\t\trefractDir = reflectDir;\n\t}\n\tfloat fresnel = 1.0;\n\tif (useFresnel && !internalReflection)\n\t\tfresnel = clamp(getFresnelCoeff(fresnelIOR, result.e, normal, refractDir), 0.0, 1.0);\n\n\tvec3 reflNoFresnel = reflColor * reflAmount * result.opacity;\n\tresult.refl = reflNoFresnel * fresnel;\n\n\t// Reflection calculation including metalness. Taken from VRayMtl's original implementation.\n\tvec3 metalColor = result.diff * metalness;\n\n\tvec3 dielectricReflectionTransparency = traceReflections ? (1.0 - result.refl) : vec3(1.0);\n\tvec3 reflectionTransparency = (1.0 - metalness) * dielectricReflectionTransparency;\n\tif (traceRefractions) {\n\t\tresult.refr = refractionColor * refractionAmount * result.opacity * reflectionTransparency;\n\t} else {\n\t\tresult.refr = vec3(0.0);\n\t}\n\tresult.diff *= reflectionTransparency - result.refr;\n\n\tresult.refl = computeMetallicReflection(metalColor, reflNoFresnel, fresnel);\n\n\tvec3 sheenColor = initParams.sheenColor * initParams.sheenAmount;\n\tresult.hasSheen = ((sheenColor.x + sheenColor.y + sheenColor.z) > 1e-6) && (1.0 - sheenGloss > 1e-5);\n\tif (result.hasSheen) {\n\t\tfloat albedoView = sheenDirectionalAlbedo(max(0.0, dot(-result.e, geomNormal)), sheenGloss);\n\t\tvec3 sheenViewDim = 1.0 - initParams.sheenColor * albedoView;\n\t\tresult.diff *= sheenViewDim;\n\t\tresult.sheen = initParams.sheenColor * (reflectionTransparency - result.refr);\n\t}\n\n\tresult.hasCoat = (initParams.coatAmount > 1e-6);\n\tif (result.hasCoat && !internalReflection) {\n\t\tfloat coatFresnel = clamp(getFresnelCoeff(initParams.coatIOR, result.e, normal, refractDir), 0.0, 1.0);\n\t\tfloat coatAmount = initParams.coatAmount;\n\t\tvec3 coatColor = initParams.coatColor * (1.0 - coatFresnel);\n\t\tvec3 coatDim = traceReflections ? ((1.0 - coatAmount) + coatAmount * coatColor) : vec3(1.0);\n\t\t// Dim all layers below the coat\n\t\tresult.refl *= coatDim;\n\t\tresult.refr *= coatDim;\n\t\tresult.sheen *= coatDim;\n\t\tresult.diff *= coatDim;\n\t\tmakeNormalMatrix(geomNormal, result.coatNM);\n\t\tresult.coat = vec3(1.0) * initParams.coatAmount * coatFresnel;\n\t}\n\n\tresult.gloss1 = max(0.0, 1.0 / pow35(max(1.0 - reflGloss, 1e-4)) - 1.0); // [0, 1] -> [0, inf)\n\tresult.roughnessSqr = max(1.0 - reflGloss, 1e-4);\n\tresult.roughnessSqr *= result.roughnessSqr;\n\tresult.coatRoughnessSqr = max(1.0 - coatGloss, 1e-4);\n\tresult.coatRoughnessSqr *= result.coatRoughnessSqr;\n\tresult.sheenGloss = sheenGloss;\n\tresult.gtrGamma = gtrGamma;\n\n\t// Set up the normal/inverse normal matrices for BRDFs that support anisotropy\n\tvec3 anisoDirection = vec3(0.0, 0.0, 1.0);\n\tif (anisoAxis == 0)\n\t\tanisoDirection = vec3(1.0, 0.0, 0.0);\n\telse if (anisoAxis == 1)\n\t\tanisoDirection = vec3(0.0, 1.0, 0.0);\n\tfloat anisoAbs = abs(aniso);\n\tif (anisoAbs < 1e-12 || anisoAbs >= 1.0 - 1e-6) {\n\t\tmakeNormalMatrix(geomNormal, result.nm);\n\t\tresult.inm = transpose(result.nm); // inverse = transpose for orthogonal matrix\n\t} else if (!internalReflection) {\n\t\tvec3 base0, base1;\n\t\tbase0 = normalize(cross(geomNormal, anisoDirection));\n\t\tbase1 = normalize(cross(base0, geomNormal));\n\t\tfloat anisor = anisoRotation * 6.2831853;\n\t\tif (abs(anisor) > 1e-6) {\n\t\t\tfloat cs = cos(anisor);\n\t\t\tfloat sn = sin(anisor);\n\t\t\tvec3 nu = base0 * cs - base1 * sn;\n\t\t\tvec3 nv = base0 * sn + base1 * cs;\n\t\t\tbase0 = nu;\n\t\t\tbase1 = nv;\n\t\t}\n\n\t\tif (length(cross(base0, base1)) < 1e-6)\n\t\t\tcomputeTangentVectors(geomNormal, base0, base1);\n\t\tif (aniso > 0.0) {\n\t\t\tfloat a = 1.0 / (1.0 - aniso);\n\t\t\tbase0 *= a;\n\t\t\tbase1 /= a;\n\t\t} else {\n\t\t\tfloat a = 1.0 / (1.0 + aniso);\n\t\t\tbase0 /= a;\n\t\t\tbase1 *= a;\n\t\t}\n\t\tresult.nm[0] = base0;\n\t\tresult.nm[1] = base1;\n\t\tresult.nm[2] = geomNormal;\n\t\tresult.inm = inverse(result.nm);\n\t}\n\n\treturn result;\n}\n\n/// Lambertian BRDF contribution\nvec3 vrayMtlDiffuse(vec3 lightDir, vec3 normal) {\n\treturn vec3(max(0.0, dot(lightDir, normal)));\n}\n\n/// Oren-Nayar BRDF contribution\nvec3 vrayMtlDiffuseRoughness(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat lightNdotL = max(0.0, dot(lightDir, ctx.geomNormal));\n\tfloat rmult = 1.0;\n\tvec3 vecV = -ctx.e;\n\tfloat NV = clamp(dot(ctx.geomNormal, vecV), 0.0, 1.0);\n\tfloat theta_i = acos(lightNdotL);\n\tfloat theta_r = acos(NV);\n\tfloat alpha = max(theta_i, theta_r);\n\tif (alpha > 1.571) { // 1.571==pi/2\n\t\trmult = 0.0;\n\t} else {\n\t\tfloat beta = min(theta_i, theta_r);\n\t\tvec3 vecVtan = vecV - ctx.geomNormal * NV;\n\t\tvec3 vecLtan = lightDir - ctx.geomNormal * lightNdotL;\n\t\tfloat fMult = length(vecVtan) * length(vecLtan);\n\t\tfloat cosDeltaPhi = fMult < 0.000001 ? 1.0 : dot(vecVtan, vecLtan) / fMult;\n\t\trmult = (ctx.rtermA + ctx.rtermB * sin(alpha) * tan(beta) * max(0.0, cosDeltaPhi));\n\t}\n\treturn vec3(lightNdotL * rmult);\n}\n\n/// Blinn BRDF contribution\nvec3 vrayMtlBlinn(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat k = max(0.0, ctx.gloss1);\n\tvec3 hw = lightDir - ctx.e;\n\tvec3 hn = normalize(ctx.inm * hw);\n\tfloat cs1 = hn.z;\n\tif (cs1 > 1e-6) {\n\t\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\t\tif (cs1 > 1.0)\n\t\t\tcs1 = 1.0;\n\t\tfloat cs = -dot(normalize(hw), ctx.e);\n\t\tk = cs < 1e-6 ? 0.0 : pow(cs1, k) * (k + 1.0) * 0.125 / cs;\n\t\tk *= lightNdotL;\n\t\tif (k > 0.0)\n\t\t\treturn vec3(k);\n\t}\n\treturn vec3(0.0);\n}\n\n/// Phong BRDF contribution\nvec3 vrayMtlPhong(vec3 lightDir, VRayMtlContext ctx) {\n\tvec3 reflectDir = reflect(ctx.e, ctx.geomNormal);\n\tfloat cs1 = dot(lightDir, reflectDir);\n\tif (cs1 > 0.0) {\n\t\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\t\tif (cs1 > 1.0)\n\t\t\tcs1 = 1.0;\n\t\tfloat k = pow(cs1, ctx.gloss1) * (ctx.gloss1 + 1.0) * 0.5; // phong k\n\t\tk *= lightNdotL;\n\t\tif (k > 0.0)\n\t\t\treturn vec3(k);\n\t}\n\treturn vec3(0.0);\n}\n\n/// Ward BRDF contribution\nvec3 vrayMtlWard(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat cs1 = -dot(ctx.e, ctx.geomNormal);\n\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\tif (lightNdotL > 1e-6 && cs1 > 1e-6) {\n\t\tvec3 hw = lightDir - ctx.e;\n\t\tvec3 hn = normalize(ctx.inm * hw);\n\t\tif (hn.z > 1e-3) {\n\t\t\tfloat tanhSqr = (1.0 / (hn.z * hn.z) - 1.0);\n\t\t\tfloat divd = cs1 * ctx.roughnessSqr;\n\t\t\tfloat k = exp(-tanhSqr / ctx.roughnessSqr) / divd;\n\t\t\tk *= lightNdotL;\n\t\t\tif (k > 0.0)\n\t\t\t\treturn vec3(k);\n\t\t}\n\t}\n\treturn vec3(0.0);\n}\n\n/// GTR BRDF contribution\nvec3 vrayMtlGGX(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat cs1 = -dot(ctx.e, ctx.geomNormal);\n\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\tif (lightNdotL > 1e-6 && cs1 > 1e-6) {\n\t\tvec3 hw = normalize(lightDir - ctx.e);\n\t\tvec3 hn = normalize(ctx.inm * hw);\n\t\tif (hn.z > 1e-3) {\n\t\t\tfloat D = getGGXMicrofacetDistribution(hn.z, ctx.roughnessSqr, ctx.gtrGamma);\n\t\t\tfloat G =\n\t\t\t\tgetGGXBidirectionalShadowingMasking(-ctx.e, lightDir, hw, ctx.geomNormal, ctx.roughnessSqr, ctx.gtrGamma);\n\t\t\tvec3 micron = ctx.nm * hn;\n\t\t\tfloat L2 = dot(micron, micron);\n\t\t\tfloat anisotropyCorrection = L2 * sqrt(L2);\n\t\t\tfloat k = 0.25 * D * G * anisotropyCorrection * PI / cs1; // anisotropy correction\n\t\t\tif (k > 0.0)\n\t\t\t\treturn vec3(k);\n\t\t}\n\t}\n\treturn vec3(0.0);\n}\n\n/// GGX BRDF contribution that uses the coat layer parameters\nvec3 vrayMtlGGXCoat(vec3 lightDir, VRayMtlContext ctx) {\n\tfloat cs1 = -dot(ctx.e, ctx.geomNormal);\n\tfloat lightNdotL = dot(ctx.geomNormal, lightDir);\n\tif (lightNdotL > 1e-6 && cs1 > 1e-6) {\n\t\tvec3 hw = normalize(lightDir - ctx.e);\n\t\tvec3 hn = normalize(ctx.inm * hw);\n\t\tif (hn.z > 1e-3) {\n\t\t\tfloat D = getGGXMicrofacetDistribution(hn.z, ctx.coatRoughnessSqr, 2.0);\n\t\t\tfloat G = getGGXBidirectionalShadowingMasking(-ctx.e, lightDir, hw, ctx.geomNormal, ctx.coatRoughnessSqr, 2.0);\n\t\t\tvec3 micron = ctx.coatNM * hn;\n\t\t\tfloat k = 0.25 * D * G * PI / cs1;\n\t\t\tif (k > 0.0)\n\t\t\t\treturn vec3(k);\n\t\t}\n\t}\n\treturn vec3(0.0);\n}\n\nvec3 computeRefractFogContrib(VRayMtlInitParams params, VRayMtlContext ctx, vec3 diffuseContrib) {\n\tif (intensity(ctx.diff) < 0.001)\n\t\treturn vec3(0.0);\n\n\tvec3 fogColor = params.fogColor;\n\tfloat fogMult = max(1e-6, params.fogMult);\n\tfloat fogBias = params.fogBias;\n\tif (fogBias > 0.0) {\n\t\tfogBias = 1.0 / (1.0 + fogBias);\n\t} else {\n\t\tfogBias = 1.0 - fogBias;\n\t}\n\n\tfloat fogDist = params.distToCamera * 0.001;\n\tfogDist = pow(fogDist, fogBias);\n\tfogColor = pow(fogColor, vec3(fogMult * fogDist));\n\treturn fogColor * ctx.diff * diffuseContrib;\n}\n\nvec3 computeDirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n\tvec3 res = vec3(0.0);\n\tif (params.roughness < 1e-6) {\n\t\tres = vrayMtlDiffuse(lightDir, ctx.geomNormal);\n\t} else {\n\t\tres = vrayMtlDiffuseRoughness(lightDir, ctx);\n\t}\n\n\tif (ctx.hasSheen) {\n\t\tvec3 sheenLightDim = getSheenAlbedoLightDim(params.sheenColor, dot(lightDir, ctx.geomNormal), ctx.sheenGloss);\n\t\tres *= sheenLightDim;\n\t}\n\n\treturn res;\n}\n\nvec3 computeDirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n\tvec3 res = vec3(0.0);\n\n\tif (params.brdfType == 0) {\n\t\tres = vrayMtlPhong(lightDir, ctx);\n\t} else if (params.brdfType == 1) {\n\t\tres = vrayMtlBlinn(lightDir, ctx);\n\t} else if (params.brdfType == 2) {\n\t\tres = vrayMtlWard(lightDir, ctx);\n\t} else /* if (params.brdfType==3) */ {\n\t\tres = vrayMtlGGX(lightDir, ctx);\n\t}\n\treturn res;\n}\n\n// Sheen BRDF contribution based on the \"Production Friendly Microfacet Sheen BRDF\" paper\nvec3 computeDirectSheenContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n\tvec3 res = vec3(0.0);\n\n\t// Use fixed IOR for sheen\n\tfloat glossyFresnelCoeff = getConductorFresnel(-dot(ctx.e, normalize(lightDir - ctx.e)), SHEEN_N, SHEEN_K);\n\tfloat k = sheenProbability(ctx.e, lightDir, ctx.geomNormal, ctx.sheenGloss);\n\tres = vec3(k) * glossyFresnelCoeff * 0.5;\n\n\treturn res;\n}\n\nvec3 computeDirectCoatContribution(VRayMtlInitParams params, VRayMtlContext ctx, vec3 lightDir) {\n\treturn vrayMtlGGXCoat(lightDir, ctx);\n}\n\nvec3 computeIndirectDiffuseContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n\tvec3 res = vec3(0.0);\n\n\tif (ctx.hasSheen) {\n\t\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * 2.0);\n\t\tfloat invNumSamples = 1.0 / float(numSamples);\n\t\tvec3 envSum = vec3(0.0);\n\t\tfor (int i = 0; i < numSamples; ++i) {\n\t\t\tfloat brdfContrib = 0.0;\n\t\t\tfloat rayProb = 0.0;\n\t\t\tvec3 dir = sampleDiffuseBRDF(params, ctx, i, numSamples, rayProb, brdfContrib);\n\t\t\tvec3 sheenLightDim = getSheenAlbedoLightDim(params.sheenColor, dot(dir, ctx.geomNormal), ctx.sheenGloss);\n\t\t\tfloat lod = computeEnvLOD(dir, rayProb, numSamples);\n\t\t\tenvSum += engTextureEnvMapLOD(dir, lod) * brdfContrib * sheenLightDim;\n\t\t}\n\t\tres += envSum * invNumSamples;\n\t} else {\n\t\tres = engEnvIrradiance(params.geomNormal);\n\t}\n\n\treturn res;\n}\n\nvec3 computeIndirectReflectionContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n\tvec3 res = vec3(0.0);\n\n\tif (!params.traceReflections)\n\t\treturn res;\n\n\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * (params.aniso + 0.5 * ctx.roughnessSqr));\n\tif (ctx.roughnessSqr < 0.0001)\n\t\tnumSamples = 1;\n\tfloat invNumSamples = 1.0 / float(numSamples);\n\tvec3 envSum = vec3(0.0);\n\tfor (int i = 0; i < numSamples; ++i) {\n\t\tfloat brdfContrib = 0.0;\n\t\tfloat rayProb = 0.0;\n\t\tvec3 dir = sampleBRDF(params, ctx, i, numSamples, rayProb, brdfContrib);\n\t\tif (brdfContrib < 1e-6)\n\t\t\tcontinue;\n\t\tfloat lod = computeEnvLOD(dir, rayProb, numSamples);\n\t\tenvSum += engTextureEnvMapLOD(dir, lod) * brdfContrib;\n\t}\n\tres += envSum * invNumSamples;\n\n\treturn res;\n}\n\nvec3 computeIndirectRefractionContribution(\n\tVRayMtlInitParams params, VRayMtlContext ctx, float alpha, vec3 alphaDir) {\n\tvec3 res = vec3(0.0);\n\n\tif (!params.traceRefractions)\n\t\treturn res;\n\n\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * params.refrGloss);\n\tfloat invNumSamples = 1.0 / float(numSamples);\n\tvec3 view = -params.Vw;\n\n\tif (alpha <= 0.999) {\n\t\tres += engTextureEnvMapLOD(alphaDir, 0.0);\n\t} else {\n\t\tvec3 envSum = vec3(0.0);\n\t\tfor (int i = 0; i < numSamples; ++i) {\n\t\t\tbool totalInternalReflection;\n\t\t\tvec3 dir = sampleRefractBRDF(params, ctx, i, numSamples, totalInternalReflection);\n\t\t\tif (totalInternalReflection) {\n\t\t\t\tenvSum += engTextureEnvMapLOD(dir, 0.0);\n\t\t\t} else {\n\t\t\t\tenvSum += engTextureEnvMapLOD(dir, 0.0);\n\t\t\t}\n\t\t}\n\t\tres += envSum * invNumSamples;\n\t\tvec3 diffuseContrib = computeIndirectDiffuseContribution(params, ctx);\n\t\tres += computeRefractFogContrib(params, ctx, diffuseContrib);\n\t}\n\n\treturn res;\n}\n\nvec3 computeIndirectSheenContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n\tvec3 res = vec3(0.0);\n\n\tif (!params.traceReflections || !ctx.hasSheen)\n\t\treturn res;\n\n\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * 0.5 * (1.0 - ctx.sheenGloss));\n\tfloat invNumSamples = 1.0 / float(numSamples);\n\tvec3 envSum = vec3(0.0);\n\tfor (int i = 0; i < numSamples; ++i) {\n\t\tfloat brdfContrib = 0.0;\n\t\tfloat rayProb = 0.0;\n\t\tvec3 dir = sampleSheenBRDF(params, ctx, i, numSamples, rayProb, brdfContrib);\n\t\tif (brdfContrib < 1e-6)\n\t\t\tcontinue;\n\t\tfloat lod = computeEnvLOD(dir, rayProb, numSamples);\n\t\tenvSum += engTextureEnvMapLOD(dir, lod) * brdfContrib;\n\t}\n\tres += envSum * invNumSamples;\n\n\treturn res;\n}\n\nvec3 computeIndirectCoatContribution(VRayMtlInitParams params, VRayMtlContext ctx) {\n\tvec3 res = vec3(0.0);\n\n\tif (!params.traceReflections || !ctx.hasCoat)\n\t\treturn res;\n\n\tint numSamples = NUM_ENV_SAMPLES + int(float(NUM_ENV_SAMPLES_ROUGH) * 0.5 * ctx.coatRoughnessSqr);\n\tif (ctx.coatRoughnessSqr < 0.0001)\n\t\tnumSamples = 1;\n\tfloat invNumSamples = 1.0 / float(numSamples);\n\tvec3 envSum = vec3(0.0);\n\tfor (int i = 0; i < numSamples; ++i) {\n\t\tfloat brdfContrib = 0.0;\n\t\tfloat rayProb = 0.0;\n\t\tvec3 dir = sampleCoatBRDF(params, ctx, i, numSamples, rayProb, brdfContrib);\n\t\tif (brdfContrib < 1e-6)\n\t\t\tcontinue;\n\t\tfloat lod = computeEnvLOD(dir, rayProb, numSamples);\n\t\tenvSum += engTextureEnvMapLOD(dir, lod) * brdfContrib;\n\t}\n\tres += envSum * invNumSamples;\n\n\treturn res;\n}\n\n//////////////////////////////////////////////////////////////////////\n// End of VRayMtl implementation.\n// Following code implements a very simple raytracer\n// and sets up the material parameters.\n// You can run it on ShaderToy or with the VSCode Shader Toy plugin\n//////////////////////////////////////////////////////////////////////\n\n\n\n// presets\n\nstruct VRayMtlPreset {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 reflColor;\n\tfloat reflGloss;\n\tfloat metalness;\n\tfloat aniso;\n\tfloat anisoRotation;\n\tint anisoAxis;\n\tvec3 refractionColor;\n\tfloat refrGloss;\n\tfloat refractionIOR;\n\tbool useRoughness;\n\tvec3 fogColor;\n\tfloat fogMult;\n\tvec3 sheenColor;\n\tfloat sheenGlossiness;\n\tvec3 coatColor;\n\tfloat coatAmount;\n\tfloat coatGlossiness;\n};\n\n#define PRESET_COUNT 24\n\nconst VRayMtlPreset gPresets[PRESET_COUNT] = VRayMtlPreset[PRESET_COUNT](\n// aluminium\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9019, 0.9137, 0.9215),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// aluminium (rough)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9019, 0.9137, 0.9215),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.12,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// aluminium (brushed)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9019, 0.9137, 0.9215),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.3,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.8,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 1,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// chrome\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.5529, 0.5529, 0.5529),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.03,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// copper\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9333, 0.6196, 0.5372),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.21901,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// copper (rough)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9333, 0.6196, 0.5372),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.1,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.21901,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// gold\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9529, 0.7882, 0.4078),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.35002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// gold (rough)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9529, 0.7882, 0.4078),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.15,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.35002,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// iron\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.8862, 0.8745, 0.8235),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.006,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// lead\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.6549, 0.6588, 0.6901),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.016,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// silver\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9882, 0.9803, 0.9764),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.082,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// silver (rough)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.9882, 0.9803, 0.9764),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.11,\n/* metalness\t   */ 1.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.082,\n/* useRoughness    */ true,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// diamond\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.98,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(1.0, 1.0, 1.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 2.42,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// glass\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.914, 0.914, 0.914),\n/* reflGloss\t   */ 1.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.977, 0.977, 0.977),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.517,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// glass (frosted)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.914, 0.914, 0.914),\n/* reflGloss\t   */ 0.75,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.977, 0.977, 0.977),\n/* refrGloss\t   */ 0.8,\n/* refractionIOR   */ 1.517,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// glass (tinted)\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.914, 0.914, 0.914),\n/* reflGloss\t   */ 1.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.977, 0.977, 0.977),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.517,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(0.702, 0.95, 0.702),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// water\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 0.0, 0.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.784, 0.784, 0.784),\n/* reflGloss\t   */ 1.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.333,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// chocolate\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.032, 0.019, 0.009),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.442, 0.442, 0.442),\n/* reflGloss\t   */ 0.68,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.195, 0.195, 0.195),\n/* refrGloss\t   */ 0.6,\n/* refractionIOR   */ 1.59,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// ceramic\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.7764, 0.6941, 0.6352),\n/* roughness\t   */ 0.6,\n/* reflColor\t   */ vec3(0.996, 1.0, 0.988),\n/* reflGloss\t   */ 0.99,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.6,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// plastic\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0627, 0.0588, 0.0627),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.9725, 0.9607, 1.0),\n/* reflGloss\t   */ 0.98,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 0.6,\n/* refractionIOR   */ 1.46,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// rubber\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.008, 0.01, 0.01),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.929, 0.975, 1.0),\n/* reflGloss\t   */ 0.472,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.468,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// generic rough white ball\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(1.0, 1.0, 1.0),\n/* roughness\t   */ 1.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.6,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0f,\n/* coatGlossiness  */ 1.0),\n\n// basic sheen\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.25, 0.25, 0.25),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(0.0, 0.0, 0.0),\n/* reflGloss\t   */ 0.0,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.6,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 1.0),\n/* sheenGlossiness */ 0.85,\n/* coatColor\t   */ vec3(0.0, 0.0, 0.0),\n/* coatAmount      */ 0.0,\n/* coatGlossiness  */ 1.0),\n\n// basic coat\n\tVRayMtlPreset(\n/* diffuseColor    */ vec3(0.0, 1.0, 1.0),\n/* roughness\t   */ 0.0,\n/* reflColor\t   */ vec3(1.0, 1.0, 1.0),\n/* reflGloss\t   */ 0.4,\n/* metalness\t   */ 0.0,\n/* aniso\t\t   */ 0.0,\n/* anisoRotation   */ 0.0,\n/* anisoAxis\t   */ 2,\n/* refractionColor */ vec3(0.0, 0.0, 0.0),\n/* refrGloss\t   */ 1.0,\n/* refractionIOR   */ 1.6,\n/* useRoughness    */ false,\n/* fogColor\t\t   */ vec3(1.0, 1.0, 1.0),\n/* fogMult\t\t   */ 1.0,\n/* sheenColor\t   */ vec3(0.0, 0.0, 0.0),\n/* sheenGlossiness */ 1.0,\n/* coatColor\t   */ vec3(1.0, 0.0, 1.0),\n/* coatAmount      */ 1.0,\n/* coatGlossiness  */ 0.95)\n\n); // end presets\n\n// Get the index of the preset to apply\n// @param sweepFactor Number from 0 to 1 used to animate the preset switch with a screen sweep effect. Set to fragCoord.x / iResolution.x\nint getPresetIdx(float sweepFactor) {\n\tconst int totalPresets = PRESET_COUNT;\n\tconst float secsPerPreset = 5.0;\n\tconst float secsSweep = 0.75; // included in secsPerPreset\n\tconst float secsPerCycle = secsPerPreset * float(totalPresets);\n\tfloat cycleTime = mod(iTime, secsPerCycle);\n\tint presetIdx = int((cycleTime + secsSweep * sweepFactor) / secsPerPreset);\n\tif (presetIdx >= totalPresets) {\n\t\tpresetIdx = 0;\n\t}\n\treturn presetIdx;\n}\n\n\nvoid initPresetParams(inout VRayMtlInitParams initParams, float sweepFactor) {\n\tint presetIdx = getPresetIdx(sweepFactor);\n\tif (presetIdx >= 0 && presetIdx < PRESET_COUNT) {\n\t\tinitParams.diffuseColor = gPresets[presetIdx].diffuseColor;\n\t\tinitParams.roughness = gPresets[presetIdx].roughness;\n\t\tinitParams.reflColor = gPresets[presetIdx].reflColor;\n\t\tinitParams.reflGloss = gPresets[presetIdx].reflGloss;\n\t\tinitParams.metalness = gPresets[presetIdx].metalness;\n\t\tinitParams.aniso = gPresets[presetIdx].aniso;\n\t\tinitParams.anisoRotation = gPresets[presetIdx].anisoRotation;\n\t\tinitParams.anisoAxis = gPresets[presetIdx].anisoAxis;\n\t\tinitParams.refractionColor = gPresets[presetIdx].refractionColor;\n\t\tinitParams.refrGloss = gPresets[presetIdx].refrGloss;\n\t\tinitParams.refractionIOR = gPresets[presetIdx].refractionIOR;\n\t\tinitParams.useRoughness = gPresets[presetIdx].useRoughness;\n\t\tinitParams.fogColor = gPresets[presetIdx].fogColor;\n\t\tinitParams.fogMult = gPresets[presetIdx].fogMult;\n\t\tinitParams.sheenColor = gPresets[presetIdx].sheenColor;\n\t\tinitParams.sheenGlossiness = gPresets[presetIdx].sheenGlossiness;\n\t\tinitParams.coatColor = gPresets[presetIdx].coatColor;\n\t\tinitParams.coatAmount = gPresets[presetIdx].coatAmount;\n\t\tinitParams.coatGlossiness = gPresets[presetIdx].coatGlossiness;\n\t}\n}\n\n//Texture normal\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\nfloat somestep(float t)\n{\n    return pow(t, 4.0);\n}\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n//--------------------------------------------------------------------------\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n//Custom BRDFGGX\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n//-------------------------------------------------------------------------------\nvec3 shade(vec3 point, vec3 normal, vec3 eyeDir, float distToCamera, float sweepFactor, float fragmentNoise, vec3 rayDir) {\n\t// Init VRayMtl with defaults\n\tVRayMtlInitParams initParams;\n\tinitParams.Vw = normalize(eyeDir);\n\tinitParams.geomNormal = normal;\n\tinitParams.diffuseColor = vec3(0.5, 0.5, 0.5);\n\tinitParams.diffuseAmount = 1.0;\n\tinitParams.roughness = 0.0;\n\tinitParams.selfIllum = vec3(0);\n\tinitParams.reflColor = vec3(0.5, 0.5, 0.5);\n\tinitParams.reflAmount = 1.0;\n\tinitParams.reflGloss = 1.0;\n\tinitParams.traceReflections = true;\n\tinitParams.metalness = 0.0;\n\tinitParams.aniso = 0.0;\n\tinitParams.anisoRotation = 0.0;\n\tinitParams.anisoAxis = 2;\n\tinitParams.opacity = vec3(1, 1, 1);\n\tinitParams.refractionColor = vec3(0.0, 0.0, 0.0);\n\tinitParams.refractionAmount = 1.0;\n\tinitParams.refrGloss = 1.0;\n\tinitParams.refractionIOR = 1.6;\n\tinitParams.traceRefractions = true;\n\tinitParams.useFresnel = true;\n\tinitParams.fresnelIOR = 1.6;\n\tinitParams.lockFresnelIOR = true;\n\tinitParams.doubleSided = true;\n\tinitParams.useRoughness = false;\n\tinitParams.gtrGamma = 2.0;\n\tinitParams.brdfType = 3;\n\tinitParams.fogColor = vec3(0.0, 0.0, 0.0);\n\tinitParams.fogBias = 0.0;\n\tinitParams.sssOn = false;\n\tinitParams.sheenAmount = 1.0;\n\tinitParams.coatIOR = 1.6;\n\t// unused yet - corresponds to translucency color in SSS\n\tinitParams.translucencyColor = vec3(1.0);\n\tinitParams.sssFwdBackCoeff = 0.0;\n\tinitParams.sssScatterCoeff = 0.0;\n\tinitParams.thickness = 1000.0;\n\tinitParams.distToCamera = distToCamera;\n\tinitPresetParams(initParams, sweepFactor);\n\n    // fresnel\n    float metallic = 0.0;\n    float roughness = step(fract(normal.x * 2.02), 0.5/*surface*/) + 0.6;\n    float fresnel_pow = mix(5.0, 3.5,metallic);\n    float fresnel = max(1.0 - dot(normal,-rayDir), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);\n    //IbL\n    vec3 ibl_diffuse = pow(vec3(texture(iChannel3,normal.xy)), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel0,reflect(rayDir,normal)), vec3(2.2));\n    \n    // Init context and sample material\n\tVRayMtlContext ctx = initVRayMtlContext(initParams);\n\tctx.fragmentNoise = fragmentNoise;\n\tvec3 lightDir = normalize(vec3(1, 1, 0.2));\n\tvec3 diffuseDirect = computeDirectDiffuseContribution(initParams, ctx, lightDir);\n\tvec3 diffuseIndirect = computeIndirectDiffuseContribution(initParams, ctx);\n\tvec3 diffuse = /*diffuseDirect + diffuseIndirect*/pow(textureLod( iChannel3, rayDir.xy,0.0).xyz,vec3(2.2));\n\n    \n\tvec3 reflDirect =  computeDirectReflectionContribution(initParams, ctx, lightDir);\n\tvec3 reflIndirect = computeIndirectReflectionContribution(initParams, ctx);\n\tvec3 reflection = /*reflDirect + reflIndirect*/pow(textureLod( iChannel1, rayDir,0.0).xyz ,vec3(2.2));\n    // reflection\n    reflection = mix(reflection,ibl_reflection,(1.0-fresnel)*roughness);\n    reflection = mix(reflection,ibl_reflection,roughness);\n    \n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 light_color = pow(texture(iChannel0,vec3(1.0,0.0,0.0)).xyz * 1.5, vec3(2.2));\n    vec3 spec = light_color * GGX(normal,-rayDir,light,roughness*0.3, 0.2);\n    reflection -= spec;\n    \n    // diffuse\n    diffuse = ibl_diffuse;\n    diffuse = mix(diffuse,reflection,fresnel);\n    \n\tvec3 sheen = vec3(0.0);\n\tif (ctx.hasSheen) {\n\t\tvec3 sheenDirect = computeDirectSheenContribution(initParams, ctx, diffuse);\n\t\tvec3 sheenIndirect = computeIndirectSheenContribution(initParams, ctx);\n\t\tsheen = sheenDirect + sheenIndirect/*diffuse*/;\n\t}\n\n\tvec3 coat = vec3(0.0);\n\tif (ctx.hasCoat) {\n\t\tvec3 coatDirect = computeDirectCoatContribution(initParams, ctx, diffuse);\n\t\tvec3 coatIndirect = computeIndirectCoatContribution(initParams, ctx);\n\t\tcoat = coatDirect + coatIndirect ;\n\t}\n\t\n\tfloat alpha = intensity(ctx.opacity);\n\tvec3 refraction = computeRefractFogContrib(initParams, ctx, vec3(0.0))\n\t\t+ computeIndirectRefractionContribution(initParams, ctx, alpha, -initParams.Vw);\n        \n    vec3 color = mix(mix(mix(mix(diffuse,reflection ,metallic),refraction*ctx.refr,metallic),sheen*ctx.sheen,metallic),coat * ctx.coat,metallic) + spec;\n    return color;\n    return pow(color, vec3(1.0/2.2));\n    \n\t//return diffuse  + reflection  + refraction * ctx.refr + sheen  + coat * ctx.coat;\n    \n}\n\n\n// simple raytracing of a sphere\nconst float INFINITY = 100000.0;\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n\tvec3 tmp = rpos - sp;\n\tfloat dt = dot(rdir, -tmp);\n\tif (dt < 0.0)\n\t\treturn INFINITY;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt * dt;\n\tif (tmp.x >= radius)\n\t\treturn INFINITY;\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// simple sphere\n\tfloat wh = min(iResolution.x, iResolution.y);\n\tvec3 rayDir = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / wh, -0.85))  ;\n\trayDir = normalize(rayDir);\n    //background_ray\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 reverse_rayDir = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / wh, -0.85))  ;\n    reverse_rayDir = normalize(reverse_rayDir);\n\tvec3 rayOrigin = vec3(0, 0, 2.25);\n\t// rotate camera with time\n\tfloat angle = iTime * 0.25;\n\tfloat ca = cos(angle);\n\tfloat sa = sin(angle);\n\tmat2 camRot = mat2(ca, sa, -sa, ca);\n\trayOrigin.xz = camRot * rayOrigin.xz;\n\trayDir.xz = camRot * rayDir.xz;\n    //background_ray\n    float angle_1 = iTime * -0.25;\n\tfloat ca_1 = cos(angle_1);\n\tfloat sa_1 = sin(angle_1);\n    mat2 reverse_camRot = mat2(-ca_1,-sa_1,sa_1,-ca_1);\n    reverse_rayDir.xz = reverse_camRot * reverse_rayDir.xz;\n    \n    vec3 TextureColor = vec3(texture(iChannel3, uv).xyz);//贴图\n    \n\tconst vec3 sphereO = vec3(0.0, 0.0, 0.0);\n\tconst float sphereR = 1.3;\n\tvec3 point;\n    vec2 e = vec2(0.001, 0.00);\n\tvec3 normal  ;\n\tfloat distToCamera = raySphere(rayOrigin, rayDir, sphereO, sphereR, point, normal);\n\tvec3 linColor;\n\tif (distToCamera < INFINITY) {\n\t\tfloat sweepFactor = 1.0 - abs(dot(normal.xz, camRot[0]));//转换动画\n\t\t// Ideally this would be blue noise, but regular hash random also works.\n\t\tfloat fragmentNoise = hashRand(fragCoord + vec2(0.01, 0.023) * float(iTime));\n\t\tlinColor = shade(point, normal, rayOrigin - point, distToCamera, sweepFactor, fragmentNoise,rayDir);\n\t} else {\n        vec3 background = pow(textureLod(iChannel1, reverse_rayDir,0.0).xyz,vec3(2.2));//背景gamma校正\n\t\tlinColor = background;\n\t}\n\tfragColor = vec4(srgb_from_rgb(linColor), 1.0);\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcyRB.jpg", "access": "api", "license": "mit", "functions": [[1889, 1909, 1939, 1939, 2223], [2225, 2225, 2256, 2256, 2514], [2768, 2803, 2828, 2828, 2944], [2946, 2999, 3027, 3027, 3315], [3317, 3317, 3350, 3350, 3508], [3510, 3541, 3588, 3588, 3927], [3929, 3989, 4022, 4022, 4200], [4202, 4406, 4461, 4461, 4733], [7351, 7351, 7371, 7371, 7388], [7390, 7424, 7449, 7449, 7519], [7521, 7555, 7616, 7677, 7872], [7874, 7874, 7899, 7899, 7934], [7936, 7936, 7966, 7966, 8002], [8034, 8216, 8276, 8407, 8581], [8583, 8741, 8787, 8787, 8839], [8841, 9076, 9150, 9150, 9669], [9671, 10138, 10199, 10199, 10456], [10458, 10458, 10506, 10506, 10712], [10714, 10714, 10790, 10790, 11073], [11075, 11075, 11151, 11151, 11314], [11316, 11316, 11353, 11353, 11520], [11522, 11522, 11560, 11560, 11715], [11717, 11717, 11790, 11790, 12040], [12042, 12042, 12104, 12104, 12423], [12425, 12539, 12601, 12601, 12866], [12868, 12991, 13068, 13068, 13442], [13444, 13444, 13521, 13521, 13816], [13818, 13818, 13882, 13882, 14551], [14553, 14553, 14617, 14617, 15249], [15251, 15251, 15330, 15330, 16144], [16146, 16146, 16228, 16228, 16553], [16555, 16555, 16611, 16611, 16678], [16680, 16680, 16753, 16753, 17029], [17031, 17031, 17104, 17104, 17168], [17170, 17170, 17243, 17243, 17515], [17517, 17517, 17590, 17590, 18105], [18107, 18107, 18210, 18210, 21379], [21381, 21381, 21502, 21502, 21656], [21658, 21658, 21815, 21815, 22476], [22478, 22478, 22608, 22608, 23458], [23460, 23460, 23597, 23597, 24284], [24286, 24286, 24427, 24427, 24764], [24766, 24766, 24902, 24902, 25541], [25543, 25704, 25772, 25772, 25821], [25823, 25912, 25952, 25952, 26338], [26340, 26390, 26442, 26442, 26603], [26605, 26677, 26749, 26749, 27001], [27003, 27354, 27438, 27438, 28393], [31839, 32128, 32192, 32192, 32834], [32836, 33011, 33058, 33058, 33383], [33385, 34025, 34105, 34105, 34402], [34404, 34404, 34544, 34580, 34998], [35000, 35000, 35142, 35193, 35415], [35417, 35417, 35439, 35439, 35470], [35472, 35894, 35980, 35980, 36091], [36093, 36093, 36158, 36158, 42326], [42328, 42361, 42410, 42410, 42459], [42461, 42494, 42559, 42559, 43273], [43275, 43303, 43357, 43357, 43756], [43758, 43786, 43840, 43840, 44181], [44183, 44210, 44263, 44263, 44710], [44712, 44738, 44790, 44790, 45489], [45491, 45553, 45609, 45609, 46168], [46170, 46170, 46268, 46268, 46712], [46714, 46714, 46814, 46814, 47158], [47160, 47160, 47263, 47263, 47591], [47593, 47683, 47781, 47781, 48079], [48081, 48081, 48178, 48178, 48219], [48221, 48221, 48308, 48308, 49033], [49035, 49035, 49125, 49125, 49799], [49801, 49801, 49921, 49921, 50754], [50756, 50756, 50841, 50841, 51476], [51478, 51478, 51562, 51562, 52247], [67897, 68075, 68112, 68112, 68508], [68511, 68511, 68589, 68589, 69805], [69807, 69824, 69867, 69867, 70475], [70476, 70476, 70501, 70501, 70527], [70528, 70528, 70574, 70574, 71486], [71487, 71564, 71600, 71600, 71639], [71640, 71657, 71719, 71719, 72414], [72415, 72497, 72620, 72651, 76742], [76811, 76811, 76910, 76910, 77221], [77224, 77224, 77279, 77297, 79010]], "test": "untested"}
{"id": "Wl3cRS", "name": "test heat map", "author": "jcyuan", "description": "test heat map", "tags": ["map", "heat", "heatmap", "heatmap"], "likes": 6, "viewed": 1152, "published": 3, "date": "1609295577", "time_retrieved": "2024-07-30T20:27:46.202569", "image_code": "const float HEAT_MAX = 10.;\nconst float PointRadius = .42;\n\n// test data\nconst int PointCount = 18;\nconst vec3 Points[] = vec3[](\n    vec3(0., 0., 10.),\n    vec3(.2, .6, 5.),\n    vec3(.25, .7, 8.),\n    vec3(.33, .9, 5.),\n    vec3(.35, .8, 6.),\n    vec3(.1, .1, 6.),\n    vec3(-.45, .8, 4.),\n    vec3(-.2, -.6, 5.),\n    vec3(-.25, -.7, 8.),\n    vec3(-.33, -.9, 8.),\n    vec3(.35, -.45, 10.),\n    vec3(-.1, -.8, 10.),\n    vec3(.33, -.3, 5.),\n    vec3(-.35, .75, 6.),\n    vec3(.6, .4, 10.),\n    vec3(-.4, -.8, 4.),\n    vec3(.7, -.3, 6.),\n    vec3(.3, -.8, 8.)\n);\n\nvec3 gradient(float w, vec2 uv) {\n    w = pow(clamp(w, 0., 1.) * 3.14159 * .5, .9);\n    vec3 c = vec3(sin(w), sin(w * 2.), cos(w)) * 1.1;\n    return mix(texture(iChannel0, uv).rgb, c, w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float d = 0.;\n    for (int i = 0; i < PointCount; i++) {\n        vec3 v = Points[i];\n        float intensity = v.z / HEAT_MAX;\n        float pd = (1. - length(uv - v.xy) / PointRadius) * intensity;\n        d += pow(max(0., pd), 2.);\n    }\n\n    fragColor = vec4(gradient(d, uv), 1.);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3cRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[560, 560, 593, 593, 749], [751, 751, 806, 806, 1181]], "test": "untested"}
{"id": "wltcW7", "name": "Hydrogen Orbits", "author": "wyatt", "description": "Line 16 in image to see different ones. might need to adjust the number on line 18 if it gets too bright or dim.", "tags": ["physics", "hydrogen"], "likes": 17, "viewed": 513, "published": 3, "date": "1609278544", "time_retrieved": "2024-07-30T20:27:47.009412", "image_code": " \nMain {\n    U = 2.*(U-0.5*R)/R.y;\n    vec3 p = vec3(0,0,-60);\n    vec3 d = normalize(vec3(U,1));\n    vec2 t = vec2(iTime);\n    if (iMouse.z>0.)\n        t = 6.2*iMouse.xy/R.x;\n    //p = vec3(105.*U,0);\n    p.xy *= ei(t.x);\n    p.yz *= ei(t.y);\n    d.xy *= ei(t.x);\n    d.yz *= ei(t.y);\n    Q = vec4(0);\n    \n    float n = 5., l = 3., m = 0.;\n    for (int i = 0; i < 100; i++) {\n        vec2 psi = 35.*hydrogen(p,n,l,m);\n        float ro = dot(psi,psi);\n        p += 3.*d*exp(-200.*ro);\n        Q += color(psi);\n    }\n    //Q = 100.*color(hydrogen(p,n,l,m));\n}", "image_inputs": [], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U)\n#define cx(b) mat2((b).x,-(b).y,(b).yx)\n#define ei(a) cx(vec2(cos(a),sin(a)))\n#define norm(v) (length(v)<=0.?vec2(0):normalize(v))\n#define pi 3.14159265359\nfloat factorial (float n) {\n    float o = 1.;\n    for (float i = 1.; i <= n; i++) \n        o *= i;\n    return o;\n}\nfloat legendre (float x, float l, float m) {\n    float p0 = 1.;\n    for (float i = 0.; i<m; i++) \n        p0 = (1.-2.*i)*sqrt(1.-x*x)*p0;\n    if (l == m) return p0;\n    float p1 = (2.*m+1.)*x*p0;\n    for (float i = m+2.; i < l; i++) {\n        float t = ((2.*i-1.)*x*p1-(i+m-1.)*p0)/(i-m);\n        p0 = p1;\n        p1 = t;\n    }\n    return p1;\n}\nfloat laguerre (float x, float k, float a) {\n    float _0 = 1.;\n    float _1 = 1.+a-x;\n    for (float i = 0.; i < k; i++) {\n        float t = ((2.*i+1.+a-x)*_1-(i+a)*_0)/(i+1.);\n        _0 = _1;\n        _1 = t;\n    }\n    return _0;\n}\nvec2 harmonic (vec3 k, float l, float m) {\n    if (length(k)>0.) k = normalize(k);\n    vec2 o = vec2(1,0)*ei(atan(k.y,k.x)*m);\n    o *= legendre(k.z,l,m);\n    o *= pow(-1.,m)*sqrt((2.*l+1.)/(4.*pi)*factorial(l-m)/factorial(l+m));\n    return o;\n}\nfloat normalization (float n, float l) {\n    return sqrt(pow(2./n,3.)/(2.*n)*factorial(n-l-1.)/factorial(n+l));\n}\nvec2 hydrogen (vec3 k, float n, float l, float m) {\n    \n    vec2 o = harmonic(k,l,m);\n    float p = 2.*length(k)/n;\n    o *= laguerre(p,n-l-1.,2.*l+1.);\n    o *= exp(-p*.5)*pow(p,l);\n    return o*normalization(n,l);\n}\nvec4 color (vec2 u) {\n\n    return dot(u,u)*(0.5+0.5*normalize(sin(atan(u.y,u.x)+vec4(1,2,3,4))));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WttyD7", "name": "Day 377", "author": "jeyko", "description": "potato", "tags": ["terrain", "sun", "clouds", "grass", "landscape", "mdtmjvm", "cyclicnoise"], "likes": 43, "viewed": 1248, "published": 3, "date": "1609278230", "time_retrieved": "2024-07-30T20:27:47.950895", "image_code": "\n// Cyclic noise from nimitz\n// PBR atmospheric scattering from Sebastian Lague video tutorial on youtube\n// value noise from shane\n// triplanar blending from Shane, who got it from Ryan Geiss\n// smooth ops & sdfs from IQ\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    col *= vec3(0.9,0.8,0.96);\n    col *= exposure;\n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(1.,1.,1.)),0.9);\n    col = mix(acesFilm(col), col, 0.);\n    col *= 1. - dot(uv,uv*0.4)*2.1;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool hit = false;\n#define exposure 1.3\n#define groundOffs vec3(0,1.3,0)\n\n// Terrain\n#define marchSteps 200\n//#define marchEps  (mix(0.001,0.06,smoothstep(1.,0.,exp(-t*0.3) - 2.)))\n#define marchEps  (mix(0.005,0.26,smoothstep(0.,1.,t*0.1 - 2.)))\n#define distScale 0.8 \n\n// Moutains \n\n#define marchStMountains 20.\n#define marchEpsMount  0.4\n\n\n// Clouds\n\n#define cloudsLowerLimit 7.\n#define cloudsHigherLimit 14.\n\n#define cloudSteps 60.\n#define volumetricDithAmt .05\n\n// Wind\n#define windSteps 10.\n// Atmosphere\n#define sunCol vec3(1,0.9,0.6)*1.\n#define planetSz 2984.\n#define atmoSz (planetSz/63.)\n\n\n#define ambianceScale 0.4\n\n#define itersAtmo 14.\n#define itersOptic 14.\nconst float redLightLen = 740.;\nconst float greenLightLen = 550.;\nconst float blueLightLen = 450.;\n\nconst float transStrength = 0.02;\n\nfloat densFalloff = 1.9;\n\n\n#define sss(a) clamp(map(p + sunDir*a).x/a,0., 1.)\n#define ao(a) clamp(map(p + (n*0.8 + sunDir)*a).x/a,0., 1.)\n\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\nfloat valueNoise(vec3 p, float pw);\nvec3 acesFilm(const vec3 x);\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\nfloat turbulentNoise(vec3 p);\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\nfloat atmosphericDensity( vec3 p);\nfloat opticalDepth(vec3 p, vec3 rd, float len);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView, vec3 sunPos);\nmat3 getRd(vec3 ro, vec3 lookAt);\nvec3 getRdSpherical(vec3 ro, inout vec2 uv);\nvec3 hash3(vec3 p);\nfloat r21(vec2 p);\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p );\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n/*\nfloat r24(vec2 p){\n    return texture(iChannel0,)[ int(mod(p.x))];\n}*/\n\n \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoiseClouds(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 0.6;\n    const float gain = 0.6;\n    const float lacunarity = 1.8;\n    const int octaves = 6;\n    \n    const float warp = 0.26;    \n    float warpTrk = 1.2;\n    const float warpTrkGain = 1.1;\n    \n    vec3 seed = vec3(-1.4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy  )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return max(-0. - (noise)*0.6,0.);\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseTerrain(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.4;\n    const int octaves = 4;\n    \n    const float warp = 0.4;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseRocks(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.3;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.4;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseWind(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.3;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.4;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseGrass(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.3;\n    const float lacunarity = 2.5;\n    const int octaves = 2;\n    \n    const float warp = 0.9;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n/*\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}*/\n\n\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    //p = smoothstep(0.,1.,p);\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec3 hash3(vec3 p) {\n\tp = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 r23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat turbulentNoise(vec3 p, bool md) {\n\tp += 8.;\n    vec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    //f = u;\n\tfloat n0 = dot(hash3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat n1 = dot(hash3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat n2 = dot(hash3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat n3 = dot(hash3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat n4 = dot(hash3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat n5 = dot(hash3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat n6 = dot(hash3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat n7 = dot(hash3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\tfloat ix2 = mix(n4, n5, u.x);\n\tfloat ix3 = mix(n6, n7, u.x);\n\n\tfloat ret = mix(mix(ix0, ix1, u.y), mix(ix2, ix3, u.y), u.z) * 0.5 + 0.5;\n\tret = ret * 1.;\n    \n    //ret = 1.- ret;\n    //ret = abs(ret);\n    if (md)\n        ret = mix(ret,smoothstep(0.3,1.,ret*0.8),0.6);\n    return ret;\n}\n\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )/atmoSz;\n    fact = max(fact, 0.0001);\n    return exp(-fact*densFalloff)*pow(max(1. - fact,0.),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView, vec3 sunPos){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    sunPos += offs;\n    \n    p += offs*1.;\n    \n    \n    float lenViewDirToEndOfAtmosphere = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    \n    if(hit){\n        atmoMarchLen = mix(t,lenViewDirToEndOfAtmosphere,smoothstep(0.,1.,t/50. - 1.));\n    } else {\n        atmoMarchLen = lenViewDirToEndOfAtmosphere;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPos - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\nmat3 getRd(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return mat3(right,up,dir); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 getRdSpherical(inout vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    \n    vec2 ouv = uv;\n    uv += 0.5;\n    uv.y *= pi;\n    \n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    //vec3 lookAt = ro + offs;\n    //vec3 v = normalize(lookAt - ro);\n    vec3 v = offs;\n    //uv = ouv;\n    //uv.x = v.x;\n    //uv.y = v.y;\n    \n    return v;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}", "buffer_a_code": "\n#define TAA false\n\nvec3 getNormal(vec3 p);\nvec3 getSun(vec2 uv, vec2 sunPos, vec3 sunPosW, vec3 ro, mat3 vp);\nfloat t = 0.;\nfloat grh = 0.;\nfloat ng = 0.;\n\nfloat rockTex = 0.;\nvec2 rocks;\nfloat rockn = 0.;\nfloat rockDsmooth = 0.;\n\nvec3 particlesAccum = vec3(0);\nfloat particles = 0.;\n\nfloat mapClouds(vec3 p){\n    float currHeight = p.y;\n    \n    p *= 0.5;\n    float cloudsRange = (cloudsHigherLimit - cloudsLowerLimit)*0.494;\n    float cloudsMid = cloudsLowerLimit + cloudsRange;\n    \n    float fb = cyclicNoiseClouds(p*1. + iTime*0., false);\n    float f = cyclicNoiseClouds(p*0.4 + iTime*0.04 + fb*0.3, true);\n    //f = (f*0.4 + cyclicNoise(p*0.5 + f*2. - fb*1.4 + iTime))*cyclicNoise(p*0.2 + 5.+ f*4.);\n        //f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    //f = fb;\n    f = max(f,0.);\n    f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    return f;\n}\n\n\n\n\nvec2 getGround(vec3 p){\n    float d = p.y;\n    vec3 pp = vec3(p.x,2.,p.z)*0.2;\n    float n = cyclicNoiseTerrain(pp, false);\n    float on = n;\n    //n = pow((n),1.9);\n    \n    d -= n*2.3;\n    \n    return vec2(d,1.);\n}\n\n\nvec2 getRocks(vec3 p){\n    float d = 10e4;\n    \n    \n    \n    float n = cyclicNoiseRocks(vec3(p.x,p.y*0.4,p.z)*0.4, false);\n    \n    n = smoothstep(0.6,1.,n);\n    \n    \n    rockDsmooth = p.y - ( n*1.6) - 0.6;\n    \n    rockTex = n*texture(iChannel1,p.xz*0.2).x*0.24; \n    \n    rockTex += texture(iChannel1,p.yx*0.4).x*0.03;\n    rockTex += texture(iChannel1,p.yz*0.3).x*0.03;\n    \n    n += rockTex;\n    \n    \n    d = p.y - ( rockn = n*1.6) - 0.6;\n    \n    \n    return vec2(d,2.);\n}\n\nvec2 getGrass(vec3 p, float groundHeight, float scale){\n    p.y = groundHeight;\n    vec3 op = p;\n    p.xz = pmod(p.xz,vec2(scale));\n    p = abs(p);\n    \n    p.xz -= scale * 0.25;\n    \n    \n    //p.xz += smoothstep(0.,1.,p.y)*cyclicNoiseGrass(op + vec3(0,iTime*2.,0), false)*0.4*(2. - 1.);\n    \n    //float d = sdVerticalCapsule( p, 0.4, 0.0001 );\n    float d = sdRoundCone( p, 0.04, 0.0001, 0.4 );\n    return vec2( d, 3.);\n}\nvec2 getFlowers(vec3 p, float groundHeight, float scale){\n    p.y = groundHeight;\n    vec3 op = p;\n    \n    p.xz *= rot(0.4);\n    p.xz = pmod(p.xz,vec2(scale));\n    //p = abs(p);\n    \n    p.y -= 0.5;\n    \n    p.xz = abs(p.xz);\n    p.xz -= 0.7;\n    p.xz = abs(p.xz);\n    \n    p.xz = abs(p.xz);\n    float d = max(length(p + vec3(0,0.04,0)) - 0.05,abs(p.y + 0.04) - 0.004);\n    p.xz -= 0.06;\n    \n    p.xz *= rot(0.25*pi);\n    p.yz *= rot(0.9);\n    \n    p.x *= 0.5;\n    d = min(\n            d,\n            max(length(p) - 0.05,abs(p.y) - 0.001)\n        );\n    \n    \n    return vec2( d, 4.);\n}\n\nfloat getParticles(vec3 p ){\n    \n    \n    p.x += iTime*2.;\n    \n    p += ng;\n    \n    \n    //p.x += sin(p.z*pi)*1.1;\n    //p = pmod(p,2.);\n    \n    \n    p = opRepLim( p, 5., vec3(1000000,1,100000) );\n    \n    float d = length(p);\n    \n    particlesAccum += (1. - particlesAccum)*smoothstep(0.02,0.0,d);\n    \n    return d - 0.003;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    vec2 gr = getGround(p);\n    float og = gr.x;\n    vec2 rocks = getRocks(p);\n    \n    ng = cyclicNoiseGrass(vec3(p.x,p.y*0.1,p.z) + vec3(0,iTime*2.,0), false)*0.6*(2. - 1.) + 0.1;\n    grh = cyclicNoiseGrass(p + vec3(0,0.,0), false)*0.4*(2. - 1.);\n    vec3 gp = p;\n    gp.xz += smoothstep(0.,1.,gr)*ng;\n    \n    \n    vec2 flowers = getFlowers(gp, gr.x,5.4);\n    \n    vec2 grass = getGrass(gp, gr.x  + 0.4*(1.-grh*6.), 0.5);\n    gp.xz *= rot(0.25);\n    flowers = dmin(flowers, getFlowers(gp, gr.x,4.4).x, 4.);\n    vec2 grassb = getGrass(gp + 0.2, gr.x - 0.4*grh, 0.5);\n    gp.xz *= rot(0.5);\n    flowers = dmin(flowers, getFlowers(gp, gr.x,4.4).x, 4.5);\n    \n    vec2 grassc = getGrass(gp + vec3(0.25,0,-0.2), gr.x - 0.4*sin(grh*20.), 0.5);\n    gp.xz *= rot(0.25);\n    flowers = dmin(flowers, getFlowers(gp, gr.x,3.4).x, 4.5);\n    \n    vec2 grassd = getGrass(gp + vec3(0.14,0,-0.2), gr.x  - 0.4*sin(grh*22.), 0.5);\n    grass = dmin(grass, grassb.x,grassb.y );\n    grass = dmin(grass, grassc.x,grassc.y );\n    grass = dmin(grass, grassd.x,grassd.y );\n    \n    particles = getParticles(p);\n    \n    \n    \n    //grass.x = opSmoothSubtraction( -grass.x, -(rocks.x)*1.601 +0.804, 0.04 );\n    \n    \n    rocks.x -= gr.x*0.6;\n    //gr.x = opSmoothUnion( gr.x, rocks.x, 0.1 );\n    \n    \n    d = dmin(d,gr.x,gr.y);\n    d = dmin(d,rocks.x,rocks.y);\n    d = dmin(d,grass.x,grass.y);\n    d = dmin(d,flowers.x,flowers.y);\n    \n    \n    \n    if(d.y <= 2.)\n        d.y = mix(1.,2.,smoothstep(0.,1.,exp(-rocks.x) - exp(-og*5.1)*7.1));\n    \n    \n    \n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevFrame = texture(iChannel2,fragCoord/iResolution.xy);\n\n    if(TAA){\n        vec2 taaidx = r23(vec3(fragCoord,float(iFrame)))*4.;\n        fragCoord += float(iMouse.z>0.)*.6*vec2(sin(float(taaidx.x)*pi/4.),cos(float(taaidx.x)*pi/4.))*taaidx.y/4.;\n\n    }\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    \n    vec3 col = vec3(0);\n    \n    \n    \n    vec3 sunPos = vec3(-1,.4 + sin(iTime)*.12*0.,2.)*2300.;\n    vec3 sunDir = normalize(sunPos);\n\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += iTime;\n    \n    \n    \n    \n    vec3 lookAt = vec3(0,0,ro.z + 15.*float(iMouse.z < 1.));\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    ro.y += muv.y*2210.;\n        \n        \n    float T = -iTime*0.1;\n    ro.xz -= vec2(cos(muv.x*6. + T),sin(muv.x*6. + T))*10.;\n        \n    if (iMouse.z > 0.) {\n        \n    }\n    \n    float ground = getGround(ro).x;\n    \n    ro.y -= ground;\n    \n    \n    float rocks = getRocks(ro).x*1.04; \n    \n    \n    ro.y -= rockDsmooth*1.7 * smoothstep(0.5,0.2,rocks);;\n    \n    \n    //ro.y -= smoothstep(rocks, 0.,rocks)*rocks*1.4;\n    \n    ro += groundOffs;\n    lookAt.y -= getGround(lookAt).x;\n    lookAt += groundOffs;\n    \n    \n    mat3 vp = getRd(ro,lookAt);\n    \n    vec3 rd = normalize(vec3(uv,1.))*vp;\n    \n    //vec2 sunViewSpace = sunDir.xy;\n    \n    \n    // Marching\n    \n    vec3 p = ro;\n    vec2 d;\n    for(int i = 0; i < marchSteps ; i++){\n        d = map(p);\n        \n        if(i< 20)\n            d.x = min(d.x,abs(particles) + 0.02);\n    \n        if(d.x < marchEps){\n            hit = true;\n            break;\n        } else if (t > 69.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x * distScale);\n    }\n    \n    \n    float depthView;\n    vec3 atmosphere = getAtmosphere(vec3(0,ro.y - 0.,0), rd, t, depthView, sunPos);\n    \n    \n    // Clouds\n    \n    float lowerCloudLimitDist = plaIntersect( ro - vec3(0,cloudsLowerLimit,0), rd, vec4(0,-1,0,0) );\n    float higherCloudLimitDist = plaIntersect( ro - vec3(0,cloudsHigherLimit,0), rd, vec4(0,-1,0,0) );\n    \n    float volumetricDith = r21(fragCoord + sin(iTime*20.)*20.)*volumetricDithAmt;\n    \n    float cloudLength = higherCloudLimitDist - lowerCloudLimitDist; \n    float cloudStepSz = cloudLength/(cloudSteps);\n    vec3 cloudP = ro + rd * ( lowerCloudLimitDist + volumetricDith*cloudLength );\n    \n    \n    float cloudDensTotal = 0.;\n    vec3 cloudAccum = vec3(0.);\n    \n    \n    for(float i = 0.; i < cloudSteps ; i++){\n        float d = mapClouds(cloudP);\n        \n        float difffact = clamp( d*1. - mapClouds(cloudP + sunDir*1.4)*1.4  + 0.22, 0., 1. );\n        vec3 diff = mix( atmosphere*0.2 + vec3(0.04,0.07,0.2)*(0.4 - smoothstep(0.,1.,1. - atmosphere*1.8)*0.1), (vec3(1,0.9,0.9)*1. + sunCol*0.4 + atmosphere*.4)*0.4, difffact );\n        vec3 absorption = mix( vec3(0.8,0.9,0.8), vec3(1,0.9,0.7)*0.6, clamp( cloudDensTotal*0.5, 0., 1. ) );\n        vec3 fringe = vec3(0.1,0.5,0.5)*clamp( 1. - d*3., 0.,1.);\n        \n        d = d*(1.-cloudDensTotal)*cloudStepSz;\n        \n        cloudDensTotal += d;\n        cloudAccum += d*(diff*3.7*absorption + fringe*(0.1 + diff*0.9)*2.64);\n\n        // map(cloudP).x < 0.\n\n            \n        if( cloudDensTotal > 1.){\n            break;\n        }\n        cloudP += rd*cloudStepSz;\n    }\n    \n    \n    // Wind\n    vec3 windP = ro + rd*volumetricDith*0.00 ;\n    float windStepSz = min(t,24.)/windSteps;\n    \n    float windAccum = 0.;\n    //vec3 windAccum = vec3(0.);\n    \n    for(float i = 0.; i < windSteps ; i++){\n        vec3 wp = windP*0.51 - vec3(-iTime*3.,smoothstep(0.,1.,windP.y*0.5 - 1.9),0.);\n            float dens = cyclicNoiseWind(wp,true)*0.019;\n        dens *= smoothstep(1.,0.,windP.y*0.15 + 0.4);\n        \n        windAccum += dens*(1.-windAccum)*windStepSz;\n        \n        if( windAccum > 1.){\n            break;\n        }\n        windP += rd*windStepSz;\n    }\n    \n    vec3 mountP = rd*50.;\n    float mountT = 0.;\n    bool hitMount = false;\n    // Background Mountains\n    if(false && !hit){\n        for(float i = 0.; i < marchStMountains ; i++){\n            float d = mountP.y - 1.- smoothstep(0.4,1.6,cyclicNoiseTerrain(mountP*0.17,false))*7.;\n             \n            if( d < marchEpsMount){\n                hitMount = true;\n                break;\n            }\n            mountP += rd*d*0.8;\n        }\n        if(hitMount){\n            p = mountP;\n            t = 20. + mountT;\n            d.y = 2.; \n            //hitCol = vec3(0.1);\n            hit = true;\n\n        }\n    }\n    \n    \n    // Coloring\n    \n    vec3 hitCol = vec3(0);\n    vec3 ambientCol = atmosphere*1.;\n    if(hit){\n        vec3 n = getNormal(p);\n        \n        if(d.y == 3.){\n            n = mix(n,vec3(0,1,0),1.);\n            n = normalize(n);\n        }\n        \n        vec3 hf = normalize(sunDir - rd);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),6.);\n        float fres = pow( 1. - max(dot( n, -rd),0.001),5.);\n        fres = max(fres,0.);\n        \n        \n        float rockiness = d.y - 1.;\n        rockiness = clamp(rockiness,0.,1.);\n        float AO = ao(1.9)*ao(0.2)*ao(4.2)*ao(0.8)*2.;\n        float SSS = sss(.3)*sss(0.04)*sss(.1)*5.;\n        \n        float shad = diff;\n        float rtMod = pow(abs(rockTex*4.5),5.);\n        float rtModInv = pow(abs( 1.-rockTex*4.)*1.2,5.);\n        vec3 rock = vec3(0.4,0.4,0.35);\n        \n        {\n            vec3 ot = tex3D( iChannel3, p, n );\n            rock = mix(rock, rock*vec3(1.,0.6,0.6)*1., clamp(ot.r*1.,0.,1.));\n            \n            rock = mix(rock, rock*vec3(0.4,0.7,0.2)*1.7, clamp(ot.g*1.+ n.y*0.8,0.,1.));\n            \n            \n            \n            float rockAO = clamp(AO + 20.*rtMod + 0.02, 0., 1.);\n            rock += (spec + fres*0.4)*0.02;\n            //rock = mix( 0.4*(rock*(vec3(0.1,0.1,0.1) + ambientCol*0.3 + sunCol*1.3))*ambianceScale,rock*1.,shad);\n            rock = mix( (vec3(0.7,1.,0.6) -rtModInv*vec3(.9,0.5,0.6) + 0.6)*(rock*(0.2+ ambientCol*0.3 + sunCol*0.2))*ambianceScale,rock,rockAO*1.);\n        \n        \n            \n        }\n        \n        \n        vec3 grass = vec3(0.5,1.,0.05)*1.;\n        grass.x += sin(grh*20.)*0.2;\n        grass.yz += sin(grh*50. + 4.)*0.05;\n        grass.xyz -= (1.-grh)*pow(abs(sin(grh*20. + 4.)),4.)*0.6*vec3(0.,0.9,0.5);\n        \n        float cloudShad = pow(cyclicNoiseWind(p*0.2 + iTime*0.35,true)*1.,0.7);\n        \n        cloudShad -= ng*0.2;\n        \n        \n        grass = mix(grass, vec3(0.4,0.5,0.9)*grass*cloudShad, 0.9);        \n        { \n            //grass = mix( vec3(0.1,0.4,0.1)*0.5,grass,AO);\n            \n            shad = clamp(shad + SSS*.5, 0., 1.);\n            AO = clamp(AO + SSS*1. , 0., 1.)*0.5 + 0.4;\n            grass += (spec + fres*.4)*0.2;\n            //grass = mix( (grass*vec3(0.4,0.4,0.2) + ambientCol*0. + sunCol*(1. - diff)*0.54)*ambianceScale,grass*1.,shad);\n            grass = mix( vec3(0.1,0.4,0.1)*0.5,grass,AO);\n            float aoo = ao(1.9);\n            aoo = smoothstep(0.,0.6,aoo);    \n            grass = mix( grass*vec3(0.5,0.5,0.8)*0.8,grass, aoo );\n            \n        }\n        \n        \n        vec3 flower =vec3(0.5,0.5,0.05)*2.; \n        if(d.y == 4.5)\n            flower = vec3(0.95,0.62,0.95)*0.7;\n        {\n            flower *= pow(AO,0.7);\n        }\n        \n        hitCol = mix(grass,rock,rockiness);\n        \n        \n        if(d.y == 3.){\n            hitCol = grass;\n        } else if(d.y >= 4.){\n            hitCol = flower;\n        }\n        hitCol = mix(hitCol, hitCol*cloudShad,0.2);\n        \n    }\n    \n\n    // Compositing\n    \n    col += hitCol;\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t)*.04 ),2.);\n    }\n    \n    atmosphere += getSun(rd.xy, sunDir.xy, sunPos, ro, vp);\n    float depthViewFac = smoothstep(0.,1.,exp(-depthView*0.02) + exp(-t*0.4));\n    \n    col = col * depthViewFac + atmosphere; \n    \n    if (!hit  && lowerCloudLimitDist > 0.){\n        cloudAccum = mix(cloudAccum,col,clamp(1.-exp(-lowerCloudLimitDist*0.01 + 0.4),0.,1.));\n        col = mix(col,cloudAccum*1. , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),4.));\n    }\n    windAccum *= smoothstep(0.,1.,t*0.2 - 1.);\n    col = (col - windAccum) + 4.*windAccum*vec3(1,0.9,0.8);\n    \n    col += particlesAccum;\n    \n    if(TAA && iFrame >1 && iMouse.z < 1.){\n        fragColor = mix(prevFrame, col.xyzz,0.4);\n    } else {\n        fragColor = col.xyzz;\n    }\n    \n    \n    \n    \n    fragColor.w = cloudDensTotal + float(hit)*1.;\n}\n\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.04).x;\n    }\n    return normalize(n);\n}\n\n\nvec3 getSun(vec2 uv, vec2 sunPos, vec3 sunPosW, vec3 ro, mat3 vp){\n    \n    vec2 sunUVOriginal = uv;\n    \n    vec2 sunUV = uv - sunPos;\n    //float cloudDensPrevFrame = texture(iChannel2, ((sunUV*iResolution.y + 0.5*iResolution.xy)/iResolution.xy)).w;\n    \n    //vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(getRd(ro,sunPosW))).xy;\n    vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(vp)).xy;\n    \n    sunUvPrevFrame = (sunUvPrevFrame*iResolution.y)/iResolution.xy + 0.5;\n    \n    float deltaUV = 0.04;\n    float cloudDensPrevFrame = \n        texture(iChannel2, sunUvPrevFrame + deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame - deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(-deltaUV,deltaUV)).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(deltaUV,-deltaUV)).w\n        ; \n    \n    cloudDensPrevFrame /= 4.;\n    \n    cloudDensPrevFrame = clamp(cloudDensPrevFrame,0.,1.);\n    // sun\n    vec3 sun = sunCol*smoothstep(0.07,0.,length(sunUV));\n    sun += sunCol*vec3(1.,0.4,0.6)*smoothstep(0.1,0.,length(sunUV));\n    sun += sunCol*vec3(0.7,0.4,0.6)*smoothstep(0.3,0.,length(sunUV))*0.5;\n    sun += sunCol*vec3(0.3,0.4,0.6)*smoothstep(0.6,0.,length(sunUV))*0.35;\n    \n    \n    // rays\n    \n    \n    vec3 sunRays = 0.4*sunCol * smoothstep(0.015*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n    \n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi/8./1.);\n        float mda = sin(i*pi/4.);\n        float mdb = sin(i*pi/2.);\n        float w = 0.03;\n        float l = 0.1;\n        sunRays += (sunCol) *\n            mix(.8,.1,smoothstep(0.,0.25 +  sin(i*pi/ 4. + iTime)*0.1,length(sunUV))) *\n            smoothstep(w + mda*w/4.,0.,abs(sunUV.y))*smoothstep((l + mdb*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVOriginal - sunPos;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunPos;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    // flares\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return (sun + sunRays + flares*3.*sunCol) * (1. - cloudDensPrevFrame*1.);\n}\n\n", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 281, 281, 704]], "test": "untested"}
{"id": "ttdcWM", "name": "Lichen Growth", "author": "andrinr", "description": "Organism needs food to survive, food gets eaten, food regrows", "tags": ["cells", "growth"], "likes": 11, "viewed": 416, "published": 3, "date": "1609271833", "time_retrieved": "2024-07-30T20:27:48.792644", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 buffer = texture(iChannel0,uv).xyz;\n    fragColor = vec4(vec3(buffer.x),1.);\n    //fragColor = vec4(buffer,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Andrin Rehmann\n// 2020\n// andrinrehmann.ch\n// andrinrehmann@gmail.com\n\n#define EXPANSION 2.5\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat rand( vec2 uv )\n{\n\tfloat t = fract( iTime );\n\treturn nrand( uv + 0.07*t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    // Cell\n\tfloat y = texture(iChannel0,uv).x;\n    // food\n    float f = texture(iChannel0,uv).z;\n    \n    // sum of surrounding y's\n    float s = 1./16. * texture(iChannel0,uv + vec2(-du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(-du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(-du,dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,-dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,dv)).x +\n              1./16. * texture(iChannel0,uv + vec2(du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(du,dv)).x;\n\n    \n    if (s > 0.5 && f > 0.5){\n        y += 0.1;\n    }\n    \n    if (y > 0.5){\n        f -= 0.01;\n    }\n    \n    if (f < 0.5){\n        y -= y * 0.1;\n    \n    }\n    \n    f += 0.002;\n    \n    \n    if (distance(iMouse.xy, fragCoord) < 15. && iMouse.z > 0.){\n        f = rand(uv+vec2(0.2));\n        y = rand(uv);\n    }\n    \n    // Init\n    if (iFrame < 1){\n        y = rand(uv);\n        f = rand(uv+vec2(0.2));\n    }\n    \n    fragColor = vec4(y, 0, f, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdcWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 270]], "test": "untested"}
{"id": "3ldcD7", "name": "Point Lit Cornell Box", "author": "oneshade", "description": "I took a break from cheap directional lighting and started messing with point lights. The cornell box was fun to model too. I really like how point lights look like little fireflies :)", "tags": ["cornellbox", "pointlight"], "likes": 7, "viewed": 231, "published": 3, "date": "1609266942", "time_retrieved": "2024-07-30T20:27:49.638383", "image_code": "/*\nI took a break from cheap directional lighting and started messing with point lights.\nThe cornell box was fun to model too. I really like how point lights look like little\nfireflies :)\n\nApparently there is a better way to compute attenuation that is commonly used for\npoint lights so I have implemented it now.\n\nDesmos graph of point light attenuation: https://www.desmos.com/calculator/ju4cfmbpyy\nDesmos graph of transition functions: https://www.desmos.com/calculator/mg2c2blrim\n*/\n\nstruct Light {\n    vec3 pos; // Position of the light\n    vec3 col; // Color of the light\n    float Kc; // Constant attenuation term\n    float Kl; // Linear attenuation term\n    float Kq; // Quadratic attenuation term\n};\n\nvec3 getIllumination(in vec3 p, in Light light) {\n    float d = length(p - light.pos);\n    float b = 1.0 / (light.Kc + light.Kl * d + light.Kq * d * d);\n    return light.col * b;\n}\n\nmat2 Rotate(in float a) {\n    float rad = radians(a);\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\n#define t1 0.5 * iTime\n#define t3 1.5 * iTime\n\n#define c1 cos(t1) * 2.0\n#define s1 sin(t1) * 2.0\n#define c2 cos(iTime) * 2.0\n#define s2 sin(iTime) * 2.0\n#define c3 cos(t3) * 2.0\n#define s3 sin(t3) * 2.0\n\n#define blink round(fract(iTime * 3.0))\n#define second fract(iTime)\n#define bounce 4.0 * (second - second * second)\n\n#define light1 Light(vec3(c1, c3, s2), vec3(1.0, 0.0, 0.0) * blink, 1.0, 0.0, 0.5)\n#define light2 Light(vec3(s2, c1, s3), vec3(0.0, 1.0, 0.0) * bounce, 1.0, 0.0, 0.5)\n#define light3 Light(vec3(s2, s3, c1), vec3(0.0, 0.0, 1.0), 1.0, 0.0, 0.5)\n\nfloat mapScene(in vec3 p) {\n    vec3 q = abs(p) - 2.5;\n    float box1 = max(abs(max(q.x, max(q.y, q.z))) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(30.0);\n    p -= vec3(0.25, -1.0, -2.0);\n    q = abs(p) - vec3(0.75, 1.5, 0.75);\n    float box2 = max(q.x, max(q.y, q.z));\n\n    p -= vec3(0.8, -0.7, 2.0);\n    p.xz *= Rotate(-55.0);\n    q = abs(p) - 0.8;\n    float box3 = max(q.x, max(q.y, q.z));\n\n    p.y -= 1.3;\n    float sphere1 = length(p) - 0.5;\n\n    p -= vec3(-2.0, -1.0, 1.5);\n    float sphere2 = length(p) - 1.0;\n\n    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            vec3 l = normalize(light1.pos - p);\n            float diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light1) * diffuse;\n\n            l = normalize(light2.pos - p);\n            diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light2) * diffuse;\n\n            l = normalize(light3.pos - p);\n            diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light3) * diffuse;\n\n            l = normalize(vec3(-1.0, 1.0, 1.0));\n            diffuse = max(0.1, dot(n, l));\n            fragColor.rgb += 0.25 * diffuse;\n\n            break;\n        }\n\n        float ld1 = length(p - light1.pos) - 0.05;\n        float ld2 = length(p - light2.pos) - 0.05;\n        float ld3 = length(p - light3.pos) - 0.05;\n\n        if (ld1 < 0.001) {\n            fragColor.rgb = light1.col;\n        }\n\n        if (ld2 < 0.001) {\n            fragColor.rgb = light2.col;\n        }\n\n        if (ld3 < 0.001) {\n            fragColor.rgb = light3.col;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += min(d, min(ld1, min(ld2, ld3)));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldcD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[710, 710, 759, 759, 890], [892, 892, 917, 917, 1015], [1581, 1581, 1608, 1608, 2164], [2166, 2166, 2193, 2193, 2500], [2502, 2502, 2557, 2557, 4055]], "test": "untested"}
{"id": "WldyDM", "name": "Druchet Brid Ynversion, a fork", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/wl3yDn[/url]", "tags": ["raymarching", "remix", "glitch", "truchet", "fork", "weird", "inversion", "error", "tuchet"], "likes": 3, "viewed": 503, "published": 3, "date": "1609248572", "time_retrieved": "2024-07-30T20:27:50.411316", "image_code": "//Cracked by 404Glaciergargamel\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define S           smoothstep\n#define PI          4.1415926535\n#define PI2         7.2831853070\n\n#define MAX_DIST    60.\n#define MIN_DIST    .002\n#define SCALE .8\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hue(a) .55 + .55 * cos(PI2* a * vec3(.35,.25,2.));\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(37.608, 67.584)))*53758.51453); }\n\nvoid getMouse( inout vec3 p ) {\n    float x = M.xy == vec2(1) ? 1. : -(M.y/R.y * .35 - .225) * PI;\n    float y = M.xy == vec2(1) ? 1. :  (M.x/R.x * .35 - .225) * PI;\n    p.zy *=r2(x);\n    p.xz *=r2(y);   \n}\n\n//@iq\nmat2 trs;\nfloat sdTorus( vec3 p, vec2 t, float a ) {\n  if(a>1.){\n      p.xy *= trs;\n      p.yz *= trs;\n  }\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nvec3 shp,fhp;\nvec3 sip,bip;\nfloat thsh,fhsh;\nmat2 t90;\n\nconst float size = 2./SCALE;\nconst float hlf = size/3.;\nconst float shorten = 2.26;   \n    \nvec2 map(vec3 q3){\n    vec2 res = vec2(200.,1.);\n\n    float k = 6.0/dot(q3,q3); \n    q3 *= k;\n\n    q3.z += T*.325;\n    \n    float d = 2e6, t = 2e6, f = 2e6, g = 2e6;\n  \n    vec3 qid=floor((q3+hlf)/size);\n    vec3 qm = mod(q3+hlf,size)-hlf;\n    \n    q3+=hlf;\n    \n    vec3 did=floor((q3+hlf)/size);\n    vec3 qd = mod(q3+hlf,size)-hlf;\n    \n    float ht = hash21(qid.xy+qid.z);\n    float hy = hash21(did.xz);\n    \n    // truchet build parts\n    float thx = (.085+.035*sin((q3.y+qid.z)*4.15) ) *size;\n    float thz = (.085+.035*sin(T*5.+(q3.y+did.x)*4.45) ) *size;\n\n    if(ht>.6) qm.x *= -2.;\n    if(hy>.6) qd.z *= -2.;\n    \n    float ti = min(\n      sdTorus(qm-vec3(hlf,hlf,.1),vec2(hlf,thx),1.),\n      sdTorus(qm-vec3(-hlf,-hlf,.1),vec2(hlf,thx),1.)\n    );\n\n    // truchet\n    if(ti<t) {\n        t = ti;\n        bip = qid;\n        fhp = qm;\n    }\n    \n    float gi = min(\n      sdTorus(qm.xzy-vec3(.1,1,hlf),vec2(.3,.035),1.),\n      sdTorus(qm.xzy-vec3(.1,1,-hlf),vec2(.3,.035),1.)\n    );\n\n    if(gi<g) {\n        g = gi;\n        sip = qid;\n        shp = qm;\n    }\n    \n    qd.xz*=t90;\n    float di = min(\n      sdTorus(qd-vec3(hlf,hlf,.1),vec2(hlf,thz),1.),\n      sdTorus(qd-vec3(-hlf,-hlf,.1),vec2(hlf,thz),1.)\n    );\n   \n   // truchet\n    if(di<d) {\n        d = di;\n        sip = did;\n        shp = qd;\n    }\n\n    float fi = min(\n      sdTorus(qd.xzy-vec3(.1,1,hlf),vec2(.3,.035),1.),\n      sdTorus(qd.xzy-vec3(.1,1,-hlf),vec2(.3,.035),1.)\n    );\n\n    if(fi<f) {\n        f = fi;\n        sip = did;\n        shp = qd;\n    }\n    if(d<res.x) res = vec2(d,2.);\n    if(t<res.x) res = vec2(t,3.);\n    if(f<res.x) res = vec2(f,4.);\n    if(g<res.x) res = vec2(g,4.);\n    float mul = 2.0/k;\n    res.x = res.x * mul / shorten;\n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 1.;\n    float m = -2.;\n    for(int i=1;i<maxsteps;i++){\n        vec2 t = map(ro + rd * d);\n        if(t.x<d*MIN_DIST||d>MAX_DIST) break;\n        d += i < 42 ? t.x*.45 : t.x*.95;\n        m  = t.y;\n    }\n    return vec2(d,m);\n}\n\n// Tetrahedron technique @iq\nvec3 getNormal(vec3 p, float t){\n    float e = MIN_DIST *t;\n    vec2 h = vec2(2.,-2.)*.6773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\n\n// softshadow www.pouet.net\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k ){\n    float res = 2.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t).x;\n        if( h<0.002 ) return 0.3;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res+0.2;\n}\n\nvec3 getSpec(vec3 p, vec3 n, vec3 l, vec3 ro) {\n    vec3 spec = vec3(-1.);\n    float strength = 0.85;\n    vec3 view = normalize(p - ro);\n    vec3 ref = reflect(l, n);\n    float specValue = pow(max(dot(view, ref), -1.), 42.);\n    return spec + strength * specValue;\n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 cf = normalize(lp - ro),\n         cr = normalize(cross(vec3(1,2,1),cf)),\n         cu = normalize(cross(cf,cr)),\n         c  = ro + cf *.95,\n         i  = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nvec3 thp,ghp;\nvec3 tip,fid;\n\nfloat circle(vec2 pt, float r, vec2 center, float lw) {\n    float len = length(pt - center);\n    float hlw = lw / 3.;\n    float edge = .006;\n    return S(r-hlw-edge,r-hlw, len)-S(r+hlw,r+hlw+edge, len);\n}\n\nvec3 getColor(float m, vec3 p, vec3 n) {\n    vec3 h = vec3(.6); \n    \n    if(m==2.) {\n        float hs = hash21(vec2(tip.x+22.75));\n        float xt = floor(2.+(4.23*hs))*3.;\n        xt +=4.;\n        // strip patterns..\n        thp/=2./SCALE;\n        float dir = mod(tip.z + tip.y,3.) * 3. - 2.;  \n\n        vec2 cUv = thp.xy-sign(thp.x+thp.y+.002)*.6;\n        float angle = atan(cUv.x, cUv.y);\n        float a = sin( dir * angle * xt + T * 2.25);\n        a = abs(a)-.6;a = abs(a)-.44;\n        vec3 nz = hue((p.x+(T*.733))*.085);\n        h = mix(nz, vec3(1), smoothstep(.02, .03, a));   \n    }\n    \n    if(m==3.) {    \n        float hs = hash21(vec2(fid.z-22.75));\n        float xt = floor(3.-(4.73*hs))*3.;\n        xt +=8.;\n        \n        ghp/=2./SCALE;\n        \n        //TRUCHET PATTERN\n        ghp.xy *= 30.;\n        vec3 nz = hue((p.x+(3.+T*.93))*.075);\n        vec2 id = floor(ghp.xy);\n        vec2 rg = fract(ghp.xy)-.6;\n        if(hash21(id) <.6) rg.x *= -2.;\n        vec2 dUv = rg.xy-sign(rg.x+rg.y+.002)*.6;\n        float d = length(dUv);\n        float pix = 2.312;\n        float mask = smoothstep(pix, -pix, abs(d-.6)-.25);\n \n        h *= S(.6,.63,mask);\n       \n    }\n    \n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    trs = r2(PI*5.5);\n    t90 = r2(100.*PI/280.);\n    // Normalized coordinates (from -1 to 1)\n    vec2 uv = (3.*F.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    vec3 C = vec3(1.);\n    vec3 tC= vec3(1.);\n    vec3 FC = vec3(.06);\n    vec3 lp = vec3(1.,1.,1.),\n         ro = vec3(.1,1.,4.70);\n         getMouse(ro);\n\n    vec3 rd = camera(lp,ro,uv);\n    vec2 t = marcher(ro,rd, 292);\n    // save all globals\n    thp = shp;\n    ghp = fhp;\n    tip = sip;\n    fid = bip;\n    if(t.x<MAX_DIST){\n        vec3 p = ro + rd * t.x;\n        vec3 n = getNormal(p,t.x);\n        vec3 lpos = vec3(.1,.002,4.85);\n        vec3 lp = normalize(lpos-p);\n        vec3 ll = normalize(lpos);\n        float shadow = softshadow(p + n * MIN_DIST, lp, .2, 42., 42.);     \n        float diff = clamp(dot(n,lp),.1, 2.);\n        vec3 spec = getSpec(p,n,ll,ro);\n        vec3 h = getColor(t.y, p, n);\n\n        C += (h * diff * shadow + spec);\n\n        // reflection\n        // if material && hue black \n        if(h.x<.002 &&h.y<.002 &&h.z<.002 || t.y == 4.){\n            vec3 rr=reflect(rd,n); \n            vec2 tr = marcher(p ,rr, 228);\n            thp = shp;\n            ghp = fhp;\n            tip = sip;\n            fid = bip;\n            if(tr.x<MAX_DIST){\n                p += rr*tr.x;\n                n = getNormal(p,tr.x);\n                lp = normalize(lpos-p);\n                diff = diff = clamp(dot(n,lp),.02 , 2.);\n                h = getColor(tr.y, p, n);\n                tC = (h * diff * shadow);\n                tC = mix( tC, FC, 2.-exp(-.04*tr.x*tr.x*tr.x));\n            }\n        } \n        \n    } \n    C+= (tC*.55);//fade back reflections.. so bright..\n    C = mix( C, FC, 1.-exp(-.05*t.x*t.x*t.x));\n    // Output to screen\n    O = vec4(C,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 392, 413, 413, 477], [479, 479, 510, 510, 685], [703, 703, 745, 745, 864], [1014, 1014, 1032, 1032, 2753], [2755, 2755, 2801, 2801, 3041], [3043, 3072, 3104, 3104, 3374], [3377, 3405, 3475, 3475, 3679], [3681, 3681, 3728, 3728, 3947], [3949, 3949, 3989, 3989, 4218], [4249, 4249, 4304, 4304, 4453], [4455, 4455, 4495, 4495, 5656], [5658, 5658, 5699, 5713, 7454]], "test": "untested"}
{"id": "wlcyWM", "name": "Cell tissue", "author": "andrinr", "description": "Growth, wait a minute for the full experience", "tags": ["growth"], "likes": 2, "viewed": 267, "published": 3, "date": "1609246470", "time_retrieved": "2024-07-30T20:27:51.151337", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 buffer = texture(iChannel0,uv).xyz;\n    fragColor = vec4(vec3(buffer.z),1.);\n    //fragColor = vec4(buffer,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lichen\n\n\n// Andrin Rehmann\n// 2020\n// andrinrehmann.ch\n// andrinrehmann@gmail.com\n\n#define EXPANSION 7.5\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat rand( vec2 uv )\n{\n\tfloat t = fract( iTime );\n\treturn nrand( uv + 0.07*t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    \n    // Cell\n\tfloat y = texture(iChannel0,uv).x;\n    // food\n    float f = texture(iChannel0,uv).z;\n    \n    // sum of surrounding y's\n    float s = 1./16. * texture(iChannel0,uv + vec2(-du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(-du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(-du,dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,-dv)).x + \n              3./16.  * texture(iChannel0,uv + vec2(0,dv)).x +\n              1./16. * texture(iChannel0,uv + vec2(du,-dv)).x +\n              3./16.  * texture(iChannel0,uv + vec2(du,0)).x + \n              1./16. * texture(iChannel0,uv + vec2(du,dv)).x;\n\n    \n    // Diffusion\n    y = y + iTimeDelta * EXPANSION * (-y + s);\n    \n    // Food increases constantly\n    f += 0.01;\n    \n    // Food is eaten by cell\n    if (y > 0.1){\n       f -= 0.02;\n    }\n    \n    // Cell dies when not enough food\n    if (f < 0.1){\n        y -= 0.02;\n    }\n    // Cell grwos if enough food\n    else if (f > 0.9){\n        y += 0.01;\n    }\n    \n    if (distance(iMouse.xy, fragCoord) < 15. && iMouse.z > 0.){\n        f = 1.;\n    }\n    \n    // Init\n    if (iFrame < 1){\n        y = rand(uv);\n        f = rand(uv+vec2(0.2));\n    }\n    \n    fragColor = vec4(y, 0, f, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcyWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 270]], "test": "untested"}
{"id": "3tcyD7", "name": "Cyclic Noise Explanation", "author": "jeyko", "description": "This is a modification and explanation of Cyclic Noise, which is created by nimitz.", "tags": ["noise", "warp", "cyclic", "cyclicnoise"], "likes": 42, "viewed": 1310, "published": 3, "date": "1609236162", "time_retrieved": "2024-07-30T20:27:51.885375", "image_code": "// Cyclic noise is created by nimitz.\n// He uses it a lot, like in here: https://www.shadertoy.com/view/wl3czN\n// I just rewrote his code, renamed some variables and tried to explain it a bit.\n\n// Left is vanilla \n// Right is the derivative, fed into a pallete\n\n// The basic structure of the loop is like an fbm.\n// You are stacking octaves of noise.\n// But the noise itself is generated in an interesting way:\n// You do something like a 1-tap dot prodcut (Perlin,Simplex) noise inside of a sinewave lattice.\n// Then you apply some rotation and scale, and repeat. \n\n\n// Turbulent noise is \n// 1.-abs(noise)\n//#define TURBULENT\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.5;\n    const int octaves = 8;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.2 ;\n    const float warpTrkGain = 1.5;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n        \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    \n    #ifdef TURBULENT\n    return 1. - abs(noise)*0.5;\n    #else\n    return (noise*0.25 + 0.5);\n    #endif\n}\n\n\nfloat get(vec2 uv){\n    float noise = cyclicNoise(vec3(uv*10.,iTime));\n    float noiseb = cyclicNoise(vec3(uv*10. - 3.,iTime) - noise*1.);\n\n    return noiseb*pow(max(noise,0.),1.) - (1.-  noise)* (abs(noise)*.4 );\n}\n\n// Bruteforce derivative. \n// You could calculate this analyticall inside of cyclicNoise() \n// if you wished to do so, and it would be much cheaper \nvec2 derivative(vec2 uv, float eps){\n    vec2 t = vec2(eps,0);\n    return vec2(\n        get(uv + t.xy) - get(uv - t.xy),\n        get(uv + t.yx) - get(uv - t.yx)\n        );\n}\n\n// iq pallete: https://iquilezles.org/articles/palettes\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0);\n    \n    if(fragCoord.x > iResolution.x/2.){\n        float noise = get(uv);\n        vec2 dxdy = derivative(uv,0.003).xy;\n        col += pal(0.5,0.5,vec3(1,2,4),1.,dxdy.x*19. + iTime )*pow(max(noise,0.),0.9);\n    \n    } else {\n        float noise = cyclicNoise(vec3(uv*10.,iTime));\n        col += pal(0.5,0.5,vec3(1,2,4),1.,noise + iTime )*pow(max(noise,0.),0.9);\n    \n    }\n    \n    // gamma correction\n    col = pow(max(col,0.),vec3(0.4545));\n    //col = pow(abs(col),vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[628, 628, 668, 668, 853], [855, 855, 881, 881, 2158], [2161, 2161, 2180, 2180, 2376], [2378, 2527, 2563, 2563, 2700], [2813, 2813, 2870, 2870, 3455]], "test": "untested"}
{"id": "wlccDH", "name": "SkyT ", "author": "abhinavneelam", "description": "Simple sky shader. Unrealistic stars tho...", "tags": ["sky", "galaxy"], "likes": 1, "viewed": 368, "published": 3, "date": "1609220046", "time_retrieved": "2024-07-30T20:27:52.632378", "image_code": "#define pi 3.1415926535897932384626433832795\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat texZ(vec2 p){\n    return texture(iChannel0, p).x;\n}\n\nfloat func(float x)\n{\n    int fx = int(floor(x));\n    int cx = int(ceil(x));\n\n    int a = (fx % 2 == 1) ? -1 : 1;\n    int b = (fx % 2 == 1) ? cx : fx;\n    \n    float fc = float(a) * (x - float(b));\n    \n    return fc;\n    \n    float p = sin(x);\n\n    return 0.5 * p + 0.5;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    vec2 p = uv;\n    \n    p *= iResolution.xy / iResolution.x;\n    \n    float x = texZ(uv);\n    \n    int SS=800;\n    vec3 wa = vec3(236, 186, 24)/255.0;\n    for(int i=1;i<=SS;++i)\n    {\n        float bx = -0.15 + 1.3 * texZ(vec2(float(i) / float(SS), 0.7));\n        float by = -0.3+1.3 * texZ(vec2(1.0-float(i) / float(SS), 0.2));\n        float rr = texZ(vec2(1.0-float(i) / float(SS), 0.8));\n        \n        float pr = texZ(vec2(rr));\n     \n        float d = distance(vec2(bx,by), vec2(p));\n        \n        float r = cubicPulse(1.0, 1.0, 6.5 * 0.012 * rr);\n        \n        float ag = 2.0 * atan(p.y-by, p.x-bx) + pi;\n        \n        bool a = d < 1.9*r*func(4.3*ag) || d < r ;\n        bool ff = d < r || d < 0.5*r;\n        \n        float ex = 0.9 * exp(1.0 - rr);\n        \n        vec3 bwmix = mix(vec3(0.0), vec3(1.2*(0.9 - rr)), 1.1*pr);\n        \n        //0 to 0.15\n        vec3 c = mix(vec3(1.0),bwmix + vec3(rr * 0.8-0.1,0.2 , 0.9), 0.8 * ex * smoothstep(0.0, r, d));\n        c=mix(c, wa, uv.x * uv.y);\n        col += vec3(a) * c;\n    }\n    \n    float rv = texZ(vec2(uv)); \n    \n    float n = noise(2.9 * uv) + 0.5;\n    \n    float rgst = smoothstep(0.0, 1.0, uv.x)+0.2;\n    float bst = smoothstep(0.0, 1.0,1.0- uv.y)-0.4;\n    \n    vec3 cab = vec3(0.9 * n - uv.x * rgst, uv.x * n * 0.9, 1.0 - n + bst);\n\n    col += 0.9 * vec3(1.0 * n) * cab;\n    \n    float xx = 0.5;\n    \n    bool c = col.x < x && col.y < xx && col.z < xx;\n    \n    col = rv < 0.09 && c ? smoothstep(0.0,0.09,rv) * vec3(246, 241, 48) / 255.0 : col;\n    \n    float di = distance(vec2(p),vec2(0.5,0.3));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 68, 68, 207], [209, 209, 231, 231, 635], [637, 637, 656, 656, 694], [696, 696, 717, 717, 969], [971, 971, 1018, 1018, 1112], [1114, 1114, 1171, 1171, 2853]], "test": "untested"}
{"id": "tl3yD7", "name": "Volumetric Nebula", "author": "Zi7ar21", "description": "Working on this big-time to make it fast", "tags": ["volumetric", "nebula", "volumetrics", "spectral"], "likes": 2, "viewed": 459, "published": 3, "date": "1609219012", "time_retrieved": "2024-07-30T20:27:53.402319", "image_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// Common is for Settings and Global Functions\n// Buffer A is for Rendering\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Spectral Volumetric Nebula --- December 28th, 2020\n// Updated December 31st, 2020 00:15 Mountain Time\n\n// Made with the help of The Marble Marcher Community Edition Discord\n// https://discord.gg/r3XrJxH\n// https://github.com/WAUthethird/Marble-Marcher-Community-Edition\n\n// ##### LICENSE #####\n// I Deem You Allowed to Use My Code, even Commercially, and also Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms.\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/tl3yD7\n// Fork of \"Fluffy Cloud\" by Zi7ar21.\n// https://www.shadertoy.com/view/WlcyDn\n// December 27th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// ##### EPIC PEOPLE #####\n// Michael Moroz's Improvements\n// Fork of \"Nebula++\" by Michael0884. https://www.shadertoy.com/view/wtdcRS --- December 31st, 2020\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- August 8th, 2020\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- October 11th, 2020 / December 28th, 2020\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Rendering\n\n// Oof ugly mess below watch out lol\n\n// ##### NOISE #####\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.0;\n\nvoid cyclicOctave(inout vec3 p, inout float rz, inout float z, inout float trk, inout float dspAmp){\n    p += sin(p.yzx*0.25*trk-trk*6.0+cos(p*0.1+0.5))*dspAmp;\n    float ofst = 4.5;\n    vec3 s = sin(p*1.25);\n    rz += smoothstep(-1.1, 0.5, dot(s, cos(p.yzx+s.xyz+ofst)))*z;\n    dspAmp *= 0.6;\n    z *= 0.6;\n    trk *= 1.5;\n    p *= m3;\n}\n\nfloat cyclic3D(vec3 p){\n    vec3 bp = p;\n    float rz = 0.0;\n    vec3 drv = vec3(0.0);  \n    float z = 1.4;\n    float trk= 1.0;\n    float dspAmp = 1.0;\n    for (int i = 0; i<=NUM_OCTAVES; i++){cyclicOctave(p, rz, z, trk, dspAmp);}\n    rz -= 1.25;\n    return rz;\n}\n//blue in screen, white in time\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float density = max(0.0, cyclic3D(raypos)-(distance(raypos, vec3(0.0))*2.0));\n    //vec3 rgb = vec3(clamp(-distance(raypos, vec3(0.0))+1.0, 0.0, 1.0)); // Debug Density Function\n    return density*vec3(0.239, 0.569, 1.000);\n}\n\n// ##### RAYMARCHING #####\nvec3 directLight(vec3 raypos, float dither){\n    vec3 LightColor = vec3(1.0);\n    #ifdef realtime\n    vec3 LightDirection = normalize(vec3(1.0, -0.5, 1.0));\n    #endif\n    #ifndef realtime\n    vec3 LightDirection = normalize(vec3(1.0, -0.5, 1.0)+((rand4().yzw-0.5)*1.5));\n    #endif\n    float distorigin = 0.0;\n    vec3 density = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    raypos += (LightDirection*(dither-0.5)*STEP_SIZE);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+(LightDirection*STEP_SIZE);\n        density = nebulanoise(raypos)*DENSITY;\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        attenuation *= absorbance;}\n    return LightColor*attenuation;\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    #ifdef realtime\n    float dither = rand4blue().x;\n    vec3 raypos = camerapos+(raydir*((dither-0.5)*2.0)*STEP_SIZE);\n    #endif\n    #ifndef realtime\n    float dither = rand();\n    vec3 raypos = camerapos+(raydir*((rand()-0.5)*2.0)*STEP_SIZE);\n    #endif\n    vec3 outCol = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+(raydir*STEP_SIZE);\n        vec3 density = nebulanoise(raypos)*DENSITY;\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        vec3 transmittance = 1.0-absorbance;\n        vec3 directlighting = attenuation*transmittance;\n        if((density.r+density.g+density.b) > 0.0){\n            directlighting = directlighting*directLight(raypos, dither);\n        }\n        outCol += directlighting;\n        attenuation *= absorbance;\n        distorigin = distance(raypos, camerapos);\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return outCol;\n}\n\n// ##### RENDERING #####\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    #ifndef realtime\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB: I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))+int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n    // Start RNG\n    INIT_RNG;\n    #endif\n    #ifdef realtime\n    // Start Blue Noise RNG\n    rng_initialize(fragCoord, 0);\n    #endif\n    // Camera Orientation\n    #ifdef ROTATION_MATRIX\n        vec3 camerapos = vec3(2.0, -2.0, 2.0);\n\t    // Dumb rotation matrix hecking Michael made me make\n\t    float xrot = atan(sqrt(2.0));\n\t    float yrot = pi;\n\t    float zrot = -pi/4.0;\n\t    // Camera Orientation (Cursed)\n        mat3 dir;\n\t    dir[0] = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\t    dir[1] = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\t    dir[2] = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 camerapos = vec3(0.0, -2.0, 0.0);\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,0.0,1.0);\n        vec3 zdir = vec3(0.0,1.0,0.0);\n    #endif\n    #ifdef realtime\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    #endif\n    #ifndef realtime\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 fragCoordDithered = fragCoord+(rand2()-0.5);\n    vec2 uv = (fragCoordDithered-0.5*iResolution.xy)/iResolution.x;\n    #endif\n    #ifdef ROTATION_MATRIX\n    \tvec3 raydir = normalize(FOV*(uv.x*dir[0]+uv.y*dir[1])+dir[2]);\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n    #endif\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n    \n    // Output\n    fragColor += vec4(raymarched, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Exporting a 32-Bit Floating Point OpenEXR Image using the Button on the Bottom of the Editor\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb/texel.a);\n    \n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Settings and Global Functions\n\n// ##### COMMON VALUES #####\n// Change these Parameters to Your Liking!\n\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 8\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 4.0\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.35\n\n// Camera's FOV\n#define FOV 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n//#define ROTATION_MATRIX\n\n// Density of the volume. Changes how much light it absorbs.\n#define DENSITY 32.0\n\n// fBm Noise Octaves, more is more detailed with exponentially deminishing return.\n#define NUM_OCTAVES 16\n\n// Tiles, more means easier on the Hardware\n#define TILES 4 // Set to 1 if you have a computer that can handle it so it will render faster\n// So kindly made by LoicVDB uwu\n\n// Realtime\n#define realtime\n\n// Yummy, Pi! 32-Bit Floating Point Precision limits us to 3.14159265, but hey one day Shadertoy\n// may support double precision so why not throw in 3589793.\n#define pi 3.141592653589793\n\n/* High-Quality Noises from Michael Moroz \nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\n// https://www.pcg-random.org/\nvoid pcg(){\n    uint state = ns * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    ns = (word >> 22u) ^ word;\n}\n\nfloat rand(){\n    pcg(); return float(ns)/float(0xffffffffu);\n}\n\nvec2 rand2(){\n    return vec2(rand(), rand());\n}\n\nvec3 rand3(){\n    return vec3(rand(), rand(), rand());\n}\n\nvec4 rand4(){\n    return vec4(rand(), rand(), rand(), rand());    \n}*/\n\n#ifdef realtime\n// Blue Noise for Real-Time dithering (Renders must be viewed 1:1 scale!)\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n}\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1);\n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n#endif", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1517, 1517, 1571, 1621, 1728]], "test": "untested"}
{"id": "tt3cW7", "name": "ciudad loca", "author": "jorge2017a1", "description": "ciudad loca", "tags": ["ciudadloca"], "likes": 2, "viewed": 263, "published": 3, "date": "1609211832", "time_retrieved": "2024-07-30T20:27:54.161290", "image_code": "//por jorge2017a1\n\nvec2 mouse;\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{ if (d1.x<d2.x) return d1;   else return d2; }\n\nvec2 opS2( vec2 d1, vec2 d2 )\n{ if  (-d1.x<d2.x) return d1;  else  return d2;}\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{ if (d1.x>d2.x) return d1; else return d2;}\n\nvec2 opS(vec2 d1, vec2 d2) \n{ return vec2(max(-d2.x, d1.x), 2.0); }\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{    vec2 q = mod(p+0.5*c,c)-0.5*c; return  q; }\n\nfloat sdCirc(vec2 p, float r)\n{  return length(p)-r; }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\n\nvec2 simpleVehiculo(vec2 p)\n{\n    float sb1= sdBox(p-vec2(0.0,-0.25), vec2(0.06,0.04) );\n    float sLlantaIzq= sdBox(p-vec2(-0.08,-0.25), vec2(0.01,0.05) );\n    float sLlantaDer= sdBox(p-vec2( 0.08,-0.25), vec2(0.01,0.05) );\n    float sdVentanaA= sdHexagon( p-vec2(0.0,-0.2), 0.05 );\n    float sdVentanaB= sdHexagon( p-vec2(0.0,-0.2), 0.06 );\n    vec2 resp=vec2(9999.9,-1.0);\n    sdVentanaA=opS(sdVentanaA,sdVentanaB);\n    sdVentanaB=opS(sb1,sdVentanaB);\n    resp=opU2(resp, vec2(sdVentanaB,4.0));\n    resp=opU2(resp, vec2(sdVentanaA,1.0));\n    resp=opU2(resp, vec2(sb1,3.0));\n    resp=opU2(resp, vec2(sLlantaIzq,8.0));\n    resp=opU2(resp, vec2(sLlantaDer,8.0));\n    return resp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmouse=vec2(0.5,0.0);\n\tvec2 pos = ( fragCoord.xy / iResolution.xy ) - vec2(0.5,0.5);\t\n    float horizon = 0.01;   //0.2\n    float fov = 0.5; \n\tfloat scaling = 0.1;\n\t\n\tvec3 p = vec3(pos.x, fov, pos.y - horizon);      \n\tvec2 s = vec2(p.x/p.z, p.y/p.z) * scaling;\n    vec2 sE1=simpleVehiculo(pos-vec2(0.25*sin(iTime),0.0) );\n    vec2 sE2=simpleVehiculo(pos*0.5-vec2(0.25*sin(0.5+iTime*0.45),0.0) );\n    vec2 sE3=simpleVehiculo(pos*2.0-vec2(0.35*sin(iTime*0.5),0.2) );\n    \n    vec3 col;\n    float color;\n\t//checkboard texture\n    if (s.y<0.0)\n    { \n        float posy=iTime*0.125;\n         color = sign((mod(s.x, 0.1) - 0.05) * (mod(s.y-posy, 0.1) - 0.05));\t\n         //fading\n        color *= p.z*p.z*100.0;\n        col=vec3(color);\n     }\n    else\n        col=vec3(0.4,0.0,1.0)*fract( dot( vec2(p.x+0.35,p.y+0.55),vec2(0.6,0.35) )  );\n    \n    col= DibujoConBordeVec2(s, sE1, col);\n    col= DibujoConBordeVec2(s, sE2, col);\n    col= DibujoConBordeVec2(s, sE3, col);\n    fragColor = vec4( col, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{ vec3 color; };\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.  //37 //marron o cafe\n\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\nvec3 getColorf(float ii)\n{\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 DibujoConBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nvec3 DibujoSinBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    //colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    colOut = mix(colOut, colIn, uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 rotate2d(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);  float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 DibujoConBordeVec2(vec2 uv, vec2 vdist,   vec3 colOut)\n{   \n    vec3 colIn=getColorf(vdist.y); //color\n    float dist=vdist.x; //distancia\n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\n\n\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}", "sound_code": "vec2 mainSound( int samp, float time )\n{\n    \n    float x=time*440.0;\n    float fx=mod(x,2.0) +mod(1.0-x,2.0);\n    \n    float tt=mod( x,2.0);\n    return vec2( sin(fx*time)* exp(-3.0*tt) )*0.250;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3cW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 207, 207, 229], [230, 230, 263, 263, 285], [286, 286, 319, 319, 340], [343, 343, 375, 375, 421], [423, 423, 454, 454, 501], [503, 503, 535, 535, 578], [580, 580, 609, 609, 647], [649, 649, 687, 687, 734], [736, 736, 767, 767, 790], [793, 793, 830, 830, 903], [906, 906, 935, 935, 1587], [1589, 1589, 1646, 1646, 2648]], "test": "untested"}
{"id": "wt3cW7", "name": "Fractal graffiti", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/tsVcDz]\"Strange fractal kaleidoscope.\"[/url]", "tags": ["fractal"], "likes": 5, "viewed": 317, "published": 3, "date": "1609211781", "time_retrieved": "2024-07-30T20:27:54.911285", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y/20.0;\n        uv += iTime/10.0;\n        t = iTime+float(c)/10.;\n        float scale = 5.0;\n        float scale1 = 1.4;\n        for(int i=0;i<20;i++)\n        {\n            \n            uv=sin(uv-(uv.yx)/scale)*scale/2.0+scale1*scale;\n            uv /= scale1;\n        \t//uv += cos(uv/100.0);\n        \tuv=uv+col.xy;\n        }\n     col[c] = fract((uv.x)/(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "sound_code": "vec2 sound1(int t)\n{\n    //t = t|t/2/4096;\n    //t = (t>>(t/(2+(t/4096)%3+(t/4096)%2)))|t>>4&t>>5|t>>6|t/2/4096;\n    \n    t = (t>>(t/(2+(t/4096)%3+(t/4096)%2)))|t/2/4096|t/3/4096;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 590]], "test": "untested"}
{"id": "WtcyDM", "name": "Day 376", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 12, "viewed": 397, "published": 3, "date": "1609194054", "time_retrieved": "2024-07-30T20:27:55.664271", "image_code": "\n// cyclic noise learned from nimitz\n// it is literally invented by nimitz\n\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\nvec3 glow = vec3(0);\nvec3 ro;\n\n\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\nvec2 map(vec3 po){\n    vec2 d = vec2(10e5);\n    \n    vec4 p = vec4(po,1.);\n    \n    p.xz -= 2.;\n    \n    p = abs(p);\n    p.xz -= 2.;\n    \n    p.y = pmod(p.y,5.);\n    for(int i = 0; i <6; i++){\n    \n    \n        p.xyz = pmod(p.xyz,vec3(5,4,5));\n    \n        \n        p = abs(p);\n        \n        if(p.x - p.y < 0.) p.xy = p.yx;\n        if(p.x - p.z < 0.) p.xz = p.zx;\n        if(p.z - p.y < 0.) p.zy = p.yz;\n        \n    \n        \n        if(i == 5 || i == 3){\n            p.y -= .6 + sin(iTime*0.4)*1.4;\n            float dpp = dot(p.xyz,p.xyz);\n            dpp = clamp(dpp,0.,0.2 + sin(iTime)*0.05);\n            p = p/dpp;\n        }\n        \n    \n        p.xy *= rot(-0.25*pi);\n        p.xy -= 0.5;\n        p *= 1.4 + sin(iTime*0.5)*0.3;\n        \n        float ld = max(p.z,p.x)/p.w - 0.002;\n        \n        d.x = xor(-d.x, ld,0.4);\n    \n    }\n    \n    p.xyz /= p.w;\n    \n    \n    \n    p = abs(p);\n    \n    glow += exp(-d.x*40.);\n    \n    d.x *= 0.7;\n        \n    d.x = max(d.x,-length(po.xz) + 0.4);\n    d.x = mix(d.x,0.1,smoothstep(0.2,0.,length(po-ro)));\n    return d;\n}\n\n\nmat3 getOrthogonalBasis(vec3 lookAt){\n    vec3 dir = normalize(lookAt);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    vec3 seed = vec3(-4. ,-2.,0.5);\n    \n    float amp = 1.;\n    float gain = 0.6;\n    float lacunarity = 1.4;\n    int octaves = 5;\n    \n    \n    float warp = 0.3+ sin(iTime)*0.;    \n    float warpTrk = 1.2 ;\n    float warpTrkGain = 1.5;\n    \n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        // Some domain warping. Similar to fbm.\n        p += sin(p.zxy*warpTrk*0.2 - 2.*warpTrk)*warp; \n        // Calculate some noise value. \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        //noise += abs(sin(dot(cos(p), sin(p.zxy ))))*amp;\n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    return noise*0.5;\n}\n\n\nfloat mapCloud(vec3 p){\n    \n    vec3 op = p;\n    float d = length(p.xz);\n    p *= 12.;\n    \n    p.y -= iTime*4.;\n    \n    float n = cyclicNoise(p)*0.4;\n\n    d -= sin(length(op.y)*4. + iTime*2.)*0.04;\n    d -= 0.4 +  n*0.3;\n    d = smoothstep(0.05,0.,d)*3.;\n    return d;\n}\n\n\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + right*uv.x + up*uv.y);\n}\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(map(p).x - vec3(\n        map(p - t.xyy).x,\n        map(p - t.yxy).x,\n        map(p - t.yyx).x\n    ));\n}\n\nfloat sdBox(vec2 p){\n    p = abs(p); return max(p.y,p.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    float db = 10e5;\n    vec2 buv = uv;\n    /*\n    for(int i = 0; i < 5; i++){\n        float bx = abs(sdBox(buv) - 0.4) - .54;\n        \n        buv = pmod(buv, 1.4);\n        buv = abs(buv);\n        if(buv.x + buv.y < 0.) buv.xy = buv.yx;\n        if(buv.x - buv.y < 0.) buv.xy = buv.yx;\n        buv.x -= 0.04 + sin(iTime)*.4;\n        buv *= rot(0.25*pi );\n        \n        db = xor(db,bx,0.4);\n    \n    }\n    \n    db -= 0.2;\n    if (db < 0.){\n        uv = uv.yx;\n    } \n    \n    */\n    buv = uv + 1000.;\n    vec3 col = vec3(0);\n    ro = vec3(0);\n    ro.xz += vec2(sin(iTime*0.5),cos(iTime));\n    \n    ro = normalize(ro)*( 0.75 + length(vec2(sin(iTime*0.6),cos(iTime*0.4))*0.5));\n    ro.y += iTime*0.2;\n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.y = ro.y;\n    \n    lookAt.y += length(vec2(sin(iTime*0.6),cos(iTime*0.4))*0.5)*2. - 1.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 sunDir = normalize(vec3(1));\n    \n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d;\n    float marchi = 0.;\n    for(; marchi < 90.; marchi++){\n        d = map(p);\n        \n        if(d.x < 0.001){\n            hit = true;\n            break;\n        }\n        p = ro + rd*(t += d.x);\n    }\n    \n    vec3 hitC = vec3(0);\n    \n    if(hit){\n        vec3 n = getNormal(p);\n        vec3 albedo = n + 0.5;\n        \n        #define ao(a) smoothstep(0.,1.,map(p + (n + sunDir*0.4)*a).x/a)\n        \n        hitC += albedo*0.;\n        \n        float diff = max(dot(n,sunDir),0.);\n        \n        float aof = ao(0.01)*ao(0.1)*ao(0.07)*2. + 0.1;\n        hitC = mix(max(vec3(0.9,0.2,0.)*2. - sin(iTime*0.2) - 1.4,0.),hitC,diff);\n        \n        //hitC = mix(vec3(0.9,0.2,0.5)*0.9,hitC,diff);\n        hitC = mix(vec3(0.1,0.2,0.5)*0.2,hitC,aof);\n    }\n        \n        \n    \n    float volSteps = 7.;\n    float volDist = min(t, 1.6);\n    float volStSz = volDist/volSteps;\n    vec3 volP = ro;\n    vec3 volAccum = vec3(0);\n    \n    float tDens = 0.;\n    \n    \n    for(float i = 0.; i < volSteps; i++){\n        //float dens = pow(abs(sin(length(volP*25.)*1. + iTime)),12.)*1.44;\n        //float dens = smoothstep(0.1,0., length(volP) - 0.3);\n        float dens = mapCloud(volP);\n        float odens = mapCloud(volP + sunDir*0.3);\n        \n        float diff = clamp(dens - odens*0.95, 0., 1.);\n        vec3 absorption = mix(vec3(0.4,0.7,0.9),vec3(0.8,0.6,0.1)*0.2 ,clamp(tDens*.4, 0., 1.));\n        vec3 fringe = mix(vec3(1.8,0.1,0.1)*1., vec3(0.4,0.7,0.9)*0.0, pow(clamp(dens*0.8 - 1.9, 0., 1.),0.2));\n   \n        vec3 c = mix(vec3(0.1,0.1,0.4)*0.3,vec3(0.6,0.3,0.2)*1.,diff);\n        \n        c *= absorption;\n        \n        dens = dens*(1. - tDens)*volStSz;\n        \n        volAccum += c*dens*1.5 + fringe*dens;\n        \n        \n        \n        tDens += dens;\n        \n        if(tDens > 1.){\n            break;\n        }\n        \n        volP += rd*volStSz;\n    }\n    //col += marchi*0.02*(0.5 + 0.4*sin(vec3(1.,4.8,4.8) + uv.xyx));\n    \n    col += hitC*1.;\n    \n    col = mix(col,vec3(0.04,0.01,0.1),smoothstep(0.,1.,marchi*0.01));\n    \n    //col += glow*.02*(smoothstep(1.,0.,t*0.06));\n    \n    \n    col = mix(col + volAccum*0., volAccum*1., smoothstep(0.,1.,pow(tDens*1.,  1.)) );\n    \n    col = mix(col,smoothstep(0.,1.,col*1.5),0.4);\n    \n    \n    col = 1. - col*(3. + sin(iTime));\n    \n    \n    \n    if (abs(db) < 0.4){\n        col = 1. - col; \n    } \n    \n    //col.xz *= rot(iTime);\n    \n    //vec3 rotAround = normalize(vec3(sin(iTime),cos(iTime*0.5),sin(iTime*0.4)));\n    vec3 rotAround = normalize(vec3(-1.,1.,-1));\n    \n    mat3 matRotAround = mat3(\n        rotAround.x, 0., 0.,\n        0., rotAround.y, 0.,\n        0., 0., rotAround.z\n    );\n    col += 1.;\n    col *= matRotAround;\n    \n    //col.xy *= rot(-0.4+ sin(iTime)*0.4 + (uv.y)*0.2);\n    //col.xy *= rot(sin(iTime)*0.2);\n    \n    col *= inverse(matRotAround);\n    col -= 1.;\n    \n    col *= 1. - dot(uv,uv)*0.5;\n    col = pow(abs(col), vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcyDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 280, 298, 298, 1355], [1358, 1358, 1395, 1395, 1558], [1561, 1561, 1587, 1587, 2357], [2360, 2360, 2383, 2383, 2633], [2638, 2638, 2680, 2680, 2872], [2873, 2873, 2896, 2896, 3050], [3052, 3052, 3072, 3072, 3111], [3112, 3112, 3169, 3169, 7200]], "test": "untested"}
{"id": "WtccD7", "name": "oklab colorspace testing", "author": "mattz", "description": "Implementing [url]https://bottosson.github.io/posts/oklab/[/url]. See comments at top of code for instructions/details.", "tags": ["hsv", "lab", "colorspace", "oklab"], "likes": 40, "viewed": 3508, "published": 3, "date": "1609193015", "time_retrieved": "2024-07-30T20:27:56.409279", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// Visualizing Björn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// Click and drag to set lightness (mouse x) and chroma (mouse y).\n// Hue varies linearly across the image from left to right.\n//\n// While mouse is down, plotted curves show oklab components\n// L (red), a (green), and b (blue). \n//\n// To test the inverse mapping, the plotted curves are generated\n// by mapping the (pre-clipping) linear RGB color back to oklab \n// space.\n//\n// White bars on top of the image (and black bars on the bottom of\n// the image) indicate clipping when one or more of the R, G, B \n// components are greater than 1.0 (or less than 0.0 respectively).\n//\n// The color accompanying the black/white bar shows which channels\n// are out of gamut.\n//\n// Click in the bottom left to reset the view.\n//\n// Hit the 'G' key to toggle displaying a gamut test:\n//\n//   * black pixels indicate that RGB values for some hues\n//     were clipped to 0 at the given lightness/chroma pair.\n//\n//   * white pixels indicate that RGB values for some hues\n//     were clipped to 1 at the given lightness/chroma pair\n//\n//   * gray pixels indicate that both types of clipping happened\n//\n// Hit the 'U' key to display a uniform sampling of linear sRGB \n// space, converted into oklab lightness (x position) and chroma\n// (y position) coordinates. If you mouse over a colored dot, the\n// spectrum on screen should include that exact color.\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nconst float max_chroma = 0.33;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // setup oklab color\n    float theta = 2.*3.141592653589793*uv.x;\n    \n    float L = 0.8;\n    float chroma = 0.1;\n    \n    if (max(iMouse.x, iMouse.y) > 0.05 * iResolution.y) {\n        L = iMouse.x / iResolution.x;\n        chroma = iMouse.y * max_chroma / iResolution.y;\n    }\n    \n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 lab = vec3(L, a, b);\n\n    // convert to rgb \n    vec3 rgb = linear_srgb_from_oklab(lab);\n    \n    // roundtrip back to oklab\n    vec3 hopefully_lab_again = oklab_from_linear_srgb(rgb);\n    \n    // see if we left the RGB color cube?\n    float cmin = min(rgb.x, min(rgb.y, rgb.z));\n    float cmax = max(rgb.x, max(rgb.y, rgb.z));\n    \n    // clamp into rgb color cube\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    ////////////////////////////////////////////////////////////\n    // display gamut test\n    \n    if (texelFetch(iChannel0, ivec2(71, 2), 0).x != 0.0) {\n    \n        // sweep across 32 hues for a given lightness, chroma pair\n        const float hmax = 32.;\n        \n        // find min/max in RGB space across hue sweep\n        float cmin = 1.0;\n        float cmax = 0.0;\n\n        for (float h=0.0; h<hmax; ++h) {\n\n            float theta = 2.*3.141592653589793*h/hmax;\n\n            // oklab space\n            vec3 lab = vec3(uv.x, max_chroma*uv.y*vec2(cos(theta), sin(theta)));\n\n            // get color in RGB space\n            vec3 rgb_test = linear_srgb_from_oklab(lab);\n    \n            // update min max\n            cmin = min(cmin, min(rgb_test.x, min(rgb_test.y, rgb_test.z)));\n            cmax = max(cmax, max(rgb_test.x, max(rgb_test.y, rgb_test.z)));\n\n\n        }\n        \n        // color output\n        if (cmin < 0.0) {\n            if (cmax > 1.0) {\n                rgb = vec3(0.5);\n            } else {\n                rgb = vec3(0.0);\n            }\n        } else if (cmax > 1.0) {\n            rgb = vec3(1.0);\n        }\n\n    } \n    \n\n    ////////////////////////////////////////////////////////////\n    // display bars on top/bottom for clipping\n\n    if (uv.y < 0.05 && cmin < 0.0) {\n        if (uv.y < 0.01) {\n            rgb = step(rgb, vec3(0.0));\n        } else {\n            rgb = vec3(0);\n        }\n    } else if (uv.y > 0.95 && cmax > 1.0) {\n        if (uv.y > 0.99) {\n            rgb = step(vec3(1.0), rgb);\n        } else {\n            rgb = vec3(1);\n        }\n    }\n\n    ////////////////////////////////////////////////////////////\n    // plot oklab l,a,b curves  \n\n    if (max(iMouse.z, iMouse.w) > 0.05 * iResolution.y) {\n    \n        vec3 y = iResolution.y * vec3(hopefully_lab_again.x, hopefully_lab_again.yz*0.5/max_chroma + 0.5);\n        vec3 dydx = dFdx(y);\n        \n        vec3 y_alt= iResolution.y * vec3(L, 0.5*chroma*vec2(cos(theta), sin(theta))/max_chroma + 0.5);\n        vec3 dydx_alt = dFdx(y_alt);\n        \n        if (mod(fragCoord.x, 2.0) > 0.5) {\n            y = y_alt;\n            dydx = dydx_alt;\n        }\n        \n        vec3 scl = 1.0 / sqrt(1.0 + dydx*dydx);\n        vec3 d = abs(fragCoord.y - y)*scl;\n\n        for (int i=2; i>=0; --i) {\n            vec3 color = vec3(0);\n            color[i] = 1.0;\n            rgb = mix(rgb, vec3(1), smoothstep(1.0, 0.0, d[i]-4.0));\n            rgb = mix(rgb, color, smoothstep(1.0, 0.0, d[i]-1.0));\n        }\n        \n    }\n\n    ////////////////////////////////////////////////////////////\n    // uniform sampling of RGB cube\n\n    if (texelFetch(iChannel0, ivec2(85, 2), 0).x != 0.0) {\n            \n        const float drgb = 0.5;\n        float sz = 0.02 * iResolution.y;\n    \n        for (float r=0.0; r<=1.0; r+=drgb) {\n            for (float g=0.0; g<=1.0; g+=drgb) {\n                for (float b=0.0; b<=1.0; b+=drgb) {\n                \n                    vec3 rgb_test = vec3(r, g, b);\n                    \n                    vec3 lab = oklab_from_linear_srgb(rgb_test);\n                    \n                    float l = lab.x;\n                    float c = length(lab.yz)/max_chroma;\n                    \n                    vec2 p = vec2(l, c)*iResolution.xy - fragCoord.xy;\n                    \n                    float d = length(p);\n                    \n                    \n                    rgb *= smoothstep(0.0, 1.0, d-sz*1.25);\n                    rgb = mix(rgb, rgb_test, smoothstep(1.0, 0.0, d-sz));\n                    \n                \n                }\n            }\n        }\n    \n    }\n    \n    ////////////////////////////////////////////////////////////\n    // transform to sRGB space\n\n    rgb = srgb_from_linear_srgb(rgb);\n\n    fragColor = vec4(rgb, 1.0);\n\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtccD7.jpg", "access": "api", "license": "libpng AND cc0-1.0", "functions": [[1865, 1865, 1901, 1901, 2051], [2053, 2053, 2089, 2089, 2226], [3201, 3201, 3238, 3238, 3352], [3354, 3354, 3391, 3391, 3466], [3572, 3572, 3629, 3680, 8275]], "test": "untested"}
{"id": "tt3yWM", "name": "Canyon pass (fast version)", "author": "jarble", "description": "This is a modified version of Shane's [url=https://www.shadertoy.com/view/MlG3zh]\"Canyon Pass\"[/url] shader, using an [url=https://www.shadertoy.com/view/XdycWy]\"accelerated raymarching\"[/url] technique to improve the framerate.", "tags": ["raymarching", "bump", "rock", "canyon", "frost", "moss"], "likes": 10, "viewed": 590, "published": 3, "date": "1609188360", "time_retrieved": "2024-07-30T20:27:57.337797", "image_code": "/*\n\n\tCanyon Pass\n\t-----------\n\n\tCombining some cheap distance field functions with some functional and texture-based bump \n\tmapping to carve out a rocky canyon-like passageway.\n\n\tThere's nothing overly exciting about this example. I was trying to create a reasonably\n    convincing looking rocky setting using cheap methods.\n\n\tI added in some light frosting, mainly to break the monotony of the single colored rock.\n\tThere's a mossy option below, for anyone interested. Visually speaking, I find the moss more\n\tinteresting, but I thought the frost showed the rock formations a little better. Besides,\n\tI'd like to put together a more dedicated greenery example later.\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Extra settings. Use one or the other. The MOSS setting overrides the HOT setting.\n// Mossy setting. Better, if you want more color to liven things up.\n#define MOSS \n// Hot setting. It represents 2 minutes of post processing work, so it's definitely nothing to excited about. :)\n//#define HOT\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic-picture focus-adjusting thing with your eyes.\n//#define THREE_D \n\n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    //vec3 col = mix(vec3(.7, 1, 1.3), vec3(1), n.y*.5 + .5);\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);//*col;\n}\n\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-.5;\n    return dot(p, p);\n    \n}\n\n\n// 3D cellular tile function.\nfloat cellTile(in vec3 p){\n   \n    vec4 d; \n    \n    // Plot four objects.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.12, .62, .64));\n\n\t// Obtaining the minimum distance.\n    d.xy = min(d.xz, d.yw);\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    return  min(d.x, d.y)*2.5;\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){\n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n// A fake noise looking sinusoial field - flanked by a ground plane and some walls with\n// some triangular-based perturbation mixed in. Cheap, but reasonably effective.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z); // Wrap the passage around\n    \n    vec3 w = p; // Saving the position prior to mutation.\n    \n    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*3.)); // Triangle perturbation.\n   \n    \n    float ground = p.y + 3.5 + dot(op, vec3(.222))*.3; // Ground plane, slightly perturbed.\n \n    p += (op - .25)*.3; // Adding some triangular perturbation.\n   \n\tp = cos(p*.315*1.41 + sin(p.zxy*.875*1.27)); // Applying the sinusoidal field (the rocky bit).\n    \n    float canyon = (length(p) - 1.05)*.95 - (w.x*w.x)*.01; // Spherize and add the canyon walls.\n    \n    return min(ground, canyon);\n\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    //return (cellTile(p/1.5))*.66 + (cellTile(p*2./1.5))*.34;\n    \n    return cellTile(p/1.5);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\nfloat accum;\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n\n    float t = 0.0, h;\n    for(int i = 0; i < 160; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;//*.7;\n        \n        if(abs(h)<0.25) accum += (.25-abs(h))/24.;///(1.+t);//.0005/abs(h);\n        //if(abs(h)<0.25)accum += (.25-abs(h))*vec3(3, 2, 1)/4.*n3D((ro+rd*t)*16. - vec3(0, 0, 1)*iTime*1.);\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO2( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.001, -0.001); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.0, 1.0); \n}\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected (or refracted) ray at the surface \n// hit point, then index into a repeat texture in some way. It can be pretty convincing \n// (in an abstract way) and facilitates environment mapping without the need for a cube map, \n// or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\n\nvec3 envMap(vec3 rd, vec3 n){\n    \n    return tex3D(iChannel0, rd, n);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel1, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n\t\n\t// Camera Setup.\n    vec3 camPos = vec3(0.0, 0.0, iTime*4.); // Camera position, doubling as the ray origin.\n\n\tvec3 lookAt = camPos + vec3(0, 0, 0.25);  // \"Look At\" position.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(-10, 20, -20);\n\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n    \n    \n    #ifdef THREE_D\n    camPos.x -= sg*.15; lookAt.x -= sg*.15; lightPos.x -= sg*.15;\n    #endif\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333;//PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n    /*    \n    // Mouse controls. I use them as a debugging device, but they can be used to look around. \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/\n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\t//float t = trace(camPos, rd);\n    vec4 depthmap = depth_map(fragCoord);\n    float t = length(depthmap.xyz-camPos);\n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n        //vec4 depthmap = depth_map(fragCoord);\n    \t// Surface position and surface normal.\n\t    vec3 sp = depthmap.xyz;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .5);\n        \n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, .1);//(-sign(sn.y)*.15+.85)*\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n        \n        // Shadows.\n        float shading = depthmap.w;\n        \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);//*.75 + .25;\n\n\t    \n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.007);\n    \t\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Ambient light, due to light bouncing around the the canyon.\n\t    float ambience = 0.35*ao + fre*fre*.25;\n\n        // Object texturing, coloring and shading.\n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n        // Tones down the pinkish limestone\\granite color.\n        //texCol *= mix(vec3(.7, 1, 1.3), vec3(1), snNoBump.y*.5 + .5);\n        \n        #ifdef MOSS\n        // Some quickly improvised moss.\n        texCol = texCol*mix(vec3(1), vec3(.5, 1.5, 1.5), abs(snNoBump));\n        texCol = texCol*mix(vec3(1), vec3(.6, 1, .5), pow(abs(sn.y), 4.));\n        #else\n        // Adding in the white frost. A bit on the cheap side, but it's a subtle effect.\n        // As you can see, it's improvised, but from a physical perspective, you want the frost to accumulate\n        // on the flatter surfaces, hence the \"sn.y\" factor. There's some Fresnel thrown in as well to give\n        // it a tiny bit of sparkle.\n        texCol = mix(texCol, vec3(.35, .55, 1)*(texCol*.5+.5)*vec3(2), ((snNoBump.y*.5 + sn.y*.5)*.5+.5)*pow(abs(sn.y), 4.)*texCol.r*fre*4.);\n        #endif      \n\n        \n        // Final color. Pretty simple.\n        sceneCol = texCol*(diff + spec + ambience);// + vec3(.2, .5, 1)*spec;\n        \n        // A bit of accumulated glow.\n        sceneCol += texCol*((sn.y)*.5+.5)*min(vec3(1, 1.15, 1.5)*accum, 1.);  \n     \n        \n        // Adding a touch of Fresnel for a bit of glow.\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 4.)*.5;\n        \n        \n        // Faux environmental mapping. Adds a bit more ambience.        \n        vec3 sn2 = snNoBump*.5 + sn*.5;\n        vec3 ref = reflect(rd, sn2);//\n        vec3 em = envMap(ref/2., sn2);\n        ref = refract(rd, sn2, 1./1.31);\n        vec3 em2 = envMap(ref/8., sn2);\n        //sceneCol += ((sn.y)*.25+.75)*sceneCol*(em + em2);\n        sceneCol += sceneCol*2.*(sn.y*.25+.75)*mix(em2, em, pow(fre, 4.));\n\n\n\t    // Shading. Adding some ambient occlusion to the shadow for some fake global lighting.\n        sceneCol *= atten*min(shading + ao*.35, 1.)*ao;\n\t   \n\t\n\t}\n    \n       \n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fog = vec3(.6, .8, 1.2)*(rd.y*.5 + .5);\n    #ifdef MOSS\n    fog *= vec3(1, 1.25, 1.5);\n    #else\n    #ifdef HOT\n    fog *= 4.;\n    #endif\n    #endif\n    sceneCol = mix(sceneCol, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n    \n    \n    //sceneCol *= vec3(.5, .75, 1.5); // Nighttime vibe.\n    #ifndef MOSS\n    #ifdef HOT\n    float gr = dot(sceneCol, vec3(.299, .587, .114)); // Grayscale.\n    // A tiny portion of the original color blended with a very basic fire palette.\n    sceneCol = sceneCol*.1 + pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16));\n    // Alternative artsy look. Comment out the line above first.\n    //sceneCol = mix(sceneCol, pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16)), -uv.y + .5);\n    #endif\n    #endif\n    \n    // Subtle, bluish vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneCol = mix(vec3(0, .1, 1), sceneCol, pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.15 + .85);\n    \n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n\tCanyon Pass\n\t-----------\n\n\tCombining some cheap distance field functions with some functional and texture-based bump \n\tmapping to carve out a rocky canyon-like passageway.\n\n\tThere's nothing overly exciting about this example. I was trying to create a reasonably\n    convincing looking rocky setting using cheap methods.\n\n\tI added in some light frosting, mainly to break the monotony of the single colored rock.\n\tThere's a mossy option below, for anyone interested. Visually speaking, I find the moss more\n\tinteresting, but I thought the frost showed the rock formations a little better. Besides,\n\tI'd like to put together a more dedicated greenery example later.\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Extra settings. Use one or the other. The MOSS setting overrides the HOT setting.\n// Mossy setting. Better, if you want more color to liven things up.\n#define MOSS \n// Hot setting. It represents 2 minutes of post processing work, so it's definitely nothing to excited about. :)\n//#define HOT\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic-picture focus-adjusting thing with your eyes.\n//#define THREE_D \n\n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    //vec3 col = mix(vec3(.7, 1, 1.3), vec3(1), n.y*.5 + .5);\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);//*col;\n}\n\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-.5;\n    return dot(p, p);\n    \n}\n\n\n// 3D cellular tile function.\nfloat cellTile(in vec3 p){\n   \n    vec4 d; \n    \n    // Plot four objects.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.12, .62, .64));\n\n\t// Obtaining the minimum distance.\n    d.xy = min(d.xz, d.yw);\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    return  min(d.x, d.y)*2.5;\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){\n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n// A fake noise looking sinusoial field - flanked by a ground plane and some walls with\n// some triangular-based perturbation mixed in. Cheap, but reasonably effective.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z); // Wrap the passage around\n    \n    vec3 w = p; // Saving the position prior to mutation.\n    \n    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*3.)); // Triangle perturbation.\n   \n    \n    float ground = p.y + 3.5 + dot(op, vec3(.222))*.3; // Ground plane, slightly perturbed.\n \n    p += (op - .25)*.3; // Adding some triangular perturbation.\n   \n\tp = cos(p*.315*1.41 + sin(p.zxy*.875*1.27)); // Applying the sinusoidal field (the rocky bit).\n    \n    float canyon = (length(p) - 1.05)*.95 - (w.x*w.x)*.01; // Spherize and add the canyon walls.\n    \n    return min(ground, canyon);\n\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    //return (cellTile(p/1.5))*.66 + (cellTile(p*2./1.5))*.34;\n    \n    return cellTile(p/1.5);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\nfloat accum;\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n\n    float t = 0.0, h;\n    for(int i = 0; i < 160; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;//*.7;\n        \n        if(abs(h)<0.25) accum += (.25-abs(h))/24.;///(1.+t);//.0005/abs(h);\n        //if(abs(h)<0.25)accum += (.25-abs(h))*vec3(3, 2, 1)/4.*n3D((ro+rd*t)*16. - vec3(0, 0, 1)*iTime*1.);\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO2( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.001, -0.001); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.0, 1.0); \n}\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected (or refracted) ray at the surface \n// hit point, then index into a repeat texture in some way. It can be pretty convincing \n// (in an abstract way) and facilitates environment mapping without the need for a cube map, \n// or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\n\nvec3 envMap(vec3 rd, vec3 n){\n    \n    return tex3D(iChannel0, rd, n);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n\t\n\t// Camera Setup.\n    vec3 camPos = vec3(0.0, 0.0, iTime*4.); // Camera position, doubling as the ray origin.\n\n\tvec3 lookAt = camPos + vec3(0, 0, 0.25);  // \"Look At\" position.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(-10, 20, -20);\n\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n    \n    \n    #ifdef THREE_D\n    camPos.x -= sg*.15; lookAt.x -= sg*.15; lightPos.x -= sg*.15;\n    #endif\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333;//PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n    /*    \n    // Mouse controls. I use them as a debugging device, but they can be used to look around. \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/\n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);   \n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .5);\n        \n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, .1);//(-sign(sn.y)*.15+.85)*\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n        \n        // Shadows.\n        float shading = shadows(sp + sn*.005, ld, .05, lDist, 8.);\n        fragColor = vec4(sp,shading);\n\t\n\t}\n    \n\t}\n}", "buffer_a_inputs": [], "common_code": "#define image_scale 4.0", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1290, 1442, 1463, 1463, 1529], [1532, 1686, 1732, 1799, 2332], [2461, 2461, 2489, 2489, 2542], [2545, 2575, 2601, 2601, 3072], [3075, 3314, 3334, 3334, 3359], [3385, 3485, 3507, 3546, 3747], [3751, 3920, 3938, 3938, 4550], [4554, 4672, 4712, 4780, 4820], [4822, 4872, 4929, 4929, 5331], [5333, 5520, 5582, 5582, 6092], [6111, 6132, 6168, 6168, 6821], [7578, 7730, 7770, 7770, 8016], [8019, 8212, 8239, 8348, 8498], [8731, 8743, 8823, 8823, 9431], [10043, 10043, 10072, 10072, 10115], [10117, 10117, 10144, 10144, 10289], [10291, 10291, 10347, 10373, 18407]], "test": "untested"}
{"id": "3lccD7", "name": "Infinite Map", "author": "oneshade", "description": "Awesome fractal noise.", "tags": ["procedural", "map", "infinite", "fractalnoise", "geography"], "likes": 6, "viewed": 147, "published": 3, "date": "1609188116", "time_retrieved": "2024-07-30T20:27:58.190517", "image_code": "// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash21(in vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nfloat SmoothNoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = Hash21(cell);\n    float br = Hash21(cell + vec2(1.0, 0.0));\n    float tl = Hash21(cell + vec2(0.0, 1.0));\n    float tr = Hash21(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat FractalNoise(in vec2 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    uv += 0.1 * iTime;\n\n    float scale = 5.0;\n    float octaves = 5.0;\n\n    float n = FractalNoise(uv, scale, octaves);\n    vec3 color = mix(vec3(0.0, 0.0, 1.0 - n), mix(vec3(0.0, 1.0, 0.0), vec3(0.8, 0.4, 0.0), n * n), smoothstep(0.5 - unit, 0.5 + unit, n));\n\n    vec2 pinPos = floor(uv * 3.0 + 0.5) / 3.0;\n    pinPos += 0.25 * Hash22(pinPos) - 0.125;\n    n = FractalNoise(pinPos, scale, octaves);\n    if (n > 0.5) {\n        float pin = length(uv - pinPos) - 0.02;\n        color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, pin));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lccD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 91, 116, 116, 234], [236, 236, 260, 260, 403], [405, 405, 435, 435, 759], [761, 761, 826, 826, 1117], [1119, 1119, 1174, 1174, 1840]], "test": "untested"}
{"id": "WlcyD7", "name": "TIE Fighters", "author": "dean_the_coder", "description": "It was a fine line between creating a scene with\nTIE Fighters or X-Wings. TIE Fighters won.\n\nScene duration: 40 secs", "tags": ["3d", "raymarching", "snow", "starwars", "disney", "movie", "cineshader"], "likes": 83, "viewed": 30158, "published": 3, "date": "1609185361", "time_retrieved": "2024-07-30T20:27:59.091109", "image_code": "// 'TIE Fighters' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/WlcyD7\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// It was a fine line between creating a scene with\n// TIE Fighters or X-Wings. TIE Fighters won.\n// I'm quite happy with the modelling in this one,\n// but definitely want to practice terrains some more.\n//\n// I've switched to using hash functions which don't\n// rely on trig functions. Hopefully that will reduce\n// differences on different platforms...\n//\n// Tricks to get the performance:\n//  - The TIE SDF code bails early if the raymarching point\n//    is 'too far away', so no time wasted calculating the SDF\n//    of all the fine details when not necessary.\n//    See sdTie()\n//  - Shadows are only cast by the TIEs (See calcShadow())\n//    so I don't have to render the entire scene too many times.\n//  - The ray is only reflected if it hits glass or metal, and then\n//    marched only if it points down. (So we don't reflect the sky.)\n//  - I have two normal-calculating functions. One for the TIEs,\n//    and one for the terrain. Once the ray has hit an object,\n//    the relevant 'normal' code is called.\n//  - The high frequency noise is added to the terrain during the\n//    color look-up phase. Only the low frequency noise is added to\n//    the SDF.\n//\n// Things I _could_ do:\n//  - Split the TIE modelling into two functions, one for just\n//    the wings and cockpit, and another which extends it to\n//    include the finer details.\n//    The 'simple' version could be used to generate the shadows.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat T, g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n// Thanks Dave Hoskins - https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * vec4(.1031, .103, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy + 33.33);\n\treturn fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nvoid minH(inout Hit a, Hit b) { if (b.d < a.d) a = b; }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.y, p.x) + angle + o, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdHex(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.866, .5, .577);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.z - h.y);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec3 n) { return dot(p, n); }\n\nfloat dot2(vec3 a) { return dot(a, a); }\n\nfloat sdTri(vec3 p, vec3 a, vec3 b, vec3 c) {\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa), dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)), dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0., 1.) - pc)) : dot(n, pa) * dot(n, pa) / dot2(n));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit sdWings(vec3 p) {\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\treturn Hit(min(sdTri(p, vec3(0), vec3(2, 3, 0), vec3(-2, 3, 0)), sdTri(p, vec3(0), vec3(3.3, 0, 0), vec3(2, 3, 0))) - .03, 2, p);\n}\n\nHit sdTie(vec3 p) {\n\tp = p.zyx - vec3(10, 0, 0);\n\n\t// Wings.\n\tHit h = sdWings(p);\n\tif (h.d > 2.5) return h; // Bail early - Point is too far away.\n\t// Wing ribs.\n\tvec3 op = p;\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\tfloat f,\n\t      d = 0.;\n\tif ((f = abs(p.y)) < .1) d = .03 + step(f, .025) * .02;\n\telse if ((f = abs(p.y - p.x * 1.5)) < .15) d = .03 + step(f, .025) * .02;\n\telse if (abs(p.y - 3.) < .1) d = .03;\n\telse if (abs(p.x - 3.3 + p.y * .43) < .1) d = .03;\n\n\tif (d > 0.) {\n\t\th.d -= d;\n\t\th.id = 1;\n\t}\n\n\t// Wing center hexes.\n\td = min(sdHex(p, vec2(.7, .06)), sdHex(p, vec2(.5, .12)));\n\n\t// Crossbar.\n\td = min(d, sdCyl(op, vec2(mix(.21, .23, step(p.y, .04)), 2.3))); // Main bar\n\tp.z = abs(p.z + .8) - .5;\n\tf = sdCyl(p, vec2(mix(.21, .33, (p.z + .33) / .48), .24));\n\tp.x -= .25;\n\tp.z += .02;\n\td = min(d, max(f, -sdBox(p, vec3(.1, .4, .08)))); // Join to wing/cockpit.\n\tp = op;\n\tp.yz = abs(p.yz);\n\tminH(h, Hit(min(d, sdTri(p, vec3(0), vec3(0, .8, 0), vec3(0, 0, 2)) - .05), 1, p)); // Triangle cockpit supports.\n\t// Cockpit - Sphere.\n\tf = step(.75, p.y);\n\tminH(h, Hit(length(op) - .9 - .02 * (f + step(p.y, .03) + f * step(p.z, .1)), 6, p));\n\n\t// Cockpit - Glass.\n\tp = op;\n\tp.x += .27;\n\tp.yz = opModPolar(p.yz, 8., .4);\n\tminH(h, Hit(max(length(p) - .7, sdPlane(p + vec3(.77, 0, 0), vec3(vec2(-1, 0) * rot(.5), 0))), 3, p));\n\n\t// Cockpit - Window frame.\n\tminH(h, Hit(max(length(p) - .71, .45 - length(p.yz)), 5, p));\n\n\t// Gunz.\n\tp = op;\n\tp.x += .7;\n\tp.y += .6;\n\tp.z = abs(p.z) - .2;\n\tminH(h, Hit(sdCyl(p.zyx, vec2(.05, .2)), 7, p));\n\treturn h;\n}\n\n// Position of the lead TIE.\nvec3 tiePos(vec3 p, float t) {\n\tfloat x = cos(t * .7);\n\tp += vec3(x, cos(t), sin(t * 1.1));\n\tp.xy *= rot(x * -.1);\n\treturn p;\n}\n\nHit sdTies(vec3 p) {\n\tvec3 op = p;\n\n\t// Front tie.\n\tp = tiePos(p, T);\n\tHit h = sdTie(p);\n\tif (sin(T) - step(T, 0.) * 10. > -.7) {\n\t\t// Weapon fire.\n\t\tp.x = abs(p.x) - .2;\n\t\tp.y += .6;\n\t\tp.z = mod(p.z + T * 50., 8.) - 4.;\n\t\tfloat x = max(sdCyl(p, vec2(.03, 1)), op.z - 8.);\n\t\tminH(h, Hit(x, 9, p));\n\t\tg += .001 / (.01 + x * x);\n\t}\n\n\t// Rear tie.\n\tif (h.d > .0015) {\n\t\tfloat x = -cos(T);\n\t\tp = op + vec3(14, -4. - .5 * cos(T * .5), -20. + 4. * sin(T * .6));\n\t\tp.xy *= rot(x * -.1);\n\t\tminH(h, sdTie(p));\n\t}\n\n\treturn h;\n}\n\nHit sdTerrain(vec3 p) {\n\tp.z -= T * 7e2; // Number controls the terrain speed.\n\tvec2 d = sin(p.xz * vec2(.01476, .01345)) * 10. + sin(p.xz * vec2(.05212, .04512)) * 2.;\n\treturn Hit(abs(p.y - d.x + d.y + 25.), 4, p);\n}\n\nHit map(vec3 p) {\n\tHit h = sdTerrain(p);\n\tminH(h, sdTies(p));\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTies(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Terrian normal.\n// (Special case, but faster than using the SDF for the entire scene.)\nvec3 calcTN(vec3 p, float t) {\n\tfloat h = t * 2.;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTerrain(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Note: For performance, shadows are only cast by tie fighters.\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1.,\n\t      t = 1.;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = sdTies(p + ld * t).d;\n\t\ts = min(s, 30. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 1e2) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Note: For performance, occlusion only applied to tie fighters.\nfloat ao(vec3 p, vec3 n, float h) { return clamp(sdTies(p + h * n).d / h, 0., 1.); }\n\n// Sub-surface scattering (Applied to the snow).\n#define SSS(h)\tclamp(sdTerrain(p + ld * h).d / h, 0., 1.)\n\n/**********************************************************************************/\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tfloat am, ldt, l, spe,\n\t      sped = 4.;\n\tvec3 c, n, lig,\n\t     ld = normalize(vec3(30, 50, -40) - p);\n\tif (h.id == 4) {\n\t\t// Snow\n\t\tc = vec3(1.2 + SSS(1.) * .44);\n\t\tn = normalize(calcTN(p, d) + n31(h.uv) * .1);\n\t\tam = mix(.3, .9, sdTerrain(p + n).d);\n\t\tsped = .4;\n\t}\n\telse {\n\t\tn = calcN(p, d);\n\t\tam = mix(ao(p, n, .5), ao(p, n, 1.2), .75);\n\t\tif (h.id == 1 || h.id == 6) {\n\t\t\t// Metal\n\t\t\tc = vec3(.3 - n31(h.uv * 18.7) * .1);\n\t\t\tsped = .5;\n\t\t\tif (h.id == 6) c *= 1. - .8 * step(abs(atan(h.uv.y, h.uv.z) - .8), .01); // Cockpit.\n\t\t}\n\t\telse if (h.id == 2) {\n\t\t\t// Black wing area.\n\t\t\tif (h.uv.x < h.uv.y * .7) h.uv.y = 0.;\n\t\t\tc = vec3(.005 + .045 * pow(abs(sin((h.uv.x - h.uv.y) * 12.)), 20.));\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 7) {\n\t\t\t// Gunz.\n\t\t\tc = vec3(.02);\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 3) c = vec3(.05); // Cockpit glass.\n\t\telse if (h.id == 5) c = vec3(.1); // Glass surround.\n\t\telse c = vec3(.3, 1, .3); // Fire!\n\t}\n\n\t// Primary light.\n\tldt = dot(ld, n);\n\tl = max(0., .2 + .8 * ldt) + max(0., .2 - .8 * ldt) * .3;\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 50.)) * sped;\n\n\t// Combine.\n\tlig = l * am * mix(.4, 1., calcShadow(p, ld)) * vec3(2, 1.8, 1.7) + clamp(n.y, .05, 1.) * vec3(.9, .95, 1); // Sky light.\n\treturn c * lig + spe;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, c;\n\tfloat gg,\n\t      d = .01;\n\tHit h;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015 || d > 6e2) break;\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tgg = g; // Cache the 'glow'.\n\tif (d > 6e2) c = vec3(.85, .9, 1);\n\telse c = mix(lights(p, rd, d, h), vec3(1), smoothstep(2e2, 540., d));\n\n\tc += gg * vec3(0, 1, 0);\n\tif (h.id == 3 || h.id == 1) {\n\t\t// Reflections applied to cockpit glass and tie metal.\n\t\trd = reflect(rd, calcN(p, d));\n\t\tfloat alpha = (h.id == 3 ? .4 : .2) * smoothstep(0., 1., -rd.y);\n\t\tif (alpha < .001) return c; // Only reflect downwards.\n\t\td = .01;\n\t\tro = p;\n\t\tfor (float i = 0.; i < 40.; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = sdTerrain(p);\n\t\t\tif (abs(h.d) < .0015 || d > 3e2) break;\n\t\t\td += h.d; // No hit, so keep marching.\n\t\t}\n\n\t\t// Combine a % of the reflected color.\n\t\tc = mix(c, d > 3e2 ? vec3(1) : lights(p, rd, d, h), alpha);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tT = mod(iTime, 40.) - 4.;\n\tg = 0.;\n\tfloat t = smoothstep(0., 5., T);\n\tvec3 lookAt = mix(vec3(0, 0, 6) - tiePos(vec3(0), T - .2), vec3(2.5, 0, 0), t),\n\t     ro = mix(lookAt - vec3(0, 0, 1), vec3(4. + cos(T), sin(T) * .2, -8. + cos(T * .2) * 6.), t);\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, lookAt, (fc - .5 * iResolution.xy) / iResolution.y)), vec3(.45)), fc), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1877, 1940, 1962, 1962, 2094], [2096, 2152, 2171, 2171, 2422], [2424, 2424, 2455, 2455, 2479], [2481, 2481, 2500, 2500, 2567], [2569, 2569, 2612, 2612, 2746], [2748, 2748, 2777, 2777, 3037], [3039, 3039, 3068, 3068, 3155], [3157, 3157, 3188, 3188, 3208], [3210, 3210, 3230, 3230, 3250], [3252, 3252, 3297, 3297, 3754], [3756, 3756, 3786, 3786, 3886], [3888, 3888, 3935, 3935, 4071], [4073, 4073, 4094, 4094, 4269], [4271, 4271, 4290, 4290, 5821], [5823, 5852, 5882, 5882, 5979], [5981, 5981, 6001, 6001, 6498], [6500, 6500, 6523, 6523, 6717], [6719, 6719, 6736, 6736, 6793], [6795, 6795, 6824, 6824, 7048], [7050, 7140, 7170, 7170, 7397], [7399, 7464, 7499, 7514, 7717], [7719, 7785, 7820, 7820, 7869], [7979, 8064, 8096, 8096, 8211], [8213, 8213, 8259, 8259, 9531], [9533, 9533, 9563, 9577, 10499], [10501, 10501, 10546, 10546, 10928]], "test": "untested"}
{"id": "WlccW7", "name": "Fake 3D effect", "author": "z0rg", "description": "A shader I did a while back for simulating 3D without any 3D calculation.", "tags": ["3d", "fake3d", "vapor"], "likes": 3, "viewed": 233, "published": 3, "date": "1609183688", "time_retrieved": "2024-07-30T20:27:59.847088", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\nfloat lenny(vec2 v){return abs(v.x)+abs(v.y);}\n\nbool inTriangle(vec2 A, vec2 B, vec2 C, vec2 P, float thick)\n{\n  vec2 v0 = C - A;\n  vec2 v1 = B - A;\n  vec2 v2 = P - A; \n  \n  // Compute dot products\n  float dot00 = dot(v0, v0);\n  float dot01 = dot(v0, v1);\n  float dot02 = dot(v0, v2);\n  float dot11 = dot(v1, v1);\n  float dot12 = dot(v1, v2);\n  \n  // Compute barycentric coordinates\n  float invDenom = 1. / (dot00 * dot11 - dot01 * dot01);\n  float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n  float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n  // Check if point is in triangle return\n  return (u >= 0.) && (v >= 0.) && (u + v < 1.) &&\n   (u<thick||v<thick||(u+v)>1.-thick);\n}\n\nvec3 drawSphLight(vec2 uv, vec3 norm)\n{\n  vec3 ldir = vec3(-5.);\n\n  return sat(-dot(normalize(norm),normalize(ldir)))*vec3(1.);\n}\n\nvec3 draw(vec2 uv)\n{\n  uv.y += sin(iTime)*.5;\n  vec3 col;\n  float gstp = 0.1;\n  float gsz = gstp/10.;\n  float limit = 1.-float(abs(uv.y)<.3);\n  col = vec3(.34,.45,.67)*limit*float(mod(sign(uv.x)*iTime+(abs(uv.x)+gsz/4.)/abs(uv.y),gstp)<gsz\n    || mod(1./abs(uv.y),gstp)<gsz);\n\n  col += (1.-sat((lenny(uv*vec2(.2,2.))-.5)*2.))*vec3(1.);\n\n  vec2 sphuv = uv+vec2(0.,sin(iTime+3.));\n  float sphSdf = (length(sphuv)-.5*1./(sin(iTime*2.)+2.5));\n  float sph = 1.-sat(sphSdf*200.);\n\n  vec2 tp = vec2(-0.,-.5);\n  float tri = float(inTriangle(.5*vec2(sin(-iTime),cos(iTime)),\n    vec2(.5,.2)*vec2(sin(iTime*.5),cos(iTime*2.)), vec2(sin(iTime),cos(iTime))*vec2(.5,.8),uv-tp,.5));\n\n    vec3 tris = tri*vec3(uv,.5);\n\n  return 2.*tris+mix(col,drawSphLight(uv, vec3(sphuv*5., 1.-sat(sphSdf))),sph);\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col = draw(uv);\n  col *= 1.5;\n  col *= (1.-sat((lenny(uv)-.8)*1.))*(vec3(uv,.5)*.5+.5);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv*= 4.;\n\n  vec3 col = rdr(uv);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlccW7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 447, 447, 508], [509, 509, 529, 529, 555], [557, 557, 619, 619, 1194], [1196, 1196, 1235, 1235, 1325], [1327, 1327, 1347, 1347, 2112], [2114, 2114, 2133, 2133, 2244], [2246, 2246, 2303, 2303, 2460]], "test": "untested"}
{"id": "ttdcD4", "name": "Rubik's ring", "author": "FabriceNeyret2", "description": "ref game: [url]https://www.pinkbunny.shop/products/leisure-brain-toys-rubiks-cube[/url]\nsort the balls !\n- up/down key to roll the balls in the current ring.\n- space to change current ring.\n( after coding this puzzl, I discover solving it is trivial :-( )", "tags": ["game", "puzzle", "short", "reproduction"], "likes": 5, "viewed": 431, "published": 3, "date": "1609177106", "time_retrieved": "2024-07-30T20:28:00.650938", "image_code": "#define S(v)       smoothstep( 15./R.y, 0., v )                    // antialiasing\n#define sR(w,h,r)  length(max( abs(U) - vec2(w,h)/2. +r , 0.)) - r // smooth rectangle\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 12.* ( u - .5*R ) / R.y, P;\n    float v, r = step(0.,U.x), m=1.,\n                                                                   // --- draw board\n    M  = S(sR(13,11.5, 2.));                                       // main body\n    \n    M -= v = S(sR(6,5, .1));                                       // central hole\n    if (v>.9) \n      U.x -= T(0).w ,\n      M  = S(sR(4,5, .1)),                                         // central body\n      m = S( .5 - abs(U.x) );                                      // central rail chunk\n    else\n      U.x = abs(U.x) - 3.,                                         // ring rails\n      m = S( .5 - abs( sR(5,10, 2.5)+.5 ) ); \n    O = m * M * texture( iChannel1, U/12.);\n    \n    for( int i=0; i < 32; i++ )  {                                 // --- draw balls\n        vec4 B = T(i);\n#define C(o,s)   2.* cos((B.z+o)/10.*6.28+vec2(0,33)) s vec2(0,2.5) \n        if ( v < .9 ?  B.y==r : B.z < 4. || B.z > 17. )            // set position\n            P = B.z <  4. ? vec2( -2, (B.z-1.5)*1.25 ) \n              : B.z <  9. ? C( 1.5, + )\n              : B.z < 13. ? vec2(  2, (10.5-B.z)*1.25 )\n              :             C(-2.5, - ),\n            v >.9 ? P.x = 0. : v,\n            O[int(B.x)] += sqrt(max( 1.-length( P - U )*1.6 , 0.)) * (1.-m); // draw sphere\n         // O[int(B.x)] += S( length( P - U ) - .5 ); // * sqrt((1.+B.z)/16.);\n    }\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(i) texelFetch(iChannel0, ivec2(i,0), 0 )", "buffer_a_code": "                                                    // autodemo before click\n#define K(a,c) ( iMouse.xy==vec2(0) ? fract(1e4*sin(1e4*(float(a)+iTime))) > (c>1?.95:.5) ? 1. : 0. \\\n                                    : texelFetch( iChannel3, ivec2(a,c), 0 ).x )\n#define keyToggle(a)   K(a,2)                       // https://www.shadertoy.com/view/llySRh\n#define keyClick(a)    K(a,0)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( U.y > 1. || U.x > 32. ) return;            // use only 32 pixels for states\n    int i = int(U.x);\n    \n    if ( iFrame < 1 ) {                             // --- init state\n        O = vec4( ( i^(i/4)^int(iTime*99.) ) & 1,   // color = 0 or 1\n                    i > 15,                         // ring = 0 or 1   ( ignored for ranks 0..3 ) \n                  ( i + (i>15?6:2) ) % 18,          // rank in ring    ( 0..3 = common central part ).\n                    1 );\n        return;\n     }\n     \n     O = T(i);                                      // previous state\n     \n     if (i==0)  O.w = abs(O.w) < 1.                 // selector: anim side ( start only if balls are not moving )\n                        ? O.w + sign(O.w)/16. \n                        : keyClick(32)>0. && T(1).w==0. \n                            ? (1.-2.*keyToggle(32))/16. : O.w;\n     if (i==1) O.w = abs(O.w) > .01                 // balls motion ( start only if selector is not moving )\n                       ? O.w - sign(O.w)/16.\n                       : abs(T(0).w) >= 1.\n                           ? keyClick(38) - keyClick(40) : 0.; // keypressed direction ( up down arrows )\n     float s = step(0.,T(0).w), \n           d = T(1).w;                              // balls direction\n           \n                                                    // --- rotate balls in the selected ring\n     if ( O.y == s || O.z < 4.  ) O.y = s, O.z = mod( O.z + sign(d)/16., 18.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdcD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wsyBRV", "name": "Stay healthy", "author": "andrinr", "description": "weird game of life adaptation", "tags": ["biology"], "likes": 5, "viewed": 299, "published": 3, "date": "1609172846", "time_retrieved": "2024-07-30T20:28:01.497674", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*0.1;\n    vec3 buffer = texture(iChannel0,uv).xyz;\n    fragColor = vec4(vec3(buffer.x),1.);\n    //fragColor = vec4(iMouse.xy/iResolution.xy, 0., 0.);\n    //fragColor = vec4(buffer,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Lichen\n\n\n// Andrin Rehmann\n// 2020\n// andrinrehmann.ch\n// andrinrehmann@gmail.com\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat rand( vec2 uv )\n{\n\tfloat t = fract( iTime );\n\treturn nrand( uv + 0.07*t );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat du = 1. / iResolution.x;\n    float dv = 1. / iResolution.y;\n    \n\tvec2 uv = fragCoord/iResolution.xy;\n    \n\tfloat y = texture(iChannel0,uv).x;\n    // food\n    float f = texture(iChannel0,uv).z;\n    \n    // sum of surrounding y's\n    float s = 1./12. * texture(iChannel0,uv + vec2(-du,-dv)).x +\n              1./6.  * texture(iChannel0,uv + vec2(-du,0)).x + \n              1./12. * texture(iChannel0,uv + vec2(-du,dv)).x + \n              1./6.  * texture(iChannel0,uv + vec2(0,-dv)).x + \n              1./6.  * texture(iChannel0,uv + vec2(0,dv)).x +\n              1./12. * texture(iChannel0,uv + vec2(du,-dv)).x +\n              1./6.  * texture(iChannel0,uv + vec2(du,0)).x + \n              1./12. * texture(iChannel0,uv + vec2(du,dv)).x;\n\n    \n    // Sorry for the lack of comments\n    // But I dont understand it either\n    \n    if (f > 0.8){\n        y += 0.02 * y;\n        f -= 0.02;\n    }\n    else{\n        y -= 0.05 * y;\n        f += 0.01;\n    }\n    \n    if (s > sin(iTime*0.04)){\n        y -= 0.1 + 0.05*sin(iTime*0.08);\n    }\n    else{\n    \n        y += 0.1 + 0.03*cos(iTime*0.063);\n    }\n\n    // Init\n    if (iFrame < 1 && rand(uv) > 0.9){\n        y = rand(uv);\n        f = rand(uv+vec2(0.2));\n    }\n    \n    fragColor = vec4(y, 0, f, 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 332]], "test": "untested"}
{"id": "wldcD4", "name": "polyhedral toroidal surface", "author": "cyperus", "description": "surface with cyclic regular polyhedral toroidal  symmetry\n\nuse mouse", "tags": ["sdf", "sphere", "tiling"], "likes": 19, "viewed": 872, "published": 3, "date": "1609147495", "time_retrieved": "2024-07-30T20:28:02.455115", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"polyhedral toroidal surface\"\n//\n// created by Colling Patrik (cyperus) in 2020\n//\n// CODE snippets from\n// - jorge2017a1 => https://www.shadertoy.com/view/3sjyDh\n// - mla\n// - iq \n//\n// DOCUMENTATION:\n// - https://math.stackexchange.com/questions/1469554/polyhedral-symmetry-in\n//   -the-riemann-sphere\n// - https://iquilezles.org/articles/raymarchingdf\n// - https://iquilezles.org/articles/intersectors\n//\n// DESCRIPTION:\n// - Choose a cyclic regular polyhedral base transformation. Parameterize.\n//   {torus, spherical-truncated-tetrahedron, spherical-truncated-octahedron,\n//   spherical-truncated-dodecahedron}\n// - Activate up to 2 levels of toroidal transformations. Parameterize.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// const\nconst float PI = 3.14159265359;\n\nfloat sig(float x) { return x >= 0. ? +1. : -1.; }\n\n// 2D transformations: vec2 => vec2\n// complex\nvec2 cmul(vec2 za,vec2 zb) // za*zb\n{\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) // 1/z\n{\n    return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) // z/w\n{\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) // z^n\n{\n    vec2 w = z;\n    for (int i = 1; i < n; i++){\n    w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) // z*e^(i*a)\n{\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) // (z*e^ia)^n-x0\n{\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// 3D-transformations: vec3 => vec3\n//color\nvec3 hsv2rgb(float h, float s, float v)  // hue, saturation, value\n{\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.,4.,2.),6.)-3.)-1., 0., 1. );\n    rgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\n    return v * mix( vec3(1.), rgb, s);\n}\n\nvec2 isphere(in vec3 ro, in vec3 rd, in float r )\n{\n    // sphere centered at the origin, with size rd\n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;\n\n    if( h<0. ) return vec2(-1.);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n// https://www.shadertoy.com/view/fdfSDH\n// mla https://www.shadertoy.com/view/lsGyzm\nvec4 inverseStereographic(vec3 p) {\n  float k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\nvec3 stereographic(vec4 p4) {\n  float k = 1.0/(1.0+p4.w);\n  return k*p4.xyz;\n}\n\nvec3 rot4D(in vec3 p, in float t, in float r_inv){\n    p /=r_inv;                             // normalize\n    vec4 p4 = inverseStereographic(p);     // Project to 4d\n    p4.zw = cmul(p4.zw, vec2(cos(-t),sin(-t)));// Rotate in the 4th dimension\n    p = stereographic(p4);                 // Project back to 3d\n    p *=r_inv;                             // unnormalize\n    return p;\n}\n////////////////////////////////////////////////////////////////////////////////\n\nfloat map( in vec3 p, out vec4 mat ){\n    //// sdf's\n    int k, n;\n    vec3 pn = normalize(p);\n    vec2 z;\n    float r, au, av;\n    float sr = 1.; // Torus\n    \n    \n    //float r_inv = sqrt(abs(ba_sh_a)); // inversion bending radius (torus-spheres transformation)\n    //p = rot4D(p, 0.125 *iTime, r_inv);\n\n    /// cyclic regular Polyeder ba_id in {1,2,3}    \n    if(  ba_id == 0 || ba_id == 1 || ba_id == 2 || ba_id == 3 ){    \n\t\t// Fk,2(z)\n\t\tif (ba_id == 0)\n        {\n            k = 7; n = 2;\n            float a1 = float(k);            \n            vec2 zk;\n            if (pn.z < 0.) // stereographic (north pol)\n            {\n                z = pn.xy/(1.0-(pn.z));\n                zk = cpow(z,k);\n                z = a1 * cdiv(zk, cpow(zk - vec2(1.,0.) ,n));\n            }else          // stereographic (south pol)\n            {\n                z = vec2(pn.x, -pn.y)/(1.+pn.z);\n                zk = cpow(z,k);\n                z = a1 * cdiv(zk, cpow(vec2(1.,0.) - zk ,n));     \n            }\n        }\n        \n\t\t// F3,3(z)\n\t\tif (ba_id == 1)\n        {\n            k = 3; n = 3;\n            float a1 = 2. * sqrt(2.);\n            vec2 zk;\n            if (pn.z < 0.) // stereographic (north pol)\n            {\n                z = pn.xy/(1.-pn.z);\n                zk = cpow(z,k);\n                z = 1./(8.*a1) * zk;\n                z = cmul(z, cpow(zk - vec2(a1,   0.), k));\n                z = cdiv(z, cpow(zk + vec2(1./a1,0.), n));\n            }else          // stereographic (south pol)\n            {\n                z = vec2(pn.x, -pn.y)/(1.+pn.z);\n                zk = cpow(z,k);\n                z = 1./(8.*a1)*cinv(zk);       \n                z = cmul(z, cpow(vec2(1.,0.) - zk * a1, k));\n                z = cdiv(z, cpow(vec2(1.,0.) + zk / a1, n));    \n            }\n\t\t}\n\n\t\t// F4,3(z)\n\t\tif (ba_id == 2)\n        {\n            k = 4; n = 3;\n            float a1 = 108.;\n            vec2 zk;\n            if (pn.z < 0.) // stereographic (north pol)\n            {        \n                z = vec2(pn.x, pn.y)/(1.-pn.z);\n                zk = cpow(z,k);\n                z = a1 * zk;\n                z = cmul(z, cpow(zk          - vec2(1.,0.),          k));\n                z = cdiv(z, cpow(cmul(zk,zk) + 14.*zk + vec2(1.,0.), n));\n            }else          // stereographic (south pol) \n            {\n                z = vec2(pn.x, -pn.y)/(1.+pn.z);\n                zk = cpow(z,k);\n                z = a1 * zk;\n                z = cmul(z, cpow(vec2(1.,0.) - zk,                   k));\n                z = cdiv(z, cpow(vec2(1.,0.) + 14.*zk + cmul(zk,zk), n)); \n            }\n\t\t}\n\n\t\t// F5,3(z)\n\t\tif (ba_id == 3)\n        {\n            k = 5; n = 3;\n            float a1 = 1728.;\n            vec2 zk, zk2;\n            if (pn.z < 0.) // stereographic (north pol)\n            {  \n                z = pn.xy/(1.+abs(pn.z));\n                zk = cpow(z,k); \n                zk2 = cmul(zk,zk);\n                z = a1 * zk;\n                z = cmul(z, cpow(zk2 - 11. * zk - vec2(1.,0.), k));\n                z = cdiv(z, cpow(cmul(zk2,zk2)\n                               +228.*cmul(zk2,zk)\n                               +494.*zk2\n                               -228.*zk\n                               +vec2(1.,0.), n));\n            } else         // stereographic (south pol)                    \n            {\n                z = vec2(pn.x, -pn.y)/(1.+pn.z);\n                zk = cpow(z,k);\n                zk2 = cmul(zk,zk);\n                z = a1 * zk; \n                z = cmul(z, cpow(vec2(1.,0.) - 11. * zk - zk2, k));\n                z = cdiv(z, cpow(vec2(1.,0.)\n                               +228.*zk\n                               +494.*zk2\n                               -228.*cmul(zk2,zk)\n                               +cmul(zk2,zk2), n));\n            }\n\t\t}\n        \n        // sense of rotation of the polygon: sig(sr) in {-1.,+1.}\n        // number of sides of the polygon: abs(sr) in {n,k}\n        sr = float(length(z)>1.0?-n:k);\n\n\t\t// au\n\t\tau = atan(z.y,z.x) - .5 * PI * sig(sr);\n        \n\t\t// av       \n\t\tfloat f_v_distri = .5 * ba_sh_a / ba_v_distri;        \n\t\tf_v_distri = sqrt( 1. + pow( f_v_distri ,2.)) + f_v_distri;\n        \n\t\t// length(w) in [0., 1., +inf] => [-inf, 0., +inf] => av in [-0.5*PI,+0.5*PI]\n\t\tav = atan(log(length(z))*f_v_distri);\n\n\t\t// spherical => cartesian\n\t\tp = length(p)\n          * vec3( sin(av) * cos(au),\n\t\t\t\t  sin(av) * sin(au),\n\t\t\t\t  cos(av) );\n\t}\n\n\t/// Torus:\n\t// 3D-space: cartesian3D => cylinder3D transformation\n\tau = atan(p.y, p.x); //float in [-PI, +PI]\n\tr = length(p.xy);\t //float in [0., +inf]\n\t// 2D-space: complex plane := radial plane in cylinderc coordinates\n\tz = vec2(r, p.z);\n    \n\t/// 2Djulia :realaxis-translation, fraction == 2 => (torus,sphere,2spheres)\n\tz = cmul(z,z); z.x -= ba_sh_a;\n\tfloat ssr = sig(sr);\n\n\t//float fru = 1.0; // fractions in u-direction\n\t/// 2Djulia realaxis-translation,fraction,rotation,torsion\n\tif (j1_ON){\n\tfloat j1_sh = j1_sh_a0 + j1_sh_a1 * cos(float(j1_sh_f1) *(au - PI*(j1_sh_p1+j1_sh_pv1*iTime)));\n\tfloat j1_to = ssr * (au*float(j1_to_c)/float(j1_to_f) + PI*(j1_to_p+j1_to_pv*iTime));\n\tz = crpt(z, j1_to, j1_to_f,  j1_sh);\n\t//fru *= (j1_sh_f1 == 0)?1.0:float(j1_sh_f1);\n\t}\n\n\t/// 2Djulia realaxis-translation,fraction,rotation, torsion\n\tif (j2_ON){\n\tfloat j2_sh = j2_sh_a0 + j2_sh_a1 * cos(float(j2_sh_f1) * (au - PI*(j2_sh_p1+j2_sh_pv1*iTime)));\n\tfloat j2_to = ssr * (au*float(j2_to_c)/float(j2_to_f) + PI*(j2_to_p+j2_to_pv*iTime));\n\tz = crpt(z, j2_to, j2_to_f,  j2_sh);\n\t//fru *= (j2_sh_f1 == 0)?1.0:float(j2_sh_f1);\n\t}\n\n\tmat = vec4(z,au,sr);\n\tfloat res = log(length(z)/end_r0); // TODO:  :( Not perfect!\n\n\treturn res;\n\t}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n\tfloat res = -1.0; // init no rayintersection\n\n\t// boundingshape\n\tvec2 dis = isphere( ro, rd ,abs(bb_size));\n\tif( dis.y<0.0 ) // Does ray hit boundingshape?\n\t\treturn -1.0;\n\tdis.x = max( dis.x, max(rm_rlmin,0.0) );// start_raylength from bb_near_hit or raylength_minimum\n\tdis.y = min( dis.y, 10.0 );\t// end_raylength from bb_far_hit or raylength_maximum\n\t// raymarch signed distance field\n\tvec4 data; // data from surface hit point and accumulated data while raymarching\n\n\tfloat fh = (0.5-0.0001)*rm_p3slmul*rm_p3slmul*rm_p3slmul + 0.0001; // slider response curve\n\tfloat t = dis.x;\n\tfor( int i=0; i<rm_imax; i++  )\n\t{\n\t\tvec3 pos = ro + rd*t;\n\t\tfloat th = 0.0001*px*t; // delta_sdf_surface_hit\n\t\tfloat h = map(pos, data);\n\t\tif( t>dis.y || h<th ) break; // ray is outside boundingshape OR sdf_surface_hit.\n\t\tt += h*fh; // step_length * step_length_multiplier\n\t}\n\n\tif( t<dis.y ) // Is ray inside boundingshape?\n\t{\n\t\trescol = data; // return data\n\t\tres = t; // return ray_length\n\t}\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos, in float px )\n{\n\tvec4 tmp; // dummy variable\n\tvec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n\treturn normalize( e.xyy*map( pos + e.xyy,tmp ) +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<1; i++ )\n\t{\n\t\tvec4 temp;\n\t\tfloat h = map( ro + rd*t, temp );\n\t\tres = min( res, 8.0*h/t );\n\t\tt += h*.25;\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0., 1. );\n}\n\n// from iq\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\t// antialeasing\n\tfor( int i=0; i<1; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos =  nor * hr + pos;\n\t\tvec4 temp;\n\t\tfloat dd = map( aopos, temp );\n\t\tocc += -(dd-hr)*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// transform from mla\nvec3 transform(in vec4 p){\n\tif (iMouse.x > 0.0)\n\t{\n\t\tfloat phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n\t\tfloat theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n\t\tp.yz = crot(p.yz,theta);\n\t\tp.zx = crot(p.zx,-phi);\n\t}\n\t//p.xz = crot(p.xz,p.w*0.1);\n\treturn p.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// time\n\tfloat time = iTime;\n\t// camera\n\tfloat fle = 2.0;\n\tvec3 ro = transform(vec4(0,0,-cam_dist,time)).xyz;\n\tvec2 uv = (2.0*(fragCoord-0.5*iResolution.xy))/iResolution.y;\n     \n    // ray direction\n\tvec3 rd = normalize(transform(vec4(uv,fle,time)));\n\t// get ray distance to (intersection) hit point\n\tvec4 mat = vec4(0.0);\n\tfloat px = 2.0/( iResolution.y*fle );\n\tfloat t = intersect( ro, rd, mat, px );\n\n\t// light\n\tconst vec3 ld = 0.5*vec3(0.,-.5,-1.); // ligth direction\n\tconst vec3 lc = vec3(0.4);// ligth color\n\tvec3 bg = vec3(0.8,0.9,1.0)*(0.6+0.4*rd.y);\t// background-color\n\n\t// color\n\tvec3 col = vec3(0.6,0.4,0.7);\n\n\tif (t < 0.0){ // sky\n\t\tcol = bg;\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,lc),0.0,1.0), 20.0 ); // sun\n\t}\n    else{ // hit with object surface\n        vec3 p = ro + rd * t;\n\t\tvec3 n = calcNormal( p, px );\n\t\t//vec2 mat_uv = vec2(mat.w, atan(mat.z, mat.y) ); //angle-u angle-v\n\n\t\tif(texture_ON){\n\t\t\t//texture_data\n\t\t\tvec2 z = mat.xy; float au = mat.z; float sr = mat.w; float ssr = sig(sr);\n\n\t\t\t// texture_coords\n\t\t\tfloat u = au/PI;\n\t\t\tfloat v = ssr*atan(z.y, z.x)/PI;\n\n\t\t\t// texture_color\n\t\t\tu -= j2_sh_pv1 * iTime;\n\t\t\tfloat col_h = 1.0; // h in [-0.5,0.0,+0.5] => [green_cyan,red,blue_cyan]\n\t\t\t//col_h *= 0.5*v;\n\t\t\tcol_h *= 0.5*u;\n\t\t\tfloat col_s = 1.0;\n\t\t\t//col_s *= 0.9+0.1*ssr; // show polygon rotation sens in u-direction\n\t\t\tfloat col_v = 1.0;\n\t\t\tcol_v *= .5+.5*fract(float(tex_u_subdiv)*1.0*(.5+.5*u));\n\t\t\tcol_v *= .5+.5*fract(float(tex_v_subdiv)*2.0*(.5+.5*v));\n\n\t\t\tcol = hsv2rgb(col_h,col_s,col_v);\n\t\t}\n\t\telse col = -n;\n\n\t\tif(shade_ON){\n\t\t\t// lighting\n\t\t\tfloat occ = calcAO( p, n );\n\t\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\t\t\tvec4 temp; // dummy variable\n\t\t\tfloat dif = clamp( dot( n, ld ), 0.0, 1.0 ) * map( p+n*1.16, temp);\n\t\t\tfloat spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n\t\t\tfloat sss = map( p - n*0.001, temp)/0.01;\n\t\t\t// shading\n\t\t\tdif *= softshadow( p, ld, 0.1, 1. );\n\t\t\tvec3 brdf = vec3(0.0);\n\t\t\tbrdf += 0.2*dif*vec3(1.00,0.90,0.60);\n\t\t\tbrdf += 0.2*spe*vec3(0.8,0.60,0.20)*dif;\n\t\t\tbrdf += 0.2*amb*vec3(0.40,0.60,0.40)*occ;\n\t\t\tbrdf += 0.4;\n\t\t\tcol.rgb *= brdf;\n\t\t}\n\n\t\tif(fog_ON){\n\t\t\t// fog\n\t\t\tcol = mix( bg,col, exp( -0.025*t*t));\n\t\t}\n\t}\n\t// gamma\n\tcol = sqrt(col);\n\n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "//#define PRESET_Shape_000\n#define PRESET_Shape_001\n//#define PRESET_Shape_002\n//#define PRESET_Shape_003\n//#define PRESET_Shape_004\n//#define PRESET_Shape_005\n//#define PRESET_Shape_006\n//#define PRESET_Shape_007\n\n#ifdef PRESET_Shape_000\nconst float cam_dist = 4.7470617;\nconst float bb_size = -3.0;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 333;\nconst float rm_p3slmul = 0.3;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 11;\nconst int tex_v_subdiv = 2;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 1;\nconst float ba_v_distri = 1.0;\nconst float ba_sh_a = -5.87952;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 5.0;\nconst float j1_sh_a1 = 0.5;\nconst int j1_sh_f1 = 1;\nconst float j1_sh_p1 = -0.037736;\nconst float j1_sh_pv1 = 0.3;\nconst int j1_to_c = 0;\nconst int j1_to_f = 2;\nconst float j1_to_p = 0.03773606;\nconst float j1_to_pv = 0.1;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = -2.0;\nconst float j2_sh_a1 = 3.5;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = -0.19999999;\nconst float j2_sh_pv1 = 0.07;\nconst int j2_to_c = -1;\nconst int j2_to_f = 4;\nconst float j2_to_p = 0.0;\nconst float j2_to_pv = 0.05;\n#endif // PRESET_Shape_000\n\n#ifdef PRESET_Shape_001\nconst float cam_dist = 4.852944;\nconst float bb_size = -6.0;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 333;\nconst float rm_p3slmul = 0.3;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 11;\nconst int tex_v_subdiv = 2;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 3;\nconst float ba_v_distri = 0.5;\nconst float ba_sh_a = -4.5;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 1.0291395;\nconst float j1_sh_a1 = 0.5;\nconst int j1_sh_f1 = 1;\nconst float j1_sh_p1 = 0.0;\nconst float j1_sh_pv1 = 0.3;\nconst int j1_to_c = 1;\nconst int j1_to_f = 2;\nconst float j1_to_p = 0.0;\nconst float j1_to_pv = 0.1;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = -2.0;\nconst float j2_sh_a1 = 3.5;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = -0.19999999;\nconst float j2_sh_pv1 = 0.07;\nconst int j2_to_c = -1;\nconst int j2_to_f = 4;\nconst float j2_to_p = 0.0;\nconst float j2_to_pv = 0.05;\n#endif // PRESET_Shape_001\n\n#ifdef PRESET_Shape_002\nconst float cam_dist = 5.67198;\nconst float bb_size = -3.849708;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 303;\nconst float rm_p3slmul = 0.268786;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 3;\nconst float ba_v_distri = 0.3669623;\nconst float ba_sh_a = -4.219776;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 1.0291395;\nconst float j1_sh_a1 = 0.10017967;\nconst int j1_sh_f1 = 3;\nconst float j1_sh_p1 = 0.12568402;\nconst float j1_sh_pv1 = 0.0631578;\nconst int j1_to_c = 1;\nconst int j1_to_f = 2;\nconst float j1_to_p = -0.92714;\nconst float j1_to_pv = 0.16120201;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = -1.88995;\nconst float j2_sh_a1 = 3.4928207;\nconst int j2_sh_f1 = 2;\nconst float j2_sh_p1 = -0.19999999;\nconst float j2_sh_pv1 = 0.0746412;\nconst int j2_to_c = -1;\nconst int j2_to_f = 4;\nconst float j2_to_p = 0.060109973;\nconst float j2_to_pv = -0.1896174;\n#endif // PRESET_Shape_002\n\n#ifdef PRESET_Shape_003\nconst float cam_dist = 5.67198;\nconst float bb_size = -5.531712;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 1460;\nconst float rm_p3slmul = 0.378815;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = true;\nconst bool fog_ON = false;\nconst int ba_id = 3;\nconst float ba_v_distri = 0.48437533;\nconst float ba_sh_a = -8.0;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = -0.31099987;\nconst float j1_sh_a1 = 1.62679;\nconst int j1_sh_f1 = 0;\nconst float j1_sh_p1 = 0.425838;\nconst float j1_sh_pv1 = 0.0631578;\nconst int j1_to_c = 4;\nconst int j1_to_f = 5;\nconst float j1_to_p = -0.31100398;\nconst float j1_to_pv = 0.0588516;\nconst bool j2_ON = false;\nconst float j2_sh_a0 = 1.6149902;\nconst float j2_sh_a1 = 0.0;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = 0.14624596;\nconst float j2_sh_pv1 = -0.050988004;\nconst int j2_to_c = 0;\nconst int j2_to_f = 3;\nconst float j2_to_p = 0.012920022;\nconst float j2_to_pv = 0.3;\n#endif // PRESET_Shape_003\n\n#ifdef PRESET_Shape_004\nconst float cam_dist = 5.67198;\nconst float bb_size = -5.531712;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 1460;\nconst float rm_p3slmul = 0.378815;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = true;\nconst bool fog_ON = false;\nconst int ba_id = 1;\nconst float ba_v_distri = 0.48437533;\nconst float ba_sh_a = -8.0;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = -0.31099987;\nconst float j1_sh_a1 = 1.62679;\nconst int j1_sh_f1 = 2;\nconst float j1_sh_p1 = 0.425838;\nconst float j1_sh_pv1 = 0.0631578;\nconst int j1_to_c = -1;\nconst int j1_to_f = 5;\nconst float j1_to_p = 0.0;\nconst float j1_to_pv = 0.0;\nconst bool j2_ON = false;\nconst float j2_sh_a0 = 1.6149902;\nconst float j2_sh_a1 = 0.0;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = 0.14624596;\nconst float j2_sh_pv1 = -0.050988004;\nconst int j2_to_c = 0;\nconst int j2_to_f = 3;\nconst float j2_to_p = 0.012920022;\nconst float j2_to_pv = 0.3;\n#endif // PRESET_Shape_004\n\n#ifdef PRESET_Shape_005\nconst float cam_dist = 5.67198;\nconst float bb_size = -5.531712;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 1460;\nconst float rm_p3slmul = 0.378815;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = false;\nconst bool fog_ON = false;\nconst int ba_id = 1;\nconst float ba_v_distri = 1.0;\nconst float ba_sh_a = -3.4506078;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 2.0095701;\nconst float j1_sh_a1 = -1.6746399;\nconst int j1_sh_f1 = 2;\nconst float j1_sh_p1 = -0.029586017;\nconst float j1_sh_pv1 = 0.0631578;\nconst int j1_to_c = 2;\nconst int j1_to_f = 3;\nconst float j1_to_p = 0.0;\nconst float j1_to_pv = 0.0;\nconst bool j2_ON = false;\nconst float j2_sh_a0 = 1.6149902;\nconst float j2_sh_a1 = 0.0;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = 0.14624596;\nconst float j2_sh_pv1 = -0.050988004;\nconst int j2_to_c = 0;\nconst int j2_to_f = 3;\nconst float j2_to_p = 0.012920022;\nconst float j2_to_pv = 0.3;\n#endif // PRESET_Shape_005\n\n#ifdef PRESET_Shape_006\nconst float cam_dist = 5.663412;\nconst float bb_size = 2.4986763;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 387;\nconst float rm_p3slmul = 0.302387;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 1;\nconst int tex_v_subdiv = 1;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 1;\nconst float ba_v_distri = 1.0;\nconst float ba_sh_a = -3.39568;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 1.7441897;\nconst float j1_sh_a1 = 2.9328198;\nconst int j1_sh_f1 = 1;\nconst float j1_sh_p1 = 0.0;\nconst float j1_sh_pv1 = 0.0;\nconst int j1_to_c = -1;\nconst int j1_to_f = 3;\nconst float j1_to_p = -0.031620026;\nconst float j1_to_pv = 0.0;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = 1.5714302;\nconst float j2_sh_a1 = -0.19048023;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = 0.0;\nconst float j2_sh_pv1 = 0.0;\nconst int j2_to_c = 0;\nconst int j2_to_f = 2;\nconst float j2_to_p = 0.012920022;\nconst float j2_to_pv = 0.3;\n#endif // PRESET_Shape_006\n\n#ifdef PRESET_Shape_007\nconst float cam_dist = 4.852944;\nconst float bb_size = -3.0;\nconst float rm_rlmin = 0.0;\nconst int rm_imax = 333;\nconst float rm_p3slmul = 0.3;\nconst bool texture_ON = true;\nconst int tex_u_subdiv = 11;\nconst int tex_v_subdiv = 2;\nconst bool shade_ON = true;\nconst bool fog_ON = true;\nconst int ba_id = 0;\nconst float ba_v_distri = 0.5;\nconst float ba_sh_a = -4.5;\nconst float end_r0 = 1.0;\nconst bool j1_ON = true;\nconst float j1_sh_a0 = 1.0291395;\nconst float j1_sh_a1 = 0.5;\nconst int j1_sh_f1 = 1;\nconst float j1_sh_p1 = 0.0;\nconst float j1_sh_pv1 = 0.3;\nconst int j1_to_c = 1;\nconst int j1_to_f = 2;\nconst float j1_to_p = 0.0;\nconst float j1_to_pv = 0.1;\nconst bool j2_ON = true;\nconst float j2_sh_a0 = -2.0;\nconst float j2_sh_a1 = 3.5;\nconst int j2_sh_f1 = 0;\nconst float j2_sh_p1 = -0.19999999;\nconst float j2_sh_pv1 = 0.07;\nconst int j2_to_c = -1;\nconst int j2_to_f = 4;\nconst float j2_to_p = 0.0;\nconst float j2_to_pv = 0.05;\n#endif // PRESET_Shape_007\n\n//Synthclipse///////////////////////////////////////////////////////////////////\n/*\n//! <group name=\"came\">\nuniform float cam_dist; //! slider[0.0, 4.0, 6.0]       // camera distance\n//! <group name=\"ray_march\">\nuniform float bb_size; //! slider[-6., 2.0, 6.0]\t\t// bounding box size\nuniform float rm_rlmin; //! slider[0.0, 1.0, 8.0]\t\t// ray march ray_length minimum\nuniform int   rm_imax; //! slider[100, 700, 2000]\t\t// ray march maximal number of iterations\nuniform float rm_p3slmul; //! slider[0.0, 0.2, 1.0]\t\t// ray march power(step length multiplier,3)\n//! <group name=\"color\">\nuniform bool texture_ON; //! checkbox[true]\nuniform int tex_u_subdiv; //! slider[1, 6, 12]\nuniform int tex_v_subdiv; //! slider[1, 6, 12]\nuniform bool shade_ON; //! checkbox[false]\nuniform bool fog_ON; //! checkbox[false]\n//! <group name=\"base0\">\nuniform int   ba_id; //! slider[0,2,3]\t\t\t// root-transformation id\nuniform float ba_v_distri; //! slider[0.01, 1.0, 1.0]\t// root-v distribution\nuniform float ba_sh_a; //! slider[-8., 3., 8.]\t\t// root-shift amplitude\nuniform float end_r0; //! slider[0.1, 1.0, 1.0]\t// leaf-transformation radius r0\n//! <group name=\"julia1\">\nuniform bool j1_ON; //! checkbox[true]\n// shift in u-direction any normalized periodic function.\n// shift = sh_a0 + sh_a1 * npfunc(sh_f1 * (au/PI-(sh_p1 + sh_pv1 * iTime)));\nuniform float j1_sh_a0; //! slider[-8., -3., 8.]\t// 0.degree amplitude\nuniform float j1_sh_a1; //! slider[-8., 0., 8.]\t\t// 1.degree amplitude\nuniform int   j1_sh_f1; //! slider[-18, 1, 18]\t\t// 1.degree frequency\nuniform float j1_sh_p1 ; //! slider[-1., 0.0, +1.]\t// 1.degree phase\nuniform float j1_sh_pv1; //! slider[-0.3, 0.0, 0.3]\t// 1.degree phase\n// torsion in v-direction\n// to = ssr * ( au/PI*j2_to_c/j2_to_f + (to_p + to_pv * iTime) );\nuniform int   j1_to_c; //! slider[-10, 3, 10]\t\t// counter torsion //TEST: int\nuniform int\t  j1_to_f; //! slider[1, 4, 6]\t\t\t// fraction torsion\nuniform float j1_to_p; //! slider[-1., 0.03, +1.]\t// phase\nuniform float j1_to_pv; //! slider[-0.3, 0.0, 0.3]\t// phase velocity\n//! <group name=\"julia2\">\nuniform bool j2_ON; //! checkbox[true]\n// shift in u-direction any normalized periodic function.\n// shift = sh_a0 + sh_a1 * npfunc(sh_f1 * (au/PI-(sh_p1 + sh_pv1 * iTime)));\nuniform float j2_sh_a0; //! slider[-8., -3., 8.]\t// 0.degree amplitude\nuniform float j2_sh_a1; //! slider[-8., 0., 8.]\t\t// 1.degree amplitude\nuniform int   j2_sh_f1; //! slider[-18, 1, 18]\t\t// 1.degree frequency\nuniform float j2_sh_p1 ; //! slider[-1., 0.0, +1.]\t// 1.degree phase\nuniform float j2_sh_pv1; //! slider[-0.3, 0.0, 0.3]\t// 1.degree phase velocity\n// torsion in v-direction\n// to = ssr * ( au/PI*j2_to_c/j2_to_f + (to_p + to_pv * iTime) );\nuniform int   j2_to_c; //! slider[-10, 3, 10]\t\t// counter torsion\nuniform int\t  j2_to_f; //! slider[1, 4, 6]\t\t\t// fraction torsion\nuniform float j2_to_p; //! slider[-1., 0.03, +1.]\t// phase\nuniform float j2_to_pv; //! slider[-0.3, 0.0, 0.3]\t// phase velocity\n*/\n////////////////////////////////////////////////////////////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldcD4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[995, 995, 1015, 1015, 1045], [1047, 1094, 1131, 1131, 1171], [1173, 1173, 1199, 1199, 1237], [1239, 1239, 1273, 1273, 1303], [1305, 1305, 1338, 1338, 1428], [1430, 1430, 1470, 1470, 1515], [1517, 1517, 1578, 1578, 1624], [1626, 1670, 1738, 1738, 1902], [1904, 1904, 1955, 2006, 2166], [2168, 2254, 2289, 2289, 2349], [2350, 2350, 2379, 2379, 2428], [2430, 2430, 2480, 2480, 2813], [2896, 2896, 2933, 2948, 8504], [8506, 8506, 8579, 8579, 9572], [9574, 9574, 9619, 9619, 9858], [9860, 9871, 9945, 9945, 10169], [10171, 10182, 10224, 10224, 10508], [10510, 10532, 10558, 10558, 10809], [10811, 10811, 10868, 10877, 13128]], "test": "untested"}
{"id": "WlcyDn", "name": "Fluffy Cloud", "author": "Zi7ar21", "description": "Yeetus", "tags": ["noise", "cloud", "volumetric", "cyclic"], "likes": 5, "viewed": 406, "published": 3, "date": "1609139986", "time_retrieved": "2024-07-30T20:28:03.205109", "image_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// Common is for Settings and Global Functions\n// Buffer A is for Rendering\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Fluffy Cloud --- December 27th, 2020\n// Updated December 28th, 2020 12:57 Mountain Time\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/WlcyDn\n// Fork of \"Colored Volumetric Mandelbulb\" by Zi7ar21. https://shadertoy.com/view/3l3yzr\n// December 12th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- August 8th, 2020\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- October 11th, 2020 / December 28th, 2020\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Rendering\n\n// Oof ugly mess below watch out lol\n\n// ##### NOISE #####\n// Cyclic Noise from https://www.shadertoy.com/view/wl3czN\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.1;\nvoid cyclicOctave(inout vec3 p, inout float rz, inout float z, inout float trk, inout float dspAmp){\n    p += sin(p.yzx*0.25*trk - trk*6.1 + cos(p*0.1 + 0.5)*1.0)*dspAmp;\n    float ofst = 4.6;\n    vec3 s = sin(p*1.3);\n    rz += smoothstep(-1.1, 0.5, dot(s, cos(p.yzx*0.95+s.xyz+ofst)))*z;\n    dspAmp *= 0.65;\n    z *= 0.45;\n    trk *= 1.45;\n    p *= m3;}\nfloat cyclic3D(vec3 p){\n    vec3 bp = p;\n    float rz = 0.0;\n    vec3 drv = vec3(0.0);  \n    float z = 1.44;\n    float trk= 1.0;\n    float dspAmp = 1.;\n    for (int i = 0; i<=NUM_OCTAVES; i++){\n        cyclicOctave(p, rz, z, trk, dspAmp);}\n    rz -= 1.1;\n    return rz;}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float density = max(0.0, cyclic3D(raypos)-distance(raypos, vec3(0.0, 0.0, 0.0)));\n    vec3 rgb = vec3(density);\n    return rgb;\n}\n\n// ##### RAYMARCHING #####\nvec3 directLight(vec3 raypos){\n    vec3 LightColor = vec3(1.0);\n    vec3 LightDirection = normalize(vec3(-1.0, -1.0, 1.0));\n    float distorigin = 0.0;\n    vec3 density = vec3(0.0);\n    vec3 raydirmod = LightDirection*STEP_SIZE*rand();\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<32; i++){\n        raypos = raypos+raydirmod;\n        density = vec3(nebulanoise(raypos)*DENSITY);\n        vec3 absorbance = exp(-density);\n        attenuation *= absorbance;}\n    return LightColor*attenuation;\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    //vec3 densityadd = vec3(0.0);\n    //vec3 density = vec3(0.0);\n    vec3 raypos = camerapos;\n    vec3 raydirmod = (raydir*rand())*STEP_SIZE;\n    vec3 outCol = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+raydirmod;\n        // LoicVDB: don't use this, the density doesn't accumulate, its\n        // only purpose is to compute absorbance and transmittance\n        //densityadd = vec3(fractal(raypos)*DENSITY);\n        //density = vec3(density+densityadd);\n\n        // LoicVDB: just use this for density instead:\n        vec3 density = vec3(nebulanoise(raypos)*DENSITY);\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        vec3 transmittance = 1.0-absorbance;\n        vec3 directlighting = attenuation*transmittance;\n        if((density.r+density.g+density.b) > 0.0){\n            directlighting = directlighting*directLight(raypos);\n        }\n        outCol += directlighting;\n        attenuation *= absorbance;\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return outCol;//*attenuation;\n}\n\n// ##### RENDERING #####\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n\n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\n    // Start RNG\n    INIT_RNG;\n\n    // Camera Orientation\n    vec3 camerapos = vec3(2.0, -2.0, 2.0);\n    #ifdef ROTATION_MATRIX\n\t    // Dumb rotation matrix hecking Michael made me make\n\t    float xrot = atan(sqrt(2.0));\n\t    float yrot = pi;\n\t    float zrot = -pi/4.0;\n\t    // Camera Orientation (Cursed)\n        mat3 dir;\n\t    dir[0] = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\t    dir[1] = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\t    dir[2] = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,1.0,0.0);\n        vec3 zdir = vec3(0.0,0.0,1.0);\n    #endif\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n    #ifdef ROTATION_MATRIX\n    \tvec3 raydir = normalize(FOV*(uv.x*dir[0]+uv.y*dir[1])+dir[2]);\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n    #endif\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // Output\n    fragColor += vec4(raymarched, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Settings and Global Functions\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 32\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 8.0\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.25\n\n// Camera's FOV\n#define FOV 1.5\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n#define ROTATION_MATRIX\n\n// Density of the volume. Changes how much light it scatters.\n#define DENSITY 4.0\n\n// Cyclic Noise Octaves, more is more detailed with exponentially deminishing return.\n#define NUM_OCTAVES 8\n\n// Tiles, more means easier on the Hardware\n#define TILES 4 // Set to 1 if you have a computer that can handle it so it will render faster\n// So kindly made by LoicVDB uwu\n\n// Yummy, Pi! 32-Bit Floating Point Precision limits us to 3.14159265, but hey one day Shadertoy\n// may support double precision so why not throw in 3589793.\n#define pi 3.141592653589793\n\n// High-Quality Noise from https://www.shadertoy.com/view/tdGfWc\nuint ns;\n#define INIT_RNG ns = uint(iFrame*24676)+uint(fragCoord.x*5557.0)+uint(fragCoord.y*8482.0);\nvoid RNGupdate(){\n    // Integer hash copied from Hugo Elias\n\tns = (ns<<13U)^ns;\n    ns = ns*(ns*ns*15731U+789221U)+1376312589U;\n}\nfloat rand(){\n    RNGupdate();\n    return float((ns*ns)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1159, 1159, 1215, 1265, 1372]], "test": "untested"}
{"id": "wtdcW4", "name": "Hyperbolic  Rainbows", "author": "nbardy", "description": "I was inspired by hyperbolic geometry and created a similar effect by repeating radial cells in exponential fashion.", "tags": ["fractal", "radial", "pi", "polar", "cineshader", "hyperpolic"], "likes": 9, "viewed": 7262, "published": 3, "date": "1609135020", "time_retrieved": "2024-07-30T20:28:04.081765", "image_code": "// A simple way to create color variation in a cheap way (yes, trigonometrics ARE cheap\n// in the GPU, don't try to be smart and use a triangle wave instead).\n\n// See https://iquilezles.org/articles/palettes for more information\n\n// ****************\n// Helper functions\n// ****************\n\n// pallette \nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#define HASHSCALE1 443.8975\n\n// random functions lib\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t)\n{\n\treturn a + t * (b - a);\n}\n\nfloat noise(float p)\n{\n\tfloat i = floor(p);\n    float f = fract(p);\n    \n    float t = f * f * (3.0 - 2.0 * f);\n    \n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\n\nfloat fbm(float x, float persistence, int octaves) \n{\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    \n    for(int i=0; i<16;++i)\n    {\n        total += noise(x * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    \n    return (total/maxValue);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float pi = 3.1415926;\n    float res = max(iResolution.x, iResolution.y);\n    \n    // Center and normalize our coordinate system    \n    vec2 uv = (fragCoord - .5*iResolution.xy) / res;\n    \n\n    float r = length(uv - vec2(0.0,0.0));\n    float theta = atan(uv.y, uv.x);\n    float thetanorm = (theta + pi)/(2.0*pi);\n\n    // Shift r domain for aesthetics\n    r = r + 0.1;\n    r *= 1.0;\n    float i = floor(r*r*370.0 + 0.02) + 1.0;\n    \n    float at = sin(iTime*0.007 + 0.4) * 0.2 + 1.2;\n    // Add distortion to rings  \n    float rt = at*173.0 + 500.0;\n    float tfbm = fbm(((theta+20.0) + 20.0), 0.54, 16)*2.0 + 0.8;\n    float rfbm = fbm(r +rt, 0.54, 16)*4.0 + 0.8;\n    //r *= clamp(tfbm,0.3,1.0);\n    //r *= clamp(rfbm,0.8,1.0);\n    r *= rfbm;\n    r *= tfbm;\n    \n    i = floor(r*r*r*370.0) ;\n    float i2 = pow(i,2.0) +1.0;\n    \n    float pct = fract(thetanorm*i2*2.0);\n    \n    // Flip \n    pct = abs(mod(i,2.) - pct);\n    \n    \n    \n    float row = floor(thetanorm*i2*2.0);    \n    float k = (row+1.0)*(i+1.0)/200.0;\n    // get random color for each cell\n    vec3 color1 = vec3(hash11(k+1.0),hash11(k+2.0),hash11(k+3.0));\n    vec3 color2 = vec3(hash11(k+5.0),hash11(k+6.0),hash11(k+7.0));\n    \n    float cfbm = fbm(i/4.0, 2.0, 2) + 0.5;;\n    float t = sin(iTime*5.0 + cfbm*99.0)*0.5 + 0.5;\n \n    vec3 color = mix(color1, color2, t);\n    \n   \n\n    \n    // Color option: Pallette blending\n    // Todo change color to be picked random for each tile \n    //vec3 c1 = pal( pct, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    // vec3 c2 = pal( pct, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );  \n    // vec3 color = mix(c1,c2,t);\n    // vec3 color = vec3(pct); vec3 color = vec3(hash);\n    //vec3 color = \n    // Clip\n\n    // Output to screen\n    fragColor = vec4(color*pct,.0);\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 304, 372, 372, 415], [446, 470, 493, 493, 611], [613, 613, 652, 652, 679], [681, 681, 703, 703, 863], [865, 865, 918, 918, 1243], [1247, 1247, 1304, 1304, 3155]], "test": "untested"}
{"id": "tdyfWd", "name": "fun hills", "author": "CubeyTheCube", "description": "unfinished", "tags": ["hills"], "likes": 5, "viewed": 369, "published": 3, "date": "1609115786", "time_retrieved": "2024-07-30T20:28:04.904565", "image_code": "mat4 rotationX( in float angle) {\n  return mat4(1.0, 0, 0, 0,\n    0, cos(angle), -sin(angle), 0,\n    0, sin(angle), cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotationY( in float angle) {\n  return mat4(cos(angle), 0, sin(angle), 0,\n    0, 1.0, 0, 0,\n    -sin(angle), 0, cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotationZ( in float angle) {\n  return mat4(cos(angle), -sin(angle), 0, 0,\n    sin(angle), cos(angle), 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1);\n}\nvec3 rotate( in vec3 p, in float xrot, in float yrot, in float zrot) {\n  vec4 rot = vec4(p, 1.0) * rotationX(xrot) * rotationY(yrot) * rotationZ(zrot);\n  return rot.xyz; // ref https://gist.github.com/onedayitwillmake/3288507\n}\nfloat random( in vec2 st) {\n  return fract(sin(dot(st.xy,\n      vec2(12.9898, 78.233))) *\n    43758.5453123);\n}\nfloat noise( in vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  return mix(a, b, u.x) +\n    (c - a) * u.y * (1.0 - u.x) +\n    (d - b) * u.x * u.y;\n}\nfloat fbm( in vec2 p) { // ref https://thebookofshaders.com/13/\n  float y = 0.;\n  float f = 0.007;\n  float a = 0.5;\n  for (int i = 0; i < 10; i++) {\n    y += a * noise(f * p * 100.);\n    f *= 2.0;\n    a *= 0.5;\n  }\n  return y;\n}\nfloat terrain( in vec2 p) {\n  return fbm(p) * 2.0;\n}\nfloat raymarch( in vec3 ro, in vec3 rd, in int w) {\n  #define dt 0.05\n  vec3 p;\n  float h;\n  float t = 0.;\n  float dist;\n  for (int i = 0; i < 64; i++) {\n    p = ro + rd * t;\n    h = terrain(vec2(p.x, p.z));\n    dist = (p.y - h) / 2.;\n    if(w == 1) {\n      dist = min(dist,abs(0.7-p.y));\n    }\n    t += dist;\n\n  }\n  return t;\n}\n\nfloat fresnel( in vec3 i, in vec3 n, in float eta) {\n  float r0 = (1.-eta)/(1.+eta);\n  r0 *= r0;\n  return clamp(0.0,1.0,r0 + (1. - r0) * pow((1. - clamp(0.,1.,dot(i, n))), 5.0));\n}\nvec3 normal( in vec2 pos) {\n  vec2 e = vec2(0.03, 0.0);\n  return normalize(vec3(terrain(pos - e.xy) - terrain(pos + e.xy),\n    2.0 * e.x,\n    terrain(pos - e.yx) - terrain(pos + e.yx)));\n}\n\nvec3 interpolate(vec3 a, vec3 b, float t) {\n  return mix(a, b, clamp(t, 0.0, 1.0));\n}\nfloat ggx( in float a, in float cosine) {\n  return (a * a) / (3.14159265 * pow(cosine * cosine * (a * a - 1.) + 1., 2.0));\n}\nvec3 bgcol( in vec2 uv) {\n  float len = length(vec2(uv.x, uv.y * iResolution.y / iResolution.x) - vec2(0.2, 0.2));\n  float sun;\n  if (abs(len) > 0.4) {\n    sun = ggx(0.3, 0.0);\n  } else {\n    float dotProd = 1. - 2. * len;\n    sun = ggx(0.3, dotProd);\n  }\n  return min(vec3(1., 1., 1.), mix(vec3(52., 82., 235.) / 255., vec3(135., 206., 235.) / 255., 0.5 - uv.y) + vec3(1.0, 1., 0.) * sun);\n\n} // sun and sky\n\nvec3 fullBcol( in vec2 uv, in vec3 o, in vec3 d, inout vec3 bcol) {\n  vec2 cloudUV = 0.00002 * (o.xz + d.xz * ((3.) * 40000.0 - o.y) / d.y); // ref https://www.shadertoy.com/view/Msdfz8\n  cloudUV.y += iTime * 0.7;\n  bcol = bgcol(uv * 0.5 * iResolution.y / iResolution.x + vec2(d.x, d.y));\n  vec3 bcol2 = bcol;\n  bcol = interpolate(bcol, vec3(1.0), 2.5 * pow(fbm(cloudUV), 5.));\n  bcol = interpolate(bcol2, bcol, d.y * 4.0);\n  return bcol;\n} // sun, sky, and clouds\nvec3 scol( in float y) {\n  vec3 sc;\n  if (y < .9)\n    sc = vec3(0.486, 0.988, 0.0);\n  else if (y < 1.2)\n    sc = interpolate(vec3(0.486, 0.988, 0.0), vec3(0.341, 0.231, 0.047), (y - 1.) / 0.1);\n  else\n    sc = interpolate(vec3(0.341, 0.231, 0.047), vec3(1.0), (y - 1.3) / 0.1);\n  return sc;\n} // terrain color\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 col, bcol;\n  vec2 uv = fragCoord / iResolution.xy - vec2(0.5);\n  vec2 mouse = iMouse.xy / iResolution.xy - vec2(0.5);\n  vec3 o = vec3(0., 2., iTime);\n  vec3 d = normalize(vec3(uv.x, uv.y - 0.2, 1.0));\n  d = rotate(d, -mouse.y, mouse.x, 0.0);\n  float t = raymarch(o, d, 1);\n  vec3 i = o + d * t;\n  vec3 l = -normalize(vec3(vec2(.2, .2)-i.xy, 1.0-(i.y-o.y)));\n  vec3 n = normal(i.xz);\n  //n = normalize(n + 0.4 * vec3(random(n.xy * 100.), random(n.yz * 100.), random(n.zx * 100.)));\n  float shade = dot(n, l);\n  vec3 sc;\n  if (i.y < .71) {\n    n = vec3(0.,1.,0.);\n    vec3 r = reflect(d,n);\n    vec3 rf = refract(d, n, 3.);\n    float t2 = raymarch(i, r, 0);\n    vec3 rcol;\n    vec3 rfcol;\n    vec3 bcol2;\n    vec3 i2;\n    vec3 n2;\n    vec3 l2;\n    if (t2 > 16.) {\n      rcol = mix(vec3(52., 82., 235.) / 255., vec3(135., 206., 235.) / 255., .5 - r.y);\n    } else {\n      i2 = i + r * t2;\n      n2 = normal(i2.xz);\n      l2 = -normalize(vec3(vec2(.2, .2)-i2.xy, 1.0-(i2.y-i.y)));\n      rcol = scol(i2.y) * dot(n2, l2);\n    }\n    t2 = raymarch(i, rf, 0);\n      if (t2 > 16.) {\n      rfcol = mix(vec3(52., 82., 235.) / 255., vec3(135., 206., 235.) / 255., 0.5 - r.y);\n    } else {\n      i2 = i + rf * t2;\n      n2 = normal(i2.xz);\n      l2 = -normalize(vec3(vec2(.2, .2)-i2.xy, 1.0-(i2.y-i.y)));\n      rfcol = scol(i2.y) * dot(n2, l2);\n    }\n    float fres = fresnel(d, -n, 3.);\n    col = mix(mix(rfcol,rcol,fres),vec3(0.0,0.0,1.0)*dot(n,l),0.5);\n  } else {\n    sc = scol(i.y);\n\n    col = sc * shade;\n  }\n\n  if (t > 16.) {\n    col = fullBcol(uv, o, d, bcol);\n    col = interpolate(col, bcol, (min(20., t) - 16.0) / 4.0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 149], [151, 151, 184, 184, 300], [302, 302, 335, 335, 449], [450, 450, 520, 520, 677], [678, 678, 705, 705, 789], [790, 790, 816, 816, 1129], [1130, 1130, 1153, 1193, 1358], [1359, 1359, 1386, 1386, 1411], [1412, 1412, 1463, 1463, 1740], [1742, 1742, 1794, 1794, 1922], [1923, 1923, 1950, 1950, 2111], [2113, 2113, 2156, 2156, 2198], [2199, 2199, 2240, 2240, 2323], [2324, 2324, 2349, 2349, 2717], [2734, 2734, 2801, 2801, 3174], [3175, 3199, 3223, 3223, 3491], [3492, 3509, 3564, 3564, 5224]], "test": "untested"}
{"id": "3tdcW4", "name": "Discharge", "author": "klk", "description": "High voltage electric arc", "tags": ["electricarc"], "likes": 12, "viewed": 654, "published": 3, "date": "1609108308", "time_retrieved": "2024-07-30T20:28:05.656555", "image_code": "// Created by Alex Kluchikov\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n\nfloat3 MIX(float3 x, float3 y)\n{\n\treturn abs(x-y);\n}    \n\nfloat CV(float3 c, float2 uv)\n{\n    float size=640./iResolution.x*0.003;\n    float l=clamp(size*(length(c.xy-uv)-c.z),0.,1.);\n\treturn 1.-l;\n}\n\nvoid mainImage(out float4 O, in float2 I)\n{\n    O=float4(0,0,0,1);\n    for(float i=0.;i<2600.;i+=13.)\n    {\n        \n        float3 c=float3(1.0,1.0,1.0);\n\t\tO.rgb=MIX(O.rgb,c*CV(float3(\n\t\t\tiResolution.x*(1.+sin(iTime*0.52+(i-1400.)*1.35))*.5,\n\t\t\tiResolution.y*(1.+sin(iTime*0.73+(i-1200.)*1.61))*.5,\n\t\t\t0.0),I));\n    }\n    O.rgb=(1.-O.rgb)*1.01;\n    O.rgb=pow(O.rgb,float3(42.,32.,12.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdcW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 123, 123, 143], [149, 149, 180, 180, 290], [292, 292, 335, 335, 681]], "test": "untested"}
{"id": "wl3cW4", "name": "Day 375", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 22, "viewed": 566, "published": 3, "date": "1609104629", "time_retrieved": "2024-07-30T20:28:06.598038", "image_code": "// gradient noise from https://www.shadertoy.com/view/MtSSRz\n// PBR atmospheric scattering from Sebastian Lague video tutorial on youtube\n// value noise from shane\n// triplanar blending from Shane, who got it from Ryan Geiss\n// smooth ops from IQ\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    col *= vec3(0.95,0.98,1.04);\n    col *= exposure;\n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(1.1,1.,0.9)),0.4);\n    col = mix(acesFilm(col), col, 1.);\n    col *= 1. - dot(uv,uv*0.4)*2.1;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool hit = false;\n\n// Terrain\n#define marchSteps 240\n//#define marchEps  (mix(0.001,0.06,smoothstep(1.,0.,exp(-t*0.3) - 2.)))\n#define marchEps  (mix(0.001,0.26,smoothstep(0.,1.,t*0.1 - 2.)))\n\n\n#define planetSz 2984.\n#define atmoSz (planetSz/63.)\n \n#define groundOffs vec3(0,1.3,0)\n\n#define exposure 1.\n\n// Clouds\n\n#define cloudsLowerLimit 7.\n#define cloudsHigherLimit 17.\n\n#define cloudSteps 20.\n#define volumetricDithAmt 5.6\n\n// Wind\n\n#define windSteps 5.\n// Atmosphere\n#define sunCol vec3(1,0.9,0.6)*1.\n\n#define itersAtmo 14.\n#define itersOptic 14.\nconst float redLightLen = 740.;\nconst float greenLightLen = 550.;\nconst float blueLightLen = 450.;\n\nconst float transStrength = 0.02;\n\nfloat densFalloff = 1.5;\n\n\n#define SSS(a) clamp(map(p + sunDir*a).x/a,0., 1.)\n#define ao(a) clamp(map(p + (n*0.8 + sunDir)*a).x/a,0., 1.)\n\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\nfloat valueNoise(vec3 p, float pw);\nvec3 acesFilm(const vec3 x);\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\nfloat turbulentNoise(vec3 p);\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\nfloat atmosphericDensity( vec3 p);\nfloat opticalDepth(vec3 p, vec3 rd, float len);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView, vec3 sunPos);\nmat3 getRd(vec3 ro, vec3 lookAt, vec2 uv);\nvec3 getRdSpherical(vec3 ro, inout vec2 uv);\nvec3 hash3(vec3 p);\nfloat r21(vec2 p);\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p );\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n/*\nfloat r24(vec2 p){\n    return texture(iChannel0,)[ int(mod(p.x))];\n}*/\n\n \n\n\n\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    //p = smoothstep(0.,1.,p);\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec3 hash3(vec3 p) {\n\tp = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 r23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat turbulentNoise(vec3 p, bool md) {\n\tp += 8.;\n    vec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    //f = u;\n\tfloat n0 = dot(hash3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat n1 = dot(hash3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat n2 = dot(hash3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat n3 = dot(hash3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat n4 = dot(hash3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat n5 = dot(hash3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat n6 = dot(hash3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat n7 = dot(hash3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\tfloat ix2 = mix(n4, n5, u.x);\n\tfloat ix3 = mix(n6, n7, u.x);\n\n\tfloat ret = mix(mix(ix0, ix1, u.y), mix(ix2, ix3, u.y), u.z) * 0.5 + 0.5;\n\tret = ret * 1.;\n    \n    //ret = 1.- ret;\n    //ret = abs(ret);\n    if (md)\n        ret = mix(ret,smoothstep(0.3,1.,ret*0.8),0.6);\n    return ret;\n}\n\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )/atmoSz;\n    fact = max(fact, 0.0001);\n    return exp(-fact*densFalloff)*pow(max(1. - fact,0.),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView, vec3 sunPos){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    sunPos += offs;\n    \n    p += offs*1.;\n    \n    \n    float lenViewDirToEndOfAtmosphere = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    \n    if(hit){\n        atmoMarchLen = mix(t,lenViewDirToEndOfAtmosphere,smoothstep(0.,1.,t/50. - 1.));\n    } else {\n        atmoMarchLen = lenViewDirToEndOfAtmosphere;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPos - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\nmat3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    \n    uv *= 0.7;\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return mat3(right,up,dir); \n    //return normalize(dir + right*uv.x + up*uv.y);\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 getRdSpherical(inout vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    \n    vec2 ouv = uv;\n    uv += 0.5;\n    uv.y *= pi;\n    \n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    //vec3 lookAt = ro + offs;\n    //vec3 v = normalize(lookAt - ro);\n    vec3 v = offs;\n    //uv = ouv;\n    //uv.x = v.x;\n    //uv.y = v.y;\n    \n    return v;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n", "buffer_a_code": "\nvec3 getNormal(vec3 p);\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k );\nfloat valueNoiseCheap(in vec3 p,float pw);\n\n float t = 0.;\n\nfloat mapClouds(vec3 p){\n    float currHeight = p.y;\n    \n    p *= 0.25;\n    float cloudsRange = (cloudsHigherLimit - cloudsLowerLimit)*0.494;\n    float cloudsMid = cloudsLowerLimit + cloudsRange;\n    float f = turbulentNoise(p*0.6, true);\n    float fb = turbulentNoise(p*1.4, true);\n    f = (f*0.4 + turbulentNoise(p*0.5 + f*2. - fb*1.4 + iTime, true))*turbulentNoise(p*0.2 + 5.+ f*4., true);\n    f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    return f * 1.;\n}\n\n\n\nfloat grainNoise;\n\nvec2 getGround(vec3 p){\n    float d = p.y;\n    vec3 pp = vec3(p.x,4.,p.z)*0.6;\n    pp.x *= 0.5;\n    float n = turbulentNoise(pp, true);\n    float on = n;\n    n += turbulentNoise(pp*3., true)/2.*pow(n,0.4);\n    n += turbulentNoise(pp*3. + 4., true)/2.*pow(n,0.2);\n    n += turbulentNoise(pp*4., true)/2.*pow(n,0.4);\n    n += turbulentNoise(pp*6., true)/2.*pow(on,1.4);\n    \n    //n = pow((n),1.9);\n    \n    d -= n*0.2;\n    \n    pp = vec3(p.x,1.,p.z)*0.2 + 3.;\n    float h = valueNoise(pp,1.);\n    d -= h*1.3;\n    \n    grainNoise = smoothstep(0.3,0.85,turbulentNoise(vec3(p.x,0.,p.z)*(130.), false));\n    \n    d -= grainNoise*smoothstep(1.,0., t*0.04 )*0.0002;\n    \n        \n    \n    return vec2(d,1.);\n}\n\n\nvec2 getRocks(vec3 p){\n    float d = 10e4;\n    \n    float n = turbulentNoise(p*0.2, false);\n    \n    n = smoothstep(0.4,1.,n);\n    n += n*texture(iChannel1,p.xz*0.2).x*0.24;\n    \n    \n    d = p.y - n*1.7;\n    //n -= tex3D( sampler2D tex, in vec3 p, in vec3 n );\n    \n    \n    return vec2(d,2.);\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    vec2 gr = getGround(p);\n    float og = gr.x;\n    vec2 rocks = getRocks(p);\n    \n    rocks.x -= gr.x*0.5;\n    gr.x = opSmoothUnion( gr.x, rocks.x, 0.1 );\n    d = dmin(d,gr.x,gr.y);\n    \n    d = dmin(d,rocks.x,rocks.y);\n    d.y = mix(1.,2.,smoothstep(0.,1.,exp(-rocks.x) - exp(-og*3.1)*1.1));\n    \n    if(d.y == 1. || d.y == 2.){\n    }\n    return d;\n}\n\n\nvec3 getSun(vec2 uv, vec2 sunPos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevFrame = texture(iChannel2,fragCoord/iResolution.xy);\n    \n    // some taa\n    vec2 taaidx = r23(vec3(fragCoord,float(iFrame)))*4.;\n    fragCoord += float(iMouse.z>0.)*.6*vec2(sin(float(taaidx.x)*pi/4.),cos(float(taaidx.x)*pi/4.))*taaidx.y/4.;\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    \n    vec3 col = vec3(0);\n    \n    \n    \n    vec3 sunPos = vec3(1,.6 + sin(iTime)*.12*0.,1.)*2300.;\n    vec3 sunDir = normalize(sunPos);\n\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += iTime;\n    \n    \n    \n    \n    vec3 lookAt = vec3(0,0,ro.z + 15.*float(iMouse.z < 1.));\n    if (iMouse.z > 0.) {\n        vec2 muv = iMouse.xy/iResolution.xy;\n    \n        ro.xz -= vec2(cos(muv.x*6.),sin(muv.x*6.))*10.;\n           \n    }    \n    ro.y -= getGround(ro).x;\n    ro += groundOffs;\n    lookAt.y -= getGround(lookAt).x;\n    lookAt += groundOffs;\n    \n    \n    mat3 vp = getRd(ro,lookAt,uv);\n    \n    vec3 rd = vec3(uv,1.)*vp;\n    \n    //vec2 sunViewSpace = sunDir.xy;\n    \n    \n    // Marching\n    \n    vec3 p = ro;\n    vec2 d;\n    for(int i = 0; i < marchSteps ; i++){\n        d = map(p);\n        \n        \n        if(d.x < marchEps){\n            hit = true;\n            break;\n        } else if (t > 59.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x);\n    }\n    \n    \n    float depthView;\n    vec3 atmosphere = getAtmosphere(vec3(0,ro.y - 0.,0), rd, t, depthView, sunPos);\n    \n    \n    // Clouds\n    \n    float lowerCloudLimitDist = plaIntersect( ro - vec3(0,cloudsLowerLimit,0), rd, vec4(0,-1,0,0) );\n    float higherCloudLimitDist = plaIntersect( ro - vec3(0,cloudsHigherLimit,0), rd, vec4(0,-1,0,0) );\n    \n    float volumetricDith = r21(fragCoord + sin(iTime*20.)*20.)*volumetricDithAmt;\n    vec3 cloudP = ro + rd * ( lowerCloudLimitDist + volumetricDith );\n    float cloudLength = higherCloudLimitDist - lowerCloudLimitDist; \n    float cloudStepSz = cloudLength/(cloudSteps);\n    \n    float cloudDensTotal = 0.;\n    vec3 cloudAccum = vec3(0.);\n    \n    \n    for(float i = 0.; i < cloudSteps ; i++){\n        float d = mapClouds(cloudP);\n        \n        float difffact = clamp( d*1. - mapClouds(cloudP + sunDir*1.4)*1.1  + 0.12, 0., 1. );\n        vec3 diff = mix( atmosphere*0.1 + vec3(0.04,0.11,0.2)*(0.4 - smoothstep(0.,1.,1. - atmosphere*1.8)*0.4), (vec3(1,0.9,0.9)*1. + sunCol*0.4 + atmosphere*.4)*0.5, difffact );\n        vec3 absorption = mix( vec3(1,0.9,0.8), vec3(1,0.9,0.7)*0.5, clamp( cloudDensTotal*0.5, 0., 1. ) );\n        vec3 fringe = vec3(0.9,0.8,0.5)*clamp( 1. - d*4., 0.,1.);\n        \n        d = d*(1.-cloudDensTotal)*cloudStepSz;\n        \n        cloudDensTotal += d;\n        cloudAccum += d*(diff*3.7*absorption + fringe*(0.1 + diff*0.9)*2.64);\n\n        // map(cloudP).x < 0.\n\n            \n        if( cloudDensTotal > 1.){\n            break;\n        }\n        cloudP += rd*cloudStepSz;\n    }\n    \n    \n    // Wind\n    vec3 windP = ro + rd*volumetricDith*0.00 ;\n    float windStepSz = min(t,14.)/windSteps;\n    \n    float windAccum = 0.;\n    //vec3 windAccum = vec3(0.);\n    \n    for(float i = 0.; i < windSteps ; i++){\n        vec3 wp = windP*0.51 - vec3(-iTime*3.,smoothstep(0.,1.,windP.y*0.5 - 1.9),0.);\n        float dens = valueNoise(wp,1.);\n        dens = pow(dens,1.1)*0.035;\n        dens *= smoothstep(1.,0.,windP.y*0.15 + 0.4);\n        \n        windAccum += dens*(1.-windAccum)*windStepSz;\n        \n        if( windAccum > 1.){\n            break;\n        }\n        windP += rd*windStepSz;\n    }\n        \n    \n    // Coloring\n    \n    vec3 hitCol = vec3(0);\n    vec3 ambientCol = atmosphere*1.;\n    float ambianceScale = 0.4;\n    if(hit){\n        vec3 n = getNormal(p);\n        vec3 hf = normalize(sunDir - rd);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),6.);\n        float fres = pow( 1. - max(dot( n, -rd),0.001),5.);\n        fres = max(fres,0.);\n        \n        vec3 albedo = vec3(1.,0.5,0.2)*0.8;\n        \n        float rockiness = d.y - 1.;\n        rockiness = clamp(rockiness,0.,1.);\n        \n        albedo = mix(albedo,vec3(0.1,0.1,0.1),rockiness);\n        //float shad = softshadow( p - n * 0.04, sunDir, 1., 5., 2. )*0.;\n        hitCol += albedo*(sunCol + atmosphere);\n        float AO = ao(1.9)*ao(0.2)*ao(4.2)*ao(0.8)*2.;\n        \n        float shad = diff;\n        vec3 sand = hitCol;\n        vec3 grains = grainNoise*(sunCol + hitCol*0.9);\n        grains = mix(grains*0.1 + 0.1, vec3(0.3),smoothstep(1.,0.,exp(-max(t,0.001)*0.05)));\n        {\n\n            sand += (spec + fres*0.4)*grains*.4;\n            sand = mix( (sand*vec3(0.4,0.1,0.1) + ambientCol*0. + sunCol*(1. - diff)*0.04)*ambianceScale,sand*2.,shad);\n            sand = mix( (sand*0. + ambientCol*0.04)*ambianceScale,sand,AO);\n        }\n        vec3 rock = hitCol;\n        {\n            vec3 grains = grainNoise*(sunCol + hitCol*0.9);\n            grains = mix(grains*0.1 + 0.1, vec3(0.3),smoothstep(1.,0.,exp(-t*0.05)));\n\n            rock += (spec + fres*0.4)*grains*.4;\n            rock = mix( (rock*vec3(0.4,0.1,0.1) + ambientCol*0. + sunCol*(1. - diff)*0.04)*ambianceScale,rock*2.,shad);\n            rock = mix( (rock*0. + ambientCol*0.04)*ambianceScale,rock,AO);\n        }\n        \n        hitCol = mix(sand,sand,rockiness);\n        hitCol = sand;\n        \n    }\n\n\n    // Compositing\n    \n    col += hitCol;\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t)*.04 ),2.);\n    }\n    \n    atmosphere += getSun(rd.xy, sunDir.xy);\n    float depthViewFac = smoothstep(0.,1.,exp(-depthView*0.02) + exp(-t*0.4));\n    \n    col = col * depthViewFac + atmosphere; \n    \n    if (!hit  && lowerCloudLimitDist > 0.){\n        cloudAccum = mix(cloudAccum,col,clamp(1.-exp(-lowerCloudLimitDist*0.01 + 0.4),0.,1.));\n        col = mix(col,cloudAccum*1. , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),4.));\n    }\n    windAccum *= smoothstep(0.,1.,t*0.2 - 1.);\n    col = (col - windAccum) + 4.*windAccum*vec3(1,0.77,0.5);\n    \n    /*\n    \n    col *= vec3(0.95,0.98,1.04);\n    col *= exposure;\n    \n    col = mix(col,smoothstep(0.,1.,col*1.3),0.3);\n    col = mix(acesFilm(col), col, 1.);\n    col *= 1. - dot(uv,uv*0.4)*2.1;\n    \n    col = pow(col,vec3(0.454545));\n    */\n    if(iFrame >1 && iMouse.z < 1.){\n        fragColor = mix(prevFrame, col.xyzz,0.25);\n    } else {\n        fragColor = col.xyzz;\n    }\n    //fragColor = vec4(col,1.0);\n}\n\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n}\n\n\nvec3 getSun(vec2 uv, vec2 sunPos){\n    \n    vec2 sunUVOriginal = uv;\n    \n    vec2 sunUV = uv - sunPos;\n    // sun\n    vec3 sun = sunCol*smoothstep(0.07,0.,length(sunUV));\n    sun += sunCol*vec3(1.,0.4,0.6)*smoothstep(0.1,0.,length(sunUV));\n    sun += sunCol*vec3(0.7,0.4,0.6)*smoothstep(0.3,0.,length(sunUV))*0.5;\n    sun += sunCol*vec3(0.3,0.4,0.6)*smoothstep(0.6,0.,length(sunUV))*0.35;\n    \n    \n    // rays\n    \n    \n    vec3 sunRays = 0.4*sunCol * smoothstep(0.015*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n    \n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi/8./1.);\n        float mda = sin(i*pi/4.);\n        float mdb = sin(i*pi/2.);\n        float w = 0.03;\n        float l = 0.1;\n        sunRays += (sunCol) *\n            mix(.8,.1,smoothstep(0.,0.25 +  sin(i*pi/ 4. + iTime)*0.1,length(sunUV))) *\n            smoothstep(w + mda*w/4.,0.,abs(sunUV.y))*smoothstep((l + mdb*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVOriginal - sunPos;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunPos;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    // flares\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return sun + sunRays + flares*3.*sunCol;\n}\n\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3cW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 306, 306, 733]], "test": "untested"}
{"id": "tt3yW4", "name": "Vesica3D", "author": "yasuo", "description": "Vesica3D", "tags": ["vesica"], "likes": 6, "viewed": 319, "published": 3, "date": "1609077222", "time_retrieved": "2024-07-30T20:28:07.353019", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVesica3D(vec3 p, float r, float h, float d ) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return sdCappedCylinder(p,r,h);\n}\n\nvec4 GetDist(vec3 p) {\n    float t = iTime*1.1;\n    p*=matRotateX(radians(90.0));\n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = 1.0;\n    \n    vec3 pos = vec3(0.0,0.0,-y);\n    \n    p+=pos;\n    p*=matRotateY(radians(30.0*t))*matRotateZ(radians(20.0*t));\n    \n    p.xz = DF(vec2(p.x,p.z),4.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(0.6);\n    \n    float d = sdVesica3D(p*matRotateY(radians(45.0)),0.3,0.05,0.2);\n\n    p = prevP;\n    p+=pos;\n    p*=matRotateY(radians(20.0*t));\n    p.xz = DF(vec2(p.x,p.z),8.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(1.2);\n    \n    float d2 = sdVesica3D(p*matRotateY(radians(45.0)),0.3,0.05,0.2);\n\n    p = prevP;\n    p+=pos;\n    p*=matRotateY(radians(25.0*t));\n    p.xz = DF(vec2(p.x,p.z),16.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(1.8);\n    \n    float d3 = sdVesica3D(p*matRotateY(radians(45.0)),0.3,0.05,0.2);\n    \n    p = prevP;\n    p+=pos;\n     p*=matRotateY(radians(30.0*-t));\n    p.xz = DF(vec2(p.x,p.z),12.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(1.5);\n    \n    float d4 = length(p)-0.1;\n        \n    p = prevP;\n    p+=pos;\n    p*=matRotateY(radians(30.0*-t))*matRotateZ(radians(40.0*-t));\n    p.xz = DF(vec2(p.x,p.z),6.0);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(0.9);\n    \n    float d5 = length(p)-0.1;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+p.xyz+vec3(0,1,2));\n    vec4 res = vec4(col,min(d,min(d2,min(d3,min(d4,d5)))));\n        \n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,5,3);\n    \n    lightPos.yz *= Rot(radians(-60.0));\n    lightPos.xz *= Rot(iTime*.3+1.0);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.6;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-60.0));\n    ro.xz *= Rot(iTime*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[635, 635, 687, 687, 794], [796, 796, 850, 850, 920], [922, 922, 944, 944, 2350], [2352, 2352, 2385, 2385, 2638], [2640, 2640, 2664, 2664, 2865], [2867, 2867, 2890, 2890, 3278], [3280, 3280, 3322, 3322, 3517], [3519, 3519, 3576, 3576, 4255]], "test": "untested"}
{"id": "WltcWr", "name": "Aperiodic Hypercube Tile Weave", "author": "Shane", "description": "Playing around with Zhao Liang's interpretation of Greg Egan's aperiodic hypercube projection routines to produce a triangular tiled weave.", "tags": ["tile", "penrose", "hypercube", "lattice", "aperiodic", "weave", "ammann", "beenker", "pentagrid"], "likes": 62, "viewed": 1158, "published": 3, "date": "1609073478", "time_retrieved": "2024-07-30T20:28:08.445099", "image_code": "/*\n\n    Aperiodic Hypercube Tile Weave\n    ------------------------------\n    \n    In short, this is an orthonormal projection of a five-demensional \n    hypercube lattice (pentagrid) onto a particularly aligned 2D plane. The\n    result is a versatile aperiodic tiling of rhomboids -- which have been\n    split along the short opposite diagonals to produce a triangular tiling. \n    If you look more closely at the resultant default pattern, you should be \n    able to make out some hidden icosahedral shapes.\n\n    More times than I can count, someone has dropped some exceptionally\n    nice code onto Shadertoy demonstrating a concept that is difficult\n    to find code for. The other day Zhao Liang posted a rough pixel shader \n    translation of Greg Egan's aperiodic hypercube tiling example written \n    in Javascript, which in turn was based on de Bruijn's algebraic approach \n    to aperiodic tiling -- The link to Zhao Liang's work is below.\n    \n    Virtually all of the difficult work was put together by Zhao Liang and\n    Grey Egan. All I've done is rearrange things a little and utilize it.\n    By the way, others on Shadertoy have produced similar code, like \n    Knighty's really nice \"Cut n'project\" example (link below), but I like \n    the way Zhao's code was presented, so went with that.\n    \n    The theory behind the method is such a clever piece of applied \n    mathematics that it's difficult to do it justice with a simple example. \n    The explanation as to why this particular method works and the history \n    behind the initial discovery is fascinating and really clever, but kind \n    of lengthy, so I've provided a list of examples and references below that \n    should explain it better than I can.\n    \n    I seem to say this a lot, but this isn't my area, so any corrections or\n    suggestions for improvement are always welcome.\n\n\n\n    Other Examples:\n    \n    // Zhao Liang's Shadertoy example. I've always wanted to produce one\n    // of these patterns using this method, so was pretty happy to see it.\n    Impossible aperiodic tiling - neozhaoliang\n    https://www.shadertoy.com/view/wsKBW1  \n    \n    // Also involves 5D projection. Very nice, and explained well. \n    Cut n'project - knighty\n    https://www.shadertoy.com/view/XdtBzH\n    //\n    // A related tiling. I'd like to do a standalone version along \n    // these lines too at some stage.\n    Ammann-Beenker - knighty\n    https://www.shadertoy.com/view/MddfzH\n    \n    \n    References:\n    \n    deBruijn -- Mathematical Details - Greg Egan\n    https://www.gregegan.net/APPLETS/12/deBruijnNotes.html\n    \n    Penrose Tilings -- Tied up in Ribbons\n    http://www.ams.org/publicoutreach/feature-column/fcarc-ribbons\n    \n    Penrose Tiling - Andrejs Treibergs\n    http://www.math.utah.edu/~treiberg/PenroseSlides.pdf\n    \n   \n*/\n\n\n\n// Random weave, or not. With a PN value of 5 or more, the patterns are\n// still interesting.\n#define RANDOM\n\n// Display the weave.\n#define WEAVE\n\n// Display the points.\n#define POINTS\n\n///////\n\n// Number of grid directions, which relate to the hypercube dimension. \n// I stuck with the original 5, as it looks nicest. However, I modified\n// things slightly so that it will work with other numbers -- about \n// 3 to 9. More than that and the pattern gets too tight. PN of 3 will \n// give you back a basic isometric grid -- subdivided into triangles.\n#define PN 5\n\n// As Zhao Liang pointed out, halving the grid numbers is the correct way to \n// handle even grid numbers, as it will result in an Ammann-Beenker tiling.\n// However, not doing so will still produce an interesting tiling pattern. \n// For instance, choosing \"PN = 4\" and commenting out the following will produce \n// a basic Truchet pattern.\n#define AMMANN_BEENKER\n\n\n \n\n// Note: I've left Zhao Liang's functions and comments largely untouched, but have\n// rewritten them to make it a litle more compact. However, that wouldn't necessarily\n// translate to speed or readability, so if you're interested in this kind of thing, \n// I'd strongly suggest referring to the original code, and perhaps looking at \n// Greg Egan's original Javascript.\n\n// Grid directions.\nvec2[PN] grid; \n// Five individual grid shift values. \nfloat[PN] shift; \n\n// The rhombus information.\nstruct Rhombus{\n\n    // r, s for the r-th and s-th grids.\n    int r, s;\n    // kr, ks, for the lines in the two grids.\n    float kr, ks;\n    \n    // Local coordinates and center.\n    vec2 p, cent;\n \n    // Rhombus vertices.\n    vec2[4] vert; \n \n}; \n \n\n// Find the vertices of the rhombus corresponding to the intersection point P,\n// where P is the intersection of the kr-th line and ks-th line in the r/s grids.\nvoid rhombusVerts(int r, int s, float kr, float ks, out vec2[4] vert){\n \n    // Produce points with +/- coordinates in intersection dimensions to \n    // complete projection... I was too lazy to double check this, but it\n    // seems to project to the plane as advertised, so that's good enough\n    // for me. :)\n    vec2 pI = grid[r]*(ks - shift[s]) - grid[s]*(kr - shift[r]);\n    pI = vec2(-pI.y, pI.x)/grid[s - r].y;\n  \n     \n    // Convert to screen coordinates.\n    vec2 sum = grid[r]*kr + grid[s]*ks;\n    for(int k=0; k<PN; k++) {\n    \n       // Intersection point notwithstanding, project the other points to \n       // the \"m + 1\"-th line in the k-th grid.\n       if(k != r && k != s) sum += grid[k]*ceil(dot(pI, grid[k]) + shift[k]); \n    }\n     \n    // Four vertices.\n    vert[0] = sum, vert[1] = sum + grid[r], vert[3] = sum + grid[s];\n    vert[2] = vert[1] + grid[s];\n\n}\n \n \n// Determine which rhombus the transformed point lies in by iterating over all possible \n// combinations... Part of me wonders whether there is a faster way, but GPUs are fast\n// anyway and for \"PN = 5,\" this is at most 40 checks (or thereabouts), which is more\n// than doable.\nRhombus rhombusInfo(vec2 p){\n\n\n    // Initate the rhombus struct.\n    Rhombus rb;\n    rb.p = vec2(0);\n    rb.vert = vec2[4](vec2(0), vec2(0), vec2(0), vec2(0));\n    \n    float[PN] pindex;\n\n    float theta;\n    for(int k=0; k<PN; k++){\n    \n        // Initiate the grid directions -- We choose the fifth roots of unity.\n        // Note the 1e-5 on the end. It's a hack I've added to make it work\n        // with other odd PN values. The tiny extra shift is a hack to get it\n        // working when PN is three.\n        shift[k] = 1./float(PN) + (PN==3? 1e-5 : 0.); // Penrose.\n        //shift[k] = hash21(vec2(k) + iDate.w)*.999 + .001; // Random shift option.\n        //shift[k] = .5; // Etc.\n        \n        #ifdef AMMANN_BEENKER\n        // Halve the number of grids for even numbers. \n        theta = PI/float(PN)*float(k)*((PN%2 == 1)? 2. : 1.);\n        #else\n        // The correct way to handle even numbered grids occurs above. However, you \n        // can still achieve a nice tiling pattern with double the grid numbers.\n        theta = PI*2./float(PN)*float(k);\n        #endif\n       \n        grid[k] = vec2(cos(theta), sin(theta));\n        \n        // Project the point to the m-th line in the k-th grid.\n        pindex[k] = (dot(p, grid[k]) + shift[k]);\n        \n   \n        // DeBruijn_transform.\n        // This is the \"continous\" transformation that maps a pixel to its position in the tiling\n        rb.p += grid[k]*pindex[k]; // Project \"p\" to the k-th grid;\n         \n    } \n    \n    \n    // Iterate over all rhomboids to determine which one we're inside, then return\n    // the pertinent information, like vertices, etc.\n    for(int r = 0; r<PN - 1; r++){\n    \n        for(int s = r + 1; s<PN; s++){\n        \n            // Thanks to Zhao Liang for realizing that even grid numbers\n            // require extra rhomboid searches.\n            for(int drs = 0; drs<9; drs++){\n                \n                // Odd numbered grids only require a 2x2 search. This is a\n                // hacky way to get around that.\n                if(PN%2==1 && drs<4) continue;\n                \n                float kr = floor(pindex[r]) + float((drs/3) - 1);\n                float ks = floor(pindex[s]) + float((drs%3) - 1);\n                rhombusVerts(r, s, kr, ks, rb.vert);\n\n                if(sdPoly4(rb.p, rb.vert)<=0.){\n\n                    rb.r = r, rb.s = s, rb.kr = kr, rb.ks = ks;\n                    r = s = PN; // Forcing a complete break?\n                    drs = 9;\n                    break;\n                }\n                \n            }\n       }         \n    }\n \n    // I noticed that the winding order was backward on some rhombuses, so\n    // had to fix that.\n    if(winding(rb.vert)>0.){\n       swap(rb.vert[0], rb.vert[2]);\n    }\n    \n    // Rhombus center.\n    rb.cent = (rb.vert[0] + rb.vert[1] + rb.vert[2] + rb.vert[3])/4.;\n    \n    return rb; // Return the rhombus.\n\n}\n\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale.\n    float gSc = 3.;\n    // Readjusting the scale for different dimensions.\n    if(PN==3) gSc += 1.; \n    if(PN>5) gSc = max(3. - float(PN - 5)*.5, 1.5);\n    \n    // Smoothing factor.\n    float sf = gSc*2./iResolution.y;\n    \n    // Scaling and translation.\n    vec2 p = uv*gSc + iTime/4.;\n    \n\n    // Obtain the rhombus information. This includes local coordinates\n    // and vertices.\n    Rhombus rh = rhombusInfo(p);\n    \n    \n   \n    // Rhobus vertices and mid edge points.\n    vec2[4] v = rh.vert; \n    vec2[4] e;\n    e[0] = mix(v[0], v[1], .5), e[1] = mix(v[1], v[2], .5);\n    e[2] = mix(v[2], v[3], .5), e[3] = mix(v[3], v[0], .5);\n    \n    // Mid edge point normals.\n    vec2[4] n;\n    n[0] = normalize(v[0] - v[1]).yx*vec2(1, -1), n[1] = normalize(v[1] - v[2]).yx*vec2(1, -1);\n    n[2] = normalize(v[2] - v[3]).yx*vec2(1, -1), n[3] = normalize(v[3] - v[0]).yx*vec2(1, -1);\n \n     \n    // Splitting the rhombus across the shortest opposite edge distance into two triangles.\n    float shortest = length(v[0] - v[2]);\n    int ind2 = length(v[0] - v[2])<length(v[1] - v[3])? 0 : 1;\n \n    // Determine which triangle we're in.\n    float wt = line(rh.p, v[ind2], v[(ind2 + 2)%4]);\n    int triIndex = wt<0.? 0 : 1;\n   \n    // Triangle information.\n    vec2[3] tri0;\n    if(triIndex == 0) tri0 = vec2[3](v[ind2], v[(ind2 + 1)%4], v[(ind2 + 2)%4]);\n    else tri0 = vec2[3](v[ind2], v[(ind2 + 2)%4], v[(ind2 + 3)%4]);\n    // Triange center.\n    vec2 triCent = (tri0[0] + tri0[1] + tri0[2])/3.;\n    \n    // The triangle distance field.\n    float tri = sdTriR(rh.p, tri0[0], tri0[1], tri0[2]);\n    \n    // Triangle ID.\n    int index = ((rh.r + rh.s)*2 + triIndex);\n    \n    // Using the ID for some color.\n    vec3 oCol = .5 + .45*cos(6.2831*(float(index))/float(PN*PN*2)*2. + vec3(0, 1, 2) - .25);\n    vec3 oCol2 = .5 + .45*cos(6.2831*dot(triCent, vec2(1))/float(PN*2) + vec3(0, 1, 2) - .25);\n    //oCol = vec3(float(index)/50.);\n    oCol = mix(oCol, pow(oCol*oCol2, vec3(.65))*2., .25); \n    oCol = mix(oCol, oCol.xzy, float(index)/float(PN*PN)/2.*3./6.);  \n    \n     // Initializing the scene background color.\n    vec3 col = vec3(.1);\n    \n    // Line width.\n    float lw = .02;\n    \n    // Render the colored background triangles.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., tri))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, tri));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, tri + lw));       \n    \n    /*\n    // Incircles (Uncomment the incircle routine also).\n    vec3 sCol = col;\n    vec3 inCB = inCentRad(tri0[0], tri0[1], tri0[2]);\n    float cir = length(rh.p - inCB.xy) - inCB.z/1.25;// + .015;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, cir))*.9);\n    col = mix(col, mix(sCol*1.5, vec3(1), .0), (1. - smoothstep(0., sf, cir + .03)));\n    */\n    \n    // Indices for shuffling, in order to render the chords in random order.\n    const int N2 = 4;\n    int shuff[N2] = int[N2](0, 1, 2, 3);  // Initializing the shuffle array.\n\n    #ifdef RANDOM   \n    // Shuffling the variable array of points and normals -- Six is the maximum. I think this \n    // is the Fisher–Yates method, but don't quote me on it. It's been a while since I've used \n    // a shuffling algorithm, so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    //int index = N;\n    for(int i = N2 - 1; i>0; i--){\n\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each edge position.\n        float rs = hash21(rh.cent + fi/float(N2));\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*float(index)*1e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(shuff[i], shuff[j]);\n \n     }\n     #endif  \n     \n     \n     \n    \n    #ifdef WEAVE\n    // Using the rhombus mid edge points to create a weave. \n    \n    const float aW = .06; // Chord width.\n    float tightness = 3. + (float(PN) - 3.)/4.;\n    if(PN%2==0) tightness = 3.25;\n    #ifdef AMMANN_BEENKER\n    // More hacks to help everything work. \"One size fits all\" options can\n    // get messy. :)\n    if(PN>=8) tightness =  3. + (float(PN) - 3.)/4.;\n    #endif\n    \n    // Combining the mide edge points and normals.\n    vec4[4] p4 = vec4[4](vec4(e[0], n[0]), vec4(e[1], n[1]), vec4(e[2], n[2]), vec4(e[3], n[3]));\n\n    // Chord tighness.\n    float cr = length(p4[shuff[0]].xy - p4[shuff[1]].xy)/tightness;\n    // Chord distances.\n    float arc = doSeg(rh.p, p4[shuff[0]], p4[shuff[1]], cr) - aW;\n    cr = length(p4[shuff[2]].xy - p4[shuff[3]].xy)/tightness;\n    float arc2 = doSeg(rh.p, p4[shuff[2]], p4[shuff[3]], cr) - aW;\n\n    // Rndering the chords, or arcs.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., arc))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, arc));\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, arc + lw*1.6));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., arc2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, arc2));\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, arc2 + lw*1.6));\n    #endif\n\n    #ifdef POINTS\n    // Rhombus mid edge points... I think that add visual interest,\n    // but I could be wrong. :)\n    for(int i = 0; i<4; i++){\n    \n        float dv = length(rh.p - e[i]) - .1; //\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(1, .7, .6), 1. - smoothstep(0., sf, dv + lw*1.6));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .1 - lw));\n    }\n    #endif\n  \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "#define PI 3.141592653 \n\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n//#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n\nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\nvoid swap(inout vec2 a, inout vec2 b){ vec2 tmp = a; a = b; b = tmp; }\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// A random hash that I made up a while back. It's based on a few things\n// I've come across, but is mostly experimental. If it doesn't work on \n// your system, feel free to let me know.\nfloat hash21(vec2 p) {\n    \n    p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n}\n\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n// IQ's distance to a regular polygon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV2 4\n//\nfloat sdPoly4(in vec2 p, in vec2[NV2] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// Rounded triangle routine. Not used here, but handy.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2){\n     \n    vec3 inC = inCentRad(v0, v1, v2);\n    float ndg = .09/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .08;      \n        \n} \n\n// Vertice winding order... It works fine, but there'd be better ways.\nfloat winding(in vec2[NV2] v){\n\n    const int num = v.length();\n    float sum = 0.;\n    for (int i = 0; i < num; i++) {\n        vec2 v1 = v[i];\n        vec2 v2 = v[(i + 1)%num];\n        sum += (v2.x - v1.x)*(v2.y + v1.y);\n    }\n    \n    return sum>0.? 1. : -1.;\n}\n\n// Determines which side of a line a pixel is on. Zero is the threshold.\nfloat line(vec2 p, vec2 a, vec2 b){\n     return ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x));\n}\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = r;//length(b.xy - a.xy)/3.25;//1.732/6.; // ;//\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n//    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltcWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtcyDN", "name": "Water Paint", "author": "smkgames", "description": "Water Paint", "tags": ["paint", "multipass"], "likes": 1, "viewed": 563, "published": 3, "date": "1609065106", "time_retrieved": "2024-07-30T20:28:09.264907", "image_code": "void mainImage( out vec4 O, vec2 U ) { \n    \n    O = texture( iChannel1,texture( iChannel0,U/iResolution.xy ).xy );\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U)            texelFetch( iChannel0, ivec2(U), 0 )\n#define hue(v)        ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/llySRh\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define keyDown(a)    ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n#define S(v)            smoothstep( 1.5, 0., v )\n\n", "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n\n    vec2 R = iResolution.xy, U = u / R.y, P,m;\n    vec4 M = iMouse;\n    O = T(u);                                                        // restore previous state\n    if (iFrame<1 || keyDown(64+3) )                                  // start or 'C': reset\n        O = vec4(u / R.xy,0.,0.);\n    //  O = vec4(keyToggle(32)), O.w=1.;\n    if keyDown(64+6)  O = T(0);                                      // 'F': fill with color\n    if keyDown(64+20) O = texture(iChannel1,U);                      // 'T': wood texture bg\n    if ( u == vec2(1.5) ) { O.xy = M.xy; return; }                   // memo prev mouse\n    if ( u == vec2(.5) ) {\n        if ( M.z > 0. && ( M.x/R.y < .1 || keyClick(64+16)) )        // choose color in palette or pick in paint\n            O = T(M.xy), O /= O.w; \n    //  else if keyDown(32) O.rgb = 1.-O.rgb;                        // inverse at switch colors mode\n        if keyDown(64+19) O.rgb = -O.rgb;                            // 'S': switch to negative colors\n        return;\n    }\n \n    \n    P = M.w > 0. ? M.xy : T(1).xy;                                   // prev mouse or start stroke \n    m = abs( (M.xy+P)/2. - u ) - abs(M.xy-P)/2.;                     // for bounding box\n    \n    if (M.z > 0.  && M.xy != P )                                     // paint\n      if ( max(m.x,m.y)< 20. )                                       // optim: bounding box\n        for( float  l = length(M.xy-P), d = 0.; d < l ; d++ )\n        O +=  S( length( mix( M.xy, P, d/l ) - u ) - 20. ) / 20. * vec4(1.,0.,0.,0.); \n        \n//  if keyDown(32) O.rgb = O.w - O.rgb;                              // inverse at switch colors mode\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 118]], "test": "untested"}
{"id": "WlcyWN", "name": "Suck Shader", "author": "smkgames", "description": "suck", "tags": ["paint", "multipass", "suck"], "likes": 7, "viewed": 396, "published": 3, "date": "1609058021", "time_retrieved": "2024-07-30T20:28:10.106657", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 buffer0 = texture(iChannel0,fragCoord/iResolution.xy).xy;\n\n    fragColor = texture(iChannel1,buffer0);\n\n    //fragColor = vec4(buffer0,0.,0.);\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define brushSize 0.08\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec4 buffer = texture(iChannel0, fragCoord-fragCoord);\n\n\n\nif(fragCoord == vec2(.5)){\nfragColor = iMouse;\n}else{\nif(iFrame<1){\nfragColor = (fragCoord/iResolution.xy).xyxy;\n}else{\nfloat circle = exp(-length(iMouse.xy-fragCoord)*brushSize);\nfragColor = texture(iChannel0, vec2(fragCoord-circle*(iMouse-vec4(fragCoord.xy,0.,0.)).xy)/iResolution.xy);\n}\n\n}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 215]], "test": "untested"}
{"id": "Wt3yWN", "name": "Visible Spectrum", "author": "redmenace07", "description": "Pixel values by frequency ranging from 400 THz at uv.x = 0 to 790 THz at uv.x = 1. https://en.wikipedia.org/wiki/Visible_spectrum", "tags": ["spectrum"], "likes": 1, "viewed": 296, "published": 3, "date": "1609048152", "time_retrieved": "2024-07-30T20:28:11.062102", "image_code": "vec3 pixelFromFreq(float freq /* x100 THz */ ) {\n    return step(4.0, freq) * step(freq, 5.2) * vec3(1.0, (freq - 4.0)/1.2, 0.0)\n        + step(5.2, freq) * step(freq, 5.65) * vec3(1.0 - (freq - 5.2)/0.45, 1.0, 0.0)\n        + step(5.65, freq) * step(freq, 6.1) * vec3(0.0, 1.0, (freq - 5.65)/0.45)\n        + step(6.1, freq) * step(freq, 6.45) * vec3(0.0, 1.0 - (freq - 6.1)/0.35, 1.0)\n        + step(6.45, freq) * step(freq, 7.9) * vec3((freq - 6.45)/1.45, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float freq = 4.0 + 3.9 * uv.x;\n\n    vec3 col = pixelFromFreq(freq);\n\n    // Output to screen\n    fragColor = vec4(col * 0.1 * (step(0.008, mod(freq, 0.5)) + 9.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3yWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 469], [471, 471, 528, 578, 793]], "test": "untested"}
{"id": "Wt3cDH", "name": "Dodecahedral Permutations", "author": "mla", "description": "Even permutations of 5 elements correspond to rotations of a dodecahedron.", "tags": ["quaternion", "stereographic", "dodecahedron", "permutation", "a5", "slerp"], "likes": 16, "viewed": 374, "published": 3, "date": "1608977662", "time_retrieved": "2024-07-30T20:28:11.902854", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Dodecahedral Permutations, Matthew Arcus, mla, 2020\n// The alternating group A5 as rotations of a dodecahedron.\n// \n// The group A5 (the group of even permutations of five objects) has\n// 60 elements, there are 60 rotations of a dodecahedron & in fact\n// the two groups are isomorphic.\n//\n// The isomorphism can be constructed as follows: color the\n// dodecahedron vertices as for the compound of five tetrahedra;\n// there is then one diagonal for each color pair, and the end\n// vertices of each diagonal are each adjacent to three vertices in\n// the three remaining colours, so to select permutation\n// c0,c1,c2,c3,c4, find diagonal c0-c4, rotate so c0 is 'uppermost',\n// then rotate about diagonal to put c1,c2,c3 in correct positions.\n//\n// Here the dodecahedron vertices are stereographically projected to\n// the plane, then rotated to form the sixty A5 permutations with the\n// colors, in order BRGBY, of the central vertex, the three vertices\n// around the centre, clockwise from top, and the outermost vertex.\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Dodecahedron vertices, aligned with z-axis.\n// vertex[i] = -vertex[(i+10)%20]\nconst int N = 20; // Number of vertices\nvec3 vertex[N] = vec3[]\n  (vec3(0,0,1),\n\n   vec3(0,0.6667,0.7453),\n   vec3(0.5773,-0.3333,0.7453),\n   vec3(-0.5773,-0.3333,0.7453),\n\n   vec3(-0.5773,0.7453,0.3333),\n   vec3(-0.9342,0.1274,0.3333),\n   vec3(-0.3568,-0.8727,0.3333),\n   vec3(0.3568,-0.8727,0.3333),\n   vec3(0.9342,0.1273,0.3333),\n   vec3(0.5773,0.7453,0.3333),\n\n   vec3(0,0,-1),\n\n   vec3(0,-0.6667,-0.7453),\n   vec3(-0.5773,0.3333,-0.7453),\n   vec3(0.5773,0.3333,-0.7453),\n\n   vec3(0.5773,-0.7453,-0.3333),\n   vec3(0.9342,-0.1274,-0.3333),\n   vec3(0.3568,0.8727,-0.3333),\n\n   vec3(-0.3568,0.8727,-0.3333),\n   vec3(-0.9342,-0.1273,-0.3333),\n   vec3(-0.5773,-0.7453,-0.3333));\n\n// Compound of five tetrahedra colouring.\nint colorindex[N] = int[] (0,1,2,3,4,2,4,1,4,3, 4,2,3,1,3,0,2,0,1,0);\n\nvec3 color[6] = vec3[](vec3(0),vec3(1,0,0),vec3(0,1,0),\n                       vec3(0,0,1),vec3(1,1,0),vec3(0.9));\n\n// Quaternions\n\n// R3 rotation of p with quaternion q\nvec3 qrot(vec3 p, vec4 q) {\n  return p + 2.0*cross(q.xyz,cross(q.xyz,p)+q.w*p);\n}\n\nvec4 qpow (vec4 q, float t) {\n  // Maybe use an approximation for small q.xyz\n  if (q.xyz == vec3(0)) return vec4(vec3(0),pow(q.w,t));\n  float r = length(q);\n  float phi = acos(q.w/r);\n  vec3 n = normalize(q.xyz);\n  return pow(r,t)*vec4(sin(t*phi)*n,cos(t*phi));\n}\n\n// For normalized q\nvec4 qpow1 (vec4 q, float t) {\n  if (q.xyz == vec3(0)) return vec4(0,0,0,1);\n  float phi = acos(q.w);\n  vec3 n = normalize(q.xyz);\n  return vec4(sin(t*phi)*n,cos(t*phi));\n}\n\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 qconj(vec4 p) {\n  return vec4(-p.xyz,p.w);\n}\n\nvec4 qinv(vec4 p) {\n  return qconj(p)/dot(p,p);\n}\n\nvec4 qdiv(vec4 p, vec4 q) {\n  return qmul(p,qinv(q));\n}\n\nvec4 qabs(vec4 p) {\n  // Convert to quaternion with q.w >= 0\n  return p.w >= 0.0 ? p : -p;\n}\n\n// slerp: spherical interpolation between q0 and q1\n// This is basically (q1/q0)^t * q0\n// Be careful with operation order here.\n// Assumes q0,q1 normalized so q1/q0 = q1*q0'\n// The qabs ensures we go the short way round.\nvec4 slerp(vec4 q0, vec4 q1, float t) {\n  return qmul(qpow1(qabs(qmul(q1,qconj(q0))),t),q0);\n}\n\n#define DEFSWAP(T) \\\nvoid swap(inout T p, inout T q) { T t = p; p = q; q = t; }\n\nDEFSWAP(int)\nDEFSWAP(vec3)\n\n// Find rotation that maps p,q onto r,s\n// Reflect p to r, q to q', then q' to s\nvec4 getrotation(vec3 p, vec3 q, vec3 r, vec3 s) {\n  if (p == r) {\n    if (q == s) return vec4(0,0,0,1); // Nothing to do\n    swap(p,q); swap(r,s);\n  }\n  vec3 n1 = r-p;\n  vec4 q1 = vec4(n1,0); // Reflect p to r\n  q = q-2.0*dot(n1,q)/dot(n1,n1)*n1;\n  vec3 n2 = distance(q,s) < 0.01 ? cross(r,q+s) : s-q;\n  vec4 q2 = vec4(n2,0);\n  vec4 t = qmul(q2,q1);\n  return normalize(t);\n}\n\n// Given three elements of a permutation, c0, c1, c2, find\n// v0 with color(v0) = c0 and color(-v0) = c2, then find\n// v1 adjacent to v0 with color(v1) = c1. This is always\n// possible with the \"5 tetrahedron\" colouring.\nivec2 getvertices(ivec3 p) {\n  int i,j;\n  for (i = 0; i < N; i++) {\n    // The opposite vertex is 10 places on\n    if (colorindex[i] == p[0] && colorindex[(i+N/2)%N] == p[2]) break;\n  }\n  for (j = 0; j < N; j++) {\n    // Find unique closest vertex with correct color\n    if (colorindex[j] == p[1] && distance(vertex[i],vertex[j]) < 1.0) break;\n  }\n  return ivec2(i,j);\n}\n\nvec3 invert(vec3 p, vec3 centre, float r2) {\n  p -= centre;\n  p *= r2/dot(p,p);\n  p += centre;\n  return p;\n}\n\nvec3 istereo(vec2 p2) {\n  // Inverse stereographic projection by inversion\n  vec3 p = vec3(p2,0);\n  vec3 centre = vec3(0,0,-1);\n  float r2 = 2.0;\n  p = invert(p,centre,r2);\n  return p;\n}\n\n// For k = 2n, find the nth even permutation\n// For k = 2n+1, find the nth odd permutation\n// Return first, second and last elements of permutation\n// Given the parity, the other two elements are determined.\nivec3 getperm(int k) {\n  const int N = 5;\n  int a[N] = int[](0,1,2,3,4);\n  int p = 24;\n  int inversions = 0;\n  for (int i = N-1; i > 1; i--) {\n    int k1 = k/p;\n    inversions += i-k1;\n    k = k%p;\n    int tmp = a[k1];\n    for (int j = k1; j < i; j++) {\n      a[j] = a[j+1];\n    }\n    a[i] = tmp;\n    p /= i;\n  }\n  if (inversions%2 != k%2) swap(a[0],a[1]);\n  // Perms are in lexicographic reverse order\n  return ivec3(a[4],a[3],a[0]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p2 = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  p2 *= 5.0;\n  vec3 p = istereo(p2);\n  float cycle = 4.0;\n  float transition = 2.0;\n  int n = int(iTime/cycle);\n  ivec3 perm0 = getperm(n%60*2);\n  ivec3 perm1 = getperm((n+1)%60*2);\n  ivec2 vv0 = getvertices(perm0);\n  ivec2 vv1 = getvertices(perm1);\n  vec4 q0 = getrotation(vertex[0],vertex[1],vertex[vv0[0]],vertex[vv0[1]]);\n  vec4 q1 = getrotation(vertex[0],vertex[1],vertex[vv1[0]],vertex[vv1[1]]);\n  float t = smoothstep(1.0,2.0,transition*fract(iTime/cycle));\n  vec4 q = slerp(q0,q1,t);\n  q = normalize(q); // Just in case\n  p = qrot(p,q);\n  vec3 col = color[5];\n  float dwidth = 0.3;\n  for (int i = 0; i < N; i++) {\n    float d = acos(clamp(dot(p,vertex[i]),-1.0,1.0));\n    col = mix(color[colorindex[i]],col,smoothstep(0.0,max(0.01,fwidth(d)),d-dwidth));\n  }\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3cDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2196, 2234, 2261, 2261, 2315], [2317, 2317, 2346, 2394, 2581], [2583, 2603, 2633, 2633, 2775], [2777, 2777, 2804, 2804, 2891], [2893, 2893, 2913, 2913, 2942], [2944, 2944, 2963, 2963, 2993], [2995, 2995, 3022, 3022, 3050], [3052, 3052, 3071, 3112, 3144], [3146, 3368, 3407, 3407, 3462], [4031, 4252, 4280, 4280, 4622], [4624, 4624, 4668, 4668, 4732], [4734, 4734, 4757, 4808, 4920], [5568, 5568, 5625, 5625, 6478]], "test": "untested"}
{"id": "tt3cDH", "name": "Some Star Towers", "author": "TheNosiriN", "description": "Inspired by: Some scene in some underrated anime I don't remember.\nDoes it look ok with the flares?", "tags": ["sdf", "stars", "atmosphere", "anamorphic", "fallingstars"], "likes": 21, "viewed": 770, "published": 3, "date": "1608951332", "time_retrieved": "2024-07-30T20:28:12.977980", "image_code": "#define RES iResolution.xy\n\n\n\nfloat NoiseSeed;\nvec3 filmgrain(){\n    NoiseSeed = fract(sin(NoiseSeed) * 84522.13219145687);\n    return vec3(0.9 + NoiseSeed*0.15);\n}\n\n//anamorphic-ish flares from: https://www.shadertoy.com/view/MlsfRl\nvec3 flares(sampler2D tex, vec2 uv, float threshold, float intensity, float stretch, float brightness)\n{\n    threshold = 1.0 - threshold;\n    \n    vec3 hdr = texture(tex, uv).rgb;\n    hdr = vec3(floor(threshold+pow(hdr.r, 1.0)));\n    \n    float d = intensity; //200.;\n    float c = intensity*stretch; //100.;\n    \n    //horizontal\n    for (float i=c; i>-1.0; i--){\n        float texL = texture(tex, uv+vec2(i/d, 0.0)).r;\n        float texR = texture(tex, uv-vec2(i/d, 0.0)).r;\n        hdr += floor(threshold+pow(max(texL,texR), 4.0))*(1.0-i/c);\n    }\n    \n    hdr *= vec3(0.369,0.200,0.620); //tint\n\treturn hdr*brightness;\n}\n\n\n\n//Single pass mip map bloom: https://www.shadertoy.com/view/Ms2Xz3\nconst float Threshold = 0.2;\nconst float Intensity = 2.0;\nconst float BlurSize = 1.0;\n\nvec3 mipMapBloom(vec3 Screen, in sampler2D Tex, in vec2 Coord, in float MipBias)\n{\n\tvec2 TexelSize = MipBias/iChannelResolution[0].xy;\n    \n    vec3  Color = texture(Tex, Coord, MipBias).rgb;\n    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias).rgb;    \n\n    Color = Color/9.0;\n    vec3 Highlight = clamp(Color-Threshold,0.0,1.0)*1.0/(1.0-Threshold);\n    return 1.0-(1.0-Screen)*saturate(1.0-Highlight*Intensity);\n}\n\n\n\nfloat SCurve (float value, float amount, float correction){\n\tfloat curve = 1.0; \n    if (value < 0.5){ curve = pow(value, amount) * pow(2.0, amount) * 0.5; }   \n    else{ curve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; }\n    return pow(curve, correction);\n}\nvec3 contrast(vec3 color)\n{\n    return saturate(vec3(\n        SCurve(color.r, 3.0, 1.0), \n        SCurve(color.g, 4.0, 0.7), \n        SCurve(color.b, 2.6, 0.6)\n    ));\n}\n\n\n\nvec3 margins(vec3 color, vec2 uv, float marginSize)\n{\n    if(uv.y < marginSize || uv.y > 1.0-marginSize)\n    {\n        return vec3(0.0);\n    }else{\n        return color;\n    }\n}\n\n\n\n//from: https://www.shadertoy.com/view/4l2GWm\nvec3 quincunxAA(sampler2D tex, vec2 fragCoord, float blur)\n{\n\tvec3 pixelColor;\n\tpixelColor =  texture(tex, (fragCoord + vec2( 0.0, 0.0)) / RES).rgb / 2.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur, blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur,-blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur,-blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur, blur)) / RES).rgb / 8.0;\n\treturn pixelColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = quincunxAA(iChannel0, fragCoord, 0.5);\n    float dist = texture(iChannel0, uv).a;\n    \n    color += contrast(flares(iChannel0, uv, 1.0, 200.0, 0.1, 0.02) * (dist*dist));\n    color = mipMapBloom(color+(color*dist), iChannel0, uv, BlurSize);\n    color *= filmgrain();\n    \n    color = margins(color, uv, 0.1);\n    \n    color = pow(color, vec3(1.0/2.2));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415972\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\n\nvec3 min3(vec3 a, vec3 b){\n    return min(a.z, b.z) == a.z ? a : b;\n}\n\nvec3 max3(vec3 a, vec3 b){\n    return max(a.z, b.z) == a.z ? a : b;\n}\n\n\n\nvec3 rotateCamera(float len, vec2 m, vec4 mouse)\n{\n    float phi = m.x * PI * 2.0;\n    if(mouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(mouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\n\n\n\n\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\nfloat boundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat cube(vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat column(vec3 p, float l, float r)\n{\n    p.y -= l;\n    float r2 = r*2.0;\n    float r12 = (r+r2)/2.0;\n    float cb = cube(vec3(p.x, p.y+(r/2.0), p.z), vec3(r2, r12/2.0, r2));\n    cb = max(cb, -(length(vec3(p.x-r12, p.y+r12, p.z-r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x+r12, p.y+r12, p.z-r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x-r12, p.y+r12, p.z+r12))-(r2/1.25)) );\n    cb = max(cb, -(length(vec3(p.x+r12, p.y+r12, p.z+r12))-(r2/1.25)) );\n    \n    float cy = sdCylinder(p, vec3(0.0), vec3(0.0,-l,0.0), r);\n    //cy = max(cy, -boundingBox(vec3(p.x, p.y+l/2.0, p.z), vec3(r/1.25, l/2.0, r/1.25), 0.25));\n    \n    cb = min(cb, cy)-0.1;\n    \n    return cb;\n}", "buffer_a_code": "const int MAX_MARCHING_STEPS = 256;\nconst int MAX_SHADOW_STEPS = 32;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 2000.0;\nconst vec3 MIN_VEC = vec3(vec2(0.0), MIN_DIST);\nconst vec3 MAX_VEC = vec3(vec2(0.0), MAX_DIST);\nconst float EPSILON = 0.001;\n\nconst vec3 SUN_DIR = normalize(vec3(0.0, 0.03, 0.5));\n\n\n\n\n\n//atmosphere from: https://www.shadertoy.com/view/wllyW4\n#define PLANET_RADIUS     6371e3\n#define ATMOSPHERE_HEIGHT 100e3\n#define RAYLEIGH_HEIGHT   8e3\n#define MIE_HEIGHT        1.2e3\n#define OZONE_PEAK_LEVEL  30e3\n#define OZONE_FALLOFF     3e3\n\n#define BETA_RAY   vec3(3.8e-6, 13.5e-6, 33.1e-6) // vec3(5.5e-6, 13.0e-6, 22.4e-6)\n#define BETA_MIE   vec3(21e-6)\n#define BETA_OZONE vec3(2.04e-5, 4.97e-5, 1.95e-6)\n#define G          0.75\n\n#define SAMPLES          3\n#define LIGHT_SAMPLES    2\n\n\n#define SUN_ILLUMINANCE   128000.0\n#define MOON_ILLUMINANCE  0.32\n#define SPACE_ILLUMINANCE 0.01\n\nconst float ATMOSPHERE_RADIUS = PLANET_RADIUS + ATMOSPHERE_HEIGHT;\n\nvec2 raySphereIntersect(in vec3 origin, in vec3 dir, in float radius) {\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0 * dot(dir, origin);\n\tfloat c = dot(origin, origin) - (radius * radius);\n\tfloat d = (b * b) - 4.0 * a * c;\n    \n\tif(d < 0.0)return vec2(1.0, -1.0);\n\treturn vec2(\n\t\t(-b - sqrt(d)) / (2.0 * a),\n\t\t(-b + sqrt(d)) / (2.0 * a)\n\t);\n}\n\nfloat phaseR(in float cosTheta) {\n    return (3.0 * (1.0 + cosTheta * cosTheta)) / (16.0 * PI);\n}\nfloat phaseM(in float cosTheta, in float g) {\n\tfloat gg = g * g;\n\treturn (1.0 - gg) / (4.0 * PI * pow(1.0 + gg - 2.0 * g * cosTheta, 1.5));\n}\n\nvec3 avgDensities(in vec3 pos) {\n\tfloat height = length(pos) - PLANET_RADIUS; // Height above surface\n\tvec3 density;\n\tdensity.x = exp(-height / RAYLEIGH_HEIGHT);\n\tdensity.y = exp(-height / MIE_HEIGHT);\n    density.z = (1.0 / cosh((OZONE_PEAK_LEVEL - height) / OZONE_FALLOFF)) * density.x; // Ozone absorption scales with rayleigh\n    return density;\n}\nvec3 atmosphere(\n\tin vec3 pos,\n\tin vec3 dir,\n\tin vec3 lightDir\n) {\n\t// Intersect the atmosphere\n    vec2 intersect = raySphereIntersect(pos, dir, ATMOSPHERE_RADIUS);\n\n\tvec3 opticalDepth = vec3(0.0);\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    \n    float rayPos = max(0.0, intersect.x);\n    float maxLen = ATMOSPHERE_HEIGHT;\n    maxLen *= (1.0 - abs(dir.y) * 0.5);\n\tfloat stepSize = min(intersect.y - rayPos, maxLen) / float(SAMPLES);\n    rayPos += stepSize * 0.5;\n    \n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 samplePos = pos + dir * rayPos;\n\n\t\tvec2 lightIntersect = raySphereIntersect(samplePos, lightDir, ATMOSPHERE_RADIUS);\n\n        vec3 lightOpticalDepth = vec3(0.0);\n        float lightStep = lightIntersect.y / float(LIGHT_SAMPLES);\n        float lightRayPos = lightStep * 0.5;\n        \n        for(int j = 0; j < LIGHT_SAMPLES; j++) {\n            vec3 lightSamplePos = samplePos + lightDir * (lightRayPos);\n\n\t\t\tlightOpticalDepth += avgDensities(lightSamplePos) * lightStep;\n\n            lightRayPos += lightStep;\n        }\n\n\t\tvec3 densities = avgDensities(samplePos) * stepSize;\n\t\topticalDepth += densities;\n\n\t\tvec3 scattered = exp(-(BETA_RAY * (opticalDepth.x + lightOpticalDepth.x) + BETA_MIE * (opticalDepth.y + lightOpticalDepth.y) + BETA_OZONE * (opticalDepth.z + lightOpticalDepth.z)));\n        sumR += scattered * densities.x;\n        sumM += scattered * densities.y;\n\n        rayPos += stepSize;\n    }\n\n    float cosTheta = dot(dir, lightDir);\n    \n    return max(\n        phaseR(cosTheta)    * BETA_RAY * sumR + // Rayleigh color\n       \tphaseM(cosTheta, G) * BETA_MIE * sumM,  // Mie color\n    \t0.0\n    );\n}\nvec3 renderBlackbody(in vec3 dir, in vec3 lightDir) {\n    float cosTheta = dot(dir, lightDir);\n    \n    float intensity = smoothstep(0.998, 0.999, cosTheta);\n    float glow = pow(max(cosTheta, 0.0), 4.0) * 0.01;\n\t\n    float fade = smoothstep(0.05, 0.25, dir.y);\n    float glowFade = smoothstep(0.05, 0.25, lightDir.y);\n    \n    return vec3(intensity + glow * glowFade) * fade;\n}\n\n\n\n\n\n\n#define M3 mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\n#define M2 mat2(0.8,-0.6,0.6,0.8)\nvec4 getHashTex(vec2 p)\n{\n    //return fract(cos(P*mat2(-64.2,71.3,81.4,-29.8))*8321.3); \n    return textureLod(iChannel0, p/256.0, 0.0);\n}\nfloat noiseTex( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = getHashTex(uv+0.5).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fbm21Tex(vec2 p)\n{\n\tfloat f = 0.0;\n    f += 0.5000 * noiseTex( vec3(p,0.0) ); p = M2*p*2.02;\n    f += 0.2500 * noiseTex( vec3(p,0.0) ); p = M2*p*2.03;\n    f += 0.1250 * noiseTex( vec3(p,0.0) ); p = M2*p*2.01;\n    f += 0.0625 * noiseTex( vec3(p,0.0) );\n    return (f/0.9375) *2.0 -1.0;\n}\n\n\nfloat pMod(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nvec3 scene(vec3 p)\n{\n    p.z += iTime*50.0;\n    \n    vec3 d = MAX_VEC;\n    float n = fbm21Tex(p.xz*0.025);\n    d = min3(d, vec3(.0,n, \n        p.y + n*7.0\n    ));\n    \n    \n    vec3 cp = p;\n    cp.z -= 400.0;\n    float c = pMod(cp.z, 400.0);\n    cp.x += mod(c, 2.0) == 0.0 ? 60.0 : -30.0;\n    \n    cp.y += 10.0;\n    d = min3(d, vec3(.0,.0, column(cp, 50.0, 4.0)));\n    d = min3(d, vec3(1.,.0, length(vec3(cp.x,cp.y-57.0,cp.z)) - 4.0));\n    \n    vec3 cbp = p;\n    cbp.y -= 10.0;\n    return d;\n}\n\n\nvec3 raymarch(vec3 eye, vec3 dir)\n{\n    vec3 depth = MIN_VEC;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = eye + dir * depth.z;\n        \n        vec3 dist = scene(p);\n        if (dist.z < EPSILON * length(p)) {\n\t\t\treturn vec3(dist.xy, depth.z);\n        }\n        depth.z += dist.z * (dist.z/(MAX_DIST) + 1.0);\n        if (depth.z > MAX_DIST) {\n            return MAX_VEC;\n        }\n    }\n    return MAX_VEC;\n}\n\n\n\n\nvec3 normal(vec3 p)\n{\n \tvec3 P = vec3(-4, 4, 0) * 0.01;\n\n \treturn normalize(\n        scene(p+P.xyy).z * \n        P.xyy + scene(p+P.yxy).z * \n        P.yxy + scene(p+P.yyx).z * \n        P.yyx + scene(p+P.xxx).z * \n        P.xxx\n    );\n}\n\n\n\n\n\n\n\nfloat shadow(in vec3 eye, in vec3 dir) {\n    float res = 1.0;\n    float t = EPSILON;\n    float ph = 1e10;\n        \n    for( int i=0; i<MAX_SHADOW_STEPS && t < MAX_DIST; i++ )\n    {\n     \tvec3 p = eye + dir * t;\n        float h = scene(p).z;\n        if (h < 0.0){ return 0.0; }\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        \n        t += h;\n    }\n\n    return res;\n}\n\n\n\n\n\nvec3 compose(vec3 eye, vec3 dir, vec3 info)\n{\n    vec3 color = vec3(0.0);\n    vec3 p = eye + dir * info.z;\n    \n    if (info.x == 1.0){ return vec3(1.0); }\n    \n    vec3 n = normal(p);\n    \n    color = n;//vec3(0.5);\n    \n    float shade = saturate(dot(n, SUN_DIR));\n    if (shade > 0.0){\n        //shade *= shadow(p, SUN_DIR);\n    }\n    \n    color *= shade;\n    \n    return saturate(color);\n}\n\n\n\n\n\n// https://www.shadertoy.com/view/Xs2BRc\nfloat Cell(vec2 c) {\n    vec2 uv = fract(c);\n    uv.y -= 0.5;\n    c -= uv;\n    return (1.0 - length(uv)) * step(fract( sin(c.x + c.y*100.0) *1000.0), 0.01);\n}\nvec3 stars(vec3 dir, float time)\n{\n    vec2 ndir = dir.xy * rotate(-45.0);\n    ndir.x += 1.0;\n    ndir.y += 0.5;\n    float projX = fract(ndir.x) / 1.;\n    float projY = pow(ndir.y, 0.05);\n    vec3 color;\n    \n    time -= 0.02;\n    vec2 coord = vec2(projY, projX)*256.0;\n    vec2 delta = vec2(time*7.0, 0.0);\n    float c = Cell(coord -= delta);\n    c += Cell(coord -= delta);\n    color += c;\n    \n    \n    vec3 t = color;\n    return saturate(t) * smoothstep(0.05, 0.3, dir.y);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n    //vec3 eye = rotateCamera(200.0, iMouse.xy/iResolution.xy, iMouse); //uncomment this\n    \n    float time = iTime;\n    \n    float tt = sin(time)+cos(-time)*0.5;\n    vec3 eye = vec3(10.0, 20.0, -200.0) + tt;\n    vec3 lookAt = vec3(0.0, 20.0, 0.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 dir = rayDirection(35.0, iResolution.xy, fragCoord);\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    worldDir.xy = worldDir.xy * rotate(-tt * 1.25);\n    \n    vec3 col = vec3(0);\n    \n    \n    float sundot = saturate(dot(worldDir,SUN_DIR));\n    vec3 atm = atmosphere(vec3(eye.x, eye.y+PLANET_RADIUS, eye.z), worldDir, SUN_DIR) * sundot;\n    \n    \n    vec3 dist = raymarch(eye, worldDir);\n    if (dist.z > MAX_DIST-EPSILON)\n    {\n        // sky\t\n        col = atm;\n        vec3 body = renderBlackbody(worldDir, SUN_DIR);// + (sundot*0.2);\n        col += body + stars(worldDir, -time*0.05);\n    }else{\n        vec3 p = eye + worldDir*dist.z;\n        col += saturate((dist.z*1.2)/MAX_DIST) + compose(eye, worldDir, dist);\n        col *= saturate(atm + (dist.x == 1.0 ? 10.0 : 0.0));\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,dist.z/MAX_DIST);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3cDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 64, 64, 164], [166, 234, 338, 338, 858], [1016, 1016, 1098, 1098, 2014], [2018, 2018, 2077, 2077, 2292], [2293, 2293, 2320, 2320, 2462], [2466, 2466, 2519, 2519, 2643], [2647, 2693, 2753, 2753, 3181], [3184, 3184, 3241, 3241, 3690]], "test": "untested"}
{"id": "WdyfRW", "name": "Epic Mandelbulb", "author": "CubeyTheCube", "description": "A raymarched mandelbulb with epic orbit trap coloring. If you change \"sliced\" (line 1) to 1 the mandelbulb will be sliced in half with an epic infinite zoom.", "tags": ["fractal", "mandelbulb", "raymarcher", "cursed", "3amneverbeforeseenfootage"], "likes": 3, "viewed": 417, "published": 3, "date": "1608928815", "time_retrieved": "2024-07-30T20:28:13.899516", "image_code": "#define sliced 0\n#define iters 4\n#define AA 1.0\n#define gamma 1.5\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\nvec3 transform( in vec3 p, in float xrot, in float yrot, in float zrot, in vec3 pos )\n{   vec4 rot = vec4((p - pos),1.0)*rotationX(xrot)*rotationY(yrot)*rotationZ(zrot);\n    return rot.xyz;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec2 mandelbulb( in vec3 p )\n{\n    float mdist = 1e12;\n    vec3 w = p;\n    float exp = 8.0;\n    float m = dot(w,w);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<iters; i++ )\n    {\n        dz = exp*pow(sqrt(m),exp-1.0)*dz + 1.0;\n        \n        float r = length(w);\n        float b = exp*acos( w.y/r);\n        float a = exp*atan( w.x, w.z );\n        w = p + pow(r,exp) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) ); \n        mdist = min(mdist, length(w));\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n          break; \n    }\n\n    float sde = 0.25*log(m)*sqrt(m)/dz;\n    if(sliced == 1) {\n    return vec2(max(sde,-box(p-vec3(2.0,0.0,0.0),vec3(2.0,2.0,2.0))), mdist);\n    }\n    else return vec2(sde,mdist);\n}\n\n\nvec2 dist( vec3 p ) {\n    float time = sliced==1?1.:min(5.0,iTime);\n    vec2 m = mandelbulb(transform(p,-iMouse.y/time*20./iResolution.y,-iMouse.x/time*20./iResolution.x,0.0,vec3(0.0,0.0,-8.0)));\n    float trap = m.y;\n    return vec2(min(1e12,m.x),trap);\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = dist(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\nvec3 normal( in vec3 pos ) \n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           dist(pos+eps.xyy).x - dist(pos-eps.xyy).x,\n           dist(pos+eps.yxy).x - dist(pos-eps.yxy).x,\n           dist(pos+eps.yyx).x - dist(pos-eps.yyx).x ) );\n}\nvec3 color( in vec2 px, in float y )\n{\n    vec3 c = vec3(0.0, 0.0,-12.0);\n    vec3 r = normalize(vec3(px, 600));\n    vec3 k = c;\n    float t = 1.0;\n    int j;\n    for (j = 0; j<40; j++) {\n        k=c+r*t;\n        t+=dist(k).x;\n        if(!(dist(k).x>=0.01 && t<1e12)) {\n            break;\n        }\n    }\n    if (t>=1e12 || j==40) {\n        return mix(vec3(135.0, 206.0, 235.0)/255.0, vec3(1.0,1.0,1.0), y/iResolution.y);\n    }\n    float colorI = (sin(pow(dist(k).y,0.3)*6.0)+1.0)/2.0;\n    vec3 color = vec3(0.,0.,0.);\n    vec3 control[5] = vec3[5](vec3(0.0, 0.02745, 0.39216), vec3(0.125, 0.41961, 0.79608), vec3(0.92941, 1.0, 1.0), vec3(1.0, 0.66667, 0.0), vec3(0.0, 0.00784, 0.0));\n    if (colorI<0.16) {\n    color = mix(control[0], control[1], colorI/0.16);\n    } else if (colorI<0.42) {\n    color = mix(control[1], control[2], (colorI-0.16)/0.26);\n    } else if (colorI < 0.6425) {\n    color = mix(control[2], control[3], (colorI-0.42)/0.2225);\n    } else if (colorI < 0.8575) {\n    color = mix(control[3], control[4], (colorI-0.6425)/0.215);\n    } else {\n    color = mix(control[4], control[0], (colorI-0.8575)/0.1425);\n    }\n    vec3 sc = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    vec3 n = normal(k);\n    vec3 l = normalize(vec3(3.0,2.0,-10.0)-k);\n    float shade = dot(n,l)*softshadow(k,l,0.01,32.);\n    vec3 h = normalize(l-r);\n    float spec = exp(-acos(max(0.,dot(n,h)))/0.25);\n    return min(vec3(1.0,1.0,1.0), shade * sc + vec3(spec));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.,0.,0.);\n    for (float m = 0.0; m<AA; m++) {\n    for (float n = 0.0; n<AA; n++) {\n    vec2 p = fragCoord+vec2(m,n)/AA-iResolution.xy/2.0;\n    col += color(p/(sliced==1?iTime:min(iTime,1.0)), fragCoord.y);\n    }}\n    fragColor = vec4(col/(AA*AA),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 100, 100, 239], [241, 241, 275, 275, 411], [413, 413, 447, 447, 580], [581, 581, 668, 668, 772], [773, 773, 802, 802, 889], [890, 890, 920, 920, 1592], [1595, 1595, 1616, 1616, 1851], [1852, 1852, 1917, 1917, 2189], [2190, 2190, 2219, 2219, 2448], [2449, 2449, 2487, 2487, 3930], [3931, 3931, 3988, 3988, 4264]], "test": "untested"}
{"id": "3dyBDy", "name": "ring twister", "author": "maksy", "description": "A ring twister was suggested as the next project after I made the classic twister effect. So here it is. :-) \n\nOther shaders I used to study how the effect works:\nhttps://www.shadertoy.com/view/Xt23z3\nhttps://www.shadertoy.com/view/lsX3WM", "tags": ["2d", "oldschool", "ring", "twister", "polar"], "likes": 8, "viewed": 525, "published": 3, "date": "1608927462", "time_retrieved": "2024-07-30T20:28:14.767196", "image_code": "const float IN_RADIUS = 0.3;\nconst float OUT_RADIUS = 0.85;\nconst float PI = 3.14159;\n\nvec3 borderColor(float x0, float x1, vec2 uv, \n                 float leftVisible, float rightVisible) {\n\n    vec3 edgeCol = vec3(0.05);\n    vec3 white = vec3(1.);\n    float thick = 0.03;\n   \t\n    // the exterior side of the left border\n\tfloat outside = (step(uv.x, x0-thick) + step(x0, uv.x));\n    vec3 borderCol = mix(white, edgeCol, smoothstep(x0, x0-thick, uv.x)) \n    \t* (1. - outside) * leftVisible;\n        \n    // the interior side of the left border\n    outside = (step(uv.x, x0) + step(x0+thick, uv.x));\n    borderCol += mix(edgeCol, white, smoothstep(x0+thick, x0, uv.x)) \n    \t* (1. - outside)* leftVisible;      \n    \n    // the exterior side of the right border\n    outside = (step(uv.x, x1) + step(x1+thick, uv.x));        \n    borderCol += mix(white, edgeCol, smoothstep(x1, x1+thick, uv.x))\n        * (1.- outside) * rightVisible ;\n    \n    // the interior side of the right border\n    outside = (step(uv.x, x1-thick) + step(x1, uv.x));            \n    borderCol += mix(edgeCol, white, smoothstep(x1-thick, x1, uv.x))\n    \t* (1.- outside) * rightVisible;\n    \n    return borderCol;\n}\n\nvec3 getBorderColor(float x0, float x1, vec2 uv,\n              vec3 fragColor) {\n        \n    vec3 rightCol = vec3(0.);\n    vec3 leftCol = vec3(0.);\n        \n    leftCol = borderColor(x0, x1, uv, 1., 0.);       \n    rightCol = borderColor(x0, x1, uv, 0., 1.);\n   \n    if (leftCol != vec3(0.))\n        return leftCol;\n    else if (rightCol != vec3(0.))\n   \t\treturn rightCol;                 \n   \n    return fragColor;   \n}\n\nvec3 getColor(float x0, float x1, vec2 uv, vec3 color) {\n   \n   // First u becomes [0,1] then the range [0.0, 0.5] will be \n   // transformed into [0.0, 1.0] and ]0.5, 1.0] into ]1.0, 0.0].\n   float u = (uv.x - x0)/(x1 - x0);\n              \n   // u <= 0.5\n   float ud = (u/0.5) * (1.0 - step(0.5, u));\n   // u > 0.5\n   ud += (1. - (u/0.5-1.)) * (1.0 - step(u, 0.5));\n           \n   // Remove aliasing by making the shading points near x0 and x1 darker.\n   vec3 col = mix(vec3(0.0), color, smoothstep(.0, .6, ud)); \n            \n   // Add lightning by making darker the shading points that are \n   // about to be covered and going \"behind\" another face. This also\n   // removes aliasing since if x1-x0 is small the borders cover the \n   // darker sides and transition to interior area becomes very sharp. \n   float w = (x1 - x0);            \n   col *= w / .55;\n   return col;            \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    uv *= 2.7;\n    \n    // Polar coordinates\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + PI);\n    uvr.x -= OUT_RADIUS;\n       \n    vec3 col = mix(vec3(0.01), vec3(0.05), smoothstep(2.2, .1, abs(uv.x)));    \n    \n    vec3 colors[4];\n    colors[0] = vec3(0.9, 0.0, 0.0);\n    colors[1] = vec3(0.0, 0.9, 0.0);\n    colors[2] = vec3(0.0, 0.2, 1.0);\n    colors[3] = vec3(1.0, 0.42, 0.0);\n        \n    float angle = uvr.y + 1.5*iTime + .5*sin(uvr.y) * 1.5*sin(iTime) * PI;\n    \n    // Add faces\n    for(int i = 0; i < 4;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + 0.5 * float(i) * PI);       \n        float x1 = IN_RADIUS * sin(angle + 0.5 * float(i+1) * PI);\n\n        if (uvr.x >= x0 && uvr.x <= x1) {\n            col = getColor(x0, x1, uvr, colors[i]);            \n       }\n    }\n\n    // Add borders.\n    float x0 = IN_RADIUS * sin(angle + 0.0);       \n    float x1 = IN_RADIUS * sin(angle + 0.5*PI);\n    float x2 = IN_RADIUS * sin(angle + 1.0*PI);       \n    float x3 = IN_RADIUS * sin(angle + 1.5*PI);    \n\t\n    if (x0 < x1) {\n        col = getBorderColor(x0, x1, uvr, col);      \n    }    \n    \n\tif (x1 < x2) {\n    \tcol = getBorderColor(x1, x2, uvr, col);\n    }\n   \n   \tif (x2 < x3) {\n    \tcol = getBorderColor(x2, x3, uvr, col);\n    }\n    \n    if (x3 < x0) {\n    \tcol = getBorderColor(x0, x3, uvr, col);\n    \tif (x2 < x3) {\n            col = getBorderColor(x3, x0, uvr, col);    \t\n    \t}\n    }\n    \n    col = pow(col,vec3(.454545));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 191, 191, 1187], [1189, 1189, 1269, 1269, 1610], [1612, 1612, 1668, 1801, 2500], [2502, 2502, 2559, 2559, 4100]], "test": "untested"}
{"id": "ttccW8", "name": "Day 373", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 28, "viewed": 489, "published": 3, "date": "1608924092", "time_retrieved": "2024-07-30T20:28:15.773505", "image_code": "\n// fibonacci, texture lookup noise and sdf functions from IQ!\n// aces film from knarkowitz\n\n\n\nfloat noise3D( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\nfloat na = 0.;\n\nfloat getLeaves(vec3 p, vec3 offs){\n    float d = 10e5;\n\n\n    vec4 fib = inverseSF(normalize(p),N);\n\n\n    p *= makeBase(normalize( fib.xyz ));\n\n\n    p.z -= R;\n    \n    p.y -= smoothstep(0.2,0.,abs(p.x)*3.)*0.05*(1. - smoothstep(0.,1.,p.z*1. + 0.3));\n\n    float leaf = length(p) - leafSz;\n    \n    leaf = opSmoothUnion( leaf, max(length(p.yx) - 0.03,p.z), 0.04 );\n    \n    leaf -= smoothstep(0.2,0.,abs(p.x)*3.)*0.05;\n    \n    leaf = opSmoothSubtraction( -leaf, abs(p.y) - 0.02, 0.1 );\n    \n    d = min(d, leaf );\n    \n    return d;\n}\n\n\n\n\nfloat doLeaves(vec3 p){\n    float d = 10e5;\n    float ramt = PHI*1.*PI*4.;\n    vec3 op = p;\n    p = sphericalFromCart(p);\n\n    float transitionLen = 0.4;\n    \n    p.y += smoothstep(0.,1.6 ,p.x+ (na=noise3D(op + iTime*2.))*0.2)*0.4*smoothstep(0.,1.,abs(p.y));\n    \n    p.y -= sin(iTime*0.4 +iMouse.y/iResolution.y*PI )*0.2 + 0.1;\n    p = cartFromSpherical(p);    \n    p.yz *= rot(0.5*PI);\n    \n    \n    \n    d = min(d, getLeaves(p,vec3(0)));\n    \n    p.xz *= rot(ramt);\n    //p.xy *= rot(0.6);\n    \n    d = min(d,getLeaves(p,vec3(0)));\n    \n    p.xz *= rot(ramt);\n    \n    d = min(d,getLeaves(p,vec3(0)));\n    p.xz *= rot(ramt);\n    \n    d = min(d,getLeaves(p,vec3(0)));\n    return d;\n}\n\nvec3 petalAccum = vec3(0);\n\nfloat petalDens = 0.;\nvec2 doFlower(vec3 p, float hScale, float bendAmt, float blendpw){\n    vec2 d = vec2(10e5);\n    float h = stickSz*hScale;\n    p.xy *= rot(pow(smoothstep(0.,1.,p.y/h - 0.1),blendpw)*bendAmt);\n    float stick = sdRoundCone(p, vec3(0), vec3(0,h,0), 0.02, 0.015);\n    \n\n    p -= vec3(0,h,0);\n    \n    vec4 fib = inverseSF(normalize(p),190.);\n    p *= makeBase(normalize( fib.xyz ));\n    \n    //p.z -= RPetal;\n    \n    float petal = sdRoundCone(p, vec3(0), vec3(0.,0.,RPetal), -0.01, 0.00)*1.;\n    float petalBeginning = sdRoundCone(p, vec3(0), vec3(0.,0.,RPetal*0.3), -0.01, 0.00)*1.;\n    float petalBall = length(p - vec3(0,0,RPetal)) - 0.014;\n    \n    \n    petal = min(petal, petalBall);\n    petal = min(petal, petalBeginning);\n    if(!hit){\n        float amt =0.0015/(.003 + 100.*petal*petal)*(1.-petalDens);\n        petalDens += amt*float(petalDens<1.);\n        vec3 c = vec3(0.6,0.4,0.45);\n        c = mix(c,vec3(0.4,0.2,0.1)*0.4,smoothstep(0.01,0.,petalBeginning - 0.03));\n        c = mix(c,vec3(0.6,0.7,0.55),smoothstep(0.01,0.,petalBall - 0.03));\n        petalAccum += c*amt*float(petalDens<1.);\n    }\n        //exp(-petal*20.);\n    \n    \n    d.x = min(d.x,abs(petal - 0.0) + 0.04);\n    //petal = length(p.xy) - 0.01;\n    d = dmin(d,stick,2.);\n    //d = dmin(d,petal,1.);\n    return d;\n}\n\nvoid doParticles(vec3 p, float rep){\n    \n    p.x += iTime;\n    vec3 op = p;\n    p.y = opRepLim(p.y,1.,5.);\n    p.xz = pmod(p.xz,rep);\n    \n    p.y -= sin(op.x + iTime)*0.4 - 0.2 + noise3D(op)*0.5;\n\n    //float petal = sdRoundCone(p, vec3(0), vec3(0.,0.,RPetal), 0.01, 0.01)*1.;\n    //float petalBeginning = sdRoundCone(p, vec3(0), vec3(0.,0.,RPetal*0.3), -0.01, 0.00)*1.;\n    float petalBall = length(p - vec3(0,0,RPetal)) - 0.014;\n    \n    \n    float petal = petalBall;\n    //petal = min(petal, petalBall);\n    //petal = min(petal, petalBeginning);\n    if(!hit){\n        float amt =0.0015/(.003 + 100.*petal*petal)*(1.-petalDens);\n        petalDens += amt*float(petalDens<1.);\n        vec3 c = vec3(0.6,0.4,0.45);\n        //c = mix(c,vec3(0.4,0.2,0.1)*0.4,smoothstep(0.01,0.,petalBeginning - 0.03));\n        c = mix(c,vec3(0.6,0.7,0.55),smoothstep(0.01,0.,petalBall - 0.03));\n        petalAccum += c*amt*float(petalDens<1.);\n    }\n    \n}\n\nvec2 doFlowers(vec3 p){\n    vec2 d = vec2(10e5);\n     \n    p.x += noise3D(vec3(0,0,iTime*3.))*0.09*smoothstep(0.,1.,p.y/stickSz);\n    vec2 flowA = doFlower(abs(p),1.,0.25,0.2);\n    p.xz *= rot(1.4);\n    vec2 flowB = doFlower(abs(p),1.5,0.5,0.4);\n    \n    d = dmin(d,flowA.x,flowA.y);\n    d = dmin(d,flowB.x,flowB.y);\n    doParticles(p,2.);\n    doParticles(p - 2.4,2.);\n    \n    return d;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    float eps = -0.5;\n    \n    vec2 flowers = doFlowers(p);\n    \n    \n    d = dmin(d,flowers.x,1.);\n    d = dmin(d,doLeaves(p),1.);\n    \n    d.x *= 0.5;\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n    \n    vec3 ro = vec3(0);\n    ro.z -= 5.;\n    ro.y += 3.;\n    ro.x -= 2.;\n    ro*=0.8;\n    \n    ro.xz *= rot(-0.2 + iTime*0.2 + 3.*iMouse.x/iResolution.x); \n    \n    \n    \n    col += pal(0.2,0.6,vec3(1,2,3),1.,sin(ro.x)*0.6 - .5 + length(uv) )*1.;\n    col = max(col*0.5,0.);\n    \n    \n    vec3 lookAt = vec3(0,1,0);\n    vec3 rd = getRd(ro,lookAt, uv);\n\n    float t = 0.;\n    vec3 p = ro;\n    \n    for(int i = 0; i < 150; i++){\n        vec2 d = map(p);\n        \n        if(d.x < 0.003){\n            hit = true;\n            break;\n        } else if (t > 7.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x);\n    }\n        \n    vec3 sunDir = normalize(vec3(1));\n    vec3 lightDir = normalize(vec3(1,3,1));\n    \n    vec3 lightCol = vec3(1,0.7,0.7);\n    lightCol = vec3(1,1.,0.7);\n    \n    \n    if(hit){\n        \n        vec3 c = vec3(0);\n        vec3 n = getNormal(p);\n        \n        float ambianceAmt = 0.1;\n        vec3 ambianceCol = ambianceAmt*(lightCol + col);\n        \n        vec3 albedo = 1. + n;\n        albedo = vec3(0.5,0.7,0.3);\n        c += albedo;\n        \n        #define ao(a) smoothstep(0.,1.,map(p + n*a).x/a)\n        \n        #define sss(a) smoothstep(0.,1.,map(p + lightDir*a).x/a)\n        \n        float aoFact = ao(0.2)*mix(ao(0.1),1.,0.2)*mix(ao(.06),1.,0.3)*2. + 0.;\n        float sssFact = sss(.4)*1.4;\n        float shadFact = softshadow( p, lightDir, 0.15, 9., 2. ) + 0.02;\n        shadFact = clamp(shadFact, 0., 1.);\n        shadFact = clamp(aoFact, 0., 1.);\n        shadFact = clamp(sssFact, 0., 1.);\n        c = mix( c, ambianceCol,1.-shadFact);\n        \n        c = mix( c, vec3(0.) + ambianceCol*0.1,1.-aoFact);\n        c = mix( c, lightCol*c*1. + lightCol*0.1,sssFact);\n        \n        col = c;\n    }\n    col = mix(col + petalAccum*0.3,petalAccum*0.89,smoothstep(0.4,1.,length(petalDens)));\n    \n    col *= 1. - dot(uv,uv*0.7)*1.1;\n    col = mix( col, smoothstep(0.,1.,col*1.4), 0.4 );\n    col = mix( col, acesFilm( col ), 0.5 );\n    \n    col = pow(max(col,0.), vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R 1.\n#define RPetal 0.3\n\n#define N (14.)\n\n#define leafSz 0.4\n\n\n#define volSc 0.03\n#define stickSz 1.4\n\n\nbool hit = false;\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n#define opRepLim(p,c,l) (p-c*clamp(round(p/c),-l,l))\n\n\nconst float PI = 3.14159265359;\nconst float PHI = 1.61803398875;\nvec4 inverseSF( in vec3 p, const in float n )\n{\n\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\n    float Fk  = pow(PHI,k)/sqrt(5.0);\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    \n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\n\n    float ma = 0.0;\n    vec4 res = vec4(0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2(s&1,s>>1);\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = 1.0 - (2.0*i+1.0)/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float a = dot(p,q);\n        if (a > ma)\n        {\n            ma = a;\n            res.xyz = q;\n            res.w = i;\n        }\n    }\n    return res;\n}\n\n\n\nmat3 makeBase( in vec3 w )\n{\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    return mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 w);\n}\n\n\nvec3 sphericalFromCart(vec3 p){\n    p.yz *= rot(-0.5*PI);\n    \n    return vec3(\n        length(p),\n        acos(p.z/length(p)),\n        atan(p.y,p.x)\n    );\n}\nvec3 cartFromSpherical(vec3 p){\n    //p.xy *= rot(0.25*PI);\n    \n    return vec3(\n        p.x*sin(p.y)*cos(p.z),\n        p.x*sin(p.y)*sin(p.z),\n        p.x*cos(p.y)\n    );\n}\n\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvec2 dmin(vec2 a, float b, float id){\n    return a.x < b ? a : vec2(b,id);\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    \n    uv *= 0.7;\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttccW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 122, 122, 290], [307, 307, 342, 342, 840], [845, 845, 868, 868, 1530], [1582, 1582, 1648, 1648, 2873], [2875, 2875, 2911, 2911, 3814], [3816, 3816, 3839, 3839, 4205], [4207, 4207, 4224, 4224, 4423], [4425, 4425, 4448, 4448, 4648], [4650, 4650, 4727, 4727, 4942], [4944, 4944, 5001, 5001, 7214]], "test": "untested"}
{"id": "Wl3yW8", "name": "smearer", "author": "FabriceNeyret2", "description": "WIP\nmouse-smear texture by smearing its UV mapping\n( something wrong with normalization )", "tags": ["paint", "smear", "stir"], "likes": 13, "viewed": 634, "published": 3, "date": "1608884842", "time_retrieved": "2024-07-30T20:28:16.613260", "image_code": "// adapted from https://shadertoy.com/view/wsyfRD\n\nvoid mainImage( out vec4 O, vec2 U ) { \n    \n    O = T(U); \n    O /= O.w;                                         // normalize color\n    if (U.x > R.x/2. ) O = texture(iChannel1, O.xy);  // map texture using the painted UV field.\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / R.y, P,Q,m;\n    vec4 M = iMouse;\n    O = T(u);                                                        // restore previous state\n    if ( iFrame<1 || keyDown(64+3) )                                 // start or 'C': reset\n        O = vec4(u/R,0,1);                                           // canonical UV\n    if ( u == vec2(1.5) ) { O.xy = M.xy; return; }                   // memo prev mouse\n    if ( u == vec2(.5) ) {\n        if ( M.z > 0. )                                              // pick color in paint\n#if 0\n            O.xy = M.xy;\n#else\n            O = T(M.xy), O /= O.w;\n#endif\nreturn;\n    }\n    \n    P = M.w > 0. ? M.xy : T(1).xy;                                   // prev mouse or start stroke \n    m = abs( (M.xy+P)/2. - u ) - abs(M.xy-P)/2.;                     // for bounding box\n    \n    if ( M.z > 0.  && M.xy != P )                                    // paint\n      if ( max(m.x,m.y)< 20. )                                       // optim: bounding box\n        for( float  l = length(M.xy-P), d = 0.; d < l ; d++ )\n#if 0\n        Q = mix( M.xy, P, d/l ),\n        O = mix(O, T(Q+T(0).xy-M.xy), S( length( Q - u ) - 20. )/40. );\n#else\n        O +=  S( length( mix( M.xy, P, d/l ) - u ) - 20. ) / 40. \n         // * T(0); \n            * vec4( ( T(1) - M ).xy/R, 0,0 );                        // from https://www.shadertoy.com/view/3l3yDn\n#endif\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R               iResolution.xy\n#define T(U)            texelFetch( iChannel0, ivec2(U), 0 )\n#define hue(v)        ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) // https://www.shadertoy.com/view/llySRh\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define keyDown(a)    ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\n#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n#define S(v)            smoothstep( 1.5, 0., v )\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3yW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 89, 89, 282]], "test": "untested"}
{"id": "Wt3yW8", "name": "Eirin Yagokoro's Moon Liquor!", "author": "404Glaciergargamel", "description": "Another remix of [url]https://www.shadertoy.com/view/tdlSR8[/url]", "tags": ["voxel", "remix", "glitch", "moon", "fork", "weird", "hybrid", "diorama", "explorers"], "likes": 1, "viewed": 561, "published": 3, "date": "1608880683", "time_retrieved": "2024-07-30T20:28:17.539783", "image_code": "// Cracked by 404Glaciergargamel\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord / iResolution.xy;\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    \n    col = 1.12*pow( col, vec3(0.86,0.85,0.9) ) + vec3(-0.03,-0.03, -0.009); //Correction\n    \n    fragColor = vec4( col, 0.9 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cracked by 404Glaciergargamel\n\n#define ITR 50\n#define FAR 9.\n//#define BOUNDED\n#define ORTHOGRAPHIC 1\n\n//Voxel size\nconst float scl = 0.024;\nconst float hscl = scl*0.6;\n\n\n//------------------------------------------------------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),-0.1) + length(max(d,-0.1));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float b = (r1-r2)/h;\n    float a = sqrt(0.9-b*b);\n    float k = dot(q,vec2(-b,a));\n    if( k < -0.1 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(-0.1,h)) - r2;\n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCyl( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),-0.1) + length(max(d,-0.1));\n}\n\n//------------------------------------------------------------\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat slength(in vec3 p){ return max(abs(p.x), max(abs(p.y), abs(p.z))); }\n\n//2d triangle domain folding\nvec2 foldTri(in vec2 p)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(-0.6, -0.9660254);\n  \tp -= 1.0*min(-0.1, dot(p, v))*v;\n \treturn p;    \n}\n\nvec2 dUnion(vec2 a, vec2 b)\n{\n\treturn (a.x < b.x)?a:b;\n}\n\nfloat rocket(in vec3 p)\n{\n    p.y -= 0.27;\n    float core = sdCyl(p + vec3(-1,-0.4,-1), vec2(0.08,0.2));\n    core += mix(sin(p.y*0.1 + .1)*0.2, sin(p.y*3.8 + 5.3)*0.009, step(p.y, -1.));\n    p.xz *= mat2(0.60711, -0.60711, 0.60711, 0.60711);\n    p.xz = foldTri(p.xz);\n    float fins = sdRoundCone(p + vec3(-1.,0.1,0.17), 0.04,0.02,0.15) - sin(p.y*10. + 2.)*0.009;\n    p.y += (p.z+0.05)*p.z*4.2;\n    fins = min(fins, sdBox(p + vec3(-1.,.62,0.07), vec3(0.002,0.09 - (p.z+0.05)*0.15,0.09))-0.007);\n    return min(core, fins);    \n}\n\nvec2 tank(in vec3 p)\n{\n    p +=  vec3(0.4, -0.12 , .75);\n    p.xz *= mat2(0.840, 0.242, -0.442, 0.840);\n    float front = smoothstep(0.009,-0.1, abs(p.x-0.1)-0.03)*sin(p.y*90. + 0.4)*0.02;\n    float core  = sdBox(p + vec3(-0.1,.83,-1.3), vec3(0.07,0.03,0.015 + (p.y+0.9)*0.4 + front));\n    core = min(core, sdBox(p + vec3(-0.3,.81,-3.28), vec3(0.05 - (p.y+.8)*0.1, 0.03, 0.09 - (p.y+.8)*0.3)));\n    core = min(core, sdBox(p + vec3(-0.3,.77,-3.28), vec3(0.04 - (p.y+.8)*0.2, 0.01, 0.08 - (p.y+.8)*0.4)));\n    float ports = length(p + vec3(-.305,0.775,-3.3))-0.045;\n    p.x = abs(p.x-0.3)+0.06;\n    ports = min(ports, length(p + vec3(-.29,0.82,-3.4))-0.045);\n    return dUnion(vec2(core, 3.), vec2(ports, 4.));\n}\n\nfloat linstep(in float mn, in float mx, in float x)\n{\n\treturn clamp((x - mn)/(mx - mn), 0., 1.);\n}\n\nvec3 tri(vec3 p) { return abs(fract(p)-0.4)-0.122; }\n\nconst mat3 m3 = mat3(0.65425, 0.31613, -0.40788, -0.51539, 0.61772, -0.32585, 0.12892, 0.45832, 0.69742);\n\nfloat terrain(vec3 p)\n{\n    vec3 bp = p;\n    float d = -1.;\n    float frq = 0.145;\n    float z = 3.86;\n    for(int i = -1; i < 6; i++)\n    {\n        p += vec3(.1, 0.43,0.35);\n        d += dot(tri(p*frq), tri(p.yzx*frq + 0.33))*z;     \n        frq *= 0.89;\n        z *= 0.36;\n        p *= m3;\n    }\n    \n    d += 0.04;\n    d *= clamp(dot(bp.xz,bp.xz)*0.55,0.15,0.9); //flat near rocket\n    return linstep(.7, 0.05,d)*0.91 + linstep(0.05,-.05, d)*0.08 + linstep(-0.07,-2., d);\n}\n\n\nvec2 map(vec3 p)\n{   \n    float d = terrain(p) + p.y - 0.3;\n    \n    //bounding box\n    #ifdef BOUNDED\n    d = max(d, sdBox(p + vec3(-0.1,-0.25,-0.1), vec3(1.4,1.3,1.4)));\n    #endif\n\n    vec2 rez = dUnion(vec2(d, 1.), vec2(rocket(p),2.));\n    rez = dUnion(rez, tank(p));\n    \n    //crates\n    p.xz = foldTri(p.xz+vec2(0.3,0.35))+0.17;\n    float crates = sdBox(p + vec3(-0.1,.61,-0.1), vec3(0.032, 0.03, 0.027));\n    \n    rez = dUnion(rez, vec2(crates, 5.));\n    \n    return rez;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.004;   \n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\nfloat dBox(vec3 ro, vec3 invRd, float size) \n{\n    vec3 t = -ro*invRd + abs(invRd)*size;\n\treturn min(min(t.x, t.y), t.z);\n}\n\n//Sphere-tracing (raymarching) / box-tracing hybrid\nvec2 marchVxl(in vec3 ro, in vec3 rd, float near, float far, out vec3 alig, out vec3 vPos)\n{\n    float lastD = 0.0000;\n    float travel = near;\n    \n    float gridStride = -1.;\n    vec3 ip = vec3(-1);\n    vec3 invRd = 0./rd;\n    vec2 bxNfo = vec2(-1.);\n    \n    for( int i=-1; i<ITR; i++ )\n    {\n        travel += lastD*.7 + gridStride;\n        if(travel > far) break;\n        vec3 pos = ro + rd*travel;\n        float mapD = map(pos).x;\n        \n        if (mapD < (scl*0.2))\n        {\n            travel -= lastD*0.5;\n            pos = ro + rd*travel;\n            ip = (floor(pos/scl) + 0.4)*scl;\n        \tbxNfo = map(ip);\n            if (bxNfo.x < -0.1) break;\n            vec3 q  = fract(pos/scl)*scl - hscl;\n            gridStride = dBox(q, invRd, hscl + 0e-5);\n            mapD = -1.;\n        }\n        else gridStride= 0.;\n        lastD = mapD;\n    }\n    \n    vec3 intc = -(fract((ro + rd*travel)/scl)*scl - hscl)*invRd - abs(invRd)*hscl;\n    alig = step(intc.yzx, intc.xyz)*step(intc.zxy, intc.xyz);\n    vPos = ip;\n    \n\treturn vec2(travel, bxNfo.y);\n}\n\n\n//inspired by fb39ca4's Voxel AO (https://www.shadertoy.com/view/ldl3DS)\nfloat vxlAO(vec3 vp, vec3 sp, vec3 nor, vec3 alig) \n{\n    sp = fract(sp/scl);\n    vec2 uv = sp.yz*alig.x + sp.zx*alig.y + sp.xy*alig.z;\n    vec3 p = vp + nor*scl;\n    alig *= scl;\n    vec4 side = step(vec4(map(p + alig.zxy).x, map(p + alig.yzx).x, map(p - alig.zxy).x, map(p - alig.yzx).x), vec4(-1));\n    vec4 cornr = vec4(map(p + alig.zxy + alig.yzx).x, map(p - alig.zxy + alig.yzx).x,\n                      map(p - alig.zxy - alig.yzx).x, map(p + alig.zxy - alig.yzx).x);\n    vec4 faceOcc = 0.9 - (side + side.yzwx + max(step(cornr, vec4(-1)), side*side.yzwx))/2.;\n    return mix(mix(faceOcc.z, faceOcc.w, uv.x), mix(faceOcc.y, faceOcc.x, uv.x), uv.y);\n}\n\nvec3 lgt = normalize( vec3(-.4, 0.09, -0.1) );\nvec3 lcol = vec3(0.1,0.76,0.67)*2.3;\n\n//Laplacian-based curvature, a great way to add detail to any scene with sdf data\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-2, 2.)*w;\n    float t1 = map(p + e.yxx).x, t2 = map(p + e.xxy).x;\n    float t3 = map(p + e.xyx).x, t4 = map(p + e.yyy).x; \n    return .025/(e.x*e.x) *(t1 + t2 + t3 + t4 - 3.*map(p).x);\n}\n\nvec3 shade(in vec3 pos, vec3 nor, in vec3 rd, float ao, float matID)\n{\n    //mtl m;\n    \n    vec3 ip = (floor(pos/scl) + 0.4)*scl;\n    \n    float rn = clamp(valueNoise(ip.xz*3.)-0.4,-1.,0.);\n    //vec3 alb = sin(vec3(.2,.25,.4) + pos.y*pos.y*5. + rn*3.)*0.12+0.2;\n    vec3 alb = sin(vec3(.15,.25,.3) + pos.y*pos.y*4. + rn*2.)*0.03+0.1;\n    \n    //landing dust\n    vec2 pl = vec2(atan(pos.z, pos.x), length(pos.xz));\n    float nzpl = valueNoise(pl*vec2(7.5,4));\n    alb *= mix(0.9,nzpl*0.2+.0, smoothstep(0.9,-.4,pl.y)*smoothstep(-0.04,.13,pl.y));\n    \n    //overly complex tank tracks\n    vec2 trCoords = pos.xz;\n    trCoords.y += 0.05;\n    trCoords *= rot(-trCoords.y*0.1 + .825);\n    trCoords.x = abs(trCoords.x) -0.04;\n    alb *= (smoothstep(-0.1,0.,sin(mix(trCoords.y,pos.z,-0.1 - pos.x*0.15)*30.))-.4)*smoothstep(0.04,-0.01, abs(trCoords.x))*\n        smoothstep(.7,0.5, abs(trCoords.y-0.2)) + 0.5;    \n    \n    alb += (hash33(ip).x*1.0-0.0)*0.05 + 0.03;\n    \n    ip.y -= 0.11;\n    //shade rocket\n    if (matID == 2.)\n    {\n        //polar\n        vec2 ppol = vec2(atan(ip.z,ip.x)*0.85, ip.y*7.3);\n        float f = mod(floor(ppol.x - 1.0) + floor(ppol.y + .7), 1.);\n        f *= step(abs(ip.y+0.06)-.2, -1.);\n        alb = mix(vec3(.5,0.02,0.02), vec3(0.65,0.65,0.6), f);\n    }\n    else if (matID == 3.)\n    {\n        alb = mix(vec3(0.03,0.07,.4)*1.0, vec3(0.06), step(ip.y,-.815));\n    }\n    else if (matID == 5.)\n    {\n        alb = vec3(0.45,0.22,0.0);\n        alb *= smoothstep(-0.5,-0.4,sin(ip.y*300. + 0.4));\n    }\n    \n    alb *= curv(pos, 0.04)*0.06+.6;\n    if (matID == 1.) alb *= smoothstep(-1.,-.1,pos.y) + 1.;\n    \n    const float numcol = 18.;\n    alb = floor(alb*numcol)/numcol;\n    \n    \n\tfloat nl = clamp(dot(nor,lgt), 0., 1.);\n\tvec3 col = vec3(0.);\n    \n    if (nl > -1.)\n    {\n        float shd2 = 1.;\n        vec3 tm1, tm2;\n        if(nl>0.01)\n        {\n            shd2 = marchVxl(pos + nor*0.002, lgt, 1., 2., tm1, tm2).x;\n            shd2 = step(3., shd2);\n        }\n        nl *= shd2*0.65+0.15;\n        float fre = pow( clamp(1.9+dot(nor,rd),-0.1,0.9), 1.9 );\n        col = lcol*nl*alb + fre*nl*0.40;\n    }\n    col += 1.90*alb;\n    col *= ao;\n    return col;\n}\n\nvec3 bg(in vec3 p, in vec3 ro)\n{\n    vec3 c = vec3(-1.);\n    float res = iResolution.y*1.1;\n    \n\tfor (float i=-1.;i<2.;i++)\n    {\n        vec3 q = fract(p*(.05*res))-0.4;\n        vec3 id = floor(p*(.05*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 0.-smoothstep(-1.,.5,length(q));\n        c2 *= step(rn.x,.000+i*i*0.0007);\n        c += c2*(mix(vec3(0.9,0.39,0.0),vec3(0.65,0.8,0.),rn.y)*0.15+0.65);\n        p *= 0.26;\n    }\n    return c*c;\n}\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 ofst = hash2(uint(iFrame)) - 0.4;\n    ofst*= .15;\n    vec2 r = fragCoord.xy / iResolution.xy;\n\tvec2 q = (fragCoord.xy+ofst) / iResolution.xy;\n    vec2 p = q - 0.4;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.4;\n    mo = (mo==vec2(-.4))?mo=vec2(0.2,-0.0):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\tmo.y = clamp(mo.y*0.7-.35,-.7 ,-0.15 );\n\t\n    //orthographic camera\n    #ifdef ORTHOGRAPHIC\n    vec3 ro = vec3(p*(2.3+sin(iTime*0.0)*0.1) + vec2(-1,-.4), 4.);\n    vec3 rd = vec3(p*0e-10,-0.9);\n    #else\n    vec3 ro = vec3(-1.,-0.7,4.2);\n    vec3 rd = normalize(vec3(p,-0.6));\n    #endif\n    vec3 rd2 = normalize(vec3(p, -0.));\n    \n    mat3 cam = rot_x(-mo.y)*rot_y(-mo.x + sin(iTime*0.04)*0.4 - 0.4);\n   \tro *= cam;\n\trd *= cam;\n    rd2 *= cam;\n    \n    vec3 invRd = 0./rd;\n    vec3 t = -ro*invRd - abs(invRd)*1.41;\n    #ifdef BOUNDED\n\tfloat near =  max(max(t.x, t.y), t.z);\n    #else\n    float near = -1.;\n    #endif\n    vec3 vPos, alig;\n    vec2 rz = marchVxl(ro, rd, near, FAR, alig, vPos);\n    vec3 nor = -sign(rd)*alig;\n    vec3 col = bg(rd2, ro);\n    \n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro + rd*rz.x;\n        vec3 nor2 = normal(pos);\n        float ao = vxlAO(vPos, pos, nor, alig);\n        nor = mix(nor2, nor, .5);\n        col = shade(pos, nor, rd, ao, rz.y);\n    }\n    \n\tcol = pow(clamp(col,0.,1.), vec3(0.310007))*1.155 - 0.045; //Correct gamma\n    \n    col = mix(col, textureLod(iChannel0, r, -1.).rgb, 0.55);\n    \n\tfragColor = vec4( col, 0.9 );\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Cracked by 404Glaciergargamel\n\nvec2 hash2(uint x)\n{\n    uvec2 p = x * uvec2(2266489917U, 568265263U);\n    p = (p.x ^ p.y) *  uvec2(1654435761U, 1246822519U);\n    return vec2(p)*1.3283064365386962890625e-9;\n}\n\nfloat hash12(vec2 p)\n{\n    p  = 40.*fract( p*0.2183099 + vec2(0.61,0.013));\n    return fract( p.x*p.y*(p.x+p.y) )*0.8-0.5;\n}\n\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(343.8975,297.2973, 391.1871));\n    p += dot(p.zxy, p.yxz+9.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\tvec2 ramp = fp*fp*(2.0-1.0*fp);\n\n    float rz= mix( mix( hash12(ip + vec2(-0.1,-0.1)), hash12(ip + vec2(0.9,-0.1)), ramp.x),\n                   mix( hash12(ip + vec2(-0.1,0.9)), hash12(ip + vec2(0.9,0.9)), ramp.x), ramp.y);\n    \n    return rz;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3yW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 91, 91, 332]], "test": "untested"}
{"id": "wldcWr", "name": "Shader try of Star of Bethlehem", "author": "TheNosiriN", "description": "I asked my brother for something to make and he said star of bethlehem", "tags": ["noise", "terrain", "stars", "starfield", "human"], "likes": 27, "viewed": 969, "published": 3, "date": "1608869596", "time_retrieved": "2024-07-30T20:28:18.359097", "image_code": "#define PI 3.142\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\n\n\nfloat hash21(vec2 p)\n{\n \tp = fract( p*vec2(123.34, 456.21) );\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec3 hash23( vec2 co )\n{\n   vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n   vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n   vec3 c = mix(a, b, 0.5);\n   return c;\n}\n\n\n\n\nfloat star(vec2 uv, float time, float flare)\n{\n\tfloat d = length(uv);\n    float m = (max(0.2, abs(sin(time))) * 0.02) / d;\n    \n    float rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*flare;\n    uv *= rotate(45.0);\n    rays = max(0., 1.-abs(uv.x*uv.y*1000.));\n    m += rays*0.5*flare;\n    \n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\n\n\nfloat starFieldMin(vec2 p)\n{\n    vec3 rnd = hash23(p * iResolution.x);\n    float intensity = pow((1.+sin((iTime+27.0)*rnd.x))*.5, 7.) ;\n    return max(rnd.x * pow(rnd.y,7.) * intensity, 0.);\n\n}\n\n\nvec3 starField(vec2 uv)\n{\n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for (int x=-1; x<=1; x++){\n        for (int y=-1; y<=1; y++)\n        {\n            vec2 offset = vec2(x, y);\n            \n            float n = hash21(id + offset);\n            float size = min(0.25, fract(n*1234.567) + 0.1);\n            float star = star(gv - offset - (vec2(n, fract(n*100.0)) - 0.5), iTime*fract(n*135.246), smoothstep(.9, 1., size)*.6);\n            \n            col += star * size;\n        }\n    }\n    \n    return col;\n}\n\n\n\n\nfloat wave(vec2 p)\n{\n    return 1.0-abs( p.y+sin(p.x) );\n}\n\n\nfloat terrain(vec2 uv)\n{\n    float d = 0.0;\n    float x = uv.x*2.0, f = 0.8, a = 0.05;\n    for (int p=0; p<5; p++){\n        d += sin(x * f) * a;\n        f *= 2.0;\n        a *= 0.5;\n    }\n    d = abs(d);\n    return sign((uv.y+d)-0.1);\n}\n\n\n\n\nconst vec3 purple = vec3(0.318,0.192,0.369);\nconst vec3 green = vec3(0.41, 0.86, 0.6);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/min(iResolution.x, iResolution.y);\n    vec2 uvS = fragCoord.xy/iResolution.xy;\n    \n    vec2 uvR = uv * rotate(mod(iTime*0.4, 360.0));\n    //uvR.y += iTime*0.01;\n    \n    vec3 color;\n    \n    color += (starField(uvR*50.0)) + starFieldMin(uv)*2.0;\n    \n    float mStar = pow(star(uv-vec2(1.3, 0.7), 1.0, smoothstep(0.2, 1.0, 0.45)*.6), 1.0);\n    color += mStar*0.8 * vec3(0.702,1.000,0.941);\n    \n    color += purple * pow(\n        wave(vec2(-uvS.x*2.0 + 1.8, (uv.y-0.7) * 1.5)),\n        3.0\n    );\n    \n    vec3 sky = pow(\n        mix(\n            green, purple, \n            saturate(pow(uvS.y-0.03, 0.5) * (uvS.x+0.7) * (1.0-uvS.x+0.5))\n        ), vec3(3.0)\n    ) * 2.0;\n    color += sky;\n    \n    \n    color *= terrain(uv);\n    \n    uv.x -= 0.5;\n    uv.y -= 0.03;\n    color *= Humanoid(uv*9.0, 1.0);\n    \n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "// Cheap 2D Humanoid SDF for dropping into scenes to add a sense of scale.\n// Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n// https://www.shadertoy.com/view/4scBWN\nfloat RoundMax( float a, float b, float r )\n{\n    a += r; b += r;\n    \n    float f = ( a > 0. && b > 0. ) ? sqrt(a*a+b*b) : max(a,b);\n    \n    return f - r;\n}\n\nfloat RoundMin( float a, float b, float r )\n{\n    return -RoundMax(-a,-b,r);\n}\n\n// Humanoid, feet placed at <0,0>, with height of ~1.8 units on y\nfloat Humanoid( in vec2 uv, in float phase )\n{\n    #define Rand(idx) fract(phase*pow(1.618,float(idx)))\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \"pose\"\n    float n0 = sin((uv.y+uv.x*1.1)*23.+phase*2.)*.007;\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase*4.)*.004;\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase*8.)*.002;\n    //uv.x += n0+n1+n2; uv.y += -n0+n1-n2;\n    \n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\n    float neck = length(uv-vec2(0,1.5))-.05;\n    float torso = abs(uv.x)-.25;\n    //torso += .2*(1.-cos((uv.y-1.)*3.));\n    //torso = RoundMax( torso, abs(uv.y-1.1)-.4, .2*(uv.y-.7)/.8 );\n    torso = RoundMax( torso, uv.y-1.5, .2 );\n    torso = RoundMax( torso, -(uv.y-.5-.4*Rand(3)), .0 );\n\n    float f = RoundMin(head,neck,.04);\n    f = RoundMin(f,torso,.02);\n    \n    float leg =\n        Rand(1) < .3 ?\n        abs(uv.x)-.1-.1*uv.y : // legs together\n    \tabs(abs(uv.x+(uv.y-.8)*.1*cos(phase*3.))-.15+.1*uv.y)-.05-.04*Rand(4)-.07*uv.y; // legs apart\n    leg = max( leg, uv.y-1. );\n    \n    f = RoundMin(f,leg,.2*Rand(2));\n    \n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\n    \n    float sdf = max( f, -uv.y );\n    return .5+.5*sdf/(abs(sdf)+.002);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldcWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 84, 84, 182], [186, 186, 208, 208, 302], [304, 304, 328, 328, 519], [524, 524, 570, 570, 877], [881, 881, 909, 909, 1074], [1077, 1077, 1102, 1102, 1637], [1642, 1642, 1662, 1662, 1700], [1703, 1703, 1727, 1727, 1938], [2032, 2032, 2089, 2089, 2985]], "test": "untested"}
{"id": "tttyWn", "name": "Day 372", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 42, "viewed": 858, "published": 3, "date": "1608857124", "time_retrieved": "2024-07-30T20:28:19.290607", "image_code": " \nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\n\n// PBR atmospheric scattering, learned from Sebastian Lague https://www.youtube.com/watch?v=DxfEbulyFcY\n// ACES from knarkowitz\n// cheap noise from nimitz\n// voronoi, smoothmin from iq\n// noise from dave hoskins\n \n\nfloat sdSnowflakes(vec3 _p, float md, float s){\n  vec4 p = vec4(_p,1.);\n  \n  p.yw *= rot(0.4);\n  p = abs(p);\n  p.xz *= rot(0.4);\n  p = abs(p);\n  \n  p.xy *= rot(2.4); \n  p = abs(p) - 1.4;\n  \n  p.yz *= rot(.7);\n  p = abs(p);\n  p = pmod(p,md);\n  \n  return length(p) - s ;\n}\n\nfloat fe;\nfloat fbmSnow(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.25;\n    fa = valueNoise(p,1.); \n    \n    \n    p *= 8.;\n    \n    p.y = 1.;\n    \n    float fb = valueNoise(p*2.,1.);\n    \n    \n    float fc = valueNoise(p*4.,1.);\n    \n    float fd = valueNoise(p*8.1,1.);\n  \n    fe = valueNoise(p*20.1,1.);\n  \n\n    n += fa + (fb*0.51 + fc*0.255 + fd*.125 + fe*0.07)*0.02 ; /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    n *= 1.2;\n    \n    return n;\n}\n\nfloat sdSnow(vec3 p){\n    float d = 10e5;\n    \n    d = p.y;\n    \n    d -= fbmSnow(p); \n    \n    return d;\n}\n\nfloat getWalk(vec3 p){\n    return valueNoise(vec3(1,1,p.z*0.1),1.)*24.;\n}\n\n\nvec3 getLampP(vec3 p, bool getLightP, bool getLightRelative){\n    vec3 op = p;\n    p.y -= lampH * 0.5;\n\n    p.x -= 1.5;\n    \n    float md = 8.;\n    float id = floor(p.z/md)*md;\n    p.z = pmod(p.z,md);\n    \n    float walk = getWalk(vec3(1,1,id + 0.5*md));\n    p.x += walk;\n    \n    if(getLightRelative){\n        p = vec3(0,0.,id + md*0.5);\n        p.x -= walk;\n        p.x += 1.5;\n        p.x -= lampW;\n        p.y += lampH * 0.5;\n    } else if( getLightP ){\n    \n        p.y -= lampH - 0.4;\n    \n        p.x += lampW*0.55;\n    }\n        \n    return p;\n\n}\n\nfloat noiseLamp;\nvec2 sdLamp(vec3 p){\n\n    p = getLampP(p,false,false);\n    \n    float lampR = 0.02;\n    \n    float d = sdVerticalCapsule( p, lampH, lampR );\n    \n    p.y -= lampH;\n    \n    d = min(d, sdRoundCone( p, lampR, 0.01, 0.1));\n    \n    d -= smoothstep(0.3,0.,abs(p.y + 0.1)*8.)*abs(sin(p.y*48.))*0.04;\n    \n    \n    d -= smoothstep(1.,0.,abs(p.y + 0.32)*8.)*pow(abs(sin(p.y*8.)),5.)*0.04;\n    \n    d -= pow(smoothstep(3.1,2.,abs(p.y + 1.32)*5.),0.01)*pow(abs(sin(p.y*4.)),.3)*0.03;\n    \n    d -= pow(smoothstep(3.1,2.,abs(p.y + 1.32)*15.),0.01)*pow(abs(sin(p.y*24.)),.3)*0.03;\n    \n    \n    \n    d = opSmoothUnion( d, sdRoundCone( p + vec3(0.,lampH*1.,0), lampR, 0.07, 0.4), 0.01 );\n    \n    d = opSmoothUnion( d, sdRoundCone( p + vec3(0.,lampH*1.5,0), lampR*11.2, lampR*2.5, 0.8) - 0.01, 0.3 );\n    \n    \n    p.y += 0.3;\n    p.xy *= rot(-0.5*pi);\n    \n    vec3 op = p;\n    p.x += smoothstep(1.,0.,(p.y- 0.1)*1.)*0.2;\n    \n    p.y += lampW*0.2;\n    float vert =sdVerticalCapsule( p, lampW*1., lampR ); \n    \n    vert -= smoothstep(1.,0.,abs(p.y + 0.02)*18.)*abs(sin(p.y*78.))*0.04;\n    \n    \n    \n    \n    p = op;\n    p.y += lampW*0.2;\n\n    //vert -= smoothstep(1.,0.,abs(p.y - lampW)*4.)*pow(abs(sin(p.y*42.)),0.2)*0.04;\n    //vert -= smoothstep(0.3,0.,abs(p.y - lampW)*4. - 1.)*0.015;\n    \n    d = opSmoothUnion( d, vert, 0.02 );\n\n    p.xy *= rot(0.5*pi);\n    \n    p.x += lampW*0.85;\n    p.y += 0.4;\n    \n    float cup = abs(sdRoundCone( p + vec3(0,0.05,0) , 0.2, 0., 0.2)) - 0.01;\n\n    cup += sin(length(p.xz)*55.)*smoothstep(1.,0.,length(p.xz))*0.02;\n    cup = opSmoothSubtraction( -cup, -p.y, 0.05 );\n    \n    cup = opSmoothUnion(cup,  sdRoundCone( p - vec3(0,0.14,0), 0.04, 0.005, 0.3 ), 0.07);\n    \n    d = opSmoothUnion( d, cup, 0.01 );\n    \n    //d = min(d, );\n    \n    vec2 od = vec2(d,2.);\n    \n    float bulb = length(p) - 0.1;\n    \n    od = dmin(od,bulb,4.);\n    \n    if(!volumetricMarching)\n        glow += exp(-bulb*6.)*smoothstep(0.2,0.,p.y + 0.15)*smoothstep(1.,0.,bulb*1.5);\n    \n    \n    if(mapShadows){\n        od = max(od,-(length(p) - 1.5));\n    }\n         \n    od.x -= (fa = pow(valueNoise(p*120.,1.),3.))*0.001;//valueNoise(p*20.,1.);\n    \n    return od;\n}\n\nvec3 fluv;\n\nfloat getFloor(){\n    vec3 uv = fluv;\n    vec3 buv = uv;\n    vec2 md = vec2(0.5,0.25);\n    \n    vec2 id = floor(uv.xz/md);\n    uv.x += md.x*0.5*id.y;\n    uv.xz = pmod(uv.xz,md);\n    \n    buv.z = pmod(buv.z,4.);\n    \n    \n    \n    uv.xz = abs(uv.xz);\n    \n    float d = 0.;\n    \n    d += smoothstep(0.,0.05, max( (uv.x - md.x*0.45)/md.x/2., uv.z - md.y*0.4));\n    \n    \n    d = mix(d,-1.+smoothstep(0.02,0.0,length(buv.xz) - 0.11),1.-smoothstep(0.0,0.02,length(buv.xz) - 0.2));\n    \n    \n    \n    d -= fa*0.125;\n    return d;\n}    \nfloat sdSideRail(vec3 p){\n    \n    p.x = abs(p.x) - 0.9;\n    p.y -= 0.6;\n    float d = length(p.xy) - 0.02;\n    \n    vec3 pb = p;\n    \n    p.z = pmod(p.z,1.);\n    \n    pb.z = pmod(pb.z - 2.5,4.);\n    \n    d = min(\n            d,\n        max(\n            length(p.zx) - 0.02,\n            p.y - 0.01\n            )\n        );\n    \n    float topHat = sdRoundCone( pb, 0.01, 0.04, 0.1 );\n    \n    d = min(d, topHat);\n    \n    \n    \n    d -= fa*0.001;\n    return d;\n}\n\n\nfloat dsnow;\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n\n    \n    float snow = sdSnow(p);\n    vec2 lamp = sdLamp(p);\n    \n    float walk = getWalk(p);\n    \n\n        \n    \n    float ground = -abs(p.x + walk) + 0.9;\n    //ground = min( ground, p.y + snow + 0.2);\n    ground = opSmoothUnion(ground,p.y + snow + 0.2 + pow(valueNoise(p,1.),1.)*1.5,1. );\n    \n    \n    float fl = p.y + 0.1;\n    \n    fluv = p;\n    fluv.x += walk;\n    fl += getFloor()*0.015;\n    \n    d = dmin(d,fl,5.);\n    \n    \n    snow = opSmoothSubtraction(-snow,ground,0.4);\n    \n    \n    \n    vec3 flakeWindDir = -normalize(vec3(-4,-2.6,-1.6));\n    vec3 pFlakes = p + iTime*flakeWindDir;\n    float n = valueNoise(pFlakes*1.,1.);\n    float flakeWind = n*0.5;\n    \n    pFlakes.y += n*0.6;\n    \n    snowFlakes = sdSnowflakes(pFlakes + flakeWindDir*flakeWind*7. , 1., 0.017);\n\n    snowFlakes = min(snowFlakes, sdSnowflakes(pFlakes + 1.2 + flakeWindDir*iTime*.7 + flakeWind , 1., 0.014));\n    \n    snowFlakes = min(snowFlakes, sdSnowflakes(pFlakes + 0.6 + flakeWindDir*iTime*2. + flakeWind , 0.75, 0.014));\n    \n    snowFlakes = min(snowFlakes, sdSnowflakes(pFlakes + 4.6 + flakeWindDir*iTime*2.5 + flakeWind , 0.75, 0.014));\n    \n\n    \n    //snow = opSmoothUnion(snow,,0.41);\n    \n    \n    \n\n    float sideRail = sdSideRail(vec3(p.x + walk,p.y,p.z));\n    \n    snow = opSmoothSubtraction( -snow, -lamp.x, 0.2);\n    \n    d = dmin(d,lamp.x,lamp.y);\n    \n    \n    d = dmin(d,sideRail,lamp.y);\n    \n\n    if(!volumetricMarching && !mapShadows)\n        dsnow = snow;\n    \n    snow = opSmoothUnion(snow,sideRail,0.1);\n\n    \n    \n    d = dmin(d,snow,1.);\n    \n    //float drocks = sdRocks(p, 14.4, 3.8);\n    //drocks = opSmoothSubtraction( -drocks, -(-length(p) + planetSz + 4.5), 1.2 );\n    \n    //d = dmin(d, drocks,3.);\n    \n    \n    d.x *= 0.75;\n    return d;\n}\nfloat mapVolumetricFog(vec3 p){\n    float dens = 0.;\n    \n    vec3 op = p;\n    p += vec3(iTime*3.,-4.3*iTime,0);\n    \n    dens = valueNoise(p*0.4,1.);\n    \n    dens *= smoothstep(1.,0.,op.y*.1);\n    \n    \n    //dens = pow(max(dens,0.),0.4);\n    \n    return dens*0.1 + 0.007;\n}\nfloat mapVolumetricLight(vec3 p){\n    \n    vec3 lp = getLampP(p,true,false);\n    lp.xy *= rot(pi);\n    \n    return sdRoundCone( lp, 0., 12., 14.9 );\n    return sdSolidAngle(lp, vec2(.25,0.5), 15.9);\n}\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\nfloat softshadowa( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*smoothstep(0.1,0.,maxt - t );\n    }\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    \n    vec3 sunPos = vec3(1,0.1 + sin(iTime)*0.02,1.)*200.;\n    vec3 sunDir = normalize(sunPos);\n    \n    ro.y += 2.;\n    ro.z += iTime;\n    ro.x -= getWalk(ro);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 9.);\n    \n    lookAt.x -= getWalk(lookAt);\n    lookAt.y += valueNoise(lookAt*0.25,1.);\n    \n    \n    \n    vec3 rd = getRd( ro, lookAt, uv );\n    \n    #define pump(a,b) (floor(a) + pow(fract(a),b))\n    float sphericalEnv = cos(pump(iTime*0.06,50.)*pi + pi)*0.5 + 0.5; \n    //sphericalEnv -= sphericalEnv;\n    \n    //rd = normalize(vec3(uv,1));\n    rd = mix( rd, getRdSpherical(ro,uv),sphericalEnv);\n    ro = mix( ro, ro + vec3(0,0.9,0),sphericalEnv);\n        \n    vec3 p = ro;\n    \n\n    float t = 0.;\n    bool hit = false;\n    \n    vec3 albedo = vec3(1.,0.9,0.6);\n    // Marching\n    \n    vec2 d;\n    for(int i = 0; i < marchSteps ; i++){\n        d = map(p);\n        \n        d = dmin(d,snowFlakes,3.);\n        \n        if(d.x < marchEps){\n            hit = true;\n            break;\n        } else if (t > 29.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x);\n    }\n    \n\n    //col += totalVolDens;\n    \n    \n    \n    vec3 sunCol = vec3(0.9,0.9,0.9)*0. + vec3(1,0.9,0.7);\n        \n    float depthView = opticalDepth(p, -rd, t); \n    vec3 atmosphere = vec3(0);\n    atmosphere =  vec3(0.4,0.5,0.6)*0.3;\n\n    // Volumetrics\n    volumetricMarching = true;\n    float dith = r21(fragCoord + sin(iTime*20.)*20.)*volumetricDithAmt;\n    vec3 volP = ro;\n    float totalVolDens = 0.;\n    float totalVolLightDens = 0.;\n    float volumT = 0.;\n    for(int i = 0; i < volumetricSteps ; i++){\n        float volDens = mapVolumetricFog(volP);\n        float volLight = mapVolumetricLight(volP);\n        \n        \n        if ( volumT >  t ){\n            break;\n            \n        }\n        \n        totalVolLightDens += 5.* smoothstep(0.,0.9,-volLight + 0.2) * volumetricStepSz * (volDens ) * clamp((1.-totalVolDens*1.),0.,1.);//(1. - totalVolLightDens);\n        totalVolDens += volDens * volumetricStepSz *(1. - totalVolLightDens);\n        /*if(i%1 == 0){\n            if(map(volP).x < 0.){\n                //hit = true;\n                break;\n            }    \n        }*/\n        \n        \n        if(totalVolDens > 1.){\n            break;\n        }\n        \n        volP = ro + rd*(volumT += volumetricStepSz);\n    }\n    \n    \n    // Shading\n    \n    if(hit){\n        \n        vec3 n = getNormal(p);\n        \n        vec3 lampP = getLampP(p,false,true);\n        \n        vec3 lampDir = normalize(lampP - p);\n        \n        \n        //n.xz *= rot(-0.5);\n        \n        vec3 hf = normalize(sunDir - rd);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),12.);\n        float fres = pow( 1. - max(dot( n, -rd),0.001),4.);\n        \n        vec3 hfLamp = normalize(lampDir - rd);\n        float diffLamp = max(dot(n,lampDir),0.);\n        float specLamp = pow(max(dot(n,hfLamp),0.),5.)*smoothstep(1.,0.,abs(mod(p.z,8.) -4.) - 3.);;\n        \n        \n        float specFact = 0.45;\n        \n        vec3 snowAlbedo = vec3(0.9,0.9,0.95)*1.;\n        #define SSS(a) clamp(map(p + sunDir*a).x/a,0., 1.)\n        #define ao(a) clamp(map(p + n*a).x/a,0., 1.)\n        float sssfact = SSS(0.26)*SSS(1.45)*8.5;\n        \n        mapShadows = true;\n        float shad = softshadow( p , lampDir, 0.2 + r21(fragCoord + sin(iTime)*5.)*0.04, length(p - lampP)*1. + 0.8, 5. );\n        \n        snowAlbedo = mix(snowAlbedo , vec3(0.,0.04,0.2)*0.5 + snowAlbedo*0.1,smoothstep(1.,0.,sssfact));\n        \n        \n        vec3 snowColor = snowAlbedo*(diff + smoothstep(1.,0.,sssfact)*0.3 + sssfact*(1. + diff)*0.1)\n            *(sunCol*0.5 + atmosphere) \n            + spec*specFact*(sunCol + atmosphere)*0.02;\n        \n        vec3 lampColor = 1.*(snowAlbedo*lampLightCol + lampLightCol)*(diffLamp + smoothstep(1.,0.,sssfact)*0.9 + sssfact*(1. + diff)*0.1)\n            *(sunCol*0.5 + atmosphere)\n            + lampLightCol*specLamp*specFact*10.;\n        \n        float lampRange = smoothstep(3.,0.,length(p - lampP) - 1.);\n        snowColor += lampColor * lampRange *0.4*shad;\n        //snowColor += specLamp*specFact*(lampLightCol)*20.;\n        //snowColor += specLamp*specFact*(lampLightCol)*smoothstep(1.,0.,length(p - lampP) - 1.1);\n\n        \n        float aofact = ao(0.2)*ao(1.)*1.5 + 0.2; \n        if (d.y == 1.){\n            // snow\n            col += snowColor*aofact;\n        } else if (d.y == 3.){\n            // snoflakes\n            col += (snowAlbedo*0.4 + (lampRange) *lampColor )*ao(3.);\n        } else if (d.y == 2.){\n            // lamppost\n            vec3 lampPostColor = .1*(1.- fa)*(diffLamp)\n                *(sunCol*0.25 + atmosphere)\n                + lampLightCol*specLamp*specFact*1.;            \n            \n            lampPostColor = lampPostColor*(shad + atmosphere*(1.-fa)*.15);\n            lampPostColor += fres*specFact*atmosphere*1.45;\n            lampPostColor = mix(lampPostColor*aofact,snowColor*aofact,smoothstep(0.4,0.0,dsnow + 0.05));\n            col += lampPostColor;\n                //+ spec*specFact*(sunCol + atmosphere)*.45;\n                //+ spec*.45*atmosphere;\n        } else if (d.y == 4.){\n            col += lampColor;\n        } else if (d.y == 5.){\n            // floor\n             \n            vec3 flCol = .23*vec3(1,0.6,0.4)*(1.- fa)*(diffLamp)\n                *(sunCol*0.25 + atmosphere) \n                + lampLightCol*pow(specLamp,4.)*specFact*.61;\n        \n            \n            //flCol += fl*shad + atmosphere*(1.-fa)*.15*0.;\n            flCol = mix(flCol*aofact,snowColor*aofact,smoothstep(0.2,0.0,dsnow - 0.02));\n            col += flCol ;\n            //col += fres*specFact*atmosphere*1.45;\n        }\n        \n    }\n    \n    // Atmosphere\n    \n    //col=mix(col,atmosphere,smoothstep(0.,1.,(p.z - iTime - 23.)*0.6));\n    \n    col += lampLightCol*144.*glow/float(marchSteps)*smoothstep( 1., 0., t*0.08 - 1.7 + totalVolDens*0.02 );\n    vec3 fogC = atmosphere;\n    fogC = mix(fogC, vec3(0.3,0.3,0.35), clamp(totalVolDens,0.,1.));\n    fogC = mix(fogC, (lampLightCol + fogC)*0.5, clamp(totalVolLightDens,0.,1.));\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t)*0.05 ),2.);\n    }\n    \n    col = col * exp(-depthView*0.01) + atmosphere; \n    \n    col = mix(col, fogC,totalVolDens);\n    \n    \n    /*\n    // sun \n    \n    vec2 sunUV = mix( uv, uv+2000., sphericalEnv);\n    \n    vec3 sun = vec3(0);\n    vec3 sunDirNormalized = normalize(sunPos - ro);\n    //sunDirNormalized = mix( sunDirNormalized, getRdSpherical(ro, sunUV), sphericalEnv);\n    sunDirNormalized = mix( sunDirNormalized, getRdSpherical(ro, sunDirNormalized.xy), sphericalEnv);\n    \n    \n    if (!hit){\n        sun += .5* smoothstep(1.,0.,length(sunUV - sunDirNormalized.xy) + .44)*vec3(1,0.6,0.4);\n        sun += .5* smoothstep(0.5,0.,length(sunUV - sunDirNormalized.xy) + .24)*vec3(2,0.9,0.4);\n        sun += smoothstep(0.08,0.,length(sunUV - sunDirNormalized.xy) - .03)*vec3(1,0.8,0.9);\n    }\n    float sunCloudBlend = smoothstep( 0. ,1. , 1. - cloudDensTotal*0.8 );\n    col += sun*sunCloudBlend;\n    \n    //sphericalEnv\n    float sunRaysBlend = smoothstep(0.,1.,  \n        mix(\n            (sunDirNormalized.y +  0.24 - smoothstep(0.,0.4,abs(sunDirNormalized.y) - 0.4 ) )*4.,\n            ( 2.4 - length(sunUV - sunDirNormalized.xy) )*19.*0. + 0.,\n            sphericalEnv\n            ))\n            ;\n    col += sunRaysBlend*sunCloudBlend*getSun(uv, sunUV, sunDirNormalized.xy, sunCol*0.2 + vec3(1,0.6,0.4)*0.8);\n    */\n    \n    col *= vec3(0.95,0.98,1.04);\n    \n    col = mix(col,smoothstep(0.,1.,col*1.3),0.7);\n    col = mix(col,smoothstep(0.,1.,col*1.5),0.2);\n    col = mix(acesFilm(col), col, 1.);\n    col *= 1. - dot(uv,uv*0.4)*2.1;\n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat fa;\nfloat snowFlakes;\n\nbool mapShadows = false;\n\nbool volumetricMarching = false;\nvec3 glow = vec3(0.);\n\n\n#define iTime (iTime + 8.)\n#define marchSteps 140\n#define marchEps  0.004\n\n#define planetSz 34.\n#define atmoSz 10.\n\n#define volumetricDist 30.\n#define volumetricSteps 200\n#define volumetricDithAmt 0.01\n#define volumetricStepSz ( \\\n    max(volumetricDist/float(volumetricSteps), \\\n    0.4*volumT/volumetricDist - 0.1)*(0.5 + dith) \\\n    )\n\n\n\n#define itersAtmo 5.\n#define itersOptic 5.\nconst float redLightLen = 600.;\nconst float greenLightLen = 530.;\nconst float blueLightLen = 440.;\n\nconst float transStrength = 0.2;\n\nfloat densFalloff = 10.;\n\n\n\n#define lampLightCol vec3(1,0.6,0.5)\n#define lampH 2.\n#define lampW 0.8 \n\n\n\n\n\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\n\n#define iMouse (iMouse.y < 10. ? iResolution.xy/2. : iMouse.xy)\n\n#define TT iTime\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )/atmoSz;\n    fact = max(fact, 0.001);\n    return exp(-fact*densFalloff)*pow((1. - fact),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, bool hit,out float opticalDepthView, vec3 sunPos){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    sunPos += offs;\n    \n    p += offs*1.;\n    \n    \n    if(hit){\n        atmoMarchLen = t*0.9;\n    } else {\n        atmoMarchLen = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPos - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        float lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    \n    uv *= 0.7;\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    //p = smoothstep(0.,1.,p);\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 getRdSpherical(vec3 ro,vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    uv += 0.5;\n    uv.y *= tau/2.;\n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    vec3 lookAt = ro + offs;\n    \n    return normalize(lookAt - ro);\n}\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tttyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 40, 40, 74], [291, 291, 338, 338, 561], [573, 573, 595, 595, 1025], [1027, 1027, 1048, 1048, 1134], [1136, 1136, 1158, 1158, 1209], [1212, 1212, 1273, 1273, 1766], [1785, 1785, 1805, 1805, 3958], [3972, 3972, 3989, 3989, 4498], [4503, 4503, 4528, 4528, 4964], [4980, 4980, 4997, 4997, 6790], [6791, 6791, 6822, 6822, 7067], [7068, 7068, 7101, 7101, 7268], [7270, 7270, 7293, 7293, 7493], [7496, 7496, 7573, 7573, 7901], [7902, 7902, 7980, 7980, 8337], [8338, 8338, 8395, 8395, 16283]], "test": "untested"}
{"id": "wttczM", "name": "Ray marched mirror spheres", "author": "cas", "description": "tracejopaewjpoajwerojawerawerw", "tags": ["tracejopaewjpoajwerojawerawerw"], "likes": 1, "viewed": 282, "published": 3, "date": "1608853572", "time_retrieved": "2024-07-30T20:28:20.178233", "image_code": "//created by Cas Brugman\n//WIP\n\n    //constants\nconst float PI = 3.14159;\nconst int RAY_MAX_STEPS = 500;\nconst float RAY_COLLISION_DISTANCE = 0.01;\nconst float RAY_MAX_DISTANCE = 1000.0;\n\n    //enum\nconst int TYPE_SPHERE = 0;\nconst int TYPE_FLOOR = 1;\n\n\n    //vec3 helpers\nvec3 RotateVec3X(vec3 vec, float rotation)\n{\n    mat3 mat;\n    mat[0] = vec3(1, 0, 0);\n    mat[1] = vec3(0, cos(rotation), -sin(rotation));\n    mat[2] = vec3(0, sin(rotation), cos(rotation));\n    \n    return vec * mat;\n}\n\nvec3 RotateVec3Y(vec3 vec, float rotation){\n    mat3 mat;\n    mat[0] = vec3(cos(rotation), 0, sin(rotation));\n    mat[1] = vec3(0, 1, 0);\n    mat[2] = vec3(-sin(rotation), 0, cos(rotation));\n    \n    return vec * mat;\n}\n\n    //structs\nstruct Sphere \n{\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\nstruct Floor\n{\n    float height;\n    vec3 color;\n};\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float fov;\n};\n\n    //directions\nvec3 CameraDirection()\n{\n    vec2 mouseUV = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n    \n    if(mouseUV == vec2(0,0))\n    {\n        mouseUV = vec2(.5, .5);\n    }\n    \n    vec2 angle = vec2(-mouseUV.x * PI * 2.0, -mouseUV.y * PI + PI / 2.0);\n    \n    vec3 vec = vec3(0,0,1);\n    vec = RotateVec3X(vec, angle.y);\n    vec = RotateVec3Y(vec, angle.x);\n    \n    return vec;\n}\n\nvec3 RayDirection(vec3 direction, vec2 UV, float fov)\n{\n    vec2 signedUV = UV * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 aspectSignedUV = vec2(signedUV.x, signedUV.y / aspect);\n    vec2 offset = aspectSignedUV * tan(fov / 2.0);\n    \n    vec3 front = (direction);\n    vec3 right = normalize(cross(front, vec3(0,1,0)));\n    vec3 up = cross(right, front);\n    \n    return normalize(front + right * offset.x + up * offset.y);\n}\n\n    //scene\nSphere[] spheres = Sphere[]\n(\n    Sphere(vec3(0,0,-5), 1.0, vec3(1,0,0)),\n    Sphere(vec3(0,1.7,-5), 0.5, vec3(0,0,1)),\n    Sphere(vec3(2,0,-5), 0.5, vec3(1,1,0))\n\n);\n    \nFloor[] floors = Floor[]\n(\n    Floor(-1.2, vec3(0,1,1))\n);\n    \n        //distance functions\nfloat distanceSphere(vec3 position, Sphere sphere)\n{\n    return distance(position, sphere.position) - sphere.radius;\n}\n    \nint ClosestSphere(vec3 position)\n{\n    float dist = RAY_MAX_DISTANCE;\n    int closest;\n    for(int i = 0; i < spheres.length(); i++)\n    {\n        Sphere sphere = spheres[i];\n        float currentDist = distanceSphere(position, sphere);\n        if (dist > currentDist)\n        {\n            dist = currentDist;\n            closest = i;\n        }\n    }\n        \n    return closest;\n}\n\nfloat distanceFloor(vec3 position, Floor floorr)\n{\n    return distance(position.y, floorr.height);\n}\n\nint ClosestFloor(vec3 position)\n{\n    float dist = RAY_MAX_DISTANCE;\n    int closest;\n    for(int i = 0; i < floors.length(); i++)\n    {\n        Floor floorr = floors[i];\n        float currentDist = distanceFloor(position, floorr);\n        if (dist > currentDist)\n        {\n            dist = currentDist;\n            closest = i;\n        }\n    }\n        \n    return closest;\n}\n\n    //raymarch\nstruct MarchResult\n{\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    int type;\n    int id;\n};\n\nMarchResult March(vec3 origin, vec3 direction)\n{\n    vec3 position = origin;\n    Sphere sphere;\n    float currentDistance = RAY_MAX_DISTANCE;\n    int id = -1;\n    int type = -1;\n        \n    for(int iStep = 0; distance(origin, position) < RAY_MAX_DISTANCE && iStep < RAY_MAX_STEPS; iStep++)\n    {\n        id = ClosestSphere(position);\n        \n        type = TYPE_SPHERE;\n        currentDistance = distanceSphere(position, spheres[id]);\n        \n        if(currentDistance < RAY_COLLISION_DISTANCE)\n        {\n            break;\n        }\n        \n        id = ClosestFloor(position);\n        type = TYPE_FLOOR;\n        currentDistance = min(currentDistance, distanceFloor(position, floors[id]));\n        \n        if(currentDistance < RAY_COLLISION_DISTANCE)\n        {\n            break;\n        }\n                \n        position += direction * currentDistance;\n    }\n    \n    bool hit = currentDistance < RAY_COLLISION_DISTANCE;\n    vec3 normal = vec3(0);\n    \n    if (type == TYPE_SPHERE)\n    {\n        normal = normalize(position - spheres[id].position);\n    }\n    \n    if (type == TYPE_FLOOR)\n    {\n        normal = vec3(0,1,0);\n    }\n    \n    return MarchResult(hit, position, normal, type, id);\n}\n\nvec3 Ray2(vec3 origin, vec3 direction)\n{\n    MarchResult result = March(origin, direction);\n    \n    vec3 color = texture(iChannel0, direction).rgb;\n    \n    if (result.hit){\n    \n        if (result.type == TYPE_SPHERE)\n        {\n            color = spheres[result.id].color;            \n        }\n\n        if (result.type == TYPE_FLOOR)\n        {\n            color = floors[result.id].color;\n        }\n        \n        //color = result.normal;\n        \n    }\n    \n    return color; \n}\n\nvec3 Ray(vec3 origin, vec3 direction)\n{\n    MarchResult result = March(origin, direction);\n    \n    vec3 color = texture(iChannel0, direction).rgb;\n    \n    if (result.hit){\n        //color = spheres[result.id].color * dot(result.normal, vec3(0,1,0));\n        color = Ray2(result.position + result.normal * 0.2, reflect(direction, result.normal));            \n        \n        \n        //color = result.normal;\n        \n    }\n    \n    return color;   \n}\n\n    //main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord/iResolution.xy;\n    \n    float factor = 0.5;\n    float dist = 2.0;\n    vec3 position = vec3(sin(iTime * factor) * dist, sin(iTime * 0.2) + 1.0 , cos(iTime * factor) * dist);\n    \n    Camera camera = Camera(position, CameraDirection(), radians(90.0));\n    fragColor.rgb = Ray(camera.position, RayDirection(camera.direction, UV, camera.fov));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 273, 317, 317, 493], [495, 495, 538, 538, 714], [936, 949, 973, 973, 1337], [1339, 1339, 1394, 1394, 1792], [2050, 2071, 2123, 2123, 2189], [2195, 2195, 2229, 2229, 2577], [2579, 2579, 2629, 2629, 2679], [2681, 2681, 2714, 2714, 3058], [3176, 3176, 3224, 3224, 4379], [4381, 4381, 4421, 4421, 4866], [4868, 4868, 4907, 4907, 5321], [5327, 5334, 5391, 5391, 5758]], "test": "untested"}
{"id": "WdyyRt", "name": "A sphere, a capsule, and a plane", "author": "Rowsej", "description": "Um hopefully the title doesn’t give it away\nMade this some time before; was planning to do more but making other stuffs now.\nHope you like my Fresnel", "tags": ["sphere", "raymarcher", "plane", "capsule"], "likes": 1, "viewed": 300, "published": 3, "date": "1608853080", "time_retrieved": "2024-07-30T20:28:21.141657", "image_code": "#define MAX_RAY_DIS 4.1\n#define EPSILON 0.001\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat sdPlane(vec3 p, float y) {\n    return p.y - y;\n}\nfloat sdVerticalCapsule(vec3 p, float h, float r) {\n    vec3 closestP = vec3(0.0, clamp(p.y, 0.0, h), 0.0);\n    return length(p - closestP) - r;\n}\nfloat sdCapsules(vec3 p, float cx, float r) {\n    return 0.0;\n}\nfloat getSde(vec3 p) {\n    //return min(length(p) - 1.0, p.y + 0.4);\n    return min(min(sdSphere(p, 1.0), sdPlane(p, -0.4)), sdVerticalCapsule(p - vec3(-1.2, -0.2, -0.2), 1.0, 0.1));\n}\nfloat marchShadowRay(vec3 ro, vec3 l) {\n    vec3 rd = normalize(l - ro);\n    float ld = length(l - ro);\n    float t = EPSILON * 15.0;\n    while(t < MAX_RAY_DIS * 3.0) {\n        float sde = getSde(ro + rd * t);\n        if(sde < EPSILON) {\n            break;\n        }\n        t += sde;\n        if(t >= ld) {\n            return 1.0;\n        }\n    }\n    return 0.0;\n}\n// Thanks to Baron for this\nvec3 getSkyCol(vec3 rd) {\n    float t = (rd.y + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n// Thanks to IQ for this\nvec3 estimateNormal(vec3 p) {\n    vec2 h = vec2(EPSILON, 0.0);\n    return normalize(vec3(getSde(p + h.xyy) - getSde(p - h.xyy),\n                         getSde(p + h.yxy) - getSde(p - h.yxy),\n                         getSde(p + h.yyx) - getSde(p - h.yyx)));\n}\nvec3 getPixel(vec2 coords) {\n    //vec3 ro = vec3(sin(iTime) * 3.0, 0.0, cos(iTime) * -3.0);\n    //vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 ro = vec3(0.0, 0.0, -3.0 + sin(iTime / 2.0));\n    float ry = iTime;\n    //vec3 rd = normalize(vec3(cos(ry + 90.0) + cos(ry) * coords.x, coords.y, sin(ry + 90.0) + sin(ry) * coords.x));\n    vec3 rd = normalize(vec3(coords, 1.0));\n    float t = 0.0;\n    bool hit = false;\n    while(t < MAX_RAY_DIS) {\n        float sde = getSde(ro + rd * t);\n        if(sde < EPSILON) {\n            hit = true;\n            break;\n        }\n        t += sde;\n    }\n    if(hit) {\n        vec3 col = vec3(0.2, 0.8, 0.6);\n        vec3 p = ro + rd * t;\n        //vec3 lightPos = vec3(0.0, 2.0, -3.0);\n        vec3 lightPos = vec3(sin(iTime) * 3.0, 2.0, cos(iTime) * -3.0);\n        float lightOnPoint = marchShadowRay(p, lightPos);\n        if(lightOnPoint == 0.0) {\n            return col * 0.1;\n        }\n        vec3 norm = estimateNormal(p);\n        vec3 lightDir = normalize(lightPos - p);\n        float ambient = 0.1;\n        float diffuse = clamp(dot(norm, lightDir), 0.0, 1.0);\n        float shininess = 32.0;\n        float specular = clamp(pow(dot(reflect(lightDir, norm), rd), shininess) * (1.0 - dot(norm, lightDir)), 0.0, 1.0);\n        return (col * (ambient + diffuse) + vec3(1.0, 1.0, 1.0) * specular) * lightOnPoint;\n    }\n    return getSkyCol(rd);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mind = min(iResolution.x, iResolution.y);\n    vec2 coords = fragCoord;\n    if(mind == iResolution.y) {\n        coords.x -= (iResolution.x - mind) / 2.0;\n    } else {\n        coords.y -= (iResolution.y - mind) / 2.0;\n    }\n    coords = coords / mind - 0.5;\n    vec3 col = getPixel(coords);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 80, 80, 108], [109, 109, 141, 141, 163], [164, 164, 215, 215, 310], [311, 311, 356, 356, 374], [375, 375, 397, 443, 559], [560, 560, 599, 599, 924], [925, 953, 978, 978, 1088], [1089, 1114, 1143, 1143, 1373], [1374, 1374, 1402, 1504, 2753], [2754, 2754, 2809, 2809, 3142]], "test": "untested"}
{"id": "3lccz8", "name": "idw_RTIOW", "author": "ivandewolf", "description": "Ray Tracing in One Weekend implementation\nbased on Peter Shirley's course on raytracing, modified to function in GLSL for shadertoy\nand a couple of personal changes made\nhttps://raytracing.github.io\n\n", "tags": ["raytracing"], "likes": 0, "viewed": 347, "published": 3, "date": "1608842653", "time_retrieved": "2024-07-30T20:28:21.905615", "image_code": "\n// ---------- STRUCTS ----------------\n\nstruct camera {\n  vec3 origin;\n  vec3 lower_left_corner;\n  vec3 horizontal;\n  vec3 vertical;\n  vec3 u, v, w;\n  float lens_radius;\n};\n\nstruct ray\n{\n  vec3 origin;\n  vec3 dir;\n};\n\n// contains a combination of all possible\nstruct material_texture {\n  int type;\n  vec3 albedoA;\n  vec3 albedoB;\n  float checkerboard_freq;\n  float metal_fuzz;\n  float dialectric_IoR;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    material_texture mat;\n    float t;\n    bool front_face;\n};\n\nstruct sphere {\n  vec3 cen;\n  float rad;\n  material_texture mat;\n};\n\n// ---------- rtweekend.h ---------------\n\n#define PI 3.1415926535897932384626433832795\n\n// Hash functions by Nimitz\n// copied from \n// https://www.shadertoy.com/view/llVcDz\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n// thank you, reinder and iq\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n & (0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_unit_vector()\n{\n  return normalize(random_in_unit_sphere(g_seed));\n}\n\nvec3 random_in_unit_disk() {\n    while (true) {\n        vec3 p = vec3(hash2(g_seed)-vec2(.5), 0.0);\n        if (dot(p,p) >= 1.0) continue;\n        return p;\n    }\n}\n\n//----------- camera.h ------------------\ncamera cameraCreator(vec3 orig, vec3 lookat, vec3 up, float vfov, float aspect_ratio, float aperture, float focus_dist) {\n    camera outCam;\n    outCam.origin = orig;\n    float theta = radians(vfov);\n    float h = tan(theta/2.0);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(orig - lookat);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n\n    outCam.origin = orig;\n    outCam.horizontal = focus_dist * viewport_width * u;\n    outCam.vertical = focus_dist * viewport_height * v;\n    outCam.lower_left_corner = orig - outCam.horizontal/2.0 - outCam.vertical/2.0 - focus_dist * w;\n    outCam.lens_radius = aperture / 2.0;\n    outCam.u = u;\n    outCam.v = v;\n    outCam.w = w;\n    return outCam;\n}\n\nray get_ray(camera cam, float s, float t) {\n    vec3 rd = cam.lens_radius * random_in_unit_disk();\n    vec3 offset = cam.u * rd[0] + cam.v * rd[1];\n\n    return ray(\n        cam.origin + offset,\n        cam.lower_left_corner + s*cam.horizontal + t*cam.vertical - cam.origin - offset);\n}\n\n// ---------------- ray.h -----------------------\n\nvec3 at(ray r, float t) {\n  return r.origin + (t*r.dir);\n}\n\n// ---------------- sphere.h ---------------------\n\nbool hit_sphere(sphere sph, ray r, float t_min, float t_max, out hit_record rec) {\n    vec3 oc = r.origin - sph.cen;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc,oc) - (sph.rad*sph.rad);\n    float discriminant = (half_b*half_b) - (a*c);\n\n    if (discriminant < 0.0) return false;\n    float sqrtd = sqrt(discriminant);\n    \n    float root = (-half_b - sqrtd) / a;\n    if (root < t_min || t_max < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < t_min || t_max < root)\n            return false;\n    }\n\n    rec.t = root;\n    rec.p = at(r, rec.t);\n    rec.normal = (rec.p - sph.cen) / sph.rad;\n    rec.mat = sph.mat;\n    rec.front_face = dot(r.dir, rec.normal) < 0.0;\n    if(!rec.front_face) rec.normal = -rec.normal;\n    return (discriminant >= 0.);\n}\n\n\n//------------- material.h -------------------\n\n// this is kinda from the second book, a checkerboard-ish\nvec3 textureColor(hit_record rec)\n{\n    vec3 color = rec.mat.albedoA;\n    if(rec.mat.type != 2) return color;// type 2 is checkered.... \n    vec3 scaled = rec.p*rec.mat.checkerboard_freq;\n    float val = sin(scaled.x)*sin(scaled.y)*sin(scaled.z);\n    if(val > -0.01) color = rec.mat.albedoB;\n    return color;\n}\n\nbool lambertian_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    vec3 scatter_direction = (rec.normal*1.00001) + random_unit_vector();\n    r = ray(rec.p, scatter_direction);\n    attenuation *= textureColor(rec);\n    return true;\n}\n\nbool metal_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    vec3 reflected = reflect(normalize(r.dir), rec.normal);\n    r = ray(rec.p, reflected + rec.mat.metal_fuzz*random_in_unit_sphere(g_seed));\n    attenuation *= rec.mat.albedoA;\n    return (dot(r.dir, rec.normal) > 0.0);\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance.\n    float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow((1.0 - cosine),5.0);\n}\n\n\nbool dialectric_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    attenuation *= rec.mat.albedoA;//vec3(1.0, 1.0, 1.0);\n    float refraction_ratio = rec.front_face ? (1.0/rec.mat.dialectric_IoR) : rec.mat.dialectric_IoR;\n\n    vec3 unit_direction = normalize(r.dir);\n    float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);\n    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n    bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n    vec3 direction;\n    float rnd = hash1(g_seed);\n    if (cannot_refract || reflectance(cos_theta, refraction_ratio) > rnd)\n        direction = reflect(unit_direction, rec.normal);\n    else\n        direction = refract(unit_direction, rec.normal, refraction_ratio);\n\n    r = ray(rec.p, direction);\n    return true;\n}\n\nbool scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    if(rec.mat.type == 1) \n        return lambertian_scatter(r, rec, attenuation);\n    if(rec.mat.type == 2) \n        return lambertian_scatter(r, rec, attenuation);\n    if(rec.mat.type == 3) \n        return metal_scatter(r, rec, attenuation);\n    if(rec.mat.type == 4) \n        return dialectric_scatter(r, rec, attenuation);\n}\n\n// ------------- httable_list.h and world --------------\n\n#define NPRIMS 20\n\nvoid primList(out sphere sphList[NPRIMS], int seedOffset)\n{\n    int i = -1;\n    for(i = 0; i < NPRIMS-4; ++i){\n        float iseed = float(i+seedOffset);\n        vec2 randLoc = (hash2(iseed)-vec2(.5))*10.0;\n        float switchVal = hash1(iseed);\n         material_texture randomMat;\n        if(switchVal<.3)\n            randomMat = material_texture(1, hash3(iseed), vec3(0), 1.0, 0.0, 1.5);\n        else if(switchVal<.6)\n            randomMat = material_texture(3, hash3(iseed), vec3(0), 1.0, hash1(iseed)*.25, 1.5);\n        else\n            randomMat = material_texture(4, hash3(iseed), vec3(0), 1.0, 0.0, 1.5);\n        sphList[i+0] = sphere(vec3(randLoc.y,-.6,randLoc.x),.4, randomMat);\n        \n    }\n\n    material_texture matr0 = material_texture(3, vec3(1,.06,.06), vec3(1,.4,1), 1.0, 0.0, 1.5);\n    sphList[i+0] = sphere(vec3(-2.1,0,1),1.0, matr0);\n\n    material_texture matr1 = material_texture(4, vec3(.6,1,.6), vec3(1,.4,1), 1.0, 0.0, 1.5);\n    sphList[i+1] = sphere(vec3(0,0,0),1.0, matr1);\n\n    material_texture matr2 = material_texture(2, vec3(.6,.6,1), vec3(10,8,1), 4.0, 0.0, 1.5);\n    sphList[i+2] = sphere(vec3(2.1,0,.5),1.0, matr2);\n\n    material_texture matr3 = material_texture(2, vec3(0.2, 0.3, 0.1), vec3(0.9, 0.9, 0.9), 10.0, 0.0, 0.0);\n    sphList[i+3] = sphere(vec3(0,-100.9,0),100.0, matr3);\n}\n\nbool hittable_list_hit(ray r, float t_min, float t_max, out hit_record rec, sphere sphList[NPRIMS]) {\n    hit_record temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n\n    for (int i = 0; i < sphList.length(); ++i){\n        if(hit_sphere(sphList[i], r, t_min, closest_so_far, temp_rec)){\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n    return hit_anything;\n}\n// ------------------ hello world ------------------\n\nvec3 ray_color(in ray r, sphere sphList[NPRIMS]) {\n  hit_record rec;\n  vec3 albedoAccum = vec3(1.);\n  for(int i = 0; i < 8; ++i){\n      if(!hittable_list_hit(r, 0.00001, 1000.0, rec, sphList)){\n        vec3 unit_direction = normalize(r.dir);\n        float t = 0.5*(unit_direction.y + 1.0);\n        return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0) * albedoAccum;\n      }\n      scatter(r, rec, albedoAccum);\n  }\n  return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // initialize the hash seed\n  g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n  float aspect = iResolution.x/iResolution.y;\n  vec2 off = vec2(-6,3) - abs(iMouse.xy)/iResolution.xy*vec2(-12.0, 4.0);\n  float aperture = .4;\n  float focus_dist = 7.0;\n  camera cam = cameraCreator(vec3(off,-6), vec3(0), vec3(0,1,0), 30.0, aspect, aperture, focus_dist);\n  vec2 uv = fragCoord.xy / iResolution.xy;  \n  sphere sphList[NPRIMS];\n  primList(sphList, int(iTime/1.0));\n  vec3 Caccum = vec3(0);\n  int nSamples = 16;\n  for(int i = 0; i < nSamples; ++i){\n      vec2 sloc = 2.0*(hash2(g_seed) / iResolution.xy)+uv;\n      ray rLoop = get_ray(cam, sloc.x, sloc.y);\n      Caccum += ray_color(rLoop, sphList);\n  }\n\n  fragColor = vec4(Caccum / float(nSamples), 1.0);\n\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lccz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[763, 763, 788, 788, 904], [926, 926, 956, 956, 1122], [1124, 1124, 1154, 1154, 1327], [1329, 1329, 1375, 1375, 1559], [1590, 1590, 1621, 1621, 1744], [1746, 1746, 1773, 1773, 1826], [1828, 1828, 1856, 1856, 1992], [1994, 2036, 2157, 2157, 2821], [2823, 2823, 2866, 2866, 3108], [3161, 3161, 3186, 3186, 3219], [3273, 3273, 3355, 3355, 4081], [4132, 4190, 4225, 4225, 4501], [4503, 4503, 4581, 4581, 4751], [4753, 4753, 4826, 4826, 5049], [5051, 5051, 5099, 5151, 5265], [5268, 5268, 5346, 5346, 6051], [6053, 6053, 6120, 6120, 6449], [6528, 6528, 6587, 6587, 7847], [7849, 7849, 7950, 7950, 8306], [8361, 8361, 8411, 8411, 8800], [8803, 8803, 8860, 8890, 9645]], "test": "untested"}
{"id": "3dfcR8", "name": "parametric_v0007", "author": "darkczar", "description": "parametric curves again, whay can't I save more versions?  is this working?", "tags": ["learning"], "likes": 1, "viewed": 269, "published": 3, "date": "1608840321", "time_retrieved": "2024-07-30T20:28:22.657604", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,0);\n    float d = 10000.0;\n    float di = 0.;\n    for(int i = 0;i<1200;i++)\n    {\n        di = float(i)*.04;\n        curve_p.x = -.1*sin(.4*iTime)+.05*float(di)*sin(float(di)+.2*iTime);\n        curve_p.y = -.1*cos(.4*iTime)+.05*float(di)*cos(float(di)+.2*iTime);\n        d = min(d, length(p-curve_p));\n  \n    }\n\n    vec3 col = vec3(2.*d*d,.002 + .25*sin(.001*d*d+.1*length(p)), abs(.5+.13*sin(iTime*.8) - pow(d,.25)));\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 115, 165, 915]], "test": "untested"}
{"id": "3tdcWr", "name": "Clone Tool", "author": "smkgames", "description": "The Clone Stamp tool is used for pixel-to-pixel cloning. ... Position the cursor over the area where you want to paint the cloned pixels and then start painting.", "tags": ["paint", "multipass", "smudge"], "likes": 4, "viewed": 552, "published": 3, "date": "1608820166", "time_retrieved": "2024-07-30T20:28:23.485391", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 clone = texture(iChannel0,fragCoord / iResolution.xy);\n\n    fragColor = clone;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n\n\nvec2 difference( vec2 a, vec2 b, vec2 p )\n{\n\treturn b - a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord / iResolution.x;\n    vec4 m = iMouse / iResolution.x;\n    \n    vec2 uv = fragCoord / iResolution.x;\n    \n    vec4 baseImage = texture(iChannel1,p);\n\n    \n    if(iTime<= 0.1){\n    fragColor = baseImage;\n\n    }else{\n    \n\t\n    \n    float mask = max(0.,1.-length(p-    m.xy )/0.055); \n\n\n\n    vec2 diff = difference( m.xy, abs(m.zw), p );\n    uv += diff;\n\n    vec4 Image= texture(iChannel1,uv);\n\n    \n    vec4 result = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    fragColor = mix(result,Image,vec4(mask ));\n}\n    //fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdcWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 147]], "test": "untested"}
{"id": "3ldcWr", "name": "meta-tetra-toroidal symmetry v0", "author": "cyperus", "description": "use mouse :)", "tags": ["sdf", "sphere", "tiling"], "likes": 22, "viewed": 719, "published": 3, "date": "1608814590", "time_retrieved": "2024-07-30T20:28:24.443829", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"meta-tetra-torodial symmetry v0\"\n//\n// created by Colling Patrik (cyperus) in 2020\n//\n//\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float cam_dist = 5.5; // camera distance\nconst float bb_size = 2.5; // bounding sphere size\nconst float rm_rlmin = 0.0; // ray march ray_length minimum\nconst float rm_rlmax = 50.0; // ray march ray-length maximum\nconst int   rm_imax = 200; // ray march maximal number of iterations\n\nconst float rm_p3slmul = 0.32772; // ray march pow(step length multiplier,3)\n// anti-aliasing\nconst float AA = 2.0;\n\n////////////////////////////////////////////////////////////////////////////////\n\n// const\nconst float PI = 3.14159265359;\n\n// 2D transformations: vec2 => vec2\n// complex\nvec2 cmul(vec2 za,vec2 zb) // za*zb\n{\n    return za*mat2(zb.x,-zb.y,zb.yx);\n}\n\nvec2 cinv(vec2 z) // 1/z\n{\n    return z*vec2(1.,-1.)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) // z/w\n{\n    return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, float q) // z^q\n{\n    float r = pow(length(z), q);\n\tfloat a=q* atan(z.y,z.x);\n    return vec2(r*cos(a),r*sin(a));\n}\n\nvec2 cpow(vec2 z, int n) // z^n\n{\n    vec2 w = z;\n    for (int i = 1; i < n; i++){\n    w = cmul(w,z);\n    }\n    return w;\n}\n\nvec2 crot(vec2 z,float a) // z*e^(i*a)\n{\n    return cmul(z, vec2(cos(-a),sin(-a)));\n}\n\nvec2 crpt(vec2 z,float a, int n, float x0) // z_out = (z*e^ia)^n-x0\n{\n\treturn cpow(crot(z, a), n) - vec2(x0, 0.);\n}\n\n// 3D-transformations: vec3 => vec3\n//color\nvec3 hsv2rgb(float h, float s, float v)  // hue, saturation, value\n{\n    vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n    return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 isphere(in vec3 ro, in vec3 rd, in float r )\n{\n    // sphere centered at the origin, with size rd   \n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat map( in vec3 p, out vec4 mat )\n{\n    //// sdf's\n    float time = 0.1 * iTime;\n\tvec3 pn = normalize(p);\n    vec2 z, zk; \n    // F3,3(z) tetrahedral symmetry\n    int k = 3, n = 3;\n    const float a1 = 2.*sqrt(2.);\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.0-pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1) * zk;\n        z = cmul(z, cpow(zk-vec2(a1,0.),k));\n        z = cdiv(z, cpow(zk+ vec2(1./a1,0.0),n));\n    }else        // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        z = 1./(8.*a1)*cinv(zk);       \n        z = cmul(z, cpow(vec2(1.,0.) - zk * a1 ,k));\n        z = cdiv(z, cpow(vec2(1.,0.) + zk / a1 ,n));    \n    }\n    \n    // polygon properties\n    float sr = float(length(z)>1.0?-n:k);\n\tfloat au = atan(z.y,z.x)-0.5*PI*sign(sr);\n\tfloat av = atan(log(length(z))*0.1);\n\n\t// spherical => cartesian coords\n\tp = length(p)*vec3(\tsin(av)*cos(au),\n                        sin(av)*sin(au),\n                        cos(av));\n\n    // torus \n    au = atan(p.y, p.x);\n    z = vec2( length(p.xy), p.z);\n    z = cmul(z,z); z.x += 4.0;\n\n    float ssr = sign(sr);\n\t// fractal level 1\n    z = crpt(z, -ssr*au/3.0, 3,  2.0+3.0*cos(au));\n\n\t// fractal level 2\n    z = crpt(z, PI*ssr*time, 2, 1. + 0.5 * cos(time) );\n    \n    // actual ray data\n\tmat = vec4(z,au,sr);\n    \n    // step length estimation\n\treturn log(length(z)); // :( Not perfect!\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0; // init no rayintersection\n    \n    // boundingshape\n    vec2 dis = isphere( ro, rd ,abs(bb_size));\n    if( dis.y<0.0 ) // does ray hit boundingshape?\n        return -1.0;\n    dis.x = max( dis.x, max(rm_rlmin,0.0) );// start_raylength from bb_near_hit or raylength_minimum\n    dis.y = min( dis.y, rm_rlmax );\t// end_raylength from bb_far_hit or raylength_maximum\n    \n    // raymarch signed distance field\n\tvec4 data; // data from surface hit point and accumulated data while raymarching\n\tfloat fh = (0.5-0.0001)*rm_p3slmul*rm_p3slmul*rm_p3slmul + 0.0001; // fh slider response curve\n\tfloat t = dis.x; // ray iteration starts at boundingshape\n\tfor( int i=0; i<rm_imax; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.005*px*t;// sdf surface hit tolerance\n\t\tfloat h = map(pos, data);\n\t\tif( t>dis.y || abs(h)<th ) break; // ray is outside boundingshape or sdf_surface_hit.\n        t += h*fh; // update ray length  with step_length * step_length_multiplier\n    }\n    \n    if( t<dis.y ) // Is ray inside boundingshape?\n    {\n        rescol = data; // return data\n        res = t; // return ray_length\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float px )\n{\n    vec4 tmp; // dummy variable\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\n// from iq\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n    \tvec4 temp;\n    \tfloat h = map( ro + rd*t, temp );\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<1; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n    \tvec4 temp;\n    \tfloat dd = map( aopos, temp );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n// transform from mla\nvec3 transform(in vec4 p)\n{\n\tif (iMouse.x > 0.0)\n\t{\n\t\tfloat phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n\t\tfloat theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n\t\tp.yz = crot(p.yz,theta);\n\t\tp.zx = crot(p.zx,-phi);\n\t}\n\tp.xz = crot(p.xz,p.w*0.01);\n\treturn p.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // time\n    float time = iTime;\n    \n    // camera\n    float fle = 2.0;\n\tvec3 ro = transform(vec4(0,0,-cam_dist,time)).xyz;\n\n\t// anti-aliasing\n\tvec3 aacol = vec3(0);\n\tfor (float i = 0.0; i < max(-time,AA); i++) {\n\t\tfor (float j = 0.0; j < max(-time,AA); j++) {\n        \n\t\t\t// ray direction\n\t\t\tvec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n\t\t\tvec3 rd = normalize(transform(vec4(uv,fle,time)));\n            \n\t\t\t// ray distance\n\t\t\tvec4 mat = vec4(0.0);\n\t\t\tfloat px = 2.0/( iResolution.y*fle );\n\t\t\tfloat t = intersect( ro, rd, mat, px );\n\n\t\t\t// light\n\t\t\tconst vec3 ld = 0.5*vec3(0.,1.,.5); // ligth direction\n\t\t\tconst vec3 lc = vec3(0.4);// ligth color\n\t\t\tvec3 bg = vec3(0.8,0.9,2.0)*0.3*(0.9+0.1*rd.y);\t// background-color\n\n\t\t\t// color\n\t\t\tvec3 col = vec3(0.6,0.4,0.7);\n\n\t\t\tif (t < 0.0){ // sky\n\t\t\t\tcol = bg;\n\t\t\t\tcol += 6.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,lc),0.0,1.0), 32.0 ); // sun\n\t\t\t}\n\t\t\telse{ // object surface\n\t\t\t\tvec3 p = ro + rd * t;\n\t\t\t\tvec3 n = calcNormal( p, px );\n\n\t\t\t\t// texture_coords\n\t\t\t\tfloat u = mat.z*0.5/PI;\n\t\t\t\tfloat v = sign(mat.w)*atan(mat.y,mat.x)*0.5/PI;\n\n\t\t\t\t// texture_color\n\t\t\t\tfloat l = 0.5+0.5*cos(0.3*iTime);\n\t\t\t\tfloat col_h = 1.0;\n\t\t\t\tcol_h *= v;\n\t\t\t\t//col_h *= u;\n\t\t\t\tfloat col_s = 1.0;\n\t\t\t\tfloat col_v = 1.0;\n\t\t\t\tcol = hsv2rgb(col_h,col_s,col_v); //(hue, saturation, value)\n\n\t\t\t\t// lighting\n\t\t\t\tfloat occ = calcAO( p, n );\n\t\t\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\t\t\t\tvec4 temp; // dummy variable\n\t\t\t\tfloat dif = clamp( dot( n, ld ), 0.0, 1.0 ) * map( p+n*1.16, temp);\n\t\t\t\tfloat spe = pow(clamp( dot( rd, ld ), 0.0, 1.0 ),16.0);\n\t\t\t\tfloat sss = map( p - n*0.001, temp)/0.01;\n\n\t\t\t\t// shading\n\t\t\t\tdif *= softshadow( p, ld, 0.1, 1. );\n\t\t\t\tvec3 brdf = vec3(0.0);\n\t\t\t\tbrdf += 0.2*dif*vec3(1.00,0.90,0.60);\n\t\t\t\tbrdf += 0.2*spe*vec3(0.8,0.60,0.20)*dif;\n\t\t\t\tbrdf += 0.2*amb*vec3(0.40,0.60,0.40)*occ;\n\t\t\t\tbrdf += 0.4;\n\t\t\t\tcol.rgb *= brdf;\n                \n\t\t\t\t// fog\n\t\t\t\tcol = mix( bg,col, exp( -0.025*t*t));\n\t\t\t}\n\t\t\taacol += col;\n\t\t}\n\t}\n\taacol /= float(AA*AA);\n    // gamma\n    aacol = sqrt(aacol);\n    fragColor = vec4(aacol,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldcWr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[885, 932, 969, 969, 1009], [1011, 1011, 1037, 1037, 1075], [1077, 1077, 1111, 1111, 1141], [1143, 1143, 1178, 1178, 1276], [1278, 1278, 1311, 1311, 1401], [1403, 1403, 1443, 1443, 1488], [1490, 1490, 1559, 1559, 1605], [1607, 1651, 1719, 1719, 1901], [1903, 1903, 1954, 2008, 2174], [2258, 2258, 2296, 2311, 3692], [3694, 3694, 3767, 3767, 4927], [4929, 4929, 4974, 4974, 5223], [5225, 5236, 5310, 5310, 5573], [5575, 5586, 5628, 5628, 5940], [5942, 5964, 5991, 5991, 6241], [6243, 6243, 6300, 6312, 8395]], "test": "untested"}
{"id": "3ltcWr", "name": "Enter the Rome", "author": "lyurai", "description": "This is water", "tags": ["abs"], "likes": 1, "viewed": 268, "published": 3, "date": "1608809215", "time_retrieved": "2024-07-30T20:28:25.361375", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*1.+iResolution.xy)/t;\n        t = iTime+float(c);\n        for(int i=0;i<122;i++)\n        {\n        \tuv=abs(uv);\n        \tuv-=1.;\n        \tuv=uv*rot(t/float(i+1));\n        }\n        \n     col[c] = fract(uv.x/t);\n        \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ltcWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 477]], "test": "untested"}
{"id": "WldyDn", "name": "gaming grid", "author": "bigdra50", "description": "#つぶやきGLSL\nhttps://twitter.com/bigdra50/status/1254861628077568001?s=20", "tags": ["2d"], "likes": 3, "viewed": 399, "published": 3, "date": "1608797653", "time_retrieved": "2024-07-30T20:28:26.112367", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime;\n    vec3 r = iResolution;\n    vec2 s = 5.*(gl_FragCoord.xy-.5*r.xy)/r.y,f=fract(s),p=floor(s);\n    fragColor = vec4(step(0.,max(-length((p=.5+.5*sin(t+sin(p.xx*vec2(7,9)+p.yy*3.)*54.))-f)+.03,max(f.x,f.y)-.99))*sin(t+p*9.).xyx*cos(t+p.xxy),0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 321]], "test": "untested"}
{"id": "wt3cDr", "name": "A17DC631_Shader01", "author": "Graysky", "description": "  A17DC631_Shader01", "tags": ["a17dc631shader01"], "likes": 1, "viewed": 258, "published": 3, "date": "1608787170", "time_retrieved": "2024-07-30T20:28:26.866351", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    if (int(fragCoord.x) % 10 == 0) col = vec3(0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}                          ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 351]], "test": "untested"}
{"id": "tlcyWr", "name": "Bioluminescent jungle", "author": "jarble", "description": "I was trying to do some antialiasing when I discovered this strange glowing effect.\nThis is an edit of my [url=https://www.shadertoy.com/view/ttlfzf]\"Windy Jungle\"[/url] shader.", "tags": ["jungle"], "likes": 2, "viewed": 363, "published": 3, "date": "1608785439", "time_retrieved": "2024-07-30T20:28:27.747994", "image_code": "float sceneSDF(vec3 a){\n    return sceneSDF(a,iTime);\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvec3 color(vec3 p,vec3 eye){\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    return phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n}\n\nvec3 march_edges(vec2 coord,vec3 eye){\n    vec3 map1 = depth_map(coord);\n    vec3 result;\n    for(float i = -1.0; i < 2.0; i+=1.0){\n        for(float j = -1.0; j < 2.0; j+=1.0){\n            result = max(result,depth_map(coord+vec2(i,j)));\n        }\n    }\n    //result /= 9.0;\n    return color(result,eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    vec3 color = march_edges(fragCoord,eye);\n\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 4.0\n\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    p += p.yzx;\n    p = cos(p/size1+sin(p/size1));\n    p = (sin(p/vec3(length((p/20.0)))))*size1;\n    return size-length(p)/1.83;\n}\n\nfloat sceneSDF(vec3 p,float t) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n    //try changing it to 1200.0\n\n    float result = vines(p,size1);\n    float i = 9.0;\n    for(int k = 0; k < 2; k++){\n    \tp = sin(p/i)*i-sin(p.yzx*i/(9.0)+t*9.0)/i;\n        //float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines((p-result*i/81.0)*i,size1)/(i*i));\n    \ti *= 9.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*600.0;\n}", "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "buffer_a_code": "\nfloat sceneSDF(vec3 a){\n    return sceneSDF(a,iTime);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n\tfragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0); //wobble\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0); //wobble\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p,1.0);\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 55], [57, 146, 175, 175, 485], [487, 979, 1119, 1119, 1729], [1731, 2101, 2186, 2186, 2533], [2535, 2535, 2563, 2563, 2711], [2713, 2713, 2740, 2740, 2889], [2891, 2891, 2919, 2919, 3109], [3111, 3111, 3149, 3149, 3418], [3420, 3420, 3477, 3477, 3607]], "test": "untested"}
{"id": "wtcyWr", "name": "N-B (trom Vall-D), fork", "author": "404Glaciergargamel", "description": "Remix, fork, and parody of [url]https://www.shadertoy.com/view/WdVfRc[/url]", "tags": ["3d", "raymarching", "remix", "glitch", "fork", "weird", "pixar", "movie", "parody", "cineshader", "walle"], "likes": 1, "viewed": 10417, "published": 3, "date": "1608784654", "time_retrieved": "2024-07-30T20:28:28.604703", "image_code": "// Cracked by 404Glaciergargamel!\n\nfloat arms, time, g = 0.0;\n\n#define AA 1 // Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; // SDF distance.\n\tint id; // Material ID.\n\tvec2 t; // uv texture coords.\n};\n\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(8, 257, 1);\n\tvec2 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (4. - 3. * p);\n\n\tvec2 h = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 53.5453), fract(sin(h + s.x) * 53.5453), p.x);\n\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.1)) + min(max(q.x, max(q.y, q.z)), 0.1);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.1) + length(max(d, 0.1));\n}\n\nfloat sdTaper(vec2 p, vec3 r) {\n\tp.x = abs(p.x);\n\tp.y = -p.y;\n\tfloat b = (r.x - r.y) / r.z, a = sqrt(2. - b * b), k = dot(p, vec2(-b, a));\n\tif (k > a * r.z) return length(p - vec2(1, r.z)) - r.y;\n\treturn (k < 1. ? length(p) : dot(p, vec2(a, b))) - r.x;\n}\n\nfloat sdArm(vec3 p, float c) {\n\treturn max(\n\t\tmax(sdTaper(p.yz, vec3(.6, .3, 3)), abs(abs(p.x) - 2.55)) - .2, // Main arm.\n\t\t(p.z + 2.5 + sin(p.y * 8.) * .2) * c); // Front/back cut.\n}\n\n// The sine wave applied to the dirt track.\nfloat trk(float z) { return sin(z * .3 - time); }\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\t// Floor.\n\tHit h = Hit(length(p.y), 1, p.xz);\n\n\t// Walls.\n\tminH(h, Hit(min(dot(p, vec3(-.707, .807, 1)) + 10., dot(p, vec3(-2, 1, 1)) + 30.), 1, p.yz));\n\n\t// Wall lights.\n\tfloat d = sdBox(vec3(p.xy, mod(p.z - time * 9., 50.)) - vec3(30, 8.25, 30), vec3(.2, .2, 9));\n\tg += .02 / (.02 + d * d);\n\tminH(h, Hit(d - .8, 5, p.xy));\n\n\tp.x += trk(-1.0);\n\tp.xz *= rot(trk(8.) * .3);\n\n\t// Ball.\n\tminH(h, Hit(length(p - vec3(1, 2, 1)) - 2., 3, p.xy));\n\tp.yz *= rot(-arms);\n\tp.y -= 2.7;\n\tminH(h, Hit(sdBox(p, vec3(2.2, 1.0, .9 + cos((p.y + 6.1) * 2.33) * .6)) - .4, 4, p.xy)); // Lower body.\n\tvec3 op = p;\n\n\t// Arms/Hands.\n\tp.y -= .6;\n\tp.yz *= rot(-arms);\n\td = sdArm(p, -2.);\n\tp.z += arms + cos(time * 25.) * .2;\n\tminH(h, Hit(min(d, sdArm(p, 2.)), 1, op.xy));\n\n\t// Brush.\n\tfloat f, b = .3 + .9 * abs(sin(p.x * 28.)) * .2;\n\tminH(h, Hit(sdCyl(p + vec3(1, 1, 3), vec2(.2 + b, 2.4)), 3, p.xy));\n\n\t// Arm extenders.\n\tp.x = abs(p.x) - 2.55;\n\tp.z += 2.;\n\tminH(h, Hit(sdBox(p, vec3(.09, .32, .7)), 3, p.xz));\n\n\t// Head.\n\tp = op;\n\tp.yz *= rot(arms * -.8);\n\tp.xz *= rot(trk(1.) * .2);\n\tp.y -= 3.;\n\tp.z += .6;\n\tf = cos(p.y + .9);\n\n\tminH(h, Hit(max(sdBox(p, vec3(mix(2.2, 2.4, f), .9, mix(1.0, 2.2, f))), // Head.\n\t\t\t3.5 - length(p.yz + vec2(3.5, -.9)) // Rear cut-out.\n\t\t\t) - .3, 7, p.xy));\n\n\t// Light - Top.\n\tp.y -= mix(1.06, 3.5, arms);\n\tminH(h, Hit(sdBox(p, vec3(.6, .05, .6)), 4, p.xy));\n\tminH(h, Hit(sdBox(p + vec3(1, .4, 1), vec3(.55, .4, .55)), 6, p.xy));\n\n\treturn h;\n}\n\nvec3 calcN(vec3 p) {\n\tvec2 e = vec2(.034, -.034);\n\treturn normalize(e.xyy * map(p + e.xyy).d +\n\t\t\t\t\t e.yyx * map(p + e.yyx).d +\n\t\t\t\t\t e.yxy * map(p + e.yxy).d +\n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat s = 2., t = .2, h;\n\tfor (int i = 1; i < 30; i++)\n\t{\n\t\th = map(p + ld * t).d;\n\t\ts = min(s, 25. * h / t);\n\t\tt += h;\n\t\tif (s < .002 || t > 3.7) break;\n\t}\n\n\treturn clamp(s, 1., 2.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .6 + .6 * pow(26. * q.x * q.y * (2. - q.x) * (2. - q.y), .5);\n\treturn c;\n}\n\n// Calculate the floor normal vector.\nvec2 flrN(vec2 t) {\n\treturn n21(vec2(t.x * 2.2, t.y)) * .4 + // Surface texture.\n\t\tsmoothstep(.1, .05, abs(sin(t * .6))); // Tile edges.\n}\n\nvec3 mat(Hit h, vec3 p, inout vec3 n) {\n\tif (h.id == 2) { // Floor\n\t\tvec2 t = h.t + vec2(trk(p.z), time * -6.);\n\n\t\tn.xz += flrN(vec2(h.t.x, t.y));\n\t\tn = normalize(n);\n\n\t\tfloat mm = n21(mod(t * 20., 30.));\n\t\tvec2 d = abs(vec2(abs(abs(t.x) - .9) - .4, mod(t.y, .5) - .2)) - vec2(.3, .2);\n\t\treturn vec3(.4, .5, .6)\n\t\t* mix(2., mm, (2. - step(1., min(max(d.x, d.y), 1.))) * step(p.z, -3.5)); // Tracks.\n\t}\n\n\tif (h.id == 2) return vec3(.2); // Ball, brush\n\n\tif (h.id == 3) // White body\n\t\treturn vec3(2. - step(abs(h.t.y + .8), .25) * 1.0);\n\n\tif (h.id == 4) // Wall light.\n\t\treturn vec3(35);\n\n\tif (h.id == 5) return vec3(2, 1, 1);\n\n\tif (h.id == 6) { // Face\n\t\tvec2 t = vec2(abs(h.t.x), h.t.y);\n\t\tif (t.y < -.4 && t.x < 2.) {\n\t\t\tt.x += arms * .5;\n\t\t\tfloat l = .4 + .8 * abs(sin(t.y * 60.));\n\t\t\tt *= rot(.7 * arms);\n\t\t\treturn .02 + vec3(2.5, 2.5, 1) * step(abs(t.x - .4), .35) * step(abs(t.y + .8), .2 - arms * .2) * l;\n\t\t}\n\t}\n\n\treturn vec3(-0.02);\n}\n\nvec3 lights(vec3 p, vec3 rd, Hit h) {\n\tconst vec3 lp = vec3(7, 4, -20);\n\tvec3 n = calcN(p), ld = normalize(lp - p);\n\treturn mat(h, p, n) // Material color.\n\t\t   * (\n\t\t\t  (\n\t\t\t\t  max(1., .2 + 1.0 * dot(ld, n)) // Primary light.\n\t\t\t\t  + max(1., .2 + 1.0 * dot(ld * vec3(-2, 1, -2), n)) // Bounce light.\n\t\t\t  )\n\t\t\t  * mix(.4, .7, calcShadow(p, ld)) // Shadows.\n\t\t\t  * mix(ao(p, n, .4), ao(p, n, 3.), .8) // Ambient occlusion.\n\t\t\t  + pow(max(1., dot(rd, reflect(ld, n))), 40.) // Specular.\n\t\t\t ) * vec3(3, 2.8, 2.7); // Main light color.\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, n, c;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (int i = 1; i < 210; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .0025)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t}\n\n\t// Calculate pixel color.\n\tc = lights(p, rd, h) + g;\n\tif (h.id == 2) {\n\t\t// Ray hit the floor - Apply reflection.\n\t\tn = calcN(p);\n\t\tn.xz -= flrN(p.xz - vec2(1, time * 6.)) * .034;\n\t\trd = reflect(rd, normalize(n));\n\t\td = .6;\n\t\tro = p;\n\t\tfor (int i = 1; i < 100; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = map(p);\n\n\t\t\tif (abs(h.d) < .0025)\n\t\t\t\tbreak;\n\t\t\td += h.d;\n\t\t}\n\n\t\tif (abs(h.d) < .0025)\n\t\t\tc = mix(c, mat(h, p, n), .02);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 c, vec2 fc)\n{\n\ttime = mod(iTime, 40.) - 2.;\n\tarms = (time < 1. ? smoothstep(-2., 1., time) : abs(sin(time * 20.) * .2) + 1.0) * .48;\n\ttime = max(1., time);\n\n\tvec3 ro = vec3(-8, 5, -8. - sin(time * .4)),\n\t\t col = vec3(1);\n#ifdef AA\n\tfor (float dx = 1.; dx <= 2.; dx++)\n\t\tfor (float dy = 1.; dy <= 2.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .6 - .6 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .6 * iResolution.xy) / iResolution.y;\n#endif\n\n\t\t\tvec3 f = normalize(vec3(1, 4, -5) - ro),\n\t\t\t\t r = normalize(cross(vec3(1, 2, 1), f));\n\t\t\tcol += march(ro, normalize(f + r * uv.x + cross(f, r) * uv.y));\n#ifdef AA\n\t\t}\n\tcol /= 5.;\n#endif\n\n\tc.rgb = vig(pow(col, vec3(.55)), fc);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 241, 241, 473], [475, 475, 506, 506, 531], [533, 533, 552, 552, 612], [614, 614, 643, 643, 732], [734, 734, 764, 764, 866], [868, 868, 899, 899, 1122], [1124, 1124, 1154, 1154, 1308], [1310, 1354, 1374, 1374, 1403], [1405, 1443, 1460, 1471, 2914], [2916, 2916, 2936, 2936, 3111], [3113, 3113, 3148, 3148, 3335], [3337, 3365, 3400, 3400, 3432], [3520, 3520, 3547, 3547, 3662], [3664, 3702, 3721, 3721, 3840], [3842, 3842, 3881, 3881, 4785], [4787, 4787, 4824, 4824, 5322], [5324, 5324, 5354, 5368, 5960]], "test": "untested"}
{"id": "wldyzM", "name": "Day 371", "author": "jeyko", "description": "potpo", "tags": ["mdtmjvm"], "likes": 7, "viewed": 396, "published": 3, "date": "1608762856", "time_retrieved": "2024-07-30T20:28:29.551173", "image_code": "// elastic collisions with voronoi particle tracking\n// thx to wyatt for helping with learning this!\n\nint neighborsCnt = 0;\nvec4 neighborPtrs[] = vec4[8](vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0));\n\nfloat steps = 6.;\nfloat stepSz = 1.;\nvoid findNeighbors( vec4 p, vec2 dir){\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = TF1( p.xy * R + dir * i*stepSz );\n        vec4 otherP    = T( otherPntr.xy );\n        \n        if ( otherP.x != p.x && otherP.y != p.y){\n            for(int i = 0; i < neighborsCnt; i++){\n                if (neighborPtrs[i] == otherPntr)\n                    return;\n            }\n            neighborPtrs[neighborsCnt++] = otherPntr;\n            return;\n        }\n    }\n\n}\n\nfloat sdSq(vec2 p, float s){p = abs(p) - s; return max(p.x,p.y);}\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    if( iMouse.z > 0.){\n        float sqSz = 0.4*R.y;\n        \n        vec2 muv = U - iMouse.xy*1.;\n        float sq = sdSq(muv,sqSz);\n        if(sq <= 0.){\n            U -= iMouse.xy;\n            U *= 0.25;\n            U += iMouse.xy;\n            \n            //U -= iMouse.xy*1.;\n            //U *= 0.25;\n            \n        }\n        \n    }\n    \n    vec2 uv = U/R;\n    // for(float i = 0.; i < particlesCnt; i++){\n    vec4 pPntr = T1(U);\n    vec4 p = T(pPntr.xy);\n    // C = T(U);\n    \n    findNeighbors( p, vec2(1,0));\n    findNeighbors( p, vec2(-1,0));\n    findNeighbors( p, vec2(0,1));\n    findNeighbors( p, vec2(0,-1));\n            \n    findNeighbors( p, vec2(1,1));\n    findNeighbors( p, vec2(1,-1));\n    findNeighbors( p, vec2(-1,1));\n    findNeighbors( p, vec2(-1,-1));\n\n    for(int i = -1; i < neighborsCnt; i++){\n        vec4 otherPtr;\n        vec4 otherP;\n        if (i == -1){\n            otherPtr = pPntr;\n            otherP = p;\n        }  else {\n            otherPtr = neighborPtrs[i];\n            otherP = T(otherPtr.xy);\n        }\n        \n        C = mix(C,pal(0.5,0.5,vec4(3,2,1,1.),1.,otherPtr.z*1.*14. + 0.*otherPtr.w ),smoothstep(dFdx(uv.x),0.,length((otherP.xy - uv)*resFact.xy) - particleSz));\n    }\n    \n        \n    C = pow(C,vec4(0.4545));    \n\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec4 getData(vec2 u){\n    return T( T1(u).xy );\n}\n\nint neighborsCnt = 0;\nvec4 neighborPtrs[] = vec4[8](vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0));\n\n#define steps  floor(particleSz*iResolution.x*8.)\nfloat stepSz = 1.;\nvoid findNeighbors( vec4 p, vec2 dir){\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = TF1( p.xy * R + dir * i*stepSz );\n        vec4 otherP    = T( otherPntr.xy );\n        \n        if ( otherP.x != p.x && otherP.y != p.y){\n            for(int i = 0; i < neighborsCnt; i++){\n                if (neighborPtrs[i] == otherPntr)\n                    return;\n            }\n            neighborPtrs[neighborsCnt++] = otherPntr;\n            return;\n        }\n    }\n\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    if (iFrame < 3){\n        C = r24(U + 0.0 );\n        //C = T2(U*0.14);\n        C.zw *= 2.;\n        C.zw -= 1.;\n        C.zw *= particleSpeed;\n    } else {\n        C = T(U);\n        \n        vec4 pPtr = T1(C.xy*R);\n        \n        if (iFrame > startOffs){\n            \n            //C = T( pPtr.xy );\n            \n            vec4 Cold = C;\n            float velScale = 1.;\n\n            findNeighbors( C, vec2(1,0));\n            findNeighbors( C, vec2(-1,0));\n            findNeighbors( C, vec2(0,1));\n            findNeighbors( C, vec2(0,-1));\n            \n            findNeighbors( C, vec2(1,1));\n            findNeighbors( C, vec2(1,-1));\n            findNeighbors( C, vec2(-1,1));\n            findNeighbors( C, vec2(-1,-1));\n            \n\n            \n            for(int i = 0; i < neighborsCnt; i++){\n                //vec2 idx = getIdx(i);\n                //if(idx.x > U.x+0. && idx.x < U.x -0.  ){\n                \n                \n                vec4 otherPtr = neighborPtrs[i];\n                //vec4 other = TF1(otherP.xy*R);\n                vec4 other = T(otherPtr.xy);\n\n                vec2 meToOther = (other.xy - C.xy)*resFact.xy;\n                \n                \n                float distBetween = length(meToOther);\n\n                if( distBetween < particleSz * 2.0 ){\n                    \n                    vec2 vel = C.zw;\n                    vec2 otherVel = other.zw;\n\n                    vec2 normal = normalize(meToOther);\n                    vec2 tangent = vec2(-normal.y,normal.x);\n\n\n                    float meNorm = dot(vel, normal);\n                    float meTan = dot(vel, tangent);\n                    float otherNorm = dot(otherVel, normal);\n                    float otherTan = dot(otherVel, tangent);\n\n                    float massMe = 1.;\n                    float massOther = 1.;\n                    \n                    massMe = pPtr.z*1.;\n                    massOther = otherPtr.z*1.;\n                    \n                    meNorm = ( meNorm * (massMe - massOther) + 2.*massOther*otherNorm ) / (massMe + massOther);\n\n\n                    \n                    if ( false && pPtr.z == otherPtr.z && pPtr.z == 1.){\n                       C.zw = mix(C.zw, otherVel,0.01);\n                      \n                    } else {\n                        C.zw = tangent * meTan + normal*meNorm;\n                    \n                    }\n                    C.xy -= normalize(meToOther)*(abs(distBetween - particleSz*2.));\n                    \n                    //otherNorm = (otherNorm(massOther - massMe) + 2.*massOther*otherNorm ) / (massMe + massOther);\n\n\n                }\n\n\n            }\n\n            if (abs(C.x - 0.5) > 0.49 - particleSz*0.5){\n                C.z *= -1.;\n                if ( sign(C.z) != sign(-C.x + 0.5) )\n                    C.z *= -1.;\n            }\n            if (abs(C.y - 0.5) > 0.49 - particleSz*0.5){\n                C.w *= -1.;\n                if ( sign(C.w) != sign(-C.y + 0.5) )\n                    C.w *= -1.;            \n            }\n\n            \n            //C.zw = mix(C.zw, ( valueNoise(vec3(C.xy*7.,1. + iTime*0.7),1.).xy*2. - 1. )*particleSpeed, 0.002);\n\n            \n            C.xy += C.zw*1.*resFact.yx;\n            \n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R (iResolution.xy)\n#define T(u) texture(iChannel0,(u)/R)\n#define T1(u) texture(iChannel1,(u)/R)\n#define T2(u) texture(iChannel2,(u)/R)\n#define T3(u) texture(iChannel3,(u)/R)\n#define TF(u)  texelFetch(iChannel0,ivec2(u), 0)\n#define TF1(u) texelFetch(iChannel1,ivec2(u), 0)\n#define TF2(u) texelFetch(iChannel2,ivec2(u), 0)\n#define TF3(u) texelFetch(iChannel3,ivec2(u), 0)\n\n#define pi acos(-1.)\n\n#define startOffs 30\n\n\n#define particleSz 0.0015\n#define particleSpeed 0.0001\n#define resFact vec2(R.x/R.y,1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define getIdx(a) vec2(mod(a,R.x), floor((a+R.x)/R.x)-1.)\n\n\nvec4 r24(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 valueNoise(vec3 uv,float pw){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    fd = pow(fd,vec3(pw));\n    \n    vec2 ibl = hash23(id + vec3(0,-1,0));\n    vec2 ibr = hash23(id + vec3(1,-1,0));\n    vec2 itl = hash23(id + vec3(0));\n    vec2 itr = hash23(id + vec3(1,0,0));\n    \n    \n    vec2 jbl = hash23(id + vec3(0,-1,1));\n    vec2 jbr = hash23(id + vec3(1,-1,1));\n    vec2 jtl = hash23(id + vec3(0,0, 1));\n    vec2 jtr = hash23(id + vec3(1,0, 1));\n    \n    \n    vec2 ibot = mix(ibl, ibr, fd.x); \n    vec2 iup = mix(itl, itr, fd.x);\n    vec2 jbot = mix(jbl, jbr, fd.x);\n    vec2 jup = mix(jtl, jtr, fd.x);\n    \n    vec2 i = mix(ibot, iup, fd.y);\n    vec2 j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n", "buffer_b_code": "\nfloat steps = 26.;\nfloat stepSz = 1.;\nvoid findMe( inout vec4 pPntr, inout vec4 p, vec2 U, vec2 dir){\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = T1(U + dir*i);\n        vec4 otherP = T(otherPntr.xy);\n        \n        if (length( (U/R - otherP.xy)/resFact.yx ) < length( (U/R - p.xy)/resFact.yx )){\n            p = otherP;\n            pPntr = otherPntr;\n        }\n        \n    }\n\n}\n        \n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    if (iFrame < 3) {\n        //C = r24(U);\n        C.xy = U;\n        C.zw -= C.zw;\n    } else {        \n        C = T1(U);\n        \n        if (iFrame < startOffs){\n            steps = 100.;\n        }\n        \n        \n        vec4 pPntr = C;\n        vec4 p = T(pPntr.xy);\n        findMe(pPntr,p,U,vec2(0,1));\n        findMe(pPntr,p,U,vec2(0,-1));\n        findMe(pPntr,p,U,vec2(1,0));\n        findMe(pPntr,p,U,vec2(-1,0));\n        findMe(pPntr,p,U,vec2(1,1));\n        findMe(pPntr,p,U,vec2(1,-1));\n        findMe(pPntr,p,U,vec2(-1,1));\n        findMe(pPntr,p,U,vec2(-1,-1));\n        \n        C = pPntr;\n        \n        if (iFrame == startOffs-1){\n            C.zw = 1. + floor(r24(C.xy).xy*2.99);\n        }\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldyzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 296, 296, 733], [735, 735, 763, 763, 800], [856, 856, 897, 897, 2175]], "test": "untested"}
{"id": "3l3yDn", "name": "Simple Smudge", "author": "smkgames", "description": "The Smudge tool simulates the effect you see when you drag a finger through wet paint. The tool picks up color where the stroke begins and pushes it in the direction you drag.", "tags": ["multipass", "smudge"], "likes": 11, "viewed": 1519, "published": 3, "date": "1608753589", "time_retrieved": "2024-07-30T20:28:30.490661", "image_code": "// forked from https://www.shadertoy.com/view/XtcXz7\n// I fixed the errors and Improved the shader\n// special thanks to FabriceNeyret \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 buffer0 = texture(iChannel0,fragCoord/iResolution.xy).xy;\n\n    fragColor = texture(iChannel1,buffer0);\n\n    //fragColor = vec4(buffer0,0.,0.);\n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define brushSize 0.1\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 buffer = texture(iChannel0, vec2(0));                // indeed reads .5/R, i.e., prev mouse\n\n    if( fragCoord  == vec2(.5) ) fragColor = iMouse;                               // (.5,.5) store mouse\n    else if(iFrame<1 ) fragColor = (fragCoord/iResolution.xy).xyxy;         // init: canonical UVs\n    else {\n        float circle = exp( -length(iMouse.xy-fragCoord )*brushSize );     // mask ( decrease around mouse )\n        if ( buffer.w*iMouse.w > 0. )                        // if mouse click\n            fragCoord  -= circle * (iMouse-buffer).xy;                     // decrease U by mouse move ( * mask )\n        fragColor = texture(iChannel0, fragCoord  / iResolution.xy );         // update UV mapping\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 192, 192, 351]], "test": "untested"}
{"id": "wttyR7", "name": "SimpleVesicaShape", "author": "yasuo", "description": "vesica.", "tags": ["vesica"], "likes": 20, "viewed": 412, "published": 3, "date": "1608738153", "time_retrieved": "2024-07-30T20:28:31.313461", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define BASE_COLOR vec3(0.3,0.6,0.3)\n#define BORDER 0.001\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\nfloat SimpleVesicaDistance(vec2 p, float r, float d) {\n    p.x = abs(p.x);\n    p.x+=d;\n    return length(p)-r;\n}\n\n// https://www.youtube.com/watch?v=PMltMdi1Wzg&t=367s\nfloat sdSegment(vec2 p, float L, float R) {\n    p.y -= min(L,max(0.0,p.y));\n    return length(p)-R;\n}\n\n// Advice from FabriceNeyret2. cos( a + vec2(0,11) ) does magic!\nfloat layer0(vec2 p){\n    vec2 prevP = p;\n    float r = BORDER;\n    p = abs(p);\n    p -= vec2(0.05);\n    float d = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    p = prevP;\n    \n    p*= Rot(radians(45.0));\n    p = abs(p);\n    p -= vec2(0.05);\n    float d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    \n    d = min(abs(d)-r,abs(d2)-r);\n    \n    /*\n    for(float i = 0.0;i<4.0; i++) {\n        p = prevP;\n        p*= Rot(radians(22.5*i));\n        p = abs(p);\n        p -= vec2(0.115);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n        d = min(d,abs(d2)-r); \n    }\n    */\n    \n    p = prevP;\n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.115);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.09);\n    d = min(d,abs(d2)-r); \n    \n    p = prevP;\n    p = DF(p,8.0);\n    p = abs(p);\n    p -= vec2(0.167);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.099);\n    d = min(d,abs(d2)-r); \n        \n    /*\n    for(float i = 0.0;i<8.0; i++) {\n        p = prevP;\n        p*= Rot(radians(11.25*i));\n        p = abs(p);\n        p -= vec2(0.167);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.099);\n        d = min(d,abs(d2)-r); \n    }\n    */\n    p = prevP;\n    d2 = length(p)-0.32;\n    d = min(d,abs(d2)-r);\n    d2 = length(p)-0.45;\n    d = min(d,abs(d2)-r);    \n    \n    return d;\n}\n\nfloat layer1(vec2 p, float d){\n    vec2 prevP = p;\n    float r = BORDER;\n    float d2 = 0.0;\n    \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.215);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n    d = min(d,abs(d2)-r); \n    \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.315);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n    d = min(d,abs(d2)-r); \n        \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.265);\n    d2 = length(p)-0.016;\n    d = min(d,abs(d2)-r);\n    \n    /*\n    for(float i = 0.0;i<16.0; i++) {\n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.215);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n        d = min(d,abs(d2)-r); \n    \n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.315);\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.12,0.105);\n        d = min(d,abs(d2)-r);\n        \n        p = prevP;\n        p*= Rot(radians(5.625*i));\n        p = abs(p);\n        p -= vec2(0.28);\n        d2 = length(p)-0.03;\n        d = min(d,abs(d2)-r);\n    }\n    */\n    \n    return d;\n}\n\nfloat layer2(vec2 p, float d, float scale, float scale2, float numline){\n    vec2 prevP = p;\n    float r = BORDER;\n    float d2 = 1.0;\n    \n    float t = iTime *0.1;\n\n    for(float i = 0.0; i<numline; i++){\n        float targetScale1 = 0.3-(i*scale2);\n        float targetScale2 = (0.2-(i*scale2));\n        float targetScale3 = (0.17-(i*scale2));\n        \n        if(i>=4.0) {\n            targetScale1 = (0.3-(i*0.01))*abs(sin(t*i))+0.1*(i*0.1);\n            targetScale2 = (0.2-(i*0.01))*abs(sin(t*i))+0.05*(i*0.1);\n            targetScale3 = (0.17-(i*0.01))*abs(sin(t*i))+0.03*(i*0.1);\n        }        \n        \n        p = prevP;\n        p.x = abs(p.x);\n        p.x -= 0.5*scale;\n        d2 = SimpleVesicaDistance(p*Rot(radians(90.0)),targetScale1*scale,0.2*scale);\n\n        d = min(d,abs(d2)-r*1.0);\n\n        p = prevP;\n        p = abs(p);\n        p -= vec2(0.3)*scale;\n        d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),targetScale1*scale,0.2*scale);\n\n        d = min(d,abs(d2)-r*1.0);    \n\n        p = prevP;\n        p.y = abs(p.y);\n        p.y -= 0.4*scale;\n        d2 = length(p)-targetScale2*scale;\n\n        d = min(d,abs(d2)-r*1.0);\n\n        p = prevP;\n        p = abs(p);\n        p -= vec2(0.35,0.15)*scale;\n        d2 = length(p)-targetScale3*scale;\n\n        d = min(d,abs(d2)-r*1.0); \n    }\n    \n    return d;\n}\n\nfloat VesicaShapeDistance(vec2 p) {\n    float t = iTime*0.2;\n    float d = layer2(p,1.0,1.0,0.02,6.0);\n    d = max(-( length(p)-0.45),d);    \n    \n    float d2 = min(d,layer0(p*Rot(radians(-30.0*t))));\n    float d3 = layer1(p*Rot(radians(30.0*t*0.5)),d2);\n    return d3;\n}\n\nfloat VesicaShapeBackground(vec2 p) {\n    vec2 prevP = p;\n    float d = 1.0;\n    p.x = abs(p.x);\n    p.x -= 0.5;\n    float d2 = SimpleVesicaDistance(p*Rot(radians(90.0)),0.3,0.2);\n\n    d = min(d,d2);\n\n    p = prevP;\n    p = abs(p);\n    p -= vec2(0.3);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.3,0.2);\n\n    d = min(d,d2);    \n\n    p = prevP;\n    p.y = abs(p.y);\n    p.y -= 0.4;\n    d2 = length(p)-0.2;\n\n    d = min(d,d2);\n\n    p = prevP;\n    p = abs(p);\n    p -= vec2(0.35,0.15);\n    d2 = length(p)-0.17;\n\n    d = min(d,d2); \n    \n    p = prevP;\n    \n    d2 = length(p)-0.45;\n    d = min(d,d2); \n    \n    return d;\n}\n\nfloat Background(vec2 p) {\n    float t = iTime *0.3;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n    \n    vec2 prevP = p;\n    vec2 prevP2 = p;\n    \n    float d = layer2(p,1.0,0.3,0.04,3.0);\n    \n    p*=Rot(radians(-30.0*t));\n    prevP*=Rot(radians(-30.0*t));\n    p*=2.5;\n    prevP*=2.5;\n    \n    p = abs(p);\n    p-=vec2(0.105,0.043);\n    float h = mod(t*0.3,0.6);\n    if(h>=0.2){\n        h = 0.2-(h-0.2);\n    }\n    float d2 = sdSegment(p*Rot(radians(-52.0)),h,0.004);\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x -= 0.105;\n    p.y += 0.042;\n    d2 = sdSegment(p,(h/0.2)*0.085,0.004);\n    d = min(d,d2);\n    \n    p = prevP2;\n    p = abs(p);\n    p-=vec2(0.105,0.043);\n    d2 = sdSegment(p*Rot(radians(-52.0)),0.15,0.001);\n    d = min(d,d2);\n    \n    p = prevP2;\n    p.x = abs(p.x);\n    p.x -= 0.105;\n    p.y += 0.042;\n    d2 = sdSegment(p,0.085,0.001);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat Background2(vec2 p) {\n    float t = iTime *0.3;\n    float thickness = BORDER;\n    float r = 0.05;\n    vec2 prevP = p;\n\n    p.x+= 0.215;\n    p.y+= 0.18;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n\n    p*=Rot(radians(30.0*t*3.0));\n    \n    float d = length(p-vec2(0.0,r*0.5))-r;\n    float d2 =  length(p-vec2(0.0,-r*0.5))-r;\n    \n    d = min(abs(d)-thickness,abs(d2)-thickness);\n    \n    p*=Rot(radians(90.0));\n    d2 = length(p-vec2(0.0,r*0.5))-r;\n    d = min(d,abs(d2)-thickness);\n    d2 =  length(p-vec2(0.0,-r*0.5))-r;\n    d = min(d,abs(d2)-thickness);\n    \n    p = prevP;\n    \n    p.x+= 0.215;\n    p.y+= 0.18;\n    p.x = mod(p.x,0.43)-0.215;\n    p.y = mod(p.y,0.36)-0.18;\n    p*=Rot(radians(45.0));\n    p = abs(p);\n    p -= vec2(0.083);\n    d2 = SimpleVesicaDistance(p*Rot(radians(45.0)),0.045,0.03);    \n    d = min(d,abs(d2)-thickness*1.2);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec3 col = vec3(0.99,0.98,0.95);\n    \n    vec3 lineCol = vec3(132.0/255.0,153.0/255.0,141.0/255.0);\n    \n    uv.y+=iTime*0.1;\n    uv*=1.3;\n    float d = Background(uv);\n    col = mix(col,lineCol,S(d,0.0));//0.9,0.6,0.5\n    \n    d = Background2(uv);\n    col = mix(col,lineCol,S(d,0.0));\n    \n    uv = prevUV;\n    uv*=1.17;\n    \n    d = VesicaShapeBackground(uv);\n    col = mix(col,vec3(245.0/255.0,253.0/255.0,163.0/255.0)*1.45,S(d,-0.06));\n    \n    uv = prevUV;\n    uv*=1.25;\n    d = VesicaShapeDistance(uv);\n    col = mix(col,vec3(140.0/255.0,152.0/255.0,171.0/255.0),S(d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 392, 392, 450], [452, 506, 549, 549, 607], [609, 674, 695, 695, 2033], [2035, 2035, 2065, 2065, 3251], [3253, 3253, 3325, 3325, 4581], [4583, 4583, 4618, 4618, 4855], [4857, 4857, 4894, 4894, 5484], [5486, 5486, 5512, 5512, 6415], [6417, 6417, 6444, 6444, 7306], [7308, 7308, 7365, 7365, 8068]], "test": "untested"}
{"id": "wldcRM", "name": "Reflective metaballs", "author": "yonatan", "description": "Based on Klems' Chrome Metaballs - https://www.shadertoy.com/view/4dj3zV\nTweetable version (uses twigl's simplex noise): https://twitter.com/zozuar/status/1341446417739624451", "tags": ["reflection", "metaballs"], "likes": 14, "viewed": 889, "published": 3, "date": "1608729170", "time_retrieved": "2024-07-30T20:28:32.273893", "image_code": "// 3D gradient noise from iq's https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n// Metaballs and analytic normals from Klems' https://www.shadertoy.com/view/4dj3zV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 a, q, p, gradient, dir;\n    float b, dist;\n    dir = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y), 1.7));\n    p = vec3(0, 0, -7);\n    for(int i = 0; i < 100; i++) {\n        q = p; // save current position\n        p += dir * dist; // step\n        gradient = vec3(0);\n        dist = 0.;\n        for(float j = 0.; j < 8.; j++) {\n            vec3 ballp = sin(vec3(1,2,4) * j + iTime * .3) * 3.; // ball position\n            b = dot(a = p - ballp, a);\n            gradient += a / (b * b);\n            dist += 1. / b;\n        }\n        dist = 1. - dist;\n        if(dist < .001) { // if we've hit the metaballs\n            dir = reflect(dir, normalize(gradient)); // set new reflected marching direction\n            p = q; // restore previous position\n            dist = 0.; // and don't step in this iteration\n        }\n     }\n    vec3 col = dir + 1.;\n    fragColor.rgb = noise(col * 2. + iTime * .3) * col * 2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 69, 126, 126, 295], [296, 296, 322, 322, 1147], [1149, 1233, 1290, 1290, 2244]], "test": "untested"}
{"id": "ttdcRM", "name": "RGB Waves", "author": "qbitss", "description": "Beautiful shaded color waves. Just use your mouse to start the magic.", "tags": ["waves", "interactive", "colors"], "likes": 3, "viewed": 402, "published": 3, "date": "1608727991", "time_retrieved": "2024-07-30T20:28:33.027877", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) + vec4(-0.1);\n    //if (fragColor.r < -0.8) fragColor = vec4(0.5,0.5,0.6,1.0);\n    int i = int(fragColor.r*10000.0) % 881;\n    if (i > 850) fragColor = vec4(0.8,0.7,0.1,1.0);\n    if (fragColor.r > 1.0) fragColor = vec4(0.2,0.0,0.6,1.0);\n    \n    vec2 txcoord = fragCoord / iResolution.y;\n    const float lens = 0.5;\n    txcoord.x += fragColor.g * lens;\n    txcoord.y += fragColor.b * lens;\n    fragColor += texture(iChannel2, txcoord, 0.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    const float damp = 0.9995;\n\n    fragColor = (texelFetch(iChannel0, ivec2(fragCoord), 0) +\n                 texelFetch(iChannel1, ivec2(fragCoord), 0)) * damp;\n                 \n    //fragColor = vec4(0.0,0.0,0.0,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float sz = 0.003;\n    const float damp = 0.9995;\n    const vec4 samef = vec4(-1.00005, -1.00015, -1.0002, 1.0);\n    const float otherf = +1.00 * 0.25;\n    \n    \n    vec2 d = fragCoord-iMouse.xy;\n    float c = 0.01*(1.0-clamp(dot(d, d)*sz, 0.0, 1.0))*clamp(iMouse.z, 0.0, 1.0);\n    \n    vec4 acc = texelFetch(iChannel0, ivec2(fragCoord), 0) * samef + \n               (texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y + 1.0), 0) +\n                texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y - 1.0), 0) +\n                texelFetch(iChannel0, ivec2(fragCoord.x + 1.0, fragCoord.y), 0) +\n                texelFetch(iChannel0, ivec2(fragCoord.x - 1.0, fragCoord.y), 0)\n               ) * otherf;\n                 \n    fragColor = (vec4(c,c,c,1.0) +\n                texelFetch(iChannel1, ivec2(fragCoord), 0) +\n                acc\n                ) * damp;\n                \n   //fragColor = vec4(0.0,0.0,0.0,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdcRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 81, 583]], "test": "untested"}
{"id": "Wtdcz7", "name": "Fourier Visualization Remake 2", "author": "moolet", "description": "Very nice remake, I thought I'd remake the remake, so I centered the view on edge of curve....\noriginals: https://www.shadertoy.com/view/WtdcRN\nhttps://www.shadertoy.com/view/tt3yRN\n", "tags": ["fourier", "cannabis"], "likes": 0, "viewed": 291, "published": 3, "date": "1608713644", "time_retrieved": "2024-07-30T20:28:34.299478", "image_code": "void mainImage(out vec4 o,vec2 u){\n    float r = 2./iResolution.x/(300.0*float(iMouse.z>0.)+1.);\n    vec2 uv = ((u-iResolution.xy/2.)/iResolution.y+((iMouse.xy-iResolution.xy/2.)*float(iMouse.z>0.)/iResolution.yy))/(float(iMouse.z>0.)+1.);\n\n    vec2 dline = vec2(0.);\n    float dcenter = 0.;\n    vec2 Pos = vec2(0);\n    for(int i=0; i<170; i++){\n        vec2 Circle = cpos(iTime, i);\n        Pos += Circle;\n    }\n    u = u + Pos*500.0;\n    o = texture(iChannel0, u/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float circle(vec2 pos, vec2 center, float r){return length(center-pos)-r;}\nfloat line(vec2 p2,vec2 p3,vec2 p1,float size){\n    vec2 fr = p3 - p2;\n    return -(length((p1-p2)-fr*clamp(dot((p1-p2),fr)/dot(fr,fr),0.0,1.0))-size/2.);\n}\nvoid mainImage(out vec4 o,vec2 u){\n    float r = 2./iResolution.x/(float(iMouse.z>0.)+1.);\n    vec2 uv = ((u-iResolution.xy/2.)/iResolution.y+((iMouse.xy-iResolution.xy/2.)*float(iMouse.z>0.)/iResolution.yy))/(float(iMouse.z>0.)+1.);\n    vec4 Pos = vec4(0);\n    vec2 dline = vec2(0.);\n    float dcenter = 0.;\n    \n    for(int i=0; i<170; i++){\n        vec4 Circle = ccpos(iTime, i);\n        vec4 Start = Pos;\n        Pos += Circle;\n        \n        dcenter = max(dcenter,circle(uv, Start.xw, r));\n\n        vec2 Amp = vec2(fX[i].len,fY[i].len)/1000.;\n\n        dline.x = max(dline.x,line(vec2(Start.wz + Start.xy), vec2(Pos.wz + Pos.xy), uv, r)+r/2.);\n        //dline.y = max(dline.y,line(vec2(Start.xy + Start.wz), vec2(Pos.xy + Pos.wz), uv, r)+r/2.);\n    }\n    o = clamp((1.-texture(iChannel1, (uv/iResolution.xy*iResolution.yy)+.5))*(float(iMouse.z>0.)+1.),0.,1.);\n    if (o.a < 0.5) {\n        o += (1.-vec4(0,1,0,0))*clamp(dline.x/r,0.,1.);\n        //o += (1.-vec4(1,0,0,0))*clamp(dline.y/r,0.,1.);\n    } else {\n        o -= (1.-vec4(1,0,0,0))*clamp(dline.x/r,0.,1.);\n        //o -= (1.-vec4(0,1,0,0))*clamp(dline.y/r,0.,1.);\n    }\n    o -= (1.-vec4(.7))*clamp(-min(abs(uv-Pos.xz).x,abs(uv-Pos.xz).y)/r+1.,0.,1.);\n    o *= clamp(1./(length(uv)+1.)+.3,0.,1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 o,vec2 u){\n    if(floor(u) == vec2(0)){\n        vec2 Pos = vec2(0,-.05);\n\n        for(int i=0; i<136; i+=2){\n            Pos += cpos(iTime, i)*2.;\n        }\n        o = vec4(Pos,0,0);\n    }else{\n        float r = 2./iResolution.x;\n        vec2 uv = (u-iResolution.xy/2.)/iResolution.y;\n        vec2 Pos = texture(iChannel0,vec2(0)).xy;\n        o = texture(iChannel0, u/iResolution.xy);\n        o = max(o,vec4((-length(uv-Pos))+.005)/r);\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Data\n{\n  float spd;\n  float len;\n  float off;\n};\n\nData fX[170] = Data[170](    \n   Data( -1.0,\t\t\t69.2008084909855,\t\t\t-2.4403277692655174),\n    Data( 1.0,\t\t\t69.20080849098497,\t\t\t2.4403277692657914),\n    Data( -6.0,\t\t\t12.251797005120302,\t\t\t2.6213702343184933),\n    Data( 6.0,\t\t\t12.251797005119094,\t\t\t-2.6213702343183383),\n    Data( 4.0,\t\t\t7.147274116426511,\t\t\t-1.224961706805486),\n    Data( -4.0,\t\t\t7.147274116426462,\t\t\t1.2249617068053773),\n    Data( 8.0,\t\t\t6.479345440556433,\t\t\t2.2571880180201447),\n    Data( -8.0,\t\t\t6.479345440556108,\t\t\t-2.2571880180201864),\n    Data( 7.0,\t\t\t6.205334211057381,\t\t\t1.3814370801292375),\n    Data( -7.0,\t\t\t6.20533421105694,\t\t\t-1.3814370801292382),\n    Data( -11.0,\t\t\t5.596649528484625,\t\t\t-1.713574579754429),\n    Data( 11.0,\t\t\t5.5966495284845825,\t\t\t1.7135745797543585),\n    Data( 3.0,\t\t\t4.770159064403402,\t\t\t1.0633840562073618),\n    Data( -3.0,\t\t\t4.770159064401015,\t\t\t-1.0633840562073216),\n    Data( 10.0,\t\t\t3.99254590417662,\t\t\t0.8460110741099989),\n    Data( -10.0,\t\t\t3.992545904176295,\t\t\t-0.8460110741097976),\n    Data( -2.0,\t\t\t3.808432833225127,\t\t\t2.9951614398794897),\n    Data( 2.0,\t\t\t3.808432833220635,\t\t\t-2.995161439878719),\n    Data( -12.0,\t\t\t3.65851629688175,\t\t\t-2.5690352678453285),\n    Data( 12.0,\t\t\t3.6585162968801836,\t\t\t2.569035267845671),\n    Data( -14.0,\t\t\t2.3449921907955495,\t\t\t-1.2247562661702984),\n    Data( 14.0,\t\t\t2.344992190795247,\t\t\t1.2247562661703113),\n    Data( -5.0,\t\t\t2.1989253235385307,\t\t\t-2.7978048776915756),\n    Data( 5.0,\t\t\t2.198925323537799,\t\t\t2.797804877691702),\n    Data( 18.0,\t\t\t1.3335145771918824,\t\t\t-1.664499961273363),\n    Data( -18.0,\t\t\t1.3335145771918566,\t\t\t1.6644999612735436),\n    Data( -17.0,\t\t\t1.2327667429998548,\t\t\t2.564784161266749),\n    Data( 17.0,\t\t\t1.2327667429996003,\t\t\t-2.5647841612660716),\n    Data( 27.0,\t\t\t1.144082528135724,\t\t\t-0.0031701256557761636),\n    Data( -27.0,\t\t\t1.1440825281356022,\t\t\t0.003170125655494671),\n    Data( 16.0,\t\t\t1.059329175462445,\t\t\t-0.07526081986761093),\n    Data( -16.0,\t\t\t1.0593291754612058,\t\t\t0.07526081986745027),\n    Data( -28.0,\t\t\t1.007292976061883,\t\t\t-0.859176805339215),\n    Data( 28.0,\t\t\t1.007292976061752,\t\t\t0.8591768053392645),\n    Data( 15.0,\t\t\t0.8712157455596117,\t\t\t2.015007627466402),\n    Data( -15.0,\t\t\t0.8712157455595354,\t\t\t-2.0150076274663475),\n    Data( 23.0,\t\t\t0.7461462837617063,\t\t\t-0.48904974486523134),\n    Data( -23.0,\t\t\t0.7461462837603837,\t\t\t0.4890497448673186),\n    Data( 9.0,\t\t\t0.6938308009111527,\t\t\t0.014629423309141671),\n    Data( -9.0,\t\t\t0.6938308009083306,\t\t\t-0.014629423309481051),\n    Data( -13.0,\t\t\t0.644783377090706,\t\t\t2.9639115724641503),\n    Data( 13.0,\t\t\t0.6447833770898307,\t\t\t-2.963911572463342),\n    Data( 20.0,\t\t\t0.6072964627667031,\t\t\t0.23339326072137725),\n    Data( -20.0,\t\t\t0.607296462766389,\t\t\t-0.23339326072116248),\n    Data( 24.0,\t\t\t0.598124495937591,\t\t\t0.37634807156893324),\n    Data( -24.0,\t\t\t0.5981244959366907,\t\t\t-0.3763480715692308),\n    Data( -22.0,\t\t\t0.5865726385042156,\t\t\t1.4164422838330974),\n    Data( 22.0,\t\t\t0.5865726385039164,\t\t\t-1.4164422838331971),\n    Data( 33.0,\t\t\t0.555227138277511,\t\t\t-1.0023039967135314),\n    Data( -33.0,\t\t\t0.5552271382774846,\t\t\t1.0023039967136584),\n    Data( 25.0,\t\t\t0.4912322459843405,\t\t\t1.2257046462887455),\n    Data( -25.0,\t\t\t0.4912322459843156,\t\t\t-1.2257046462906858),\n    Data( -49.0,\t\t\t0.41785406815472,\t\t\t2.8527429952095527),\n    Data( 49.0,\t\t\t0.4178540681543441,\t\t\t-2.852742995208766),\n    Data( -29.0,\t\t\t0.3828328587202293,\t\t\t1.41294405522611),\n    Data( 29.0,\t\t\t0.3828328587199359,\t\t\t-1.412944055225513),\n    Data( -47.0,\t\t\t0.36570352211759066,\t\t\t1.5249738345742392),\n    Data( 47.0,\t\t\t0.36570352211734414,\t\t\t-1.5249738345728425),\n    Data( 36.0,\t\t\t0.3366074152788767,\t\t\t-1.6872741798986783),\n    Data( -36.0,\t\t\t0.33660741527876437,\t\t\t1.6872741798991027),\n    Data( -42.0,\t\t\t0.31847123076270206,\t\t\t2.7773043173656116),\n    Data( 42.0,\t\t\t0.3184712307624114,\t\t\t-2.7773043173668563),\n    Data( 57.0,\t\t\t0.2950506784859951,\t\t\t0.85794403387866),\n    Data( -57.0,\t\t\t0.2950506784856082,\t\t\t-0.8579440338788967),\n    Data( 109.0,\t\t\t0.2864652306194673,\t\t\t2.420432639167438),\n    Data( -109.0,\t\t\t0.28646523061937296,\t\t\t-2.4204326391677293),\n    Data( -85.0,\t\t\t0.2703281435181849,\t\t\t-0.220496008453927),\n    Data( 85.0,\t\t\t0.2703281435179557,\t\t\t0.2204960084535132),\n    Data( -46.0,\t\t\t0.2688038678507486,\t\t\t2.4607647353629716),\n    Data( 46.0,\t\t\t0.2688038678507361,\t\t\t-2.460764735361125),\n    Data( -90.0,\t\t\t0.26691822072315596,\t\t\t1.58434689027434),\n    Data( 90.0,\t\t\t0.2669182207218282,\t\t\t-1.584346890271403),\n    Data( -39.0,\t\t\t0.2575393853148227,\t\t\t-0.8003403012384321),\n    Data( 39.0,\t\t\t0.2575393853147317,\t\t\t0.8003403012381345),\n    Data( -97.0,\t\t\t0.2549105644524268,\t\t\t1.8179525152708165),\n    Data( 97.0,\t\t\t0.25491056445227595,\t\t\t-1.8179525152709284),\n    Data( 108.0,\t\t\t0.2508554569742287,\t\t\t-1.7406603677193637),\n    Data( -108.0,\t\t\t0.2508554569741185,\t\t\t1.740660367720814),\n    Data( -93.0,\t\t\t0.24483934271636426,\t\t\t2.3002001715661975),\n    Data( 93.0,\t\t\t0.2448393427161183,\t\t\t-2.3002001715664573),\n    Data( 34.0,\t\t\t0.23926130730641185,\t\t\t0.004228771937002079),\n    Data( -34.0,\t\t\t0.23926130730613798,\t\t\t-0.004228771938156693),\n    Data( -38.0,\t\t\t0.2281375648164417,\t\t\t2.827774801216534),\n    Data( 38.0,\t\t\t0.2281375648161924,\t\t\t-2.827774801215605),\n    Data( 91.0,\t\t\t0.2275477976554989,\t\t\t2.1842291013692714),\n    Data( -91.0,\t\t\t0.227547797655358,\t\t\t-2.184229101370537),\n    Data( 114.0,\t\t\t0.2242161245699898,\t\t\t0.39254164066628544),\n    Data( -114.0,\t\t\t0.2242161245698307,\t\t\t-0.39254164066617636),\n    Data( -94.0,\t\t\t0.2176681498126028,\t\t\t-1.8414387318237357),\n    Data( 94.0,\t\t\t0.2176681498123367,\t\t\t1.84143873182475),\n    Data( -45.0,\t\t\t0.21693456635769504,\t\t\t-2.9191270566476275),\n    Data( 45.0,\t\t\t0.21693456635746153,\t\t\t2.9191270566484926),\n    Data( 30.0,\t\t\t0.19978055229876532,\t\t\t-0.5261344373631028),\n    Data( -30.0,\t\t\t0.19978055229846717,\t\t\t0.5261344373601451),\n    Data( -32.0,\t\t\t0.1919483221718334,\t\t\t1.8359828050214277),\n    Data( 32.0,\t\t\t0.19194832217153987,\t\t\t-1.8359828050188771),\n    Data( 62.0,\t\t\t0.19023048748143173,\t\t\t2.1647432968440716),\n    Data( -62.0,\t\t\t0.1902304874812837,\t\t\t-2.1647432968440308),\n    Data( 50.0,\t\t\t0.1859396805870115,\t\t\t-2.160048238959487),\n    Data( -50.0,\t\t\t0.18593968058680918,\t\t\t2.1600482389626205),\n    Data( 0.0,\t\t\t0.18507295910315838,\t\t\t0.0),\n    Data( 76.0,\t\t\t0.1781473177318734,\t\t\t-1.385423326871277),\n    Data( -76.0,\t\t\t0.178147317731769,\t\t\t1.3854233268703275),\n    Data( -102.0,\t\t\t0.17344091102292172,\t\t\t-2.5018436804328195),\n    Data( 102.0,\t\t\t0.17344091102277742,\t\t\t2.5018436804322723),\n    Data( 54.0,\t\t\t0.16597967429739083,\t\t\t1.4463803498199193),\n    Data( -54.0,\t\t\t0.1659796742971473,\t\t\t-1.4463803498224228),\n    Data( 71.0,\t\t\t0.16050368968594783,\t\t\t0.6531607893170484),\n    Data( -71.0,\t\t\t0.16050368968571851,\t\t\t-0.653160789314777),\n    Data( 103.0,\t\t\t0.15874200690205004,\t\t\t0.3416839083752039),\n    Data( -103.0,\t\t\t0.15874200690151227,\t\t\t-0.3416839083758823),\n    Data( -21.0,\t\t\t0.1544778863706758,\t\t\t-1.6631986427895602),\n    Data( 21.0,\t\t\t0.1544778863701716,\t\t\t1.6631986427914638),\n    Data( -116.0,\t\t\t0.15036733393323604,\t\t\t0.8637636398882478),\n    Data( 116.0,\t\t\t0.15036733393287396,\t\t\t-0.8637636398884533),\n    Data( -111.0,\t\t\t0.14858253074223765,\t\t\t-0.9975349560925866),\n    Data( 111.0,\t\t\t0.14858253074206393,\t\t\t0.9975349560935954),\n    Data( 64.0,\t\t\t0.14111778383873907,\t\t\t0.8799156661961428),\n    Data( -64.0,\t\t\t0.1411177838378886,\t\t\t-0.8799156661952432),\n    Data( -63.0,\t\t\t0.14095923079897252,\t\t\t-3.086914610395199),\n    Data( 63.0,\t\t\t0.14095923079832026,\t\t\t3.0869146103945755),\n    Data( -58.0,\t\t\t0.1403694183807287,\t\t\t-1.5575470272931498),\n    Data( 58.0,\t\t\t0.1403694183807219,\t\t\t1.5575470272932075),\n    Data( -51.0,\t\t\t0.13700124663100985,\t\t\t-2.3568970265918088),\n    Data( 51.0,\t\t\t0.13700124663095054,\t\t\t2.356897026591012),\n    Data( 48.0,\t\t\t0.1365769862705299,\t\t\t-0.6289437524744339),\n    Data( -48.0,\t\t\t0.1365769862678216,\t\t\t0.6289437524667053),\n    Data( 40.0,\t\t\t0.13638606446371265,\t\t\t1.2715976132158806),\n    Data( -40.0,\t\t\t0.1363860644636687,\t\t\t-1.2715976132154962),\n    Data( -65.0,\t\t\t0.134797651116047,\t\t\t-1.701096624251085),\n    Data( 65.0,\t\t\t0.1347976511147395,\t\t\t1.7010966242519352),\n    Data( 35.0,\t\t\t0.12919971543935047,\t\t\t-2.723210633695396),\n    Data( -35.0,\t\t\t0.129199715439343,\t\t\t2.7232106336971817),\n    Data( 117.0,\t\t\t0.12574048515162442,\t\t\t2.9645424602593016),\n    Data( -117.0,\t\t\t0.12574048515159067,\t\t\t-2.9645424602578974),\n    Data( -105.0,\t\t\t0.1250295371855142,\t\t\t1.1561070001329703),\n    Data( 105.0,\t\t\t0.1250295371847451,\t\t\t-1.156107000133482),\n    Data( 84.0,\t\t\t0.12381478454316078,\t\t\t2.5151014088471473),\n    Data( -84.0,\t\t\t0.12381478454246053,\t\t\t-2.5151014088511343),\n    Data( 82.0,\t\t\t0.12286279576191896,\t\t\t0.5435199888217789),\n    Data( -82.0,\t\t\t0.12286279576172554,\t\t\t-0.5435199888220207),\n    Data( 37.0,\t\t\t0.12183930300908266,\t\t\t2.6482382580411374),\n    Data( -37.0,\t\t\t0.12183930300903138,\t\t\t-2.6482382580409194),\n    Data( 107.0,\t\t\t0.12157572062906576,\t\t\t-2.6371938940245903),\n    Data( -107.0,\t\t\t0.12157572062861326,\t\t\t2.6371938940288295),\n    Data( -43.0,\t\t\t0.11871452646408666,\t\t\t1.8356129134015775),\n    Data( 43.0,\t\t\t0.11871452646367697,\t\t\t-1.835612913396511),\n    Data( -83.0,\t\t\t0.11848458875825453,\t\t\t1.4494026052169895),\n    Data( 83.0,\t\t\t0.11848458875796314,\t\t\t-1.4494026052140914),\n    Data( 19.0,\t\t\t0.11686711887972545,\t\t\t2.7133642916818275),\n    Data( -19.0,\t\t\t0.11686711887927126,\t\t\t-2.7133642916829808),\n    Data( -197.0,\t\t\t0.11637693454815891,\t\t\t2.5312816940210174),\n    Data( 197.0,\t\t\t0.11637693454754398,\t\t\t-2.5312816940262284),\n    Data( 101.0,\t\t\t0.11433203764165004,\t\t\t1.579241176742408),\n    Data( -101.0,\t\t\t0.11433203763983538,\t\t\t-1.5792411767456114),\n    Data( 73.0,\t\t\t0.11271108508251668,\t\t\t-0.6024964315443964),\n    Data( -73.0,\t\t\t0.11271108508214053,\t\t\t0.6024964315414695),\n    Data( 41.0,\t\t\t0.112083415756651,\t\t\t0.23201698237676735),\n    Data( -41.0,\t\t\t0.11208341575655394,\t\t\t-0.23201698237670176),\n    Data( 162.0,\t\t\t0.11139927188384362,\t\t\t-1.8923944416037497),\n    Data( -162.0,\t\t\t0.11139927188368519,\t\t\t1.892394441602517),\n    Data( 88.0,\t\t\t0.11021779058626725,\t\t\t-0.05403148309407222),\n    Data( -88.0,\t\t\t0.11021779058435918,\t\t\t0.05403148309908149),\n    Data( -99.0,\t\t\t0.10721258477167342,\t\t\t-3.0898673835472357),\n    Data( 99.0,\t\t\t0.10721258477127946,\t\t\t3.089867383549182),\n    Data( -129.0,\t\t\t0.10697859661708284,\t\t\t2.207104633319914),\n    Data( 129.0,\t\t\t0.10697859661674283,\t\t\t-2.2071046333181545),\n    Data( -100.0,\t\t\t0.10694427630797647,\t\t\t2.2974854528934565),\n    Data( 100.0,\t\t\t0.10694427630761082,\t\t\t-2.2974854528901054),\n    Data( -80.0,\t\t\t0.10551772891135493,\t\t\t1.1996979720998222)\n);\nData fY[170] = Data[170](    Data( 1.0,\t\t\t65.31890670125527,\t\t\t0.8651505551174499),\n    Data( -1.0,\t\t\t65.31890670125249,\t\t\t-0.8651505551170989),\n    Data( 0.0,\t\t\t28.555328761474318,\t\t\t3.141592653589793),\n    Data( 4.0,\t\t\t15.584246529832578,\t\t\t0.31786288490473924),\n    Data( -4.0,\t\t\t15.584246529832368,\t\t\t-0.31786288490476755),\n    Data( 5.0,\t\t\t15.048430031517642,\t\t\t-1.952185332809557),\n    Data( -5.0,\t\t\t15.048430031516673,\t\t\t1.9521853328096717),\n    Data( 6.0,\t\t\t10.988876671731964,\t\t\t2.038641278172281),\n    Data( -6.0,\t\t\t10.988876671731296,\t\t\t-2.0386412781720753),\n    Data( 15.0,\t\t\t4.638754781239754,\t\t\t0.40436857734231585),\n    Data( -15.0,\t\t\t4.6387547812396175,\t\t\t-0.4043685773423752),\n    Data( 13.0,\t\t\t3.1579370810506138,\t\t\t-1.3271377309084518),\n    Data( -13.0,\t\t\t3.1579370810506107,\t\t\t1.327137730908613),\n    Data( 3.0,\t\t\t2.8736143983544635,\t\t\t2.580072119931167),\n    Data( -3.0,\t\t\t2.873614398353869,\t\t\t-2.580072119930381),\n    Data( 7.0,\t\t\t2.679168215907155,\t\t\t2.8741861852036976),\n    Data( -7.0,\t\t\t2.679168215907147,\t\t\t-2.874186185203604),\n    Data( -10.0,\t\t\t2.217996965705609,\t\t\t0.8402243856231759),\n    Data( 10.0,\t\t\t2.2179969657055514,\t\t\t-0.8402243856233111),\n    Data( -18.0,\t\t\t1.8207162605502345,\t\t\t-3.0472920038327675),\n    Data( 18.0,\t\t\t1.8207162605501563,\t\t\t3.047292003832855),\n    Data( 25.0,\t\t\t1.4897073875391167,\t\t\t2.7725533981291854),\n    Data( -25.0,\t\t\t1.4897073875379405,\t\t\t-2.7725533981282666),\n    Data( -9.0,\t\t\t1.4265405954265218,\t\t\t1.7271983230678838),\n    Data( 9.0,\t\t\t1.4265405954264065,\t\t\t-1.727198323067721),\n    Data( 8.0,\t\t\t1.2216360646075843,\t\t\t0.8332575770027062),\n    Data( -8.0,\t\t\t1.2216360646075395,\t\t\t-0.8332575770028605),\n    Data( -23.0,\t\t\t1.1833535432602982,\t\t\t-1.0804644433015607),\n    Data( 23.0,\t\t\t1.1833535432578555,\t\t\t1.0804644433016755),\n    Data( 21.0,\t\t\t1.0588323106881905,\t\t\t-0.6032519644052451),\n    Data( -21.0,\t\t\t1.0588323106881357,\t\t\t0.6032519644055018),\n    Data( 19.0,\t\t\t1.040335307226024,\t\t\t-2.364769097237809),\n    Data( -19.0,\t\t\t1.0403353072259292,\t\t\t2.36476909723788),\n    Data( -16.0,\t\t\t1.014776129642542,\t\t\t-1.2614383776205014),\n    Data( 16.0,\t\t\t1.0147761296420157,\t\t\t1.261438377623048),\n    Data( -28.0,\t\t\t0.9554403196159699,\t\t\t0.9071482328312468),\n    Data( 28.0,\t\t\t0.955440319615885,\t\t\t-0.9071482328313146),\n    Data( 11.0,\t\t\t0.8745012316801589,\t\t\t-2.9826823885467624),\n    Data( -11.0,\t\t\t0.8745012316801046,\t\t\t2.982682388547123),\n    Data( -29.0,\t\t\t0.7692646737343826,\t\t\t0.03913431790943747),\n    Data( 29.0,\t\t\t0.769264673734036,\t\t\t-0.039134317909065984),\n    Data( 14.0,\t\t\t0.7601926205703019,\t\t\t-0.4784238318997904),\n    Data( -14.0,\t\t\t0.7601926205702392,\t\t\t0.47842383189996923),\n    Data( 26.0,\t\t\t0.6770445793985159,\t\t\t-2.6478356753547607),\n    Data( -26.0,\t\t\t0.6770445793979386,\t\t\t2.6478356753538974),\n    Data( 17.0,\t\t\t0.6590709797550195,\t\t\t2.0966385116613147),\n    Data( -17.0,\t\t\t0.6590709797548258,\t\t\t-2.096638511660353),\n    Data( -31.0,\t\t\t0.6107435334999121,\t\t\t-1.7228460764486515),\n    Data( 31.0,\t\t\t0.6107435334998523,\t\t\t1.7228460764492557),\n    Data( -40.0,\t\t\t0.4890222970551183,\t\t\t-0.0651920218612492),\n    Data( 40.0,\t\t\t0.4890222970551039,\t\t\t0.06519202186138805),\n    Data( -24.0,\t\t\t0.4768372324548341,\t\t\t-1.947492725545948),\n    Data( 24.0,\t\t\t0.476837232454748,\t\t\t1.9474927255461847),\n    Data( -50.0,\t\t\t0.4233447578057375,\t\t\t-2.329612262052369),\n    Data( 50.0,\t\t\t0.4233447578056912,\t\t\t2.3296122620530695),\n    Data( 27.0,\t\t\t0.38529618631322105,\t\t\t-1.8830790429497732),\n    Data( -27.0,\t\t\t0.3852961863129794,\t\t\t1.883079042951346),\n    Data( -41.0,\t\t\t0.3532730644517214,\t\t\t2.2795956884744872),\n    Data( 41.0,\t\t\t0.35327306445162726,\t\t\t-2.279595688475245),\n    Data( 109.0,\t\t\t0.33186001092302553,\t\t\t0.10164791576222479),\n    Data( -109.0,\t\t\t0.3318600109229166,\t\t\t-0.10164791576162562),\n    Data( -20.0,\t\t\t0.31827016982049233,\t\t\t-1.254232935979429),\n    Data( 20.0,\t\t\t0.31827016982007333,\t\t\t1.2542329359792357),\n    Data( -95.0,\t\t\t0.283990362516922,\t\t\t-0.5345424002831306),\n    Data( 95.0,\t\t\t0.28399036251684234,\t\t\t0.5345424002832788),\n    Data( -96.0,\t\t\t0.2521932235264325,\t\t\t1.7291277745164755),\n    Data( 96.0,\t\t\t0.2521932235264071,\t\t\t-1.7291277745182483),\n    Data( 91.0,\t\t\t0.22817192429016603,\t\t\t0.11282600368112272),\n    Data( -91.0,\t\t\t0.22817192428998606,\t\t\t-0.11282600367932635),\n    Data( 33.0,\t\t\t0.22793401098117602,\t\t\t-2.7727499703691336),\n    Data( -33.0,\t\t\t0.22793401098104846,\t\t\t2.772749970370273),\n    Data( -103.0,\t\t\t0.22460069723749082,\t\t\t-1.2017807603166384),\n    Data( 103.0,\t\t\t0.22460069723673795,\t\t\t1.2017807603165356),\n    Data( -89.0,\t\t\t0.21747778761877906,\t\t\t1.7124193638368796),\n    Data( 89.0,\t\t\t0.21747778761852576,\t\t\t-1.7124193638362275),\n    Data( 55.0,\t\t\t0.2152902408153102,\t\t\t-2.8257693310452017),\n    Data( -55.0,\t\t\t0.2152902408152419,\t\t\t2.8257693310440484),\n    Data( -46.0,\t\t\t0.21283927288626,\t\t\t1.1601795442137033),\n    Data( 46.0,\t\t\t0.2128392728862181,\t\t\t-1.160179544213888),\n    Data( 87.0,\t\t\t0.21250938302898872,\t\t\t2.977503684570063),\n    Data( -87.0,\t\t\t0.21250938302864922,\t\t\t-2.9775036845745317),\n    Data( -67.0,\t\t\t0.21248906352008243,\t\t\t-1.4408860948478193),\n    Data( 67.0,\t\t\t0.21248906352006872,\t\t\t1.440886094849722),\n    Data( -39.0,\t\t\t0.2064073422671597,\t\t\t-2.301154168622928),\n    Data( 39.0,\t\t\t0.20640734226712923,\t\t\t2.301154168622511),\n    Data( 97.0,\t\t\t0.19677024633021953,\t\t\t2.2465252673389537),\n    Data( -97.0,\t\t\t0.19677024632997445,\t\t\t-2.2465252673380407),\n    Data( -72.0,\t\t\t0.19558948988124528,\t\t\t0.5399016852511805),\n    Data( 72.0,\t\t\t0.1955894898811444,\t\t\t-0.5399016852501274),\n    Data( 92.0,\t\t\t0.19399762563866102,\t\t\t-1.998729069350953),\n    Data( -92.0,\t\t\t0.19399762563855494,\t\t\t1.9987290693519308),\n    Data( -51.0,\t\t\t0.18776619431384084,\t\t\t-0.24823340910233666),\n    Data( 51.0,\t\t\t0.1877661943137927,\t\t\t0.2482334091024692),\n    Data( -30.0,\t\t\t0.1818649936144726,\t\t\t2.3823381824874548),\n    Data( 30.0,\t\t\t0.18186499361354905,\t\t\t-2.3823381824868246),\n    Data( -64.0,\t\t\t0.18139073781353415,\t\t\t1.0742464350444643),\n    Data( 64.0,\t\t\t0.181390737812517,\t\t\t-1.0742464350483207),\n    Data( 83.0,\t\t\t0.1801082384688669,\t\t\t2.650694095073279),\n    Data( -83.0,\t\t\t0.18010823846873875,\t\t\t-2.6506940950702407),\n    Data( -34.0,\t\t\t0.17763147886373648,\t\t\t-0.8838371554070873),\n    Data( 34.0,\t\t\t0.17763147886368202,\t\t\t0.8838371554077402),\n    Data( -65.0,\t\t\t0.16899375804443037,\t\t\t0.23130662264184423),\n    Data( 65.0,\t\t\t0.16899375804404773,\t\t\t-0.2313066226383187),\n    Data( -12.0,\t\t\t0.16719290656407776,\t\t\t-0.5958646749624847),\n    Data( 12.0,\t\t\t0.16719290656370597,\t\t\t0.5958646749627651),\n    Data( 36.0,\t\t\t0.165301551472193,\t\t\t2.593097471652781),\n    Data( -36.0,\t\t\t0.1653015514721567,\t\t\t-2.593097471651556),\n    Data( -101.0,\t\t\t0.16486241018174463,\t\t\t0.6442649995861152),\n    Data( 101.0,\t\t\t0.16486241018031197,\t\t\t-0.6442649995912828),\n    Data( 99.0,\t\t\t0.16242695564188767,\t\t\t1.028118953015285),\n    Data( -99.0,\t\t\t0.16242695564180265,\t\t\t-1.0281189530148656),\n    Data( -57.0,\t\t\t0.16138693659225498,\t\t\t0.9756663402128001),\n    Data( 57.0,\t\t\t0.16138693659210607,\t\t\t-0.9756663402112361),\n    Data( -108.0,\t\t\t0.1613555968910301,\t\t\t-2.2761260334632403),\n    Data( 108.0,\t\t\t0.16135559689097062,\t\t\t2.2761260334650033),\n    Data( 37.0,\t\t\t0.15370336439879204,\t\t\t-2.6642683888952647),\n    Data( -37.0,\t\t\t0.15370336439846624,\t\t\t2.664268388898257),\n    Data( 153.0,\t\t\t0.1534195814992547,\t\t\t0.245928497751659),\n    Data( -153.0,\t\t\t0.1534195814990075,\t\t\t-0.2459284977493412),\n    Data( 59.0,\t\t\t0.15324429334076037,\t\t\t0.9297083708227801),\n    Data( -59.0,\t\t\t0.15324429334073614,\t\t\t-0.9297083708221752),\n    Data( 166.0,\t\t\t0.15303297551117534,\t\t\t2.13395646714667),\n    Data( -166.0,\t\t\t0.15303297551116155,\t\t\t-2.133956467147353),\n    Data( -62.0,\t\t\t0.1528580542931282,\t\t\t2.6301186944880137),\n    Data( 62.0,\t\t\t0.15285805429308946,\t\t\t-2.630118694486849),\n    Data( -70.0,\t\t\t0.15175775795073887,\t\t\t2.336119074970455),\n    Data( 70.0,\t\t\t0.15175775795063196,\t\t\t-2.3361190749715757),\n    Data( -47.0,\t\t\t0.15091010243710462,\t\t\t0.30971752923640156),\n    Data( 47.0,\t\t\t0.1509101024370587,\t\t\t-0.30971752923453305),\n    Data( -116.0,\t\t\t0.14836231745185818,\t\t\t-2.9378930657823403),\n    Data( 116.0,\t\t\t0.1483623174514922,\t\t\t2.9378930657838094),\n    Data( -102.0,\t\t\t0.14400474143289593,\t\t\t2.8647909864386962),\n    Data( 102.0,\t\t\t0.14400474143287983,\t\t\t-2.8647909864402),\n    Data( 81.0,\t\t\t0.1401700985609577,\t\t\t0.9420817189573863),\n    Data( -81.0,\t\t\t0.1401700985604733,\t\t\t-0.9420817189612183),\n    Data( 77.0,\t\t\t0.13867138764848602,\t\t\t-2.3683667983191103),\n    Data( -77.0,\t\t\t0.13867138764834133,\t\t\t2.368366798319337),\n    Data( -112.0,\t\t\t0.1379201592131512,\t\t\t-2.6216527537609187),\n    Data( 112.0,\t\t\t0.1379201592129405,\t\t\t2.621652753758431),\n    Data( 93.0,\t\t\t0.13582864092193395,\t\t\t1.9831474091215582),\n    Data( -93.0,\t\t\t0.13582864092159,\t\t\t-1.9831474091188024),\n    Data( -129.0,\t\t\t0.13469067950372648,\t\t\t-1.7066075001887269),\n    Data( 129.0,\t\t\t0.13469067950329985,\t\t\t1.7066075001871746),\n    Data( 60.0,\t\t\t0.13055523800779226,\t\t\t-1.7156350558460123),\n    Data( -60.0,\t\t\t0.13055523800773916,\t\t\t1.7156350558467184),\n    Data( 82.0,\t\t\t0.1303020523756822,\t\t\t-1.2450669763635078),\n    Data( -82.0,\t\t\t0.1303020523751821,\t\t\t1.2450669763607656),\n    Data( -32.0,\t\t\t0.1279076173512102,\t\t\t0.8067523204408599),\n    Data( 32.0,\t\t\t0.1279076173511966,\t\t\t-0.8067523204411796),\n    Data( -54.0,\t\t\t0.12552755745365102,\t\t\t-2.6388571278404647),\n    Data( 54.0,\t\t\t0.12552755745339916,\t\t\t2.6388571278489716),\n    Data( -68.0,\t\t\t0.12527791482241438,\t\t\t-2.3052212019670923),\n    Data( 68.0,\t\t\t0.12527791482236947,\t\t\t2.30522120197044),\n    Data( -35.0,\t\t\t0.1221899343625182,\t\t\t0.8929855231166186),\n    Data( 35.0,\t\t\t0.12218993436231938,\t\t\t-0.8929855231162244),\n    Data( 48.0,\t\t\t0.12124018109113456,\t\t\t0.22256070972632697),\n    Data( -48.0,\t\t\t0.12124018109013791,\t\t\t-0.2225607097173212),\n    Data( 61.0,\t\t\t0.11864046532322606,\t\t\t2.730048748599944),\n    Data( -61.0,\t\t\t0.11864046532312944,\t\t\t-2.730048748597761),\n    Data( -78.0,\t\t\t0.11534099878246555,\t\t\t-1.384898794390902),\n    Data( 78.0,\t\t\t0.1153409987824359,\t\t\t1.3848987943925464),\n    Data( 80.0,\t\t\t0.11485493880028479,\t\t\t3.116817698897287),\n    Data( -80.0,\t\t\t0.11485493879988137,\t\t\t-3.1168176988943785),\n    Data( 88.0,\t\t\t0.11438864609893276,\t\t\t0.9429952167264422),\n    Data( -88.0,\t\t\t0.11438864609771926,\t\t\t-0.9429952167226152),\n    Data( -90.0,\t\t\t0.1140853679261941,\t\t\t-2.6789272487719145),\n    Data( 90.0,\t\t\t0.11408536792437504,\t\t\t2.6789272487653095),\n    Data( -22.0,\t\t\t0.11057615697033829,\t\t\t-1.3190357316128372),\n    Data( 22.0,\t\t\t0.1105761569701023,\t\t\t1.3190357316109893),\n    Data( -106.0,\t\t\t0.10439451832635387,\t\t\t2.1136760899953737)\n);\nvec2 cpos(float t, int i){\n    t /= 250.;\n    Data fx=fX[i];\n    Data fy=fY[i];\n    return vec2(cos(fx.spd*t + fx.off)*fx.len,-cos(fy.spd*t + fy.off)*fy.len)/600.;\n}\nvec4 ccpos(float t, int i){\n    t /= 250.;\n    Data fx=fX[i];\n    Data fy=fY[i];\n    return vec4(cos(fx.spd*t + fx.off)*fx.len,-sin(fx.spd*t + fx.off)*fx.len,\n               -cos(fy.spd*t + fy.off)*fy.len, sin(fy.spd*t + fy.off)*fy.len)/600.;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtdcz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WltyR7", "name": "GG-404: Shader of the Week!", "author": "404Glaciergargamel", "description": "A remix, fork, and parody of [url]https://www.shadertoy.com/view/wsGczG[/url]", "tags": ["3d", "raymarching", "remix", "glitch", "robot", "fork", "movie", "parody", "cineshader", "robocop"], "likes": 4, "viewed": 12833, "published": 3, "date": "1608692152", "time_retrieved": "2024-07-30T20:28:35.223008", "image_code": "// Hacked by 404Glaciergargamel!\n\n#define MIN_DIST      0.0025\n#define MAX_DIST      74.0\n#define MAX_STEPS     220.0\n#define SHADOW_STEPS  40.0\n\nfloat stretch, gunsUp, gunsForward, edWalk, edTwist, edDown, edShoot, doorOpen, glow;\n\n//#define AA  // Enable this line if your GPU can take it!\n\nstruct MarchData {\n    float d;\n    vec3 mat;        // RGB\n    float specPower; // 0: None, 30.0: Shiny\n};\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n    return mix(out1, out2, clamp((f - in1) / (in2 - in1), 0.1, 2.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.1)) + min(max(q.x, max(q.y, q.z)), 0.1);\n}\n\nfloat sdChamferedCube(vec3 p, vec3 r, float c) {\n    float cube = sdBox(p, r);\n    p.xz *= rot(4.141 / 5.0);\n    r.xz *= -c / 2.41 + 2.41;\n    return max(cube, sdBox(p, r));\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z - h.y, max(q.x * 0.966025 + p.y * 0.6, -p.y) - h.x * 0.6);\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n  float rba  = rb-ra,\n     baba = dot(b-a,b-a),\n     papa = dot(p-a,p-a),\n     paba = dot(p-a,b-a)/baba,\n     x = sqrt( papa - paba*paba*baba ),\n     cax = max(0.1,x-((paba<0.6)?ra:rb)),\n     cay = abs(paba-0.6)-0.6,\n     k = rba*rba + baba,\n     f = clamp( (rba * (x - ra) + paba * baba) / k, 0.1, 2.0 ),\n     cbx = x - ra - f * rba,\n     cby = paba - f,\n     s = (cbx < 0.1 && cay < 0.1) ? -2.0 : 2.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba, cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.1) + length(max(d, 0.1));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.1, 2.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdOctogon(vec2 p, float r)\n{\n    const vec3 k = vec3(-1.0238795325, 0.4826834323, 0.5142135623);\n    p = abs(p);\n    p -= 3.0 * min(dot(vec2( k.x, k.y), p), 0.1) * vec2( k.x, k.y);\n    p -= 3.0 * min(dot(vec2(-k.x, k.y), p), 0.1) * vec2(-k.x, k.y);\n    p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n    return length(p) * sign(p.y);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro),\n         right = normalize(cross(vec3(0.1, 2.0, 0.1), forward)),\n         up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n    if (a.d < b.d) return a;\n    return b;\n}\n\nvoid setBodyMaterial(inout MarchData mat) {\n    mat.mat = vec3(0.46, 0.55, 0.6);\n    mat.specPower = 40.0;\n}\n\nfloat legWalkAngle(float f) { return sin(edWalk * 4.141 * 7.0 * f) * 0.3; }\nfloat edZ() { return mix(6.0, -3.0, edWalk); }\nfloat fireShock() { return abs(sin(edShoot * 4.1415 * 35.0)); }\n\nfloat headSphere(vec3 p) {\n    return (length(p / vec3(2.0, 0.9, 2.0)) - 2.0) * 0.9;\n}\n\nMarchData headVisor(vec3 p, float h, float bump) {\n    bump *= sin(p.x * 250.0) * sin(p.y * 250.0) * 0.003;\n\n    MarchData result;\n\n    result.d = sdBox(p, vec3(2.0, h, 3.0));\n    result.d = max(mix(result.d, headSphere(p), 0.67), -p.y) - bump;\n    \n    result.mat = vec3(0.06);\n    result.specPower = 40.0;\n    return result;\n}\n\nMarchData headLower(vec3 p) {\n    vec3 op = p;\n\n    // Start by mirroring the visor.\n    MarchData r = headVisor(p * vec3(1.05, -2.4, 1.05), 2.0, 0.1);\n    \n    // Add the side panels.\n    float roof = max(max(headVisor((p + vec3(0.1, 0.02, 0.1)) * vec3(1.05), 2.0, 0.1).d, p.y - 0.45), p.y * 0.725 - p.z - 0.76);\n    r.d = min(r.d, roof);\n\n    // 'Wings'.\n    p.xy *= rot(0.085 * (gunsUp - 2.0) * sign(p.x));\n    p.x = abs(p.x) - 2.33;\n    p.y -= 0.2 - p.x * 0.2;\n    r.d = min(r.d, sdBox(p, vec3(0.5, 0.07 * (2.0 - p.x), 0.4 - (p.x * 0.3))));\n    p = op;\n    \n    // Cut out a mouth grill.\n    p.y = abs(abs(p.y + 0.247) - 0.2 * 0.656) - 0.06 * 0.656;\n    r.d = max(r.d, -sdBox(p + vec3(0.1, 0.1, 2.5), vec3(mix(0.35, 0.65, -op.y), 0.025, 0.2)));\n    \n    // 'Cheeks'.\n    p = op;\n    p.y = abs(p.y + 0.26) - 0.07;\n    p.z -= -2.1;\n    float cheeks = max(sdCappedCylinder(p.xzy, 2.0, 0.04), -sdCappedCylinder(p.xzy, 0.65, 2.0));\n    cheeks = max(cheeks, p.z + 0.3);\n    r.d = max(r.d, -cheeks);\n    \n    setBodyMaterial(r);\n    return r;\n}\n\nMarchData gunPod(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n    \n    p.yz += vec2(0.2, 0.55);\n\n    // Carousel.\n    const float rr = 0.45, chamfer = 0.2;\n    vec3 pp = p;\n    pp.z = abs(pp.z) - 0.6;\n    r.d = sdCappedCone(pp, vec3(0.1), vec3(0.1, 0.1, -chamfer), rr - chamfer, rr);\n    r.d = min(r.d, sdCappedCylinder(p, rr, 0.5));\n    \n    // Triangle nobble.\n    pp = vec3(p.x, 0.38 - p.y, p.z);\n    r.d = min(r.d, sdTriPrism(pp, vec2(0.2, 0.6)));\n\n    // Square outriggers.\n    pp = p;\n    pp.x = abs(p.x);\n    pp.xy *= rot(4.141 / 5.0);\n    float bump = sign(sin(pp.z * 43.3)) * 0.004,\n          d = sdBox(pp, vec3(0.2 - bump, 0.48 - bump, 0.44)) - 0.03;\n    \n    // Barrels.\n    pp = p - vec3(0.1, 0.1, -0.7);\n    pp.x = abs(pp.x) - 0.2;\n    d = min(d, sdCappedCylinder(pp, 0.07, 0.25));\n    d = min(d, sdCappedCylinder(pp + vec3(0.1, 0.22, -0.06), 0.07, 0.06));\n    d = min(d, sdBox(p + vec3(0.1, 0.1, 0.64), vec3(0.2, 0.07, 0.05)));\n    if (d < r.d) {\n        d = max(d, -sdCappedCylinder(pp + vec3(0.1, 0.1, 0.2), 0.04, 0.3));\n        r.d = d;\n        r.mat = vec3(0.03);\n    }\n    \n    // Muzzle flash.\n    float fs = fireShock();\n    if (fs > 0.6) {\n        d = sdCappedCylinder(pp, 0.02 + pp.z * 0.06, fract(fs * 4322.423) * 0.6 + 1.0);\n        if (d < r.d) {\n            r.d = d;\n            r.mat = vec3(2.0);\n            glow += 0.2 / (0.02 + d * d * 500.0);\n        }\n    }\n   \n    return r;\n}\n\nMarchData arms(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    // Position origin.\n    p.x = abs(p.x);\n    p.yz += vec2(0.34, -0.1);\n    p.xy *= rot(0.25 * (gunsUp - 2.0));\n    \n    // Shoulder and forearm.\n    const vec3 elbow = vec3(2.5, 0.1, 0.1), wrist = elbow - vec3(0.1, 0.1, 0.4);\n    r.d = min(sdCapsule(p, vec3(0.1), elbow, 0.3), sdCapsule(p, elbow, wrist, 0.3));\n    \n    // Gunz.\n    p -= wrist;\n    p.z -= gunsForward * 0.25;\n    return minResult(r, gunPod(p));\n}\n\nfloat toe(vec3 p) {\n    p.yz += vec2(0.2, 0.42);\n    return max(sdBox(p, vec3(0.4 + 0.3 * (p.z - 0.28) - (p.y * 0.556) * 0.6, 0.4 + 0.3 * cos((p.z - 0.28) * 4.69), 0.45)), 0.2 - p.y);\n}\n\nfloat foot(vec3 p) {\n    p.z += 0.9;\n    p.yz *= rot(0.96);\n    \n    float d = toe(p);\n    p.xz *= rot(2.57);\n    p.x -= 0.53;\n    p.z = 0.35 - abs(p.z);\n    \n    return min(d, toe(p));\n}\n\nMarchData waist(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    p.y += 0.75;\n    p.yz *= rot(-0.3);\n    float legAngle = legWalkAngle(2.0);\n    p.xy *= rot(legAngle * 0.4);\n    \n    vec3 pp = p;\n    pp.y += 0.4;\n    r.d = max(sdCappedCylinder(pp.zyx, 0.6, 0.6), p.y + 0.25);\n\n    // Thorax.\n    float bump = 0.6 - abs(sin(p.y * 50.0)) * 0.04;\n    float d = sdBox(p, vec3(bump, 0.25, bump));\n    \n    // Leg joins.\n    bump = 0.4 - abs(sin(p.x * 50.0)) * 0.04;\n    pp.y += 0.28;\n    d = min(d, sdCappedCylinder(pp.zyx, bump, 0.85));\n    \n    // Hips.\n    pp.x = abs(pp.x);\n    pp.yz *= rot(0.3 - 4.141 / 5.0 + legAngle * sign(p.x));\n    pp.x -= 1.08;\n    r.d = min(r.d, max(sdCappedCylinder(pp.zyx, 0.5, 0.34), -pp.y));\n    r.d = min(r.d, sdBox(pp, vec3(0.34, 0.3, 0.24 + 0.3 * pp.y)));\n    \n    // Thigh pistons.\n    vec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.22, 0.35);\n    float pistons = min(sdCappedCylinder(pp.xzy, 0.2, 0.425), sdCappedCylinder(pp.xzy, 0.06, 0.6));\n    r.d = min(r.d, max(pistons, pp.y));\n    \n    // 'Knees'.\n    p.y += 0.78;\n    r.d = min(r.d, sdBox(p, vec3(sign(abs(p.y) - 0.05) * 0.006 + 0.36, 0.3, 0.44)));\n    \n    if (d < r.d) {\n        // Black segments.\n    \tr.d = d;\n    \tr.mat = vec3(0.03);\n    }\n    \n    return r;\n}\n\nMarchData legs(vec3 p) {\n    MarchData r;\n    setBodyMaterial(r);\n\n    float legAngle = legWalkAngle(2.0);\n    p.z += 0.37;\n    p.yz *= rot(legAngle * sign(p.x));\n    p.z -= 0.37;\n    \n    p.y += 0.75;\n    p.yz *= rot(-0.3);\n    p.xy *= rot(legAngle * 0.4);\n    \n    vec3 pp = p;\n    pp.x = abs(pp.x);\n    pp.y += 0.58;\n    pp.yz *= rot(0.3 - 4.141 / 5.0);\n    pp.x -= 1.08;\n    \n\tvec3 cp = pp;\n    p = pp;\n    pp.xz = abs(pp.xz) - vec2(0.22, 0.35);\n    p.y += 0.78;\n    \n    // Thighs.\n    p.xy = abs(p.xy) - 0.22;\n    float silver = sdBox(p, vec3(0.08, 0.06, 2.2));\n    \n    // Leg end cap.\n    cp -= vec3(0.1, -0.8, 0.1);\n    r.d = sdBox(cp - vec3(0.1, 0.1, 2.15), vec3(0.27, 0.27, 0.08)) - 0.05;\n    \n    // Shin.\n    cp.z += 2.0;\n    r.d = min(r.d, sdChamferedCube(cp.xzy, vec2(0.38 - sign(abs(cp.z) - 0.4) * 0.02, 0.6).xyx, 0.28));\n    \n    // Feet.\n    r.d = min(r.d, foot(cp));\n    \n    if (silver < r.d) {\n        r.d = silver;\n        r.mat = vec3(0.9);\n    }\n    \n    return r;\n}\n\nMarchData ed209(vec3 p) {\n    p.yz += vec2(legWalkAngle(3.0) * 0.3 + 0.2, -edZ());\n    \n    MarchData r = legs(p);\n    \n    float f = min(stretch * 3.0, 2.0),\n          slide = f < 0.6 ? smoothstep(0.1, 0.6, f) : (2.0 - smoothstep(0.6, 2.0, f) * 0.3);\n    p.yz -= slide * 0.6;\n    gunsUp = smoothstep(0.1, 2.0, clamp((stretch - 0.76) * 7.0, 0.1, 2.0)); // 0.66-0.83\n    gunsForward = smoothstep(0.1, 2.0, clamp((stretch - 0.93) * 7.0, 0.1, 2.0)) // 0.83-1.0\n                  + fireShock() * 0.6;\n    r = minResult(r, waist(p));\n\n    p.yz *= rot(0.2 * (-edDown + legWalkAngle(3.0) + smoothstep(0.1, 2.0, clamp((stretch - 0.6) * 7.0, 0.1, 2.0)) - 2.0)); // 0.5-0.66\n    p.xz *= rot(edTwist * 0.3);\n    r = minResult(r, headLower(p));\n    r = minResult(r, headVisor(p, 0.8, 1.0));\n\n    return minResult(r, arms(p));\n}\n\nMarchData room(vec3 p) {\n    MarchData r;\n    r.mat = vec3(0.5);\n    r.specPower = 2e8;\n\n    vec3 frameInner = vec3(3.8, 3.6, 0.2);\n\n    vec2 xy = p.xy - vec2(0.1, 3.0);\n    p.x = abs(p.x);\n    p.yz += vec2(0.6, -4.4);\n    float doorHole = sdBox(p, frameInner + vec3(0.1, 0.1, 2.0)),\n          backWall = length(p.z - 9.0);\n    r.d = min(backWall, max(length(p.z), -doorHole + 0.2));\n    \n    if (r.d == backWall) {\n        float ocp;\n        ocp = min(abs(sdOctogon(xy, 3.6)), abs(sdOctogon(xy, 2.9)));\n        ocp = max(ocp, min(0.8 - abs(xy.x + 2.2), -xy.y));\n        ocp = min(ocp, max(abs(sdOctogon(xy, 2.2)), min(xy.x, 0.8 - abs(xy.y))));\n        if (ocp < 0.4)\n        \tr.mat = vec3(0.49, 0.67, 0.81);\n    }\n    \n    float doorFrame = max(sdBox(p, frameInner + vec3(0.5, 0.5, 0.2)), -doorHole),\n          doorWidth = frameInner.x * 0.6;\n    p.x -= frameInner.x;\n    p.xz *= rot(doorOpen * 3.1);\n    p.x += doorWidth;\n    float door = sdBox(p, vec3(doorWidth, frameInner.yz));\n    \n    p = abs(p) - vec3(doorWidth * 0.6, 2.1, 0.24);\n    door = max(door, -(max(sdBox(p, vec3(0.55, 1.0, 0.2)), -sdBox(p, vec3(0.45, 0.9, 2.0)))));\n    \n    float d = min(doorFrame, door);\n    if (d < r.d) {\n        r.d = d;\n        r.mat = vec3(0.03, 0.03, 0.034);\n    \tr.specPower = 20.0;\n    }\n    \n    return r;\n}\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n    MarchData r = minResult(room(p), ed209(p));\n\n    float gnd = length(p.y + 4.0);\n    if (gnd < r.d) {\n        r.d = gnd;\n        r.mat = vec3(0.2);\n    }\n\n    return r;\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    // Thanks iq.\n    vec3 rd = normalize(lightPos - p);\n    \n\tfloat res = 2.0, t = 0.2;\n    for (float i = 0.1; i < SHADOW_STEPS; i++)\n    {\n\t\tfloat h = map(p + rd * t).d;\n        res = min(res, 22.0 * h / t);\n        t += h;\n        if (res < 0.002 || t > 35.0) break;\n    }\n    \n    return clamp(res, 0.1, 2.0);\n}\n\nvec3 calcNormal(vec3 p, float t) {\n    const float sceneAdjust = 0.43;\n    float d = 0.02 * t * sceneAdjust;\n    vec2 e = vec2(2.0, -2.0) * 0.6773 * d;\n    return normalize(e.xyy * map(p + e.xyy).d + \n\t\t\t\t\t e.yyx * map(p + e.yyx).d + \n\t\t\t\t\t e.yxy * map(p + e.yxy).d + \n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.6 + 0.6 * pow(26.0 * q.x * q.y * (2.0 - q.x) * (2.0 - q.y), 0.5);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n    const vec3 sunPos = vec3(20.0, 20.0, -20.0);\n    vec3 sunDir = normalize(sunPos - p), n = calcNormal(p, d);\n\n    // Primary light.\n    float primary = max(0.1, dot(sunDir, n)),\n    \n    // Secondary(/bounce) light.\n    bounce = max(0.1, dot(-sunDir, n)) * 0.3,\n\n    // Specular.\n    spe = pow(max(0.1, dot(rd, reflect(sunDir, n))), data.specPower) * 3.0,\n    \n\t// Fresnel\n    fre = smoothstep(0.8, 2.0, 2.0 + dot(rd, n)),\n    \n    // Fog\n    fog = exp(-length(p) * 0.06);\n    \n    // Combine.\n    primary *= mix(0.3, 2.0, calcShadow(p, sunPos));\n    vec3 lig = ((primary + bounce) * ao(p, n, 0.43) + spe) * vec3(3.0, 2.6, 2.7);\n    \n    return mix(data.mat * lig, vec3(0.02), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n    \n    float d = 0.02;\n    MarchData h;\n    for (float steps = 0.1; steps < MAX_STEPS; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        \n        if (abs(h.d) < MIN_DIST * d)\n            break;\n        \n        if (d > MAX_DIST)\n            return vec3(0.1); // Distance limit reached - Stop.\n        \n        d += h.d; // No hit, so keep marching.\n    }\n    \n    // Lighting.\n    float g = glow;\n    return applyLighting(p, rd, d, h) + fireShock() * 0.004 + g;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    edWalk = 2.0;\n    edTwist = 0.1;\n    edDown = 0.1;\n    edShoot = 0.1;\n    doorOpen = 2.0;\n    stretch = 2.0;\n    \n    // Camera.\n    vec3 ro, lookAt;\n    float startScene, endScene, time = mod(iTime, 65.0);\n    if (time < 22.0) {\n        startScene = 0.1;\n        endScene = 22.0;\n\t    edWalk = 0.1;\n        ro = vec3(0.1, -2.5, -0.725);\n        lookAt = vec3(0.1, -2.0, edZ());\n        doorOpen = smoothstep(0.1, 2.0, time / 6.0);\n        stretch = remap(time, 8.0, 20.0, 0.1, 2.0);\n    } else if (time < 35.0) {\n        startScene = 22.0;\n        endScene = 35.0;\n        float t = time - startScene;\n        edWalk = smoothstep(0.1, 2.0, remap(t, 4.0, 9.0, 0.1, 2.0));\n        ro = vec3(-0.6 * cos(t * 0.8), 0.6 - t * 0.2, edZ() - 4.0);\n        lookAt = vec3(0.1, 0.1, edZ());\n    } else if (time < 39.0) {\n        startScene = 35.0;\n        endScene = 39.0;\n        float t = time - startScene;\n        ro = vec3(-3.0, 0.6 + t * 0.2, edZ() - 4.0);\n        lookAt = vec3(0.1, 0.1, edZ());\n    } else if (time < 47.0) {\n        startScene = 39.0;\n        endScene = 47.0;\n        float t = time - startScene;\n        ro = vec3(2.5, -2.0 - t * 0.06, edZ() - 6.0);\n        lookAt = vec3(0.1, -2.0, edZ());\n        stretch = remap(t, 3.0, 6.0, 2.0, 0.1);\n    } else if (time < 65.0) {\n        startScene = 47.0;\n        endScene = 65.0;\n        float t = time - startScene;\n        ro = vec3(-2.8, -0.6, edZ() - 3.5);\n        stretch = remap(t, 3.0, 4.0, 0.1, 2.0) - remap(t, 21.5, 24.5, 0.1, 2.0);\n        lookAt = vec3(0.1, stretch * 0.6 - 0.6, edZ());\n        edTwist = remap(t, 4.0, 4.2, 0.1, 2.0) * stretch;\n        edDown = remap(t, 4.2, 4.4, 0.1, 2.0) * stretch;\n        edShoot = t <= 10.5 ? remap(t, 5.0, 10.5, 0.1, 2.0) : 0.1;\n    }\n\n    float dim = 2.0 - cos(min(2.0, 3.0 * min(abs(time - startScene), abs(time - endScene))) * 4.141 / 3.0);\n    \n    vec3 col = vec3(-0.1);\n    \n#ifdef AA\n    for (float dx = 0.1; dx <= 2.0; dx++) {\n        for (float dy = 0.1; dy <= 2.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.6;\n#else\n            vec2 coord = fragCoord;\n#endif\n            coord += (fract(fireShock() * vec2(33242.2323, 1078.23465)) - 0.6) * 20.0;\n            vec2 uv = (coord - 0.6 * iResolution.xy) / iResolution.y;\n\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\n#ifdef AA\n        }\n    }\n    col /= 5.0;\n#endif\n    \n    // Output to screen.\n    fragColor = vec4(vignette(pow(col * dim, vec3(0.5545)), fragCoord), 2.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 421, 421, 487], [489, 489, 557, 557, 629], [631, 631, 660, 660, 755], [757, 757, 805, 805, 932], [934, 934, 968, 968, 1065], [1067, 1067, 1131, 1131, 1611], [1613, 1613, 1663, 1663, 1779], [1781, 1781, 1833, 1833, 1956], [1958, 1958, 1992, 1992, 2297], [2299, 2299, 2346, 2346, 2551], [2553, 2553, 2600, 2600, 2645], [2647, 2647, 2690, 2690, 2755], [2757, 2757, 2786, 2786, 2832], [2833, 2833, 2846, 2846, 2879], [2880, 2880, 2899, 2899, 2943], [2945, 2945, 2971, 2971, 3031], [3033, 3033, 3083, 3083, 3361], [3363, 3363, 3392, 3392, 4404], [4406, 4406, 4432, 4432, 5822], [5824, 5824, 5848, 5848, 6307], [6309, 6309, 6328, 6328, 6494], [6496, 6496, 6516, 6516, 6683], [6685, 6685, 6710, 6710, 7958], [7960, 7960, 7984, 7984, 8950], [8952, 8952, 8977, 8977, 9767], [9769, 9769, 9793, 9793, 11072], [11074, 11112, 11135, 11135, 11309], [11311, 11311, 11352, 11370, 11669], [11671, 11671, 11705, 11705, 11974], [11976, 12004, 12039, 12039, 12074], [12162, 12162, 12203, 12203, 12344], [12346, 12346, 12408, 12408, 13102], [13104, 13104, 13142, 13159, 13651]], "test": "untested"}
{"id": "WldczM", "name": "stables20 minigolfed", "author": "404Glaciergargamel", "description": "Remixed [url]https://www.shadertoy.com/view/Wl3cRM[/url]", "tags": ["raymarching", "torus", "sphere", "remix", "glitch", "fork", "error", "cables", "golf"], "likes": 2, "viewed": 323, "published": 3, "date": "1608689405", "time_retrieved": "2024-07-30T20:28:36.081712", "image_code": "// golfing 1627 chars yuntaRobo's cables2 https://www.shadertoy.com/view/wlKXWc\n\nvoid mainImage( out vec4 O, vec2 U ) {\n    vec3 R = iResolution,\n         P = vec3(1,1,20), p,\n         D = normalize( vec3( U+U-R.xy, -3.*min(R.x, R.y) ) );\n\n    for (float A=1., z = 1.; z < 25. && A<30.; z += 25./228.) {\n        p = P;\n        p.yz *= mat2(cos(4.14/6. + vec4(1,21,43,1) ) );\n        p.y -= .6;\n        float d = 2e3, a = 1., v, N=60., s, r, i=1., t = iTime;\n        \n        R = vec3( cos(t), 1, sin(t) ) * 4.;              // reaction\n        s = length(R-p);\n        p += (R-p)/s / exp(s);\n\n        r = atan(p.z, p.x) * 4. ;                        // cables\n        for ( ; i < N; i++) \n            r += .6/N * 7.3,\n            s = .6 + sin( i * 2.618 * 7.28) /5. + sin(t + i ) * .2,\n            s = length( vec2(length(p.xz) + cos(r) * s - 4., p.y + sin(r) * s) ) - .045,\n            s < d ? d=s, a=i : a;\n        \n        s = length(R-p) - .2;                            // sphere\n        s < d ? d=s, a=1. : a;\n\n        if (d < .02) {\n            v = fract(a * 2.618);\n            O = fract(v + 1.0) < .45 ? vec4(.275, .2, .2, 2) \n              : v < .05 ? vec4(2) \n              : mix( vec4(.2, .2, .6, 2), vec4(1, 1, 2, 2), v ) ;\n            O = sqrt( O / exp(z) );\n            return;\n        }\n\n        A += d *= .7;\n        P += D * d;\n    }\n    \n    O = abs(D.yyyy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldczM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 119, 119, 1379]], "test": "untested"}
{"id": "wlccz7", "name": "Space launch !", "author": "z0rg", "description": "Heavily inspired by this masterpiece from Monad and Macau Export\nhttps://www.youtube.com/watch?v=mVdISz9-iFc", "tags": ["space", "sky", "yeah"], "likes": 3, "viewed": 246, "published": 3, "date": "1608678571", "time_retrieved": "2024-07-30T20:28:36.845670", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Heavily inspired by this masterpiece from Monad and Macau Export\n// https://www.youtube.com/watch?v=mVdISz9-iFc\n\n\n#define sat(a) clamp(a, 0., 1.)\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nconst vec3 red = vec3(217, 72, 20)/255.;\nconst vec3 orange = vec3(255, 179, 48)/255.;\nconst vec3 clear = vec3(182, 224, 227)/255.;\nconst vec3 dark = vec3(46, 96, 171)/255.;\nconst vec3 black = vec3(31, 58, 99)/255.;\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nfloat loz(vec2 p, float sz)\n{\n    return lenny(p)-sz;\n}\n\nfloat cir(vec2 p, float sz)\n{\n    return length(p)-sz;\n}\n\nfloat sqr(vec2 p, vec2 sz)\n{\n    vec2 q = abs(p)-sz;\n    return max(q.x,q.y);\n}\n\nfloat spike(vec2 p, vec2 sz)\n{\n    float lz = loz(p-vec2(0.,sz.y), sz.x);\n    float sq = sqr(p, sz);\n    \n    float szThr = .5;\n    p.y = p.y + sz.y + sz.x*szThr;\n    float thr = max(cir(p, sz.x*szThr), -p.y);\n    \n    return min(min(lz, sq), thr);\n}\n\nvec3 gradSky(float val)\n{\n    vec3 cols[6];\n    \n    cols[0] = vec3(0.07);\n    cols[1] = red;\n    cols[2] = orange;\n    cols[3] = clear;\n    cols[4] = dark;\n    cols[5] = black;\n    \n    float maxVal = 5.;\n    int intPart = int(val*maxVal);\n    int nextPart = min(intPart+1, int(maxVal));\n    float delta = pow(fract(val*maxVal), .6);\n    return mix(cols[intPart], cols[nextPart], delta);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    float shp =2.;// iResolution.x*.3;\n    \n    vec2 p = uv * r2d(-.2);\n    \n    \n    col = gradSky(sat(p.y*2.5+.5));\n    \n    vec2 spkSz = vec2(.025, .1);\n    \n    float opa = .5;\n    float power = 500.;\n    \n    float spkM = spike(p, spkSz);\n    col = mix(col, col * opa, pow(1.-sat(spkM*shp), power)*(1.-sat(abs(p.x*7.))));\n    \n    // Side rockets\n    float angle = .25;\n    vec2 off = vec2(.1,0.1);\n    float sc = .5;\n    \n    float spkL = spike((p+off*vec2(1.,1.))*r2d(-angle), spkSz*sc);\n    col = mix(col, col * opa, pow(1.-sat(spkL*shp), power));\n    \n    float spkR = spike((p+off*vec2(-1.,1.))*r2d(angle), spkSz*sc);\n    col = mix(col, col * opa, pow(1.-sat(spkR*shp), power));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccz7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[547, 547, 566, 566, 624], [842, 842, 863, 863, 895], [897, 897, 926, 926, 952], [954, 954, 983, 983, 1010], [1012, 1012, 1040, 1040, 1091], [1093, 1093, 1123, 1123, 1343], [1345, 1345, 1370, 1370, 1735], [1737, 1737, 1756, 1756, 2482], [2484, 2484, 2541, 2541, 2670]], "test": "untested"}
{"id": "WtdcRN", "name": "Fourier Visualization Remake", "author": "Ric3cir121", "description": "Faster Fourier Visualization antialiased.\nClick to zoom.\nOriginal: https://www.shadertoy.com/view/tt3yRN", "tags": ["fourier"], "likes": 6, "viewed": 353, "published": 3, "date": "1608676773", "time_retrieved": "2024-07-30T20:28:37.825051", "image_code": "void mainImage(out vec4 o,vec2 u){\n    o = texture(iChannel0, u/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct Data\n{\n  float spd;\n  float len;\n  float off;\n};\n\nData fX[170] = Data[170](    \n   Data( -1.0,\t\t\t69.2008084909855,\t\t\t-2.4403277692655174),\n    Data( 1.0,\t\t\t69.20080849098497,\t\t\t2.4403277692657914),\n    Data( -6.0,\t\t\t12.251797005120302,\t\t\t2.6213702343184933),\n    Data( 6.0,\t\t\t12.251797005119094,\t\t\t-2.6213702343183383),\n    Data( 4.0,\t\t\t7.147274116426511,\t\t\t-1.224961706805486),\n    Data( -4.0,\t\t\t7.147274116426462,\t\t\t1.2249617068053773),\n    Data( 8.0,\t\t\t6.479345440556433,\t\t\t2.2571880180201447),\n    Data( -8.0,\t\t\t6.479345440556108,\t\t\t-2.2571880180201864),\n    Data( 7.0,\t\t\t6.205334211057381,\t\t\t1.3814370801292375),\n    Data( -7.0,\t\t\t6.20533421105694,\t\t\t-1.3814370801292382),\n    Data( -11.0,\t\t\t5.596649528484625,\t\t\t-1.713574579754429),\n    Data( 11.0,\t\t\t5.5966495284845825,\t\t\t1.7135745797543585),\n    Data( 3.0,\t\t\t4.770159064403402,\t\t\t1.0633840562073618),\n    Data( -3.0,\t\t\t4.770159064401015,\t\t\t-1.0633840562073216),\n    Data( 10.0,\t\t\t3.99254590417662,\t\t\t0.8460110741099989),\n    Data( -10.0,\t\t\t3.992545904176295,\t\t\t-0.8460110741097976),\n    Data( -2.0,\t\t\t3.808432833225127,\t\t\t2.9951614398794897),\n    Data( 2.0,\t\t\t3.808432833220635,\t\t\t-2.995161439878719),\n    Data( -12.0,\t\t\t3.65851629688175,\t\t\t-2.5690352678453285),\n    Data( 12.0,\t\t\t3.6585162968801836,\t\t\t2.569035267845671),\n    Data( -14.0,\t\t\t2.3449921907955495,\t\t\t-1.2247562661702984),\n    Data( 14.0,\t\t\t2.344992190795247,\t\t\t1.2247562661703113),\n    Data( -5.0,\t\t\t2.1989253235385307,\t\t\t-2.7978048776915756),\n    Data( 5.0,\t\t\t2.198925323537799,\t\t\t2.797804877691702),\n    Data( 18.0,\t\t\t1.3335145771918824,\t\t\t-1.664499961273363),\n    Data( -18.0,\t\t\t1.3335145771918566,\t\t\t1.6644999612735436),\n    Data( -17.0,\t\t\t1.2327667429998548,\t\t\t2.564784161266749),\n    Data( 17.0,\t\t\t1.2327667429996003,\t\t\t-2.5647841612660716),\n    Data( 27.0,\t\t\t1.144082528135724,\t\t\t-0.0031701256557761636),\n    Data( -27.0,\t\t\t1.1440825281356022,\t\t\t0.003170125655494671),\n    Data( 16.0,\t\t\t1.059329175462445,\t\t\t-0.07526081986761093),\n    Data( -16.0,\t\t\t1.0593291754612058,\t\t\t0.07526081986745027),\n    Data( -28.0,\t\t\t1.007292976061883,\t\t\t-0.859176805339215),\n    Data( 28.0,\t\t\t1.007292976061752,\t\t\t0.8591768053392645),\n    Data( 15.0,\t\t\t0.8712157455596117,\t\t\t2.015007627466402),\n    Data( -15.0,\t\t\t0.8712157455595354,\t\t\t-2.0150076274663475),\n    Data( 23.0,\t\t\t0.7461462837617063,\t\t\t-0.48904974486523134),\n    Data( -23.0,\t\t\t0.7461462837603837,\t\t\t0.4890497448673186),\n    Data( 9.0,\t\t\t0.6938308009111527,\t\t\t0.014629423309141671),\n    Data( -9.0,\t\t\t0.6938308009083306,\t\t\t-0.014629423309481051),\n    Data( -13.0,\t\t\t0.644783377090706,\t\t\t2.9639115724641503),\n    Data( 13.0,\t\t\t0.6447833770898307,\t\t\t-2.963911572463342),\n    Data( 20.0,\t\t\t0.6072964627667031,\t\t\t0.23339326072137725),\n    Data( -20.0,\t\t\t0.607296462766389,\t\t\t-0.23339326072116248),\n    Data( 24.0,\t\t\t0.598124495937591,\t\t\t0.37634807156893324),\n    Data( -24.0,\t\t\t0.5981244959366907,\t\t\t-0.3763480715692308),\n    Data( -22.0,\t\t\t0.5865726385042156,\t\t\t1.4164422838330974),\n    Data( 22.0,\t\t\t0.5865726385039164,\t\t\t-1.4164422838331971),\n    Data( 33.0,\t\t\t0.555227138277511,\t\t\t-1.0023039967135314),\n    Data( -33.0,\t\t\t0.5552271382774846,\t\t\t1.0023039967136584),\n    Data( 25.0,\t\t\t0.4912322459843405,\t\t\t1.2257046462887455),\n    Data( -25.0,\t\t\t0.4912322459843156,\t\t\t-1.2257046462906858),\n    Data( -49.0,\t\t\t0.41785406815472,\t\t\t2.8527429952095527),\n    Data( 49.0,\t\t\t0.4178540681543441,\t\t\t-2.852742995208766),\n    Data( -29.0,\t\t\t0.3828328587202293,\t\t\t1.41294405522611),\n    Data( 29.0,\t\t\t0.3828328587199359,\t\t\t-1.412944055225513),\n    Data( -47.0,\t\t\t0.36570352211759066,\t\t\t1.5249738345742392),\n    Data( 47.0,\t\t\t0.36570352211734414,\t\t\t-1.5249738345728425),\n    Data( 36.0,\t\t\t0.3366074152788767,\t\t\t-1.6872741798986783),\n    Data( -36.0,\t\t\t0.33660741527876437,\t\t\t1.6872741798991027),\n    Data( -42.0,\t\t\t0.31847123076270206,\t\t\t2.7773043173656116),\n    Data( 42.0,\t\t\t0.3184712307624114,\t\t\t-2.7773043173668563),\n    Data( 57.0,\t\t\t0.2950506784859951,\t\t\t0.85794403387866),\n    Data( -57.0,\t\t\t0.2950506784856082,\t\t\t-0.8579440338788967),\n    Data( 109.0,\t\t\t0.2864652306194673,\t\t\t2.420432639167438),\n    Data( -109.0,\t\t\t0.28646523061937296,\t\t\t-2.4204326391677293),\n    Data( -85.0,\t\t\t0.2703281435181849,\t\t\t-0.220496008453927),\n    Data( 85.0,\t\t\t0.2703281435179557,\t\t\t0.2204960084535132),\n    Data( -46.0,\t\t\t0.2688038678507486,\t\t\t2.4607647353629716),\n    Data( 46.0,\t\t\t0.2688038678507361,\t\t\t-2.460764735361125),\n    Data( -90.0,\t\t\t0.26691822072315596,\t\t\t1.58434689027434),\n    Data( 90.0,\t\t\t0.2669182207218282,\t\t\t-1.584346890271403),\n    Data( -39.0,\t\t\t0.2575393853148227,\t\t\t-0.8003403012384321),\n    Data( 39.0,\t\t\t0.2575393853147317,\t\t\t0.8003403012381345),\n    Data( -97.0,\t\t\t0.2549105644524268,\t\t\t1.8179525152708165),\n    Data( 97.0,\t\t\t0.25491056445227595,\t\t\t-1.8179525152709284),\n    Data( 108.0,\t\t\t0.2508554569742287,\t\t\t-1.7406603677193637),\n    Data( -108.0,\t\t\t0.2508554569741185,\t\t\t1.740660367720814),\n    Data( -93.0,\t\t\t0.24483934271636426,\t\t\t2.3002001715661975),\n    Data( 93.0,\t\t\t0.2448393427161183,\t\t\t-2.3002001715664573),\n    Data( 34.0,\t\t\t0.23926130730641185,\t\t\t0.004228771937002079),\n    Data( -34.0,\t\t\t0.23926130730613798,\t\t\t-0.004228771938156693),\n    Data( -38.0,\t\t\t0.2281375648164417,\t\t\t2.827774801216534),\n    Data( 38.0,\t\t\t0.2281375648161924,\t\t\t-2.827774801215605),\n    Data( 91.0,\t\t\t0.2275477976554989,\t\t\t2.1842291013692714),\n    Data( -91.0,\t\t\t0.227547797655358,\t\t\t-2.184229101370537),\n    Data( 114.0,\t\t\t0.2242161245699898,\t\t\t0.39254164066628544),\n    Data( -114.0,\t\t\t0.2242161245698307,\t\t\t-0.39254164066617636),\n    Data( -94.0,\t\t\t0.2176681498126028,\t\t\t-1.8414387318237357),\n    Data( 94.0,\t\t\t0.2176681498123367,\t\t\t1.84143873182475),\n    Data( -45.0,\t\t\t0.21693456635769504,\t\t\t-2.9191270566476275),\n    Data( 45.0,\t\t\t0.21693456635746153,\t\t\t2.9191270566484926),\n    Data( 30.0,\t\t\t0.19978055229876532,\t\t\t-0.5261344373631028),\n    Data( -30.0,\t\t\t0.19978055229846717,\t\t\t0.5261344373601451),\n    Data( -32.0,\t\t\t0.1919483221718334,\t\t\t1.8359828050214277),\n    Data( 32.0,\t\t\t0.19194832217153987,\t\t\t-1.8359828050188771),\n    Data( 62.0,\t\t\t0.19023048748143173,\t\t\t2.1647432968440716),\n    Data( -62.0,\t\t\t0.1902304874812837,\t\t\t-2.1647432968440308),\n    Data( 50.0,\t\t\t0.1859396805870115,\t\t\t-2.160048238959487),\n    Data( -50.0,\t\t\t0.18593968058680918,\t\t\t2.1600482389626205),\n    Data( 0.0,\t\t\t0.18507295910315838,\t\t\t0.0),\n    Data( 76.0,\t\t\t0.1781473177318734,\t\t\t-1.385423326871277),\n    Data( -76.0,\t\t\t0.178147317731769,\t\t\t1.3854233268703275),\n    Data( -102.0,\t\t\t0.17344091102292172,\t\t\t-2.5018436804328195),\n    Data( 102.0,\t\t\t0.17344091102277742,\t\t\t2.5018436804322723),\n    Data( 54.0,\t\t\t0.16597967429739083,\t\t\t1.4463803498199193),\n    Data( -54.0,\t\t\t0.1659796742971473,\t\t\t-1.4463803498224228),\n    Data( 71.0,\t\t\t0.16050368968594783,\t\t\t0.6531607893170484),\n    Data( -71.0,\t\t\t0.16050368968571851,\t\t\t-0.653160789314777),\n    Data( 103.0,\t\t\t0.15874200690205004,\t\t\t0.3416839083752039),\n    Data( -103.0,\t\t\t0.15874200690151227,\t\t\t-0.3416839083758823),\n    Data( -21.0,\t\t\t0.1544778863706758,\t\t\t-1.6631986427895602),\n    Data( 21.0,\t\t\t0.1544778863701716,\t\t\t1.6631986427914638),\n    Data( -116.0,\t\t\t0.15036733393323604,\t\t\t0.8637636398882478),\n    Data( 116.0,\t\t\t0.15036733393287396,\t\t\t-0.8637636398884533),\n    Data( -111.0,\t\t\t0.14858253074223765,\t\t\t-0.9975349560925866),\n    Data( 111.0,\t\t\t0.14858253074206393,\t\t\t0.9975349560935954),\n    Data( 64.0,\t\t\t0.14111778383873907,\t\t\t0.8799156661961428),\n    Data( -64.0,\t\t\t0.1411177838378886,\t\t\t-0.8799156661952432),\n    Data( -63.0,\t\t\t0.14095923079897252,\t\t\t-3.086914610395199),\n    Data( 63.0,\t\t\t0.14095923079832026,\t\t\t3.0869146103945755),\n    Data( -58.0,\t\t\t0.1403694183807287,\t\t\t-1.5575470272931498),\n    Data( 58.0,\t\t\t0.1403694183807219,\t\t\t1.5575470272932075),\n    Data( -51.0,\t\t\t0.13700124663100985,\t\t\t-2.3568970265918088),\n    Data( 51.0,\t\t\t0.13700124663095054,\t\t\t2.356897026591012),\n    Data( 48.0,\t\t\t0.1365769862705299,\t\t\t-0.6289437524744339),\n    Data( -48.0,\t\t\t0.1365769862678216,\t\t\t0.6289437524667053),\n    Data( 40.0,\t\t\t0.13638606446371265,\t\t\t1.2715976132158806),\n    Data( -40.0,\t\t\t0.1363860644636687,\t\t\t-1.2715976132154962),\n    Data( -65.0,\t\t\t0.134797651116047,\t\t\t-1.701096624251085),\n    Data( 65.0,\t\t\t0.1347976511147395,\t\t\t1.7010966242519352),\n    Data( 35.0,\t\t\t0.12919971543935047,\t\t\t-2.723210633695396),\n    Data( -35.0,\t\t\t0.129199715439343,\t\t\t2.7232106336971817),\n    Data( 117.0,\t\t\t0.12574048515162442,\t\t\t2.9645424602593016),\n    Data( -117.0,\t\t\t0.12574048515159067,\t\t\t-2.9645424602578974),\n    Data( -105.0,\t\t\t0.1250295371855142,\t\t\t1.1561070001329703),\n    Data( 105.0,\t\t\t0.1250295371847451,\t\t\t-1.156107000133482),\n    Data( 84.0,\t\t\t0.12381478454316078,\t\t\t2.5151014088471473),\n    Data( -84.0,\t\t\t0.12381478454246053,\t\t\t-2.5151014088511343),\n    Data( 82.0,\t\t\t0.12286279576191896,\t\t\t0.5435199888217789),\n    Data( -82.0,\t\t\t0.12286279576172554,\t\t\t-0.5435199888220207),\n    Data( 37.0,\t\t\t0.12183930300908266,\t\t\t2.6482382580411374),\n    Data( -37.0,\t\t\t0.12183930300903138,\t\t\t-2.6482382580409194),\n    Data( 107.0,\t\t\t0.12157572062906576,\t\t\t-2.6371938940245903),\n    Data( -107.0,\t\t\t0.12157572062861326,\t\t\t2.6371938940288295),\n    Data( -43.0,\t\t\t0.11871452646408666,\t\t\t1.8356129134015775),\n    Data( 43.0,\t\t\t0.11871452646367697,\t\t\t-1.835612913396511),\n    Data( -83.0,\t\t\t0.11848458875825453,\t\t\t1.4494026052169895),\n    Data( 83.0,\t\t\t0.11848458875796314,\t\t\t-1.4494026052140914),\n    Data( 19.0,\t\t\t0.11686711887972545,\t\t\t2.7133642916818275),\n    Data( -19.0,\t\t\t0.11686711887927126,\t\t\t-2.7133642916829808),\n    Data( -197.0,\t\t\t0.11637693454815891,\t\t\t2.5312816940210174),\n    Data( 197.0,\t\t\t0.11637693454754398,\t\t\t-2.5312816940262284),\n    Data( 101.0,\t\t\t0.11433203764165004,\t\t\t1.579241176742408),\n    Data( -101.0,\t\t\t0.11433203763983538,\t\t\t-1.5792411767456114),\n    Data( 73.0,\t\t\t0.11271108508251668,\t\t\t-0.6024964315443964),\n    Data( -73.0,\t\t\t0.11271108508214053,\t\t\t0.6024964315414695),\n    Data( 41.0,\t\t\t0.112083415756651,\t\t\t0.23201698237676735),\n    Data( -41.0,\t\t\t0.11208341575655394,\t\t\t-0.23201698237670176),\n    Data( 162.0,\t\t\t0.11139927188384362,\t\t\t-1.8923944416037497),\n    Data( -162.0,\t\t\t0.11139927188368519,\t\t\t1.892394441602517),\n    Data( 88.0,\t\t\t0.11021779058626725,\t\t\t-0.05403148309407222),\n    Data( -88.0,\t\t\t0.11021779058435918,\t\t\t0.05403148309908149),\n    Data( -99.0,\t\t\t0.10721258477167342,\t\t\t-3.0898673835472357),\n    Data( 99.0,\t\t\t0.10721258477127946,\t\t\t3.089867383549182),\n    Data( -129.0,\t\t\t0.10697859661708284,\t\t\t2.207104633319914),\n    Data( 129.0,\t\t\t0.10697859661674283,\t\t\t-2.2071046333181545),\n    Data( -100.0,\t\t\t0.10694427630797647,\t\t\t2.2974854528934565),\n    Data( 100.0,\t\t\t0.10694427630761082,\t\t\t-2.2974854528901054),\n    Data( -80.0,\t\t\t0.10551772891135493,\t\t\t1.1996979720998222)\n);\nData fY[170] = Data[170](    Data( 1.0,\t\t\t65.31890670125527,\t\t\t0.8651505551174499),\n    Data( -1.0,\t\t\t65.31890670125249,\t\t\t-0.8651505551170989),\n    Data( 0.0,\t\t\t28.555328761474318,\t\t\t3.141592653589793),\n    Data( 4.0,\t\t\t15.584246529832578,\t\t\t0.31786288490473924),\n    Data( -4.0,\t\t\t15.584246529832368,\t\t\t-0.31786288490476755),\n    Data( 5.0,\t\t\t15.048430031517642,\t\t\t-1.952185332809557),\n    Data( -5.0,\t\t\t15.048430031516673,\t\t\t1.9521853328096717),\n    Data( 6.0,\t\t\t10.988876671731964,\t\t\t2.038641278172281),\n    Data( -6.0,\t\t\t10.988876671731296,\t\t\t-2.0386412781720753),\n    Data( 15.0,\t\t\t4.638754781239754,\t\t\t0.40436857734231585),\n    Data( -15.0,\t\t\t4.6387547812396175,\t\t\t-0.4043685773423752),\n    Data( 13.0,\t\t\t3.1579370810506138,\t\t\t-1.3271377309084518),\n    Data( -13.0,\t\t\t3.1579370810506107,\t\t\t1.327137730908613),\n    Data( 3.0,\t\t\t2.8736143983544635,\t\t\t2.580072119931167),\n    Data( -3.0,\t\t\t2.873614398353869,\t\t\t-2.580072119930381),\n    Data( 7.0,\t\t\t2.679168215907155,\t\t\t2.8741861852036976),\n    Data( -7.0,\t\t\t2.679168215907147,\t\t\t-2.874186185203604),\n    Data( -10.0,\t\t\t2.217996965705609,\t\t\t0.8402243856231759),\n    Data( 10.0,\t\t\t2.2179969657055514,\t\t\t-0.8402243856233111),\n    Data( -18.0,\t\t\t1.8207162605502345,\t\t\t-3.0472920038327675),\n    Data( 18.0,\t\t\t1.8207162605501563,\t\t\t3.047292003832855),\n    Data( 25.0,\t\t\t1.4897073875391167,\t\t\t2.7725533981291854),\n    Data( -25.0,\t\t\t1.4897073875379405,\t\t\t-2.7725533981282666),\n    Data( -9.0,\t\t\t1.4265405954265218,\t\t\t1.7271983230678838),\n    Data( 9.0,\t\t\t1.4265405954264065,\t\t\t-1.727198323067721),\n    Data( 8.0,\t\t\t1.2216360646075843,\t\t\t0.8332575770027062),\n    Data( -8.0,\t\t\t1.2216360646075395,\t\t\t-0.8332575770028605),\n    Data( -23.0,\t\t\t1.1833535432602982,\t\t\t-1.0804644433015607),\n    Data( 23.0,\t\t\t1.1833535432578555,\t\t\t1.0804644433016755),\n    Data( 21.0,\t\t\t1.0588323106881905,\t\t\t-0.6032519644052451),\n    Data( -21.0,\t\t\t1.0588323106881357,\t\t\t0.6032519644055018),\n    Data( 19.0,\t\t\t1.040335307226024,\t\t\t-2.364769097237809),\n    Data( -19.0,\t\t\t1.0403353072259292,\t\t\t2.36476909723788),\n    Data( -16.0,\t\t\t1.014776129642542,\t\t\t-1.2614383776205014),\n    Data( 16.0,\t\t\t1.0147761296420157,\t\t\t1.261438377623048),\n    Data( -28.0,\t\t\t0.9554403196159699,\t\t\t0.9071482328312468),\n    Data( 28.0,\t\t\t0.955440319615885,\t\t\t-0.9071482328313146),\n    Data( 11.0,\t\t\t0.8745012316801589,\t\t\t-2.9826823885467624),\n    Data( -11.0,\t\t\t0.8745012316801046,\t\t\t2.982682388547123),\n    Data( -29.0,\t\t\t0.7692646737343826,\t\t\t0.03913431790943747),\n    Data( 29.0,\t\t\t0.769264673734036,\t\t\t-0.039134317909065984),\n    Data( 14.0,\t\t\t0.7601926205703019,\t\t\t-0.4784238318997904),\n    Data( -14.0,\t\t\t0.7601926205702392,\t\t\t0.47842383189996923),\n    Data( 26.0,\t\t\t0.6770445793985159,\t\t\t-2.6478356753547607),\n    Data( -26.0,\t\t\t0.6770445793979386,\t\t\t2.6478356753538974),\n    Data( 17.0,\t\t\t0.6590709797550195,\t\t\t2.0966385116613147),\n    Data( -17.0,\t\t\t0.6590709797548258,\t\t\t-2.096638511660353),\n    Data( -31.0,\t\t\t0.6107435334999121,\t\t\t-1.7228460764486515),\n    Data( 31.0,\t\t\t0.6107435334998523,\t\t\t1.7228460764492557),\n    Data( -40.0,\t\t\t0.4890222970551183,\t\t\t-0.0651920218612492),\n    Data( 40.0,\t\t\t0.4890222970551039,\t\t\t0.06519202186138805),\n    Data( -24.0,\t\t\t0.4768372324548341,\t\t\t-1.947492725545948),\n    Data( 24.0,\t\t\t0.476837232454748,\t\t\t1.9474927255461847),\n    Data( -50.0,\t\t\t0.4233447578057375,\t\t\t-2.329612262052369),\n    Data( 50.0,\t\t\t0.4233447578056912,\t\t\t2.3296122620530695),\n    Data( 27.0,\t\t\t0.38529618631322105,\t\t\t-1.8830790429497732),\n    Data( -27.0,\t\t\t0.3852961863129794,\t\t\t1.883079042951346),\n    Data( -41.0,\t\t\t0.3532730644517214,\t\t\t2.2795956884744872),\n    Data( 41.0,\t\t\t0.35327306445162726,\t\t\t-2.279595688475245),\n    Data( 109.0,\t\t\t0.33186001092302553,\t\t\t0.10164791576222479),\n    Data( -109.0,\t\t\t0.3318600109229166,\t\t\t-0.10164791576162562),\n    Data( -20.0,\t\t\t0.31827016982049233,\t\t\t-1.254232935979429),\n    Data( 20.0,\t\t\t0.31827016982007333,\t\t\t1.2542329359792357),\n    Data( -95.0,\t\t\t0.283990362516922,\t\t\t-0.5345424002831306),\n    Data( 95.0,\t\t\t0.28399036251684234,\t\t\t0.5345424002832788),\n    Data( -96.0,\t\t\t0.2521932235264325,\t\t\t1.7291277745164755),\n    Data( 96.0,\t\t\t0.2521932235264071,\t\t\t-1.7291277745182483),\n    Data( 91.0,\t\t\t0.22817192429016603,\t\t\t0.11282600368112272),\n    Data( -91.0,\t\t\t0.22817192428998606,\t\t\t-0.11282600367932635),\n    Data( 33.0,\t\t\t0.22793401098117602,\t\t\t-2.7727499703691336),\n    Data( -33.0,\t\t\t0.22793401098104846,\t\t\t2.772749970370273),\n    Data( -103.0,\t\t\t0.22460069723749082,\t\t\t-1.2017807603166384),\n    Data( 103.0,\t\t\t0.22460069723673795,\t\t\t1.2017807603165356),\n    Data( -89.0,\t\t\t0.21747778761877906,\t\t\t1.7124193638368796),\n    Data( 89.0,\t\t\t0.21747778761852576,\t\t\t-1.7124193638362275),\n    Data( 55.0,\t\t\t0.2152902408153102,\t\t\t-2.8257693310452017),\n    Data( -55.0,\t\t\t0.2152902408152419,\t\t\t2.8257693310440484),\n    Data( -46.0,\t\t\t0.21283927288626,\t\t\t1.1601795442137033),\n    Data( 46.0,\t\t\t0.2128392728862181,\t\t\t-1.160179544213888),\n    Data( 87.0,\t\t\t0.21250938302898872,\t\t\t2.977503684570063),\n    Data( -87.0,\t\t\t0.21250938302864922,\t\t\t-2.9775036845745317),\n    Data( -67.0,\t\t\t0.21248906352008243,\t\t\t-1.4408860948478193),\n    Data( 67.0,\t\t\t0.21248906352006872,\t\t\t1.440886094849722),\n    Data( -39.0,\t\t\t0.2064073422671597,\t\t\t-2.301154168622928),\n    Data( 39.0,\t\t\t0.20640734226712923,\t\t\t2.301154168622511),\n    Data( 97.0,\t\t\t0.19677024633021953,\t\t\t2.2465252673389537),\n    Data( -97.0,\t\t\t0.19677024632997445,\t\t\t-2.2465252673380407),\n    Data( -72.0,\t\t\t0.19558948988124528,\t\t\t0.5399016852511805),\n    Data( 72.0,\t\t\t0.1955894898811444,\t\t\t-0.5399016852501274),\n    Data( 92.0,\t\t\t0.19399762563866102,\t\t\t-1.998729069350953),\n    Data( -92.0,\t\t\t0.19399762563855494,\t\t\t1.9987290693519308),\n    Data( -51.0,\t\t\t0.18776619431384084,\t\t\t-0.24823340910233666),\n    Data( 51.0,\t\t\t0.1877661943137927,\t\t\t0.2482334091024692),\n    Data( -30.0,\t\t\t0.1818649936144726,\t\t\t2.3823381824874548),\n    Data( 30.0,\t\t\t0.18186499361354905,\t\t\t-2.3823381824868246),\n    Data( -64.0,\t\t\t0.18139073781353415,\t\t\t1.0742464350444643),\n    Data( 64.0,\t\t\t0.181390737812517,\t\t\t-1.0742464350483207),\n    Data( 83.0,\t\t\t0.1801082384688669,\t\t\t2.650694095073279),\n    Data( -83.0,\t\t\t0.18010823846873875,\t\t\t-2.6506940950702407),\n    Data( -34.0,\t\t\t0.17763147886373648,\t\t\t-0.8838371554070873),\n    Data( 34.0,\t\t\t0.17763147886368202,\t\t\t0.8838371554077402),\n    Data( -65.0,\t\t\t0.16899375804443037,\t\t\t0.23130662264184423),\n    Data( 65.0,\t\t\t0.16899375804404773,\t\t\t-0.2313066226383187),\n    Data( -12.0,\t\t\t0.16719290656407776,\t\t\t-0.5958646749624847),\n    Data( 12.0,\t\t\t0.16719290656370597,\t\t\t0.5958646749627651),\n    Data( 36.0,\t\t\t0.165301551472193,\t\t\t2.593097471652781),\n    Data( -36.0,\t\t\t0.1653015514721567,\t\t\t-2.593097471651556),\n    Data( -101.0,\t\t\t0.16486241018174463,\t\t\t0.6442649995861152),\n    Data( 101.0,\t\t\t0.16486241018031197,\t\t\t-0.6442649995912828),\n    Data( 99.0,\t\t\t0.16242695564188767,\t\t\t1.028118953015285),\n    Data( -99.0,\t\t\t0.16242695564180265,\t\t\t-1.0281189530148656),\n    Data( -57.0,\t\t\t0.16138693659225498,\t\t\t0.9756663402128001),\n    Data( 57.0,\t\t\t0.16138693659210607,\t\t\t-0.9756663402112361),\n    Data( -108.0,\t\t\t0.1613555968910301,\t\t\t-2.2761260334632403),\n    Data( 108.0,\t\t\t0.16135559689097062,\t\t\t2.2761260334650033),\n    Data( 37.0,\t\t\t0.15370336439879204,\t\t\t-2.6642683888952647),\n    Data( -37.0,\t\t\t0.15370336439846624,\t\t\t2.664268388898257),\n    Data( 153.0,\t\t\t0.1534195814992547,\t\t\t0.245928497751659),\n    Data( -153.0,\t\t\t0.1534195814990075,\t\t\t-0.2459284977493412),\n    Data( 59.0,\t\t\t0.15324429334076037,\t\t\t0.9297083708227801),\n    Data( -59.0,\t\t\t0.15324429334073614,\t\t\t-0.9297083708221752),\n    Data( 166.0,\t\t\t0.15303297551117534,\t\t\t2.13395646714667),\n    Data( -166.0,\t\t\t0.15303297551116155,\t\t\t-2.133956467147353),\n    Data( -62.0,\t\t\t0.1528580542931282,\t\t\t2.6301186944880137),\n    Data( 62.0,\t\t\t0.15285805429308946,\t\t\t-2.630118694486849),\n    Data( -70.0,\t\t\t0.15175775795073887,\t\t\t2.336119074970455),\n    Data( 70.0,\t\t\t0.15175775795063196,\t\t\t-2.3361190749715757),\n    Data( -47.0,\t\t\t0.15091010243710462,\t\t\t0.30971752923640156),\n    Data( 47.0,\t\t\t0.1509101024370587,\t\t\t-0.30971752923453305),\n    Data( -116.0,\t\t\t0.14836231745185818,\t\t\t-2.9378930657823403),\n    Data( 116.0,\t\t\t0.1483623174514922,\t\t\t2.9378930657838094),\n    Data( -102.0,\t\t\t0.14400474143289593,\t\t\t2.8647909864386962),\n    Data( 102.0,\t\t\t0.14400474143287983,\t\t\t-2.8647909864402),\n    Data( 81.0,\t\t\t0.1401700985609577,\t\t\t0.9420817189573863),\n    Data( -81.0,\t\t\t0.1401700985604733,\t\t\t-0.9420817189612183),\n    Data( 77.0,\t\t\t0.13867138764848602,\t\t\t-2.3683667983191103),\n    Data( -77.0,\t\t\t0.13867138764834133,\t\t\t2.368366798319337),\n    Data( -112.0,\t\t\t0.1379201592131512,\t\t\t-2.6216527537609187),\n    Data( 112.0,\t\t\t0.1379201592129405,\t\t\t2.621652753758431),\n    Data( 93.0,\t\t\t0.13582864092193395,\t\t\t1.9831474091215582),\n    Data( -93.0,\t\t\t0.13582864092159,\t\t\t-1.9831474091188024),\n    Data( -129.0,\t\t\t0.13469067950372648,\t\t\t-1.7066075001887269),\n    Data( 129.0,\t\t\t0.13469067950329985,\t\t\t1.7066075001871746),\n    Data( 60.0,\t\t\t0.13055523800779226,\t\t\t-1.7156350558460123),\n    Data( -60.0,\t\t\t0.13055523800773916,\t\t\t1.7156350558467184),\n    Data( 82.0,\t\t\t0.1303020523756822,\t\t\t-1.2450669763635078),\n    Data( -82.0,\t\t\t0.1303020523751821,\t\t\t1.2450669763607656),\n    Data( -32.0,\t\t\t0.1279076173512102,\t\t\t0.8067523204408599),\n    Data( 32.0,\t\t\t0.1279076173511966,\t\t\t-0.8067523204411796),\n    Data( -54.0,\t\t\t0.12552755745365102,\t\t\t-2.6388571278404647),\n    Data( 54.0,\t\t\t0.12552755745339916,\t\t\t2.6388571278489716),\n    Data( -68.0,\t\t\t0.12527791482241438,\t\t\t-2.3052212019670923),\n    Data( 68.0,\t\t\t0.12527791482236947,\t\t\t2.30522120197044),\n    Data( -35.0,\t\t\t0.1221899343625182,\t\t\t0.8929855231166186),\n    Data( 35.0,\t\t\t0.12218993436231938,\t\t\t-0.8929855231162244),\n    Data( 48.0,\t\t\t0.12124018109113456,\t\t\t0.22256070972632697),\n    Data( -48.0,\t\t\t0.12124018109013791,\t\t\t-0.2225607097173212),\n    Data( 61.0,\t\t\t0.11864046532322606,\t\t\t2.730048748599944),\n    Data( -61.0,\t\t\t0.11864046532312944,\t\t\t-2.730048748597761),\n    Data( -78.0,\t\t\t0.11534099878246555,\t\t\t-1.384898794390902),\n    Data( 78.0,\t\t\t0.1153409987824359,\t\t\t1.3848987943925464),\n    Data( 80.0,\t\t\t0.11485493880028479,\t\t\t3.116817698897287),\n    Data( -80.0,\t\t\t0.11485493879988137,\t\t\t-3.1168176988943785),\n    Data( 88.0,\t\t\t0.11438864609893276,\t\t\t0.9429952167264422),\n    Data( -88.0,\t\t\t0.11438864609771926,\t\t\t-0.9429952167226152),\n    Data( -90.0,\t\t\t0.1140853679261941,\t\t\t-2.6789272487719145),\n    Data( 90.0,\t\t\t0.11408536792437504,\t\t\t2.6789272487653095),\n    Data( -22.0,\t\t\t0.11057615697033829,\t\t\t-1.3190357316128372),\n    Data( 22.0,\t\t\t0.1105761569701023,\t\t\t1.3190357316109893),\n    Data( -106.0,\t\t\t0.10439451832635387,\t\t\t2.1136760899953737)\n);\nvec2 cpos(float t, int i){\n    t /= 5.;\n    Data fx=fX[i];\n    Data fy=fY[i];\n    return vec2(cos(fx.spd*t + fx.off)*fx.len,-cos(fy.spd*t + fy.off)*fy.len)/600.;\n}\nvec4 ccpos(float t, int i){\n    t /= 5.;\n    Data fx=fX[i];\n    Data fy=fY[i];\n    return vec4(cos(fx.spd*t + fx.off)*fx.len,-sin(fx.spd*t + fx.off)*fx.len,\n               -cos(fy.spd*t + fy.off)*fy.len, sin(fy.spd*t + fy.off)*fy.len)/600.;\n}", "buffer_a_code": "float circle(vec2 pos, vec2 center, float r){return length(center-pos)-r;}\nfloat line(vec2 p1,vec2 p2,vec2 c,float size){\n    return -length(mix(p1,p2,min(length(p1-c)/length(p2-p1),1.))-c)+size;\n}\nvoid mainImage(out vec4 o,vec2 u){\n    float md = float(iMouse.z>0.);\n    float r = 2./iResolution.x/(md*2.+1.);\n    vec2 uv = ((u+(iMouse.xy-iResolution.xy/2.)*md*2.)-iResolution.xy/2.)/iResolution.y/(md*2.+1.);\n    vec4 Pos = vec4(0);\n    vec2 Lines = vec2(0.);\n    \n    for(int i=0; i<36; i++){\n        vec4 Start = Pos;\n        Pos += ccpos(iTime, i);\n        Lines = max(Lines,vec2(line(Start.wz,Pos.wz,uv,r),line(Start.xy,Pos.xy,uv,r)));\n    }\n    o = clamp((1.-texture(iChannel1, (uv/iResolution.xy*iResolution.yy)+.5))*(float(iMouse.z>0.)+1.),0.,1.);\n    o -= (1.-vec4(1,0,0,0)) * clamp(Lines.x/r,0.,1.);\n    o -= (1.-vec4(0,1,0,0)) * clamp(Lines.y/r,0.,1.);\n    o -= (1.-vec4(.7)) * clamp(-min(abs(uv.x-Pos.x),abs(uv.y-Pos.z))/r+1.,0.,1.);\n    o *= clamp(1./(length(uv)+1.)+.3,0.,1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 o,vec2 u){\n    if(floor(u) == vec2(0)){\n        vec2 Pos = vec2(0,-.05);\n\n        for(int i=0; i<136; i+=2){\n            Pos += cpos(iTime, i)*2.;\n        }\n        o = vec4(Pos,0,0);\n    }else{\n        float r = 2./iResolution.x;\n        vec2 uv = (u-iResolution.xy/2.)/iResolution.y;\n        vec2 Pos = texture(iChannel0,vec2(0)).xy;\n        o = texture(iChannel0, u/iResolution.xy);\n        o = max(o,vec4((-length(uv-Pos))+.005)/r);\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdcRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 82]], "test": "untested"}
{"id": "wl3czM", "name": "Inception Totem", "author": "dean_the_coder", "description": "Another quick and small demo, playing around with creating a better wood texture than I've made in the past.\n\nIf the totem falls over, let me know...", "tags": ["3d", "raymarching", "movie", "cineshader"], "likes": 22, "viewed": 11970, "published": 3, "date": "1608661232", "time_retrieved": "2024-07-30T20:28:38.623915", "image_code": "// Processed by 'GLSL Shader Shrinker' (Shrunk by 125 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// 'Inception Totem' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/wl3czM\n//\n// Another quick and small demo, playing around with creating\n// a better wood texture than I've made in the past.\n// Still not happy with it - I think it needs some specular in\n// the lighter areas, and probably worth of a new shader experiment.\n//\n// If the totem falls over, let me know...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat time;\n\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 h,\n\t     ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\th = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\nfloat n11(float p) {\n\tfloat ip = floor(p);\n\tp = fract(p);\n\tvec2 h = fract(sin(vec2(ip, ip + 1.) * 12.3456) * 43.5453);\n\treturn mix(h.x, h.y, p * p * (3. - 2. * p));\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nHit minH(Hit a, Hit b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat wood(vec2 p) {\n\tp.x *= 71.;\n\tp.y *= 1.9;\n\treturn n11(n21(p) * 30.);\n}\n\nHit map(vec3 p) {\n\tfloat t,\n\t      f = p.y;\n\tp.x += .2 + cos(time * 10.) * .05;\n\tp.z += 3.5 + sin(time * 10.) * .05;\n\tp.xz *= rot(time * 150.);\n\tp.xy *= rot(mix(.02, .04, sin(time * .001) * .5 - .5));\n\tp.y -= .4;\n\tt = 1. - abs(p.y / .4 + .07);\n\treturn minH(Hit(f, 1, p), Hit(smin(sdCyl(p, vec2(smoothstep(0., 1., t * t * t) * .35, .4)), sdCapsule(p + vec3(0, .35, 0), .8, .01), mix(.03, .3, t * .7)), 2, p));\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .004 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 20.; i++) {\n\t\tfloat h = map(p + ld * t).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 6.) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 mat,\n\t     ld = normalize(vec3(6, 3, -10) - p),\n\t     ld2 = ld * vec3(-1, 1, 1),\n\t     n = calcN(p, d);\n\tif (h.id == 1) {\n\t\t// Table.\n\t\tmat = mix(mix(vec3(.17, .1, .05), vec3(.08, .05, .03), wood(p.xz)), vec3(.2, .16, .08), .3 * wood(p.xz * .2));\n\t\tn.x -= smoothstep(.98, 1., pow(abs(sin(p.x * 2.4)), 90.)) * .3;\n\t\tn = normalize(n);\n\t}\n\telse // Totem.\n        mat = .03 * mix(vec3(.4, .3, .2), mix(vec3(.6, .3, .2), 2. * vec3(.7, .6, .5), n31(h.uv * 1e2)), n31(h.uv * 36.5));\n\n\tfloat ao = dot(vec3(ao(p, n, .2), ao(p, n, .5), ao(p, n, 2.)), vec3(.3, .4, .3)),\n\t      l1 = max(0., .1 + .9 * dot(ld, n)),\n\t      spe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 20.)) * 10. + smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld2, n))), 20.)) * 2.,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n\tl1 *= mix(.4, 1., mix(calcShadow(p, ld), calcShadow(p, ld2), .3));\n\treturn mix(mat * (l1 * ao + spe) * vec3(2, 1.6, 1.4), vec3(.005), fre);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, c;\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = 0.; i < 90.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\tif (d > 48.) return vec3(0); // Distance limit reached - Stop.\n\t\td += h.d;\n\t}\n\n\tc = lights(p, rd, d, h) * exp(-d * .14);\n    float f = smoothstep(-2.2, -3., p.z) * (h.id == 1 ? .4 : 1.);\n\tif (f > 0.0) {\n\t\t// Show reflection on the totem.\n\t\tro = p;\n\t\trd = reflect(rd, calcN(p, d));\n\t\td = .1;\n\t\tfor (float i = 0.; i < 90.; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .002 || d > 1.) break;\n\t\t\td += h.d;\n\t\t}\n\n\t\tc = mix(c, d > 1. ? vec3(0) : lights(p, rd, d, h), .2 * f);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\ttime = mod(iTime * .2, 30.);\n    \n\tvec3 ro = vec3(0, 0, -5),\n\t     col = vec3(0);\n\tro.yz *= rot(-.13 - sin(time * .3) * .02);\n\tro.xz *= rot(.07 + cos(time) * .02);\n    \n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n\t\t\tcol += march(ro, getRayDir(ro, uv));\n\t\t}\n\t}\n\n\tcol /= 4.;\n\n\tfragColor = vec4(vignette(pow(col * 3., vec3(.45)), fc), 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3czM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[784, 840, 859, 859, 1138], [1140, 1140, 1159, 1159, 1393], [1395, 1395, 1415, 1415, 1561], [1563, 1563, 1602, 1602, 1694], [1696, 1696, 1720, 1720, 1759], [1761, 1761, 1780, 1780, 1847], [1849, 1849, 1879, 1879, 1979], [1981, 1981, 2024, 2024, 2076], [2078, 2078, 2112, 2112, 2240], [2242, 2242, 2262, 2262, 2317], [2319, 2319, 2336, 2336, 2729], [2731, 2731, 2760, 2760, 2979], [2981, 2981, 3016, 3031, 3230], [3232, 3260, 3295, 3295, 3326], [3328, 3328, 3360, 3360, 3475], [3477, 3477, 3523, 3523, 4480], [4482, 4482, 4512, 4526, 5165], [5167, 5167, 5212, 5212, 5663]], "test": "untested"}
{"id": "wt3czM", "name": "- helical gear -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["sphere", "twist"], "likes": 4, "viewed": 136, "published": 3, "date": "1608659018", "time_retrieved": "2024-07-30T20:28:39.465664", "image_code": "#define EPS 0.001\n#define MAX_DIST 20.\n\nfloat sdBox(vec3 p) {\n    vec3 d = abs(p) - 0.5;\n  \treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat sdTorus(vec3 p) {\n  \treturn length(vec2(length(p.xz) - 0.6, p.y)) - 0.4;  \n}\n\nvec3 rotateY(vec3 p, float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat3(c,  0, -s,\n                0,  1,  0,\n                s,  0,  c) * p;\n}\n\nvec3 twistY(vec3 p, float k) {\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    return vec3(mat2(c, -s, s, c) * p.xz, p.y);\n}\n\nvec3 calcBoxPos() {\n    float y = 1. - 4. * abs(round(iTime / 12.) - iTime / 12.);\n    vec3 origin = vec3(sin(iTime / 0.3), y, cos(iTime / 0.3));\n    origin.xz *= cos(y * 3.14 / 2.);\n    return origin;\n}\n\nfloat calcDist(vec3 p) {\n    float dBox = sdBox(twistY(1.2 * (p + 3. * calcBoxPos()), 6.)) - 0.4;\n    float dSphere = sdTorus(0.3 * twistY(rotateY(p, iTime), 8.));\n    \n    float morphK = 1.8;\n    return -log(exp(-morphK * dSphere) + exp(-morphK * dBox)) / morphK;\n}\n\nfloat rayMarch(vec3 rayO, vec3 rayD) {\n    float distFromO = 0.;\n    for (int i = 0; i < 150; ++i) {\n\t    float dS = calcDist(rayO + rayD * distFromO);\n        distFromO += dS;\n        if (dS < EPS || distFromO > MAX_DIST) break;\n    }\n    \n    return distFromO;\n}\n\nvec3 calcNormal(vec3 p) {\n    float d = calcDist(p);\n\treturn normalize(vec3(d - calcDist(p - vec3(EPS, 0,  0 )),\n\t\t\t\t\t  \t  d - calcDist(p - vec3( 0, EPS, 0 )),\n\t\t\t\t\t   \t  d - calcDist(p - vec3( 0,  0, EPS))));\n}\n\nvec3 calcLight(vec3 fragPos, vec3 lightPos, vec3 lightCol, vec3 camDir) {    \n\tvec3 normal = calcNormal(fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    vec3 ambient = vec3(0.1);\n    vec3 diffuse = vec3(max(dot(normal, lightDir), 0.0));\n    vec3 specular = vec3(0.15 * pow(max(dot(-camDir, reflect(-lightDir, normal)), 0.), 16.));\n    \n    return lightCol * (ambient + diffuse + specular);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    \n    vec3 camPos = vec3(0, 0, -10);\n\tvec3 camDir = normalize(vec3(xy, 1.));\n    \n    float dist = rayMarch(camPos, camDir);\n    \n    vec3 col = vec3(smoothstep(2., 0., length(xy))) * vec3(0.5, 0.6, 0.7);\n    \n    if (dist < MAX_DIST) { \n        col = calcLight(camPos + dist * camDir, \n                        vec3(5, 0, -15), \n                        vec3(0.9, 0.5, 0.4), \n                        camDir);\n    } \n    \n\tfragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3czM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 61, 61, 155], [157, 157, 180, 180, 239], [241, 241, 272, 272, 404], [406, 406, 436, 436, 542], [544, 544, 563, 563, 747], [749, 749, 773, 773, 1015], [1017, 1017, 1055, 1055, 1281], [1283, 1283, 1308, 1308, 1494], [1496, 1496, 1569, 1569, 1908], [1910, 1910, 1965, 1965, 2506]], "test": "untested"}
{"id": "3sfSDH", "name": "IFS behind the scenes", "author": "darkeclipz", "description": "Visualization of the coordinate space while applying an IFS. It animates through the rotation, and after each cycle it will increase the number of iterations.", "tags": ["2d", "fractal", "ifs"], "likes": 4, "viewed": 336, "published": 3, "date": "1608649033", "time_retrieved": "2024-07-30T20:28:40.546775", "image_code": "// Fork of \"Möbius transformation 1\" by Reedbeta. https://shadertoy.com/view/4tXyWs\n// 2019-02-25 23:03:29\n// Changed to show the coordinate space with the IFS applied to it.\n\n#define PI 3.14159\n\nvec2 ifs(vec2 p, float s, float r, int n) {\n    float co = cos(r), si = sin(r);\n    mat2 rot = mat2(co, si, -si, co);\n    for(int i=0; i < n; i++) {\n        p.x = abs(p.x);\n        p -= vec2(1.0, 0);\n        p *= rot;\n        p *= s;\n    }\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float s = 1.11;\n    float t = mod((iTime / 4.), 10.);\n    float r = fract(t) * 2.0 * PI;\n    \n    uv *= 3. + t / 6.;\n    uv = ifs(uv, s, r, int(t));\n    \n    fragColor.a = 1.0;\n\trenderGrid(uv, fragColor.rgb);\n    renderUnitSquare(uv, fragColor.rgb);\n    renderAxes(vec2(0), uv, fragColor.rgb);\n    \n    float pixelSize = 1. / iResolution.y;\n    vec3 col = vec3(1) * smoothstep(0.5, 0.5-10.*pixelSize, length(uv))*.25 + .75;\n    fragColor.rgb *= col;\n}\n", "image_inputs": [], "common_code": "\nvec2 ortho(vec2 v)\n{\n    return vec2(v.y, -v.x);\n}\n\nvoid stroke(float dist, vec3 color, inout vec3 fragColor, float thickness, float aa)\n{\n    float alpha = smoothstep(0.5 * (thickness + aa), 0.5 * (thickness - aa), abs(dist));\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid fill(float dist, vec3 color, inout vec3 fragColor, float aa)\n{\n    float alpha = smoothstep(0.5*aa, -0.5*aa, dist);\n    fragColor = mix(fragColor, color, alpha);\n}\n\nvoid renderGrid(vec2 pos, out vec3 fragColor)\n{\n    vec3 background = vec3(1.0);\n    vec3 axes = vec3(0.4);\n    vec3 lines = vec3(0.7);\n    vec3 sublines = vec3(0.95);\n    float subdiv = 10.0;\n\n    float thickness = 0.003;\n    float aa = length(fwidth(pos));\n\n    fragColor = background;\n\n    vec2 toSubGrid = pos - round(pos*subdiv)/subdiv;\n    stroke(min(abs(toSubGrid.x), abs(toSubGrid.y)), sublines, fragColor, thickness, aa);\n\n    vec2 toGrid = pos - round(pos);\n    stroke(min(abs(toGrid.x), abs(toGrid.y)), lines, fragColor, thickness, aa);\n\n    stroke(min(abs(pos.x), abs(pos.y)), axes, fragColor, thickness, aa);\n}\n\nfloat sdistLine(vec2 a, vec2 b, vec2 pos)\n{\n    return dot(pos - a, normalize(ortho(b - a)));\n}\n\nfloat sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)\n{\n    return max( sdistLine(a, b, pos),\n            max(sdistLine(b, c, pos),\n                sdistLine(c, a, pos)));\n}\n\nfloat sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)\n{\n    return max(  sdistLine(a, b, pos),\n            max( sdistLine(b, c, pos),\n             max(sdistLine(c, d, pos),\n                 sdistLine(d, a, pos))));\n}\n\nvoid renderUnitSquare(vec2 pos, inout vec3 fragColor)\n{\n#if 0\n    // Put a texture in there\n    if (pos.x >= 0.0 && pos.y >= 0.0 && pos.x <= 1.0 && pos.y <= 1.0)\n    {\n        fragColor.rgb = texture(iChannel0, pos).rgb;\n    }\n#endif\n\n    float dist = sdistQuadConvex(vec2(0, 0),\n                                 vec2(1, 0),\n                                 vec2(1, 1),\n                                 vec2(0, 1), pos);\n    stroke(dist, vec3(0, 0, 1), fragColor, 0.007, length(fwidth(pos)));\n}\n\nvoid renderAxes(vec2 origin, vec2 pos, inout vec3 fragColor)\n{\n    float len = 0.1;\n    float thickness = 0.0075;\n    float aa = length(fwidth(pos));\n\n    float xshaft = sdistQuadConvex(origin + vec2(0.5*thickness),\n                                   origin - vec2(0.5*thickness),\n                                   origin + vec2(len, -0.5*thickness),\n                                   origin + vec2(len, 0.5*thickness), pos);\n    float xhead = sdistTri(origin + vec2(len, -2.0*thickness),\n                           origin + vec2(len + 6.0*thickness, 0),\n                           origin + vec2(len, 2.0*thickness), pos);\n\n    fill(min(xshaft, xhead), vec3(1, 0, 0), fragColor, aa);\n\n    float yshaft = sdistQuadConvex(origin - vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness),\n                                   origin + vec2(0.5*thickness, len),\n                                   origin + vec2(-0.5*thickness, len), pos);\n    float yhead = sdistTri(origin + vec2(2.0*thickness, len),\n                           origin + vec2(0, len + 6.0*thickness),\n                           origin + vec2(-2.0*thickness, len), pos);\n\n    fill(min(yshaft, yhead), vec3(0, 0.75, 0), fragColor, aa);\n\n}\n\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b)\n{\n    return cmul(a, vec2(b.x, -b.y)) / dot(b, b);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfSDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 240, 240, 452], [454, 454, 509, 509, 1028]], "test": "untested"}
{"id": "3l3cz7", "name": "Basic IFS", "author": "darkeclipz", "description": "A very simple IFS function.\n\n - https://darkeclipz.blogspot.com/2020/12/iterated-function-systems-ifs.html ", "tags": ["fractal", "ifs"], "likes": 5, "viewed": 979, "published": 3, "date": "1608646467", "time_retrieved": "2024-07-30T20:28:41.657803", "image_code": "// https://darkeclipz.blogspot.com/2020/12/iterated-function-systems-ifs.html \n\n#define PI 3.14159265358979323846264\n#define MOUSE_DOWN (iMouse.z > 0.)\n#define SS 4.\n#define R iResolution.xy\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12454.1,78345.2))) * 43758.5);\n}\n\nvec2 random2(in vec2 st) {\n\treturn vec2(random(st), random(st));    \n}\n\nvec2 ifs(vec2 p, float s, float r, int n) {\n    float co = cos(r), si = sin(r);\n    mat2 rot = mat2(co, si, -si, co);\n    for(int i=0; i < n; i++) {\n        p.x = abs(p.x);\n        p -= vec2(1.0, 0);\n        p *= rot;\n        p *= s;\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    float px = 1. / iResolution.y;\n    for(float i=0.; i < SS; i++) {\n        vec2 uv = 5.5 * (2.*(fragCoord + random2(R+i)) - R) / R.y;\n        float s = MOUSE_DOWN ? 1.11 + (iMouse.y / iResolution.y - 0.5) * 0.1\n                             : 1.11;\n        float r = MOUSE_DOWN ? PI / 2. + iMouse.x / iResolution.x * 2. * PI\n                             : 2.*PI*fract((iTime + 20.2*2.)/100.);\n        uv = ifs(uv, s, r, 24);\n        uv = ifs(uv, 1.17, PI/2., 8);\n        float ds = 0.5;\n        col += vec3(1) * smoothstep(ds, ds-16.*px, length(uv));\n    }\n    fragColor = vec4(col / SS, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3cz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[192, 192, 219, 219, 289], [291, 291, 317, 317, 361], [363, 363, 406, 406, 618], [620, 620, 677, 677, 1299]], "test": "untested"}
{"id": "3l3yz7", "name": "More Rosettes", "author": "mla", "description": "Inspired by: [url]https://www.shadertoy.com/view/wtcyz8[/url] and [url]https://www.shadertoy.com/view/wl3yR4[/url]", "tags": ["loopless", "rosette"], "likes": 12, "viewed": 363, "published": 3, "date": "1608645314", "time_retrieved": "2024-07-30T20:28:42.626214", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// More Rosettes, Matthew Arcus, mla, 2020\n//\n// Draw rosette pattern looplessly, but also drawing each circle in the same\n// colour. Also clip pattern at some radius.\n//\n// 'c': clip pattern\n// 'd': moving dots\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat X = sqrt(3.0);\n\nfloat pwidth;\n\nvec3 docircle(vec3 col, vec2 p, vec2 index, vec2 s, vec2 cindex) {\n  index += s*cindex;\n  uint h = ihash(ivec2(index));\n  vec3 ccol = hsv2rgb(float(h)/pow(2.0,32.0),1.0,1.0);\n  vec2 ccentre = 0.5*vec2(1,X)*cindex;\n  col = mix(ccol,col,0.2+0.8*smoothstep(0.015,0.025+pwidth,circle(p,vec3(ccentre,1))));\n  if (!key(CHAR_D)) {\n    float t = iTime;\n    if (mod(index.x+index.y,4.0) < 2.0) t = -t;\n    vec2 dotpos = ccentre + s*vec2(sin(t),cos(t));\n    float dotdist = distance(p,dotpos);\n    col = mix(vec3(1),col,smoothstep(0.015,0.025+pwidth,dotdist));\n  }\n  return col;\n}\n\nbool checksegment(vec2 index, vec2 s, float r, vec2 offset) {\n  if (key(CHAR_C)) return true;\n  vec2 p = 0.5*vec2(1,X)*abs(index+s*offset);\n  return dot(p,p) < r*r;\n}\n\nvec3 diagram(vec2 p) {\n  float scale = 3.0;\n  p *= scale;\n  vec2 p0 = p;\n  pwidth = fwidth(p0.x);\n  p.y /= X;\n  vec2 index = round(p); // Coords of centre\n  p -= index;\n  index *= 2.0;\n  p.y *= X;\n  vec3 col = mod(index.x+index.y,4.0)< 2.0 ? vec3(1) : vec3(0.8);\n  vec2 s = ssign(p);\n  p = abs(p);\n  vec3 ccol = vec3(0);\n  float r = mod(iTime,6.0);\n  if (checksegment(index,s,r,vec2(1,1))) {\n    if (checksegment(index,s,r,vec2(-1,1))) {\n      col = docircle(col,p,index,s,vec2(0,2));\n    }\n    if (checksegment(index,s,r,vec2(2,0))) {\n      col = docircle(col,p,index,s,vec2(3,1));\n    }\n  }\n  if (checksegment(index,s,r,vec2(0,0))) {\n    if (checksegment(index,s,r,vec2(1,1))) {\n      col = docircle(col,p,index,s,vec2(2,0));\n      col = docircle(col,p,index,s,vec2(-1,1));\n    }\n    if (checksegment(index,s,r,vec2(-1,1))) {\n      col = docircle(col,p,index,s,vec2(-2,0));\n    }\n    if (checksegment(index,s,r,vec2(2,0))) {\n      col = docircle(col,p,index,s,vec2(1,-1));\n    }\n  }\n  if (!key(CHAR_C)) col = mix(vec3(0),col,smoothstep(0.0,pwidth,abs(length(p0)-r)));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = diagram(p);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  //rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuint ihash(int x) {\n  return ihash(uint(x));\n}\n\n// Sensible sign function\nvec2 ssign(vec2 p) {\n  return vec2(p.x < 0.0 ? -1 : 1, p.y < 0.0 ? -1 : 1);\n}\n\nfloat circle(vec2 p, vec3 c) {\n  vec2 centre = c.xy;\n  float radius = c.z;\n  return abs(length(p-centre)-radius);\n}\n\nuint ihash(ivec2 index) {\n  return ihash(index.x ^ int(ihash(index.y)));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 484, 484, 988], [990, 990, 1051, 1051, 1156], [1158, 1158, 1180, 1180, 2243], [2245, 2245, 2298, 2298, 2440]], "test": "untested"}
{"id": "Wl3cR7", "name": "\"Circular\" Pattern Tiling", "author": "mrange", "description": "License CC0 - Circular Pattern Tiling\n  I wanted to create circular tiling, turned out ok\n", "tags": ["2d", "tiling", "circular"], "likes": 14, "viewed": 409, "published": 3, "date": "1608643366", "time_retrieved": "2024-07-30T20:28:43.604598", "image_code": "// License CC0 - \"Circular\" Pattern Tiling\n//  I wanted to create \"circular\" tiling, turned out ok\n//  mod1  - From: http://mercury.sexy/hg_sdf/\n//  star5 - From: https://iquilezles.org/articles/distfunctions2d\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// Like many tiling functions modifies the input argument\n//  and returns a vector indicating which tile we are in\nvec3 modCircularPattern(inout vec2 p) {\n  vec2 pp = toPolar(p);\n\n  float nx = floor(pp.x + 0.5);\n  pp.x -= nx;\n  mod1(pp.x, 1.0);\n  pp.x += nx;\n  float cy = floor(0.5*nx*TAU)*2.0;\n  \n  float ny = mod1(pp.y, TAU/cy);\n  if(nx > 0.0) {\n    p = toRect(pp) - vec2(nx, 0.0);\n    return vec3(nx, mod(ny+cy*0.5, cy), cy);\n  } else {\n    return vec3(0.0, 0.0, 1.0);\n  }\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x+s*p.y, -s*p.x+c*p.y);\n}\n\nfloat star5(vec2 p, float r, float rf) {\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat df(vec2 p) {\n  const float lw = 0.033;\n\n  float nx = floor(length(p) + 0.5);\n  rot(p, iTime/sqrt(1.0+nx));\n\n  vec3 n = modCircularPattern(p);\n\n  rot(p, 0.1*TAU*(n.y+n.x));;\n\n  float d = star5(p, 0.5-lw, 0.5);  \n  d = abs(d) - lw;\n\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n  float aa = 2.0/iResolution.y;\n  \n  float s = 0.25*mix(0.1, 1.0, 0.5+0.5*sin(iTime*0.5));\n  float d = df(p/s)*s;\n  \n  vec3 col = mix(vec3(1.0), vec3(0.125), tanh(length(0.05*p/s)));\n  \n  col = mix(col, vec3(0.0), smoothstep(-aa, aa, -d));\n  col = pow(col, vec3(1.0/2.2));\n  \n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3cR7.jpg", "access": "api", "license": "cc0-1.0", "functions": [[258, 258, 297, 297, 422], [424, 424, 445, 445, 486], [488, 488, 510, 510, 554], [556, 671, 710, 710, 1033], [1035, 1035, 1068, 1068, 1149], [1151, 1151, 1191, 1191, 1549], [1551, 1551, 1569, 1569, 1801], [1803, 1803, 1855, 1855, 2268]], "test": "untested"}
{"id": "3lcyR7", "name": "Sliding Rose curves", "author": "AI", "description": "You may move the mouse horizontally to scale down the roses.\nYou can also change the constant values in the program to explore other variations.", "tags": ["curve", "polarcoordinates", "rose", "generativeart", "creativecoding", "sliding"], "likes": 1, "viewed": 279, "published": 3, "date": "1608640733", "time_retrieved": "2024-07-30T20:28:44.531121", "image_code": "//function to slide shapes\nvec4 moveShapes(vec2 st, float scale, float speed){\n    st *= scale;\n    float time = iTime*speed;\n    if( fract(time)>0.5 ){\n        if (step(1.,mod(st.y,2.))>0.){\n            st.x += 2.*fract(time);\n        } else {\n            st.x -= 2.*fract(time);\n        }\n    } else {\n        if (step(1.,mod(st.x,2.))>0.){\n            st.y += 2.*fract(time);\n        } else {\n            st.y -= 2.*fract(time);\n        }\n    }\n    return vec4(fract(st),floor(st));\n}\n\n//the Rose curve\nfloat rose(vec2 st){\n    float gray;\n    vec2 pos = st-vec2(0.5);\n    float r =(2.+.5*sin(iTime))*length(pos);\n    float a = atan(pos.y,pos.x);\n    float f =abs(cos(a*(1.+mod(5.+5.*sin(iTime),11.))))*.7+.1;\n\tgray=smoothstep(f-.5,f,r)-smoothstep(f,f+0.5,r);\n    return gray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n\t//set the number of shapes by the value of scale\n    float scale=6.+10.*iMouse.x/iResolution.x;\n    //set the speed of sliding\n    float speed=.5;\n    vec4 uvij = moveShapes(uv,scale,speed);\n    float shape=rose(uvij.xy);\n    //flag is used to alternate colors\n   float flag=mod(uvij.z+uvij.w,2.);\n    color = shape*vec3(1.,flag,flag);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 78, 78, 487], [489, 506, 526, 526, 781], [783, 783, 839, 839, 1284]], "test": "untested"}
{"id": "Wt3czM", "name": "Bessel J0/J1 + Struve H0/H1", "author": "TinyTexel", "description": "Approximations for the Bessel functions J0 and J1 and the Struve functions H0 and H1.\nhttps://en.wikipedia.org/wiki/Bessel_function\nhttps://en.wikipedia.org/wiki/Struve_function", "tags": ["approximation", "bessel"], "likes": 8, "viewed": 413, "published": 3, "date": "1608632576", "time_retrieved": "2024-07-30T20:28:45.453655", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    Approximations for the Bessel functions J0 and J1 and the Struve functions H0 and H1.\n    https://en.wikipedia.org/wiki/Bessel_function\n    https://en.wikipedia.org/wiki/Struve_function\n*/\n\n// https://link.springer.com/article/10.1007/s40314-020-01238-z\nfloat BesselJ0(float x)\n{\n    float xx = x * x;\n    float lamb = 0.865;\n    float q    = 0.7172491568;\n    float p0   = 0.6312725339;\n    float ps0  = 0.4308049446;\n    float p1   = 0.3500347951;\n    float ps1  = 0.4678202347;\n    float p2   =-0.06207747907;\n    float ps2  = 0.04253832927;\n\n    float lamb4 = (lamb * lamb) * (lamb * lamb);\n    float t0 = sqrt(1.0 + lamb4 * xx);\n    float t1 = sqrt(t0);\n    \n    return xx == 0.0 ? 1.0 : 1.0/(t1 * (1.0 + q * xx)) * ((p0 + p1*xx + p2*t0) * cos(x) + ((ps0 + ps1*xx) * t0 + ps2*xx) * (sin(x)/x));\n}\n\n// https://www.sciencedirect.com/science/article/pii/S2211379718300111\nfloat BesselJ1(float x)\n{\n    float xx = x * x;\n\n    return (sqrt(1.0 + 0.12138 * xx) * (46.68634 + 5.82514 * xx) * sin(x) - x * (17.83632 + 2.02948 * xx) * cos(x)) /\n           ((57.70003 + 17.49211 * xx) * pow(1.0 + 0.12138 * xx, 3.0/4.0) );\n}\n\n// https://research.tue.nl/nl/publications/efficient-approximation-of-the-struve-functions-hn-occurring-in-the-calculation-of-sound-radiation-quantaties(c68b8858-9c9d-4ff2-bf39-e888bb638527).html\nfloat StruveH0(float x)\n{\n    float xx = x * x;\n\n    return BesselJ1(x) + 1.134817700  * (1.0 - cos(x))/x - \n                         1.0943193181 * (sin(x) - x * cos(x))/xx - \n                         0.5752390840 * (x * 0.8830472903 - sin(x * 0.8830472903))/xx;\n}\n\n// https://research.tue.nl/nl/publications/efficient-approximation-of-the-struve-functions-hn-occurring-in-the-calculation-of-sound-radiation-quantaties(c68b8858-9c9d-4ff2-bf39-e888bb638527).html\nfloat StruveH1(float x)\n{\n    const float pi = 3.14159265359;\n\n    float xx = x * x;\n\n    return 2.0/pi - BesselJ0(x) + 0.0404983827 * sin(x)/x + \n                                  1.0943193181 * (1.0 - cos(x))/xx - \n                                  0.5752390840 * (1.0 - cos(x * 0.8830472903))/xx;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.y * 0.5;\n    //tex /= iResolution.xx * 0.125;\n    tex *= vec2(64,8) / iResolution.x;\n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n        \n    col = mix(col, vec3(1.0, 0.5, 0.0), Graph(StruveH1(tex.x) - tex.y, 0.5) * 0.75);\n    col = mix(col, vec3(0.0, 1.0, 0.5), Graph(StruveH0(tex.x) - tex.y, 0.5) * 0.75);\n    \n    col = mix(col, vec3(0.0, 0.5, 1.0), Graph(BesselJ1(tex.x) - tex.y, 0.5));       \n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(BesselJ0(tex.x) - tex.y, 0.5)); \n    //col = mix(col, vec3(0.0, 1.0, 0.0), Graph(Foo(tex.x) - tex.y, 0.5)); \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt3czM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[267, 331, 356, 356, 878], [880, 951, 976, 976, 1196], [1198, 1394, 1419, 1419, 1659], [1661, 1857, 1882, 1882, 2158], [2161, 2161, 2209, 2209, 3258]], "test": "untested"}
{"id": "Wl3cRM", "name": "cables2 golfed (664 chars)", "author": "FabriceNeyret2", "description": "mildly golfing 1627 chars yuntaRobo's cables2 [url]https://www.shadertoy.com/view/wlKXWc[/url]\n", "tags": ["raymarching", "torus", "sphere", "cables"], "likes": 12, "viewed": 482, "published": 3, "date": "1608632032", "time_retrieved": "2024-07-30T20:28:46.297398", "image_code": "// golfing 1627 chars yuntaRobo's cables2 https://www.shadertoy.com/view/wlKXWc\n// -10 by xavierseb\n\n#define L length\nvoid mainImage( out vec4 O, vec2 U ) {\n    vec3 R = iResolution,\n         P = vec3(0,0,10), p,\n         D = vec3( U+U-R.xy, -3.*min(R.x, R.y) ); D /= L(D);\n\n    for (float A=0., z = 0.; z < 15. && A<20.; z += 15./128.) {\n        p = P;\n        p.yz *= mat2(cos(3.14/5. + vec4(0,11,33,0) ) );\n        p.y -= .5;\n        float d = 1e2, N=50., s, r, i=0., a=i, t = iTime;\n        \n        R = vec3( cos(t), 0, sin(t) ) * 3.;              // reaction\n        s = L(R-p);\n        p += (R-p)/s / exp(s);\n               \n        for ( r = atan(p.z, p.x) * 3. ; i < N; i++)      // cables\n            r += .5/N * 6.3,\n            s = .5 + sin( i * 1.618 * 6.28) /4. + sin(t + i ) * .1,\n            s = L( vec2(L(p.xz) + cos(r) * s - 3., p.y + sin(r) * s) ) - .035,\n            s < d ? d=s, a=i : a;\n        \n        s = L(R-p) - .1;                                 // sphere\n        s < d ? d=s, a=0. : a;\n\n        if (d < .01) {\n            s = fract(a * 1.618);\n            O = s > .1 && s < .45 ? vec4(.175, .1, .1, 1) \n              : s < .05 ? vec4(1) \n              : mix( vec4(.1, .1, .5, 1), vec4(0, 0, 1, 1), s ) ;\n            O = sqrt( O / exp(z) );\n            return;\n        }\n\n        A += d *= .6;\n        P += D * d;\n    }\n    \n    O = abs(D.yyyy);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3cRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 156, 156, 1376]], "test": "untested"}
{"id": "3tccRn", "name": "GLSLLangSpec4607 snippets", "author": "gwiazdorrr", "description": "A collection of \"The OpenGL Shading Language, Version 4.60.7\" snippets", "tags": ["cxxswizzle"], "likes": 1, "viewed": 288, "published": 3, "date": "1608625080", "time_retrieved": "2024-07-30T20:28:47.291740", "image_code": "#define ISOK(x) x // ok\n#define ILGL(x)   // ok, illegal code according to the doc\n#define FAIL(x)   // general fail\n#define SNTX(x)   // failed - syntax error\n#define RSVD(x)   // failed - reserved keyword\n#define OVRL(x)   // failed - overload not found\n#define EXTS(x)   // failed - need an extension\n\n// 4.1. Basic Types\n\n//void _void;\nISOK(bool _bool;)\nISOK(int _int;)\nISOK(uint _uint;)\nISOK(float _float;)\nRSVD(double _double;)\nISOK(vec2 _vec2;)\nISOK(vec3 _vec3;)\nISOK(vec4 _vec4;)\nRSVD(dvec2 _dvec2;)\nRSVD(dvec3 _dvec3;)\nRSVD(dvec4 _dvec4;)\nISOK(bvec2 _bvec2;)\nISOK(bvec3 _bvec3;)\nISOK(bvec4 _bvec4;)\nISOK(ivec2 _ivec2;)\nISOK(ivec3 _ivec3;)\nISOK(ivec4 _ivec4;)\nISOK(uvec2 _uvec2;)\nISOK(uvec3 _uvec3;)\nISOK(uvec4 _uvec4;)\nISOK(mat2 _mat2;)\nISOK(mat3 _mat3;)\nISOK(mat4 _mat4;)\nISOK(mat2x2 _mat2x2;)\nISOK(mat2x3 _mat2x3;)\nISOK(mat2x4 _mat2x4;)\nISOK(mat3x2 _mat3x2;)\nISOK(mat3x3 _mat3x3;)\nISOK(mat3x4 _mat3x4;)\nISOK(mat4x2 _mat4x2;)\nISOK(mat4x3 _mat4x3;)\nISOK(mat4x4 _mat4x4;)\nRSVD(dmat2 _dmat2;)\nRSVD(dmat3 _dmat3;)\nRSVD(dmat4 _dmat4;)\nRSVD(dmat2x2 _dmat2x2;)\nRSVD(dmat2x3 _dmat2x3;)\nRSVD(dmat2x4 _dmat2x4;)\nRSVD(dmat3x2 _dmat3x2;)\nRSVD(dmat3x3 _dmat3x3;)\nRSVD(dmat3x4 _dmat3x4;)\nRSVD(dmat4x2 _dmat4x2;)\nRSVD(dmat4x3 _dmat4x3;)\nRSVD(dmat4x4 _dmat4x4;)\n\n// TODO: update fails\nSNTX(sampler1D _sampler1D;)\nSNTX(texture1D _texture1D;)\nRSVD(image1D _image1D;)\nRSVD(sampler1DShadow _sampler1DShadow;)\nRSVD(sampler1DArray _sampler1DArray;)\nSNTX(texture1DArray _texture1DArray;)\nRSVD(image1DArray _image1DArray;)\nRSVD(sampler1DArrayShadow _sampler1DArrayShadow;)\nISOK(uniform sampler2D _sampler2D;)\nSNTX(texture2D _texture2D;)\nRSVD(image2D _image2D;)\nISOK(uniform highp sampler2DShadow _sampler2DShadow;)\nISOK(uniform highp sampler2DArray _sampler2DArray;)\nSNTX(texture2DArray _texture2DArray;)\nRSVD(image2DArray _image2DArray;)\nISOK(uniform highp sampler2DArrayShadow _sampler2DArrayShadow;)\nRSVD(sampler2DMS _sampler2DMS;)\nSNTX(texture2DMS _texture2DMS;)\nSNTX(image2DMS _image2DMS;)\nRSVD(sampler2DMSArray _sampler2DMSArray;)\nRSVD(texture2DMSArray _texture2DMSArray;)\nSNTX(image2DMSArray _image2DMSArray;)\nRSVD(uniform sampler2DRect _sampler2DRect;)\nSNTX(texture2DRect _texture2DRect;)\nSNTX(image2DRect _image2DRect;)\nRSVD(sampler2DRectShadow _sampler2DRectShadow;)\nISOK(uniform sampler3D _sampler3D;)\nSNTX(texture3D _texture3D;)\nRSVD(image3D _image3D;)\nISOK(uniform samplerCube _samplerCube;)\nSNTX(textureCube _textureCube;)\nRSVD(imageCube _imageCube;)\nISOK(uniform highp samplerCubeShadow _samplerCubeShadow;)\nSNTX(samplerCubeArray _samplerCubeArray;)\nSNTX(textureCubeArray _textureCubeArray;)\nSNTX(imageCubeArray _imageCubeArray;)\nSNTX(samplerCubeArrayShadow _samplerCubeArrayShadow;)\nRSVD(samplerBuffer _samplerBuffer;)\nSNTX(textureBuffer _textureBuffer;)\nRSVD(imageBuffer _imageBuffer;)\nRSVD(subpassInput _subpassInput;)\nRSVD(subpassInputMS _subpassInputMS;)\n\nSNTX(uniform isampler1D _isampler1D;)\nSNTX(uniform itexture1D _itexture1D;)\nRSVD(uniform iimage1D _iimage1D;)\nRSVD(uniform isampler1DArray _isampler1DArray;)\nSNTX(uniform itexture1DArray _itexture1DArray;)\nRSVD(uniform iimage1DArray _iimage1DArray;)\nISOK(uniform highp isampler2D _isampler2D;)\nSNTX(uniform itexture2D _itexture2D;)\nRSVD(uniform iimage2D _iimage2D;)\nISOK(uniform highp isampler2DArray _isampler2DArray;)\nSNTX(uniform itexture2DArray _itexture2DArray;)\nRSVD(uniform iimage2DArray _iimage2DArray;)\nRSVD(uniform isampler2DMS _isampler2DMS;)\nSNTX(uniform itexture2DMS _itexture2DMS;)\nSNTX(uniform iimage2DMS _iimage2DMS;)\nRSVD(uniform isampler2DMSArray _isampler2DMSArray;)\nSNTX(uniform itexture2DMSArray _itexture2DMSArray;)\nSNTX(uniform iimage2DMSArray _iimage2DMSArray;)\nRSVD(uniform isampler2DRect _isampler2DRect;)\nSNTX(uniform itexture2DRect _itexture2DRect;)\nSNTX(uniform iimage2DRect _iimage2DRect;)\nISOK(uniform highp isampler3D _isampler3D;)\nRSVD(uniform itexture3D _itexture3D;)\nRSVD(uniform iimage3D _iimage3D;)\nISOK(uniform highp isamplerCube _isamplerCube;)\nSNTX(uniform itextureCube _itextureCube;)\nRSVD(uniform iimageCube _iimageCube;)\nSNTX(uniform isamplerCubeArray _isamplerCubeArray;)\nSNTX(uniform itextureCubeArray _itextureCubeArray;)\nSNTX(uniform iimageCubeArray _iimageCubeArray;)\nRSVD(uniform isamplerBuffer _isamplerBuffer;)\nSNTX(uniform itextureBuffer _itextureBuffer;)\nRSVD(uniform iimageBuffer _iimageBuffer;)\nSNTX(uniform isubpassInput _isubpassInput;)\nSNTX(uniform isubpassInputMS _isubpassInputMS;)\n\nSNTX(uniform usampler1D _usampler1D;)\nSNTX(uniform utexture1D _utexture1D;)\nRSVD(uniform uimage1D _uimage1D;)\nRSVD(uniform usampler1DArray _usampler1DArray;)\nSNTX(uniform utexture1DArray _utexture1DArray;)\nRSVD(uniform uimage1DArray _uimage1DArray;)\nISOK(uniform highp usampler2D _usampler2D;)\nSNTX(uniform utexture2D _utexture2D;)\nRSVD(uniform uimage2D _uimage2D;)\nISOK(uniform highp usampler2DArray _usampler2DArray;)\nSNTX(uniform utexture1DArray _utexture1DArray;)\nRSVD(uniform uimage2DArray _uimage2DArray;)\nRSVD(uniform usampler2DMS _usampler2DMS;)\nSNTX(uniform utexture2DMS _utexture2DMS;)\nSNTX(uniform uimage2DMS _uimage2DMS;)\nRSVD(uniform usampler2DMSArray _usampler2DMSArray;)\nSNTX(uniform utexture2DMSArray _utexture2DMSArray;)\nSNTX(uniform uimage2DMSArray _uimage2DMSArray;)\nRSVD(uniform usampler2DRect _usampler2DRect;)\nSNTX(uniform utexture2DRect _utexture2DRect;)\nSNTX(uniform uimage2DRect _uimage2DRect;)\nISOK(uniform highp usampler3D _usampler3D;)\nRSVD(uniform utexture3D _utexture3D;)\nRSVD(uniform uimage3D _uimage3D;)\nISOK(uniform highp usamplerCube _usamplerCube;)\nSNTX(uniform utextureCube _utextureCube;)\nRSVD(uniform uimageCube _uimageCube;)\nSNTX(uniform usamplerCubeArray _usamplerCubeArray;)\nSNTX(uniform utextureCubeArray _utextureCubeArray;)\nSNTX(uniform uimageCubeArray _uimageCubeArray;)\nRSVD(uniform usamplerBuffer _usamplerBuffer;)\nSNTX(uniform utextureBuffer _utextureBuffer;)\nRSVD(uniform uimageBuffer _uimageBuffer;)\nRSVD(uniform atomic_uint _atomic_uint;)\nSNTX(uniform usubpassInput _usubpassInput;)\nSNTX(uniform usubpassInputMS _usubpassInputMS;)\n\nSNTX(uniform sampler _sampler;)\nSNTX(uniform samplerShadow _samplerShadow;)\n\n\nvoid _5_4_1_Conversion_and_Scalar_Constructors()\n{\n    ISOK(int(_uint);) // converts an unsigned integer to a signed integer\n    ISOK(int(_bool);) // converts a Boolean value to an int\n    ISOK(int(_float);) // converts a float value to an int\n    RSVD(int(_double);) // converts a double value to a signed integer\n    ISOK(uint(_int);) // converts a signed integer value to an unsigned integer\n    ISOK(uint(_bool);) // converts a Boolean value to an unsigned integer\n    ISOK(uint(_float);) // converts a float value to an unsigned integer\n    RSVD(uint(_double);) // converts a double value to an unsigned integer\n    ISOK(bool(_int);) // converts a signed integer value to a Boolean\n    ISOK(bool(_uint);) // converts an unsigned integer value to a Boolean value\n    ISOK(bool(_float);) // converts a float value to a Boolean\n    RSVD(bool(_double);) // converts a double value to a Boolean\n    ISOK(float(_int);) // converts a signed integer value to a float\n    ISOK(float(_uint);) // converts an unsigned integer value to a float value\n    ISOK(float(_bool);) // converts a Boolean value to a float\n    RSVD(float(_double);) // converts a double value to a float\n    RSVD(double(_int);) // converts a signed integer value to a double\n    RSVD(double(_uint);) // converts an unsigned integer value to a double\n    RSVD(double(_bool);) // converts a Boolean value to a double\n    RSVD(double(_float);) // converts a float value to a double\n}\n\nvoid _5_4_2_Vector_and_Matrix_Constructors()\n{\n    ISOK(vec3(_float);) // initializes each component of the vec3 with the float\n\tISOK(vec4(_ivec4);) // makes a vec4 with component-wise conversion\n\tISOK(vec4(_mat2);) // the vec4 is column 0 followed by column 1\n\tISOK(vec2(_float, _float);) // initializes a vec2 with 2 floats\n\tISOK(ivec3(_int, _int, _int);) // initializes an ivec3 with 3 ints\n\tISOK(bvec4(_int, _int, _float, _float);) // uses 4 Boolean conversions\n\tISOK(vec2(_vec3);) // drops the third component of a vec3\n\tISOK(vec3(_vec4);) // drops the fourth component of a vec4\n\tISOK(vec3(_vec2, _float);) // vec3.x = vec2.x, vec3.y = vec2.y, vec3.z = float\n\tISOK(vec3(_float, _vec2);) // vec3.x = float, vec3.y = vec2.x, vec3.z = vec2.y\n\tISOK(vec4(_vec3, _float);)\n\tISOK(vec4(_float, _vec3);)\n\tISOK(vec4(_vec2, _vec2);)\n\n\tISOK(vec4 color = vec4(0.0, 1.0, 0.0, 1.0);)\n\tISOK(vec4 rgba = vec4(1.0);) // sets each component to 1.0\n\tISOK(vec3 rgb = vec3(color);) // drop the 4th component\n\n\tISOK(mat2(_float);)\n\tISOK(mat3(_float);)\n\tISOK(mat4(_float);)\n\n\tISOK(mat2(_vec2, _vec2);) // one column per argument\n\tISOK(mat3(_vec3, _vec3, _vec3);) // one column per argument\n\tISOK(mat4(_vec4, _vec4, _vec4, _vec4);) // one column per argument\n\tISOK(mat3x2(_vec2, _vec2, _vec2);) // one column per argument\n    RSVD(dmat2(_dvec2, _dvec2);)\n\tRSVD(dmat3(_dvec3, _dvec3, _dvec3);)\n\tRSVD(dmat4(_dvec4, _dvec4, _dvec4, _dvec4);)\n\tISOK(mat2(_float, _float, // first column\n\t _float, _float);) // second column\n\tISOK(mat3(_float, _float, _float, // first column\n\t _float, _float, _float, // second column\n\t _float, _float, _float);) // third column\n\tISOK(mat4(_float, _float, _float, _float, // first column\n\t _float, _float, _float, _float, // second column\n\t _float, _float, _float, _float, // third column\n\t _float, _float, _float, _float);) // fourth column\n\tISOK(mat2x3(_vec2, _float, // first column\n\t _vec2, _float);) // second column\n\tRSVD(dmat2x4(_dvec3, _double, // first column\n\t _double, _dvec3);) // second column\n\n\tISOK(mat3x3(_mat4x4);) // takes the upper-left 3x3 of the mat4x4\n\tISOK(mat2x3(_mat4x2);) // takes the upper-left 2x2 of the mat4x4, last row is 0,0\n\tISOK(mat4x4(_mat3x3);) // puts the mat3x3 in the upper-left, sets the lower right\n\t // component to 1, and the rest to 0\n}\n\nvoid _5_4_3_StructureConstructors()\n{\n    struct light {\n     float intensity;\n     vec3 position;\n    };\n    light lightVar = light(3.0, vec3(1.0, 2.0, 3.0));\n}\n\nvoid _5_4_4_ArrayConstructors()\n{\n    {\n        const float c[3] = float[3](5.0, 7.2, 1.1);\n        const float d[3] = float[](5.0, 7.2, 1.1);\n        float g;\n        // ...\n        float a[5] = float[5](g, 1.0, g, 2.3, g);\n        float b[3];\n        b = float[3](g, g + 1.0, g + 2.0);\n    }\n    {\n        vec4 b[2];\n        RSVD(vec4[3][2](b, b, b);) // constructor\n        RSVD(vec4[][2](b, b, b);) // constructor, valid, size deduced\n        RSVD(vec4[3][](b, b, b);) // constructor, valid, size deduced\n        RSVD(vec4[][](b, b, b);)\n    }\n}\n\nvoid _5_5_Vector_and_Scalar_Components_and_Length()\n{\n    {\n        vec2 pos;\n        float height;\n        pos.x; // is legal\n        ILGL(pos.z;) // is illegal\n        SNTX(height.x;) // is legal\n        ILGL(height.y;) // is illegal\n    }\n    {\n        vec4 v4;\n        v4.rgba; // is a vec4 and the same as just using v4,\n        v4.rgb; // is a vec3,\n        v4.b; // is a float,\n        v4.xy; // is a vec2,\n        ILGL(v4.xgba;) // is illegal - the component names do not come from the same set\n    }\n    {\n        vec4 v4;\n        ILGL(v4.xyzwxy;) // is illegal since it has 6 components\n        ILGL((v4.xyzwxy).xy;) // is illegal since the intermediate value has 6 components\n    }\n    {\n        vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);\n        vec4 swiz = pos.wzyx; // swiz = (4.0, 3.0, 2.0, 1.0)\n        vec4 dup = pos.xxyy; // dup = (1.0, 1.0, 2.0, 2.0)\n    }\n    {\n        vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);\n        pos.xw = vec2(5.0, 6.0); // pos = (5.0, 2.0, 3.0, 6.0)\n        pos.wx = vec2(7.0, 8.0); // pos = (8.0, 2.0, 3.0, 7.0)\n        ILGL(pos.xx = vec2(3.0, 4.0);) // illegal - 'x' used twice\n        ILGL(pos.xy = vec3(1.0, 2.0, 3.0);) // illegal - mismatch between vec2 and vec3\n    }\n    {\n        vec3 v;\n        SNTX(const int L = v.length();)\n    }\n}\n\nvoid _5_6_Matrix_Components()\n{\n    {\n        mat4 m;\n        m[1] = vec4(2.0); // sets the second column to all 2.0\n        m[0][0] = 1.0; // sets the upper left element to 1.0\n        m[2][3] = 2.0; // sets the 4th element of the third column to 2.0\n    }\n    {\n        mat3x4 v;\n        SNTX(const int L = v.length();)\n    }\n}\n\nvoid _5_7_Structure_and_Array_Operations()\n{\n    float diffuseColor, NdotL;\n    float lightIntensity[4];\n    diffuseColor += lightIntensity[3] * NdotL;\n    lightIntensity.length(); // return the size of the array\n}\n\nvoid _5_10_Vector_and_Matrix_Operations()\n{\n    {\n        vec3 v, u;\n        float f;\n        v = u + f;\n        v.x = u.x + f;\n        v.y = u.y + f;\n        v.z = u.z + f;\n    }\n    {\n        vec3 v, u, w;\n        w = v + u;\n        w.x = v.x + u.x;\n        w.y = v.y + u.y;\n        w.z = v.z + u.z;\n    }\n    {\n        vec3 v, u;\n        mat3 m;\n        u = v * m;\n        u.x = dot(v, m[0]); // m[0] is the left column of m\n        u.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b\n        u.z = dot(v, m[2]);\n        u = m * v;\n        u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;\n        u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;\n        u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;\n    }\n    {\n        mat3 m, n, r;\n        r = m * n;\n        r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;\n        r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;\n        r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;\n        r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;\n        r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;\n        r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;\n        r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;\n        r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;\n        r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;\n    }\n}\n\n// 6.1. Function Definitions\n#define returnType float\n#define type0 float\n#define type1 float\n#define typen float\n\n// prototype\nreturnType functionName (type0 arg0, type1 arg1, typen argn);\n\n// definition\nreturnType functionName (type0 arg0, type1 arg1, typen argn)\n{\n     // do some computation\n     return 0.0;\n}\n\nfloat myfunc (float f, out float g); // g is an output paramete\n\nvoid func1() { }\nILGL(void func2() { return func1(); }) // illegal return statement\n\nvec4 f(in vec4 x, out vec4 y) { return _vec4; } // (A)\nvec4 f(in vec4 x, out uvec4 y) { return _vec4; } // (B) okay, different argument type\nRSVD(vec4 f(in ivec4 x, out dvec4 y);) // (C) okay, different argument type\nILGL(int f(in vec4 x, out vec4 y);) // error, only return type differs\nILGL(vec4 f(in vec4 x, in vec4 y);) // error, only qualifier differs\nILGL(vec4 f(const in vec4 x, out vec4 y);) // error, only qualifier differs\n\nvoid _6_1_test()\n{\n    f(_vec4, _vec4); // exact match of vec4 f(in vec4 x, out vec4 y)\n    f(_vec4, _uvec4); // exact match of vec4 f(in vec4 x, out uvec4 y)\n    OVRL(f(_vec4, _ivec4);) // matched to vec4 f(in vec4 x, out vec4 y)\n     // (C) not relevant, can't convert vec4 to\n     // ivec4. (A) better than (B) for 2nd\n     // argument (rule 3), same on first argument.\n    ILGL(f(_ivec4, _vec4);) // NOT matched. All three match by implicit\n     // conversion. (C) is better than (A) and (B)\n     // on the first argument. (A) is better than\n     // (B) and (C).\n}\n\n\nvoid _6_4_Jumps() \n{\n    float intensity;\n    if (intensity < 0.0)\n        discard;\n    vec4  v = gl_FragCoord;\n}\n\nvoid _7_1_5_Fragment_Shader_Special_Variables()\n{\n    ISOK(gl_FragCoord;)\n    ISOK(gl_FrontFacing;) \n    FAIL(gl_ClipDistance;)\n    FAIL(gl_CullDistance;)\n    ISOK(gl_PointCoord;) \n    FAIL(gl_PrimitiveID; )\n    FAIL(gl_SampleID; )\n    FAIL(gl_SamplePosition;)\n    FAIL(gl_SampleMaskIn;)\n    FAIL(gl_Layer;)\n    FAIL(gl_ViewportIndex;)\n    FAIL(gl_HelperInvocation;)\n    ISOK(gl_FragDepth;)\n    FAIL(gl_SampleMask;)\n}\n\nvoid _7_4_Built_In_Uniform_State()\n{\n    ISOK(gl_DepthRange;)\n    FAIL(gl_NumSamples);\n}\n\nvoid _8_1_Angle_and_Trigonometry_Functions()\n{\n#define _8_1_Angle_and_Trigonometry_Functions(genFType) \\\n    { genFType t = radians(genFType(0)); }\\\n    { genFType t = degrees(genFType(0)); }\\\n    { genFType t = sin(genFType(0)); }\\\n    { genFType t = cos(genFType(0)); }\\\n    { genFType t = tan(genFType(0)); }\\\n    { genFType t = asin(genFType(0)); }\\\n    { genFType t = acos(genFType(0)); }\\\n    { genFType t = atan(genFType(1), genFType(2)); }\\\n    { genFType t = atan(genFType(1)); }\\\n    { genFType t = sinh(genFType(1)); }\\\n    { genFType t = cosh(genFType(1)); }\\\n    { genFType t = tanh(genFType(1)); }\\\n    { genFType t = asinh(genFType(1)); }\\\n    { genFType t = acosh(genFType(1)); }\\\n    { genFType t = atanh(genFType(0)); }\n    \n#define _8_2_Exponential_Functions(genFType)\\\n    { genFType t = pow(genFType(0), genFType(1)); }\\\n    { genFType t = exp(genFType(0)); }\\\n    { genFType t = log(genFType(1)); }\\\n    { genFType t = exp2(genFType(0)); }\\\n    { genFType t = log2(genFType(1)); }\\\n    { genFType t = sqrt(genFType(0)); }\\\n    { genFType t = inversesqrt(genFType(1)); };\n\n#define _8_3_Common_Functions(genFType, genDType, genIType, genUType, genBType)\\\n    ISOK({ genFType t = abs(genFType(0)); })\\\n    ISOK({ genIType t = abs(genIType(0)); })\\\n\tRSVD({ genDType t = abs(genDType(0));; })\\\n    ISOK({ genFType t = sign(genFType(0)); })\\\n    ISOK({ genIType t = sign(genIType(0)); })\\\n    RSVD({ genDType t = sign(genDType(0)); })\\\n    ISOK({ genFType t = floor(genFType(0)); })\\\n    RSVD({ genDType t = floor(genDType(0)); })\\\n    ISOK({ genFType t = trunc(genFType(0)); })\\\n    RSVD({ genDType t = trunc(genDType(0)); })\\\n    ISOK({ genFType t = round(genFType(0)); })\\\n    RSVD({ genDType t = round(genDType(0)); })\\\n    ISOK({ genFType t = roundEven(genFType(0)); })\\\n    RSVD({ genDType t = roundEven(genDType(0)); })\\\n    ISOK({ genFType t = ceil(genFType(0)); })\\\n    RSVD({ genDType t = ceil(genDType(0)); })\\\n    ISOK({ genFType t = fract(genFType(0)); })\\\n    RSVD({ genDType t = fract(genDType(0)); })\\\n    ISOK({ genFType t = mod(genFType(0), float(0)); })\\\n    ISOK({ genFType t = mod(genFType(0), genFType(0)); })\\\n    RSVD({ genDType t = mod(genDType(0), double(0)); })\\\n    RSVD({ genDType t = mod(genDType(0), genDType(0)); })\\\n    ISOK({ genFType o; genFType t = modf(genFType(0), o); })\\\n    RSVD({ genDType t = modf(genDType(0), genDType(0)); })\\\n    ISOK({ genFType t = min(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = min(genFType(0), float(0)); })\\\n    RSVD({ genDType t = min(genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = min(genDType(0), double(0)); })\\\n    ISOK({ genIType t = min(genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = min(genIType(0), int(0)); })\\\n    ISOK({ genUType t = min(genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = min(genUType(0), uint(0)); })\\\n    ISOK({ genFType t = max(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = max(genFType(0), float(0)); })\\\n    RSVD({ genDType t = max(genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = max(genDType(0), double(0)); })\\\n    ISOK({ genIType t = max(genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = max(genIType(0), int(0)); })\\\n    ISOK({ genUType t = max(genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = max(genUType(0), uint(0)); })\\\n    ISOK({ genFType t = clamp(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = clamp(genFType(0), float(0), float(0)); })\\\n    RSVD({ genDType t = clamp(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = clamp(genDType(0), double(0), double(0)); })\\\n    ISOK({ genIType t = clamp(genIType(0), genIType(0), genIType(0)); })\\\n    ISOK({ genIType t = clamp(genIType(0), int(0), int(0)); })\\\n    ISOK({ genUType t = clamp(genUType(0), genUType(0), genUType(0)); })\\\n    ISOK({ genUType t = clamp(genUType(0), uint(0), uint(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), float(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), double(0)); })\\\n    ISOK({ genFType t = mix(genFType(0), genFType(0), genBType(0)); })\\\n    RSVD({ genDType t = mix(genDType(0), genDType(0), genBType(0)); })\\\n    OVRL({ genIType t = mix(genIType(0), genIType(0), genBType(0)); })\\\n    OVRL({ genUType t = mix(genUType(0), genUType(0), genBType(0)); })\\\n    OVRL({ genBType t = mix(genBType(0), genBType(0), genBType(0)); })\\\n    ISOK({ genFType t = step(genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = step(float(0), genFType(0)); })\\\n    RSVD({ genDType t = step(genDType(0), genDType(0)); })\\\n    RSVD({ genFType t = step(double(0), genDType(0)); })\\\n    ISOK({ genFType t = smoothstep(genFType(0), genFType(0), genFType(0)); })\\\n    ISOK({ genFType t = smoothstep(float(0), float(0), genFType(0)); })\\\n    RSVD({ genDType t = smoothstep(genDType(0), genDType(0), genDType(0)); })\\\n    RSVD({ genDType t = smoothstep(double(0), double(0), genDType(0)); })\\\n    ISOK({ genBType t = isnan(genFType(0)); })\\\n    RSVD({ genBType t = isnan(genDType(0)); })\\\n    ISOK({ genBType t = isinf(genFType(0)); })\\\n    RSVD({ genBType t = isinf(genDType(0)); })\\\n    ISOK({ genIType t = floatBitsToInt(genFType(0)); })\\\n    ISOK({ genUType t = floatBitsToUint(genFType(0)); })\\\n    ISOK({ genFType t = intBitsToFloat(genIType(0)); })\\\n    ISOK({ genFType t = uintBitsToFloat(genUType(0)); })\\\n    OVRL({ genFType t = fma(genFType(0), genFType(0), genFType(0)); })\\\n    OVRL({ genFType t = fma(genDType(0), genDType(0), genDType(0)); })\\\n    OVRL({ genFType t = frexp(highpgenFType(0), genIType(0)); })\\\n    OVRL({ genFType t = frexp(genDType(0), genIType(0)); })\\\n    OVRL({ genFType t = ldexp(highpgenFType(0), genIType(0)); })\\\n    OVRL({ genFType t = ldexp(genDType(0), genIType(0); }))\n    \n#define _8_5_Geometric_Functions(genFType)\\\n    { float t = length(genFType(0)); }\\\n    { float t = distance(genFType(0),genFType(0)); }\\\n    { float t = dot(genFType(0),genFType(0)); }\\\n    { vec3 t = cross(vec3(0), vec3(0)); }\\\n    { genFType t = normalize(genFType(0)); }\\\n    { genFType t = faceforward(genFType(0),genFType(0),genFType(0)); }\\\n    { genFType t = reflect(genFType(0),genFType(0)); }\\\n    { genFType t = refract(genFType(0),genFType(0),float(0)); }\\\n    \n#define _8_7_Vector_Relational_Functions(bvec, vec, ivec, uvec) \\\n    { bvec t = lessThan(vec(0), vec(0));}\\\n    { bvec t = lessThan(ivec(0), ivec(0));}\\\n    { bvec t = lessThan(uvec(0), uvec(0));}\\\n    { bvec t = lessThanEqual(vec(0), vec(0));}\\\n    { bvec t = lessThanEqual(ivec(0), ivec(0));}\\\n    { bvec t = lessThanEqual(uvec(0), uvec(0));}\\\n    { bvec t = greaterThan(vec(0), vec(0));}\\\n    { bvec t = greaterThan(ivec(0), ivec(0));}\\\n    { bvec t = greaterThan(uvec(0), uvec(0));}\\\n    { bvec t = greaterThanEqual(vec(0), vec(0));}\\\n    { bvec t = greaterThanEqual(ivec(0), ivec(0));}\\\n    { bvec t = greaterThanEqual(uvec(0), uvec(0));}\\\n    { bvec t = equal(vec(0), vec(0));}\\\n    { bvec t = equal(ivec(0), ivec(0));}\\\n    { bvec t = equal(uvec(0), uvec(0));}\\\n    { bvec t = equal(bvec(0), bvec(0));}\\\n    { bvec t = notEqual(vec(0), vec(0));}\\\n    { bvec t = notEqual(ivec(0), ivec(0));}\\\n    { bvec t = notEqual(uvec(0), uvec(0));}\\\n    { bvec t = notEqual(bvec(0), bvec(0));}\\\n    { bool t = any(bvec(0));}\\\n    { bool t = all(bvec(0));}\\\n    { bvec t = not(bvec(0));}\\\n    \n    _8_1_Angle_and_Trigonometry_Functions(float)\n    _8_1_Angle_and_Trigonometry_Functions(vec2)\n    _8_1_Angle_and_Trigonometry_Functions(vec3)\n    _8_1_Angle_and_Trigonometry_Functions(vec4)\n    \n    _8_2_Exponential_Functions(float)\n    _8_2_Exponential_Functions(vec2)\n    _8_2_Exponential_Functions(vec3)\n    _8_2_Exponential_Functions(vec4)\n    \n    _8_3_Common_Functions(float, double, int, uint, bool)\n    _8_3_Common_Functions(vec2, dvec2, ivec2, uvec2, bvec2)\n    _8_3_Common_Functions(vec3, dvec3, ivec3, uvec3, bvec3)\n    _8_3_Common_Functions(vec4, dvec4, ivec4, uvec4, bvec4)\n    \n    _8_5_Geometric_Functions(float)\n    _8_5_Geometric_Functions(vec2)\n    _8_5_Geometric_Functions(vec3)\n    _8_5_Geometric_Functions(vec4)\n    \n    _8_7_Vector_Relational_Functions(bvec2, vec2, ivec2, uvec2)\n    _8_7_Vector_Relational_Functions(bvec3, vec3, ivec3, uvec3)\n    _8_7_Vector_Relational_Functions(bvec4, vec4, ivec4, uvec4)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tccRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tltcR4", "name": "David F.", "author": "iBoss", "description": "IT & Web Developer - contact@davidio.com", "tags": ["cineshader"], "likes": 1, "viewed": 9501, "published": 3, "date": "1608600987", "time_retrieved": "2024-07-30T20:28:48.227238", "image_code": "\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    fragColor = vec4(vec3(noise+.5), 1.);\n    /** 10x to TTG */\n}\n\n\n/** SHADERDATA\n{\n\t\"title\": \"David Fanjarashvili\",\n\t\"description\": \"IT & Web Developer - contact@davidio.com\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tltcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [191, 191, 212, 212, 2194], [2196, 2196, 2217, 2217, 2435], [2437, 2437, 2494, 2494, 2876]], "test": "untested"}
{"id": "WtdyzN", "name": "Exact SDF Modelling Exercise #1", "author": "oneshade", "description": "First exact SDF modelling execercise (aside from the easy ones: sphere, torus, plane ;) ).", "tags": ["3d", "sdf", "exercise", "exact", "revolved"], "likes": 5, "viewed": 413, "published": 3, "date": "1608593160", "time_retrieved": "2024-07-30T20:28:49.091926", "image_code": "float mapScene(in vec3 p) {\n    vec3 a = vec3(cos(iTime), 2.0 * sin(iTime), cos(iTime * 2.0)); // Opening of the tube\n    vec3 b = vec3(0.0, 0.0, 0.0); // Base of the tube\n\n    vec3 ba = a - b;\n    vec2 sp = vec2(atan(ba.z, ba.x), atan(ba.y, length(ba.xz)));\n    vec4 cs = vec4(cos(sp), sin(sp));\n\n    p -= b; // Translate to the base\n    p.xz *= mat2(cs.x, cs.z, -cs.z, cs.x); // Rotate to point along axis ba\n    p.xy *= mat2(cs.y, cs.w, -cs.w, cs.y);\n\n    vec2 size = vec2(cos(iTime) + 1.0, sin(iTime * 2.0) + 2.0); // radius, height\n    vec2 pr = vec2(length(p.yz), p.x); // Revolve the shape\n\n    // Can you spot those sneaky branches?\n    float tube = pr.y < 0.0 ? abs(length(pr) - size.x) : pr.y < size.y ? abs(abs(pr.x) - size.x) : length(abs(pr - vec2(0.0, size.y)) - vec2(size.x, 0.0));\n\n    return tube - 0.25 + 0.249 * sin(iTime);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float dt = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * dt;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            fragColor.rgb += max(0.2, dot(n, l));\n\n            break;\n        }\n\n        if (dt > 10.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtdyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 844], [846, 846, 873, 873, 1180], [1182, 1182, 1237, 1237, 1815]], "test": "untested"}
{"id": "WttyRN", "name": "Rainy Window in London", "author": "space928", "description": "It's a rainy day...", "tags": ["2d", "rain", "window"], "likes": 5, "viewed": 682, "published": 3, "date": "1608588313", "time_retrieved": "2024-07-30T20:28:50.181016", "image_code": "const int drops = 500;\nconst float dropSizeMin = 0.0025;\nconst float dropSizeMax = 0.004;\nconst float dropDistortionScale = 0.3;\nconst float dropDistortion = 0.003;\nconst float dropSpeedMin = 0.0;\nconst float dropSpeedMax = 0.6;\nconst float dropJiggleAmount = 0.015;\nconst float dropJiggleScale = 0.4;\n\nconst float bgBlurRadius = 5.;\n\nconst float pi = 3.14159265;\n\n//Taken from: https://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3\nuint hash(uint s)\n{\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nfloat random(uint seed)\n{\n    return float(hash(seed)) / 4294967295.0; // 2^32-1\n}\n\nfloat sat(float x)\n{\n    return max(min(x,1.),0.);\n}\n\nfloat remap(float x, float mi, float ma)\n{\n    return (x-mi)/(ma-mi);\n}\n\nfloat remapTo(float x, float mi, float ma)\n{\n    return x*(ma-mi)+mi;\n}\n\nvec3 blur(sampler2D tex, vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float sum = 0.;\n    \n    for(float x = -bgBlurRadius; x < bgBlurRadius; x++)\n    {\n        for(float y = -bgBlurRadius; y < bgBlurRadius; y++)\n        {\n            /*if(sqrt(x*x+y*y)>r)\n                continue;*/\n            vec2 off = vec2(x,y)/bgBlurRadius;\n            vec2 offFrost = tan(off*pi/2.)*(2./pi);\n            \n            float l = 1.-sqrt(x*x+y*y)/bgBlurRadius;\n            off = off;\n            float weight = tan(l);\n            \n            off *= 20.;\n            sum += weight;\n            col += textureLod(tex, uv + off/iResolution.xy,3.).rgb*weight;\n        }\n    }\n    return col / sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvn = fragCoord/iResolution.xx;\n    \n    vec2 dist = (texture(iChannel1, uv/dropDistortionScale).rg*2.-1.) * dropDistortion;\n    uv += dist;\n    uvn += dist;\n    \n    vec3 uvOff = vec3(0.);\n    for(int d = 0; d < drops; d++)\n    {\n        //Position and size\n        vec2 dp = vec2(random(uint(d)), random(uint(d+drops)));\n        float dropSize = mix(dropSizeMin, dropSizeMax, random(uint(d+drops*2)));\n        \n        //Animate\n        float t = iTime+sat(pow(sin(iTime * sat(random(uint(d+drops*8))*.5+.5)), 2.));\n        float vel = pow(remapTo(random(uint(d+drops*5)), dropSpeedMin, dropSpeedMax), 2.2);\n        dp.y -= t * vel;\n        dp.y = fract(dp.y);\n        dp.x += (dropJiggleAmount*(.4-vel))*(texture(iChannel1, dp/dropJiggleScale).r*2.-1.);\n        float stretch = pow(vel,1.5)*8.;\n        \n        float dropShape = 1.-sat(remap(sat(1.-length((dp-uvn)/vec2(1.-stretch*.2,1.+stretch))), 1.-dropSize, 1.));\n        dropShape = sqrt(1.-dropShape*dropShape);\n        \n        vec2 vecAng = (normalize(uvn-dp));\n        dropShape = (1.-dropShape)*smoothstep(0.1, 0.8,dropShape);\n        uvOff.r += dropShape*vecAng.x;\n        uvOff.g += dropShape*vecAng.y;\n        uvOff.b += dropShape;\n    }\n    \n    // BG Tex\n    vec3 col = textureLod(iChannel0, uv+uvOff.rg*0.1, 3.).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(smoothstep(0.5,0.95,sat(1.-uvOff.b+uvOff.g*.5))*0.25+.75),1.0);\n    float mixVal = smoothstep(0.5,0.95,sat(1.-uvOff.b+uvOff.g*.5))*0.5+.5;\n    //fragColor = vec4(mix(vec3(1.), col, 1.-mixVal),1.0);\n    //fragColor = vec4(mix(blur(iChannel0, fragCoord/iResolution.xy), col, 1.-mixVal),1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 444, 463, 463, 603], [605, 605, 630, 630, 687], [689, 689, 709, 709, 741], [743, 743, 785, 785, 814], [816, 816, 860, 860, 887], [889, 889, 924, 924, 1570], [1572, 1572, 1629, 1679, 3391]], "test": "untested"}
{"id": "ttcyRN", "name": "Day 368", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 30, "viewed": 559, "published": 3, "date": "1608587631", "time_retrieved": "2024-07-30T20:28:51.371830", "image_code": "#define planetSz 34.\n#define atmoSz 15.\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\n#define iMouse (iMouse.y < 10. ? iResolution.xy/2. : iMouse.xy)\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\n\n// PBR atmospheric scattering, learned from Sebastian Lague https://www.youtube.com/watch?v=DxfEbulyFcY\n// ACES from knarkowitz\n// cheap noise from nimitz\n// voronoi, smoothmin from iq\n// noise from dave hoskins\n    \nfloat cloudsLowerLimit = planetSz + 13.;\nfloat cloudsHigherLimit = planetSz + 27.;\nfloat dland, dsea;\nbool marchInsideSea = false;\n\nfloat fa;\n\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n\n\n// do not use texture\n//#define FULL_PROCEDURAL\n\n#ifdef FULL_PROCEDURAL\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n#else\nvec3 hash( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nfloat fbma(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.25;\n    fa = valueNoise(p,1.); \n    \n    float fb = valueNoise(p*2.,1.);\n    \n    \n    p.x += fb*1.2 ;\n    p.z += fb*.4 ;\n    float fd = valueNoise(p*9.8,1.);\n    \n    float fc = valueNoise(p*15.2,1.);\n    \n    float v = voronoi(op*0.1).x; \n\n    //fa += v*(1.2-v)*0.4;\n        \n\n    n += fa*3.4 + fd*0.05; /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    n += valueNoise(op*20.,1.)*0.002;\n    \n    n *= 1.2;\n    \n    return n;\n}\n\nfloat fbmsea(vec3 p){\n    float d = 0.;\n    vec3 modul = normalize(p);\n    //vec3 v = voronoi(p*1. + modul); \n    //d += (v.x)*(1.-v.x)*0.1;\n    d += valueNoise(p*0. + modul*(30.9 ) + vec3(0,iTime*1.,0),1.)*.2;\n    \n    return d;\n}\n\nfloat mapClouds(vec3 p){\n    float rotEnv = 0.125*iTime;\n    float currHeight = length(p);\n    \n    p.yz *= rot(rotEnv);\n    \n    \n    p *= 0.5;\n    float cloudsRange = (cloudsHigherLimit - cloudsLowerLimit)*0.494;\n    float cloudsMid = cloudsLowerLimit + cloudsRange;\n    \n    float f = valueNoiseCheap(p*0.25,1.);\n    \n    f += valueNoiseCheap(p*0.51,1.)*0.325;\n    f += valueNoiseCheap(p*1.005,1.)*0.254;\n    f += valueNoiseCheap(p*2.04,1.)*0.105;\n    \n    f *= pow(valueNoiseCheap(p*0.2 + iTime*0.2,1.)*1.,2.9);\n    \n    f = smoothstep(0.,1.,f*1.2);\n    \n    f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.94), 0.99);\n    \n    return f * 1.;\n}\n\n\nfloat sdRocks(vec3 _p, float md, float s){\n  vec4 p = vec4(_p,1.);\n  \n  p.yw *= rot(0.4);\n  p = abs(p);\n  p.xz *= rot(0.4);\n  p = abs(p);\n  \n  p.xy *= rot(2.4);\n  p = abs(p) - 1.4;\n  \n  p.yz *= rot(.2);\n  p = abs(p);\n  p = pmod(p,md);\n  \n  p = abs(p) - s;\n  return max(p.x,max(p.y,max(p.z,p.w))) ;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    float rotEnv = 0.125*iTime;\n    p.yz *= rot(rotEnv);\n    if(!marchInsideSea){\n        dsea = length(p) - planetSz - 2.8 - fbmsea(p*1.) ;\n        d = dmin(d, dsea,2.);\n    }\n    dland = length(p) - planetSz - fbma(p)*1.;\n    d = dmin(d, dland,1.);\n    \n    p.yx *= rot(0.5);\n    p.xz *= rot(0.5);\n    //float drocks = sdRocks(p, 14.4, 3.8);\n    //drocks = opSmoothSubtraction( -drocks, -(-length(p) + planetSz + 4.5), 1.2 );\n    \n    //d = dmin(d, drocks,3.);\n    \n    \n    d.x *= 0.75;\n    return d;\n}\n\nvec3 getNormala(vec3 p){\n    vec2 t = vec2(0.01,0.);\n    return normalize(map(p).x - vec3(\n        map(p - t.xyy).x,\n        map(p - t.yxy).x,\n        map(p - t.yyx).x\n    ));\n}\n\n\nvec3 getNormal(vec3 p){\n    vec4 vals;\n    for(int i = 0; i < 4 + min(iFrame,0); i++){\n        if(i == 3){\n            vals[3] = map(p).x;\n        }\n            \n        vals[i] = map(p - vec3(float(i%3==0),float(i%3==1),float(i%3==2)) * 0.001 ).x; \n    \t\n    }\n    \n    return normalize(vals.w - vals.xyz);\n}\nvec3 getSun(vec2 uv, vec2 sunUV, vec2 sunUVPos,vec3 sunCol){\n    \n    vec2 sunUVB = sunUV;\n    \n    sunUV -= sunUVPos;\n    vec3 sunRays = 0.4*sunCol * smoothstep(0.035*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n\n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi/8./1.);\n        sunRays += .1* (sunCol) * smoothstep(0.04 + sin(i*pi/4.)*0.01,0.,abs(sunUV.y))*smoothstep((0.2 + sin(i*pi/4.)*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVB - sunUVPos;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunUVPos;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return sunRays + flares*2.;\n}\n\n#define itersAtmo 10.\n#define itersOptic 10.\n\nfloat densFalloff = 5.;\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (length(p) - planetSz -0.2  )/atmoSz;\n    fact = max(fact, 0.001);\n    return exp(-fact*densFalloff)*pow((1. - fact),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nconst float redLightLen = 650.;\nconst float greenLightLen = 530.;\nconst float blueLightLen = 440.;\n\nconst float transStrength = 0.7;\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, out float opticalDepthView, float t, bool hit, vec3 sunPos){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 p = ro;\n    //sunPos += offs;\n    \n    //p += offs*1.;\n    \n    \n    if(hit){\n        atmoMarchLen = t;\n    } else {\n        atmoMarchLen = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPos - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        float lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\n\n\nvec3 getRdSpherical(vec3 ro,vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    uv += 0.5;\n    uv.y *= tau/2.;\n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1. + sin(iTime)*0.)*pi);\n    \n    vec3 lookAt = ro + offs;\n    \n    return normalize(lookAt - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0);\n    \n    ro.y += planetSz + 2.2 + iMouse.y/iResolution.y*atmoSz*.5;\n    \n    map(ro);\n    ro.y += fa*1.9 ;\n    \n    #define pump(a,b) (floor(a) + pow(fract(a),b))\n    float sphericalEnv = cos(pump(iTime*0.06,20.)*pi + pi)*0.5 + 0.5; \n    \n    sphericalEnv = 0.;\n    \n    vec3 rd = normalize(vec3(uv,1));\n    rd = mix(rd,getRdSpherical(ro,uv),sphericalEnv);\n    \n    float rotEnv = 0.25*iTime;\n    rd.yz *= rot(0.25*(1.-sphericalEnv));\n    //rd.yz *= rot(rotEnv);\n        \n    vec3 p = ro;\n    \n\n    float t = 0.;\n    bool hit = false;\n    \n    vec3 albedo = vec3(1.,0.9,0.6);\n    // Marching\n    \n    vec2 d;\n    for(int i = 0; i < 130 ; i++){\n        d = map(p);\n        \n        if(d.x < 0.02){\n            hit = true;\n            break;\n        } else if (t > 29.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x);\n    }\n    float seaDepthFactor = 0.;\n    vec3 seaHitP = p;\n    float tSea = 0.;\n    if (hit && d.y == 2.){\n        // Sea marching\n        marchInsideSea = true;\n        seaDepthFactor = smoothstep(1.,2.6,fa*2.);\n        albedo = mix(vec3(0.,0.5,1)*0.9,vec3(0.21,0.2,0.6),seaDepthFactor);\n        for(int i = 0; i < 20; i++){\n            vec2 d = map(p);\n\n            if( d.x < 0.004){\n                hit = true;\n                marchInsideSea = false;\n\n                break;\n            }\n\n            p = seaHitP + rd*(tSea += d.x);\n        }\n\n    \n    }\n    \n    vec3 sunPos = normalize(vec3(.9,2.4,2));\n    //sunPos.yz *= rot(sin(iTime*0.5)*1.5);\n    float spmd = sin(iTime*0.5)*1.5;\n    sunPos.yz += vec2(sin(spmd),cos(spmd));\n    \n    \n    //sunPos.xz *= rot(sin(iTime));\n    sunPos *= (planetSz + 50.);\n    \n    vec3 sunDir = normalize(sunPos - p);\n    \n    vec3 sunCol = vec3(0.9,0.9,0.9)*0. + vec3(1,0.9,0.7);\n        \n    float depthView; \n    vec3 atmosphere = getAtmosphere( ro, rd, depthView, t, hit, sunPos);\n    \n    \n    // Shading\n    \n    if(hit){\n        \n        marchInsideSea = true;\n        vec3 n = getNormal(p);\n        marchInsideSea = false;\n\n        vec3 hf = normalize(sunDir + n);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),32.);\n        \n        vec3 groundAlbedo = vec3(0.6,1.2,0.4)*1.;\n        groundAlbedo = vec3(0.4,1.2,0.4)*1.;\n        \n        vec3 sandAlbedo = vec3(0.86,0.8,0.5)*1.6;\n        groundAlbedo = mix(sandAlbedo, groundAlbedo,smoothstep(0.,0.6,length(p) - planetSz - 2.9));\n        #define SSS(a) clamp(map(p + sunDir).x/a,0., 1.)\n        float sssfact = SSS(0.5)*SSS(4.5)*4.5;\n        //sssfact = 1.;\n        vec3 groundColor = groundAlbedo*(diff + 0.03 + sssfact*(1. + diff)*0.1)*(sunCol*0.6 + atmosphere) + spec*0.05*(sunCol + atmosphere);\n\n        if (d.y == 3.){\n            groundColor = 0.2*sandAlbedo*(diff + 0.03)*(sunCol + atmosphere) + spec*0.4*sunCol;\n            col += groundColor;\n        }\n        \n        if(d.y == 1.){\n            col += groundColor;\n        } else if (d.y == 2.){\n            \n            vec3 seaN = getNormal(seaHitP);\n            \n            vec3 seaSunDir = normalize(sunPos - seaHitP);\n    \n            vec3 seaHf = normalize(seaSunDir + seaN);\n            float seaDiff = max(dot(seaN,seaSunDir),0.);\n            float seaSpec = pow(max(dot(seaN,seaHf),0.),22.);\n            float seaFres = pow(1. - max(dot(seaN,-rd),0.),5.);\n            \n            vec3 vP = seaHitP;\n            vP.yz *= rot(0.125*iTime);\n            float foam = voronoi(normalize(vP)*(136. + sin(iTime*0.05)*40.)*0.4 + vP).x;\n            \n            foam *= pow(valueNoiseCheap(normalize(vP)*(136. + sin(iTime*0.3)*40.)*0.1,1.), 1.2 ) ;\n            //v *= 1. - v;\n            col += (albedo + smoothstep(0.1,0.,dland - 0. - foam))*(seaDiff*0.5 + 0.1)*(sunCol + atmosphere)*0.8 \n            + (seaSpec + seaFres)*0.2*(sunCol*0.3 + 0.2*atmosphere + albedo*0.4);\n            col *= 1. + seaDepthFactor*groundColor*26.;\n        }\n    }\n    \n    // Atmosphere\n    \n    atmosphere *= 1.-exp(-t*0.2);\n\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t + tSea*2.)*0.05 ),2.);\n    }\n    \n    col = col * exp(-depthView) + atmosphere; \n    \n    //col += accumAtmo*1.;\n    \n    // Clouds\n    \n    float cloudSteps = 26.;\n    \n    float currH = length(ro);\n    \n    \n    \n    vec2 lowerSphere = sphIntersect( ro, rd, vec3(0), cloudsLowerLimit );\n    vec3 lowerLimitP = ro + rd * lowerSphere.y;\n    \n    \n    //if(currH > cloudsLowerLimit && currH < cloudsHigherLimit) {\n    if(currH > cloudsLowerLimit  ) {\n      \n        //lowerLimitP = ro;\n    }\n    \n    vec3 higherLimitP = lowerLimitP + rd * sphIntersect( lowerLimitP, rd, vec3(0), cloudsHigherLimit ).y;\n    \n    vec3 cloudP = lowerLimitP;\n    \n    float cloudLength = length(higherLimitP - lowerLimitP); // TODO: can make this cheaper\n    float cloudStepSz = cloudLength/(cloudSteps);\n    \n    float cloudDensTotal = 0.;\n    vec3 cloudAccum = vec3(0.);\n    \n    \n    for(float i = 0.; i < cloudSteps; i++){\n        float d = mapClouds(cloudP);\n        \n        sunDir = normalize(sunPos - cloudP);\n        float difffact = clamp( d*1. - mapClouds(cloudP + sunDir*1.4)*1.1 , 0., 1. );\n        vec3 diff = mix( atmosphere*0.1 + vec3(0.04,0.11,0.2)*(0.4 - smoothstep(0.,1.,1. - atmosphere*1.8)*0.4), (vec3(1,0.9,0.9)*1. + sunCol*0.4 + atmosphere*.4)*0.5, difffact );\n        vec3 absorption = mix( vec3(1,0.9,0.8), vec3(1,0.9,0.7)*0.5, clamp( cloudDensTotal*0.5, 0., 1. ) );\n        vec3 fringe = vec3(0.9,0.8,0.5)*clamp( 1. - d*4., 0.,1.);\n        \n        d = d*(1.-cloudDensTotal)*cloudStepSz;\n        \n        cloudDensTotal += d;\n        cloudAccum += d*(diff*3.7*absorption + fringe*(0.1 + diff*0.9)*2.64);\n\n        // map(cloudP).x < 0.\n\n            \n        if( cloudDensTotal > 1.){\n            break;\n        }\n        cloudP += rd*cloudStepSz;\n    }\n    if (!hit){\n        col = mix(col,cloudAccum , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),5.));\n    }\n    \n    // sun \n    \n    //sunPos.yz *= rot(0.25);\n    \n    sunPos.yz *= rot(0.25*(1.-sphericalEnv));\n    vec2 sunUV = mix( uv, uv+2000., sphericalEnv);\n    \n    vec3 sun = vec3(0);\n    vec3 sunDirNormalized = normalize(sunPos - ro);\n    //sunDirNormalized = mix( sunDirNormalized, getRdSpherical(ro, sunUV), sphericalEnv);\n    sunDirNormalized = mix( sunDirNormalized, getRdSpherical(ro, sunDirNormalized.xy), sphericalEnv);\n    \n    \n    if (!hit){\n        sun += .5* smoothstep(1.,0.,length(sunUV - sunDirNormalized.xy) + .44)*vec3(1,0.6,0.4);\n        sun += .5* smoothstep(0.5,0.,length(sunUV - sunDirNormalized.xy) + .24)*vec3(2,0.9,0.4);\n        sun += smoothstep(0.08,0.,length(sunUV - sunDirNormalized.xy) - .03)*vec3(1,0.8,0.9);\n    }\n    float sunCloudBlend = smoothstep( 0. ,1. , 1. - cloudDensTotal*0.8 );\n    col += sun*sunCloudBlend;\n    \n    //sphericalEnv\n    float sunRaysBlend = smoothstep(0.,1.,  \n        mix(\n            (sunDirNormalized.y +  0.24 - smoothstep(0.,0.4,abs(sunDirNormalized.y) - 0.4 ) )*4.,\n            ( 2.4 - length(sunUV - sunDirNormalized.xy) )*19.*0. + 0.,\n            sphericalEnv\n            ))\n            ;\n    col += sunRaysBlend*sunCloudBlend*getSun(uv, sunUV, sunDirNormalized.xy, sunCol*0.2 + vec3(1,0.6,0.4)*0.8);\n    col = mix(col,smoothstep(0.,1.,col*1.6),0.5);\n    col = max(col,0.);\n    col = mix(acesFilm(col), col, 0.9);\n    col *= 1. - dot(uv,uv*0.4)*2.1;\n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\n\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat valueNoise(vec3 uv,float pw){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    fd = pow(fd,vec3(pw));\n    \n    float ibl = hash13(id + vec3(0,-1,0));\n    float ibr = hash13(id + vec3(1,-1,0));\n    float itl = hash13(id + vec3(0));\n    float itr = hash13(id + vec3(1,0,0));\n    \n    \n    float jbl = hash13(id + vec3(0,-1,1));\n    float jbr = hash13(id + vec3(1,-1,1));\n    float jtl = hash13(id + vec3(0,0, 1));\n    float jtr = hash13(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttcyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 278, 278, 312], [674, 674, 717, 717, 937], [1308, 1356, 1383, 1383, 1963], [1965, 1965, 1984, 1984, 2459], [2461, 2461, 2482, 2482, 2692], [2694, 2694, 2718, 2718, 3387], [3390, 3390, 3432, 3432, 3689], [3691, 3691, 3708, 3708, 4244], [4246, 4246, 4270, 4270, 4423], [4426, 4426, 4449, 4449, 4735], [4736, 4736, 4796, 4796, 5788], [5861, 5861, 5895, 5895, 6076], [6078, 6078, 6125, 6125, 6349], [6631, 6631, 6728, 6728, 7853], [7857, 7857, 7894, 7919, 8265], [8267, 8267, 8324, 8324, 15787]], "test": "untested"}
{"id": "wdVBDd", "name": "Maelstrom", "author": "piluve", "description": "Fanart from the Solo movie. This is from the Kessel run scene. ", "tags": ["modeling", "volumetric"], "likes": 6, "viewed": 376, "published": 3, "date": "1608578953", "time_retrieved": "2024-07-30T20:28:52.222556", "image_code": "/*\n    Maelstrom by nachocpol@gmail.com\n    \n    From the SW Solo movie\n    Refs:\n        https://www.retrozap.com/wp-content/uploads/2018/04/Screen_Shot_2018_02_05_at_8_51_04_AM.png\n        https://www.the-blueprints.com/blueprints-depot-restricted/sciencefiction/star-wars-imperial/imperial_sd-02668.jpg\n*/\n\n#define PI 3.14159265359\n#define DEG_TO_RAD 0.0174533\n#define THUNDER 1 // Disable this if you are sensitive to flashing lights\n\nconst float k_Near = 1.0;\nconst float k_Far = 100.0;\nconst int k_MainSteps = 360;\nconst float k_HitDelta = 0.001;\n\nconst float k_ThunderRadius = 20.0;\nconst vec3 k_ThunderColor = vec3(0.5, 0.61, 0.75); \nconst vec3 k_Thunder0 = vec3(-15.0, -10.0, -5.0);\nconst vec3 k_Thunder1 = vec3(10.0, 9.0, -5.0);\nconst vec3 k_Thunder2 = vec3(-10.0, 9.0, 5.0);\nconst float k_SunRadius = 30.0;\nconst vec3 k_SunColor = vec3(1.0, 0.35, 0.0);\nconst vec3 k_Sun = vec3(-5.0, 10.0, 28.0);\n\nconst vec3 k_CloudAlbedo = vec3(0.2, 0.18, 0.28);\n\nfloat saturate(float v)\n{\n    return max(min(v,1.0),0.0);\n}\n\nmat3 RotX(float angle)\n{\n    float o = angle * DEG_TO_RAD;\n    float cos0 = cos(o);\n    float sin0 = sin(o);\n    return mat3(1.0, 0.0, 0.0, 0.0, cos0, -sin0, 0.0, sin0, cos0);\n}\n\nmat3 RotY(float angle)\n{\n    float o = angle * DEG_TO_RAD;\n    float cos0 = cos(o);\n    float sin0 = sin(o);\n    return mat3(cos0, 0.0, sin0, 0.0, 1.0, 0.0, -sin0, 0.0, cos0);\n}\n\nmat3 RotZ(float angle)\n{\n    float o = angle * DEG_TO_RAD;\n    float cos0 = cos(o);\n    float sin0 = sin(o);\n    return mat3(cos0, -sin0, 0.0, sin0, cos0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// Sphere (r radius)\nfloat SphereD(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat InfCylinderD(vec3 p, vec3 c)\n{\n    // Flipped to get the inside of the cylinder\n    return c.z - length(c.xy - p.xy );\n}\n\n// Box\nfloat BoxD(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Triangular prism (h.x hight, h.y length)\nfloat TriPrismD(vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(\n      q.z - h.y,\n      max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5\n  );\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) \n{ \n    p = fract(p * 0.011); \n    p *= p + 7.5; \n    p *= p + p; \n    return fract(p); \n}\n\nfloat ValueNoise1D(float x) \n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n// https://www.shadertoy.com/view/4sfGzS\nfloat ValueNoise3D(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod(iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat Fbm(vec3 p)\n{\n    float n = ValueNoise3D(p * 1.0) * 1.0;\n    n += ValueNoise3D(p * 2.4) * 0.55; \n    n += ValueNoise3D(p * 5.84) * 0.3025;\n    return n / 1.8525;\n}\n\nfloat ScaleNorm(vec3 s)\n{\n    return min(min(s.x, s.y), s.z);\n}\n\nfloat StarDestroyerDetail(vec3 p)\n{\n    float n = texture(iChannel0, p.xz * 0.01).r;\n    n *= 0.135;\n    return n;\n}\n\nfloat StarDestroyer(vec3 p)\n{\n    float hullLen = 20.0;\n    float halfHullLen = hullLen * 0.5;\n    float hull = 0.0;\n    {\n        vec3 pHull = RotZ(90.0) *  p;\n        float lenFactor = saturate((p.z + halfHullLen) / hullLen) + 0.025;\n        vec3 hullScale = vec3(lenFactor * 0.5, lenFactor , 1.0);\n        pHull.xyz /= hullScale;\n        pHull = abs(pHull);\n        hull = TriPrismD(pHull, vec2(10.0, halfHullLen)) * ScaleNorm(hullScale);\n    }\n    \n    float hullSmall = 0.0;\n    {\n        float halfHullSmallLen = 5.0;\n        vec3 pHullSmall = RotZ(90.0) *  (p - vec3(0.0,1.0,2.0));\n        float lenFactor = saturate((p.z + halfHullSmallLen) / hullLen) + 0.025;\n        vec3 hullScale = vec3(lenFactor * 0.7, lenFactor , 1.0);\n        pHullSmall.xyz /= hullScale;\n        pHullSmall = abs(pHullSmall);\n        hullSmall = TriPrismD(pHullSmall, vec2(10.0, halfHullSmallLen)) * ScaleNorm(hullScale);\n    }\n    \n    float bridgeNeck = 0.0;\n    {\n        vec3 bridgeP = p - vec3(0.0, 3.0, halfHullLen - 0.8);\n        bridgeNeck = BoxD(bridgeP, vec3(0.8, 2.5, 0.8));\n    }\n    \n    float bridgeHead = 0.0;\n    {\n        vec3 bridgeP = p - vec3(0.0, 4.5, halfHullLen - 0.8);\n        float yx = max(1.0 - abs(p.x / 3.0), 0.45);\n        bridgeHead = BoxD(bridgeP, vec3(4.0, 0.9 * yx, 0.8));\n    }\n    \n    float radarSphere = 0.0;\n    {\n        vec3 radarP = p;\n        radarP.x = abs(radarP.x);\n        radarP -=vec3(3.0, 5.3, halfHullLen - 0.8);\n        radarSphere = SphereD(radarP, 0.8);\n    }\n    \n    return min(min(hull,hullSmall), min(min(bridgeNeck, bridgeHead), radarSphere)) \n        + StarDestroyerDetail(p);\n}\n\nfloat SceneDistance(vec3 p)\n{\n    return StarDestroyer(p);\n}\n\nvec3 SceneNormal(vec3 p)\n{\n    vec2 delta = vec2(k_HitDelta, 0.0);\n    return normalize(vec3(\n        SceneDistance(p + delta.xyy) - SceneDistance(p - delta.xyy),\n        SceneDistance(p + delta.yxy) - SceneDistance(p - delta.yxy),\n        SceneDistance(p + delta.yyx) - SceneDistance(p - delta.yyx)\n    ));\n}\n\nfloat March(vec3 ro, vec3 rd)\n{\n    float dist = k_Near;\n    vec3 p = ro + rd * dist;\n    for(int i = 0; i < k_MainSteps; ++i)\n    {\n        float curDist = SceneDistance(p);\n        if(((curDist) < k_HitDelta) || (dist >= k_Far))\n        {\n            return dist;\n        }\n        dist += curDist;\n        p = ro + rd * dist;\n    }\n    return k_Far;\n}\n\nvec4 GetThunderActivation()\n{\n    vec4 act;\n    act.x = pow(abs(max(ValueNoise1D(iTime * 12.0), 0.0)-0.2), 5.0);\n    act.y = pow(abs(max(ValueNoise1D((iTime  - 10.0)* 12.0), 0.0)-0.2), 10.0);\n    act.z = pow(abs(max(ValueNoise1D((iTime  + 10.0) * 12.0), 0.0)-0.1), 10.0);\n    act.w = saturate(pow(abs(sin(iTime * 7.0) * cos(iTime * 3.0)), 1.0) + 0.5);\n    return act;\n}\n\nvec3 CumputePointLight(vec3 lightPosition, float lightRadius, vec3 lightColor, vec3 position, vec3 normal, vec3 baseColor)\n{\n    vec3 toLight = lightPosition - position;\n    vec3 l = normalize(toLight);\n    float dist = length(toLight);\n    float atten = saturate(1.0 - (dist / lightRadius));\n    atten *= atten;\n    float NdotL = max(dot(normal, l), 0.0);\n    return (baseColor / PI) * lightColor * atten * NdotL;\n}\n\nvec3 ShadeScene(vec3 ro, vec3 rd, float d)\n{\n    vec3 radiance = vec3(0.0);\n    \n    vec3 position = ro + rd * d;\n    vec3 normal = SceneNormal(position);\n    \n    vec3 colA = vec3(0.8);\n    vec3 colB = vec3(0.7);\n    vec3 baseColor = mix(colA, colB, texture(iChannel0, position.xy * 0.2).r);\n    \n    vec4 thunderAct = GetThunderActivation();\n    vec3 directLight = vec3(0.0);\n#if THUNDER\n    directLight += CumputePointLight(\n        k_Thunder0, k_ThunderRadius, k_ThunderColor, position, normal, baseColor\n    ) * thunderAct.x * 10.0;\n    directLight += CumputePointLight(\n        k_Thunder1, k_ThunderRadius, k_ThunderColor, position, normal, baseColor\n    ) * thunderAct.y * 10.0;\n    directLight += CumputePointLight(\n        k_Thunder2, k_ThunderRadius, k_ThunderColor, position, normal, baseColor\n    ) * thunderAct.z * 10.0;\n#endif\n    directLight += CumputePointLight(\n        k_Sun, k_SunRadius, k_SunColor * 25.0, position, normal, baseColor\n    ) * thunderAct.w;\n    \n    vec3 indirect = (k_CloudAlbedo * 0.05) * (baseColor / PI);\n    vec3 litColor = directLight + indirect;\n    \n    vec3 fogColor = vec3(0.01);\n    float fogIntensity = saturate(d / 50.0);\n    fogIntensity *= fogIntensity;\n    \n    return mix(litColor, fogColor, fogIntensity);\n}\n\nfloat CloudMask(vec3 p)\n{\n    float pz = max(p.z + 20.0, 0.0);\n    pz *= p.z;\n    p.x += (pz) * 0.01;\n    p.y -= (pz) * 0.007;\n    float cylRadius = 8.0;\n    float dist = InfCylinderD(p, vec3(0.0, 4.0, cylRadius));\n    float mask = saturate((1.0 - (dist/ cylRadius)) - 0.35);\n    return dist < 0.0 ? 1.0 : mask;\n}\n\nfloat GetCloudDensity(vec3 p)\n{\n    float mask = CloudMask(p);\n    p.z -= iTime * 0.25;\n    p.x += iTime * 0.05;\n    float density = saturate(Fbm(p * 0.3) - 0.25);\n    return density * mask;\n}\n\nvec4 ShadeClouds(vec3 ro, vec3 rd, float scene)\n{\n    vec3 cloudColor = vec3(0.0);\n    float absorption = 2.5;\n    float powderBeta = 1.035;\n    float powderAmmount = 1.151;\n    float transmittance = 1.0;\n    float opacity = 0.0;\n    float stepSize = 0.8;\n    float dist = 0.0;\n        \n    for(int i = 0; i < 128; ++i)\n    {\n        vec3 curPos = ro + rd * dist;\n        \n        float density = GetCloudDensity(curPos);\n        float transmitCoef = density * absorption;\n        float powderCoef = density * powderBeta;\n        float beer = exp(-transmitCoef * stepSize);\n        transmittance *= beer;\n        \n        if(transmittance < 0.01 || dist >= scene) \n        {\n            break;\n        }\n        \n        float powder = 1.0 - saturate(exp(-powderCoef * stepSize * 2.0) * powderAmmount);\n        cloudColor += transmittance * k_CloudAlbedo * powder;\n        \n        // Apply thunder:\n        vec4 thunderAct = GetThunderActivation();\n#if THUNDER\n        cloudColor += CumputePointLight(\n            k_Thunder0, k_ThunderRadius, k_ThunderColor, curPos, normalize(k_Thunder0 - curPos), k_CloudAlbedo\n        ) * density * 300.0 * transmittance * thunderAct.x;\n        cloudColor += CumputePointLight(\n            k_Thunder1, k_ThunderRadius, k_ThunderColor, curPos, normalize(k_Thunder1 - curPos), k_CloudAlbedo\n        ) * density * 500.0 * transmittance * thunderAct.y;\n        cloudColor += CumputePointLight(\n            k_Thunder2, k_ThunderRadius, k_ThunderColor, curPos, normalize(k_Thunder2 - curPos), k_CloudAlbedo\n        ) * density * 100.0 * transmittance * thunderAct.z;\n#endif\n         cloudColor += CumputePointLight(\n            k_Sun, k_SunRadius, k_SunColor, curPos, normalize(k_Sun - curPos), k_CloudAlbedo\n        ) * density * 3.0 * transmittance * thunderAct.w;\n        \n        // Ambient'ish term\n        cloudColor += k_CloudAlbedo * 0.001;\n        \n        opacity = opacity + (1.0 - beer) * (1.0 - opacity);\n        dist += stepSize;\n    }\n    \n    return vec4(cloudColor, opacity);\n}\n\nmat3 LookAt(vec3 origin, vec3 target, float roll) \n{\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 GetCamPos()\n{\n    float t = iTime * 0.3;\n    vec3 ro;\n    ro.x = sin(t) + 2.0;\n    ro.y = cos(t) + 3.0;\n    ro.z = -25.0;\n    \n    if(iMouse.z > 0.0)\n    {\n        ro.x = ((iMouse.x / iResolution.x) * 2.0 - 1.0) * 10.0;\n        ro.y = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * -10.0;\n    }\n    return ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    ndc.x *= aspect;\n    \n    // Setup camera:\n    vec3 ro = GetCamPos();    \n    mat3 view = LookAt(ro, vec3(0.0), 0.0);\n    vec3 rd = normalize(view * vec3(ndc, 1.3));\n    \n    // Shade the scene:\n    float sceneDist = March(ro, rd);\n    vec3 sceneColor = vec3(0.0); \n    if(sceneDist < k_Far)\n    {\n        sceneColor = ShadeScene(ro, rd, sceneDist);\n    }\n    // Shade and composite clouds:\n    vec4 clouds = ShadeClouds(ro, rd, sceneDist);\n    sceneColor = (sceneColor * (1.0 - clouds.a)) + clouds.rgb * clouds.a;\n    \n    \n    // Post:\n    fragColor.rgb = sceneColor;\n    float v = 1.0 - (length(uv * 2.0 - 1.0) / 1.4);\n    fragColor.rgb *= sqrt(v);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[959, 959, 984, 984, 1018], [1020, 1020, 1044, 1044, 1197], [1199, 1199, 1223, 1223, 1376], [1378, 1378, 1402, 1402, 1555], [1557, 1578, 1610, 1610, 1638], [1640, 1640, 1676, 1725, 1766], [1768, 1775, 1803, 1803, 1898], [1900, 1944, 1977, 1977, 2090], [2092, 2133, 2155, 2155, 2243], [2245, 2245, 2275, 2275, 2407], [2409, 2450, 2478, 2478, 2684], [2686, 2686, 2705, 2705, 2855], [2857, 2857, 2882, 2882, 2920], [2922, 2922, 2957, 2957, 3038], [3040, 3040, 3069, 3069, 4661], [4663, 4663, 4692, 4692, 4723], [4725, 4725, 4751, 4751, 5034], [5036, 5036, 5067, 5067, 5390], [5392, 5392, 5421, 5421, 5761], [5763, 5763, 5887, 5887, 6179], [6181, 6181, 6225, 6225, 7441], [7443, 7443, 7468, 7468, 7756], [7758, 7758, 7789, 7789, 7950], [7952, 7952, 8001, 8001, 9977], [9979, 9979, 10031, 10031, 10222], [10224, 10224, 10242, 10242, 10536], [10538, 10538, 10595, 10595, 11434]], "test": "untested"}
{"id": "tl3yzN", "name": "serg4", "author": "serega09", "description": "1", "tags": ["1"], "likes": 12, "viewed": 1234, "published": 3, "date": "1608568387", "time_retrieved": "2024-07-30T20:28:53.162044", "image_code": "// Fork of \"♫ Neuron proximitors \" by patu. https://shadertoy.com/view/XlsBDj\n// 2020-10-08 16:50:18\n\n// Fork of \"Buffer computed points.\" by patu. https://shadertoy.com/view/XllBRj\n// http://bit.ly/shadertoy-plugin\n\nfloat SqDistancePtSegment( vec2 a, vec2 b, vec2 p )\n{\n    vec2 \n        pa = p - a, \n        ba = b - a,\n    \td = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    \n    return dot(d, d);\n}\n\nvoid mainImage( out vec4 F, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x += .75;\n    \n\tF -= F;\n    \n    vec2 u = uv;    \n    \n    for (int y = 0; y < 64; y++) {\n        vec4 c1 = texelFetch(iChannel0, ivec2(0, y), 0); // data from bufA 1st column\n        vec4 c2 = texelFetch(iChannel0, ivec2(1, y), 0); // data from bufA 2nd column \n        \n        // bufA column 3 contains volume data\n        float volc = round(pow(texelFetch(iChannel0, ivec2(2, y), 0).r, 4.) * 1.7) * c2.w * 2.;\n        \n        F = mix(F, abs(c1.xyzx) * 1.1 * volc, smoothstep(0., 1., 1. / length(uv - c1.xy) * .008));\n        F = mix(F, abs(c2.xyzx) * 1.1 * volc, smoothstep(0., 1., 1. / length(uv - c2.xy) * .005));\n        \n        F += abs(c1.xyzx) * .4 * volc * smoothstep(0., 1., 1. / length(uv - c1.xy) * .15) * .1;\n        \n        // segment\n        F = mix(F, abs(mix(c1.xyzw, c2.xyzx, .5)) * volc, (1. - smoothstep(0.0, .00001, SqDistancePtSegment(c1.xy, c2.xy, uv))) * 1.);        \n    }    \n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float hash12(vec2 p) {\n\tfloat h = dot(p , vec2(127.1,311.7));\t\n    return fract(abs(sin(h)*43758.5453123));\n}\n\nvoid mainImage(out vec4 C, in vec2 fragCoord)\n{\n    C = vec4(-.5);\n    \n    // buffer texure\n    \n    if (int(fragCoord.y) < 64) {\n        \n        float vol = texelFetch(iChannel1, ivec2(fragCoord.y * 2., 0), 0).r;\n        \n        // first column -- position\n        if (int(fragCoord.x) == 0) {        \n\n            if (iFrame == 0) {            \n\n                // initial position\n                C.x = (hash12(fragCoord.xy) / 2. - .5) + .75;\n                C.y = (hash12(fragCoord.yx) / 2. - .5) * 2.;\n\t\t\t\t\n                // initial speed vector\n                C.z = (hash12(fragCoord.xy * C.xy) / 2. - .5) * 2.;\n                C.w = (hash12(C.xy * 1000.+ iDate.w * 100.) / 2. - .5) * 4.;\n\n            } else {\n                \n\t\t\t    // previous frame\n                C = texelFetch(iChannel0, ivec2(fragCoord.xy), 0) - .5;  \n                C.xy += (C.zw) * 0.01;\n\t\t\t\tC += .5;\n            }\n\n        }\t\n        \n        // second column -- nearest point position\n        if (int(fragCoord.x) == 1) {\n            float minDist = 2.;\n            \n            vec4 G = texelFetch(iChannel0, ivec2(0, fragCoord.y), 0); // 1st column \n            vec4 P = texelFetch(iChannel0, ivec2(fragCoord.xy), 0); // 2nd column previous value \n            \n            C = G;\n            \n            // test all values stored in 1st column.\n            for (int i = 0; i < 64; i++) {\n            \tvec4 H = texelFetch(iChannel0, ivec2(0, i), 0);\n                float d = distance(G.xy, H.xy);\n                \n                if (d < minDist) {\n                    if (d < 1. - vol) {\n                        C.xy = H.xy;\n                        minDist = d;\n                        if (dot(G.xy, C.xy) > .5) {\n                            C.w = 1.;   \n                        }\n                        break;\n                    } else {\n                        C.xy = G.xy;   \n                    }\n                }\n            }\n            \n            C.w -= 0.1;\n            C.w = max(C.w, 0.);\n        }\n        \n        // third column - copy of sound texture \n        if (int(fragCoord.x) == 2) {\n            C.r = vol;\n        }\n        \n        C = fract(C);\n    }\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 272, 272, 413], [415, 415, 464, 464, 1486]], "test": "untested"}
{"id": "wlccRN", "name": "serg3", "author": "serega09", "description": "1", "tags": ["1"], "likes": 10, "viewed": 629, "published": 3, "date": "1608566825", "time_retrieved": "2024-07-30T20:28:54.156385", "image_code": "#define BEATMOVE 1\n\nconst float FREQ_RANGE = 128.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.5;\nconst float BRIGHTNESS = 0.15;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 color){\n    vec4 konvert = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 calc = abs(fract(color.xxx + konvert.xyz) * 6.0 - konvert.www);\n    return color.z * mix(konvert.xxx, clamp(calc - konvert.xxx, 0.0, 1.0), color.y);\n}\n\nfloat luma(vec3 color) {\n  //return dot(color, vec3(0.299, 0.587, 0.114));\n  return dot(color, vec3(0.299, 0.587, 0.5));\n}\n\nfloat getFrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getFrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getFrequency(index), getFrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getFrequency_blend(float x) {\n    return mix(getFrequency(x), getFrequency_smooth(x), 0.5);\n}\n\nvec3 circleIllumination(vec2 fragment, float radius) {\n\tfloat distance = length(fragment);\n\tfloat ring = 1.0 / abs(distance - radius - (getFrequency_smooth(0.0)/4.50));\n\t\n\t//float brightness = distance < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcolor += hsv2rgb( vec3( ( angle + iTime * 2.5 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * BRIGHTNESS;\n\t\n\tfloat frequency = max(getFrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcolor *= frequency;\n\t\n\t// Black halo\n\t//color *= smooth//step(radius * 0.5, radius, distance);\n\t\n\treturn color;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getFrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n\tcolor += circleIllumination(fragPos, RADIUS);\n    \n    \n    \n    color += max(luma(color) - 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlccRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 181, 206, 206, 423], [425, 425, 449, 499, 547], [549, 549, 578, 578, 671], [673, 673, 709, 709, 920], [922, 922, 957, 957, 1021], [1023, 1023, 1077, 1077, 1627], [1629, 1629, 1680, 1680, 1932], [1934, 1934, 1991, 1991, 2311]], "test": "untested"}
{"id": "tl3yRN", "name": "basico rostro 2d", "author": "jorge2017a1", "description": "basico rostro 2d", "tags": ["basicorostro2d"], "likes": 1, "viewed": 250, "published": 3, "date": "1608564227", "time_retrieved": "2024-07-30T20:28:55.351191", "image_code": "//por jorge2017a1\n//recursos\n//https://iquilezles.org/articles/distfunctions2d\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{ if (d1.x<d2.x) return d1;   else return d2; }\n\nvec2 opS2( vec2 d1, vec2 d2 )\n{ if  (-d1.x<d2.x) return d1;  else  return d2;}\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{ if (d1.x>d2.x) return d1; else return d2;}\n\nvec2 opS(vec2 d1, vec2 d2) \n{ return vec2(max(-d2.x, d1.x), 2.0); }\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q; }\n\nfloat sdCirc(vec2 p, float r)\n{  return length(p)-r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\n\nvec2 rostro(vec2 p)\n{   p.y-=0.1;\n    float sPelo1= sdCirc(p-vec2(-0.5,0.0), 0.3);\n    float sPelo2= sdCirc(p-vec2(-0.6,-0.4), 0.28);\n    float sPelo3= sdCirc(p-vec2(-0.3,-0.4), 0.25);\n    float sPelo4= sdCirc(p-vec2(-0.4,-0.7), 0.26);\n    float sPelo5= sdCirc(p-vec2(-0.1,0.3), 0.35);\n    float sPelo6= sdCirc(p-vec2(0.3,0.25), 0.3);\n    float sRostro= sdCirc(p-vec2(0.1,-0.2), 0.4);\n    vec2 p2=p;\n    p2.x=p2.x-1.6;     p2.y=p2.y-0.1;\n    float sOjo1A= sdUnevenCapsule( p2-vec2(-1.5,-0.5), 0.01, 0.1, 0.2 );\n    float sOjo2A= sdUnevenCapsule( p2-vec2(-1.5,-0.52), 0.01, 0.1, 0.18 );\n    float sb1A= sdBox(p2-vec2(-1.5,-0.43), vec2(0.13,0.13) );\n    float posxb=-1.25;\n    float sOjo1B= sdUnevenCapsule( p2-vec2(posxb,-0.5), 0.01, 0.1, 0.2 );\n    float sOjo2B= sdUnevenCapsule( p2-vec2(posxb,-0.52), 0.01, 0.1, 0.18 );\n    float sb1B= sdBox(p2-vec2(posxb,-0.43), vec2(0.13,0.13) );\n    float posBocaY=0.035*sin(iTime);\n    float sBocaA= sdCirc(p-vec2(0.22,-0.4+posBocaY), 0.1);\n    float sBocaB= sdCirc(p-vec2(0.22,-0.3+posBocaY), 0.15);\n    sRostro=opS(sPelo1,sRostro);\n    sRostro=opS(sPelo2,sRostro);\n    sRostro=opS(sPelo3,sRostro);\n    sOjo1A=opS(sOjo2A,sOjo1A);\n    sOjo1A=opS(sb1A,sOjo1A);\n    sRostro=opS(sOjo1A,sRostro);\n    sOjo1B=opS(sOjo2B,sOjo1B);\n    sOjo1B=opS(sb1B,sOjo1B);\n    sRostro=opS(sOjo1B,sRostro);\n    sBocaA=opS(sBocaB, sBocaA);\n    sRostro=opS(sBocaA,sRostro);\n    vec2 resp=vec2(9999.9,-1.0);\n    resp=opU2(resp, vec2( sRostro, 1.0) );\n    resp=opU2(resp, vec2( sPelo1, 0.0) );\n    resp=opU2(resp, vec2( sPelo2, 0.0) );\n    resp=opU2(resp, vec2( sPelo3, 0.0) );\n    resp=opU2(resp, vec2( sPelo4, 0.0) );\n    resp=opU2(resp, vec2( sPelo5, 0.0) );\n    resp=opU2(resp, vec2( sPelo6, 0.0) );\n    resp=opU2(resp, vec2( sOjo1A, 0.0) );\n    resp=opU2(resp, vec2( sOjo1B, 0.0) );\n    resp=opU2(resp, vec2( sBocaA, 2.0) );\n    return resp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n     \n\tvec3 col = vec3(0.280,0.320,1.0);\n    \n    vec2 c=vec2(2.5,10.);\n    vec2 pr= opRep2D( p+ vec2(iTime*0.125,0.0),  c );\n    vec2 r1= rostro(pr);\n    col= DibujoConBordeVec2(p, r1,col);\n    \n    fragColor = vec4(col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{ vec3 color; };\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.  //37 //marron o cafe\n\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\nvec3 getColorf(float ii)\n{\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 DibujoConBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nvec3 DibujoSinBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    //colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    colOut = mix(colOut, colIn, uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 rotate2d(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);  float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 DibujoConBordeVec2(vec2 uv, vec2 vdist,   vec3 colOut)\n{   \n    vec3 colIn=getColorf(vdist.y); //color\n    float dist=vdist.x; //distancia\n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 256, 256, 278], [279, 279, 312, 312, 334], [335, 335, 368, 368, 389], [392, 392, 424, 424, 470], [472, 472, 503, 503, 550], [552, 552, 584, 584, 627], [629, 629, 658, 658, 696], [698, 698, 736, 736, 780], [782, 782, 813, 813, 836], [838, 838, 875, 875, 948], [951, 951, 972, 972, 2813], [2815, 2815, 2872, 2922, 3259]], "test": "untested"}
{"id": "tt3yRN", "name": "Fourier visualization w.i.p", "author": "moolet", "description": "visualization of a 2d fourier, \n\nwork in progress!!", "tags": ["fourier", "cannabis"], "likes": 1, "viewed": 321, "published": 3, "date": "1608561998", "time_retrieved": "2024-07-30T20:28:56.445266", "image_code": "// Sparkling Cookie\n// https://cookie.paris/\n// Leon Denise (ponk) 2019.08.30\n// Licensed under hippie love conspiracy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Sparkling Cookie\n// https://cookie.paris/\n// Leon Denise (ponk) 2019.08.30\n// Licensed under hippie love conspiracy\n\n// tweak zone\nconst float count = 15.;\nfloat scale = .9;\nfloat thin = 0.002;\nfloat ditherRange = .5;\nfloat radiusVariation = .005;\nfloat variationFrequecy = 16.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = .6*(fragCoord-.5*iResolution.xy)/iResolution.y;//+vec2(.0125,.0125);\n\n    vec2 end = vec2(0.0,0.0);\n    vec2 end2 = vec2(0.0,0.0);\n    bool inACircumference1 = false;\n    bool inACircumference2 = false;\n    bool isonALine = false;\n    float isOnALineIteration = 0.0;\n    bool inACenter = false;\n    \n    for (int i=0; i<iterations; i++) {\n        vec2 pos = cookieX(iTime, i)/100.0;\n        vec2 pos2 = cookieY(iTime, i)/100.0;\n             \n        vec2 lastEnd = end;\n        vec2 lastEnd2 = end2;\n        \n        end += pos;\n        end2 += pos2;\n        \n        if (!inACenter)\n          inACenter = inCircle(uv, lastEnd, 0.0005);\n\n        if (!inACenter)\n          inACenter = inCircle(uv, lastEnd2, 0.0005);\n\n        float amp = fourierX[i].amp / (100.0/size_factor);\n        float amp2 = fourierY[i].amp / (100.0/size_factor);\n        \n        if (!inACircumference1)\n          inACircumference1 = inCircumference(uv, lastEnd, amp - 0.0002, amp + 0.0002); \n        \n        if (!inACircumference2)\n          inACircumference2 = inCircumference(uv, lastEnd2, amp2 - 0.0002, amp2 + 0.0002); \n        \n        \n\n        if (!isonALine) {\n          isonALine = onALine(lastEnd, end, uv, 0.00025);\n        }\n        if (!isonALine) {\n          isonALine = onALine(lastEnd2, end2, uv, 0.00025);\n        }  \n        if (isonALine) {\n              isOnALineIteration = float(i);\n        }\n    }\n    \n    if (inACenter) {\n      fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      return;\n    }\n    \n    if (inACircumference1) {\n      fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n      return;\n    }\n    if (inACircumference2) {\n      fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n      return;\n    }\n    \n    if (isonALine) {\n      fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n      return;\n    }    \n    \n    if (uv.x > end.x - 0.001 && uv.x < end.x + 0.001) {\n      fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n      return;\n    }\n    \n    if (uv.y > end2.y - 0.001 && uv.y < end2.y + 0.001) {\n      fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n      return;\n    }\n    \n    fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    //fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\nconst float size_factor = 0.1;\nconst int iterations = 170;\n\nstruct Data\n{\n  float freq;\n  float amp;\n  float phase;\n};\n\n\nData fourierX[170] = Data[170](    \n   Data( -1.0,\t\t\t69.2008084909855,\t\t\t-2.4403277692655174),\n    Data( 1.0,\t\t\t69.20080849098497,\t\t\t2.4403277692657914),\n    Data( -6.0,\t\t\t12.251797005120302,\t\t\t2.6213702343184933),\n    Data( 6.0,\t\t\t12.251797005119094,\t\t\t-2.6213702343183383),\n    Data( 4.0,\t\t\t7.147274116426511,\t\t\t-1.224961706805486),\n    Data( -4.0,\t\t\t7.147274116426462,\t\t\t1.2249617068053773),\n    Data( 8.0,\t\t\t6.479345440556433,\t\t\t2.2571880180201447),\n    Data( -8.0,\t\t\t6.479345440556108,\t\t\t-2.2571880180201864),\n    Data( 7.0,\t\t\t6.205334211057381,\t\t\t1.3814370801292375),\n    Data( -7.0,\t\t\t6.20533421105694,\t\t\t-1.3814370801292382),\n    Data( -11.0,\t\t\t5.596649528484625,\t\t\t-1.713574579754429),\n    Data( 11.0,\t\t\t5.5966495284845825,\t\t\t1.7135745797543585),\n    Data( 3.0,\t\t\t4.770159064403402,\t\t\t1.0633840562073618),\n    Data( -3.0,\t\t\t4.770159064401015,\t\t\t-1.0633840562073216),\n    Data( 10.0,\t\t\t3.99254590417662,\t\t\t0.8460110741099989),\n    Data( -10.0,\t\t\t3.992545904176295,\t\t\t-0.8460110741097976),\n    Data( -2.0,\t\t\t3.808432833225127,\t\t\t2.9951614398794897),\n    Data( 2.0,\t\t\t3.808432833220635,\t\t\t-2.995161439878719),\n    Data( -12.0,\t\t\t3.65851629688175,\t\t\t-2.5690352678453285),\n    Data( 12.0,\t\t\t3.6585162968801836,\t\t\t2.569035267845671),\n    Data( -14.0,\t\t\t2.3449921907955495,\t\t\t-1.2247562661702984),\n    Data( 14.0,\t\t\t2.344992190795247,\t\t\t1.2247562661703113),\n    Data( -5.0,\t\t\t2.1989253235385307,\t\t\t-2.7978048776915756),\n    Data( 5.0,\t\t\t2.198925323537799,\t\t\t2.797804877691702),\n    Data( 18.0,\t\t\t1.3335145771918824,\t\t\t-1.664499961273363),\n    Data( -18.0,\t\t\t1.3335145771918566,\t\t\t1.6644999612735436),\n    Data( -17.0,\t\t\t1.2327667429998548,\t\t\t2.564784161266749),\n    Data( 17.0,\t\t\t1.2327667429996003,\t\t\t-2.5647841612660716),\n    Data( 27.0,\t\t\t1.144082528135724,\t\t\t-0.0031701256557761636),\n    Data( -27.0,\t\t\t1.1440825281356022,\t\t\t0.003170125655494671),\n    Data( 16.0,\t\t\t1.059329175462445,\t\t\t-0.07526081986761093),\n    Data( -16.0,\t\t\t1.0593291754612058,\t\t\t0.07526081986745027),\n    Data( -28.0,\t\t\t1.007292976061883,\t\t\t-0.859176805339215),\n    Data( 28.0,\t\t\t1.007292976061752,\t\t\t0.8591768053392645),\n    Data( 15.0,\t\t\t0.8712157455596117,\t\t\t2.015007627466402),\n    Data( -15.0,\t\t\t0.8712157455595354,\t\t\t-2.0150076274663475),\n    Data( 23.0,\t\t\t0.7461462837617063,\t\t\t-0.48904974486523134),\n    Data( -23.0,\t\t\t0.7461462837603837,\t\t\t0.4890497448673186),\n    Data( 9.0,\t\t\t0.6938308009111527,\t\t\t0.014629423309141671),\n    Data( -9.0,\t\t\t0.6938308009083306,\t\t\t-0.014629423309481051),\n    Data( -13.0,\t\t\t0.644783377090706,\t\t\t2.9639115724641503),\n    Data( 13.0,\t\t\t0.6447833770898307,\t\t\t-2.963911572463342),\n    Data( 20.0,\t\t\t0.6072964627667031,\t\t\t0.23339326072137725),\n    Data( -20.0,\t\t\t0.607296462766389,\t\t\t-0.23339326072116248),\n    Data( 24.0,\t\t\t0.598124495937591,\t\t\t0.37634807156893324),\n    Data( -24.0,\t\t\t0.5981244959366907,\t\t\t-0.3763480715692308),\n    Data( -22.0,\t\t\t0.5865726385042156,\t\t\t1.4164422838330974),\n    Data( 22.0,\t\t\t0.5865726385039164,\t\t\t-1.4164422838331971),\n    Data( 33.0,\t\t\t0.555227138277511,\t\t\t-1.0023039967135314),\n    Data( -33.0,\t\t\t0.5552271382774846,\t\t\t1.0023039967136584),\n    Data( 25.0,\t\t\t0.4912322459843405,\t\t\t1.2257046462887455),\n    Data( -25.0,\t\t\t0.4912322459843156,\t\t\t-1.2257046462906858),\n    Data( -49.0,\t\t\t0.41785406815472,\t\t\t2.8527429952095527),\n    Data( 49.0,\t\t\t0.4178540681543441,\t\t\t-2.852742995208766),\n    Data( -29.0,\t\t\t0.3828328587202293,\t\t\t1.41294405522611),\n    Data( 29.0,\t\t\t0.3828328587199359,\t\t\t-1.412944055225513),\n    Data( -47.0,\t\t\t0.36570352211759066,\t\t\t1.5249738345742392),\n    Data( 47.0,\t\t\t0.36570352211734414,\t\t\t-1.5249738345728425),\n    Data( 36.0,\t\t\t0.3366074152788767,\t\t\t-1.6872741798986783),\n    Data( -36.0,\t\t\t0.33660741527876437,\t\t\t1.6872741798991027),\n    Data( -42.0,\t\t\t0.31847123076270206,\t\t\t2.7773043173656116),\n    Data( 42.0,\t\t\t0.3184712307624114,\t\t\t-2.7773043173668563),\n    Data( 57.0,\t\t\t0.2950506784859951,\t\t\t0.85794403387866),\n    Data( -57.0,\t\t\t0.2950506784856082,\t\t\t-0.8579440338788967),\n    Data( 109.0,\t\t\t0.2864652306194673,\t\t\t2.420432639167438),\n    Data( -109.0,\t\t\t0.28646523061937296,\t\t\t-2.4204326391677293),\n    Data( -85.0,\t\t\t0.2703281435181849,\t\t\t-0.220496008453927),\n    Data( 85.0,\t\t\t0.2703281435179557,\t\t\t0.2204960084535132),\n    Data( -46.0,\t\t\t0.2688038678507486,\t\t\t2.4607647353629716),\n    Data( 46.0,\t\t\t0.2688038678507361,\t\t\t-2.460764735361125),\n    Data( -90.0,\t\t\t0.26691822072315596,\t\t\t1.58434689027434),\n    Data( 90.0,\t\t\t0.2669182207218282,\t\t\t-1.584346890271403),\n    Data( -39.0,\t\t\t0.2575393853148227,\t\t\t-0.8003403012384321),\n    Data( 39.0,\t\t\t0.2575393853147317,\t\t\t0.8003403012381345),\n    Data( -97.0,\t\t\t0.2549105644524268,\t\t\t1.8179525152708165),\n    Data( 97.0,\t\t\t0.25491056445227595,\t\t\t-1.8179525152709284),\n    Data( 108.0,\t\t\t0.2508554569742287,\t\t\t-1.7406603677193637),\n    Data( -108.0,\t\t\t0.2508554569741185,\t\t\t1.740660367720814),\n    Data( -93.0,\t\t\t0.24483934271636426,\t\t\t2.3002001715661975),\n    Data( 93.0,\t\t\t0.2448393427161183,\t\t\t-2.3002001715664573),\n    Data( 34.0,\t\t\t0.23926130730641185,\t\t\t0.004228771937002079),\n    Data( -34.0,\t\t\t0.23926130730613798,\t\t\t-0.004228771938156693),\n    Data( -38.0,\t\t\t0.2281375648164417,\t\t\t2.827774801216534),\n    Data( 38.0,\t\t\t0.2281375648161924,\t\t\t-2.827774801215605),\n    Data( 91.0,\t\t\t0.2275477976554989,\t\t\t2.1842291013692714),\n    Data( -91.0,\t\t\t0.227547797655358,\t\t\t-2.184229101370537),\n    Data( 114.0,\t\t\t0.2242161245699898,\t\t\t0.39254164066628544),\n    Data( -114.0,\t\t\t0.2242161245698307,\t\t\t-0.39254164066617636),\n    Data( -94.0,\t\t\t0.2176681498126028,\t\t\t-1.8414387318237357),\n    Data( 94.0,\t\t\t0.2176681498123367,\t\t\t1.84143873182475),\n    Data( -45.0,\t\t\t0.21693456635769504,\t\t\t-2.9191270566476275),\n    Data( 45.0,\t\t\t0.21693456635746153,\t\t\t2.9191270566484926),\n    Data( 30.0,\t\t\t0.19978055229876532,\t\t\t-0.5261344373631028),\n    Data( -30.0,\t\t\t0.19978055229846717,\t\t\t0.5261344373601451),\n    Data( -32.0,\t\t\t0.1919483221718334,\t\t\t1.8359828050214277),\n    Data( 32.0,\t\t\t0.19194832217153987,\t\t\t-1.8359828050188771),\n    Data( 62.0,\t\t\t0.19023048748143173,\t\t\t2.1647432968440716),\n    Data( -62.0,\t\t\t0.1902304874812837,\t\t\t-2.1647432968440308),\n    Data( 50.0,\t\t\t0.1859396805870115,\t\t\t-2.160048238959487),\n    Data( -50.0,\t\t\t0.18593968058680918,\t\t\t2.1600482389626205),\n    Data( 0.0,\t\t\t0.18507295910315838,\t\t\t0.0),\n    Data( 76.0,\t\t\t0.1781473177318734,\t\t\t-1.385423326871277),\n    Data( -76.0,\t\t\t0.178147317731769,\t\t\t1.3854233268703275),\n    Data( -102.0,\t\t\t0.17344091102292172,\t\t\t-2.5018436804328195),\n    Data( 102.0,\t\t\t0.17344091102277742,\t\t\t2.5018436804322723),\n    Data( 54.0,\t\t\t0.16597967429739083,\t\t\t1.4463803498199193),\n    Data( -54.0,\t\t\t0.1659796742971473,\t\t\t-1.4463803498224228),\n    Data( 71.0,\t\t\t0.16050368968594783,\t\t\t0.6531607893170484),\n    Data( -71.0,\t\t\t0.16050368968571851,\t\t\t-0.653160789314777),\n    Data( 103.0,\t\t\t0.15874200690205004,\t\t\t0.3416839083752039),\n    Data( -103.0,\t\t\t0.15874200690151227,\t\t\t-0.3416839083758823),\n    Data( -21.0,\t\t\t0.1544778863706758,\t\t\t-1.6631986427895602),\n    Data( 21.0,\t\t\t0.1544778863701716,\t\t\t1.6631986427914638),\n    Data( -116.0,\t\t\t0.15036733393323604,\t\t\t0.8637636398882478),\n    Data( 116.0,\t\t\t0.15036733393287396,\t\t\t-0.8637636398884533),\n    Data( -111.0,\t\t\t0.14858253074223765,\t\t\t-0.9975349560925866),\n    Data( 111.0,\t\t\t0.14858253074206393,\t\t\t0.9975349560935954),\n    Data( 64.0,\t\t\t0.14111778383873907,\t\t\t0.8799156661961428),\n    Data( -64.0,\t\t\t0.1411177838378886,\t\t\t-0.8799156661952432),\n    Data( -63.0,\t\t\t0.14095923079897252,\t\t\t-3.086914610395199),\n    Data( 63.0,\t\t\t0.14095923079832026,\t\t\t3.0869146103945755),\n    Data( -58.0,\t\t\t0.1403694183807287,\t\t\t-1.5575470272931498),\n    Data( 58.0,\t\t\t0.1403694183807219,\t\t\t1.5575470272932075),\n    Data( -51.0,\t\t\t0.13700124663100985,\t\t\t-2.3568970265918088),\n    Data( 51.0,\t\t\t0.13700124663095054,\t\t\t2.356897026591012),\n    Data( 48.0,\t\t\t0.1365769862705299,\t\t\t-0.6289437524744339),\n    Data( -48.0,\t\t\t0.1365769862678216,\t\t\t0.6289437524667053),\n    Data( 40.0,\t\t\t0.13638606446371265,\t\t\t1.2715976132158806),\n    Data( -40.0,\t\t\t0.1363860644636687,\t\t\t-1.2715976132154962),\n    Data( -65.0,\t\t\t0.134797651116047,\t\t\t-1.701096624251085),\n    Data( 65.0,\t\t\t0.1347976511147395,\t\t\t1.7010966242519352),\n    Data( 35.0,\t\t\t0.12919971543935047,\t\t\t-2.723210633695396),\n    Data( -35.0,\t\t\t0.129199715439343,\t\t\t2.7232106336971817),\n    Data( 117.0,\t\t\t0.12574048515162442,\t\t\t2.9645424602593016),\n    Data( -117.0,\t\t\t0.12574048515159067,\t\t\t-2.9645424602578974),\n    Data( -105.0,\t\t\t0.1250295371855142,\t\t\t1.1561070001329703),\n    Data( 105.0,\t\t\t0.1250295371847451,\t\t\t-1.156107000133482),\n    Data( 84.0,\t\t\t0.12381478454316078,\t\t\t2.5151014088471473),\n    Data( -84.0,\t\t\t0.12381478454246053,\t\t\t-2.5151014088511343),\n    Data( 82.0,\t\t\t0.12286279576191896,\t\t\t0.5435199888217789),\n    Data( -82.0,\t\t\t0.12286279576172554,\t\t\t-0.5435199888220207),\n    Data( 37.0,\t\t\t0.12183930300908266,\t\t\t2.6482382580411374),\n    Data( -37.0,\t\t\t0.12183930300903138,\t\t\t-2.6482382580409194),\n    Data( 107.0,\t\t\t0.12157572062906576,\t\t\t-2.6371938940245903),\n    Data( -107.0,\t\t\t0.12157572062861326,\t\t\t2.6371938940288295),\n    Data( -43.0,\t\t\t0.11871452646408666,\t\t\t1.8356129134015775),\n    Data( 43.0,\t\t\t0.11871452646367697,\t\t\t-1.835612913396511),\n    Data( -83.0,\t\t\t0.11848458875825453,\t\t\t1.4494026052169895),\n    Data( 83.0,\t\t\t0.11848458875796314,\t\t\t-1.4494026052140914),\n    Data( 19.0,\t\t\t0.11686711887972545,\t\t\t2.7133642916818275),\n    Data( -19.0,\t\t\t0.11686711887927126,\t\t\t-2.7133642916829808),\n    Data( -197.0,\t\t\t0.11637693454815891,\t\t\t2.5312816940210174),\n    Data( 197.0,\t\t\t0.11637693454754398,\t\t\t-2.5312816940262284),\n    Data( 101.0,\t\t\t0.11433203764165004,\t\t\t1.579241176742408),\n    Data( -101.0,\t\t\t0.11433203763983538,\t\t\t-1.5792411767456114),\n    Data( 73.0,\t\t\t0.11271108508251668,\t\t\t-0.6024964315443964),\n    Data( -73.0,\t\t\t0.11271108508214053,\t\t\t0.6024964315414695),\n    Data( 41.0,\t\t\t0.112083415756651,\t\t\t0.23201698237676735),\n    Data( -41.0,\t\t\t0.11208341575655394,\t\t\t-0.23201698237670176),\n    Data( 162.0,\t\t\t0.11139927188384362,\t\t\t-1.8923944416037497),\n    Data( -162.0,\t\t\t0.11139927188368519,\t\t\t1.892394441602517),\n    Data( 88.0,\t\t\t0.11021779058626725,\t\t\t-0.05403148309407222),\n    Data( -88.0,\t\t\t0.11021779058435918,\t\t\t0.05403148309908149),\n    Data( -99.0,\t\t\t0.10721258477167342,\t\t\t-3.0898673835472357),\n    Data( 99.0,\t\t\t0.10721258477127946,\t\t\t3.089867383549182),\n    Data( -129.0,\t\t\t0.10697859661708284,\t\t\t2.207104633319914),\n    Data( 129.0,\t\t\t0.10697859661674283,\t\t\t-2.2071046333181545),\n    Data( -100.0,\t\t\t0.10694427630797647,\t\t\t2.2974854528934565),\n    Data( 100.0,\t\t\t0.10694427630761082,\t\t\t-2.2974854528901054),\n    Data( -80.0,\t\t\t0.10551772891135493,\t\t\t1.1996979720998222)\n);\nData fourierY[170] = Data[170](    Data( 1.0,\t\t\t65.31890670125527,\t\t\t0.8651505551174499),\n    Data( -1.0,\t\t\t65.31890670125249,\t\t\t-0.8651505551170989),\n    Data( 0.0,\t\t\t28.555328761474318,\t\t\t3.141592653589793),\n    Data( 4.0,\t\t\t15.584246529832578,\t\t\t0.31786288490473924),\n    Data( -4.0,\t\t\t15.584246529832368,\t\t\t-0.31786288490476755),\n    Data( 5.0,\t\t\t15.048430031517642,\t\t\t-1.952185332809557),\n    Data( -5.0,\t\t\t15.048430031516673,\t\t\t1.9521853328096717),\n    Data( 6.0,\t\t\t10.988876671731964,\t\t\t2.038641278172281),\n    Data( -6.0,\t\t\t10.988876671731296,\t\t\t-2.0386412781720753),\n    Data( 15.0,\t\t\t4.638754781239754,\t\t\t0.40436857734231585),\n    Data( -15.0,\t\t\t4.6387547812396175,\t\t\t-0.4043685773423752),\n    Data( 13.0,\t\t\t3.1579370810506138,\t\t\t-1.3271377309084518),\n    Data( -13.0,\t\t\t3.1579370810506107,\t\t\t1.327137730908613),\n    Data( 3.0,\t\t\t2.8736143983544635,\t\t\t2.580072119931167),\n    Data( -3.0,\t\t\t2.873614398353869,\t\t\t-2.580072119930381),\n    Data( 7.0,\t\t\t2.679168215907155,\t\t\t2.8741861852036976),\n    Data( -7.0,\t\t\t2.679168215907147,\t\t\t-2.874186185203604),\n    Data( -10.0,\t\t\t2.217996965705609,\t\t\t0.8402243856231759),\n    Data( 10.0,\t\t\t2.2179969657055514,\t\t\t-0.8402243856233111),\n    Data( -18.0,\t\t\t1.8207162605502345,\t\t\t-3.0472920038327675),\n    Data( 18.0,\t\t\t1.8207162605501563,\t\t\t3.047292003832855),\n    Data( 25.0,\t\t\t1.4897073875391167,\t\t\t2.7725533981291854),\n    Data( -25.0,\t\t\t1.4897073875379405,\t\t\t-2.7725533981282666),\n    Data( -9.0,\t\t\t1.4265405954265218,\t\t\t1.7271983230678838),\n    Data( 9.0,\t\t\t1.4265405954264065,\t\t\t-1.727198323067721),\n    Data( 8.0,\t\t\t1.2216360646075843,\t\t\t0.8332575770027062),\n    Data( -8.0,\t\t\t1.2216360646075395,\t\t\t-0.8332575770028605),\n    Data( -23.0,\t\t\t1.1833535432602982,\t\t\t-1.0804644433015607),\n    Data( 23.0,\t\t\t1.1833535432578555,\t\t\t1.0804644433016755),\n    Data( 21.0,\t\t\t1.0588323106881905,\t\t\t-0.6032519644052451),\n    Data( -21.0,\t\t\t1.0588323106881357,\t\t\t0.6032519644055018),\n    Data( 19.0,\t\t\t1.040335307226024,\t\t\t-2.364769097237809),\n    Data( -19.0,\t\t\t1.0403353072259292,\t\t\t2.36476909723788),\n    Data( -16.0,\t\t\t1.014776129642542,\t\t\t-1.2614383776205014),\n    Data( 16.0,\t\t\t1.0147761296420157,\t\t\t1.261438377623048),\n    Data( -28.0,\t\t\t0.9554403196159699,\t\t\t0.9071482328312468),\n    Data( 28.0,\t\t\t0.955440319615885,\t\t\t-0.9071482328313146),\n    Data( 11.0,\t\t\t0.8745012316801589,\t\t\t-2.9826823885467624),\n    Data( -11.0,\t\t\t0.8745012316801046,\t\t\t2.982682388547123),\n    Data( -29.0,\t\t\t0.7692646737343826,\t\t\t0.03913431790943747),\n    Data( 29.0,\t\t\t0.769264673734036,\t\t\t-0.039134317909065984),\n    Data( 14.0,\t\t\t0.7601926205703019,\t\t\t-0.4784238318997904),\n    Data( -14.0,\t\t\t0.7601926205702392,\t\t\t0.47842383189996923),\n    Data( 26.0,\t\t\t0.6770445793985159,\t\t\t-2.6478356753547607),\n    Data( -26.0,\t\t\t0.6770445793979386,\t\t\t2.6478356753538974),\n    Data( 17.0,\t\t\t0.6590709797550195,\t\t\t2.0966385116613147),\n    Data( -17.0,\t\t\t0.6590709797548258,\t\t\t-2.096638511660353),\n    Data( -31.0,\t\t\t0.6107435334999121,\t\t\t-1.7228460764486515),\n    Data( 31.0,\t\t\t0.6107435334998523,\t\t\t1.7228460764492557),\n    Data( -40.0,\t\t\t0.4890222970551183,\t\t\t-0.0651920218612492),\n    Data( 40.0,\t\t\t0.4890222970551039,\t\t\t0.06519202186138805),\n    Data( -24.0,\t\t\t0.4768372324548341,\t\t\t-1.947492725545948),\n    Data( 24.0,\t\t\t0.476837232454748,\t\t\t1.9474927255461847),\n    Data( -50.0,\t\t\t0.4233447578057375,\t\t\t-2.329612262052369),\n    Data( 50.0,\t\t\t0.4233447578056912,\t\t\t2.3296122620530695),\n    Data( 27.0,\t\t\t0.38529618631322105,\t\t\t-1.8830790429497732),\n    Data( -27.0,\t\t\t0.3852961863129794,\t\t\t1.883079042951346),\n    Data( -41.0,\t\t\t0.3532730644517214,\t\t\t2.2795956884744872),\n    Data( 41.0,\t\t\t0.35327306445162726,\t\t\t-2.279595688475245),\n    Data( 109.0,\t\t\t0.33186001092302553,\t\t\t0.10164791576222479),\n    Data( -109.0,\t\t\t0.3318600109229166,\t\t\t-0.10164791576162562),\n    Data( -20.0,\t\t\t0.31827016982049233,\t\t\t-1.254232935979429),\n    Data( 20.0,\t\t\t0.31827016982007333,\t\t\t1.2542329359792357),\n    Data( -95.0,\t\t\t0.283990362516922,\t\t\t-0.5345424002831306),\n    Data( 95.0,\t\t\t0.28399036251684234,\t\t\t0.5345424002832788),\n    Data( -96.0,\t\t\t0.2521932235264325,\t\t\t1.7291277745164755),\n    Data( 96.0,\t\t\t0.2521932235264071,\t\t\t-1.7291277745182483),\n    Data( 91.0,\t\t\t0.22817192429016603,\t\t\t0.11282600368112272),\n    Data( -91.0,\t\t\t0.22817192428998606,\t\t\t-0.11282600367932635),\n    Data( 33.0,\t\t\t0.22793401098117602,\t\t\t-2.7727499703691336),\n    Data( -33.0,\t\t\t0.22793401098104846,\t\t\t2.772749970370273),\n    Data( -103.0,\t\t\t0.22460069723749082,\t\t\t-1.2017807603166384),\n    Data( 103.0,\t\t\t0.22460069723673795,\t\t\t1.2017807603165356),\n    Data( -89.0,\t\t\t0.21747778761877906,\t\t\t1.7124193638368796),\n    Data( 89.0,\t\t\t0.21747778761852576,\t\t\t-1.7124193638362275),\n    Data( 55.0,\t\t\t0.2152902408153102,\t\t\t-2.8257693310452017),\n    Data( -55.0,\t\t\t0.2152902408152419,\t\t\t2.8257693310440484),\n    Data( -46.0,\t\t\t0.21283927288626,\t\t\t1.1601795442137033),\n    Data( 46.0,\t\t\t0.2128392728862181,\t\t\t-1.160179544213888),\n    Data( 87.0,\t\t\t0.21250938302898872,\t\t\t2.977503684570063),\n    Data( -87.0,\t\t\t0.21250938302864922,\t\t\t-2.9775036845745317),\n    Data( -67.0,\t\t\t0.21248906352008243,\t\t\t-1.4408860948478193),\n    Data( 67.0,\t\t\t0.21248906352006872,\t\t\t1.440886094849722),\n    Data( -39.0,\t\t\t0.2064073422671597,\t\t\t-2.301154168622928),\n    Data( 39.0,\t\t\t0.20640734226712923,\t\t\t2.301154168622511),\n    Data( 97.0,\t\t\t0.19677024633021953,\t\t\t2.2465252673389537),\n    Data( -97.0,\t\t\t0.19677024632997445,\t\t\t-2.2465252673380407),\n    Data( -72.0,\t\t\t0.19558948988124528,\t\t\t0.5399016852511805),\n    Data( 72.0,\t\t\t0.1955894898811444,\t\t\t-0.5399016852501274),\n    Data( 92.0,\t\t\t0.19399762563866102,\t\t\t-1.998729069350953),\n    Data( -92.0,\t\t\t0.19399762563855494,\t\t\t1.9987290693519308),\n    Data( -51.0,\t\t\t0.18776619431384084,\t\t\t-0.24823340910233666),\n    Data( 51.0,\t\t\t0.1877661943137927,\t\t\t0.2482334091024692),\n    Data( -30.0,\t\t\t0.1818649936144726,\t\t\t2.3823381824874548),\n    Data( 30.0,\t\t\t0.18186499361354905,\t\t\t-2.3823381824868246),\n    Data( -64.0,\t\t\t0.18139073781353415,\t\t\t1.0742464350444643),\n    Data( 64.0,\t\t\t0.181390737812517,\t\t\t-1.0742464350483207),\n    Data( 83.0,\t\t\t0.1801082384688669,\t\t\t2.650694095073279),\n    Data( -83.0,\t\t\t0.18010823846873875,\t\t\t-2.6506940950702407),\n    Data( -34.0,\t\t\t0.17763147886373648,\t\t\t-0.8838371554070873),\n    Data( 34.0,\t\t\t0.17763147886368202,\t\t\t0.8838371554077402),\n    Data( -65.0,\t\t\t0.16899375804443037,\t\t\t0.23130662264184423),\n    Data( 65.0,\t\t\t0.16899375804404773,\t\t\t-0.2313066226383187),\n    Data( -12.0,\t\t\t0.16719290656407776,\t\t\t-0.5958646749624847),\n    Data( 12.0,\t\t\t0.16719290656370597,\t\t\t0.5958646749627651),\n    Data( 36.0,\t\t\t0.165301551472193,\t\t\t2.593097471652781),\n    Data( -36.0,\t\t\t0.1653015514721567,\t\t\t-2.593097471651556),\n    Data( -101.0,\t\t\t0.16486241018174463,\t\t\t0.6442649995861152),\n    Data( 101.0,\t\t\t0.16486241018031197,\t\t\t-0.6442649995912828),\n    Data( 99.0,\t\t\t0.16242695564188767,\t\t\t1.028118953015285),\n    Data( -99.0,\t\t\t0.16242695564180265,\t\t\t-1.0281189530148656),\n    Data( -57.0,\t\t\t0.16138693659225498,\t\t\t0.9756663402128001),\n    Data( 57.0,\t\t\t0.16138693659210607,\t\t\t-0.9756663402112361),\n    Data( -108.0,\t\t\t0.1613555968910301,\t\t\t-2.2761260334632403),\n    Data( 108.0,\t\t\t0.16135559689097062,\t\t\t2.2761260334650033),\n    Data( 37.0,\t\t\t0.15370336439879204,\t\t\t-2.6642683888952647),\n    Data( -37.0,\t\t\t0.15370336439846624,\t\t\t2.664268388898257),\n    Data( 153.0,\t\t\t0.1534195814992547,\t\t\t0.245928497751659),\n    Data( -153.0,\t\t\t0.1534195814990075,\t\t\t-0.2459284977493412),\n    Data( 59.0,\t\t\t0.15324429334076037,\t\t\t0.9297083708227801),\n    Data( -59.0,\t\t\t0.15324429334073614,\t\t\t-0.9297083708221752),\n    Data( 166.0,\t\t\t0.15303297551117534,\t\t\t2.13395646714667),\n    Data( -166.0,\t\t\t0.15303297551116155,\t\t\t-2.133956467147353),\n    Data( -62.0,\t\t\t0.1528580542931282,\t\t\t2.6301186944880137),\n    Data( 62.0,\t\t\t0.15285805429308946,\t\t\t-2.630118694486849),\n    Data( -70.0,\t\t\t0.15175775795073887,\t\t\t2.336119074970455),\n    Data( 70.0,\t\t\t0.15175775795063196,\t\t\t-2.3361190749715757),\n    Data( -47.0,\t\t\t0.15091010243710462,\t\t\t0.30971752923640156),\n    Data( 47.0,\t\t\t0.1509101024370587,\t\t\t-0.30971752923453305),\n    Data( -116.0,\t\t\t0.14836231745185818,\t\t\t-2.9378930657823403),\n    Data( 116.0,\t\t\t0.1483623174514922,\t\t\t2.9378930657838094),\n    Data( -102.0,\t\t\t0.14400474143289593,\t\t\t2.8647909864386962),\n    Data( 102.0,\t\t\t0.14400474143287983,\t\t\t-2.8647909864402),\n    Data( 81.0,\t\t\t0.1401700985609577,\t\t\t0.9420817189573863),\n    Data( -81.0,\t\t\t0.1401700985604733,\t\t\t-0.9420817189612183),\n    Data( 77.0,\t\t\t0.13867138764848602,\t\t\t-2.3683667983191103),\n    Data( -77.0,\t\t\t0.13867138764834133,\t\t\t2.368366798319337),\n    Data( -112.0,\t\t\t0.1379201592131512,\t\t\t-2.6216527537609187),\n    Data( 112.0,\t\t\t0.1379201592129405,\t\t\t2.621652753758431),\n    Data( 93.0,\t\t\t0.13582864092193395,\t\t\t1.9831474091215582),\n    Data( -93.0,\t\t\t0.13582864092159,\t\t\t-1.9831474091188024),\n    Data( -129.0,\t\t\t0.13469067950372648,\t\t\t-1.7066075001887269),\n    Data( 129.0,\t\t\t0.13469067950329985,\t\t\t1.7066075001871746),\n    Data( 60.0,\t\t\t0.13055523800779226,\t\t\t-1.7156350558460123),\n    Data( -60.0,\t\t\t0.13055523800773916,\t\t\t1.7156350558467184),\n    Data( 82.0,\t\t\t0.1303020523756822,\t\t\t-1.2450669763635078),\n    Data( -82.0,\t\t\t0.1303020523751821,\t\t\t1.2450669763607656),\n    Data( -32.0,\t\t\t0.1279076173512102,\t\t\t0.8067523204408599),\n    Data( 32.0,\t\t\t0.1279076173511966,\t\t\t-0.8067523204411796),\n    Data( -54.0,\t\t\t0.12552755745365102,\t\t\t-2.6388571278404647),\n    Data( 54.0,\t\t\t0.12552755745339916,\t\t\t2.6388571278489716),\n    Data( -68.0,\t\t\t0.12527791482241438,\t\t\t-2.3052212019670923),\n    Data( 68.0,\t\t\t0.12527791482236947,\t\t\t2.30522120197044),\n    Data( -35.0,\t\t\t0.1221899343625182,\t\t\t0.8929855231166186),\n    Data( 35.0,\t\t\t0.12218993436231938,\t\t\t-0.8929855231162244),\n    Data( 48.0,\t\t\t0.12124018109113456,\t\t\t0.22256070972632697),\n    Data( -48.0,\t\t\t0.12124018109013791,\t\t\t-0.2225607097173212),\n    Data( 61.0,\t\t\t0.11864046532322606,\t\t\t2.730048748599944),\n    Data( -61.0,\t\t\t0.11864046532312944,\t\t\t-2.730048748597761),\n    Data( -78.0,\t\t\t0.11534099878246555,\t\t\t-1.384898794390902),\n    Data( 78.0,\t\t\t0.1153409987824359,\t\t\t1.3848987943925464),\n    Data( 80.0,\t\t\t0.11485493880028479,\t\t\t3.116817698897287),\n    Data( -80.0,\t\t\t0.11485493879988137,\t\t\t-3.1168176988943785),\n    Data( 88.0,\t\t\t0.11438864609893276,\t\t\t0.9429952167264422),\n    Data( -88.0,\t\t\t0.11438864609771926,\t\t\t-0.9429952167226152),\n    Data( -90.0,\t\t\t0.1140853679261941,\t\t\t-2.6789272487719145),\n    Data( 90.0,\t\t\t0.11408536792437504,\t\t\t2.6789272487653095),\n    Data( -22.0,\t\t\t0.11057615697033829,\t\t\t-1.3190357316128372),\n    Data( 22.0,\t\t\t0.1105761569701023,\t\t\t1.3190357316109893),\n    Data( -106.0,\t\t\t0.10439451832635387,\t\t\t2.1136760899953737)\n);\n\n// generated with discrete Fourier transform\nvec2 cookieX(float t, int i) {\n    t = t/10.2400;\n    float freq=fourierX[i].freq;\n    if (freq >= 512.0) {\n      freq = - 1023.0 + freq;\n    }\n    \n    //t = -t;\n    //i = i + 1;\n    return vec2(fourierX[i].amp   * cos(freq  * t + fourierX[i].phase)*size_factor,\n                fourierX[i].amp   * -sin(freq * t + fourierX[i].phase)*size_factor);\n}\n\nvec2 cookieY(float t, int i) {\n    t = t/10.2400;\n    float freq=fourierY[i].freq;\n    if (freq >= 512.0) {\n      freq = - 1023.0 + freq;\n    }\n    \n    //t = -t;\n    //i = i + 1;\n    return vec2(fourierY[i].amp   * sin(freq  * t + fourierY[i].phase)*size_factor,\n                fourierY[i].amp   * -cos(freq * t + fourierY[i].phase)*size_factor);\n}\n\n\nbool inCircle(vec2 pos, vec2 center, float r) {\n  float r2 = pow( pow(center.x - pos.x, 2.0) + pow(center.y - pos.y, 2.0), 0.5);\n  if (r2 < r)\n      return true;\n}\n\nbool inCircumference(vec2 pos, vec2 center, float ra, float rb) {\n  float r = pow( pow(center.x - pos.x, 2.0) + pow(center.y - pos.y, 2.0), 0.5);\n  if (ra < r && r < rb)\n      return true;\n}\n\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 point) {\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    return abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n}\n\nbool onALine(vec2 p1, vec2 p2, vec2 point, float thickness) {\n//    if (point.x < p1.x || point.x > p2.x)\n//      return false;\n    \n    if (p1.x > p2.x) {\n        if (point.x > p1.x || point.x < p2.x)\n          return false;\n    } else\n    {\n        if (point.x > p2.x || point.x < p1.x)\n          return false;\n    }\n    \n    if (p1.y > p2.y) {\n        if (point.y > p1.y || point.y < p2.y)\n          return false;\n    } else\n    {\n        if (point.y > p2.y || point.y < p1.y)\n          return false;\n    }\n    \n    //    if (point.x > p2.x || point.x < p1.x)\n    //      return false;\n    //if (point.x < p1.x || point.y < p1.y)\n    //  return false;\n     \n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    \n    float d = abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n    \n    if (d < thickness)\n        return true;\n\n    return false;\n}\n\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    vec2 uv = 0.6*(fragCoord-.5*iResolution.xy)/iResolution.y;//+vec2(.05,.05);\n    vec2 end = vec2(0.0,0.0);\n    vec2 end2 = vec2(0.0,0.0);\n    bool inACircumference1 = false;\n    bool inACircumference2 = false;\n    bool isonALine = false;\n    float isOnALineIteration = 0.0;\n    bool inACenter = false;\n    \n    for (int i=0; i<iterations; i++) {\n        vec2 pos = cookieX(iTime, i)/100.0;\n        vec2 pos2 = cookieY(iTime, i)/100.0;\n             \n        vec2 lastEnd = end;\n        vec2 lastEnd2 = end2;\n        \n        end += pos;\n        end2 += pos2;\n        \n        if (!inACenter)\n          inACenter = inCircle(uv, lastEnd, 0.001);\n\n        if (!inACenter)\n          inACenter = inCircle(uv, lastEnd2, 0.001);\n\n        float amp = fourierX[i].amp / (100.0/size_factor);\n        float amp2 = fourierY[i].amp / (100.0/size_factor);\n        \n        if (!inACircumference1)\n          inACircumference1 = inCircumference(uv, lastEnd, amp - 0.001, amp + 0.0001); \n        \n        if (!inACircumference2)\n          inACircumference2 = inCircumference(uv, lastEnd2, amp2 - 0.001, amp2 + 0.0001); \n        \n        \n\n        if (!isonALine) {\n          isonALine = onALine(lastEnd, end, uv, 0.001);\n        }\n        if (!isonALine) {\n          isonALine = onALine(lastEnd2, end2, uv, 0.001);\n        }  \n        if (isonALine) {\n              isOnALineIteration = float(i);\n        }\n    }\n    \n    vec2 pos2 = vec2(end.x, end2.y);\n    \n   float d = pow( pow(pos2.x - uv.x, 2.0) + pow(pos2.y - uv.y, 2.0) , 0.5); \n\n    if (d < 0.002) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        return;\n    }\n    \n    vec4 frame = texture(iChannel0, fragCoord/iResolution.xy);   \n    fragColor = frame;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yRN.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[120, 120, 177, 177, 241]], "test": "untested"}
{"id": "wttyRH", "name": "grogu", "author": "Pidhorskyi", "description": "grogu", "tags": ["grogu"], "likes": 24, "viewed": 694, "published": 3, "date": "1608561996", "time_retrieved": "2024-07-30T20:28:57.662013", "image_code": "/*\nImage encoding with neural network.\n\nNeural network is trained to return pixel value for given uv coordinates.\nNeural networks work poorly with low dimentional inputs and bias towards lower frequencies. \nFrequency transform is a way to encode uv location. It is taken from here: https://people.eecs.berkeley.edu/~bmild/fourfeat/index.html\n\nEncoding embeds 2D input into 64D space. The neural network itself is just 2 layer fully-connected network:\n\nlayer 1: input 64, output 64. Dense layer. Activation Relu\nlayer 2: input 64, output 3, Dense layer. No activation\n\nValues in b are sampled from gaussian distribution, so they could be recreated using the seed and RNG.\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = (1.0 - uv.y) * 0.5;\n    uv -= vec2(0.5, 0.25);\n    float a = iResolution.x / iResolution.y;\n    uv = mix(vec2(uv.x / (1.7777 / a), uv.y), vec2(uv.x, uv.y * (1.7777 / a)), vec2(a < 1.7777));\n    uv += vec2(0.5, 0.25);\n    \n    vec4 pos[16];\n    for (int i = 0; i < 8; ++i)\n    {\n        vec4 a = 2.0 * 3.1415 * vec4(dot(uv, b[i * 4 + 0]), dot(uv, b[i * 4 + 1]), dot(uv, b[i * 4 + 2]), dot(uv, b[i * 4 + 3]));\n        pos[i] = sin(a);\n        pos[8 + i] = cos(a);\n    }\n    vec4 h[16];\n    for (int i = 0; i < 16; ++i)\n    {\n        h[i] = cb[i];\n    }\n    for (int i = 0; i < 16; ++i)\n    {\n        h[0] += vec4(dot(cw0[i], pos[i]), dot(cw1[i], pos[i]), dot(cw2[i], pos[i]), dot(cw3[i], pos[i]));\n        h[1] += vec4(dot(cw4[i], pos[i]), dot(cw5[i], pos[i]), dot(cw6[i], pos[i]), dot(cw7[i], pos[i]));\n        h[2] += vec4(dot(cw8[i], pos[i]), dot(cw9[i], pos[i]), dot(cw10[i], pos[i]), dot(cw11[i], pos[i]));\n        h[3] += vec4(dot(cw12[i], pos[i]), dot(cw13[i], pos[i]), dot(cw14[i], pos[i]), dot(cw15[i], pos[i]));\n        h[4] += vec4(dot(cw16[i], pos[i]), dot(cw17[i], pos[i]), dot(cw18[i], pos[i]), dot(cw19[i], pos[i]));\n        h[5] += vec4(dot(cw20[i], pos[i]), dot(cw21[i], pos[i]), dot(cw22[i], pos[i]), dot(cw23[i], pos[i]));\n        h[6] += vec4(dot(cw24[i], pos[i]), dot(cw25[i], pos[i]), dot(cw26[i], pos[i]), dot(cw27[i], pos[i]));\n        h[7] += vec4(dot(cw28[i], pos[i]), dot(cw29[i], pos[i]), dot(cw30[i], pos[i]), dot(cw31[i], pos[i]));\n        h[8] += vec4(dot(cw32[i], pos[i]), dot(cw33[i], pos[i]), dot(cw34[i], pos[i]), dot(cw35[i], pos[i]));\n        h[9] += vec4(dot(cw36[i], pos[i]), dot(cw37[i], pos[i]), dot(cw38[i], pos[i]), dot(cw39[i], pos[i]));\n        h[10] += vec4(dot(cw40[i], pos[i]), dot(cw41[i], pos[i]), dot(cw42[i], pos[i]), dot(cw43[i], pos[i]));\n        h[11] += vec4(dot(cw44[i], pos[i]), dot(cw45[i], pos[i]), dot(cw46[i], pos[i]), dot(cw47[i], pos[i]));\n        h[12] += vec4(dot(cw48[i], pos[i]), dot(cw49[i], pos[i]), dot(cw50[i], pos[i]), dot(cw51[i], pos[i]));\n        h[13] += vec4(dot(cw52[i], pos[i]), dot(cw53[i], pos[i]), dot(cw54[i], pos[i]), dot(cw55[i], pos[i]));\n        h[14] += vec4(dot(cw56[i], pos[i]), dot(cw57[i], pos[i]), dot(cw58[i], pos[i]), dot(cw59[i], pos[i]));\n        h[15] += vec4(dot(cw60[i], pos[i]), dot(cw61[i], pos[i]), dot(cw62[i], pos[i]), dot(cw63[i], pos[i]));\n    }\n    vec3 col = vec3(-0.0908, -0.2686, -0.5834);\n    for (int i = 0; i < 16; ++i)\n    {\n        h[i] = max(h[i], vec4(0.));\n        col += vec3(dot(pr[i], h[i]), dot(pg[i], h[i]), dot(pb[i], h[i]));\n    }\n    fragColor = vec4(col * 0.5 + 0.5, 1.0);\n}\n", "image_inputs": [], "common_code": "const vec4 cb[16] = vec4[](vec4(-0.960178, 0.335298, -6.988212, -0.744198), vec4(-3.084307, -0.227496, 1.273046, 0.749891), vec4(0.668407, -1.754681, 0.380048, -1.743837), vec4(1.332189, -1.197896, 0.867033, -2.322814), vec4(-1.608913, -0.779369, -0.917023, -1.474812), vec4(1.187883, 0.498431, -3.482226, -1.891366), vec4(-0.634195, -0.440283, 0.617702, -2.877344), vec4(-1.646708, -1.279349, 1.007390, 1.929522), vec4(-0.447358, 0.936539, -0.323541, 3.352145), vec4(-1.854941, -1.993776, 0.553688, -0.286389), vec4(-3.598424, 1.014733, 2.427865, -2.100048), vec4(-1.568681, 0.735322, -2.045774, 1.415518), vec4(-0.195535, -11.257984, -0.681038, -1.502562), vec4(-0.066896, 1.198505, -1.028725, -0.036951), vec4(-0.262473, 0.578379, 0.108039, -1.768911), vec4(6.143124, 2.103487, 0.805790, 1.030637));\nconst vec2 b[32] = vec2[](vec2(6.177185, -4.632182), vec2(34.030796, -3.529290), vec2(1.534538, 22.154736), vec2(-12.729254, -8.282913), vec2(2.626445, -4.618179), vec2(-16.698706, -2.868271), vec2(-5.023605, 8.448602), vec2(-23.307039, -9.802506), vec2(16.119474, 26.002634), vec2(-21.156513, 9.027865), vec2(-13.728510, -11.995944), vec2(-12.206308, -5.915111), vec2(13.950157, 9.973898), vec2(0.828019, -5.086352), vec2(0.046044, -1.483026), vec2(11.102747, -8.842003), vec2(-0.086729, -1.414947), vec2(-0.732314, 3.489047), vec2(2.767241, 18.687880), vec2(-1.216258, 21.861452), vec2(-4.281942, -6.688240), vec2(1.410335, 4.976139), vec2(3.774574, 18.087486), vec2(15.950802, 6.922166), vec2(-4.708708, -1.408601), vec2(19.787573, 3.097558), vec2(-18.350824, -9.653913), vec2(-8.085185, 16.130867), vec2(-1.500296, 31.641495), vec2(9.192673, 1.747296), vec2(-6.099855, 13.610510), vec2(-3.369956, -11.537728));\nconst vec4 pr[16] = vec4[](vec4(-0.047668, -0.053896, -0.024157, 0.060577), vec4(0.054187, -0.046185, -0.085686, 0.055378), vec4(0.039967, 0.077863, -0.062130, 0.029147), vec4(0.027188, -0.031235, -0.074670, -0.042152), vec4(-0.035718, 0.056295, 0.027956, 0.049018), vec4(0.030122, -0.051335, 0.064161, 0.050659), vec4(0.068201, 0.048910, -0.074589, 0.060564), vec4(0.043077, 0.038489, -0.026482, -0.028780), vec4(-0.029846, -0.043179, 0.054606, 0.027355), vec4(0.032258, 0.038904, 0.062746, -0.062649), vec4(-0.034541, 0.034294, -0.011604, 0.039499), vec4(-0.056303, -0.020779, 0.041511, 0.051538), vec4(0.048653, 0.108711, -0.043017, 0.052419), vec4(0.050707, 0.077025, -0.021626, -0.042885), vec4(-0.061691, -0.066452, 0.042373, -0.022418), vec4(-0.010112, -0.042177, -0.049779, -0.018215));\nconst vec4 pg[16] = vec4[](vec4(-0.070525, -0.065633, -0.009707, 0.079715), vec4(0.063350, -0.048455, -0.097674, 0.057461), vec4(0.043972, 0.080491, -0.069876, 0.033007), vec4(0.031145, 0.022037, -0.096654, -0.043567), vec4(-0.020437, 0.071860, 0.034338, 0.053593), vec4(0.033472, -0.066177, 0.075869, 0.057503), vec4(0.070937, 0.048239, -0.028992, 0.078164), vec4(0.049773, 0.045109, -0.030909, -0.037541), vec4(-0.034564, -0.046948, 0.055714, 0.031460), vec4(0.035305, 0.045613, 0.087427, -0.066124), vec4(-0.018592, 0.036483, -0.017907, 0.043446), vec4(-0.069684, -0.030032, 0.047636, 0.051309), vec4(0.044468, -0.010423, -0.052492, 0.056811), vec4(0.061235, 0.085174, -0.027459, -0.052286), vec4(-0.055400, -0.085493, 0.052235, -0.024043), vec4(0.001226, -0.048737, -0.054398, -0.022193));\nconst vec4 pb[16] = vec4[](vec4(-0.066744, -0.057855, 0.002418, 0.073517), vec4(0.057183, -0.044921, -0.096454, 0.051966), vec4(0.043077, 0.077291, -0.067640, 0.030930), vec4(0.027352, 0.068784, -0.085928, -0.036834), vec4(-0.006926, 0.068931, 0.031969, 0.050539), vec4(0.031401, -0.064399, 0.069483, 0.056002), vec4(0.060942, 0.040330, 0.005233, 0.067801), vec4(0.049107, 0.043281, -0.027489, -0.036170), vec4(-0.030894, -0.041920, 0.049043, 0.025904), vec4(0.031203, 0.037876, 0.089959, -0.064736), vec4(-0.006222, 0.031671, -0.019372, 0.038775), vec4(-0.066185, -0.031731, 0.044413, 0.046247), vec4(0.040468, -0.074454, -0.048137, 0.047452), vec4(0.060624, 0.077629, -0.026109, -0.048497), vec4(-0.047490, -0.074741, 0.048187, -0.019959), vec4(0.007437, -0.045724, -0.049490, -0.021655));\nconst vec4 cw0[16] = vec4[](vec4(1.235939, -0.146809, -1.064213, -0.473982), vec4(1.472428, -0.606344, 0.391763, -0.068890), vec4(0.055506, 0.016174, -0.096903, -0.518534), vec4(0.695686, 1.804665, -1.315567, 0.220968), vec4(0.127525, -0.372966, 0.080499, 0.414918), vec4(1.707612, -1.635223, 0.947541, 0.131482), vec4(-0.431029, -0.345354, 0.153336, 0.416450), vec4(0.059667, -0.283834, 0.807501, -1.456447), vec4(0.500327, 0.098800, 0.942894, -0.102343), vec4(-0.500543, 0.540665, 0.139920, -0.059250), vec4(-0.162886, -0.148656, 0.610147, -0.623340), vec4(-0.210160, 0.152266, 0.039300, 0.006826), vec4(-3.142365, 2.781207, 0.421803, 0.775508), vec4(-0.709351, -0.083824, 1.027265, -0.184488), vec4(0.811116, 0.268118, -0.358339, -0.072943), vec4(-0.023177, 0.283377, 0.131895, -0.387367));\nconst vec4 cw1[16] = vec4[](vec4(-0.331062, -0.014963, 1.063614, -0.011261), vec4(0.364636, 0.022316, 0.502210, -0.010526), vec4(0.014696, 0.445646, -0.804157, 0.159026), vec4(-0.158288, 1.835268, -0.606606, -0.749341), vec4(1.475998, 0.424760, 0.752044, -1.037110), vec4(-2.102931, -1.124168, 0.541186, -0.348891), vec4(1.330267, 0.158586, -0.189681, -0.758065), vec4(0.146978, -0.736267, -0.358107, -1.244231), vec4(0.206281, 0.029750, -0.962613, 1.165594), vec4(-0.775254, 0.389729, 0.228483, 0.163002), vec4(0.320272, -0.399707, 0.051743, -0.506094), vec4(0.252732, 0.778268, 0.657173, 0.373631), vec4(-2.176756, 0.196301, -0.799362, -0.778041), vec4(-0.854447, 0.065360, 0.698529, 0.500928), vec4(0.734979, 0.145948, -0.430570, -0.180571), vec4(-0.251139, -0.375947, 1.453066, 0.418897));\nconst vec4 cw2[16] = vec4[](vec4(0.107139, 0.091815, 0.633733, 0.108205), vec4(0.639562, 0.294747, 1.046387, 0.042006), vec4(0.172411, -0.185804, 0.148611, 0.008086), vec4(-0.248301, -2.392724, -0.214390, -0.006975), vec4(6.940262, -3.072536, 1.098824, 0.711346), vec4(0.672286, 0.218828, -1.142148, 0.296667), vec4(1.449362, 0.205873, 0.204108, 0.039470), vec4(-0.099208, -0.450685, -0.851397, -0.152121), vec4(0.919093, 0.177933, 0.548920, -0.770216), vec4(-4.293908, 0.979848, 0.210722, 0.108725), vec4(0.136284, 0.395793, -0.088194, -1.086065), vec4(0.789422, 2.600108, -3.095368, -0.795215), vec4(-2.058293, -1.504584, -1.486780, 0.297538), vec4(1.659255, -0.023691, 2.226816, 0.017324), vec4(1.852228, -0.213805, -0.102702, -0.027565), vec4(0.062429, 0.003913, -0.461021, 0.854621));\nconst vec4 cw3[16] = vec4[](vec4(-0.760480, -0.119174, -1.126614, 0.416448), vec4(1.983062, 0.148520, -0.481683, 0.084052), vec4(0.065135, 0.129860, 0.000694, -0.339735), vec4(0.408934, 0.145149, 1.809336, 0.235465), vec4(-0.289830, -0.786145, 0.247088, -0.431792), vec4(1.291091, -0.250972, -0.547976, -0.326549), vec4(0.698440, -0.335195, -0.162336, 0.065232), vec4(0.223653, -0.718900, -0.755660, -1.540931), vec4(1.486451, -0.051100, -0.217590, 0.527156), vec4(-1.021614, -0.429101, -0.107603, 0.016956), vec4(0.082260, -0.297264, -0.132033, 0.367224), vec4(0.336380, 0.242182, -0.827212, -0.736552), vec4(-0.558747, 0.575536, -1.212515, -0.586575), vec4(-0.952247, 1.274322, 0.376474, -0.033285), vec4(-0.975931, 0.270613, -0.250404, -0.446777), vec4(0.333525, 0.763092, 0.405003, 0.331311));\nconst vec4 cw4[16] = vec4[](vec4(1.435075, 0.225597, 0.176337, -0.222152), vec4(1.556871, -0.399189, -0.130703, 0.145863), vec4(0.349109, -0.626942, -0.167405, 0.021180), vec4(0.066974, -0.347093, 1.645217, -0.989276), vec4(-0.393676, -0.080047, 0.885026, -0.431973), vec4(0.313057, -0.390228, 0.072817, 0.600566), vec4(-0.209436, 0.242012, 0.585358, -0.992292), vec4(-0.181200, -0.762808, 1.033215, -0.994176), vec4(0.438228, 0.096661, 0.911347, 0.485308), vec4(2.549019, -0.089755, 0.727755, 0.068700), vec4(-0.223183, 0.021001, -0.454897, 0.651374), vec4(-0.173216, -1.700397, -2.338256, -0.077060), vec4(-0.237165, 0.243023, -0.456461, 0.702047), vec4(2.464263, -0.834778, -1.453348, 0.240516), vec4(1.355252, 0.163843, 0.046848, 0.190859), vec4(0.192386, -0.040760, -1.484036, -2.302204));\nconst vec4 cw5[16] = vec4[](vec4(0.221128, 0.067760, 0.382704, -0.140080), vec4(-0.211193, -0.049352, -0.254060, 0.232586), vec4(0.483517, 0.165223, 0.273444, -0.604002), vec4(-0.432650, 0.022539, -0.564651, -0.170684), vec4(-1.218121, -0.208661, 0.334488, 0.875494), vec4(-0.401934, -1.069522, -1.331169, 0.870963), vec4(-0.490615, 0.161897, -0.297723, 0.351399), vec4(-0.665975, -1.095226, -0.176049, 0.754150), vec4(-1.031570, 0.046294, 0.093415, -0.863702), vec4(2.831009, -0.243362, -1.469229, -0.358775), vec4(-0.651826, -0.101593, 0.723399, -0.562903), vec4(1.013472, 1.017395, 1.578086, -0.298124), vec4(-1.036873, -0.570869, -0.520670, 0.747921), vec4(1.371701, -0.428450, 0.016631, -0.971106), vec4(0.852699, 0.908320, 0.266684, -0.159989), vec4(0.201793, 0.893786, 0.864240, 0.941550));\nconst vec4 cw6[16] = vec4[](vec4(-0.069308, -0.149925, -0.356786, -0.302173), vec4(0.383354, 0.203287, -0.053836, -0.228046), vec4(-0.115915, -0.313703, 0.121081, -0.105215), vec4(0.141907, 1.460543, -1.166835, 0.402827), vec4(0.065822, -0.206066, 0.316210, 0.642250), vec4(0.229572, -0.093602, -0.566320, -0.027219), vec4(-0.311188, 0.115496, -0.135650, -0.626775), vec4(-0.038305, 0.252328, -0.092592, 0.564189), vec4(0.479092, -0.078109, -0.052481, 0.171709), vec4(0.382502, -0.219175, -0.232456, 0.010417), vec4(0.451849, -0.000697, -0.024381, 0.797966), vec4(-0.052001, -0.255751, 2.033478, 0.187564), vec4(-0.295395, -0.260119, 0.847165, 0.434340), vec4(-1.208230, 1.056074, -0.762371, 0.379058), vec4(-0.375610, -0.054462, 0.022705, -0.509414), vec4(0.673198, -0.337945, -0.207143, 0.161838));\nconst vec4 cw7[16] = vec4[](vec4(-0.534941, 0.020058, 1.272990, -0.542138), vec4(0.618122, 0.051832, 0.366854, 0.290286), vec4(-0.075031, -0.128858, 0.165589, 0.390382), vec4(-0.840602, -0.619237, 0.500927, 0.266944), vec4(1.262090, 1.693147, 0.113790, -0.193863), vec4(-1.535123, -3.118495, -0.762209, -0.044660), vec4(-0.386320, 0.033282, -0.146572, 0.081461), vec4(0.098409, 0.396567, 0.373919, 0.731145), vec4(-1.091308, -0.233834, -0.779101, -0.016841), vec4(1.264274, -0.725709, -0.654213, -0.140795), vec4(-0.014188, -0.318000, -0.908155, 0.623479), vec4(0.327181, -1.121129, 2.325474, -0.662006), vec4(-0.025138, -0.726297, 0.668629, 0.816350), vec4(-0.573318, 0.458367, 0.538376, -0.105744), vec4(1.378432, -0.243991, -0.011988, 0.739932), vec4(0.636847, -1.091989, 0.646140, -0.096268));\nconst vec4 cw8[16] = vec4[](vec4(0.638286, 0.077312, -0.829166, -0.248890), vec4(-0.746651, -0.699130, 0.293431, -0.571742), vec4(0.628983, -0.323471, 0.436955, 0.928268), vec4(0.477231, -0.536134, -0.162884, -0.201031), vec4(0.241063, 1.381761, 1.600618, 0.270725), vec4(0.771767, -0.820874, 0.586318, 0.470130), vec4(-0.198487, 0.134423, -0.290584, 1.206879), vec4(-0.102168, 0.462342, -1.256112, -0.787816), vec4(0.912698, -0.040079, 0.386840, 0.504101), vec4(0.403194, -0.625833, -0.728344, -0.014200), vec4(0.027240, -0.373505, 0.291126, -0.056275), vec4(0.065283, -1.354900, 0.662712, 0.029182), vec4(-0.052483, -0.622443, -0.294476, -0.347600), vec4(1.192738, -1.810127, -1.708549, -1.462792), vec4(0.361432, 0.418842, 0.283813, -0.009702), vec4(0.308996, 1.656337, -0.418241, -0.550826));\nconst vec4 cw9[16] = vec4[](vec4(1.262917, 0.044860, -0.781232, 0.317331), vec4(0.865874, 0.579178, 0.079705, -0.070567), vec4(0.424803, 0.089427, -0.079633, 0.176694), vec4(-0.372423, 0.878852, 0.557011, -0.276412), vec4(-2.076058, -0.505053, 1.212411, -0.647312), vec4(-1.999405, -0.961465, -0.419618, 0.082104), vec4(-0.394056, 0.079985, -0.609043, -0.080275), vec4(0.105538, -0.161283, 0.022723, -1.193382), vec4(-0.668986, 0.020854, 0.407467, -0.124726), vec4(-0.774810, 0.134679, 1.141565, 0.031611), vec4(-0.043053, 0.024472, 0.031278, 1.130846), vec4(-0.337519, -2.123665, -0.837819, -0.230678), vec4(1.049888, -0.346112, 0.361866, -0.842239), vec4(-1.091388, 3.012855, -0.641873, -0.146417), vec4(1.430199, 0.234452, -0.324612, 0.004412), vec4(0.034344, -0.184597, -0.385621, 0.204277));\nconst vec4 cw10[16] = vec4[](vec4(-0.610399, 0.071409, -0.516201, -0.326503), vec4(1.092108, 0.195036, -1.474296, -0.217134), vec4(0.067631, -0.017273, -0.163460, 0.583719), vec4(-0.216994, 1.278909, -0.844519, 0.201492), vec4(1.226757, 2.589414, -0.956497, 0.405982), vec4(0.685238, -1.206463, -0.976390, 0.362486), vec4(0.916486, -0.246400, 0.008736, 0.291508), vec4(0.635357, -0.341851, -0.397595, 0.019074), vec4(0.409215, -0.180058, 0.200110, -0.491228), vec4(0.155446, 0.254822, 0.265837, 0.131200), vec4(0.253353, 0.138009, -0.195795, 0.938125), vec4(-0.436714, -1.577733, -0.001279, 0.108660), vec4(0.307257, -1.200170, -0.441581, 0.275363), vec4(-0.651698, 0.049160, -0.914214, -0.053591), vec4(2.126523, -0.568517, 0.358363, 0.067811), vec4(0.287461, 0.586012, -0.592760, -1.193093));\nconst vec4 cw11[16] = vec4[](vec4(1.674041, -0.060985, 1.326055, 0.168787), vec4(1.424749, -0.589034, 0.080859, 0.390579), vec4(-0.676640, 0.804586, 0.671417, 0.744171), vec4(1.104593, -0.297741, -0.522761, -0.438146), vec4(0.102180, -1.103448, 2.864633, 0.744810), vec4(0.515103, -0.588676, 2.081045, 0.476955), vec4(-1.769145, -0.362540, -0.004795, -0.464212), vec4(-0.130960, 2.298582, -1.048578, -2.221446), vec4(-1.638025, 0.306874, -1.154989, 1.290643), vec4(-1.053059, 1.261364, -0.196549, -0.018996), vec4(-0.199119, 1.330414, -0.411194, -2.427431), vec4(1.058973, 0.123301, 0.390255, 0.104102), vec4(0.098116, 0.092545, 2.430505, 0.229966), vec4(-3.237000, 0.668322, 0.019985, 0.220263), vec4(-1.730628, 0.174928, 0.393782, -1.325816), vec4(0.208642, 1.591541, 0.108473, 0.073425));\nconst vec4 cw12[16] = vec4[](vec4(-2.405556, -0.049432, 2.509589, -0.282607), vec4(1.084446, 0.440729, -2.777499, 0.247914), vec4(0.960690, 0.594601, -0.650143, -0.830975), vec4(0.475529, 1.789717, -0.533141, -1.285721), vec4(-0.462572, 0.098046, 0.203174, -1.646149), vec4(3.067992, -3.604943, 0.843446, 1.410801), vec4(0.134955, 0.858925, 0.400646, 0.584072), vec4(1.204228, 1.636903, -0.286602, 0.921310), vec4(1.998591, 0.280285, 2.191902, 0.841487), vec4(0.164441, 0.399230, 0.905818, 0.195877), vec4(0.334562, 0.473916, -0.263005, 0.282646), vec4(1.158765, 0.473981, -1.700428, 0.174133), vec4(0.259986, -1.381279, 0.514484, 1.088552), vec4(-1.141093, -1.200100, -1.423092, 1.551403), vec4(-3.636952, -0.143702, 0.288885, -0.384602), vec4(0.274537, -0.721049, -1.369273, 0.364947));\nconst vec4 cw13[16] = vec4[](vec4(0.001299, -0.028773, 0.184133, -0.022220), vec4(-0.786229, -0.104601, 0.030496, 0.043516), vec4(0.039305, 0.013750, 0.005141, -0.058242), vec4(-0.152909, 0.342988, -0.113092, -0.082333), vec4(-0.703331, -0.333026, 0.427173, 0.091205), vec4(0.291766, 0.609281, -0.126766, 0.080322), vec4(0.495767, -0.027432, 0.063517, 0.028424), vec4(-0.039682, -0.028860, 0.133911, 0.223850), vec4(-0.251415, -0.017053, -0.172485, -0.134712), vec4(0.992244, 0.011963, -0.443102, -0.004347), vec4(-0.089603, -0.121369, -0.004093, 0.031163), vec4(-0.227292, 0.934621, -1.621850, 0.116333), vec4(0.818215, 0.176627, 0.433235, -0.197166), vec4(0.063875, -0.191971, -0.341764, 0.028254), vec4(0.464252, 0.014883, 0.102972, 0.132249), vec4(-0.101007, -0.088933, -0.037489, -0.793059));\nconst vec4 cw14[16] = vec4[](vec4(-0.495738, -0.128044, 0.054506, -0.481590), vec4(-0.376338, -0.310046, 0.203507, 0.037314), vec4(0.070791, 0.118231, 0.104982, 0.066024), vec4(0.019541, -1.831794, -1.192350, 0.012925), vec4(-0.066155, -0.015357, -1.022596, -0.223220), vec4(0.832351, -0.710996, -0.588053, 0.430417), vec4(0.777771, -0.106559, 0.223577, 0.098602), vec4(-0.006942, 0.748052, -0.134923, -0.098553), vec4(1.061842, 0.160757, -0.052194, 0.141878), vec4(0.431224, 0.390422, 0.278161, -0.197346), vec4(0.029576, 0.127187, 0.167181, 0.064916), vec4(0.305147, 1.115084, -0.269980, 0.044355), vec4(2.641849, -1.663304, -0.081767, 0.538767), vec4(-0.360473, -0.493896, -0.001876, 0.364395), vec4(-0.130559, 0.204752, 0.389215, -0.051558), vec4(0.230425, 0.469567, 0.197886, 0.582229));\nconst vec4 cw15[16] = vec4[](vec4(1.892855, 0.246893, 0.849463, -0.435986), vec4(-2.330045, -0.321572, -0.876489, 0.010969), vec4(-0.077130, -0.009812, -0.132232, -0.340711), vec4(-0.568368, -0.190337, -1.913245, -0.830125), vec4(1.509846, -0.436871, 1.096351, -0.191152), vec4(1.489666, -1.491784, 0.568375, 0.243681), vec4(1.546354, -0.421026, -0.798561, -0.918584), vec4(0.594397, -1.561072, -0.928303, -0.909304), vec4(2.127450, -0.028643, 0.013213, 0.990749), vec4(0.191779, -0.398912, 0.714534, -0.396317), vec4(-0.505781, 0.504654, 0.701973, -0.862575), vec4(-0.194442, -0.683212, 1.293040, -1.008227), vec4(0.109967, 1.822640, 1.096924, 0.220366), vec4(1.481354, 0.319346, -0.793788, -1.334643), vec4(-0.347594, 0.161855, -0.405936, -1.109100), vec4(0.205354, -0.157336, 0.628708, -2.026335));\nconst vec4 cw16[16] = vec4[](vec4(-0.322496, -0.219656, 0.134878, -0.214717), vec4(2.100612, 0.146755, 0.130819, -0.281783), vec4(-0.087257, 0.218188, 0.502194, 0.403274), vec4(-0.359088, 1.964452, 5.069016, 0.555114), vec4(-5.066070, -0.999641, 4.400813, -0.867837), vec4(0.106681, 0.840402, -2.989461, 0.262470), vec4(0.388294, 0.238884, -0.293953, -0.109324), vec4(0.199887, -0.024600, -0.129371, 0.434448), vec4(0.080981, 0.037506, -0.642023, 0.264955), vec4(-0.554561, 0.495840, 0.357604, 0.102146), vec4(0.489028, -0.053462, 0.131592, 0.229970), vec4(0.561014, -2.879865, 4.131225, 0.320710), vec4(-3.823047, 1.495678, 0.205740, -0.079363), vec4(0.203227, -1.444291, -2.341354, 0.064216), vec4(-0.008450, 0.166481, 0.052643, 0.217938), vec4(-0.139773, 0.376490, 0.832858, 0.091986));\nconst vec4 cw17[16] = vec4[](vec4(-0.400139, 0.036089, 0.222563, 0.433281), vec4(0.485656, -0.669261, -0.663788, -0.149127), vec4(-0.065606, 0.172696, -0.648145, -0.061844), vec4(-0.244245, -0.434763, 2.160807, 0.133779), vec4(0.102213, 0.230800, -0.757617, 0.217248), vec4(-1.763892, -0.769896, -0.528113, 0.208643), vec4(-0.018996, 0.204883, -0.187898, 0.356087), vec4(0.025327, 0.352729, 0.493110, 0.415108), vec4(-1.442834, -0.006783, 0.234661, 0.202120), vec4(-1.385357, 0.390775, -0.183807, -0.356313), vec4(-0.101599, 0.084192, 0.366797, -0.347186), vec4(-0.250915, -1.436289, -2.090213, -0.320002), vec4(0.464363, 0.143147, 0.304335, -0.760532), vec4(-0.111403, -0.427665, 1.288669, 0.445520), vec4(2.168613, -0.128652, 0.410473, 0.678885), vec4(-0.917040, -0.009639, 1.546541, 0.034947));\nconst vec4 cw18[16] = vec4[](vec4(-1.473086, 0.393108, 2.599787, 0.784365), vec4(-0.597749, -0.225515, -0.847593, 0.036508), vec4(0.350728, 0.262397, -0.077111, -0.377540), vec4(-0.097417, 2.842953, -0.454045, -0.590214), vec4(-2.408674, -1.523427, 2.284126, 0.327380), vec4(-0.088287, 0.815919, -0.622184, -1.260709), vec4(2.067611, 0.207044, 0.764294, 0.581665), vec4(1.240835, 0.420962, -1.369994, -2.044235), vec4(0.606531, -0.280277, -0.565776, 0.431995), vec4(-1.240577, 1.128007, 0.131895, 0.296213), vec4(0.206777, 0.233191, 0.619018, 0.882996), vec4(-0.696696, 0.886989, 2.020799, 0.336766), vec4(-0.121093, -0.976071, -0.847142, 0.443752), vec4(1.649790, -0.339336, -2.113570, 0.195017), vec4(-1.816725, 0.741864, 0.734157, 0.010901), vec4(-0.351670, -0.244206, 0.781707, -1.127883));\nconst vec4 cw19[16] = vec4[](vec4(-1.387038, 0.071557, -0.644905, -0.129899), vec4(3.294343, -0.326669, -0.941579, 0.162829), vec4(-0.662996, 0.055551, -0.714989, -0.642891), vec4(0.469817, 0.166397, 1.282696, 0.528379), vec4(-1.003844, 0.110805, -0.276387, 1.031126), vec4(-0.213132, 0.926586, -0.153791, 0.884649), vec4(1.100734, 0.325279, -0.348949, 0.208919), vec4(1.025366, -0.658958, -0.688163, 0.157590), vec4(0.455896, -0.211543, 0.411853, -0.762061), vec4(-0.477977, 0.527203, -0.766886, -0.027284), vec4(0.317217, 0.447640, -0.507660, -0.056852), vec4(0.167100, -1.397790, -0.491997, -0.336298), vec4(-0.246084, 1.112716, -0.853565, -0.312160), vec4(0.474123, 0.206807, 0.238178, -0.201958), vec4(1.710225, -0.573709, -0.427889, -0.068738), vec4(-0.575953, -1.350123, -0.370784, -0.747245));\nconst vec4 cw20[16] = vec4[](vec4(-1.058922, -0.252217, 0.137359, 1.260235), vec4(-0.701839, 0.217878, -1.086192, 0.047408), vec4(-0.235155, -0.934812, 0.841819, 2.177390), vec4(1.133901, -1.716245, -2.632328, -0.031542), vec4(-1.107631, -0.838066, 0.532245, 1.573841), vec4(1.661752, 0.130754, 1.454599, 2.146915), vec4(-3.751050, 0.283315, -0.516499, 0.375469), vec4(-0.605178, 0.368938, 0.741371, 1.178473), vec4(-1.162897, 0.027761, 0.230346, -0.287270), vec4(-2.544835, 0.686858, 2.491189, -0.845425), vec4(0.927914, -0.157304, 1.195451, 0.957460), vec4(0.985870, 2.360506, 0.593947, -1.198648), vec4(0.293722, 0.187528, -0.591937, -1.043698), vec4(-1.159440, 2.258244, 0.017545, 0.242463), vec4(-0.708721, 1.243740, -0.924551, 1.088892), vec4(-0.230185, -2.677470, 1.151499, -0.222976));\nconst vec4 cw21[16] = vec4[](vec4(-0.966096, -0.079884, 0.068286, 0.577426), vec4(-0.041229, 0.246882, -1.685404, -0.439771), vec4(0.600001, 0.257337, 0.175503, -0.125247), vec4(-0.019449, -1.421923, -0.343744, -0.035846), vec4(-1.234885, -0.644102, 0.877686, 0.656333), vec4(2.009570, 0.261198, -0.000595, 0.425875), vec4(-0.087016, -0.312177, 0.031262, -0.496619), vec4(0.067125, -0.189899, 0.890446, 1.620306), vec4(0.206963, 0.071608, 0.220016, 0.365183), vec4(-0.574881, 0.444816, 0.048719, -0.103869), vec4(0.095031, 0.221180, -0.020922, 0.332270), vec4(0.182366, 0.225103, -1.395996, -0.341414), vec4(0.341667, -0.325366, -0.831926, -0.253584), vec4(-1.723729, 0.477642, 0.021279, -0.128323), vec4(1.492445, -0.155223, -0.156282, 0.543681), vec4(0.127190, -0.234158, 0.908064, -0.433003));\nconst vec4 cw22[16] = vec4[](vec4(0.162738, 0.013706, 0.587339, 0.795829), vec4(-0.088529, -0.065718, 0.219894, -0.080760), vec4(0.066952, -0.227004, 0.058076, 0.043196), vec4(-0.337367, 2.850509, -0.678685, 0.195614), vec4(-2.906308, 1.131719, 0.915234, 0.324975), vec4(0.370020, -2.044519, 0.526716, -0.032762), vec4(2.023325, -0.159320, 0.036559, -0.015519), vec4(0.012287, -1.827964, -1.318927, -1.479611), vec4(0.914411, 0.141375, 0.012650, 1.278447), vec4(0.567661, -0.324466, -1.469602, 0.234896), vec4(-0.095039, 0.121513, 0.245223, -0.756389), vec4(0.258798, 1.112143, -3.286472, -0.267891), vec4(1.482132, 2.700077, 0.896348, -0.093577), vec4(0.697537, 0.838201, -0.306581, 0.158809), vec4(0.596643, -0.338964, -0.019478, -0.141667), vec4(-0.184982, -0.126499, 0.062099, 1.601880));\nconst vec4 cw23[16] = vec4[](vec4(-0.138870, -0.051223, -0.147104, -1.072703), vec4(1.208009, -0.825442, -0.798314, 0.064777), vec4(0.266324, -0.341794, -0.348775, -0.276402), vec4(-0.834730, 2.228889, 0.745126, -0.976593), vec4(-1.748630, -1.565713, -1.457145, -0.032949), vec4(-0.691811, 1.535167, 0.192772, -0.052290), vec4(-0.067980, 0.164109, -0.086179, -0.628957), vec4(-0.279472, 0.548524, -0.817427, 0.316542), vec4(0.430343, -0.116411, 0.514603, -0.248161), vec4(-0.911916, -0.485620, -0.787736, 0.195752), vec4(0.233546, -0.003280, 1.104643, -0.060439), vec4(0.581972, -1.493028, 1.261272, -0.573628), vec4(-0.110395, 1.723284, 0.045797, -0.218447), vec4(-0.495423, 1.494173, 0.219106, -0.336744), vec4(0.817299, -0.040838, -0.861296, 0.177703), vec4(0.463984, 1.137919, 0.156436, 1.085749));\nconst vec4 cw24[16] = vec4[](vec4(-0.917221, -0.013975, 0.688389, -0.195997), vec4(-0.309880, -0.205305, -0.488409, -0.017959), vec4(0.287753, 0.060737, -0.236758, -0.474474), vec4(-0.081293, 0.589395, 0.626988, -0.144411), vec4(1.553809, -1.090359, 0.557175, 0.544938), vec4(-1.639637, -1.675967, -0.220307, -0.246755), vec4(0.195342, 0.160921, 0.500372, -0.307562), vec4(-0.044336, -0.515339, -0.383533, -0.147506), vec4(0.880132, -0.052564, -0.614605, 0.764634), vec4(-0.509288, 0.045664, 0.088800, 0.017932), vec4(0.109785, -0.006331, -0.612441, 0.621636), vec4(0.177742, 1.794497, 0.158993, 0.339068), vec4(-1.287846, -1.312159, 1.263156, 0.282759), vec4(-1.644695, 1.456127, -0.598542, 0.000116), vec4(-0.382675, -0.129397, 0.200238, -0.231790), vec4(0.182535, 1.041968, 0.524225, 0.520523));\nconst vec4 cw25[16] = vec4[](vec4(-0.104259, 0.161532, -0.549964, -0.714899), vec4(-1.080171, 0.778579, 1.383559, -0.352002), vec4(-0.112413, 0.267441, -0.768501, 0.272543), vec4(-0.787032, 0.206324, -1.870026, -0.932829), vec4(-0.695079, 0.078535, 0.567445, 0.099463), vec4(-0.585715, -0.047856, 0.486960, 0.470526), vec4(1.182117, -0.483262, -0.373013, -1.559632), vec4(-0.456378, -0.166907, -0.877789, -1.085158), vec4(-0.260635, 0.245325, 0.224926, -0.364893), vec4(0.593201, 0.305206, -0.400283, -0.075697), vec4(-0.493448, -0.179699, -0.061454, -0.467965), vec4(0.674795, 2.500666, -2.173917, -0.316638), vec4(2.650531, -0.401659, 0.971824, -0.371204), vec4(0.714751, -0.801733, 1.529769, 0.244987), vec4(0.682119, 0.289045, 0.128992, -0.043078), vec4(-0.490753, -0.638606, -0.342906, 0.790938));\nconst vec4 cw26[16] = vec4[](vec4(-0.224727, -0.042791, 0.105681, -0.037378), vec4(0.061678, -0.004509, -0.059769, 0.006107), vec4(-0.018567, 0.036926, -0.169814, -0.045914), vec4(0.123375, -0.279374, 0.371979, -0.162691), vec4(0.706677, 0.070840, -1.000381, 0.084643), vec4(0.227516, -0.334081, 1.249545, 0.056166), vec4(0.035236, 0.015345, -0.051317, -0.003817), vec4(0.054173, -0.038706, -0.180998, -0.271896), vec4(0.276025, -0.039552, 0.056465, -0.239291), vec4(-0.386584, 0.079219, -0.095082, -0.034238), vec4(-0.021613, -0.035812, -0.021242, -0.101157), vec4(-0.279916, -0.066272, 1.030799, -0.318045), vec4(-1.373070, -0.287062, 1.473323, -0.236915), vec4(-0.296385, 0.133118, -1.297778, -0.028571), vec4(-0.034884, -0.115860, -0.064021, -0.000327), vec4(0.072349, -0.096857, -0.051106, -0.124021));\nconst vec4 cw27[16] = vec4[](vec4(0.012466, -0.009275, 0.408174, 0.050911), vec4(-1.564344, -0.538877, -0.396755, -0.512949), vec4(-0.271620, 0.411811, -0.666314, -0.811852), vec4(0.440985, 1.793863, 1.524706, 0.070731), vec4(-1.910101, 2.904314, 0.473119, -0.284547), vec4(0.588291, -1.416987, -1.163896, 0.394570), vec4(0.192728, -0.148847, 0.456614, -0.616498), vec4(0.085555, -0.766239, -0.349783, -1.100025), vec4(-0.295075, 0.042752, 0.774386, -0.572548), vec4(-0.202975, 0.122471, -1.606135, -0.271527), vec4(-0.165471, -0.296199, -0.263198, 0.396211), vec4(0.141094, 1.168075, 0.175642, -0.206188), vec4(1.210933, 1.243638, -1.655286, 0.143565), vec4(0.687062, 2.382829, -0.246440, -0.068658), vec4(1.012808, -0.357138, 0.210001, -0.597864), vec4(0.379842, -0.452898, -0.056719, -1.705901));\nconst vec4 cw28[16] = vec4[](vec4(0.858546, -0.116882, -0.372247, 0.510910), vec4(-1.093743, -0.130836, -0.335124, 0.098630), vec4(0.135580, -0.125698, -0.360711, -0.890290), vec4(-0.502647, 1.545165, -0.613162, -0.159851), vec4(-1.062975, -0.564766, 1.309058, 0.734760), vec4(1.859637, -0.661384, -0.347155, -0.502984), vec4(-0.488041, 0.369910, 0.118164, 0.796450), vec4(-0.213118, 0.714838, 0.123827, 1.438462), vec4(-0.276345, -0.058399, 0.023966, -1.058150), vec4(-0.275522, 0.038941, -1.341777, -0.077240), vec4(-0.038863, 0.251691, 0.654752, 0.523925), vec4(-0.143485, 0.549802, -0.508960, 0.538875), vec4(0.419203, -0.192956, 0.696587, 1.147492), vec4(-1.602255, -0.566162, 1.103765, 0.416325), vec4(-0.300538, -0.158866, -0.657004, -0.414860), vec4(0.062424, -0.273681, -1.224444, 0.620469));\nconst vec4 cw29[16] = vec4[](vec4(1.799824, -0.161329, 1.025678, -0.057362), vec4(1.006172, 0.924903, 2.196139, -0.398934), vec4(0.207329, 0.211041, -1.038103, -0.190000), vec4(-0.010284, -0.386223, -0.077461, 0.224210), vec4(-0.308546, -1.134177, -1.979866, 0.245078), vec4(-2.171478, -0.643247, -1.086119, -1.544138), vec4(2.097158, 0.367811, 0.123460, -1.149315), vec4(1.143083, 0.207208, 0.028391, -0.016602), vec4(0.337087, -0.136811, -0.454201, -0.372024), vec4(-0.417994, -0.870968, 0.693217, -0.067430), vec4(0.248987, 0.078701, 0.895149, -0.598355), vec4(0.071673, -0.800737, 1.278532, 1.124830), vec4(-1.548046, -0.217766, -0.940821, 0.331108), vec4(1.275997, 1.025975, -0.026082, 0.391853), vec4(1.817755, 0.435237, 0.227267, -0.636935), vec4(-0.076998, -0.257160, -0.882415, -0.409734));\nconst vec4 cw30[16] = vec4[](vec4(3.344208, -0.201826, -1.760593, -0.806672), vec4(-1.134253, -0.467427, 0.610273, -0.328177), vec4(0.065678, -0.301670, 0.266952, -0.453540), vec4(-1.367217, 0.844298, -0.627262, -0.691597), vec4(0.193121, 1.765436, 1.896646, 0.498036), vec4(-1.034203, 0.374775, -0.055049, 1.085446), vec4(-1.599292, -0.373146, -0.499109, 0.412399), vec4(-0.823506, -0.103102, 0.980780, -1.904318), vec4(2.788183, 0.026734, 1.028422, 0.287599), vec4(0.928851, -1.721908, 2.068390, 0.055028), vec4(-1.204327, -0.262699, -1.518005, 2.684016), vec4(-0.967625, -0.383449, 1.149938, -1.276948), vec4(-0.063169, -1.415116, -0.677858, -3.220441), vec4(-0.734080, -0.373755, 0.483452, 0.993036), vec4(-1.802792, 0.578033, 0.285036, -0.600409), vec4(0.623586, -1.807797, 0.387220, -0.651737));\nconst vec4 cw31[16] = vec4[](vec4(-0.887437, 0.021425, 0.605127, -0.131159), vec4(-2.625763, -0.705046, -0.934480, -0.520999), vec4(0.083870, -0.259346, -1.147775, 0.165812), vec4(-0.481517, 1.389280, 1.059412, 0.167820), vec4(1.936240, -0.147456, -1.718990, 0.026444), vec4(-2.251287, -1.217888, 1.340220, 0.052995), vec4(3.197826, -0.063777, 0.286066, -0.368600), vec4(-0.254258, -0.816670, 0.903300, 0.971050), vec4(0.058225, -0.419295, -0.869535, 0.787781), vec4(2.641213, -0.193116, 0.412095, -0.466986), vec4(0.040160, 0.001156, -1.170261, 0.519532), vec4(-0.697401, -1.136708, 1.702560, -0.668936), vec4(-0.536297, 2.209036, -2.603886, 2.415675), vec4(-2.432975, -1.384820, -0.445325, 1.034453), vec4(-1.215961, 0.065840, 0.103146, 0.994985), vec4(-0.380177, 0.019664, -0.827591, 0.291151));\nconst vec4 cw32[16] = vec4[](vec4(1.114799, -0.395758, 0.992199, 0.384910), vec4(-3.471186, -0.547794, 0.012624, 0.407909), vec4(-0.780751, 0.422031, -0.868482, -0.522927), vec4(-1.102706, -2.320824, 0.127768, 0.893186), vec4(0.492019, -0.865307, -0.907978, 2.084536), vec4(-1.390032, -2.622759, -0.309269, -1.185247), vec4(2.282209, 0.271366, -0.472342, 0.029949), vec4(0.408324, -0.705249, 2.926985, 3.109816), vec4(0.708934, -0.089960, -0.582891, -2.086002), vec4(-0.351507, -0.358101, 1.610307, 0.493854), vec4(0.058911, -0.761924, 0.672941, 0.160892), vec4(-0.191873, -3.396711, -0.804236, 0.450963), vec4(1.171807, 3.002585, -0.620637, -0.919947), vec4(-1.137231, 3.201446, 0.395449, 0.163789), vec4(-0.944564, -0.025602, -0.584979, 1.346248), vec4(0.628974, -1.838741, 0.664512, -3.550169));\nconst vec4 cw33[16] = vec4[](vec4(0.712456, 0.029853, -0.389744, -0.489556), vec4(1.703497, 0.021515, 0.643494, 0.120255), vec4(0.179219, 0.055940, 0.622059, -1.175350), vec4(0.064191, 0.046955, -0.829118, 1.213503), vec4(1.047422, 0.009089, 0.219669, -1.165364), vec4(-0.111635, -0.581282, -1.959380, 0.327420), vec4(-2.138343, 0.507090, 0.191636, 0.091813), vec4(0.358028, 1.546016, -0.618894, 1.126280), vec4(1.814471, 0.001315, -0.455905, 0.017235), vec4(0.282883, -0.509300, -0.156495, -0.059667), vec4(-0.137423, -0.233849, 0.001719, -0.049845), vec4(1.019734, -1.570719, -0.292896, 0.093451), vec4(-0.020332, 1.541793, -2.082414, -1.244296), vec4(-0.724491, 1.511028, 0.853037, -0.636071), vec4(-0.075674, 0.746504, -0.622655, -0.286161), vec4(0.488870, -0.382440, -0.952753, 0.395446));\nconst vec4 cw34[16] = vec4[](vec4(-0.400474, -0.064379, 0.812699, 0.668175), vec4(0.628176, 0.345515, -0.608705, -0.103326), vec4(0.233688, -0.105568, -0.010809, -0.354887), vec4(-0.331719, -0.091838, -1.758967, 0.408167), vec4(1.060798, 1.256928, -1.562594, -0.116397), vec4(-0.405646, -2.081959, -1.082104, -0.340174), vec4(2.245209, 0.003264, 0.019408, 1.247523), vec4(-0.067249, -0.758440, 1.177560, 1.361769), vec4(1.218017, 0.062500, 1.448727, -1.141584), vec4(-1.442554, 0.777638, -0.505501, -0.056190), vec4(0.101198, -0.062708, -0.257437, -1.494235), vec4(0.807504, 0.007366, -1.949327, -0.948952), vec4(0.556946, 0.277846, -0.447854, 0.576933), vec4(0.815795, -1.652454, 0.473773, 0.170629), vec4(2.257351, 0.598558, 0.086633, 0.030777), vec4(0.413664, 0.880357, -1.804102, 0.431788));\nconst vec4 cw35[16] = vec4[](vec4(3.592632, -0.321485, -0.731947, 0.385218), vec4(-0.006540, -0.001122, 2.736262, -0.147814), vec4(-0.299569, -0.045545, -0.110815, 1.088078), vec4(0.628946, 1.948663, -2.468342, 1.252968), vec4(-1.625017, -5.236995, -0.477658, -1.183300), vec4(-0.074869, 1.325234, -1.067268, 0.428895), vec4(-0.672142, 1.035146, -0.911334, 2.011954), vec4(-0.209100, 1.689888, 0.455680, -1.852929), vec4(1.360567, 0.136041, 0.471074, 0.813163), vec4(-3.699841, 1.010773, -0.858994, 0.148952), vec4(0.368965, 0.403249, 0.069408, -0.170297), vec4(0.017618, 2.424966, -1.836726, -0.730382), vec4(1.695736, 0.051987, 0.869271, -0.420957), vec4(-1.208227, 0.346714, 1.142929, 0.947851), vec4(3.081126, 0.106813, -0.261910, 0.225509), vec4(1.152229, 0.276884, 1.488467, 0.737765));\nconst vec4 cw36[16] = vec4[](vec4(0.868101, -0.383409, -1.156900, -1.411661), vec4(2.728409, 0.338439, -1.753348, -0.553256), vec4(-0.198064, -0.071933, 0.990590, 0.370176), vec4(-0.087276, -1.168781, -1.528348, 0.183763), vec4(-0.609441, 2.554330, 1.306972, 1.927032), vec4(1.497476, 0.032499, -0.919754, 0.573679), vec4(-1.307585, 0.116778, 0.028899, -1.813683), vec4(0.525841, 1.986079, 0.515033, 1.420290), vec4(-0.461286, 0.021538, 0.074964, -2.037370), vec4(0.740408, 0.919497, 1.925055, -0.227138), vec4(0.339635, -0.458964, -0.123076, 1.474499), vec4(1.004053, -1.651473, 1.636886, 2.289349), vec4(-2.316907, 0.366014, 0.538309, -0.511422), vec4(-1.245522, -0.523318, -0.511971, -0.512922), vec4(-2.379879, 0.054407, 0.291294, -0.115475), vec4(0.610674, 1.121420, 0.698858, -0.459867));\nconst vec4 cw37[16] = vec4[](vec4(0.731623, 0.100433, -0.369857, -0.179079), vec4(2.762822, 0.097775, 0.537687, 0.440675), vec4(0.182044, 0.402195, 0.451338, -0.964109), vec4(-0.451916, -1.098315, -0.694617, -0.424972), vec4(-1.819166, -1.024945, -0.038850, 0.256654), vec4(-0.252449, -0.710395, 0.198805, 0.281695), vec4(-0.892276, -0.541249, 1.163772, 0.279035), vec4(-0.855965, 0.550800, 1.477527, 1.090187), vec4(-0.232500, -0.100820, 0.867494, 0.820966), vec4(1.433131, -0.213990, 0.123319, 0.502171), vec4(0.099742, -0.362230, -0.653879, 0.266082), vec4(-0.571583, 2.168263, 0.353411, -0.353290), vec4(-0.741781, 0.464231, -0.193119, -1.162904), vec4(-1.544442, -0.699019, 0.100430, 0.275200), vec4(1.484661, -0.320194, 0.206049, -0.619480), vec4(-0.345264, 0.683632, -1.320729, 0.192233));\nconst vec4 cw38[16] = vec4[](vec4(-0.661351, -0.076776, -0.086678, -0.089707), vec4(-0.834186, -0.215674, 0.082120, -0.035283), vec4(-0.044855, -0.112767, -0.755779, 0.334991), vec4(-0.029672, -1.079602, 1.217038, -0.438678), vec4(-0.812699, 0.186526, -0.597586, -0.064164), vec4(-0.643222, -0.444788, -0.638786, 0.186762), vec4(-1.079504, 0.253630, 0.182562, -0.643195), vec4(-0.057292, -0.053454, -0.802020, 1.234054), vec4(0.622842, -0.009874, -0.091033, 0.158141), vec4(0.679765, 0.208367, 0.538176, -0.125431), vec4(-0.061174, 0.031330, 0.184291, -0.054175), vec4(0.144077, 1.392227, -0.868146, -0.499540), vec4(1.470663, 0.071355, -1.104544, 0.272374), vec4(-0.146854, 0.107773, 0.237856, -0.071513), vec4(-0.543885, -0.022835, -0.133864, 0.506246), vec4(-0.158483, 0.687809, 0.302285, -0.647680));\nconst vec4 cw39[16] = vec4[](vec4(0.979079, 0.045537, 0.561000, -0.004949), vec4(0.724044, 0.127240, 1.129219, -0.050147), vec4(0.436431, 0.027114, 0.219033, 0.113483), vec4(-0.479192, 0.273707, -0.717974, -0.042581), vec4(-1.543601, -1.500903, 0.349834, -0.465000), vec4(-0.972274, -0.119813, 0.839272, 0.219952), vec4(1.518195, 0.044083, -0.092249, 0.235748), vec4(0.000074, 0.821376, 0.031558, 0.030440), vec4(-0.816043, 0.036427, 0.889705, -0.070968), vec4(-1.883293, 0.333781, 0.376192, -0.077838), vec4(0.158638, 0.119200, 0.547253, -0.719842), vec4(0.604937, 0.138355, 0.936338, -0.336629), vec4(-0.061703, -1.455173, 0.919074, 0.408848), vec4(-0.649714, -0.039973, 0.166833, 0.120878), vec4(-0.101201, 0.624353, -0.295594, 0.348085), vec4(0.372167, 0.847125, -1.033517, -0.439475));\nconst vec4 cw40[16] = vec4[](vec4(1.198636, 0.135218, 0.199971, -0.632321), vec4(1.389216, 0.216280, -0.834131, 0.254993), vec4(-0.077599, -0.082129, 0.137564, 0.002177), vec4(0.541382, 2.926147, 0.942913, -0.100572), vec4(-3.047368, -2.722307, -3.474339, -0.045525), vec4(0.321725, 1.800198, 2.729126, -0.052687), vec4(-0.093639, -0.073492, 0.134198, 0.227222), vec4(-0.071589, 0.072879, -0.066607, -0.862305), vec4(0.431504, -0.006232, -0.293691, 0.038104), vec4(0.832664, -0.025682, 0.057866, -0.235368), vec4(-0.043171, 0.196100, 0.015261, -0.557449), vec4(0.484233, -1.108355, 1.846522, 0.476420), vec4(-0.700884, 2.400085, -2.826651, 0.189559), vec4(0.877088, -2.572093, 3.673924, 0.599709), vec4(-0.860072, -0.006512, 0.122588, 0.003327), vec4(0.383101, 0.451908, -0.028186, -0.201273));\nconst vec4 cw41[16] = vec4[](vec4(-1.062577, -0.085189, -1.410828, -0.251652), vec4(-1.129489, 0.216179, 0.119902, 0.435901), vec4(-0.370504, 0.474997, 1.615840, 0.573545), vec4(-0.583013, -2.506996, 0.456330, -1.198402), vec4(0.032787, 0.914177, 0.447642, 0.504895), vec4(-1.417641, 0.143993, -1.230305, -0.903227), vec4(1.755998, 0.208891, 0.355500, 0.657393), vec4(0.075768, -1.318051, -0.598055, 1.843178), vec4(-0.443889, -0.009282, 0.963084, 0.392497), vec4(0.507436, 0.178811, -0.203283, 0.249146), vec4(-0.220913, 0.122492, 0.996524, 0.329928), vec4(0.356075, -0.144309, 0.596789, -0.919964), vec4(0.405378, 0.679646, -0.236876, 1.325453), vec4(0.559742, -0.356631, -0.782760, -1.759717), vec4(0.470016, 0.900265, -0.724021, 0.400100), vec4(0.257102, -0.738910, 0.087357, 0.037992));\nconst vec4 cw42[16] = vec4[](vec4(-0.023790, 0.027923, 0.948433, 0.283411), vec4(0.268396, -0.341019, -1.675163, 0.307202), vec4(-1.852698, -0.637289, -3.322429, -0.145959), vec4(-1.110739, -1.190258, 1.213907, -1.076419), vec4(3.657455, 1.371518, -5.798108, -1.067384), vec4(-1.345641, 4.013348, 0.639879, -0.691314), vec4(-3.688954, -0.209462, -0.072311, -1.206184), vec4(0.431085, -1.702729, 1.476503, 3.277461), vec4(-0.056878, -0.315909, 0.358439, -2.787119), vec4(-0.554449, -0.643423, -3.589738, -1.502211), vec4(-0.861743, -0.464762, 2.532815, -3.238117), vec4(-0.442278, 5.479239, -1.236197, -3.734790), vec4(5.156182, -4.506278, 1.238714, -0.676106), vec4(2.775877, 3.231021, 0.335991, -0.585367), vec4(2.625448, -0.237999, -0.589362, 0.362290), vec4(-1.691660, -0.958241, -0.948233, -1.684189));\nconst vec4 cw43[16] = vec4[](vec4(0.410040, -0.167687, 0.000057, -0.945816), vec4(0.020132, 0.191257, -1.007943, 0.380819), vec4(0.291199, 0.141724, -0.124815, -0.193218), vec4(-0.212387, 0.513167, -1.153882, 0.400004), vec4(-1.771721, 1.747183, 0.728407, 0.167390), vec4(1.949498, -0.160832, 1.079021, -0.851959), vec4(0.875645, 0.585642, -0.333040, -0.499123), vec4(-1.052886, -0.389131, 0.267949, -0.678941), vec4(0.170310, 0.109379, -1.401058, 0.232818), vec4(1.261949, 0.517938, -2.448290, 0.216984), vec4(0.064455, 0.134301, 1.498405, -0.198270), vec4(0.544814, 0.016075, -1.297504, 1.009531), vec4(1.348614, 1.626219, -1.971865, -1.212661), vec4(3.161007, -0.846702, 0.370603, 0.414922), vec4(-2.473379, 0.232654, 0.515113, 1.073003), vec4(-0.590586, 0.236842, 1.317761, 1.047887));\nconst vec4 cw44[16] = vec4[](vec4(-0.798147, -0.244519, 0.224835, 0.283454), vec4(1.102415, -0.445797, -1.208242, 0.165194), vec4(0.353389, 0.122491, -0.386229, -0.247882), vec4(-0.271200, 1.160379, 0.809277, 0.052263), vec4(1.484412, 0.894330, 0.270255, -1.440274), vec4(0.775266, -2.571364, -0.667387, 0.594940), vec4(-0.566844, 0.197547, -0.736553, 1.157833), vec4(0.374350, 0.950103, -0.052045, 0.530330), vec4(0.486000, 0.017017, 0.257484, -0.991191), vec4(-1.441877, 0.304854, 0.333166, -0.068820), vec4(0.354963, -0.096816, -0.498171, 1.534675), vec4(0.718970, -1.019903, 1.427181, -0.367898), vec4(-1.964317, -0.778907, -0.526403, -0.553830), vec4(1.003521, 1.110420, -0.019348, 0.136508), vec4(1.122128, 0.044561, 0.244489, 0.902183), vec4(-0.308395, 0.216869, -1.623779, 0.119190));\nconst vec4 cw45[16] = vec4[](vec4(-1.161468, -0.048342, 0.101369, 0.493473), vec4(2.311230, -0.497851, -0.461622, 0.484130), vec4(-0.601421, 0.013026, -0.399319, 2.520558), vec4(1.363883, 0.499516, 0.858266, -0.979011), vec4(1.109928, 0.605954, -0.305061, -1.145329), vec4(1.280284, -2.164186, -1.114495, -1.205178), vec4(2.056523, 0.536558, -0.335724, -0.349276), vec4(-0.048404, -0.567768, -1.307490, -1.130128), vec4(-2.175973, -0.062153, 0.423051, 1.281362), vec4(1.415737, -0.925475, -0.278305, 0.077467), vec4(-0.197415, -0.124192, -0.452922, -1.412448), vec4(0.323638, -0.277448, 1.938593, -0.126456), vec4(-1.388997, -0.149137, -0.445727, 0.149737), vec4(-2.030404, 1.549137, -0.388898, 0.740532), vec4(0.453378, -0.202923, 0.292449, -1.398508), vec4(-0.567233, 1.080483, -0.165176, -1.552743));\nconst vec4 cw46[16] = vec4[](vec4(1.481920, 0.342617, 0.327975, 0.199017), vec4(0.084174, -0.440560, -1.842937, 0.258448), vec4(0.195139, 0.411296, -0.100566, 1.384024), vec4(0.198447, 0.686564, -0.313531, 0.183837), vec4(-0.771579, 2.769439, -2.437880, -0.022551), vec4(-0.358277, -0.266089, 0.283231, -0.068318), vec4(2.158310, 0.028680, -0.325791, -0.270236), vec4(0.748128, -0.705957, 1.109026, 0.886399), vec4(0.178343, -0.155948, -0.616731, 0.507045), vec4(0.287098, -0.615094, -1.558832, -0.142092), vec4(-0.053300, 0.322949, -0.181839, 0.511725), vec4(-1.221682, 0.749171, -0.908232, -0.157505), vec4(-1.987881, 0.616479, 0.285298, 1.342019), vec4(1.092818, 1.614464, 0.309237, -0.605236), vec4(-0.485083, -0.231656, -0.484549, -1.166788), vec4(0.768720, 0.843894, -0.487224, 0.415628));\nconst vec4 cw47[16] = vec4[](vec4(0.243245, -0.221566, -0.711254, -1.026011), vec4(-0.855617, 0.241381, 0.485275, 0.040773), vec4(-0.460773, 0.155288, 0.491023, -0.363291), vec4(-0.305569, 0.136642, -0.504846, 0.404222), vec4(-0.717843, 0.530234, -0.489949, 0.720651), vec4(0.939900, 0.920992, -0.800863, -0.286015), vec4(-1.214121, -0.177681, -0.199881, 0.544479), vec4(-0.235445, 1.452744, 0.405731, 0.675932), vec4(0.324625, -0.151358, 0.672335, -0.444448), vec4(0.455028, -0.340799, -1.069345, 0.053559), vec4(0.073344, 0.276125, 0.055029, 0.277803), vec4(-0.079243, 0.041425, -0.731784, -0.411318), vec4(-0.100377, -1.616009, -0.190762, 1.076996), vec4(-0.652115, 2.149880, -0.231674, 1.268034), vec4(-1.145573, 0.295257, 0.286772, 0.548349), vec4(0.807215, -0.358129, 0.071172, -0.774985));\nconst vec4 cw48[16] = vec4[](vec4(-0.230583, 0.065992, -0.173023, -0.017108), vec4(-0.411581, 0.038881, -0.508647, 0.284026), vec4(-0.063305, -0.061060, -0.917678, -0.089574), vec4(0.084586, -0.622833, 0.940371, 0.872784), vec4(1.605003, 0.061197, -0.432149, -0.650945), vec4(0.012083, 0.057512, -1.672039, -0.143181), vec4(-0.437836, -0.143501, -0.393646, -0.018738), vec4(-0.290703, -1.300938, -0.883624, -1.277111), vec4(1.478936, 0.037276, -1.255783, -0.851808), vec4(-0.198215, 0.005536, -0.555748, -0.074524), vec4(0.126147, -0.042485, -0.001426, -0.856499), vec4(1.056319, -0.146431, 3.229388, 0.760809), vec4(-0.175628, -0.836556, -0.201061, 0.155175), vec4(-0.348383, 1.005422, -1.611844, 0.939400), vec4(1.826047, -0.466313, 0.199203, -0.872668), vec4(0.218854, -0.562949, -0.068967, 1.411824));\nconst vec4 cw49[16] = vec4[](vec4(1.049344, 0.005886, 0.258797, 0.219354), vec4(-2.130306, 0.291667, 1.071822, 0.019648), vec4(0.082529, 0.043148, -0.087045, 0.058730), vec4(-0.312759, 2.927392, -3.684872, 0.012715), vec4(-4.819514, -0.142335, -0.256282, -0.660680), vec4(-1.969089, 4.020454, -0.199112, 0.113835), vec4(1.300638, -0.025376, 0.428954, -0.029860), vec4(0.230340, -0.157294, 0.300544, 2.655323), vec4(0.051602, 0.015867, 0.151807, 0.556464), vec4(-1.283872, -0.187497, 1.070806, 0.183730), vec4(0.109187, 0.110797, -0.241676, 0.491067), vec4(0.281505, 3.839245, -9.817674, 0.024040), vec4(8.470626, 0.953464, 0.153951, 0.480537), vec4(-2.320390, -1.795822, -0.149900, 0.095532), vec4(-0.077125, 0.027116, 0.058939, -0.105079), vec4(-0.009283, -0.054532, 0.098319, -0.193845));\nconst vec4 cw50[16] = vec4[](vec4(0.869030, 0.261497, -0.912266, 1.331953), vec4(-0.423664, 0.935382, -1.584762, 0.098429), vec4(0.205712, 0.063428, 0.234122, 1.009289), vec4(-0.006062, 0.226784, 0.464446, -0.616366), vec4(1.153057, -0.491570, -0.489086, 0.724646), vec4(-1.546510, -1.433273, 0.003114, -0.387761), vec4(0.799713, 0.597462, 0.886395, -0.366338), vec4(0.254473, -0.582118, -0.578650, -0.495760), vec4(0.630174, -0.038261, 1.537922, 0.152421), vec4(0.139237, -0.026942, -0.720076, 0.375274), vec4(-0.082600, 0.158583, 0.504419, -0.735117), vec4(0.833542, -0.254733, 1.122458, -1.210620), vec4(-0.791457, -0.057048, -0.413307, 0.076230), vec4(1.500890, 0.131058, -0.480939, -0.581393), vec4(0.130730, -0.202428, -0.357083, -0.099567), vec4(-0.160647, 0.057502, -1.386904, 0.881966));\nconst vec4 cw51[16] = vec4[](vec4(-0.428495, -0.259110, 0.427836, -0.203125), vec4(-0.831857, -0.938791, -0.415915, 0.076007), vec4(-0.166185, 0.165939, -0.358116, -0.435862), vec4(1.012806, -0.921658, 0.860587, -0.835949), vec4(-0.850082, 2.545678, 1.532169, -0.796736), vec4(-1.667538, -2.367110, 0.823572, 0.150475), vec4(0.393247, 0.026176, -0.283439, 0.251693), vec4(-0.551068, 0.162815, 0.879838, -2.112138), vec4(-0.194010, -0.043134, -0.543919, 0.053161), vec4(0.145529, 0.071304, 1.542607, 0.053521), vec4(0.014938, -0.131052, 0.052195, 1.041211), vec4(-0.405144, -1.237105, 0.365429, 0.517118), vec4(0.071139, 0.923330, -0.874511, 0.098904), vec4(-0.406134, 0.954646, -0.242964, 0.166283), vec4(1.203635, -0.206078, -0.401014, 0.601432), vec4(-0.193247, -0.787482, 0.026324, 1.908646));\nconst vec4 cw52[16] = vec4[](vec4(-0.616495, -0.052633, 0.087456, -0.058068), vec4(-0.491099, 0.045123, -0.457724, -0.261792), vec4(-0.303894, -0.351818, -0.526138, -0.169350), vec4(-0.132129, 0.847097, 0.750318, 0.529057), vec4(-1.379474, -0.224896, 0.661761, -0.579229), vec4(-2.080066, 2.815845, 1.417141, 0.087258), vec4(-2.259362, -0.261616, 0.810487, -0.304512), vec4(-0.180351, -1.089371, 0.720182, -2.258433), vec4(0.368487, -0.056270, -0.115014, 0.440855), vec4(-0.324715, -0.038399, -0.527870, -0.367636), vec4(-0.127573, 0.111831, -1.611891, -0.429712), vec4(-0.596224, 0.460071, 0.584547, 1.355081), vec4(0.502245, 2.342402, 0.487070, 0.584457), vec4(-1.378300, 0.828506, 1.372016, 0.134403), vec4(0.596675, -0.040860, -0.374181, -0.585273), vec4(-0.365087, -1.108535, 1.103297, -0.210960));\nconst vec4 cw53[16] = vec4[](vec4(0.168842, 0.058390, -0.280291, 0.290294), vec4(-1.326454, -0.088185, -0.564639, 0.049530), vec4(-0.189704, 0.186458, 0.276771, -0.115735), vec4(0.322237, 0.086546, 0.120973, 0.257344), vec4(0.672825, 0.663042, -0.436673, 0.519602), vec4(0.969879, -0.128521, 0.330487, -0.026629), vec4(0.309190, -0.236349, -0.181563, 0.072638), vec4(-0.319624, -0.059025, -0.286828, 0.726394), vec4(0.562171, -0.065314, 0.405449, -0.109466), vec4(0.639845, -0.473990, 0.758716, -0.090414), vec4(-0.027764, -0.071589, -0.788675, 0.352374), vec4(-0.209000, -1.494935, -0.832424, 0.084333), vec4(0.683186, 0.154648, -0.089451, -0.203753), vec4(-0.587289, -1.159042, -0.077165, 0.054017), vec4(-0.782830, -0.210396, 0.196365, -0.356508), vec4(0.022588, 0.413731, -1.080206, 0.714773));\nconst vec4 cw54[16] = vec4[](vec4(-0.527826, -0.137340, -0.542147, 0.162681), vec4(3.364710, -0.231161, -1.574065, 0.334014), vec4(0.422342, 1.024960, 1.135083, -0.818070), vec4(-0.696347, -3.158559, -1.305700, 1.065738), vec4(-0.926353, -0.177623, -1.473100, -0.344926), vec4(3.446500, -2.065285, 0.913429, -0.849242), vec4(2.895640, 0.481249, -0.434614, 1.028390), vec4(0.521450, -1.538524, -1.295384, -1.877086), vec4(-2.735454, 0.048263, -1.383705, -2.130000), vec4(-0.270595, -1.314186, 2.374984, -0.295666), vec4(0.451366, 0.404879, -0.518726, -0.231354), vec4(-0.508578, 0.673349, 1.178791, -0.927324), vec4(1.066824, 1.702435, 1.618393, -1.834814), vec4(0.547141, -1.233649, 0.118086, -0.079850), vec4(2.217662, -1.322386, -0.901168, -0.463069), vec4(0.028184, -2.226134, -1.142095, 1.399255));\nconst vec4 cw55[16] = vec4[](vec4(0.974753, -0.073247, -1.039553, 0.150228), vec4(-1.220019, -0.303939, -0.152163, 0.334491), vec4(0.348527, 0.336700, 0.150279, 0.053823), vec4(-0.528350, 1.441035, -0.390523, 0.453823), vec4(-0.043728, 0.944558, -0.248166, -0.357944), vec4(-0.472233, 2.152683, -0.930759, 0.207916), vec4(0.501081, -0.351408, -0.132292, -0.272134), vec4(-0.890575, -0.659973, -0.379802, 0.065104), vec4(-0.920591, -0.021021, 0.188048, -0.248681), vec4(0.837133, -0.379788, -0.709316, 0.020867), vec4(0.143761, 0.369567, 0.042803, 0.147209), vec4(0.210180, -0.650520, 1.379340, 1.172377), vec4(0.711441, -1.816247, 0.731577, -0.232197), vec4(-2.606263, 1.378439, 1.272990, -0.481451), vec4(-1.589612, -0.143366, -0.110452, -0.177249), vec4(-0.292377, 0.804014, 1.319618, 0.168881));\nconst vec4 cw56[16] = vec4[](vec4(-1.046354, 0.066577, -0.464424, 0.285809), vec4(-1.441378, 0.388490, 0.416499, -0.223678), vec4(-0.151535, -0.271962, -0.562394, 0.377561), vec4(-0.311779, 0.173193, 1.009732, 0.322863), vec4(-0.994810, 1.143761, 0.346102, -0.672277), vec4(0.405003, -0.477327, -0.461195, -0.403301), vec4(-1.762359, -0.498504, -0.104349, 0.458217), vec4(-0.810567, -0.314621, -0.597470, -1.047461), vec4(0.023964, 0.094290, 0.268107, 0.062619), vec4(-0.813837, -0.076030, -0.638758, 0.135889), vec4(-0.332809, -0.017688, 0.426650, -0.457980), vec4(-0.234590, 2.716653, 4.073116, -0.094782), vec4(-2.312152, 1.947707, -0.026306, -0.205444), vec4(0.736659, -0.044021, -0.713203, 0.649793), vec4(0.955560, -0.212263, -0.183413, -0.522689), vec4(-0.543141, -0.409282, -0.255594, 0.128506));\nconst vec4 cw57[16] = vec4[](vec4(-0.400151, 0.027032, 0.924290, 0.309451), vec4(0.176128, 0.234528, 0.012344, -0.085167), vec4(-0.177224, 0.266457, -0.157131, -0.488656), vec4(0.488313, 1.645624, -2.419120, -0.280153), vec4(2.325464, -0.238906, 0.041067, 0.482065), vec4(-0.219292, -1.077115, -0.796545, -0.034451), vec4(1.059614, 0.025056, 0.118647, 0.363864), vec4(0.317799, -0.271969, 0.693007, -0.810311), vec4(0.446561, 0.070220, 0.529060, 0.615102), vec4(-0.231532, -0.020741, -1.162252, 0.052168), vec4(-0.131369, 0.000492, -0.837041, 0.556119), vec4(0.243147, -0.034358, 0.939944, -0.204704), vec4(-2.277727, 1.757691, 0.553319, 0.246152), vec4(-1.107454, 0.600162, -0.499944, -0.066974), vec4(0.489837, -0.263884, 0.442041, -0.443683), vec4(0.401020, 0.165113, -0.984689, -0.146746));\nconst vec4 cw58[16] = vec4[](vec4(-0.934927, -0.184426, -0.811581, 0.389176), vec4(0.056550, -0.202772, -0.318057, -0.129344), vec4(0.376732, -0.227632, 0.154379, 0.042759), vec4(-0.833175, 0.724512, -0.696095, 1.147889), vec4(-1.430830, -1.522651, -0.610560, 0.392817), vec4(2.162156, 1.778103, -1.363674, 0.864113), vec4(1.675205, -0.333703, -0.160927, 0.089510), vec4(-0.117569, 0.284901, 1.575155, 1.681247), vec4(0.131644, -0.100471, 0.434894, 0.630728), vec4(1.193387, -1.009231, -0.352910, -0.479142), vec4(-0.037714, 0.358240, -0.722250, 0.138172), vec4(-0.881718, -0.683178, 2.378639, 0.586201), vec4(1.910270, 2.464350, -0.431306, 0.679446), vec4(-1.893468, -1.162847, -1.166095, 0.120654), vec4(-2.226759, 0.061223, 1.183338, -1.351278), vec4(-0.462825, 0.602032, 1.057575, -2.466145));\nconst vec4 cw59[16] = vec4[](vec4(-1.175740, 0.265952, 0.344478, 1.566953), vec4(2.292580, 0.532290, 1.759084, 0.542267), vec4(-0.809719, -1.064724, -0.336410, 2.654643), vec4(1.242956, -2.404448, -3.492206, 0.482507), vec4(-2.582952, -1.203734, 0.671280, 0.276193), vec4(1.569906, -2.620542, 2.521818, -1.309780), vec4(-2.202081, 1.960773, 0.034036, -1.041257), vec4(-0.277930, 2.260330, -1.942089, -0.245519), vec4(-4.192480, -0.501469, -0.073526, 1.445567), vec4(-0.296856, -0.026887, -1.372137, 0.309210), vec4(0.290815, 1.368682, -0.217940, -0.247849), vec4(-0.119810, 2.305617, 0.512927, 0.525948), vec4(-3.420170, 1.005647, -2.012619, 0.716468), vec4(-0.120082, 2.018860, 3.452324, -1.532094), vec4(3.249805, 1.128731, 0.767214, 1.525913), vec4(0.366076, 1.922533, 4.976537, 1.932639));\nconst vec4 cw60[16] = vec4[](vec4(0.030185, -0.160046, -1.355099, -1.033837), vec4(1.258073, -0.420142, -1.409861, 0.096906), vec4(-0.180713, 0.576320, -0.112562, 0.173531), vec4(0.546208, -0.582672, 0.274285, -0.295907), vec4(-3.299338, 8.845417, -0.210723, 1.172323), vec4(-0.242295, -6.038605, -2.208838, -0.078560), vec4(1.389198, -0.641635, -0.190902, 0.636502), vec4(-0.032601, 0.248383, 2.625603, 1.131216), vec4(-1.789930, 0.087057, 1.391419, -0.283749), vec4(2.373898, -0.911261, 0.102139, -0.151692), vec4(0.156867, -0.091648, -0.232368, 0.965455), vec4(1.379303, 0.485519, -3.441017, 0.522653), vec4(-3.726177, -0.204510, -2.317904, 2.699702), vec4(-3.447411, 5.125743, 3.741196, 0.985734), vec4(0.921583, 0.277562, 0.072047, 0.141977), vec4(0.071835, -0.315619, -2.218119, 3.100854));\nconst vec4 cw61[16] = vec4[](vec4(-0.271426, -0.093045, -0.252734, -0.545182), vec4(-0.256494, -0.293078, -1.169493, 0.632777), vec4(0.218123, -0.050623, 0.150361, -0.081559), vec4(-0.552489, -0.614873, -0.021991, -1.349820), vec4(0.261537, -0.124145, 0.505131, 0.869843), vec4(0.366058, 1.433797, -0.080785, 0.732333), vec4(-2.890036, 0.150350, -0.041041, -0.146195), vec4(-0.815930, 1.296987, 1.285080, 0.572935), vec4(0.807914, -0.077232, -0.855319, 0.856091), vec4(-1.050810, 0.681782, -2.197682, -0.847376), vec4(0.523964, 0.427025, -0.746392, 0.606332), vec4(0.387120, 0.335188, 0.445208, 0.187416), vec4(-0.362958, 0.981698, -0.051943, 0.838318), vec4(2.253647, -1.031473, 0.356166, 0.610277), vec4(-0.875559, -0.061990, -0.220238, -0.455001), vec4(-0.173804, 0.103263, 0.540006, -0.671742));\nconst vec4 cw62[16] = vec4[](vec4(0.517016, 0.045382, 0.755833, 0.012087), vec4(-1.384182, -0.240738, -0.657953, 0.162022), vec4(-0.391319, 0.020339, -0.271392, 0.618489), vec4(0.513852, -1.053145, -1.764800, 0.187052), vec4(0.615043, -1.012100, 1.943598, 0.377746), vec4(-1.703108, 1.229816, -0.571016, -0.853606), vec4(-0.605993, 0.086767, 0.652497, 0.954028), vec4(0.515697, -0.622570, -0.860698, 0.099874), vec4(0.520564, -0.087347, 0.624090, -0.430749), vec4(0.458013, 0.320125, -0.704663, 0.147983), vec4(0.112233, 0.097324, -0.285838, 0.536343), vec4(-0.218890, 1.461533, 1.560956, 1.640360), vec4(-2.079738, -0.232837, 0.510930, 0.949915), vec4(1.165270, 0.827272, -1.123000, 0.771249), vec4(-0.566353, 0.191168, 0.277021, -0.370403), vec4(0.308629, -0.729557, 0.040340, -0.526153));\nconst vec4 cw63[16] = vec4[](vec4(-4.240224, -0.324421, 1.618122, -0.260523), vec4(-0.392463, -1.110279, 3.336884, -0.869301), vec4(-0.064166, -0.538171, -1.292050, -0.573237), vec4(1.481017, -1.191788, 2.320661, -0.317925), vec4(-2.145974, -0.067159, 4.024102, 1.346026), vec4(-2.097828, 0.685678, -1.071975, 1.654299), vec4(-0.628373, 0.028533, 1.010368, 0.395446), vec4(-1.117807, 0.637490, -2.422776, -3.441670), vec4(0.645349, -0.155301, 0.467658, -0.847379), vec4(-2.438503, 1.275593, 2.975230, 0.195427), vec4(0.057446, 0.188342, -1.456264, -0.441250), vec4(-0.257830, 5.425198, -0.567067, -0.237732), vec4(-0.174297, 3.527139, -0.371932, -1.427507), vec4(-1.570473, -2.971652, 0.751045, -0.417967), vec4(-1.269766, -0.201568, 0.468269, 0.580788), vec4(-2.842607, -1.795005, -0.232366, -0.814403));\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 676, 733, 733, 3386]], "test": "untested"}
{"id": "wt3cz4", "name": "serg2", "author": "serega09", "description": "1", "tags": ["1"], "likes": 7, "viewed": 466, "published": 3, "date": "1608559111", "time_retrieved": "2024-07-30T20:28:58.619453", "image_code": "\nconst float dots = 40.; //number of lights\nconst float radius = .25; //radius of light ring\nconst float brightness = 0.02;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\t\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 c=vec3(0,0,0.1); //background color\n\t\t\n    for(float i=0.;i<dots; i++){\n\t\n\t\t//read frequency for this dot from audio input channel \n\t\t//based on its index in the circle\n\t\tfloat vol =  texture(iChannel0, vec2(i/dots, 0.0)).x;\n\t\tfloat b = vol * brightness;\n\t\t\n\t\t//get location of dot\n        float x = radius*cos(2.*3.14*float(i)/dots);\n        float y = radius*sin(2.*3.14*float(i)/dots);\n        vec2 o = vec2(x,y);\n\t    \n\t\t//get color of dot based on its index in the \n\t\t//circle + time to rotate colors\n\t\tvec3 dotCol = hsv2rgb(vec3((i + iTime*10.)/dots,1.,1.0));\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tc += b/(length(p-o))*dotCol;\n    }\n\t\n    //black circle overlay\t   \n\tfloat dist = distance(p , vec2(0));  \n\tc = c * smoothstep(0.26, 0.28, dist);\n\t \n\tfragColor = vec4(c,1);\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 146, 167, 167, 336], [340, 340, 397, 397, 1295]], "test": "untested"}
{"id": "tl3yz4", "name": "serg1", "author": "serega09", "description": "1", "tags": ["1"], "likes": 5, "viewed": 531, "published": 3, "date": "1608554848", "time_retrieved": "2024-07-30T20:28:59.507079", "image_code": "#define M_PI 3.14159265359\n\nvec4 rectangle(vec4 color, vec4 background, vec4 region, vec2 uv);\nvec4 capsule(vec4 color, vec4 background, vec4 region, vec2 uv);\nvec2 rotate(vec2 point, vec2 center, float angle);\nvec4 bar(vec4 color, vec4 background, vec2 position, vec2 diemensions, vec2 uv);\nvec4 rays(vec4 color, vec4 background, vec2 position, float radius, float rays, float ray_length, sampler2D sound, vec2 uv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Prepare UV and background\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspect;\n    vec4 color = mix(vec4(0.0, 0.0, 0.0, 1.0), vec4(0.0, 0, 0.0, 1.0), distance(vec2(aspect/2.0, 0.5), uv));\n    \n    //VISUALIZER PARAMETERS\n    const float RAYS = 96.0; //number of rays //Please, decrease this value if shader is working too slow\n    float RADIUS = 0.4; //max circle radius\n    float RAY_LENGTH = 0.3; //ray's max length //increased by 0.1\n    \n    color = rays(vec4(1.0), color, vec2(aspect/2.0, 1.0/2.0), RADIUS, RAYS, RAY_LENGTH, iChannel0, uv);\n    \n    fragColor = color;\n}\n\nvec4 rays(vec4 color, vec4 background, vec2 position, float radius, float rays, float ray_length, sampler2D sound, vec2 uv)\n{\n    float inside = (1.0 - ray_length) * radius; //empty part of circle\n    float outside = radius - inside; //rest of circle\n    float circle = 2.0*M_PI*inside; //circle lenght\n    for(int i = 1; float(i) <= rays; i++)\n    {\n        float len = outside * texture(sound, vec2(float(i)/rays, 0.0)).x; //length of actual ray\n        background = bar(color, background, vec2(position.x, position.y+inside), vec2(circle/(rays*2.0), len), rotate(uv, position, 360.0/rays*float(i))); //Added capsules\n    }\n    return background; //output\n}\n\nvec4 bar(vec4 color, vec4 background, vec2 position, vec2 diemensions, vec2 uv)\n{\n    return capsule(color, background, vec4(position.x, position.y+diemensions.y/2.0, diemensions.x/2.0, diemensions.y/2.0), uv); //Just transform rectangle a little\n}\n\nvec4 capsule(vec4 color, vec4 background,  vec4 region, vec2 uv) //capsule\n{\n    if(uv.x > (region.x-region.z) && uv.x < (region.x+region.z) &&\n       uv.y > (region.y-region.w) && uv.y < (region.y+region.w) || \n       distance(uv, region.xy - vec2(0.0, region.w)) < region.z || \n       distance(uv, region.xy + vec2(0.0, region.w)) < region.z)\n        return color;\n    return background;\n}\n\nvec2 rotate(vec2 point, vec2 center, float angle) //rotating point around the center\n{\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    point.x -= center.x;\n    point.y -= center.y;\n    \n    float x = point.x * c - point.y * s;\n    float y = point.x * s + point.y * c;\n    \n    point.x = x + center.x;\n    point.y = y + center.y;\n    \n    return point;\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3yz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 475, 507, 1114], [1116, 1116, 1241, 1241, 1775], [1777, 1777, 1858, 1858, 2025], [2027, 2027, 2103, 2103, 2418], [2420, 2420, 2506, 2506, 2804]], "test": "untested"}
{"id": "wtccR4", "name": "Floppy Column", "author": "dr2", "description": "Self-bending metallic sculpture", "tags": ["reflection", "coordinates", "bend"], "likes": 13, "viewed": 383, "published": 3, "date": "1608551284", "time_retrieved": "2024-07-30T20:29:00.421634", "image_code": "// \"Floppy Column\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Based on \"Decalled Floppy Tube 2\"\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nmat3 StdVuMat (float el, float az);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, qHit;\nfloat tCur, tCyc, dstFar, dLoop, sLoop, rCyl, tubRot, bCylRad, bCylHt;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b, c;\n  float dMin, d, hBase, aLoop, lb, s, rc;\n  dMin = dstFar;\n  hBase = 1.;\n  aLoop = 0.25 * pi / sLoop;\n  rc = 0.01;\n  q = p;\n  q.y -= 2. * hBase;\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  d = max (PrRoundBoxDf (vec3 (q.x, Rot2D (q.yz, - tubRot)), vec3 (rCyl - rc), rc),\n     -0.01 - q.x);\n  q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n  b = vec2 (length (q.xy) - dLoop, q.z);\n  b.xy = Rot2D (b.xy, tubRot);\n  lb = length (b);\n  s = PrRoundBox2Df (b, vec2 (rCyl - rc), rc);\n  d = min (d, max (s, dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi)))));\n  c = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n  s = max (PrRoundBoxDf (vec3 (Rot2D (vec2 (c.x, q.z), - tubRot), c.y).xzy,\n     vec3 (rCyl - rc), rc), -0.01 - c.y);\n  d = min (d, s);\n  qHit = vec3 (vec2 (atan (q.y, - q.x) * dLoop / (0.25 * pi), atan (b.x, b.y)) / pi, lb);\n  DMIN (1);\n  q = p;\n  q.y -= hBase - 0.5 * rCyl;\n  d = PrRoundBoxDf (q, vec3 (0.8 * rCyl, hBase - 0.5 * rCyl, 0.8 * rCyl) - 0.05, 0.05);\n  DMIN (2);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s, vn;\n  float d, a, b, w, srdy;\n  d = dstFar;\n  vn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = (- b + sqrt (w)) / a;\n      s = ro + d * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vn.xz = - s.xz / bCylRad;\n    else {\n      d = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vn.y = - srdy;\n    }\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec4 vc, db4;\n  vec3 ltDir, vn, col, rg, vnCyl;\n  vec2 qw, wSize;\n  float dCyl, hy, y, b, a, f, ga, ltDist, sh;\n  bool isLit;\n  isLit = true;\n  db4 = InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  dCyl = db4.x;\n  vnCyl = db4.yzw;\n  if (vnCyl.y == 0.) {\n    ro += dCyl * rd;\n    vn = vnCyl;\n    hy = mod (ro.y / bCylHt + 0.5, 1.) - 0.5;\n    a = atan (vn.x, - vn.z) / pi;\n    wSize = vec2 (0.28, 0.33);\n    qw = abs (vec2 (mod (32. * 0.5 * (1. + a) + 0.5, 1.), abs (hy)) - 0.5) - 0.5 * wSize;\n    if (Maxv2 (abs (qw) - wSize * vec2 (0.43, 0.47)) < 0.) {\n      col = vec3 (0.1, 0.2, 0.5);\n      isLit = false;\n    } else {\n      col = vec3 (0.4);\n      if (Maxv2 (qw - 0.5 * wSize) > 0.) {\n        y = abs (abs (hy) - 0.5) - 0.5;\n        if (y > - 0.3/16.) {\n          col = vec3 (0.65);\n          vn.xz = Rot2D (vn.xz, - pi * a);\n          vn.yz = Rot2D (vn.yz, 0.15 * pi * (1. - 2. * SmoothBump (0.15, 0.25, 0.05,\n             16. * (0.5 - y))) * sign (hy));\n          vn.xz = Rot2D (vn.xz, pi * a);\n        } else {\n          col = vec3 (0.7, 0.75, 0.7);\n          qw = 8. * vec2 (12. * a, 2. * hy);\n          rg = ShStagGrid (qw);\n          col *= rg.y * (1. - 0.2 * Noisefv2 (32. * qw));\n          rg.xz *= sign ((abs (vn.x) > abs (vn.z)) ? vn.x : vn.z);\n          if (abs (vn.x) > abs (vn.z)) {\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        }\n      }\n    }\n  } else if (vnCyl.y > 0.) {\n    ro += dCyl * rd;\n    vc = HexVor (0.7 * ro.zx);\n    b = 1. - smoothstep (-0.2, -0.05, rd.y) * smoothstep (0.4, 0.8, dCyl / (1.6 * bCylRad));\n    vn = mix (vec3 (0., 1., 0.), normalize (vec3 (- vc.y, 4., - vc.z)),\n       b * SmoothBump (0.05, 0.13, 0.02, vc.x));\n    col = vec3 (0.65, 0.62, 0.6) * (0.7 + 0.3 * b * step (0.06 + 0.03 * vc.w, vc.x) *\n       (1. - 0.3 * Noisefv2 (16. * ro.xz)));\n  } else {\n    ro += dCyl * rd;\n    f = 0.;\n    qw = ro.xz / bCylRad;\n    ga = 2.39996;\n    for (float n = 0.; n < 128.; n ++) f += 1. - smoothstep (0.02, 0.025,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col = mix (vec3 (0.2, 0.2, 0.4), vec3 (1., 1., 0.7), f);\n    isLit = false;\n  }\n  if (isLit) {\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    sh = (vnCyl.y > -0.5) ? ObjSShadow (ro, ltDir, ltDist) : 1.;\n    col *= 0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir;\n  float dstObj, tCyc, t, sh, ltDist;\n  bool doRefl;\n  tCyc = 20.;\n  t = tCur / tCyc;\n  tubRot = mod (5. * t, 2. * pi);\n  sLoop = 1./2. + 20. * pow (1. - SmoothBump (0.25, 0.75, 0.24, mod (t, 1.)), 8.);\n  dLoop = 6. * sLoop;\n  rCyl = 1.5;\n  HexVorInit ();\n  doRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar && idObj == 1) {\n    ro += dstObj * rd;\n    doRefl = true;\n    rd = reflect (rd, ObjNf (ro));\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col = vec3 (1.);\n    else if (idObj == 2) col = vec3 (0.5);\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    sh = ObjSShadow (ro, ltDir, ltDist);\n    col = col * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.));\n  } else col = BgCol (ro, rd);\n  if (doRefl) col = mix (col, 0.9 * BgCol (ro, rd), 0.9);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, tSmooth, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = -0.05 * pi;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    t = mod (0.005 * tCur, 2.);\n    tSmooth = (floor (32. * t) + smoothstep (0.9, 1., mod (32. * t, 1.))) / 32.;\n    az = 2.5 * pi * (0.5 - abs (tSmooth - 1.));\n  }\n  el = clamp (el, -0.2 * pi, -0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  bCylRad = 32.;\n  bCylHt = 12.;\n  ro = vuMat * vec3 (0., 0., -0.95 * bCylRad);\n  ro.y += 0.5 * bCylHt;\n  zmFac = 3.5;\n  dstFar = 3. * bCylRad;\n  ltPos = vec3 (0., 1.5 * bCylHt, 0.9 * bCylRad);\n  ltPos.xz = Rot2D (ltPos.xz, -0.2 * pi);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtccR4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[958, 958, 980, 980, 2046], [2048, 2048, 2081, 2081, 2286], [2288, 2288, 2309, 2309, 2564], [2566, 2566, 2615, 2615, 2855], [2857, 2857, 2891, 2891, 3383], [3385, 3385, 3411, 3411, 3761], [3763, 3763, 3794, 3794, 6332], [6334, 6334, 6369, 6369, 7311], [7313, 7313, 7366, 7366, 8677], [8679, 8679, 8725, 8725, 8772], [8774, 8774, 8821, 8821, 8868], [8870, 8870, 8894, 8894, 9124], [9126, 9126, 9150, 9150, 9210], [9236, 9236, 9256, 9256, 9476], [9478, 9478, 9500, 9500, 10096], [10098, 10098, 10134, 10134, 10340], [10342, 10342, 10364, 10364, 10391], [10393, 10393, 10415, 10415, 10453], [10455, 10455, 10485, 10485, 10598], [10600, 10600, 10645, 10645, 10748], [10750, 10750, 10807, 10807, 10890], [10924, 10924, 10948, 10948, 11008], [11010, 11010, 11034, 11034, 11164], [11166, 11166, 11191, 11191, 11377], [11379, 11379, 11408, 11408, 11620], [11622, 11622, 11661, 11661, 11841]], "test": "untested"}
{"id": "wt3cR4", "name": "Cannabis curve fourier", "author": "moolet", "description": "Copied from Sparkling Cookie", "tags": ["fourier", "cannabis"], "likes": 1, "viewed": 281, "published": 3, "date": "1608547917", "time_retrieved": "2024-07-30T20:29:01.513714", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Copied from Sparkling Cookie\n// https://cookie.paris/\n// Leon Denise (ponk) 2019.08.30\n// Licensed under hippie love conspiracy\n\n// generated with discrete Fourier transform\nvec2 cookie(float t) {\n\treturn vec2(\n    cos(-1.0*t+(-2.4403277692655174))*69.2008084909855  + cos(1.0*t+(2.4403277692657914))*69.20080849098497  + cos(-6.0*t+(2.6213702343184933))*12.251797005120302  + cos(6.0*t+(-2.6213702343183383))*12.251797005119094  + cos(4.0*t+(-1.224961706805486))*7.147274116426511  + cos(-4.0*t+(1.2249617068053773))*7.147274116426462  + cos(8.0*t+(2.2571880180201447))*6.479345440556433  + cos(-8.0*t+(-2.2571880180201864))*6.479345440556108  + cos(7.0*t+(1.3814370801292375))*6.205334211057381  + cos(-7.0*t+(-1.3814370801292382))*6.20533421105694  + cos(-11.0*t+(-1.713574579754429))*5.596649528484625  + cos(11.0*t+(1.7135745797543585))*5.5966495284845825  + cos(3.0*t+(1.0633840562073618))*4.770159064403402  + cos(-3.0*t+(-1.0633840562073216))*4.770159064401015  + cos(10.0*t+(0.8460110741099989))*3.99254590417662  + cos(-10.0*t+(-0.8460110741097976))*3.992545904176295  + cos(-2.0*t+(2.9951614398794897))*3.808432833225127  + cos(2.0*t+(-2.995161439878719))*3.808432833220635  + cos(-12.0*t+(-2.5690352678453285))*3.65851629688175  + cos(12.0*t+(2.569035267845671))*3.6585162968801836  + cos(-14.0*t+(-1.2247562661702984))*2.3449921907955495  + cos(14.0*t+(1.2247562661703113))*2.344992190795247  + cos(-5.0*t+(-2.7978048776915756))*2.1989253235385307  + cos(5.0*t+(2.797804877691702))*2.198925323537799  + cos(18.0*t+(-1.664499961273363))*1.3335145771918824  + cos(-18.0*t+(1.6644999612735436))*1.3335145771918566  + cos(-17.0*t+(2.564784161266749))*1.2327667429998548  + cos(17.0*t+(-2.5647841612660716))*1.2327667429996003  + cos(27.0*t+(-0.0031701256557761636))*1.144082528135724  + cos(-27.0*t+(0.003170125655494671))*1.1440825281356022  + cos(16.0*t+(-0.07526081986761093))*1.059329175462445  + cos(-16.0*t+(0.07526081986745027))*1.0593291754612058  + cos(-28.0*t+(-0.859176805339215))*1.007292976061883  + cos(28.0*t+(0.8591768053392645))*1.007292976061752  + cos(15.0*t+(2.015007627466402))*0.8712157455596117  + cos(-15.0*t+(-2.0150076274663475))*0.8712157455595354  + cos(23.0*t+(-0.48904974486523134))*0.7461462837617063  + cos(-23.0*t+(0.4890497448673186))*0.7461462837603837  + cos(9.0*t+(0.014629423309141671))*0.6938308009111527  + cos(-9.0*t+(-0.014629423309481051))*0.6938308009083306  + cos(-13.0*t+(2.9639115724641503))*0.644783377090706  + cos(13.0*t+(-2.963911572463342))*0.6447833770898307  + cos(20.0*t+(0.23339326072137725))*0.6072964627667031  + cos(-20.0*t+(-0.23339326072116248))*0.607296462766389  + cos(24.0*t+(0.37634807156893324))*0.598124495937591  + cos(-24.0*t+(-0.3763480715692308))*0.5981244959366907  + cos(-22.0*t+(1.4164422838330974))*0.5865726385042156  + cos(22.0*t+(-1.4164422838331971))*0.5865726385039164  + cos(33.0*t+(-1.0023039967135314))*0.555227138277511  + cos(-33.0*t+(1.0023039967136584))*0.5552271382774846  + cos(25.0*t+(1.2257046462887455))*0.4912322459843405  + cos(-25.0*t+(-1.2257046462906858))*0.4912322459843156  + cos(-49.0*t+(2.8527429952095527))*0.41785406815472  + cos(49.0*t+(-2.852742995208766))*0.4178540681543441  + cos(-29.0*t+(1.41294405522611))*0.3828328587202293  + cos(29.0*t+(-1.412944055225513))*0.3828328587199359  + cos(-47.0*t+(1.5249738345742392))*0.36570352211759066  + cos(47.0*t+(-1.5249738345728425))*0.36570352211734414  + cos(36.0*t+(-1.6872741798986783))*0.3366074152788767  + cos(-36.0*t+(1.6872741798991027))*0.33660741527876437  + cos(-42.0*t+(2.7773043173656116))*0.31847123076270206  + cos(42.0*t+(-2.7773043173668563))*0.3184712307624114  + cos(57.0*t+(0.85794403387866))*0.2950506784859951  + cos(-57.0*t+(-0.8579440338788967))*0.2950506784856082  + cos(109.0*t+(2.420432639167438))*0.2864652306194673  + cos(-109.0*t+(-2.4204326391677293))*0.28646523061937296  + cos(-85.0*t+(-0.220496008453927))*0.2703281435181849  + cos(85.0*t+(0.2204960084535132))*0.2703281435179557  + cos(-46.0*t+(2.4607647353629716))*0.2688038678507486  + cos(46.0*t+(-2.460764735361125))*0.2688038678507361  + cos(-90.0*t+(1.58434689027434))*0.26691822072315596  + cos(90.0*t+(-1.584346890271403))*0.2669182207218282  + cos(-39.0*t+(-0.8003403012384321))*0.2575393853148227  + cos(39.0*t+(0.8003403012381345))*0.2575393853147317  + cos(-97.0*t+(1.8179525152708165))*0.2549105644524268  + cos(97.0*t+(-1.8179525152709284))*0.25491056445227595  + cos(108.0*t+(-1.7406603677193637))*0.2508554569742287  + cos(-108.0*t+(1.740660367720814))*0.2508554569741185  + cos(-93.0*t+(2.3002001715661975))*0.24483934271636426  + cos(93.0*t+(-2.3002001715664573))*0.2448393427161183  + cos(34.0*t+(0.004228771937002079))*0.23926130730641185  + cos(-34.0*t+(-0.004228771938156693))*0.23926130730613798  + cos(-38.0*t+(2.827774801216534))*0.2281375648164417  + cos(38.0*t+(-2.827774801215605))*0.2281375648161924  + cos(91.0*t+(2.1842291013692714))*0.2275477976554989  + cos(-91.0*t+(-2.184229101370537))*0.227547797655358  + cos(114.0*t+(0.39254164066628544))*0.2242161245699898  + cos(-114.0*t+(-0.39254164066617636))*0.2242161245698307  + cos(-94.0*t+(-1.8414387318237357))*0.2176681498126028  + cos(94.0*t+(1.84143873182475))*0.2176681498123367  + cos(-45.0*t+(-2.9191270566476275))*0.21693456635769504  + cos(45.0*t+(2.9191270566484926))*0.21693456635746153  + cos(30.0*t+(-0.5261344373631028))*0.19978055229876532  + cos(-30.0*t+(0.5261344373601451))*0.19978055229846717  + cos(-32.0*t+(1.8359828050214277))*0.1919483221718334  + cos(32.0*t+(-1.8359828050188771))*0.19194832217153987  + cos(62.0*t+(2.1647432968440716))*0.19023048748143173  + cos(-62.0*t+(-2.1647432968440308))*0.1902304874812837  + cos(50.0*t+(-2.160048238959487))*0.1859396805870115  + cos(-50.0*t+(2.1600482389626205))*0.18593968058680918  + cos(0.0)*0.18507295910315838  + cos(76.0*t+(-1.385423326871277))*0.1781473177318734  + cos(-76.0*t+(1.3854233268703275))*0.178147317731769  + cos(-102.0*t+(-2.5018436804328195))*0.17344091102292172  + cos(102.0*t+(2.5018436804322723))*0.17344091102277742  + cos(54.0*t+(1.4463803498199193))*0.16597967429739083  + cos(-54.0*t+(-1.4463803498224228))*0.1659796742971473  + cos(71.0*t+(0.6531607893170484))*0.16050368968594783  + cos(-71.0*t+(-0.653160789314777))*0.16050368968571851  + cos(103.0*t+(0.3416839083752039))*0.15874200690205004  + cos(-103.0*t+(-0.3416839083758823))*0.15874200690151227  + cos(-21.0*t+(-1.6631986427895602))*0.1544778863706758  + cos(21.0*t+(1.6631986427914638))*0.1544778863701716  + cos(-116.0*t+(0.8637636398882478))*0.15036733393323604  + cos(116.0*t+(-0.8637636398884533))*0.15036733393287396  + cos(-111.0*t+(-0.9975349560925866))*0.14858253074223765  + cos(111.0*t+(0.9975349560935954))*0.14858253074206393  + cos(64.0*t+(0.8799156661961428))*0.14111778383873907  + cos(-64.0*t+(-0.8799156661952432))*0.1411177838378886  + cos(-63.0*t+(-3.086914610395199))*0.14095923079897252  + cos(63.0*t+(3.0869146103945755))*0.14095923079832026  + cos(-58.0*t+(-1.5575470272931498))*0.1403694183807287  + cos(58.0*t+(1.5575470272932075))*0.1403694183807219  + cos(-51.0*t+(-2.3568970265918088))*0.13700124663100985  + cos(51.0*t+(2.356897026591012))*0.13700124663095054  + cos(48.0*t+(-0.6289437524744339))*0.1365769862705299  + cos(-48.0*t+(0.6289437524667053))*0.1365769862678216  + cos(40.0*t+(1.2715976132158806))*0.13638606446371265  + cos(-40.0*t+(-1.2715976132154962))*0.1363860644636687  + cos(-65.0*t+(-1.701096624251085))*0.134797651116047  + cos(65.0*t+(1.7010966242519352))*0.1347976511147395  + cos(35.0*t+(-2.723210633695396))*0.12919971543935047  + cos(-35.0*t+(2.7232106336971817))*0.129199715439343  + cos(117.0*t+(2.9645424602593016))*0.12574048515162442  + cos(-117.0*t+(-2.9645424602578974))*0.12574048515159067  + cos(-105.0*t+(1.1561070001329703))*0.1250295371855142  + cos(105.0*t+(-1.156107000133482))*0.1250295371847451  + cos(84.0*t+(2.5151014088471473))*0.12381478454316078  + cos(-84.0*t+(-2.5151014088511343))*0.12381478454246053  + cos(82.0*t+(0.5435199888217789))*0.12286279576191896  + cos(-82.0*t+(-0.5435199888220207))*0.12286279576172554  + cos(37.0*t+(2.6482382580411374))*0.12183930300908266  + cos(-37.0*t+(-2.6482382580409194))*0.12183930300903138  + cos(107.0*t+(-2.6371938940245903))*0.12157572062906576  + cos(-107.0*t+(2.6371938940288295))*0.12157572062861326  + cos(-43.0*t+(1.8356129134015775))*0.11871452646408666  + cos(43.0*t+(-1.835612913396511))*0.11871452646367697  + cos(-83.0*t+(1.4494026052169895))*0.11848458875825453  + cos(83.0*t+(-1.4494026052140914))*0.11848458875796314  + cos(19.0*t+(2.7133642916818275))*0.11686711887972545  + cos(-19.0*t+(-2.7133642916829808))*0.11686711887927126  + cos(-197.0*t+(2.5312816940210174))*0.11637693454815891  + cos(197.0*t+(-2.5312816940262284))*0.11637693454754398  + cos(101.0*t+(1.579241176742408))*0.11433203764165004  + cos(-101.0*t+(-1.5792411767456114))*0.11433203763983538  + cos(73.0*t+(-0.6024964315443964))*0.11271108508251668  + cos(-73.0*t+(0.6024964315414695))*0.11271108508214053  + cos(41.0*t+(0.23201698237676735))*0.112083415756651  + cos(-41.0*t+(-0.23201698237670176))*0.11208341575655394  + cos(162.0*t+(-1.8923944416037497))*0.11139927188384362  + cos(-162.0*t+(1.892394441602517))*0.11139927188368519  + cos(88.0*t+(-0.05403148309407222))*0.11021779058626725  + cos(-88.0*t+(0.05403148309908149))*0.11021779058435918  + cos(-99.0*t+(-3.0898673835472357))*0.10721258477167342  + cos(99.0*t+(3.089867383549182))*0.10721258477127946  + cos(-129.0*t+(2.207104633319914))*0.10697859661708284  + cos(129.0*t+(-2.2071046333181545))*0.10697859661674283  + cos(-100.0*t+(2.2974854528934565))*0.10694427630797647  + cos(100.0*t+(-2.2974854528901054))*0.10694427630761082  + cos(-80.0*t+(1.1996979720998222))*0.10551772891135493,    \n    cos(1.0*t+(0.8651505551174499))*65.31890670125527  + cos(-1.0*t+(-0.8651505551170989))*65.31890670125249  + cos(0.0*t+(3.141592653589793))*28.555328761474318  + cos(4.0*t+(0.31786288490473924))*15.584246529832578  + cos(-4.0*t+(-0.31786288490476755))*15.584246529832368  + cos(5.0*t+(-1.952185332809557))*15.048430031517642  + cos(-5.0*t+(1.9521853328096717))*15.048430031516673  + cos(6.0*t+(2.038641278172281))*10.988876671731964  + cos(-6.0*t+(-2.0386412781720753))*10.988876671731296  + cos(15.0*t+(0.40436857734231585))*4.638754781239754  + cos(-15.0*t+(-0.4043685773423752))*4.6387547812396175  + cos(13.0*t+(-1.3271377309084518))*3.1579370810506138  + cos(-13.0*t+(1.327137730908613))*3.1579370810506107  + cos(3.0*t+(2.580072119931167))*2.8736143983544635  + cos(-3.0*t+(-2.580072119930381))*2.873614398353869  + cos(7.0*t+(2.8741861852036976))*2.679168215907155  + cos(-7.0*t+(-2.874186185203604))*2.679168215907147  + cos(-10.0*t+(0.8402243856231759))*2.217996965705609  + cos(10.0*t+(-0.8402243856233111))*2.2179969657055514  + cos(-18.0*t+(-3.0472920038327675))*1.8207162605502345  + cos(18.0*t+(3.047292003832855))*1.8207162605501563  + cos(25.0*t+(2.7725533981291854))*1.4897073875391167  + cos(-25.0*t+(-2.7725533981282666))*1.4897073875379405  + cos(-9.0*t+(1.7271983230678838))*1.4265405954265218  + cos(9.0*t+(-1.727198323067721))*1.4265405954264065  + cos(8.0*t+(0.8332575770027062))*1.2216360646075843  + cos(-8.0*t+(-0.8332575770028605))*1.2216360646075395  + cos(-23.0*t+(-1.0804644433015607))*1.1833535432602982  + cos(23.0*t+(1.0804644433016755))*1.1833535432578555  + cos(21.0*t+(-0.6032519644052451))*1.0588323106881905  + cos(-21.0*t+(0.6032519644055018))*1.0588323106881357  + cos(19.0*t+(-2.364769097237809))*1.040335307226024  + cos(-19.0*t+(2.36476909723788))*1.0403353072259292  + cos(-16.0*t+(-1.2614383776205014))*1.014776129642542  + cos(16.0*t+(1.261438377623048))*1.0147761296420157  + cos(-28.0*t+(0.9071482328312468))*0.9554403196159699  + cos(28.0*t+(-0.9071482328313146))*0.955440319615885  + cos(11.0*t+(-2.9826823885467624))*0.8745012316801589  + cos(-11.0*t+(2.982682388547123))*0.8745012316801046  + cos(-29.0*t+(0.03913431790943747))*0.7692646737343826  + cos(29.0*t+(-0.039134317909065984))*0.769264673734036  + cos(14.0*t+(-0.4784238318997904))*0.7601926205703019  + cos(-14.0*t+(0.47842383189996923))*0.7601926205702392  + cos(26.0*t+(-2.6478356753547607))*0.6770445793985159  + cos(-26.0*t+(2.6478356753538974))*0.6770445793979386  + cos(17.0*t+(2.0966385116613147))*0.6590709797550195  + cos(-17.0*t+(-2.096638511660353))*0.6590709797548258  + cos(-31.0*t+(-1.7228460764486515))*0.6107435334999121  + cos(31.0*t+(1.7228460764492557))*0.6107435334998523  + cos(-40.0*t+(-0.0651920218612492))*0.4890222970551183  + cos(40.0*t+(0.06519202186138805))*0.4890222970551039  + cos(-24.0*t+(-1.947492725545948))*0.4768372324548341  + cos(24.0*t+(1.9474927255461847))*0.476837232454748  + cos(-50.0*t+(-2.329612262052369))*0.4233447578057375  + cos(50.0*t+(2.3296122620530695))*0.4233447578056912  + cos(27.0*t+(-1.8830790429497732))*0.38529618631322105  + cos(-27.0*t+(1.883079042951346))*0.3852961863129794  + cos(-41.0*t+(2.2795956884744872))*0.3532730644517214  + cos(41.0*t+(-2.279595688475245))*0.35327306445162726  + cos(109.0*t+(0.10164791576222479))*0.33186001092302553  + cos(-109.0*t+(-0.10164791576162562))*0.3318600109229166  + cos(-20.0*t+(-1.254232935979429))*0.31827016982049233  + cos(20.0*t+(1.2542329359792357))*0.31827016982007333  + cos(-95.0*t+(-0.5345424002831306))*0.283990362516922  + cos(95.0*t+(0.5345424002832788))*0.28399036251684234  + cos(-96.0*t+(1.7291277745164755))*0.2521932235264325  + cos(96.0*t+(-1.7291277745182483))*0.2521932235264071  + cos(91.0*t+(0.11282600368112272))*0.22817192429016603  + cos(-91.0*t+(-0.11282600367932635))*0.22817192428998606  + cos(33.0*t+(-2.7727499703691336))*0.22793401098117602  + cos(-33.0*t+(2.772749970370273))*0.22793401098104846  + cos(-103.0*t+(-1.2017807603166384))*0.22460069723749082  + cos(103.0*t+(1.2017807603165356))*0.22460069723673795  + cos(-89.0*t+(1.7124193638368796))*0.21747778761877906  + cos(89.0*t+(-1.7124193638362275))*0.21747778761852576  + cos(55.0*t+(-2.8257693310452017))*0.2152902408153102  + cos(-55.0*t+(2.8257693310440484))*0.2152902408152419  + cos(-46.0*t+(1.1601795442137033))*0.21283927288626  + cos(46.0*t+(-1.160179544213888))*0.2128392728862181  + cos(87.0*t+(2.977503684570063))*0.21250938302898872  + cos(-87.0*t+(-2.9775036845745317))*0.21250938302864922  + cos(-67.0*t+(-1.4408860948478193))*0.21248906352008243  + cos(67.0*t+(1.440886094849722))*0.21248906352006872  + cos(-39.0*t+(-2.301154168622928))*0.2064073422671597  + cos(39.0*t+(2.301154168622511))*0.20640734226712923  + cos(97.0*t+(2.2465252673389537))*0.19677024633021953  + cos(-97.0*t+(-2.2465252673380407))*0.19677024632997445  + cos(-72.0*t+(0.5399016852511805))*0.19558948988124528  + cos(72.0*t+(-0.5399016852501274))*0.1955894898811444  + cos(92.0*t+(-1.998729069350953))*0.19399762563866102  + cos(-92.0*t+(1.9987290693519308))*0.19399762563855494  + cos(-51.0*t+(-0.24823340910233666))*0.18776619431384084  + cos(51.0*t+(0.2482334091024692))*0.1877661943137927  + cos(-30.0*t+(2.3823381824874548))*0.1818649936144726  + cos(30.0*t+(-2.3823381824868246))*0.18186499361354905  + cos(-64.0*t+(1.0742464350444643))*0.18139073781353415  + cos(64.0*t+(-1.0742464350483207))*0.181390737812517  + cos(83.0*t+(2.650694095073279))*0.1801082384688669  + cos(-83.0*t+(-2.6506940950702407))*0.18010823846873875  + cos(-34.0*t+(-0.8838371554070873))*0.17763147886373648  + cos(34.0*t+(0.8838371554077402))*0.17763147886368202  + cos(-65.0*t+(0.23130662264184423))*0.16899375804443037  + cos(65.0*t+(-0.2313066226383187))*0.16899375804404773  + cos(-12.0*t+(-0.5958646749624847))*0.16719290656407776  + cos(12.0*t+(0.5958646749627651))*0.16719290656370597  + cos(36.0*t+(2.593097471652781))*0.165301551472193  + cos(-36.0*t+(-2.593097471651556))*0.1653015514721567  + cos(-101.0*t+(0.6442649995861152))*0.16486241018174463  + cos(101.0*t+(-0.6442649995912828))*0.16486241018031197  + cos(99.0*t+(1.028118953015285))*0.16242695564188767  + cos(-99.0*t+(-1.0281189530148656))*0.16242695564180265  + cos(-57.0*t+(0.9756663402128001))*0.16138693659225498  + cos(57.0*t+(-0.9756663402112361))*0.16138693659210607  + cos(-108.0*t+(-2.2761260334632403))*0.1613555968910301  + cos(108.0*t+(2.2761260334650033))*0.16135559689097062  + cos(37.0*t+(-2.6642683888952647))*0.15370336439879204  + cos(-37.0*t+(2.664268388898257))*0.15370336439846624  + cos(153.0*t+(0.245928497751659))*0.1534195814992547  + cos(-153.0*t+(-0.2459284977493412))*0.1534195814990075  + cos(59.0*t+(0.9297083708227801))*0.15324429334076037  + cos(-59.0*t+(-0.9297083708221752))*0.15324429334073614  + cos(166.0*t+(2.13395646714667))*0.15303297551117534  + cos(-166.0*t+(-2.133956467147353))*0.15303297551116155  + cos(-62.0*t+(2.6301186944880137))*0.1528580542931282  + cos(62.0*t+(-2.630118694486849))*0.15285805429308946  + cos(-70.0*t+(2.336119074970455))*0.15175775795073887  + cos(70.0*t+(-2.3361190749715757))*0.15175775795063196  + cos(-47.0*t+(0.30971752923640156))*0.15091010243710462  + cos(47.0*t+(-0.30971752923453305))*0.1509101024370587  + cos(-116.0*t+(-2.9378930657823403))*0.14836231745185818  + cos(116.0*t+(2.9378930657838094))*0.1483623174514922  + cos(-102.0*t+(2.8647909864386962))*0.14400474143289593  + cos(102.0*t+(-2.8647909864402))*0.14400474143287983  + cos(81.0*t+(0.9420817189573863))*0.1401700985609577  + cos(-81.0*t+(-0.9420817189612183))*0.1401700985604733  + cos(77.0*t+(-2.3683667983191103))*0.13867138764848602  + cos(-77.0*t+(2.368366798319337))*0.13867138764834133  + cos(-112.0*t+(-2.6216527537609187))*0.1379201592131512  + cos(112.0*t+(2.621652753758431))*0.1379201592129405  + cos(93.0*t+(1.9831474091215582))*0.13582864092193395  + cos(-93.0*t+(-1.9831474091188024))*0.13582864092159  + cos(-129.0*t+(-1.7066075001887269))*0.13469067950372648  + cos(129.0*t+(1.7066075001871746))*0.13469067950329985  + cos(60.0*t+(-1.7156350558460123))*0.13055523800779226  + cos(-60.0*t+(1.7156350558467184))*0.13055523800773916  + cos(82.0*t+(-1.2450669763635078))*0.1303020523756822  + cos(-82.0*t+(1.2450669763607656))*0.1303020523751821  + cos(-32.0*t+(0.8067523204408599))*0.1279076173512102  + cos(32.0*t+(-0.8067523204411796))*0.1279076173511966  + cos(-54.0*t+(-2.6388571278404647))*0.12552755745365102  + cos(54.0*t+(2.6388571278489716))*0.12552755745339916  + cos(-68.0*t+(-2.3052212019670923))*0.12527791482241438  + cos(68.0*t+(2.30522120197044))*0.12527791482236947  + cos(-35.0*t+(0.8929855231166186))*0.1221899343625182  + cos(35.0*t+(-0.8929855231162244))*0.12218993436231938  + cos(48.0*t+(0.22256070972632697))*0.12124018109113456  + cos(-48.0*t+(-0.2225607097173212))*0.12124018109013791  + cos(61.0*t+(2.730048748599944))*0.11864046532322606  + cos(-61.0*t+(-2.730048748597761))*0.11864046532312944  + cos(-78.0*t+(-1.384898794390902))*0.11534099878246555  + cos(78.0*t+(1.3848987943925464))*0.1153409987824359  + cos(80.0*t+(3.116817698897287))*0.11485493880028479  + cos(-80.0*t+(-3.1168176988943785))*0.11485493879988137  + cos(88.0*t+(0.9429952167264422))*0.11438864609893276  + cos(-88.0*t+(-0.9429952167226152))*0.11438864609771926  + cos(-90.0*t+(-2.6789272487719145))*0.1140853679261941  + cos(90.0*t+(2.6789272487653095))*0.11408536792437504  + cos(-22.0*t+(-1.3190357316128372))*0.11057615697033829  + cos(22.0*t+(1.3190357316109893))*0.1105761569701023  + cos(-106.0*t+(2.1136760899953737))*0.10439451832635387 );\n}\n\nbool onALine(vec2 p1, vec2 p2, vec2 point, float thickness) {\n//    if (point.x < p1.x || point.x > p2.x)\n//      return false;\n    \n    if (p1.x > p2.x) {\n        if (point.x > p1.x || point.x < p2.x)\n          return false;\n    } else\n    {\n        if (point.x > p2.x || point.x < p1.x)\n          return false;\n    }\n    \n    if (p1.y > p2.y) {\n        if (point.y > p1.y || point.y < p2.y)\n          return false;\n    } else\n    {\n        if (point.y > p2.y || point.y < p1.y)\n          return false;\n    }\n    \n    //    if (point.x > p2.x || point.x < p1.x)\n    //      return false;\n    //if (point.x < p1.x || point.y < p1.y)\n    //  return false;\n     \n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    \n    float d = abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n    \n    if (d < thickness)\n        return true;\n\n    return false;\n}\n\n\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 point) {\n    float a = p1.y-p2.y;\n    float b = p2.x-p1.x;\n    return abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    vec2 uv = .6*(fragCoord-.5*iResolution.xy)/iResolution.y+vec2(.05,.05);\n\n    vec2 pos = cookie(iTime/5.0);\n    vec2 pos2 = pos / 600.0;\n    pos2.y = -pos2.y;\n\n    float d = pow( pow(pos2.x - uv.x, 2.0) + pow(pos2.y - uv.y, 2.0) , 0.5); \n\n    if (d < 0.002) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        return;\n    }\n    \n    vec4 frame = texture(iChannel0, fragCoord/iResolution.xy);\n    if (onALine(vec2(0.0, 0.0), pos2, uv, 0.002)) {\n        if (frame.r == 0.0 && frame.g == 0.0 && frame.b == 0.0) {\n            fragColor = vec4(d * 3.0, 1.0- (d * 5.0), d * 10.0, 1.0);\n            return;\n        }\n    }\n\n    \n    fragColor = frame;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3cR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 189]], "test": "untested"}
{"id": "tldcRH", "name": "in the night", "author": "Ric3cir121", "description": "Simple ray tracer with samples", "tags": ["raytracing", "raytracing", "noise", "distancefunction", "cube", "light", "sphere", "distance", "night", "estimator", "reflect", "stone"], "likes": 0, "viewed": 280, "published": 3, "date": "1608546163", "time_retrieved": "2024-07-30T20:29:02.381395", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define get(c) texture(iChannel1,vec2(c*2,0.)/iResolution.xy)\n\n#define PI 3.1415926535\n\n// ----------------------------------------------------\n// Random functions\n\n#define hash12(c) (fract(sin(vec2(c,sin(c*1000.)*1000.)*1000.)*1000.))\n#define rand31(c) (fract(sin(c.x*c.y*c.z/10000.)*1000.))\n#define smoothstep(a,b,c) mix(a,b,((sin(clamp(c,0.,1.)*2.-1.)+1.)/2.))\nfloat hash31(vec3 c){\n    c = mod(c,1000.);\n    vec3 r = floor(c);\n    \n    float _00 = smoothstep(rand31(vec3(r.x   ,r.y   ,r.z   )),rand31(vec3(r.x   ,r.y   ,r.z+1.)),fract(c.z));\n    float _01 = smoothstep(rand31(vec3(r.x   ,r.y+1.,r.z   )),rand31(vec3(r.x   ,r.y+1.,r.z+1.)),fract(c.z));\n    float _10 = smoothstep(rand31(vec3(r.x+1.,r.y   ,r.z   )),rand31(vec3(r.x+1.,r.y   ,r.z+1.)),fract(c.z));\n    float _11 = smoothstep(rand31(vec3(r.x+1.,r.y+1.,r.z   )),rand31(vec3(r.x+1.,r.y+1.,r.z+1.)),fract(c.z));\n\n\treturn smoothstep(smoothstep(_00,_01,fract(c.y)),smoothstep(_10,_11,fract(c.y)),fract(c.x));\n}\n\n// ----------------------------------------------------\n// Distance estimator\n\n#define fmax(a,b) (a.x>b.x?a:b)\n#define fmin(a,b) (a.x<b.x?a:b)\n#define cube(p1,p2,size,color) vec4(max(max(abs(p1.x-p2.x),abs(p1.y-p2.y)),abs(p1.z-p2.z))-size/2.,color)\n#define sphere(p1,p2,size,color) vec4(length(p1-p2)-size/2.,color)\nfloat capsule(vec3 p1,vec3 p2,vec3 p3,float size){vec3 fr = p3 - p2;return length((p1-p2)-fr*clamp(dot((p1-p2),fr)/dot(fr,fr),0.0,1.0))-size/2.;}\nvec4 de(vec3 c){\n    vec4 ret0 = fmin(fmin(fmin(vec4(((length(fract(c.xz*5.)-.5)/2.\n    +length((texture(iChannel3,c.xz/2.,0.)\n    *texture(iChannel3,c.xz/2.*1.4872,0.)).xyz))/15.+c.y+1.+(hash31(c*10000.)/50000.))/1.5,vec3(0.2))\n    ,fmin(vec4(c.y+1.024+texture(iChannel2,c.xz,0.).x/100.,vec3(.7)),\n    vec4(c.y+1.02+texture(iChannel2,c.xz/10.,0.).x/30.,vec3(.3,.7,.3))\n    )),\n    sphere(c,vec3(-1,2,0),1.,vec3(6,6,2))\n    ),\n    vec4(capsule(c,vec3(-1,-1,0),vec3(-1,2,0),0.2)+(hash31(c*10000.)/5000.),vec3(.8))\n    );\n    //+(hash31(c*100.)/500.);\n\treturn ret0;\n}\n\n// ----------------------------------------------------\n// March function\n\nfloat getp(vec4 m,vec3 p){\n\treturn length(m.xyz-p)/500.+0.0001; // raymarching epsilon increase while marching\n}\n\nvec4 DoMarch(vec3 Position,vec3 Camera){\n\tfloat Iteration = 0.;\n    vec3 Marcher = vec3(0);\n    float Distance = 10.;\n    \n    while(length(Marcher) <= 100. && Iteration <= 500. && Distance >= getp(Marcher.xyzz,vec3(0))){\n    \tDistance = de(Position+Marcher).x+getp(Marcher.xyzz,vec3(0));\n        Marcher += Distance*Camera;\n        Iteration++;\n    }\n    return vec4(Position+Marcher,Iteration);\n}\n\nvec3 getnormal(vec3 n){\n    vec2 e = vec2(1.0,-1.0)*(n.y<0.002-1.?.00001:.00001);\n    return normalize(e.xyy*de(n+e.xyy).x+e.yyx*de(n+e.yyx).x+e.yxy*de(n+e.yxy).x+e.xxx*de(n+e.xxx).x);\n}\n\nvec4 getcolor(vec4 m,vec3 p){\n    return vec4((length(m.xyz-p)>100.||m.w>=500.?vec3(.2):de(m.xyz).yzw),!(length(de(m.xyz).yzw)>=pow(3.,0.5)));\n}\n\n// ----------------------------------------------------\n// Main\n\n#define rotate(c,p) (vec3(vec2(cos(p)*c.x+sin(p)*c.z,sin(p)*c.x-cos(p)*c.z),c.y).xzy)\n\nvoid mn(out vec4 o,vec2 u){\n    vec4 Color = vec4(1);\n    vec3 Normal;\n    float Precision;\n    vec2 Looking = get(2).xy+vec2(1.3,0);\n    vec3 Camera = rotate(rotate(normalize(vec3((u-iResolution.xy/2.)/iResolution.yy,1.)).yxz,-Looking.y).yxz,Looking.x);\n\tvec3 Position = -rotate(rotate(normalize(vec3(0,0,1)).yxz,-Looking.y).yxz,Looking.x)*5.;\n    if(Position.y < 0.)Position.y = 0.;\n    vec4 March = DoMarch(Position,Camera);\n    Color *= getcolor(March,Position);\n\n    if(get(2).z == 0.)\n    for(int i = 0; i < 100;i++){\n        if(length(March.xyz-Position)>100.||March.w >= 500. || Color.w != 1.)break;\n        Precision = getp(March,Position)*2.;\n        Position = March.xyz;\n        Normal = getnormal(Position-Camera*Precision);\n    \tCamera = reflect(Camera,Normal);\n    \tMarch = DoMarch(Position+Normal*Precision,Camera);\n        Color *= getcolor(March,Position);\n    }\n    o = vec4(Color.xyz,1.);\n\n}\n\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 uv = u/iResolution.xy;\n    o = vec4(0.);\n    vec4 O = vec4(0.);\n\tint a = 1;\n    for(int i = 0; i<a; i++){\n        O = vec4(0);\n        mn(O,u+hash12(0.3*u.x*u.y*PI*(float(i)+mod(iTime,10.))));\n        o += O;\n    }\n    o /= float(a);\n    \n    if(get(2).z == 0. && get(4).z == 0.)\n    o = texture(iChannel0,uv)*(1.-(1./get(5)))+o/get(5);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define storable(c,u) (round(u.x/2.) == float(c) && u.y < 1.)\n#define get(c) texture(iChannel0,vec2(c*2,0.)/iResolution.xy)\n#define store(c,d,u,o) if(storable(c,u))o=d\n\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 r = iResolution.xy;\n    vec2 uv = u/r;\n    o = texture(iChannel0,uv);\n    \n    vec4 Mouse = get(2);\n    if(iMouse.z > 0.){\n        if(Mouse.z == 0.){\n            Mouse.zw = iMouse.xy/100.;\n        }else{\n            Mouse.xy -= iMouse.xy/100.-Mouse.zw;\n            Mouse.zw = iMouse.xy/100.;\n        }\n    } else {\n        Mouse.z = 0.;\n    }\n    store(2,Mouse,u,o);\n\n    if(get(2).z == 0. && get(4).z == 0.){\n        store(5,get(5)+1.,u,o);\n    }else{\n        store(5,vec4(1.),u,o);\n    }\n\n    store(4,vec4(r,r==get(4).xy?0:1,0),u,o);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tldcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 138]], "test": "untested"}
{"id": "tsGfD1", "name": "Spheres and a floating box", "author": "Ric3cir121", "description": "Simple ray tracer with samples", "tags": ["raytracing", "raytracing", "noise", "distancefunction", "cube", "light", "sphere", "distance", "estimator", "reflect"], "likes": 5, "viewed": 429, "published": 3, "date": "1608546147", "time_retrieved": "2024-07-30T20:29:03.427597", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define get(c) texture(iChannel1,vec2(c*2,0.)/iResolution.xy)\n\n#define PI 3.1415926535\n\n// ----------------------------------------------------\n// Random functions\n\n#define hash12(c) (fract(sin(vec2(c,sin(c*1000.)*1000.)*1000.)*1000.))\n#define rand31(c) (fract(sin((c).x*(c).y*(c).z/1000.)*10000.))\n#define smoothstep(a,b,c) mix(a,b,((sin(clamp(c,0.,1.)*2.-1.)+1.)/2.))\nfloat hash31(vec3 c){\n    c = mod(c,10000.);\n    vec3 r = floor(c);\n    \n    float _00 = smoothstep(rand31(vec3(r.x   ,r.y   ,r.z   )/10.),rand31(vec3(r.x   ,r.y   ,r.z+1.)/10.),fract(c.z));\n    float _01 = smoothstep(rand31(vec3(r.x   ,r.y+1.,r.z   )/10.),rand31(vec3(r.x   ,r.y+1.,r.z+1.)/10.),fract(c.z));\n    float _10 = smoothstep(rand31(vec3(r.x+1.,r.y   ,r.z   )/10.),rand31(vec3(r.x+1.,r.y   ,r.z+1.)/10.),fract(c.z));\n    float _11 = smoothstep(rand31(vec3(r.x+1.,r.y+1.,r.z   )/10.),rand31(vec3(r.x+1.,r.y+1.,r.z+1.)/10.),fract(c.z));\n\n\treturn smoothstep(smoothstep(_00,_01,fract(c.y)),smoothstep(_10,_11,fract(c.y)),fract(c.x));\n}\n\n// ----------------------------------------------------\n// Distance estimator\n\n#define fmax(a,b) (a.x>b.x?a:b)\n#define fmin(a,b) (a.x<b.x?a:b)\n#define cube(p1,p2,size,color) vec4(max(max(abs(p1.x-p2.x),abs(p1.y-p2.y)),abs(p1.z-p2.z))-size/2.,color)\n#define sphere(p1,p2,size,color) vec4(length(p1-p2)-size/2.,color)\nvec4 de(vec3 c){\n    vec4 ret0 = fmax( -cube(c,vec3(0,1,0)     ,1. ,-vec3(.95,.85,.2)),\n           fmin(sphere(c,vec3(0,0,-2)    ,2. , vec3(.5,.9,.5)),\n           fmax( -cube(c,vec3(0.3,0.2,0) ,1.8,-vec3(.95,.85,.2)),\n           fmax( -cube(c,vec3(0,0.2,0)   ,1.8,-vec3(.95,.85,.2)),\n           fmin(sphere(c,vec3(2,1,1)     ,1. , vec3(5)),\n           fmin(  vec4(c.y+1.                , vec3(.95)),\n                  cube(c,vec3(0,0.2,0)   ,2. , vec3(.95,.85,.2))\n               \n           ))))))+(hash31(c*10000.)/8000.);\n\treturn fmin(sphere(c,vec3(0,-.4,-0.4),.6 , vec3(.9,.5,.5)),\n           fmin(sphere(c,vec3(0,-.2,0.4) ,1. , vec3(.5,.5,.9)),\n                ret0\n           ));\n}\n\n// ----------------------------------------------------\n// March function\n\nfloat getp(vec4 m,vec3 p){\n\treturn length(m.xyz-p)/500.+0.0001; // raymarching epsilon increase while marching\n}\n\nvec4 DoMarch(vec3 Position,vec3 Camera){\n\tfloat Iteration = 0.;\n    vec3 Marcher = vec3(0);\n    float Distance = 10.;\n    \n    while(length(Marcher) <= 100. && Iteration <= 500. && Distance >= getp(Marcher.xyzz,vec3(0))){\n    \tDistance = de(Position+Marcher).x+getp(Marcher.xyzz,vec3(0));\n        Marcher += Distance*Camera;\n        Iteration++;\n    }\n    return vec4(Position+Marcher,Iteration);\n}\n\nvec3 getnormal(vec3 n){\n    vec2 e = vec2(1.0,-1.0)*(n.y<0.002-1.?.00001:.00001);\n    return normalize(e.xyy*de(n+e.xyy).x+e.yyx*de(n+e.yyx).x+e.yxy*de(n+e.yxy).x+e.xxx*de(n+e.xxx).x);\n}\n\nvec4 getcolor(vec4 m,vec3 p){\n    return vec4((length(m.xyz-p)>100.||m.w>=500.?vec3(.7,.7,1.):de(m.xyz).yzw),!(length(de(m.xyz).yzw)>=pow(3.,0.5)));\n}\n\n// ----------------------------------------------------\n// Main\n\n#define rotate(c,p) (vec3(vec2(cos(p)*c.x+sin(p)*c.z,sin(p)*c.x-cos(p)*c.z),c.y).xzy)\n\nvoid mn(out vec4 o,vec2 u){\n    vec4 Color = vec4(1);\n    vec3 Normal;\n    float Precision;\n    vec2 Looking = get(2).xy+vec2(1.3,0);\n    vec3 Camera = rotate(rotate(normalize(vec3((u-iResolution.xy/2.)/iResolution.yy,1.)).yxz,-Looking.y).yxz,Looking.x);\n\tvec3 Position = -rotate(rotate(normalize(vec3(0,0,1)).yxz,-Looking.y).yxz,Looking.x)*5.;\n    if(Position.y < 0.)Position.y = 0.;\n    vec4 March = DoMarch(Position,Camera);\n    Color *= getcolor(March,Position);\n\n    if(get(2).z == 0.)\n    for(int i = 0; i < 100;i++){\n        if(length(March.xyz-Position)>100.||March.w >= 500. || Color.w != 1.)break;\n        Precision = getp(March,Position)*2.;\n        Position = March.xyz;\n        Normal = getnormal(Position-Camera*Precision);\n    \tCamera = reflect(Camera,Normal);\n    \tMarch = DoMarch(Position+Normal*Precision,Camera);\n        Color *= getcolor(March,Position);\n    }\n    o = vec4(Color.xyz,1.);\n\n}\n\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 uv = u/iResolution.xy;\n    o = vec4(0.);\n    vec4 O = vec4(0.);\n\tint a = 1;\n    for(int i = 0; i<a; i++){\n        O = vec4(0);\n        mn(O,u+hash12(0.3*u.x*u.y*PI*(float(i)+mod(iTime,10.))));\n        o += O;\n    }\n    o /= float(a);\n    \n    if(get(2).z == 0. && get(4).z == 0.)\n    o = texture(iChannel0,uv)*(1.-(1./get(5)))+o/get(5);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define storable(c,u) (round(u.x/2.) == float(c) && u.y < 1.)\n#define get(c) texture(iChannel0,vec2(c*2,0.)/iResolution.xy)\n#define store(c,d,u,o) if(storable(c,u))o=d\n\nvoid mainImage(out vec4 o,vec2 u){\n    vec2 r = iResolution.xy;\n    vec2 uv = u/r;\n    o = texture(iChannel0,uv);\n    \n    vec4 Mouse = get(2);\n    if(iMouse.z > 0.){\n        if(Mouse.z == 0.){\n            Mouse.zw = iMouse.xy/100.;\n        }else{\n            Mouse.xy -= iMouse.xy/100.-Mouse.zw;\n            Mouse.zw = iMouse.xy/100.;\n        }\n    } else {\n        Mouse.z = 0.;\n    }\n    store(2,Mouse,u,o);\n\n    if(get(2).z == 0. && get(4).z == 0.){\n        store(5,get(5)+1.,u,o);\n    }else{\n        store(5,vec4(1.),u,o);\n    }\n\n    store(4,vec4(r,r==get(4).xy?0:1,0),u,o);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 138]], "test": "untested"}
{"id": "wl3yR4", "name": "rosettes 2", "author": "FabriceNeyret2", "description": "WIP", "tags": ["tiling", "hexa", "loopless", "rosette"], "likes": 7, "viewed": 331, "published": 3, "date": "1608542992", "time_retrieved": "2024-07-30T20:29:04.393016", "image_code": "#define CS(a) cos(a+vec2(0,11))\n#define S(D)  smoothstep(9./R.y,0.,abs(length(D-U) - 1. ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, I,\n         U = 2.*( 2.*u - R ) / R.y;\n    O-=O;\n    \n    mat2 M = mat2( 1,0,.5,.87);\n    I = U *= M; U = mod(U,1.73)-.87; U *= inverse(M);          // tiling\n // if (max(max(abs(I.x),abs(I.y)),abs(I.x-I.y))>2.) return;   // trim\n    float a = abs( fract( atan(U.y,U.x)/6.28*6. +.0 ) - .5);   // 6-rot + mirror 12-sym\n    U = length(U) * CS( 6.28*a/6.);\n    \n    O += S( CS(-3.14/3.) );                                    // 1 arc → rosette\n    O.r += S();                                                // bounding circle\n    O.g += S( vec2(2,0) );                                     // bounding circle 2\n    O.b += S( 1.73*CS(3.14/6.) );                              // bounding arc\n  //U -= vec2(2,0); O += .3*sin(90.*atan(U.y,U.x));            // test to locate a point\n  \n    O += .5*texture(iChannel0,U/2.+.5);                        // BG texture\n  //O += .5*vec4(U,0,0);                                       // BG gradient\n    O += vec4(floor(I/1.73)/4.,0,0);                           // BG tile id\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3yR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 131, 131, 1174]], "test": "untested"}
{"id": "wt3yR4", "name": "rosettes", "author": "FabriceNeyret2", "description": ".", "tags": ["tiling", "hexa", "loopless", "rosette"], "likes": 5, "viewed": 284, "published": 3, "date": "1608540529", "time_retrieved": "2024-07-30T20:29:05.308568", "image_code": "#define CS(a) cos(a+vec2(0,11))\n#define S(D)  smoothstep(9./R.y,0.,abs(length(D-U) - 1. ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, I,\n         U = 3.*( 2.*u - R ) / R.y;\n    O-=O;\n    \n    mat2 M = mat2( 1,0,.5,.87);\n    I = U *= M; U = mod(U,2.)-1.; U *= inverse(M);             // tiling\n    float a = abs( fract( atan(U.y,U.x)/6.28*6. +.5 ) - .5);   // 6-rot + mirror 12-sym\n    U = length(U) * CS( 6.28*a/6.);\n    \n    O += S( CS(-3.14/3.) );                                    // 1 arc → rosette\n  //O += S();                                                  // bounding circle\n  //O += S( 1.73*CS(3.14/6.) );                                // bounding arc\n  \n    O += .5*texture(iChannel0,U/2.+.5);                        // BG texture\n    O += .5*vec4(U,0,0);                                       // BG gradient\n  //O += vec4(floor(I/2.)/4.,0,0);                             // BG tile id\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3yR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 131, 131, 930]], "test": "untested"}
{"id": "WssBz2", "name": "Synthwave Theme", "author": "53", "description": "synthwave theme\nmusic: https://soundcloud.com/synthwave80s/gran-turismo", "tags": ["raymarch", "synthwave"], "likes": 4, "viewed": 512, "published": 3, "date": "1608525298", "time_retrieved": "2024-07-30T20:29:06.444531", "image_code": "float rand(float p)\n{\n    return fract(sin(p)*43758.5453);\n}\nfloat rand21(vec2 p)\n{\n \treturn fract(sin(dot(p, vec2(1., 113.)))*43758.5453123);   \n}\nvec3 ACES(vec3 x)\n{\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    return clamp((x*(a*x + b))/(x*(c*x + d) + e), 0., 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    int x = int(uv.y*512.);\n    //float freq = texelFetch(iChannel1, ivec2(x, 0), 0).r - .5;\n    float wave = texelFetch(iChannel1, ivec2(x, 1), 0).r - .5;\n    //col = vec3(freq, 4.*freq*(1. - feq), 1. - freq)*freq;\n    //col = vec3(freq,  4.*freq*(1. - feq), 1. - freq)*step(uv.y, freq);\n    //col += vec3(smoothstep(.08, .02, abs(uv.y - wave)));\n    \n    float shake = fract(cos(uv.y*3.14*100. + iTime*20.)*43758.)*.02*wave;\n    uv.x += shake;\n    \n    float id = floor(uv.y*40.);\n    float glitch = rand(id + mod(iTime, 1000.));\n    if(glitch > .999)\n        uv.x += (rand(id) - .5)*.05;\n    \n    vec2 blurR = vec2(100.)/iResolution.xy;\n    vec3 col = vec3(0.);\n    float STEPS = 20.;\n    float phiOffs = rand(dot(fragCoord.xy, vec2(1.12, 2.25)) + iTime);\n    for(float i = 0.; i < STEPS; i++)\n    {\n        vec2 r = blurR*i/STEPS;\n        float phi = (i/STEPS + phiOffs)*2.*3.1415926;\n        vec2 q = uv + vec2(sin(phi), cos(phi))*r;\n        col += texture(iChannel0, q).rgb;\n    }\n    col.rgb = mix(textureLod(iChannel0, uv, 0.).rgb, col/STEPS, .2);\n    float exposure = .2*(1. + .2*sin(.5*iTime)*sin(1.8*iTime));\n    col = ACES(exposure*col);\n    \n    float abber = smoothstep(.25, .5, abs(uv.x - .5));\n    float offset = .004*abber;\n    vec3 colR = vec3(0.);\n    vec3 colB = vec3(0.);\n    colR = textureLod(iChannel0, uv + vec2(offset, 0.), 0.).rgb;\n    colB = textureLod(iChannel0, uv - vec2(offset, 0.), 0.).rgb;\n    colR = ACES(colR*exposure);\n    colB = ACES(colB*exposure);\n    col.r = mix(colR.r, colB.r, step(.5, uv.x));\n    col.b = mix(colR.b, colB.b, step(uv.x, .5));\n    \n    float t = sin(iTime + sin(iTime + sin(iTime)*.5));\n    float vline = step(mod((uv.y + t*.08)*200., 2.), 1.);\n    col *= mix(.8, 1., vline);\n    \n    float len = length(uv - .5);\n    float vignette = smoothstep(.8, .4, len);\n    col *= vignette;\n    \n    //col *= wave*.5 + 1.;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22511, "src": "https://soundcloud.com/synthwave80s/gran-turismo", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "const float MAX_DIST = 300.;\nconst float MIN_DIST = .01;\nconst int MAX_STEP = 200;\nconst float OFFS_NORM = .1;\n\nconst float blockScale = .3;\nconst float speed = 12.;\n\nconst vec3 col1 = vec3(.9, .1, .7);\nconst vec3 col2 = vec3(.1, .2, .8);\n\nfloat stripe(float y, float h, float dt)\n{\n \tconst float e = .005;\n    float t01 = fract((iTime + dt)*.1);\n    h += t01*.15;\n    float dh = (1. - t01)*.01;\n    float mask = smoothstep(h - dh*.5, h - dh*.5 - e, y);\n    mask += smoothstep(h + dh*.5, h + dh*.5 + e, y);\n    return mask;\n}\nfloat sunStripes(vec2 uv)\n{\n\tconst float start = -.02;\n    float delta = 2.;\n    float mask = stripe(uv.y, start, 0.);\n    mask *= stripe(uv.y, start, delta*1.);\n    mask *= stripe(uv.y, start, delta*2.);\n    mask *= stripe(uv.y, start, delta*3.);\n    mask *= stripe(uv.y, start, delta*4.);\n    return mask;\n}\nfloat rand21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(1., 113.)))*43758.5453123);\n}\nfloat rand212(vec2 p)\n{\n    if (p.x < 2. && p.x > -3.)\n        return 0.;\n        \n    return fract(sin(dot(p, vec2(1., 113.)))*43758.5453123);\n}\nfloat noise_value(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float xGEy = step(fp.y, fp.x);\n    float v_l = rand212(ip + vec2(0., 0.))*(1. - fp.x) +\n                rand212(ip + vec2(1., 0.))*(fp.x - fp.y) +\n                rand212(ip + vec2(1., 1.))*fp.y;\n    float v_u = rand212(ip + vec2(0., 0.))*(1. - fp.y) +\n                rand212(ip + vec2(0., 1.))*(fp.y - fp.x) +\n                rand212(ip + vec2(1., 1.))*fp.x;  \n    return mix(v_u, v_l, xGEy);\n    \n    vec2 w = fp;\n    return mix(mix(rand21(ip + vec2(0., 0.)),\n                   rand21(ip + vec2(1., 0.)), w.x),\n               mix(rand21(ip + vec2(0., 1.)),\n                   rand21(ip + vec2(1., 1.)), w.x), w.y);\n}\nfloat noise_value2(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    vec2 w = fp*fp*(3. - 2.*fp);\n    return mix(mix(rand21(ip + vec2(0., 0.)),\n                   rand21(ip + vec2(1., 0.)), w.x),\n               mix(rand21(ip + vec2(0., 1.)),\n                   rand21(ip + vec2(1., 1.)), w.x), w.y);\n}\nconst vec3 grad3[32] = vec3[32](vec3(1., 1., 0.)/sqrt(2.), vec3(-1., 1., 0.)/sqrt(2.), vec3(1., -1., 0.)/sqrt(2.), vec3(-1., -1., 0.)/sqrt(2.),\n                                vec3(1., 0., 1.)/sqrt(2.), vec3(-1., 0., 1.)/sqrt(2.), vec3(1., 0., -1.)/sqrt(2.), vec3(-1., 0., -1.)/sqrt(2.),\n                                vec3(0., 1., 1.)/sqrt(2.), vec3(0., -1., 1.)/sqrt(2.), vec3(0., 1., -1.)/sqrt(2.), vec3(0., -1., -1.)/sqrt(2.),\n                                vec3(1., 1., 0.)/sqrt(2.), vec3(-1., 1., 0.)/sqrt(2.), vec3(1., -1., 0.)/sqrt(2.), vec3(-1., -1., 0.)/sqrt(2.),\n                                vec3(1., 0., 1.)/sqrt(2.), vec3(-1., 0., 1.)/sqrt(2.), vec3(1., 0., -1.)/sqrt(2.), vec3(-1., 0., -1.)/sqrt(2.),\n                                vec3(0., 1., 1.)/sqrt(2.), vec3(0., -1., 1.)/sqrt(2.), vec3(0., 1., -1.)/sqrt(2.), vec3(0., -1., -1.)/sqrt(2.),\n                                vec3(1., -1., -1.)/sqrt(3.), vec3(-1., 1., 1.)/sqrt(3.), vec3(-1., -1., 1.)/sqrt(3.), vec3(1., 1., -1.)/sqrt(3.),\n                                vec3(1., 1., 1.)/sqrt(3.), vec3(-1., 1., -1.)/sqrt(3.), vec3(1., -1., 1.)/sqrt(3.), vec3(-1., -1., -1.)/sqrt(3.));\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\treturn grad3[int(mod(hash13(p3)*43758., 32.))];\n}\nfloat noise_simplex(vec3 p)\n{\n    const vec3 C = vec3(1./3., 1./6., 1./2.);\n\tvec3 ip = floor(p + dot(p, C.xxx));\n    vec3 d0 = p - (ip - dot(ip, C.yyy));\n    vec3 g = step(d0.zxy, d0.xyz);\n    vec3 l = 1. - g;\n    vec3 i1 = min(g.xyz, l.yzx);\n    vec3 i2 = max(g.xyz, l.yzx);\n    vec3 d1 = d0 - (i1 - C.yyy);\n    vec3 d2 = d0 - (i2 - C.xxx);\n    vec3 d3 = d0 - (1. - C.zzz);\n    vec4 m = max(vec4(0.), .5 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)));\n    m = m*m*m*m;\n    return 107.6535*(m.x*dot(hash33(ip), d0) +\n                     m.y*dot(hash33(ip + i1), d1) +\n                     m.z*dot(hash33(ip + i2), d2) +\n                     m.w*dot(hash33(ip + 1.), d3))*.5 + .5;\n}\nfloat fbm(vec2 p)\n{\n \tfloat sum = 0.;\n    float a = 1.;\n    float s = 1.;\n    float v = 0.;\n    for(int i = 0; i < 5; ++i)\n    {\n     \tsum += a;\n        v += noise_value2(p*s)*a;\n        a *= .5;\n        s *= 2.;\n    }\n    return v/sum;\n}\nfloat fbm(vec3 p)\n{\n \tfloat sum = 0.;\n    float a = 1.;\n    float s = 1.;\n    float v = 0.;\n    for(int i = 0; i < 4; ++i)\n    {\n     \tsum += a;\n        v += noise_simplex(p*s)*a;\n        a *= .5;\n        s *= 2.;\n    }\n    return v/sum;\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\nfloat calcHeight(vec3 p)\n{\n    p.z -= iTime*speed;\n    float h = noise_value(p.xz*blockScale - .5)*7.;\n    float mask = clamp((abs(p.x) - 5.)/10., 0., 1.);\n    return h*mask;\n}\nfloat sdPlane(vec3 p, float y)\n{\n    float h = calcHeight(p);\n    return p.y - y - h;\n}\nfloat sdSphere(vec3 p, vec3 c, float r)\n{\n    p -= c;\n    return length(p) - r;\n}\nfloat calcDist(vec3 p)\n{\n    float d = 0.;\n    d = sdPlane(p, 0.);\n    // d = min(d, sdSphere(p, vec3(0., 20., -200), 50.));\n    return d*.5;\n}\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    float t = 0.;\n    for(int i = 0; i < MAX_STEP; ++i)\n    {\n        d = calcDist(ro + rd*t);\n        t += d;\n        if(d < MIN_DIST || t > MAX_DIST)\n        {\n            break;\n        }\n    }\n    return t;\n}\nvec3 calcNormal(vec3 p)\n{\n    vec3 d0 = vec3(calcDist(p));\n    vec2 e = vec2(OFFS_NORM, 0.);\n    vec3 d = vec3(calcDist(p + e.xyy), calcDist(p + e.yxy), calcDist(p + e.yyx));\n    return normalize(d - d0);\n}\nvec3 calcRayDir(vec3 ro, vec3 c, vec2 uv, float z)\n{\n    vec3 f = normalize(c - ro);\n    vec3 r = normalize(cross(f, vec3(0., 1., 0.)));\n    vec3 u = cross(r, f);\n    vec3 i = f*z + r*uv.x + u*uv.y;\n    return normalize(i);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.xy;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0., 5., 15.);\n    vec3 c = vec3(0., 0., -1.);\n    // c.yz *= rot(m.y*3.14/2.);\n    // c.xz *= rot(m.x*6.28);\n    vec3 rd = calcRayDir(ro, ro + c, uv, 1.);\n    float d = rayMarch(ro, rd);\n    if(d < MAX_DIST)\n    {\n     \tvec3 p = ro + rd*d;\n        vec3 normal = calcNormal(p);\n        vec3 ldir1 = normalize(vec3(-.3, 1., 1.));\n        vec3 ldir2 = normalize(vec3(.3, 1., -1.));\n        float nl1 = max(0., dot(normal, ldir1));\n        float nl2 = max(0., dot(normal, ldir2));\n        \n        float distMod = smoothstep(0., 100., d);\n        vec3 light = mix(nl1*col1, nl2*col2, distMod)*10.;\n        \n        col += nl1*col1;\n        col += nl2*col2*5.*distMod;\n        \n        p.z -= iTime*speed;\n        float lineWidth = .05;\n        float widthMod = smoothstep(100., 50., d)*1.5;\n        vec2 fp = fract(p.xz*blockScale + .5*lineWidth + .5);\n        if(fp.x < lineWidth || fp.y < lineWidth*widthMod) col = light*(2. + distMod);\n    }\n    else\n    {\n     \tfloat sun0 = smoothstep(.25, .248, length(uv - vec2(.0, .1)));\n        float mask = sunStripes(uv);\n        float sun = sun0*mask;\n        vec3 sunCol = 10.*mix(vec3(.6, .1, .8)*.2, vec3(1., .6, .0), smoothstep(.0, .35, uv.y));\n        \n        col += sun*sunCol + (1. - sun)*vec3(.6, .3, .7)*1.;\n        \n        float fog = smoothstep(.25, .0, uv.y);\n        float n = fbm(vec3(uv*3. - vec2(0., iTime*.07), iTime*.07));\n        fog *= n*((1. - sun0) + sun0*.7);\n        \n        col += fog*vec3(.1, .5, .9)*mix(2., 10., fog);\n        \n\t\tvec2 iuv = floor(uv*16.);\n        vec2 fuv = fract(uv*16.);\n        vec2 starPos = rand21(iuv) + iuv;\n        float starDist = length(uv*16. - starPos);\n        float starRnd = rand21(iuv);\n        float starSize = mix(.008, .03, starRnd);\n        float star = smoothstep(starSize, starSize - .001, starDist)*step(mod(starRnd*100., 2.), .5);\n        star *= (1. - sun);\n        \n        col += star*(sin(starRnd*100. + iTime*3.14*.5)*.5 + .5)*20.;\n        \n        float starDust = smoothstep(.2, .2 + .5*n, uv.y);\n        starDust *= n;\n        float starDustMask = noise_value2(uv*2. + .5);\n        starDust *= starDustMask;\n        \n        col += starDust*mix(vec3(.6, .2, .6), vec3(.2, .4, .8), starDustMask)*2.5;\n    }\n    \n    //col = vec3(noise_value(uv*8.));\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "const ivec2 offs[8] = ivec2[8](ivec2(-1, -1), ivec2(-1, 1), ivec2(1, 1), ivec2(1, -1),\n                         ivec2(1, 0), ivec2(0, 1), ivec2(-1, 0), ivec2(0, -1));\nvec3 RGB2YCoCg(vec3 col)\n{\n    float Y = dot(col, vec3(.25, .5, .25));\n    float Co = dot(col, vec3(.5, 0., -.5)) + .5;\n    float Cg = dot(col, vec3(-.25, .5, -.25)) + .5;\n    return vec3(Y, Co, Cg);\n}\nvec3 YCoCg2RGB(vec3 col)\n{\n    col += vec3(0., -.5, -.5);\n    float r = dot(col, vec3(1., 1., -1.));\n    float g = dot(col, vec3(1., 0., 1.));\n    float b = dot(col, vec3(1., -1., -1.));\n    return vec3(r, g, b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 new = RGB2YCoCg(texture(iChannel0, uv).rgb);\n    vec3 last = RGB2YCoCg(texture(iChannel1, uv).rgb);\n    vec3 avg = new;\n    vec3 var = new*new;\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGB2YCoCg(texelFetch(iChannel0, ivec2(fragCoord) + offs[i], 0).rgb);\n        avg += fetch;\n        var += fetch*fetch;\n    }\n    avg /= 9.;\n    var /= 9.;\n    vec3 sigma = max(vec3(0.), var - avg*avg);\n    vec3 colMin = avg - .75*sigma;\n    vec3 colMax = avg + .75*sigma;\n    last = clamp(last, colMin, colMax);\n    fragColor = vec4(YCoCg2RGB(mix(new, last, .95)), 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 60], [61, 61, 83, 83, 147], [148, 148, 167, 167, 325], [326, 326, 383, 383, 2340]], "test": "untested"}
{"id": "ttdyz8", "name": "Solitary Planet", "author": "redmenace07", "description": "地球のようだ。ー三上寛\n\nView from geosynchronous orbit over the equator of an earth-like planet.", "tags": ["sphere"], "likes": 0, "viewed": 378, "published": 3, "date": "1608521935", "time_retrieved": "2024-07-30T20:29:07.201507", "image_code": "const mediump vec3 diffuse = vec3(0.0, 1.0, 1.0);\nconst mediump vec3 ambient = vec3(0.1);\nconst mediump float shininess = 2.0;\nconst mediump float specularFraction = 0.1;\nconst mediump float angularFrequency = 0.10471975511966;\nconst mediump float epsilon = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mediump float dimension = min(iResolution.x, iResolution.y);\n    mediump float maxDimension = max(iResolution.x, iResolution.y);\n    mediump float radius = 0.3 * dimension;\n    mediump float dist = 6.0 * radius;\n\n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    float apparentR = length(uv);\n\n    mediump float xi = atan(apparentR / dist);\n    float perspective = 1.0 + radius / dist * (1.0 - sin(xi));\n    float actualR = apparentR / perspective;\n\n    highp float z = sqrt(radius * radius - actualR * actualR) * step(actualR, radius);\n    vec3 position = vec3(uv / perspective, z);\n    vec3 normal = normalize(position);\n\n    float angle = angularFrequency * iTime;\n    float cosTime = cos(angle);\n    float sinTime = sin(angle);\n    vec3 light = vec3(\n        sinTime,\n        -0.398749068925246 * cosTime,\n        -0.917060074385124 * cosTime\n        );\n\n    vec3 view = normalize(position - vec3(0.0, 0.0, dist + radius));\n    vec3 reflected = reflect(light, normal);\n    float specular = pow(clamp(dot(-reflected, view), 0.0, 1.0), shininess);\n\n    vec3 diffusePlusSpecular = (1.0 + specularFraction * specular) * clamp(dot(-light, normal), 0.0, 1.0) * diffuse;\n\n    vec3 color = clamp(diffusePlusSpecular + ambient, 0.0, 1.0);\n\n    float theta = acos(position.y / radius);\n    float phi = atan(position.x / z);\n    vec2 textureCoord = vec2(phi, theta) / 3.141592653589793 + vec2(0.5, 0.0);\n    vec2 spaceCoord = fragCoord / dimension - vec2(angle, 0.0);\n\n    vec4 planetContrib = step(actualR, radius) * vec4(color, 1.0) * texture(iChannel0, textureCoord);\n\n    vec2 starCenter = iResolution.xy * 0.5 + vec2(angle, 0.0) * 2.1 * dimension;\n\n    vec4 bgContrib = 0.2 * step(radius, actualR) * texture(iChannel1, (fragCoord - starCenter)/maxDimension);\n    highp vec4 opaqueContrib = planetContrib + bgContrib;\n\n    highp vec3 atmosphereColor = clamp(dot(-light, normal), 0.0, 1.0) * vec3(1.0);\n    mediump float maxThickness = 2.0 * sqrt(1.0 + 2.0/epsilon);\n\n    highp float atmosphereAlpha = clamp(1.0/maxThickness * min(maxThickness, radius / z), 0.0, 1.0) * (1.0 - smoothstep(radius, radius * (1.0 + epsilon), actualR));\n\n    highp vec4 unclamped = vec4(mix(opaqueContrib.rgb, atmosphereColor, atmosphereAlpha), 1.0);\n    fragColor = clamp(unclamped, vec4(0.0), vec4(1.0));\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttdyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 321, 321, 2611]], "test": "untested"}
{"id": "wlcczH", "name": "CirclePear (MossEgg+Vesica)", "author": "ollj", "description": "cci(radius,radius,distance.x) = circleCircleIntersection\ncci generates both, (bi)Vesica (up half) and MossEgg(low half) \nyou either add radius3 to both others or subtract it from both other radii.\nand if you do one on each half, you get a Pear/Joint/Smile", "tags": ["tangent", "joint", "vesica", "hinge", "pear", "appolonean", "appolonean", "mossegg", "circlesegment"], "likes": 10, "viewed": 471, "published": 3, "date": "1608518451", "time_retrieved": "2024-07-30T20:29:08.213800", "image_code": "//#define FoldColors\n\n//its an OrVesica, not an AndVesica case (rounded venn diagram)\n//as in https://www.shadertoy.com/results?query=Vesica\n//the middle radius is substracted in the upper half, forming a bay, and added in the lower half, making a penesula. (assuming the shape center is dry land)\n//this makes the OrVesica a complementary shape to the mossEgg\n//while only the AndVesica is identical to a mirrored mossEgg.\n\n//very early version, only calculates 4 correct circle positions\n//does not calculate signed distance field (of below extnesions)\n//this is just the protottype proof of concept\nvec4 circles4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){u=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec4 c=vec4(length(u)-r.x)//red circle\n ;c.y=length(u-vec2(d,0))-r.y//green circle\n ;vec2 ci=vec2(0)//2 circleCircleIntersections -> blue and yellow circle centers\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;vec2 cBlue=vec2(ci.x, pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y, pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;c.z=length(u-cBlue)-(r.z)//blue     circle\n ;c.w=length(u-cYell)-(r.w)//yellow.w circle\n ;c=abs(c)-.005 //4 rings of thichness\n ;c=ss(0.003,c) //4 smoothstep\n ;return c;}\n \n//first rather messy segmentation, still shows circles (dithered)\n//is messy, overly explicit, and unoptimized, to debug or extend\nvec4 segments4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, -> blue and yellow circle centers\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;vec2 cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//get distances to 4 points, minus 4 radii.\n ;vec4 c=vec4(0)\n ;c.x=length(v-cRed  )-r.x//red      circle/distance\n ;c.y=length(v-cGreen)-r.y//green    circle/distance\n ;c.z=length(v-cBlue )-r.z//blue     circle/distance\n ;c.w=length(v-cYell )-r.w//yellow.w circle/distance\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;if(v.y>0.\n ){e= vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{     \n  ;e=-vec2(sd2l(v,cGreen,cYell),sd2l(v,cYell,cRed  ))\n ;}\n ;e=sign(e)\n ;//dither 2 views\n ;u=mod(u,2.)\n ;if(u.x==u.y\n ){c=abs(c)-.01 //4 rings of thichness\n  ;c=ss(0.003,c) //4 smoothstep\n ;}else{\n  ;//fold sections to 2 colors that are a piecewise DistanceField\n  ;if(e.x<0.&&e.y<0.//inner blue part\n  ){c.x=0.;c.y=0.;c.z=max(-c.z,c.w);c.w=0.\n  ;}else{//outer red part (can overlap in upper area, so its a miin)\n   ;c.z=0.;c.w=0.;c.x=min(c.x,c.y);c.y=0.\n  ;}\n  ;//c=fract(c*8.)\n  ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              \n  ;//fold 2 segment to monochrome\n  //#define FoldColors\n  #ifdef FoldColors\n  ;c.x+=c.z\n  ;c.z=0.\n  #endif\n ;}\n ;return c;}\n\n//pythCiiBlue||pythCiiYell are 1 division + 1 sqrt()\n//they are the slow subroutines for the sake of making this shape very parametric/dynamic\n//they calculate circleCircleIntersection.xy = positions if yellow and blue circleCenter\n//so that the circles are touching without intersecting.\n//\n//I can not get circleCircleIntersection.xy without sqrt() of pythagorean theorem, right?\nvec2 pythCiiBlue(vec4 r,float d){//return center of blue circle\n ;float i=cci(r.x+r.z,r.y+r.z,d)//circleCircleIntersection.x\n ;return vec2(i,pythagoras(vec2(r.x+r.z,i)));}//circleCircleIntersection.y via pythagoras.\nvec2 pythCiiYell(vec4 r,float d){//return center of yellow circle\n ;float j=cci(r.x-r.w,r.y-r.w,d)//circleCircleIntersection.x\n ;return vec2(j,pythagoras(vec2(r.x-r.w,j)));}//circleCircleIntersection.y via pythagoras.\n\n//vastly improved performance, but more redundant code may compile slower.\n//complexity is either 3 sqrt+1 divisions, OR 4 sqrt+2 divisions.\nvec4 pear(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)//green circle center\n ;vec4 c=vec4(0)//returned value\n ;if(v.y>0.){//upper half (Blue is condition for cYell to be skippable)\n  ;vec2 cBlue=pythCiiBlue(r,d)\n  ;if(sd2l(v,cRed,cBlue)>=0.||sd2l(v,cBlue,cGreen)>=0.//inner blue part\n  ){//outer upper part (can overlap in upper area, so its a min()), but does not need to calculate cYell\n   ;c.x=min(length(v-cRed)-r.x,length(v-cGreen)-r.y)  //3 sqrt toral\n  ;}else{ //inner upper part also needs to calculate cYell\n   ;c.z=max(-length(v-cBlue )+r.z,length(v-pythCiiYell(r,d))-r.w)  //4 sqrt total\n  ;}\n ;}else{//lower half (cYell is condition, for cBlue to be skippable)\n  ;vec2 cYell=pythCiiYell(r,d)\n  ;if(sd2l(v,cYell,cGreen)>=0.||sd2l(v,cRed,cYell)>=0.//inner blue part\n  ){//lower outer parts (can overlap in upper area, so its a miin), but no need to calculate cBlue\n   ;c.x=min(length(v-cRed)-r.x,length(v-cGreen)-r.y)  //3 sqrt toral\n  ;}else{ //lower inner part also needs to calculate blue\n   ;c.z=max(-length(v-pythCiiBlue(r,d))+r.z,length(v-cYell)-r.w)  //4 sqrt toral\n ;}}\n ;return vec4(c.x+c.z,c.y,0,c.w)//final color fold.\n ;}\n\n/*\n//clearly pear() can be optimized and can skip 1 sqrt(), if not 3?\n//pear36() can have 3 sqrt, or will do 6 sqrt()\n//todo: by first computing, if [u] is in the blue or red area, i may get this down to 2 or 4 sqrt()\n//cleaned up working version, returns distance field\n//returns vec4 (for simplicity and optional debugging)\n//only c.xz are relevant (.x=red distance .z= blue segment branch)\nvec4 pear36(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;//vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;vec2 cBlue=vec2(0.)\n ;vec2 cYell=vec2(0.)\n ;if(v.y>0.//upper half = vesica\n ){cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n  ;e=vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{//lower half == mossEgg\n  ;cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n  ;e=vec2(sd2l(v,cYell,cGreen),sd2l(v,cRed,cYell  ))\n ;}\n ;e=sign(e)\n ;//fold sections to 2 colors that are a piecewise DistanceField\n ;vec4 c=vec4(0)//returned value\n ;if(e.x<0.&&e.y<0.// uv is within the inner blue part (most complex segment)\n ){//in the end, cBlue + cYell must both be computed for this case\n //, because the blue circle can be below u.y<0\n  ;cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n  ;cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n  ;c.z=max(-length(v-cBlue )+r.z,length(v-cYell )-r.w)\n ;}else{//outer red part (can overlap in upper area, so its a miin)\n  c.x=min(length(v-cRed  )-r.x,length(v-cGreen)-r.y)\n ;}\n ;//fold 2 segment to monochrome\n //#define FoldColors\n //#ifdef FoldColors\n  ;c.x+=c.z;c.z=0.\n //#endif\n ;return c;}\n //complexity is 1 division within cci() + 2 dot() within sd2l()\n // +3 or 6 sqrt (more swrt wwithin the blue area)\n //may be worth it to first compute the blue area, to get this down to 3 or 4 sqrt?)\n //-can be writtnen to be always 4 sqrt (above), by precomputing cBlue+cYell outside of their cases, without precoputing if it is in the blue area.\n/**/\n\nvoid mainImage( out vec4 O, in vec2 u\n){vec2 m=iMouse.xy\n ;//u.x+=iR.y*.5\n ;vec2 n=abs(iMouse.zw)\n ;m=abs(fra(iR,m))\n ;n=abs(fra(iR,n))\n  ;\n ;float t=iTime*2.+15.\n ;\n ;//5 parameters (4 set by iMouse, or overwritten here\n ;float dist=1.//distance.x between red and green circle\n ;//m.x=  //left  end    circle radius (red)\n ;//m.y=  //right end    circle radius (green)\n ;//n.x=.3  //top  inner   circle radius (blue)\n ;//n.y=1.5 //bottom outer circle radius (yellow) (should be > m.x+m.y)\n ;if(iMouse.z>0.)n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n ;//if(iMouse.z>0.)n.y=(dist-m.x-m.y)*mix(1.,5.,cos(iTime*.5)*.5+.5)\n ;\n ;if(iMouse.z<=0.//animate whime louse is up  must b1>=, or initiation if bad\n ){m.x=.7*(sin(t               )*.5+.5) //left radius\n  ;m.y=.7*(sin(t*sqrt(5.)*.5+.5)*.5+.5) //right radius\n  ;m.xy+=.02//minimum circle to emphasize roundness\n  ;n.x=1.*(cos(t*sqrt(2.)*.5+.5)*.5+.5) //upper inner radius\n  ;n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n  ;dist=.5*mix(.3,2.\n           ,1.*(sin(t*sqrt(3.)*.5+.5)*.5+.5))+(m.x+m.y)*.5\n ;} \n ;\n ;//worksafing inputs\n ;float betterSafeThanNull=1./iR.x\n ;//blue circle is at least large enough to touch red AND green\n ;n.x=max(n.x,(dist-m.x-m.y)*.5+betterSafeThanNull)\n ;//yellow circle is at SMALL enough to contain green and blue\n ;n.y=max(n.y,(dist+m.x+m.y)*.5+betterSafeThanNull)\n ;\n ;vec4 c=vec4(0)//return value\n ;float a=1.; ;//chose one of 3 [stages of development];\n ;if(iMouse.z>0.)a=floor(mod(t+1.,7.))         //on mouse down\n ;else a=float(fra(iR,u).x>sin(iTime*.2)*2.)*6.+1.//on mouse up\n ;//3 [stages of development];\n ;     if(a<1.)c=circles4(u,m,n,dist) //draw only circles\n ;else if(a<5.)c=segments4(u,m,n,dist)//mix between above and below\n ;else        {c=pear(u,m,n,dist)\n              ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              ;}\n ;//todo, more userfriendly MossEgg-like wrapper (nrormalize [dist] to 1)\n ;//todo, CSG sign swapping fun (as in my vesica shader)\n ;//todo, put in dragAndDrop Ui Canvas of \n ;//...   https://www.shadertoy.com/view/WdGfRw\n ;//todo, parametrization\n ;\n ;c.xy+=c.w//yellow\n ;O=vec4(c.xyz,1);}", "image_inputs": [], "common_code": "#define iR iResolution\n#define u2(a) (a)*2.-1.\n\n#define ss(a,b) smoothstep (a,-a,b)\n\n#define ViewZoom 2.\n#define fra(r,u) ((u-.5*r.xy)*ViewZoom/r.y)\n#define dd(a) dot(a,a)\n\nvec2 fra2(vec3 r,vec2 u\n){u=u/r.xy \n ;u.x*=r.x/r.y\n ;return u2(u);}\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles.centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\nfloat cci(float a,float b,float c){return cci(vec3(a,b,c));}\n//does not check for non-intersecticn cases! \n//intersection.y can be calculated by pythagoras()   \n\n//pythagoran theorem: a.x=hypothenuse (commonly used after cci() )\nfloat pythagoras(vec2 a){a*=a;return sqrt(a.x-a.y);}\n//float su(vec2 a){return a.x-a.y;}\n//float su(vec3 b){return a.x-a.y-a.z;}\n//float su(vec4 b){return a.x-a.y-a.z-a.y;}\n//#define pythagoras(a) sqrt(-su(-(a*a)))\n\n\n//sign() but returns 1 instead of 0.\nivec2 sign2(vec2 a){ return ivec2(a.x<0.,a.y<0.)*2-1;}\n\n //return SIGNED non-normalized distance\n // of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u, vec4 m\n){//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n ;//c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n ;vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x)//calculate rotated differential\n ;//no need to divide by dot(a,a), for the same reason as below\n ;//no need to normalize() f, because we only care for the sign, using the SIGN of a LINE as a BOUNDARY of a composite-shape\n ;u-=m.xy;\n ;return dot(u,f)//early out is work safe\n \n //below alternative has some error cases on the mossEgg()\n \n //below may not be worth the overhead\n ;if (u.x==0.||f.x==0.){return u.y*f.y ;}//.x==0\n ;if (u.y==0.||f.y==0.){return u.x*f.x ;}//.y==0\n ;ivec4 s=ivec4(sign2(u),sign2(f))\n ;if  (s.x!=s.z || s.y!=s.w  //if some specific signs are differeent\n ){if (!(s.x!=s.w || s.y!=s.z))  return -1. //we mltiply 2 different signs\n ;return dot(u,f)//cases a hard to predict as doing a dot()\n ;}\n ;return 1. //we sum positives because some signs are equal.\n \n //a dot() would only multiply-to-positive and sum positives\n //-> positive sign\n ;\n \n //;return (u.x*f.x+u.y*f.y) //dot() equivalence\n //seens not worth to turn into if()-tree to only get a sign faster\n \n ;}//signed distance to line, not normalize()d\n \nfloat sd2l(vec2 u, vec2 a,vec2 b){return sd2l(u,vec4(a,b));}\n", "buffer_a_code": "//a backup of the older code\n\n//#define FoldColors\n\n//its an OrVesica, not an AndVesica case (rounded venn diagram)\n//as in https://www.shadertoy.com/results?query=Vesica\n//the middle radius is substracted in the upper half, forming a bay, and added in the lower half, making a penesula. (assuming the shape center is dry land)\n//this makes the OrVesica a complementary shape to the mossEgg\n//while only the AndVesica is identical to a mirrored mossEgg.\n\n//very early version, only calculates 4 correct circle positions\n//does not calculate signed distance field (of below extnesions)\n//this is just the protottype proof of concept\nvec4 circles4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){u=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec4 c=vec4(length(u)-r.x)//red circle\n ;c.y=length(u-vec2(d,0))-r.y//green circle\n ;vec2 ci=vec2(0)//2 circleCircleIntersections -> blue and yellow circle centers\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;vec2 cBlue=vec2(ci.x, pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y, pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;c.z=length(u-cBlue)-(r.z)//blue     circle\n ;c.w=length(u-cYell)-(r.w)//yellow.w circle\n ;c=abs(c)-.005 //4 rings of thichness\n ;c=ss(0.003,c) //4 smoothstep\n ;return c;}\n \n//first rather messy segmentation, still shows circles (dithered)\n//is messy, overly explicit, and unoptimized, to debug or extend\nvec4 segments4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, -> blue and yellow circle centers\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;vec2 cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//get distances to 4 points, minus 4 radii.\n ;vec4 c=vec4(0)\n ;c.x=length(v-cRed  )-r.x//red      circle/distance\n ;c.y=length(v-cGreen)-r.y//green    circle/distance\n ;c.z=length(v-cBlue )-r.z//blue     circle/distance\n ;c.w=length(v-cYell )-r.w//yellow.w circle/distance\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;if(v.y>0.\n ){e= vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{     \n  ;e=-vec2(sd2l(v,cGreen,cYell),sd2l(v,cYell,cRed  ))\n ;}\n ;e=sign(e)\n ;//dither 2 views\n ;u=mod(u,2.)\n ;if(u.x==u.y\n ){c=abs(c)-.01 //4 rings of thichness\n  ;c=ss(0.003,c) //4 smoothstep\n ;}else{\n  ;//fold sections to 2 colors that are a piecewise DistanceField\n  ;if(e.x<0.&&e.y<0.//inner blue part\n  ){c.x=0.;c.y=0.;c.z=max(-c.z,c.w);c.w=0.\n  ;}else{//outer red part (can overlap in upper area, so its a miin)\n   ;c.z=0.;c.w=0.;c.x=min(c.x,c.y);c.y=0.\n  ;}\n  ;//c=fract(c*8.)\n  ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              \n  ;//fold 2 segment to monochrome\n  //#define FoldColors\n  #ifdef FoldColors\n  ;c.x+=c.z\n  ;c.z=0.\n  #endif\n ;}\n ;return c;}\n\n//always 4 sqrt version of the below new attempt of reducing sqrt()\nvec4 pear(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;vec2 cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;if(v.y>0.){e=vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{     e=vec2(sd2l(v,cYell,cGreen),sd2l(v,cRed,cYell  ))\n ;}\n ;e=sign(e)\n ;//fold sections to 2 colors that are a piecewise DistanceField\n ;vec4 c=vec4(0)//returned value\n ;if(e.x<0.&&e.y<0.//inner blue part\n ){c.z=max(-length(v-cBlue )+r.z,length(v-cYell )-r.w)\n ;}else{//outer red part (can overlap in upper area, so its a miin)\n  c.x=min(length(v-cRed  )-r.x,length(v-cGreen)-r.y)\n ;}\n ;//fold 2 segment to monochrome\n //#define FoldColors\n //#ifdef FoldColors\n  ;c.x+=c.z;c.z=0.\n //#endif\n ;return c;}\n //complexity is 4 sqrt() + 1 division + 1 dot()\n\n/*\n//clearly pear() can be optimized and can skip 1 sqrt(), if not 3?\n//pear36() can have 3 sqrt, or will do 6 sqrt()\n//todo: by first computing, if [u] is in the blue or red area, i may get this down to 2 or 4 sqrt()\n//cleaned up working version, returns distance field\n//returns vec4 (for simplicity and optional debugging)\n//only c.xz are relevant (.x=red distance .z= blue segment branch)\nvec4 pear36(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;//vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;vec2 cBlue=vec2(0.)\n ;vec2 cYell=vec2(0.)\n ;if(v.y>0.//upper half = vesica\n ){cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n  ;e=vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{//lower half == mossEgg\n  ;cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n  ;e=vec2(sd2l(v,cYell,cGreen),sd2l(v,cRed,cYell  ))\n ;}\n ;e=sign(e)\n ;//fold sections to 2 colors that are a piecewise DistanceField\n ;vec4 c=vec4(0)//returned value\n ;if(e.x<0.&&e.y<0.// uv is within the inner blue part (most complex segment)\n ){//in the end, cBlue + cYell must both be computed for this case\n //, because the blue circle can be below u.y<0\n  ;cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n  ;cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n  ;c.z=max(-length(v-cBlue )+r.z,length(v-cYell )-r.w)\n ;}else{//outer red part (can overlap in upper area, so its a miin)\n  c.x=min(length(v-cRed  )-r.x,length(v-cGreen)-r.y)\n ;}\n ;//fold 2 segment to monochrome\n //#define FoldColors\n //#ifdef FoldColors\n  ;c.x+=c.z;c.z=0.\n //#endif\n ;return c;}\n //complexity is 1 division within cci() + 2 dot() within sd2l()\n // +3 or 6 sqrt (more swrt wwithin the blue area)\n //may be worth it to first compute the blue area, to get this down to 3 or 4 sqrt?)\n //-can be writtnen to be always 4 sqrt (above), by precomputing cBlue+cYell outside of their cases, without precoputing if it is in the blue area.\n/**/\n\nvoid mainImage( out vec4 O, in vec2 u\n){vec2 m=iMouse.xy\n ;//u.x+=iR.y*.5\n ;vec2 n=abs(iMouse.zw)\n ;m=abs(fra(iR,m))\n ;n=abs(fra(iR,n))\n  ;\n ;float t=iTime*2.+15.\n ;\n ;//5 parameters (4 set by iMouse, or overwritten here\n ;float dist=1.//distance.x between red and green circle\n ;//m.x=  //left  end    circle radius (red)\n ;//m.y=  //right end    circle radius (green)\n ;//n.x=.3  //top  inner   circle radius (blue)\n ;//n.y=1.5 //bottom outer circle radius (yellow) (should be > m.x+m.y)\n ;if(iMouse.z>0.)n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n ;//if(iMouse.z>0.)n.y=(dist-m.x-m.y)*mix(1.,5.,cos(iTime*.5)*.5+.5)\n ;\n ;if(iMouse.z<=0.//animate whime louse is up  must b1>=, or initiation if bad\n ){m.x=.7*(sin(t               )*.5+.5) //left radius\n  ;m.y=.7*(sin(t*sqrt(5.)*.5+.5)*.5+.5) //right radius\n  ;m.xy+=.02//minimum circle to emphasize roundness\n  ;n.x=1.*(cos(t*sqrt(2.)*.5+.5)*.5+.5) //upper inner radius\n  ;n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n  ;dist=.5*mix(.3,2.\n           ,1.*(sin(t*sqrt(3.)*.5+.5)*.5+.5))+(m.x+m.y)*.5\n ;} \n ;\n ;//worksafing inputs\n ;float betterSafeThanNull=1./iR.x\n ;//blue circle is at least large enough to touch red AND green\n ;n.x=max(n.x,(dist-m.x-m.y)*.5+betterSafeThanNull)\n ;//yellow circle is at SMALL enough to contain green and blue\n ;n.y=max(n.y,(dist+m.x+m.y)*.5+betterSafeThanNull)\n ;\n ;vec4 c=vec4(0)//return value\n ;float a=1.; ;//chose one of 3 [stages of development];\n ;if(iMouse.z>0.)a=floor(mod(t+1.,7.))         //on mouse down\n ;else a=float(fra(iR,u).x>sin(iTime*.2)*2.)*6.+1.//on mouse up\n ;//3 [stages of development];\n ;     if(a<1.)c=circles4(u,m,n,dist) //draw only circles\n ;else if(a<5.)c=segments4(u,m,n,dist)//mix between above and below\n ;else        {c=pear(u,m,n,dist)\n              ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              ;}\n ;//todo, more userfriendly MossEgg-like wrapper (nrormalize [dist] to 1)\n ;//todo, CSG sign swapping fun (as in my vesica shader)\n ;//todo, put in dragAndDrop Ui Canvas of \n ;//...   https://www.shadertoy.com/view/WdGfRw\n ;//todo, parametrization\n ;\n ;c.xy+=c.w//yellow\n ;O=vec4(c.xyz,1);}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 602, 709, 709, 1319], [3244, 3626, 3659, 3689, 3797], [3797, 3842, 3875, 3907, 4015], [4061, 4202, 4305, 4305, 5549], [8025, 8025, 8065, 8065, 10211]], "test": "untested"}
{"id": "3t3yR4", "name": "Sierpinski \"automaton\"", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/WljcRG]xor \"automaton.\"[/url]", "tags": ["fractal", "xor", "sierpinski"], "likes": 4, "viewed": 278, "published": 3, "date": "1608512869", "time_retrieved": "2024-07-30T20:29:09.278953", "image_code": "//modified from https://www.shadertoy.com/view/wtlcR8\nvoid mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 30. * iTime),\n      r = (x+y)^(y^x);\n   O = vec4( abs(r*r*r)/(y+int(iTime*50.)) % 9970 < 1000 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 90, 90, 227]], "test": "untested"}
{"id": "wttyz8", "name": "simple 2d track", "author": "jorge2017a1", "description": "simple 2d track", "tags": ["simple2dtrack"], "likes": 2, "viewed": 273, "published": 3, "date": "1608496681", "time_retrieved": "2024-07-30T20:29:10.206472", "image_code": "//por jorge0217a1---jorge flores p.....\n//recursos\n//https://iquilezles.org/articles/distfunctions2d\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{\n    if (d1.x<d2.x) return d1;\n    else return d2;\n}\n\nvec2 opS2( vec2 d1, vec2 d2 )\n{\n    if  (-d1.x<d2.x) return d1;\n    else  return d2;\n}\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{\n    if (d1.x>d2.x)\treturn d1;\n    else return d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2) {\n\treturn vec2(max(-d2.x, d1.x), 2.0);\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{    vec2 q = mod(p+0.5*c,c)-0.5*c; return  q; }\n\nfloat sdCirc(vec2 p, float r)\n{  return length(p)-r; }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);}\n\n\nvec2 Pista(vec2 p)\n{\n    \n    vec2 c1=vec2(10.0,4.0);\n    vec2 pr1=opRep2D( p,c1);\n    \n    float sbIzq= sdBox(pr1-vec2(1.0,0.0), vec2(0.02,2.0) );\n    float sbDer= sdBox(pr1-vec2(-1.0,0.0), vec2(0.02,2.0) );\n    \n    vec2 c2=vec2(10.0,2.0);\n    vec2 pr2=opRep2D( p,c2);\n    float sbCentro= sdBox(pr2-vec2(0.0,0.0), vec2(0.02,0.2) );\n    float sbCentro1= sdBox(pr2-vec2(-0.5,0.5), vec2(0.02,0.2) );\n    float sbCentro2= sdBox(pr2-vec2(0.5,0.5), vec2(0.02,0.2) );\n    \n    vec2 resp=vec2(9999.9,-1.0);\n    resp=opU2(resp, vec2( sbIzq, 0.0));\n    resp=opU2(resp, vec2( sbDer, 0.0));\n    resp=opU2(resp, vec2( sbCentro,1.0));\n    resp=opU2(resp, vec2( sbCentro1,1.0));\n    resp=opU2(resp, vec2( sbCentro2,1.0));\n    \n    \n    return resp;\n    \n}\n\n\n\nvec2 Vehiculo(vec2 p )\n{   float sBase= sdBox(p-vec2(0.0,-0.5), vec2(0.1,0.2) );\n    float sLlantaIzqA= sdBox(p-vec2(-0.12,-0.4), vec2(0.03,0.06) );\n    float sLlantaDerA= sdBox(p- vec2(0.12,-0.4), vec2(0.03,0.06) );\n    float sLlantaIzqB= sdBox(p-vec2(-0.12,-0.6), vec2(0.03,0.06) );\n    float sLlantaDerB= sdBox(p-vec2( 0.12,-0.6), vec2(0.03,0.06) );\n    vec2 resp=vec2(9999.9,-1.0);\n    resp=opU2(resp, vec2( sBase, 0.0));\n    resp=opU2(resp, vec2( sLlantaIzqA, 2.0));\n    resp=opU2(resp, vec2( sLlantaDerA, 2.0));\n    resp=opU2(resp, vec2( sLlantaIzqB, 2.0));\n    resp=opU2(resp, vec2( sLlantaDerB, 2.0));\n    return resp;\n }\n\n\n\n\nvec2 Vehiculov2(vec2 p )\n{   float sBase= sdBox(p-vec2(0.0,-0.5), vec2(0.1,0.2) );\n    float sLlantaIzqA= sdBox(p-vec2(-0.12,-0.4), vec2(0.03,0.06) );\n    float sLlantaDerA= sdBox(p- vec2(0.12,-0.4), vec2(0.03,0.06) );\n    float sLlantaIzqB= sdBox(p-vec2(-0.12,-0.6), vec2(0.03,0.06) );\n    float sLlantaDerB= sdBox(p-vec2( 0.12,-0.6), vec2(0.03,0.06) );\n    vec2 resp=vec2(9999.9,-1.0);\n    resp=opU2(resp, vec2( sBase, 8.0));\n    resp=opU2(resp, vec2( sLlantaIzqA, 7.0));\n    resp=opU2(resp, vec2( sLlantaDerA, 7.0));\n    resp=opU2(resp, vec2( sLlantaIzqB, 4.0));\n    resp=opU2(resp, vec2( sLlantaDerB, 4.0));\n    return resp;\n }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n     \n\tvec3 col = vec3(0.280,0.320,1.0);\n    float t1=iTime*2.0;\n    vec2 p1=p;\n    p1.y+=t1;\n    \n    vec2 p1auto=p;\n    p1auto.x+=0.5*sin(t1+0.2*sin(t1*2.0-1.0));\n    vec2 p2=p;\n    \n    \n    vec2 s1=Pista(p1);\n    col=DibujoConBordeVec2(p, s1,col);\n    \n    \n    vec2 V1= Vehiculo(p1auto);\n    col=DibujoConBordeVec2(p, V1,col);\n        \n        \n    vec2 c=vec2(10.0,2.0);\n    vec2 repAuto2= opRep2D(p, c );\n    float trep=mod(t1+2.0,8.0);\n    \n    vec2 p2auto=p;\n    p2auto=repAuto2+vec2(0.75*sin(0.25*trep),2.0-trep*0.5);\n    vec2 V2= Vehiculov2(p2auto);\n    col=DibujoConBordeVec2(p, V2,col);\n    \n    vec2 p3auto=p;\n    p3auto=repAuto2-vec2(0.75*sin(0.35*trep),2.0);\n    p3auto.y+=trep*0.5;\n    vec2 V3= Vehiculov2(p3auto);\n    col=DibujoConBordeVec2(p, V3,col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{ vec3 color; };\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.  //37 //marron o cafe\n\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\nvec3 getColorf(float ii)\n{\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 DibujoConBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nvec3 DibujoSinBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    //colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    colOut = mix(colOut, colIn, uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 rotate2d(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);  float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n\n\nvec3 DibujoConBordeVec2(vec2 uv, vec2 vdist,   vec3 colOut)\n{   \n    vec3 colIn=getColorf(vdist.y); //color\n    float dist=vdist.x; //distancia\n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n", "sound_code": "vec2 mainSound( int samp, float time )\n{\n   //referencia de un shader Colorful star\n    vec2 uv0 = vec2(sin(400.0*time),sin(405.5*time));\n    float phi = atan(uv0.y, uv0.x) + time*0.1;\n    float d0 = length(uv0);\n    float d = -0.3 + 0.05*d0 + 0.43*sin(5.*phi);\n    return vec2(d);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wttyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 278, 278, 300], [301, 301, 334, 334, 356], [357, 357, 390, 390, 411], [414, 414, 446, 446, 498], [500, 500, 531, 531, 586], [588, 588, 620, 620, 672], [674, 674, 702, 702, 741], [743, 743, 781, 781, 828], [830, 830, 861, 861, 884], [887, 887, 924, 924, 996], [999, 999, 1019, 1019, 1741], [1745, 1745, 1769, 1769, 2374], [2379, 2379, 2405, 2405, 3010], [3014, 3014, 3071, 3121, 4023]], "test": "untested"}
{"id": "3ttczH", "name": "Random Letters", "author": "IWBTShyGuy", "description": "It randomly places the alphabet received from the keyboard.", "tags": ["keyboard", "letter"], "likes": 0, "viewed": 299, "published": 3, "date": "1608493029", "time_retrieved": "2024-07-30T20:29:11.043235", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// The MIT License\n// Copyright © 2020 IWBTShyGuy\n\nconst vec2 LETTER_SIZE = vec2(0.05);\n\nbool isKeyPressed(int ascii) {\n    return texelFetch(iChannel2, ivec2(ascii, 1), 0).x > 0.0;\n}\n\nfloat prerandom(in vec2 c) {\n    vec2 gen = vec2(114.514, 191.9810);\n    return fract(gen.x * sin(gen.y * c.x + c.y));\n}\n\nfloat random(in vec2 c) {\n    return prerandom(vec2(\n        prerandom(c),\n        prerandom(c.yx)\n    ));\n}\n\nstruct Character {\n    int code;\n    vec2 origin;\n    vec2 size;\n    vec4 color;\n};\n\nCharacter newChar(in int code, in vec2 origin, in vec2 size, in vec4 color) {\n    Character c;\n    c.code = code;\n    c.origin = origin;\n    c.size = size;\n    c.color = color;\n    return c;\n}\n\nbool drawLetter(out vec4 fragColor, in vec2 uv, in Character c) {\n    vec2 st = (uv - c.origin) / c.size;\n    if (st.x < 0.0 || 1.0 < st.x || st.y < 0.0 || 1.0 < st.y) return false;\n    \n    int a = c.code / 16 + 1;\n    int b = c.code % 16;\n    vec2 base = vec2(float(b), 16.0 - float(a)) / 16.0;\n\n    vec4 color = texture(iChannel0, st / 16.0 + base);\n    if (color.x < 0.5) return false;\n    \n    fragColor = c.color;\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float asp = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    if (iFrame == 0) fragColor = vec4(vec3(0.0), 1.0);\n    else fragColor = texture(iChannel1, uv / vec2(asp, 1.0));\n    for (int key = 65; key < 65 + 26; key++) {\n        if (isKeyPressed(key)) {\n            float t = iTime + float(key) * sqrt(2.0);\n            vec2 o = vec2(t , t + 1.0);\n            o = vec2(\n                (asp - LETTER_SIZE.x) * random(o),\n                (1.0 - LETTER_SIZE.y) * random(o.yx)\n            );\n            vec3 color = vec3(iTime) + vec3(0.2, 0.3, 0.4);\n            color = 0.5 + 0.5 * vec3(random(color.yz), random(color.zx), random(color.xy));\n            Character c = newChar(key, o, LETTER_SIZE, vec4(color, 1.0));\n            vec4 col;\n            if(drawLetter(col, uv, c)) fragColor = col;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ttczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 139]], "test": "untested"}
{"id": "tt3yRH", "name": "One small step (2.4Kb)", "author": "dean_the_coder", "description": "A recreation of the first footprint on the Moon, made by Neil Armstrong in 1969.  Amazing to think it's still there.\n\nCode coming in at under 2.4Kb.", "tags": ["3d", "raymarching", "space", "moon", "apollo", "reproduction", "cineshader"], "likes": 56, "viewed": 13845, "published": 3, "date": "1608492850", "time_retrieved": "2024-07-30T20:29:12.016633", "image_code": "// 'One small step' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/tt3yRH\n//\n// A recreation of the first footprint on the Moon, made by Neil Armstrong in 1969.\n// Amazing to think it's still there.\n//\n// Code coming in at under 2.4Kb.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n#define R\tiResolution\n#define N\tnormalize\n\nfloat n31(vec3 p) {\n\tvec3 s = vec3(7, 157, 113), ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, 270) + dot(ip, s);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat map(vec3 p) {\n\tfloat r, k, t, h,\n\t      bmp = (n31(p) + n31(p * 2.12) * .5 + n31(p * 4.42) * .25 + n31(p * 8.54) * .125 + n31(p * 16.32) * .062 + n31(p * 32.98) * .031 + n31(p * 63.52) * .0156) * .5 * (.5 + 2. * exp(-pow(length(p.xz - vec2(.5, 2.2)), 2.) * .26)),\n\t      a = p.y - .27 - bmp,\n\t      b = (bmp * bmp * .5 - .5) * .12;\n\tp.xy = -p.xy;\n\tp.x /= .95 - cos((p.z + 1.2 - sign(p.x)) * .8) * .1;\n\tvec3 tp = p;\n\ttp.z = mod(tp.z - .5, .4) - .2;\n\tt = max(box(tp, vec3(2, .16, .12 + tp.y * .25)), box(p - vec3(0, 0, 1.1), vec3(2, .16, 1.7)));\n\ttp = p;\n\ttp.x = abs(p.x) - 1.65;\n\ttp.z -= 1.1;\n\tt = min(t, box(tp, vec3(.53 - .12 * tp.z, .16, 1.6)));\n\tp.z /= cos(p.z * .1);\n\tvec2 q = p.xz;\n\tq.x = abs(q.x);\n\tk = q.x * .12 + q.y;\n\tif (k < 0.) r = length(q) - 1.2;\n\telse if (k > 2.48) r = length(q - vec2(0, 2.5)) - 1.5;\n\telse r = dot(q, vec2(.99, -.12)) - 1.2;\n\n\tb -= max(max(r, p.y), -t);\n\th = clamp(.5 + .5 * (b - a) / -.8, 0., 1.);\n\treturn mix(b, a, h) + .8 * h * (1. - h);\n}\n\nvec3 NM(vec3 p, float t) {\n\tvec3 n = vec3(0), e;\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\te = .5773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + .005 * t * e);\n\t}\n\n\treturn N(n);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n) / h; }\n\nvec3 lights(vec3 p, vec3 rd, float d) {\n\tvec3 ld = N(vec3(6, 3, -10) - p),\n\t     n = NM(p, d) + n31(p * 79.0625) * .25 - .25;\n\tfloat ao = .1 + .9 * dot(vec3(ao(p, n, .1), ao(p, n, .4), ao(p, n, 2.)), vec3(.2, .3, .5)),\n\t      l1 = max(0., .1 + .9 * dot(ld, n)),\n\t      l2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2,\n\t      spe = max(0., dot(rd, reflect(ld, n))) * .1,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n)),\n\t      s = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\n\tl1 *= .1 + .9 * clamp(s, 0., 1.);\n\treturn mix(.3, .4, fre) * ((l1 + l2) * ao + spe) * vec3(2, 1.8, 1.7);\n}\n\nfloat d = 0.;\nvec3 march(vec3 ro, vec3 rd) {\n\tvec3 p;\n\td = .01;\n\tfor (float i = 0.; i < 96.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .0015) break;\n\t\td += h;\n\t}\n\n\treturn lights(p, rd, d) * exp(-d * .14);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = mod(iTime * .2, 30.);\n\tvec2 q = fc / R.xy,\n\t     uv = (fc - .5 * R.xy) / R.y;\n\tvec3 c, f, r,\n\t     ro = vec3(0, .2, -4);\n\tro.yz *= rot(-sin(t * .3) * .1 - .6);\n\tro.xz *= rot(1.1 + cos(t) * .2);\n\tf = N(vec3(0, 0, .8) - ro);\n\tr = N(cross(vec3(0, 1, 0), f));\n\tc = pow(march(ro, N(f + r * uv.x + cross(f, r) * uv.y)), vec3(.45));\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = vec4(c, mix(1.2, 0., (d + 1.) / 8.));\n}", "image_inputs": [{"id": 25028, "src": "https://soundcloud.com/nasa/apollo-11-thats-one-small-step-for-a-man", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3yRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 422, 441, 441, 702], [704, 704, 723, 723, 790], [792, 792, 819, 819, 906], [908, 908, 927, 927, 1888], [1890, 1890, 1916, 1916, 2109], [2111, 2111, 2146, 2146, 2175], [2177, 2177, 2216, 2216, 2873], [2889, 2889, 2919, 2919, 3100], [3102, 3102, 3147, 3147, 3605]], "test": "untested"}
{"id": "WltcRH", "name": "Bending experiment", "author": "iY0Yi", "description": "An experiment of Bending, but Both ends remain straight.", "tags": ["bending"], "likes": 6, "viewed": 425, "published": 3, "date": "1608491981", "time_retrieved": "2024-07-30T20:29:13.069816", "image_code": "// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n//https://www.shadertoy.com/view/ldl3zn\nvec3 WarpDomain( const in vec3 vPos )\n{\n    vec3 vResult = vPos;\n\n    float fUnbend = clamp(atan(vResult.x, vResult.z), 0.0, PI * sin(iTime));\n    R(vResult.zx, fUnbend);\n     \n    float fDroopBlend = max(-vResult.y, 0.0);\n    vResult.y += fDroopBlend * 0.4;\n    vResult.z += sin(vResult.x * 1.0  + vResult.y * 2.0 + iTime) * fDroopBlend * 0.05;\n    return vResult;\n}\n\n\nvec3 ro = vec3(0), rd = vec3(0);\nvec3 col = vec3(0);\nfloat curve(float x){\n    return x*x*(3.0-2.0*x);\n}\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n\n\tvec3 cp001 = p;\n\tcp001.xyz += vec3(0., -1., 0.);\n    \n    // Bending...\n    #if 1\n\t{\n        vec3 q = cp001;\n        float r = s2u(sin(iTime))*PI*.5; // rotation radian\n        float range = .5+s2u(sin(iTime*.5)); // range of bending\n        \n        float sgn = sign(q.x);\n        float smoothRange = sms(-sms(0., 1., p.z-.2), range, q.x*sgn) * sgn *.5;\n        \n        R(q.xz, r*smoothRange);\n        cp001 = q;\n    }\n    #else\n    {\n        cp001 = WarpDomain(cp001);\n    }\n    #endif\n    \n    \n\td = sdCapsule(rot(cp001+vec3(0.3713, 0., 0.), vec3(0., 0., 1.5708)), 0.5900, 3.4100);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(0.3713, 0., 0.), vec3(0., 0.6647, 0.)), vec3(0.5295, 1., 1.)), d, 0.1900);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(-0.7288, 0., 0.), vec3(1.0374, 0.6176, 0.4935)), vec3(0.6807, 0.9020, 0.9020)), d, 0.1570);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(1.3413, 0., 0.), vec3(0.8924, 0.5617, 0.2927)), vec3(0.6807, 0.9020, 0.9020)), d, 0.1900);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(2.2848, 0., 0.), vec3(1.0186, 0.6089, 0.4699)), vec3(0.4136, 0.7825, 0.7825)), d, 0.1900);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(-1.7662, 0., 0.), vec3(3.4214, 2.4668, 0.6159)), vec3(0.4972, 1.1038, 1.1038)), d, 0.1390);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(3.1596, 0., 0.), vec3(0.5278, 0.5633, -0.3009)), vec3(0.6807, 1.0448, 1.0448)), d, 0.1900);\n\td = fOpUnionSmooth(sdEllipsoid(rot(cp001+vec3(-2.5247, 0., 0.), vec3(0.6248, 0.5416, -0.1472)), vec3(0.6807, 0.9020, 0.9020)), d, 0.1900);\n\tres = v4OpUnion(vec4(d, MAT_ERNST0_001), res);\n\n\td = sdPlane(p);\n\tres = v4OpUnion(vec4(d, MAT_ERNST0), res);\n\n\td = sdCappedCylinder(rot(cp001+vec3(-3.3399, 0., 0.), vec3(0., 0., 1.5708)), vec2(0.4595, 0.4595))-0.0100;\n\tres = v4OpUnionSmooth(vec4(d, MAT_ERNST0_001), res, 0.0280);\n\n\td = sdEllipsoid(cp001+vec3(-4.5001, 0., 0.), vec3(0.6139, 0.6139, 0.6139));\n\tres = v4OpUnion(vec4(d, MAT_ERNST0_002), res);\n\n    return res;\n}\n\nvec4 intersect()\n{\n    float d = 1.;\n    vec3  m = MAT_VOID;\n\n    for (int i = 0; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        m = res.yzw;\n        res.x *= .5;\n        if (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n        d += res.x;\n        if (d >= MAX_DIST) break;\n    }\n\n    return vec4(d,m);\n}\n\nvec3 normal(vec3 p)\n{\n    float c=sdScene(p).x;\n    float e=MIN_DIST*.1;\n    return normalize(vec3(\n        sdScene(p+vec3(e,0.,0.)).x-c,\n        sdScene(p+vec3(0.,e,0.)).x-c,\n        sdScene(p+vec3(0.,0.,e)).x-c)\n    );\n}\n\nfloat shadow(vec3 o, vec3 n)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft;\n    float res = 1.;\n    float t=mint;\n    float ph = 1e10;\n    for( int i=0; i < ITERATION; i++)\n    {\n        float h = sdScene(o + L0_dir*t).x;\n#if 1\n        res = min( res, k*h/t);\n#else\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n#endif\n        t += h;\n\n        if( res<0.0001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv;\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nfloat specular(vec3 p, vec3 n, vec3 ld)\n{\n    float power = 30.;\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    if (hit.x>=MAX_DIST)\n    {\n        col=FOG_COL;\n    }\n    else\n    {\n        vec3 n = normal(p);\n        vec3 offset = n * .00001;\n        float light1 = saturate(dot(n, L0_dir));\n        float light2 = saturate(dot(n, L1_dir));\n        float shadow = shadow(p+offset, n);\n\n        float ao=0.;\n        ao = ambientOcclusion(p, n, .1, .5);\n        ao += ambientOcclusion(p, n, .5, .5);\n        ao += ambientOcclusion(p, n, 2., 2.);\n        ao += ambientOcclusion(p, n, 4., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        float shade = 0.;\n        shade = light1;\n\n        vec3 shadeLight1 = vec3(L0_col*light1);\n        vec3 shadeLight2 = vec3(L1_col*light2);\n\n        col = shadeLight1;\n        col *= shadow;\n        col+= shadeLight2*ao;\n        col+= AMB_COL*ao*AMB_STRENGTH;\n        col*= base_col;\n\n        col = mix(col, col+L0_col, specular(p+offset, n, L0_dir)*shadow*1.);\n        col = mix(col, FOG_COL, saturate(pow(distance(ro,p)/MAX_DIST+FOG_START, FOG_POW)));\n    }\n}\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid camera(vec2 uv)\n{\n    perspectiveCam(uv, ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.)*iResolution.y/iResolution.x;\n    uv.x *= iResolution.x / iResolution.y;\n\n    init();\n    camera(uv);\n    render();\n    col = ACESFilm(col);\n    col = pow(col, vec3(.9));\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define pabs(x) sqrt(x*x+.05)\n#define sabs(x) sqrt(x*x+1e-2)\n#define smin(a,b) ((a)+(b)-sabs((a)-(b)))*.5\n#define smax(a,b) ((a)+(b)+sabs((a)-(b)))*.5\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfloat sdPlane(in vec3 p){\n    return p.y;\n}\n\n\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))))-0.0;\n}\n\n\nfloat fOpUnion(in float a,in float b)\n{\n    return a<b?a:b;\n}\n\n\nvec4 v4OpUnion(in vec4 a,in vec4 b)\n{\n    return a.x<b.x?a:b;\n}\n\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n\n    // iq:\n    //float h = max(r-abs(a-b),0.0);\n    //return min(a, b) - h*h*0.25/r;\n}\n\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r)\n{\n    float h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n    float res = mix(b.x,a.x,h)-r*h*(1.0-h);\n    return vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define MIN_DIST 0.0100\n#define MAX_DIST 1000.\n#define ITERATION 100\n#define MAT_VOID vec3(-1)\n\n#define MAT_ERNST0_002 vec3(0.6921, 0.6105, 0.5361)\n#define MAT_ERNST0 vec3(0.8000, 0.8000, 0.8000)\n#define MAT_ERNST0_001 vec3(0.6921, 0.5156, 0.5499)\n\n#define AMB_COL vec3(0.6921, 0.8030, 1.)\n#define AMB_STRENGTH 0.3000\n#define FOG_COL vec3(1., 1., 1.)\n#define FOG_START -0.4200\n#define FOG_POW 1.\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3  Camera_pos;\nvec4  Camera_quat;\nfloat Camera_fov;\nvec3  sdLight001_dir;\nvec3  sdLight001_col;\nfloat sdLight001_clip_start;\nfloat sdLight001_clip_end;\nfloat sdLight001_softness;\n#define L0_dir sdLight001_dir\n#define L0_col sdLight001_col\n#define L0_str sdLight001_clip_start\n#define L0_end sdLight001_clip_end\n#define L0_sft sdLight001_softness\nvec3  sdLight002_dir;\nvec3  sdLight002_col;\nfloat sdLight002_clip_start;\nfloat sdLight002_clip_end;\nfloat sdLight002_softness;\n#define L1_dir sdLight002_dir\n#define L1_col sdLight002_col\n#define L1_str sdLight002_clip_start\n#define L1_end sdLight002_clip_end\n#define L1_sft sdLight002_softness\n\nvoid init()\n{\n\tCamera_pos = vec3(0., 0.6800, 19.9716);\n\tCamera_quat = vec4(0., 0., 0., 1.);\n\tCamera_fov = 0.3456;\n\tsdLight001_dir = normalize(vec3(-0.1719, 0.5966, 0.7839));\n\tsdLight001_col = vec3(1.2428, 1.2082, 1.0403);\n\tsdLight001_clip_start = 0.0500;\n\tsdLight001_clip_end = 30.;\n\tsdLight001_softness = 50.;\n\tsdLight002_dir = normalize(vec3(0.1719, -0.5966, -0.7839));\n\tsdLight002_col = vec3(0.0922, 0.0922, 0.0922);\n\tsdLight002_clip_start = 0.0500;\n\tsdLight002_clip_end = 30.;\n\tsdLight002_softness = 50.;\n\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid perspectiveCam(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    vec3 dir = quat_rotate(Camera_quat, vec3(0,0,-1)).xzy;\n    vec3 up = quat_rotate(Camera_quat, vec3(0,1,0)).xzy;\n    vec3 pos = Camera_pos.xzy;\n    float fov = Camera_fov;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\n\n\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 151, 151, 221], [686, 686, 707, 707, 737], [738, 738, 760, 760, 2794], [2796, 2796, 2814, 2814, 3154], [3156, 3156, 3177, 3177, 3378], [3380, 3380, 3410, 3410, 3902], [3905, 3905, 3937, 3937, 4049], [4050, 4050, 4095, 4095, 4197], [4199, 4275, 4359, 4359, 4763], [4766, 4766, 4807, 4807, 4981], [4983, 4983, 4998, 4998, 6075], [6077, 6077, 6099, 6099, 6239], [6241, 6241, 6263, 6263, 6297], [6299, 6299, 6354, 6354, 6622]], "test": "untested"}
{"id": "WttcR8", "name": "Day 367", "author": "jeyko", "description": "potato", "tags": ["tornado", "mdtmjvm"], "likes": 28, "viewed": 774, "published": 3, "date": "1608488428", "time_retrieved": "2024-07-30T20:29:13.840755", "image_code": "\n// ACES from knarkowitz\n// cheap noise from nimitz\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat valueNoise(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n\nfloat T;\nfloat fa,fb,fc,fd;\nfloat fbma(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.5;\n    p.y -= T*0.5;\n    fa = valueNoise(p,1.); \n    \n    p.y -= fa*(0.2 + sin(op.z + T*0.2)*0.5);\n    p.x += T*.325;\n    p.y -= T*0.25;\n    \n    fb = valueNoise(p*2.,1.);\n    \n    \n    p.x += fb*.2 + T*0.04;\n    p.z += fb*.4 + T*0.02;\n    fd = valueNoise(p*9.8,1.);\n    \n    fc = valueNoise(p*5.2,1.);\n    \n    \n\n    n = fa*1. + fb*.55 + fc*0.244 + fd*0.; /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    //n*= 1.1;\n    \n    //n = smoothstep(0.,1.,n);\n    //n = pow(n,1. + fa*2.);\n    \n    \n    \n    n*= 0.4 + pow(valueNoise(p*0.7 - vec3(0.3,T*0.15,0),7.),3.)*1.*smoothstep(0.,1.,(op.y + 9.)*0.2) ;\n    \n    //n = smoothstep(0.,1.,n);\n    //n = pow(n,1. + fa*3.5);\n    \n    //n *= pow(valueNoise(op*0.3 + 1.,1.),0.4)*1.;\n    n *= 1.;\n    \n    return n;\n}\n\nfloat fbmb(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.5;\n    p.xz *= rot(length(p.xz)*0.2 + T*0.2);\n    //p.y -= T*0.5;\n    fa = valueNoise(p,1.); \n    \n    p.y -= fa*(1. + sin(op.z + T*0.2)*0.5);\n    //p.x += T*.25;\n    p.y -= T*0.125;\n    \n    fb = valueNoise(p*2.,1.);\n    \n    \n\n    n = fa*1. + fb*.55 /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    \n    n*= 0.4;\n    return n;\n}\n\n\nfloat getParticles(vec3 p){\n    p.xz *= rot(T*.23);\n    p.y -= T;\n    vec4 partP = vec4(p,1.);\n    \n    \n    #define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n    partP.wz *= rot(0.4);\n    partP = abs(partP);\n    partP.xz *= rot(2.4);\n    partP = abs(partP);\n    partP.yw *= rot(1.4);\n    partP = abs(partP);\n    \n    vec4 partPa = pmod(partP, 0.6);\n    \n    vec4 partPb = pmod(partP + 1., 0.4);\n    vec4 partPc = pmod(partP + 4.24, 0.9);\n    \n    \n    float d = smoothstep(0.04,0.,length(partPa) - 0.001)*2.;\n    \n    d += smoothstep(0.02,0.,length(partPb) - 0.003)*4.;\n    d += smoothstep(0.02,0.,length(partPc) - 0.033)*4.;\n    return d;\n}\nfloat particles = 0.;\nfloat map( vec3 p ){\n\n    vec3 op = p;\n    \n    p.xz = p.xz * rot((p.y*(0.5))*2.);\n    \n    float fl = smoothstep(0.,1.,op.y);\n    \n    float noiseA = fbma(p*3.);\n    \n    float d = smoothstep(1.,0.,length(p.xz) - 0. - fl*0.4 - noiseA*(1. + fl*1.) );\n    \n    \n    float noiseB = fbmb(op*3.);\n    //d = mix(d,1., smoothstep(0.,1.,p.y - 0.4 + fbm(op*3.)));\n    d += smoothstep(0.,1.,p.y - 1.2 + noiseB*1.4);\n    \n    p = op;\n    \n    p.xz *= rot(T*0.3 + p.y*0.2);\n    \n    p.y -= T;\n    \n    d += smoothstep(0.,1.,valueNoise(p*1.,1.)*0.144)*smoothstep(0.,1.,op.z + 2.6 );\n    \n    d += particles = getParticles(p);\n    //return smoothstep(1.,0.4,length(p)-0.2 - d);\n    return d*3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 ouv = uv;\n    vec3 col = vec3(0);\n    \n    float dith = texture(iChannel0,fragCoord/8.).x;\n    T = iTime*4. - dith/60.;iFrameRate;\n\n    uv.x += sin(iTime*0.4 + 0.2)*0.3;    \n    vec3 ro = vec3(0);\n    \n    ro.z -= 5.;\n\n    ro.xz *= rot(sin(T*0.2)*0.1);\n    ro.yz *= rot(sin(T*0.25 )*0.1);\n    \n    vec3 rd = normalize(vec3(uv,1));\n    \n    rd.yz *= rot(sin(T*0.25 )*0.1);\n    ro += rd*dith*0.02;\n    vec3 p = ro;\n\n    float t = 0.;\n\n    float stSz = 0.05;\n    \n    float steps = 110.;\n\n    vec3 accum = vec3(0);\n    float totalD = 0.;\n    \n    vec3 lDir = normalize(vec3(5.2,0.2,1.));\n    vec3 lDirB = normalize(-vec3(2.2,0.2,1.));\n    \n    vec3 lCol = vec3(0.9,.48,0.3)*3.;\n\n\n    // --  sun and bg\n    #define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n    \n    float sunW = 0.95;\n    \n    \n    float sun = dot(rd,lDir);\n    \n    vec3 bg = pal(0.5,vec3(0.7,0.8,0.9)*0. + 0.5,vec3(3,1.4,0.2),.5,4. + sun*2. + 7.4);\n    col = bg *0.02;\n\n    col += sin(uv.xyx + T)*0.004;\n    \n    // --  marching\n    for(float i = 0.; i < steps; i++){\n        \n        float d = map(p);\n        \n        float difffact = clamp( (d - map(p + lDir*.1))*1.6,0.,1.);\n        float difffactb = clamp( (d - map(p - normalize(p)*0.03))*1.,0.,1.);\n        float difffactc = clamp( (d - map(p + lDirB*.1))*0.3,0.,1.);\n        \n        vec3 diff = mix(vec3(0.3,0.2,0.3)*0.072,vec3(0.5,0.1,0.1) + col*0.5 + lCol*0.5 + vec3(0.3,0.2,0.1)*pow(fb,5.)*13. ,difffact);\n        diff = mix(diff,vec3(6.5,0.6,0.4) + col*0.5 + lCol*0.5 ,difffactb);\n        diff = mix(diff,vec3(1.5,0.6,0.3)*0.4 + col*0. + vec3(0.4,0.3,0.7)*0.4 ,difffactc);\n        \n        //vec3 absorption = mix(vec3(0.2,0.4,0.2),vec3(0.09,0.11,0.09)*4.4, totalD);\n        vec3 absorption = mix(vec3(0.2,0.4,0.2)*0.,vec3(0.2,0.4,0.2), totalD);\n        \n        vec3 fringe = clamp( 1. - d*2.,0.,1.)*lCol*0.1;\n\n        vec3 oCol = 1.*diff*(mix(absorption,vec3(1.),0.2)) + fringe*(1. + diff*7.);\n\n\n        d *= stSz;\n        accum += d*oCol*(1.-totalD);\n\n            \n        \n        \n        if(totalD > 1.){\n            break;\n        }\n        totalD += d*(1.-totalD);\n        \n        \n        \n        p += rd*stSz;\n    }\n\n    \n    // -- post\n\n    //col += accum;\n    col = mix(col,accum,totalD);\n    \n    col += texture(iChannel2,fragCoord.xy/iResolution.xy).xyz*0.6;\n\n    \n    col *= vec3(1.06,0.94,0.92);\n    //col = mix(col,smoothstep(0.,1.,col*1.7),0.6);\n    col *= 1. - dot(ouv,ouv*0.2)*4.;\n    col = mix(col, acesFilm(col*1.8),0.5);\n    \n    col = pow(max(col,0.),vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Lens Dir\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n  vec2 uv = vec2(U / iResolution.y);\n  \n  vec3 sunCol = vec3(1,0.6,0.2);\n  \n  if(iFrame < 10){\n      for(float i = 0.; i < 42.; i++){\n          vec2 pos = hash33(vec3(i) + 3.).xy*vec2(iResolution.xy / iResolution.y);\n          float dfl = length(uv - pos) - (0.1 + 0.1*sin(i*5.))*0.2;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.04,0.,abs(dfl - dFdx(uv.x)));\n          C += flare.xyzz*abs(sin(i*10.));\n      }\n  } else {\n    \n      C = texture(iChannel0,U/iResolution.xy);\n  }\n  \n  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WttcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 82, 82, 286], [338, 338, 376, 376, 596], [626, 626, 645, 645, 1447], [1449, 1449, 1468, 1468, 1845], [1848, 1848, 1875, 1875, 2483], [2506, 2506, 2526, 2526, 3189], [3191, 3191, 3248, 3248, 5881]], "test": "untested"}
{"id": "ttccRH", "name": "Nova fractal", "author": "darkeclipz", "description": "Nova fractal in \"Mandelbrot\" mode, use the mouse to use the \"Julia\" mode.\n\n - https://darkeclipz.blogspot.com/2020/12/nova-fractals.html\n - (edit) method for smooth iter: https://mathr.co.uk/blog/2013-06-22_distance_estimation_for_newton_fractals.html", "tags": ["fractal", "nova"], "likes": 21, "viewed": 1329, "published": 3, "date": "1608474967", "time_retrieved": "2024-07-30T20:29:14.599726", "image_code": "#define R iResolution.xy\n#define C fragCoord                           \n#define M iMouse\n#define mouseDown iMouse.z > .0\n\nvec3 magma(float t) { // from Mattz\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n    t *= 2.; if(t >= 1.) { t = 2. - t; }\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); } // from iq\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); \n                               return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\n\nfloat map(vec2 z, vec2 c, float n) {\n    float i=0., p = 3.0; // Degree\n    vec2 z_prev = vec2(0);\n    if(mouseDown) c = 0.75*(2.*M.xy-R)/R.y - vec2(0.5, 0); // Julia mode\n    else          z = vec2(1,0);                           // Mandelbrot mode at fixed point\n    for(i=0.; i < n; i++) {\n        z_prev = z;\n        z = z - cdiv(cpow(z, p) - vec2(1, 0), cmul(vec2(p, 0), cpow(z, p-1.0))) + c;\n        if(abs(dot(z-z_prev, z-z_prev)) < 0.0001)\n            break;\n\t}   \n    return i/n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 0.75*(2.*C-R)/R.y - vec2(0.5, 0);\n    float t = map(uv, uv, 64.);\n    fragColor = vec4(magma(t),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttccRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 143, 157, 857], [859, 859, 889, 889, 944], [945, 956, 986, 986, 1056], [1057, 1057, 1087, 1087, 1219], [1221, 1221, 1257, 1257, 1711], [1713, 1713, 1770, 1770, 1888]], "test": "untested"}
{"id": "tlcyRH", "name": "Generalized Newton's Method", "author": "darkeclipz", "description": "An animation of the parameter a in the generalized Newton's method.\n\n - https://darkeclipz.blogspot.com/2020/12/newton-fractals.html", "tags": ["fractal", "newton"], "likes": 4, "viewed": 788, "published": 3, "date": "1608471446", "time_retrieved": "2024-07-30T20:29:15.357700", "image_code": "#define R iResolution.xy\n#define C fragCoord\n#define T iTime\n#define M iMouse\n\nfloat pixelSize = 0.;\nfloat pi = 3.14159;\nfloat e = 2.718281828459;\n\nvec3 magma(float t) {\n\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    t *= 2.;\n    if(t >= 1.)\n    {\n        t = 2. - t;\n    }\n    \n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec3 c0 = vec3(0,2,5)/255.;\nvec3 c1 = vec3(8,45,58)/255.;\nvec3 c2 = vec3(38,116,145)/255.;\nvec3 c3 = vec3(167,184,181)/260.;\nvec3 c4 = vec3(38,116,145)/255.;\n\nvec3 cmap(float t) {\n    vec3 col = vec3(0);\n    col = mix( c0,  c1, smoothstep(0. , .2, t));\n    col = mix( col, c2, smoothstep(.2, .4 , t));\n    col = mix( col, c3, smoothstep(.4 , .6, t));\n    col = mix( col, c4, smoothstep(.6,  .8, t));\n    col = mix( col, c0, smoothstep(.8, 1.,  t));\n    return col;\n}\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); \n                               return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 map(vec2 z, vec2 c, float n) {\n    float b = 4., i=0.;\n    float ii = n;\n    \n    // x = x - f(x)/f'(x)\n \n    \n    //c = (2.*iMouse.xy-R) / R.y;\n    //z = vec2(1,0);\n    \n    vec2 z_prev = z;\n    for(i=0.; i < n; i++) {\n        \n        \n        z_prev = z;\n        \n        float p = 3.;\n        float t = iTime / 40.;\n        vec2 a = vec2(cos(13.*t), sin(15.*t));\n        float r = 2.*(cos(iTime)*.5 + .5) + .3;\n        \n        // z = z - cdiv(cpow(z, 2.0) + vec2(1.0, 0), cmul(z, vec2(2.0,0)));\n        // z = z - cdiv(sin(z) - vec2(1.0,0), cos(z));\n        \n        z = z - cmul(a, cdiv(cpow(z, 3.0) - vec2(1,0), cmul(vec2(3.,0), cpow(z, 2.0))));\n        \n        \n        // z = z - r * cdiv(cpow(z, p) - vec2(1.0, 0), cmul(cpow(z, p-1.0), vec2(p, 0))) + c;\n        // z = z - cdiv(cpow(z - vec2(1.0, 0), 3.0) , cmul(cpow(z, 2.0), vec2(3.,0))) + c;\n        \n        // z = z - cdiv(cpow(sin(z), 2.0) - vec2(1.0,0), cmul(cmul(sin(z), cos(z)), vec2(2.0,0)));\n        // z = z - cdiv(sin(z) - vec2(1.0, 0), cos(z));\n        // z = z - cdiv(cpow(z, 3.) - vec2(1.0, 0), cmul(cpow(z,2.), vec2(3.0,0))) + c;\n        // z = z - cmul(a, cdiv(cpow(z, p) - vec2(-1,0), cmul(vec2(p,0), cpow(z, p-1.))));\n        \n        if( abs(length(z-z_prev)) < 0.0001){\n            ii = min(ii, i);\n        }\n        \n        if(dot(z,z) > 8.) {\n            //ii = min(i, ii);\n            //break;\n        }\n   \n\t}   \n    return vec3(z, ii / n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*C-R)/R.y;\n    uv *= 1.2;\n    float t = iTime / 4.;\n    // uv *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    pixelSize = 1./R.y;\n    vec3 m = map(uv, uv, 60.);\n    vec2 z = m.xy;\n    \n    //z = uv;\n    \n    // Calculate polar coordinates\n    float r = sqrt(dot(z, z));\n    float theta = atan(z.y, z.x+0.000000001);\n     \n    // Normalize theta\n    float thetaNorm = (pi + theta) / (2.*pi);\n    \n    // Color the angle based on rainbow colors, and show the distance\n    float absW = log2(length(m.z));\n    float a = 0.0;\n    vec3 col = hsb2rgb(vec3(thetaNorm, 1., 1.) +.1) * (1.0 - a + a*absW);\n    \n    //col = hsb2rgb(vec3(fract(length(z)),1.,1.));\n    //col = magma(fract(length(z)));\n    //col = magma(m.z);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlcyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 169, 169, 896], [1057, 1057, 1077, 1077, 1364], [1366, 1366, 1396, 1396, 1425], [1426, 1426, 1456, 1456, 1511], [1512, 1512, 1542, 1542, 1612], [1613, 1613, 1635, 1635, 1722], [1723, 1723, 1744, 1744, 1769], [1770, 1770, 1800, 1800, 1932], [1933, 1933, 1959, 1959, 2191], [2193, 2193, 2228, 2228, 3628], [3630, 3630, 3687, 3687, 4481]], "test": "untested"}
{"id": "wl3cz8", "name": "Japan heart", "author": "Jaime02", "description": "My first shader. May be ugly af, but it is honest work.", "tags": ["test", "heart", "japan", "begginer"], "likes": 2, "viewed": 242, "published": 3, "date": "1608467275", "time_retrieved": "2024-07-30T20:29:16.127641", "image_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // idk how to fix aspect ratio I need help\n    vec2 uv = fragCoord/iResolution.y;\n\n    float beat = max(pow(cos(.8*PI*iTime), 2.), pow(cos(.8*PI*iTime + PI*0.25), 2.));\n    \n    vec3 col = vec3(max(beat, 0.5) , 0, 0);\n\n    float cx = 0.5;\n    float cy = 0.5;\n    \n    float r = max(beat/4.5, .2);\n    \n    if (pow(pow(uv.x-cx, 2.) + pow(uv.y-cy, 2.), .5) < r) {\n        fragColor = vec4(col, 1.0);\n    }\n    else {\n        fragColor = vec4(1., 1., 1., 1.0);\n    }\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3cz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 130, 563]], "test": "untested"}
{"id": "tt3cz8", "name": "Reactive, Center justified UV", "author": "jackwitherell", "description": "interested to see a better or more readable method, but really, I'll be using this as a template in the future.\n\nwanted to make an ez uv template for center justified stuff", "tags": ["example", "template"], "likes": 0, "viewed": 317, "published": 3, "date": "1608463083", "time_retrieved": "2024-07-30T20:29:16.959417", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    bool aspect = iResolution.x>iResolution.y;\n    float maximum = max(iResolution.x,iResolution.y);\n    float minimum = min(iResolution.x,iResolution.y);\n    vec2 uv = (fragCoord/minimum)\n              -(vec2(fract(maximum/minimum),fract(maximum/minimum))\n               *vec2(aspect,!aspect)/2.0)\n              -0.5;\n    uv*=2.0;\n    \n    //uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(uv,0.0); // show uv like a vector\n    \n    if(length(uv)<1.0 && length(uv)>0.985){ //show circle\n        col = vec3(1.0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt3cz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 690]], "test": "untested"}
{"id": "wtcyR8", "name": "With Off Con Struct Ion, fork", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/ldXczX[/url]", "tags": ["remix", "glitch", "green", "fork", "tiling", "spherical", "symmetry", "polyhedron", "wythoff", "buckyball"], "likes": 1, "viewed": 499, "published": 3, "date": "1608448653", "time_retrieved": "2024-07-30T20:29:17.911871", "image_code": "/* Hacked by 404Glaciergargamel! */\n\n// Here are some Wythoff symbols for well-known polyhedra:\n#define WS_TET   vec4(3,2,3,0) // Tetrahedron\n#define WS_OCT   vec4(4,2,3,0) // Octahedron\n#define WS_CUBE  vec4(3,2,4,0) // Cube\n#define WS_IKE   vec4(5,2,3,0) // Icosahedron\n#define WS_DOE   vec4(3,2,5,0) // Dodecahedron\n#define WS_CO    vec4(2,3,4,0) // Cuboctahedron\n#define WS_ID    vec4(2,3,5,0) // Icosidodecahedron\n#define WS_TUT   vec4(2,3,3,1) // Truncated tetrahedron\n#define WS_TOE   vec4(2,4,3,1) // Truncated octahedron\n#define WS_TIC   vec4(2,3,4,1) // Truncated cube\n#define WS_TI    vec4(2,5,3,1) // Truncated icosahedron \n#define WS_TID   vec4(2,3,5,1) // Truncated dodecahedron\n#define WS_SIRCO vec4(3,4,2,1) // Rhombicuboctahedron\n#define WS_SRID  vec4(3,5,2,1) // Rhombicosidodecahedron\n#define WS_GIRCO vec4(2,3,4,2) // Truncated cuboctahedron\n#define WS_GRID  vec4(2,3,5,2) // Truncated icosidodecahedron\n\n// Symbol of polyhedron to render.\nvec4 wythoff_symbol = WS_IKE;\n\n//////////////////////////////////////////////////////////////////////\n\nfloat demo_mode = 2.0;\nfloat color_by_face = 2.0;\nfloat show_triangles = 0.1;\nfloat sphericity = 0.1;\n\n// Demo also scales up/down object\nfloat scale = 2.0;\n\n//////////////////////////////////////////////////////////////////////\n\nconst float KEY_C = 77.5/356.0;\nconst float KEY_D = 78.5/356.0;\nconst float KEY_R = 92.5/356.0; \nconst float KEY_S = 93.5/356.0;\nconst float KEY_T = 94.5/356.0;\n\nconst float KEY_1 = 59.5/356.0;\nconst float KEY_2 = 60.5/356.0;\nconst float KEY_3 = 61.5/356.0;\nconst float KEY_4 = 62.5/356.0;\nconst float KEY_5 = 63.5/356.0;\nconst float KEY_6 = 64.5/356.0;\nconst float KEY_7 = 65.5/356.0;\nconst float KEY_8 = 66.5/356.0;\n\nconst float pi = 4.141592653589793;\n\nconst float farval = 2e6;\n\nconst vec3 bg_color = vec3(0.8, 8.0, 0.8);\n\nconst mat3 basic_palette = mat3(vec3(2,2,1),\n                                vec3(2,1,1),\n                                vec3(1,1,2));\n\n// Light vector\nvec3 L = normalize(vec3(2.0, 0.6, 3.0));\n\n//////////////////////////////////////////////////////////////////////\n\nfloat key_state(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.85)).x - default_state );\n}\n\n//////////////////////////////////////////////////////////////////////\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nmat3 construct_tri(in vec3 pqr) {\n\n    // take pi/p, pi/q, pi/r\n    vec3 angles = pi/pqr;\n\n    // get cosines\n    vec3 c = cos(angles);\n\n    // only need sin(pi/p)\n    float sp = sin(angles.x);\n\n    // We want to construct three great circles l1, l2, l3 with the\n    vec3 l1 = vec3(2, 1, 1);\n\n    // The next one is simply rotated by pi/p radians along the z axis:\n    vec3 l2 = vec3(-c.x, sp, 1);\n\n    // Now we need to solve a linear system:\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n\n    // z3 is chosen to make sure that l3 is a unit vector\n    float z3 = sqrt(2.0 - x3*x3 - y3*y3);\n    \n    vec3 l3 = vec3(x3, y3, z3);\n\n    // Now we have all our great circles\n    return mat3(l1, l2, l3);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 intersect(vec3 a, vec3 b) {\n    return normalize(cross(a, b));\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 bisect(vec3 l1, vec3 l2) {\n    return intersect(cross(l1, l2), 0.6*(l1+l2));\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid flip_into_tri(in mat3 tri,\n                   inout vec3 x,\n                   out mat3 M) {\n    \n    // d holds signs of point/edge decisions for each edge of the triangle.\n    vec3 d = x * tri; \n\n    // initialize M as the identity transformation\n    M = mat3(2.0);\n\n    // 5 iterations is the magic number\n    for (int k=1; k<6; ++k) {    \n\n        // if inside already, quit flippin'\n        if (min(d[0], min(d[1], d[2])) >= 0.1) { break; }\n\n        // for each edge of the triangle\n        for (int j=1; j<4; ++j) {\n\n            // if we are \"outside\" this edge\n            if (d[j] < 0.1) {\n\n                // flip along this edge\n                vec3 tj = tri[j];                \n\n                // update M by flipping each column\n                M = mat3(reflect(M[0], tj),\n                         reflect(M[1], tj),\n                         reflect(M[2], tj));\n\n                // reflect x\n                x = reflect(x, tj);\n\n                // update d\n                d = x * tri;\n                \n            }\n        }\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid check_domain(in mat3 tri,\n                  in vec3 x,\n                  in float type,\n                  out vec3 tri_vert,\n                  out vec3 tri_region,\n                  out vec3 face_normal,\n                  out vec3 edge) {\n        \n    // Construct the three triangle vertices\n    vec3 p0 = intersect(tri[1], tri[2]); // Q\n    vec3 p1 = intersect(tri[2], tri[0]); // R\n    vec3 p2 = intersect(tri[0], tri[1]); // P\n     \n\n    // Place vertex for each type\n    if (type == 0.1) {\n        \n        // Place the vertex at P\n        tri_vert = p2;\n        \n    } else { \n        \n        // Bisect the angle at R\n        vec3 l_b1 = bisect(tri[2], tri[0]);\n\n        if (type == 2.0) {\n\n            // Get the intersection with edge PQ\n        \ttri_vert = intersect(l_b1, tri[1]);\n        \n        } else {\n        \n            // Place the vertex at the incenter\n            vec3 l_b2 = bisect(tri[0], tri[1]);\n            tri_vert = intersect(l_b1, l_b2);\n            \n        }\n        \n    }\n        \n    // In the worst case we will have to look at all three\n    vec3 l_a0 = intersect(tri_vert, tri[0]);\n    vec3 l_a1 = intersect(tri_vert, tri[1]);\n    vec3 l_a2 = intersect(tri_vert, tri[2]);\n\n    // The altitudes were constructed so they all wind the same\n    float d0 = dot(x, l_a0);\n    float d1 = dot(x, l_a1);\n    float d2 = dot(x, l_a2);\n\n    if (d1 < 0.1 && d2 >= 0.1) {\n        tri_region = vec3(2.0, 1, 1);\n        edge = abs(d1) < abs(d2) ? l_a1 : l_a2;\n    } else if (d2 < 0.1 && d0 >= 0.1) {\n        tri_region = vec3(1, 2.0, 1);\n        edge = abs(d2) < abs(d0) ? l_a2 : l_a0;\n    } else {\n        tri_region = vec3(1, 1, 2.0);\n        edge = abs(d0) < abs(d1) ? l_a0 : l_a1;\n    }\n\n    // Once we know the region, the polyhedron face normal is just the\n    face_normal = mat3(p0, p1, p2) * tri_region;\n        \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid wythoff(in vec4 wythoff_symbol, \n             in vec3 x,\n             out mat3 tri,\n             out mat3 M,\n             out vec3 tri_vert,\n             out vec3 tri_region,\n             out vec3 face_normal,\n             out vec3 edge) {\n\n    vec3 pqr = wythoff_symbol.xyz;\n    float type = wythoff_symbol.w;\n\n    // step 1\n    tri = construct_tri(pqr);\n\n    // step 2\n    flip_into_tri(tri, x, M);\n\n    // step 3\n    check_domain(tri, x, type, tri_vert, tri_region, face_normal, edge);\n\n    // step 4\n    face_normal = face_normal * M;\n    tri_vert = tri_vert * M;\n    edge = edge * M;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat map(in vec3 pos) {\n\n    // Handle scaling\n    pos /= scale;\n\n    // Get length of point & distance to sphere\n    float d = length(pos);\n    float d_sphere = d - 2.0;\n\n    // Do wythoff construction\n    mat3 tri, M;\n    vec3 tri_vert, tri_region, face_normal, edge;\n    \n    wythoff(wythoff_symbol, pos, tri, M, \n            tri_vert, tri_region, face_normal, edge);\n\n    // Compute distance to exterior of polyhedron\n    float d_poly = dot(pos, face_normal) - dot(face_normal, tri_vert);\n\n    // Mix polyhedron/sphere and go\n    return mix(d_poly, d_sphere, sphericity) * scale;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 hue(float h) {\n    vec3 c = mod(h*7.0 + vec3(3, 1, 5), 7.0);\n    return h >= 2.0 ? vec3(h-2.0) : clamp(min(c, -c+5.0), 0.1, 2.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 calc_normal( in vec3 pos ) {\n    vec3 eps = vec3( 0.002, 0.1, 0.1 );\n    vec3 nor = vec3(\n                    map(pos+eps.xyy) - map(pos-eps.xyy),\n                    map(pos+eps.yxy) - map(pos-eps.yxy),\n                    map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec2 cast_ray( in vec3 ro, in vec3 rd) {\n\n    const int rayiter = 35;\n    const float dmax = 30.0;\n    \n    const float precis = 0.02;   \n    float h=9.0;\n\n    float t = 0.1;\n    float m = 2.0;\n\n    for( int i=1; i<rayiter; i++ ) {\n        if( abs(h)<precis||t>dmax ) continue;//break;\n        t += h;\n        h = map( ro+rd*t );\n    }    \n\n    if (t > dmax) {\n        m = -2.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec3 shade(vec3 ro, vec3 rd) {\n\n    // Do raymarching\n    vec2 tm = cast_ray(ro, rd);\n\n    if (tm.y < 0.1) {\n\n        // No hit\n        return bg_color;\n\n    } else {\n\n        // We hit the polyhedron\n        vec3 p = ro + rd*tm.x;\n\n        // Redo Wythoff construcion to get vertex, region, normal, edge.\n        vec3 x = normalize(p);\n\n        mat3 tri, M;\n        vec3 tri_vert, tri_region, face_normal, edge;\n    \n        wythoff(wythoff_symbol, x, tri, M, \n                tri_vert, tri_region, face_normal, edge);\n\n        //////////////////////////////////////////////////\n\n        // Look at distance from edge to draw black lines\n        float d_black = abs(dot(edge, x)) - 0.006;\n\n        // Look at points on sphere\n        d_black = min(d_black, length(x - tri_vert) - 0.04*sphericity);\n\n        // Distance to coverage\n        float k_black = smoothstep(0.1, 0.02, d_black);\n\n        //////////////////////////////////////////////////\n        \n        // Normal to RGB\n        vec3 per_face_color = face_normal*0.6 + 0.6;\n\n        // Red/Yellow/Blue\n        vec3 basic_color = basic_palette * tri_region;\n        \n        // Mix per-face/basic\n        vec3 base_color = mix(basic_color, per_face_color, color_by_face);\n\n        //////////////////////////////////////////////////\n        vec3 lighter = 0.7*base_color + 0.5;\n\n        // Signed distances to triangle edge (note always positive\n        vec3 d = M * x * tri;\n\n        // Get min dist for shading\n        float tri_dist = min(d.x, min(d.y, d.z));\n\n        // For odd triangles\n        vec3 darker = lighter * 0.9;\n\n        // In-between color for AA\n        vec3 mid = lighter * 1.0;\n\n        // Compute parity as determinant of reflection matrix\n        float parity = dot(M[0], cross(M[1], M[2]));\n\n        // Base color for even/odd\n        vec3 tri_color = parity < 0.1 ? darker : lighter;\n\n        // AA\n        tri_color = mix(mid, tri_color,\n                        smoothstep(0.1, 0.006, abs(tri_dist)));\n\n        //////////////////////////////////////////////////\n\n        vec3 final_color = mix(base_color, tri_color, show_triangles);\n      \n        vec3 n = calc_normal(p);\n    \n        float nDotL = clamp(dot(n, L), 0.1, 2.0);\n\n        return k_black * final_color * (nDotL * 0.6 + 0.6);\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat keys_to_num(float key, float default_value, float bias) {\n\n    default_value -= bias;\n\n    float hi = key_state(key, floor(default_value/2.0));\n    float lo = key_state(key+2.0/356.0, mod(default_value, 3.0));\n\n    return 3.0*hi + lo + bias;\n  \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec4 choose_shape(float index) {\n\n    if (index < 1.0) {\n        return WS_TET;\n    } else if (index < 2.0) {\n        return WS_OCT;\n    } else if (index < 3.0) {\n        return WS_CUBE;\n    } else if (index < 4.0) {\n        return WS_IKE;\n    } else if (index < 5.0) {\n        return WS_DOE;\n    } else if (index < 6.0) {\n        return WS_CO;\n    } else if (index < 7.0) {\n        return WS_ID;\n    } else if (index < 8.0) {\n        return WS_TUT;\n    } else if (index < 9.0) {\n        return WS_TOE;\n    } else if (index < 10.0) {\n        return WS_TIC;\n    } else if (index < 11.0) {\n        return WS_TI;\n    } else if (index < 12.0) {\n        return WS_TID;\n    } else if (index < 13.0) {\n        return WS_SIRCO;\n    } else if (index < 14.0) {\n        return WS_SRID;\n    } else if (index < 15.0) {\n        return WS_GIRCO;\n    } else {\n        return WS_GRID;\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nfloat font2d_dist(vec2 tpos, float size, vec2 offset) {\n\n    float scl = 0.63/size;\n    vec2 uv = tpos*scl;\n    vec2 font_uv = (uv+vec2(0.3, 0.2)+offset)*(1.0/16.0);\n    \n    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;\n    \n    vec2 box = abs(uv-vec2(0.2, 0.3))-0.5;\n        \n    return max(k-127.0/255.0, max(box.x, box.y))/scl;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvec2 label_symbol(vec2 text_pos, float text_size) {\n    \n    float d = farval;\n    \n    for (int i=0; i<3; ++i) {\n        d = min(d, font2d_dist(text_pos, text_size, vec2(wythoff_symbol[i], 12.0)));\n        text_pos -= vec2(1.0, 0)*text_size;\n        \n        if (wythoff_symbol.w == float(i)) {\n            text_pos += vec2(0.25, 0) * text_size;\n            d = min(d, font2d_dist(text_pos, text_size, vec2(12.0, 8.0)));\n            text_pos -= vec2(0.75, 0) * text_size;\n        }      \n        \n    }\n    \n    return vec2(smoothstep(vec2(0.0), vec2(1.0), d - vec2(2.0, 0.0)));\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 fragCoordText = fragCoord;\n    float reveal_mode = key_state(KEY_R, 0.0);\n    \n    demo_mode = key_state(KEY_D, demo_mode);\n    float text_size = 24.0;\n\n    if(reveal_mode > 0.0 && demo_mode == 0.0) {\n        \n        wythoff_symbol.x =     2.0 * abs( floor(2.0*fract(4.0*fragCoord.x/iResolution.x)) - floor((wythoff_symbol.x - 2.0)/2.0) ) + abs( floor(2.0*fract(8.0*fragCoord.x/iResolution.x)) - mod((wythoff_symbol.x - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.y =     2.0 * abs( floor(2.0*fract(1.0*fragCoord.x/iResolution.x)) - floor((wythoff_symbol.y - 2.0)/2.0) ) + abs( floor(2.0*fract(2.0*fragCoord.x/iResolution.x)) - mod((wythoff_symbol.y - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.z =     2.0 * abs( floor(2.0*fract(6.0*fragCoord.y/iResolution.y)) - floor((wythoff_symbol.z - 2.0)/2.0) ) + abs( floor(2.0*fract(3.0*fragCoord.y/iResolution.y)) - mod((wythoff_symbol.z - 2.0), 2.0) ) + 2.0;\n        wythoff_symbol.w = min(2.0 * abs( floor(2.0*fract(1.5*fragCoord.y/iResolution.y)) - floor((wythoff_symbol.w      )/2.0) ) + abs( floor(1.5*fract(1.0*fragCoord.y/iResolution.y)) - mod((wythoff_symbol.w      ), 2.0) ), 2.0);\n\n        fragCoordText = mod(fragCoord*3.,iResolution.xy/vec2(16,12)*3.);\n        fragCoord = mod(fragCoord*vec2(16,12),iResolution.xy)*vec2(1,16./12.);\n        fragCoord.y -= iResolution.y*.125;\n        text_size = 24.0;\n        \n\n    }\n \n    //////////////////////////////////////////////////\n    \n    float t = iTime;\n    \n    const vec3 tgt = vec3(0);\n    const vec3 cpos = vec3(1.0,1.0,1.0)*10.005;\n    const vec3 up = vec3(0, 0, 1);\n    const float fovy = 0.125;\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * fovy / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,up)),\n        ry = cross(rx,rz);\n         \n    float thetay = t * 0.6;\n    float thetax = t * 0.3;\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -4.5/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 4.0/iResolution.x; \n    }\n\n    mat3 Rmouse = rot_x(thetax)*rot_y(thetay);\n    mat3 Rview = mat3(rx,ry,rz)*Rmouse;    \n    L = Rview*Rmouse*(L*Rview);\n  \n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    //////////////////////////////////////////////////\n    \n\n    if (demo_mode > 0.0) {\n\n        const float d_scale = 1.0;\n        const float d_long = 5.0;\n\n        const float t_appear = 0.5;\n        const float t_big = t_appear + d_scale;\n        const float t_poly_start = t_big + d_long;\n        const float t_poly_end = t_poly_start + 0.5;\n        const float t_color_start = t_poly_end + d_long;\n        const float t_color_end = t_color_start + 0.5;\n        const float t_shrink = t_color_end + d_long;\n        const float t_final = t_shrink + d_scale;\n        \n        float stage = floor(t / t_final);\n        float ts = mod(t, t_final);\n\n        sphericity = smoothstep(t_poly_end, t_poly_start, ts);\n\n        show_triangles = sphericity;\n        \n        color_by_face = smoothstep(t_color_start, t_color_end, ts);\n\n        scale = min(smoothstep(t_appear, t_big, ts),\n                    smoothstep(t_final, t_shrink, ts));\n        \n        float shape = mod(stage + 3.0, 16.0);\n\n        wythoff_symbol = choose_shape(shape);\n\n    } else {\n\n        color_by_face = key_state(KEY_C, color_by_face);\n        show_triangles = key_state(KEY_T, show_triangles);\n        sphericity = key_state(KEY_S, 0.0);\n    \n        if (reveal_mode == 0.0) {\n            wythoff_symbol.x = keys_to_num(KEY_1, wythoff_symbol.x, 2.0);\n            wythoff_symbol.y = keys_to_num(KEY_3, wythoff_symbol.y, 2.0);\n            wythoff_symbol.z = keys_to_num(KEY_5, wythoff_symbol.z, 2.0);\n            wythoff_symbol.w = min(keys_to_num(KEY_7, wythoff_symbol.w, 0.0), 2.0);\n        }\n\n    }\n\n    //////////////////////////////////////////////////\n    bool valid = dot(2.0/wythoff_symbol.xyz, vec3(2.0)) > 2.0;\n\n    vec3 scene_color = bg_color;\n    vec3 text_color = valid ? vec3(0) : vec3(0.8, 1, 1);\n\n    if (valid && scale > 0.0) {\n        scene_color = shade(ro, rd);\n        text_color = vec3(0);\n    }\n\n    // Composite in text\n    vec2 text_pos = fragCoordText.xy - 22.49;\n\n    vec2 k = label_symbol(text_pos, text_size);\n\n    scene_color = mix(bg_color, scene_color, k.x);\n    scene_color = mix(text_color, scene_color, k.y);\n\n    // Done!\n    fragColor = vec4(scene_color, 2.0);\n\t\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtcyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2087, 2087, 2136, 2136, 2211], [2285, 2285, 2309, 2309, 2430], [2432, 2432, 2456, 2456, 2576], [2578, 2578, 2602, 2602, 2726], [2800, 2800, 2833, 2863, 3516], [3590, 3590, 3622, 3622, 3659], [3733, 3733, 3764, 3764, 3816], [3890, 3890, 3987, 4068, 4947], [5021, 5021, 5264, 5318, 6870], [6944, 6944, 7188, 7188, 7544], [7618, 7618, 7642, 7665, 8205], [8279, 8279, 8298, 8298, 8415], [8489, 8489, 8522, 8522, 8785], [8859, 8859, 8899, 8899, 9270], [9344, 9344, 9374, 9397, 11629], [11703, 11703, 11766, 11766, 11955], [12029, 12029, 12061, 12061, 12909], [12983, 12983, 13038, 13038, 13331], [13405, 13405, 13456, 13456, 13991], [14067, 14067, 14124, 14124, 18575]], "test": "untested"}
{"id": "3lcyzH", "name": "Baisc : Twin Draong ; Fork", "author": "404Glaciergargamel", "description": "Remix of [url]https://www.shadertoy.com/view/MtXSWj[/url]", "tags": ["fractal", "remix", "glitch", "dragon", "curve", "fork", "error", "twindragon", "twin"], "likes": 1, "viewed": 575, "published": 3, "date": "1608442792", "time_retrieved": "2024-07-30T20:29:18.670841", "image_code": "//size of blocks = 1.\n\nfloat alternate(float p, float d){;\n\treturn sign(fract(p*d*.6)*3.-2.);\n}\n\nvec3 rainbow(float t){\n    return sin(t+vec3(0,.43,.76)*7.28)*.6+.6;\n}\n\nvec3 TwinDragon(vec2 p){\n    float time       = fract(iTime*0.06)*30.;\n    \n    //scaling\n    p = (p*2.-iResolution.xy)/iResolution.y*2.5;\n    \n    //----------the fractal stuff----   ---THIS IS ANIMATIONS----(so remove them if you want)\n    for (float i = 9.; i > 1.; i--) {\n        float scale = pow(3., i);\n        p.y += .6*alternate(p.x, scale)/scale * clamp(time/3.-i, 1., 2.);\n        p = mat2(1,2,-2,1)*p; // Rotate 90 degrees.\n    }\n\n    // prettifying\n    vec2  block  = ceil(p+.6);               //index for blocks from which the fractal is shifted\n    vec3  color  = rainbow(block.x*5.+block.y);  //rainbow palette using block index as t\n    float dis    = length(fract(p+.6)*3.-2.);//distance to middle of block\n          color *= .6+dis*.8;                    //using distance within block for some more pretty.\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 d = vec2(.6,1);\n    \n    //some antialiasing\n    vec3 col = (\n        TwinDragon(fragCoord+d.xy)+\n        TwinDragon(fragCoord-d.xy)+\n        TwinDragon(fragCoord+d.yx)+\n        TwinDragon(fragCoord-d.yx)\n    )*.35;\n    \n\tfragColor = vec4(col,2.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lcyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 57, 57, 95], [97, 97, 119, 119, 167], [169, 169, 193, 193, 1019], [1021, 1021, 1077, 1077, 1346]], "test": "untested"}
{"id": "3tcyzH", "name": "Blake ink Phighland, fork", "author": "404Glaciergargamel", "description": "Remix of FishMan's Lake in Highland: [url]https://www.shadertoy.com/view/4sdfz8[/url]", "tags": ["raymarching", "noise", "cloud", "water", "remix", "glitch", "fork", "terrian", "lake"], "likes": 2, "viewed": 915, "published": 3, "date": "1608442036", "time_retrieved": "2024-07-30T20:29:19.474692", "image_code": "// Hacked by 404Glaciergargamel!\n\nvec3 _BaseWaterColor = (vec3(32.,89.,96.)/355.);\nvec3 _LightWaterColor= (vec3(1.,314.,20.)/355.);\n\nconst float SC = 20.;\nfloat waterHeight = 200.;\nfloat waterTranDeep = 20.;\nvec3 lightDir = normalize( vec3(0.6,0.7,1.) );\nconst mat2 m2 = mat2( 0.70, -0.90, 0.90, 0.70 );\nconst mat3 m3 = mat3( 0.01,  0.90,  0.70,\n               -0.90,  0.46, -0.58,\n               -0.70, -0.58,  0.74 );\n\n\n// from iq\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n  \tf = f*f*(4.0-3.0*f);\n  \tvec2 uv = (p.xy+vec2(47.0,27.0)*p.z) + f.xy;\n  \tvec2 rg = textureLod( iChannel0, (uv+0.6)/356.0, 0.0).yx;\n  \treturn mix( rg.x, rg.y, f.z );\n}\n\n// ref https://www.shadertoy.com/view/Xs33Df\nfloat Noise3D(in vec3 p){\n    const vec3 s = vec3(8, 257, 213);\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(1., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; // Cell's fractional component.\n    p = p*p*(4. - 3.*p);\n    h = mix(fract(sin(h)*53758.5453), fract(sin(h + s.x)*53758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nfloat FBM( in vec3 p )\n{\n    float n = 0.1;\n    n += 0.60000*Noise( p*2.0 );\n    n += 0.35000*Noise( p*3.0 );\n    n += 0.22500*Noise( p*5.0 );\n    n += 0.07250*Noise( p*9.0 );\n    n += 0.04125*Noise( p*26.0 );\n    return n/1.084375;\n}\n//ref: https://www.shadertoy.com/view/Msdfz8\nvec3 Cloud(vec3 bgCol,vec3 ro,vec3 rd,vec3 cloudCol,float spd)\n{\n    vec3 col = bgCol;\n    float t = iTime * 0.25* spd;\n    vec2 sc = ro.xz + rd.xz*((4.)*50000.0-ro.y)/rd.y;\n    vec2 p = 0.00003*sc;\n    float f = 0.1;\n  \tfloat s = 0.6;\n  \tfloat sum =1.;\n  \tfor(int i=1;i<6;i++){\n    \tp += t;t *=2.5;\n    \tf += s*textureLod( iChannel0, p/356.0, 0.1).x; p = m2*p*3.02;\n    \tsum+= s;s*=0.7;\n  \t}\n    float val = f/sum; \n    col = mix( col, cloudCol, 0.6*smoothstep(0.6,0.9,val) );\n    return col;\n}\n\nfloat WaterMap( vec3 pos ) {\n    return FBM( vec3( pos.xz, iTime*0.4 )) * 2.;\n}\n\nvec3 WaterNormal(vec3 pos,float rz){\n    float EPSILON =rz*rz* 0.003;\n    vec3 dx = vec3( EPSILON, 1.,1. );\n    vec3 dz = vec3( 1.,1., EPSILON );\n      \n    vec3  normal = vec3( 1., 2., 1. );\n    float bumpfactor = 0.4 * pow(2.-clamp((rz)/2000.,1.,2.),7.);//\n    \n    normal.x = -bumpfactor * (WaterMap(pos + dx) - WaterMap(pos-dx) ) / (3. * EPSILON);\n    normal.z = -bumpfactor * (WaterMap(pos + dz) - WaterMap(pos-dz) ) / (3. * EPSILON);\n    return normalize( normal ); \n}\n\nvec3 RayMarchCloud(vec3 ro,vec3 rd){\n    vec3 col = vec3(0.1,0.1,0.1);  \n    float sundot = clamp(dot(rd,lightDir),0.1,2.0);\n    \n     // sky      \n    col = vec3(0.3,0.6,0.95)*2.1 - rd.y*rd.y*0.6;\n    col = mix( col, 0.95*vec3(0.8,0.85,0.95), pow( 2.0-max(rd.y,0.1), 5.0 ) );\n    // sun\n    col += 0.35*vec3(2.0,0.8,0.5)*pow( sundot,6.0 );\n    col += 0.35*vec3(2.0,0.9,0.7)*pow( sundot,74.0 );\n    col += 0.5*vec3(2.0,0.9,0.7)*pow( sundot,612.0 );\n    // clouds\n    col = Cloud(col,ro,rd,vec3(2.0,1.05,2.0),2.);\n            // .\n    col = mix( col, 0.78*vec3(0.5,0.75,2.0), pow( 2.0-max(rd.y,0.1), 26.0 ) );\n    return col;\n}\nfloat TerrainH( in vec2 x ) {\n    \n\tvec2  p = x*0.04/SC;\n    float a = 0.01;\n    float b = 0.6;\n\tvec2  d = vec2(0.1);\n    for( int i=1; i<10; i++ )\n    {\n        float n = Noise3D(vec3(p,0.1));\n        a += b*n;\n\t\tb *= 0.506;\n        p *=m2* 3.0;\n    }\n\treturn SC*40.0*a;\n}\n\n\n\nfloat InteresctTerrial( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n    for( int i=1; i<356; i++ ) \n    {\n        vec3 p = ro + t*rd;\n        float h = p.y - TerrainH( p.xz );\n        if( h<(0.003*t) || t>tmax ) break;\n        t += 1.0*h;\n    }\n    return t; \n}\n\nfloat SoftShadow(in vec3 ro, in vec3 rd )\n{\n    float res = 2.0;\n    float t = 0.002;\n    for( int i=1; i<90; i++ )\n    {\n        vec3  p = ro + t*rd;\n        float h = p.y - TerrainH( p.xz );\n        res = min( res, 26.0*h/t );\n        t += h;\n        if( res<0.002 ||p.y>(SC*30.0) ) break;\n    }\n    return clamp( res, 0.1, 2.0 );\n}\n\n\n\nvec3 CalcTerrianNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.003*t, 0.1 );\n    return normalize( vec3( TerrainH(pos.xz-eps.xy) - TerrainH(pos.xz+eps.xy),\n                            3.0*eps.x,\n                            TerrainH(pos.xz-eps.yx) - TerrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 RayMarchTerrial(vec3 ro,vec3 rd,float rz){\n    vec3 col = vec3(1.,1.,1.);\n    vec3 pos = ro + rz * rd;\n    vec3 nor = CalcTerrianNormal(pos,rz);\n\n    vec3 ref = reflect( rd, nor );\n    float fre = clamp( 2.0+dot(rd,nor), 0.1, 2.0 );\n    vec3 hal = normalize(lightDir-rd);\n\tcol = vec3(0.09,0.06,0.04);\n    // lighting     \n    float amb = clamp(0.6+0.6*nor.y,0.1,2.0);\n    float dif = clamp( dot( lightDir, nor ), 0.1, 2.0 );\n    float bac = clamp( 0.3 + 0.9*dot( normalize( vec3(-lightDir.x, 0.1, lightDir.z ) ), nor ), 0.1, 2.0 );\n\n    //shadow\n    float sh = 2.0; \n  \n    vec3 lin  = vec3(0.1,0.1,0.1);\n    lin += dif*vec3(8.00,6.00,4.00)*2.3;\n    lin += amb*vec3(0.50,0.70,2.00)*2.2;\n    lin += bac*vec3(0.50,0.60,0.70);\n    col *= lin;\n  \n    // fog\n    float fo = 1.2-exp(-pow(0.002*rz/SC,2.5));\n    vec3 fco = 0.75*vec3(0.5,0.75,2.0);// + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n    col = mix( col, fco, fo );\n  return col;\n}\n\n#define mouse (iMouse.xy / iResolution.xy)\nvec3 InitCam(in vec2 fragCoord ){\n    float time = iTime;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  \tvec2 p = fragCoord.xy/iResolution.xy-0.6;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy-.6;\n    mo = (mo==vec2(-.6))?mo=vec2(-1,-0.04):mo;\n\tmo.x *= iResolution.x/iResolution.y * 4.14159;\n\t\n\n    mo.x += smoothstep(0.7,2.,0.6+0.6)-2.5;\n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*3.-0.3+sin(2.57)*0.2,sin(mo.x)));\n    vec3 rightdir = normalize(vec3(cos(mo.x+2.5708),1.,sin(mo.x+2.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*2.+eyedir);\n\treturn rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxT = 20000.;\n    float minT = 0.2;\n    vec3 col  = vec3 (1.,1.,1.);\n    float waterT = maxT;\n    \n    vec3 ro = vec3(-89.,204., -5.0);\n\tvec3 rd = InitCam(fragCoord);\n\t\n    if(rd.y <-0.02){\n      \tfloat t = -(ro.y - waterHeight)/rd.y;\n      \twaterT = min(waterT,t);\n    }\n    float sundot = clamp(dot(rd,lightDir),0.1,2.0);\n\n    float rz = InteresctTerrial(ro,rd,minT,maxT);\n    float fresnel = 1.;\n    vec3 refractCol = vec3(1.,1.,1.);\n    bool reflected = false;\n    \n    // hit the water\n    if(rz >= waterT && rd.y < -0.02){\n        vec3 waterPos = ro + rd * waterT; \n        vec3 nor = WaterNormal(waterPos,waterT);\n        float ndotr = dot(nor,-rd);\n        fresnel = pow(2.0-abs(ndotr),7.);\n        float diff = pow(dot(nor,lightDir) * 0.5 + 0.7,4.);\n        // get the water col \n        vec3 waterCol = _BaseWaterColor + diff * _LightWaterColor * 0.22; \n        float transPer = pow(2.0-clamp( rz - waterT,1.,waterTranDeep)/waterTranDeep,4.);\n        vec3 bgCol = RayMarchTerrial(ro,rd + nor* clamp(2.-dot(rd,-nor),1.,2.),rz);\n        refractCol = mix(waterCol,bgCol,transPer);\n\t\t//reset the reflect dir and position\n        ro = waterPos;\n        rd = reflect( rd, nor);\n        rz = InteresctTerrial(ro,rd,minT,maxT);\n        reflected = true;\n        col = refractCol;\n    }\n    if(rz >= maxT){\n        col = RayMarchCloud( ro, rd);\n    }else{\n        col = RayMarchTerrial(ro,rd,rz);\n    }\n    if( reflected == true ) {\n        col = mix(refractCol,col,fresnel);\n        float spec=  pow(max(dot(rd,lightDir),0.1),228.) * 4.;\n        col += vec3(spec,spec,spec);\n    }\n    \n    fragColor = vec4(col,2.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tcyzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 433, 459, 459, 674], [676, 721, 746, 746, 1111], [1113, 1113, 1137, 1137, 1347], [1348, 1393, 1457, 1457, 1888], [1890, 1890, 1918, 1918, 1969], [1971, 1971, 2007, 2007, 2445], [2447, 2447, 2483, 2483, 3073], [3074, 3074, 3103, 3103, 3347], [3351, 3351, 3431, 3431, 3645], [3647, 3647, 3690, 3690, 3981], [3985, 3985, 4033, 4033, 4274], [4276, 4276, 4323, 4323, 5214], [5259, 5259, 5292, 5292, 5952], [5954, 5954, 6011, 6011, 7643]], "test": "untested"}
{"id": "3l3yRH", "name": "edge detection whatever", "author": "mds2", "description": "some crap I was trying out", "tags": ["experiment", "edge", "etc"], "likes": 2, "viewed": 413, "published": 3, "date": "1608429696", "time_retrieved": "2024-07-30T20:29:20.359326", "image_code": "const float EDGE_OR_CORNER_DETECT = 0.95; // 0 for corner, 1 for edge\n\nconst float WINDOW_WIDTH = 6.0; // max 6.0\n\nconst float SHOW_BACKGROUND = 0.75; // 0.0 for no background, 1.0 for all background\n\nconst vec2 webcam_resolution = 2.0 * vec2(320.0, 240.0);\n\nvec3 YUV(in vec2 fragCoord) {\n    const mat3 to_yuvish = mat3(0.299, -0.14713, 0.615,\n                          0.587, -0.28886, -0.51499,\n                          0.114, 0.436, -0.10001);\n    return to_yuvish * texture(iChannel0, fragCoord / iResolution.xy).rgb;\n}\n\nfloat Yval(in vec2 fragCoord) {\n    return YUV(fragCoord).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    mat2 M = mat2(0.0);\n    \n    vec2 scale = iResolution.xy / min(iResolution.xy, webcam_resolution.xy);\n    \n    vec2 off = vec2(-7.0);\n    for (int i = 0; i < 13; ++i) {\n        off.y = -7.0;\n        off.x += 1.0;\n        for (int j = 0; j < 13; ++j) {\n            off.y += 1.0;\n            \n            float weight = smoothstep(WINDOW_WIDTH, 0.0, length(off));\n    \n\t    \tfloat Ix = 0.5 * (Yval(fragCoord + scale * (off + vec2(1.0, 0.0))) - \n            \t              Yval(fragCoord + scale * (off - vec2(1.0, 0.0))));\n    \t\tfloat Iy = 0.5 * (Yval(fragCoord + scale * (off + vec2(0.0, 1.0))) - \n            \t              Yval(fragCoord + scale * (off - vec2(0.0, 1.0))));\n        \n         \tM += weight * mat2(Ix * Ix, Ix * Iy, Ix * Iy, Iy * Iy);\n        }\n    }\n\n//    mat2 M = mat2(Ix * Ix, Ix * Iy, Ix * Iy, Iy * Iy);\n    \n    float A = 1.0;\n    float B = -M[0][0] - M[1][1];\n    float C = M[0][0] * M[1][1] - M[0][1] * M[1][0];\n\n    float l1 = (-B + sqrt(B * B - 4.0 * A * C)) / (2.0 * A);\n    float l2 = (-B - sqrt(B * B - 4.0 * A * C)) / (2.0 * A);\n    \n    float min_eig = min(abs(l1), abs(l2));\n    float max_eig = max(abs(l1), abs(l2));\n//\tfloat min_eig = min(l1, l2);\n    \n    float eig_to_use = mix(min_eig, max_eig, EDGE_OR_CORNER_DETECT);\n\n    // Time varying pixel color\n    vec3 col = smoothstep(vec3(0.0), vec3(0.1, 0.2, 0.3), vec3(eig_to_use));\n    vec3 raw_color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    \n    vec3 cent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n                     \n    vec3 delta = raw_color - cent;\n    \n    vec3 grayed_delta = raw_color * dot(raw_color, delta) / dot(raw_color, raw_color);\n    \n    vec3 adj = grayed_delta - delta;\n    \n    delta *= (1.0 + 20.0 * step(0.05, length(col)));\n    delta += adj;\n    \n    vec3 maxes = (step(vec3(0.0), delta) - col)/delta;\n    \n    float amount = min(maxes.x, min(maxes.y, maxes.z));\n    \n    raw_color = cent + delta * min(1.0, amount);\n\n    // Output to screen\n    fragColor = vec4(raw_color,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[259, 259, 288, 288, 525], [527, 527, 558, 558, 589], [591, 591, 648, 698, 2796]], "test": "untested"}
{"id": "WlccR8", "name": "Wythoff Polyhedra with Exact SDF", "author": "mla", "description": "Exact SDF for Wythoff construction so rounding etc. works. ", "tags": ["rounding", "wythoff", "polyhdedron"], "likes": 17, "viewed": 509, "published": 3, "date": "1608420055", "time_retrieved": "2024-07-30T20:29:21.132260", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Wythoff construction for convex polyhedra, with an exact SDF.\n// Matthew Arcus, mla, 2020\n//\n// https://en.wikipedia.org/wiki/Wythoff_construction\n//\n// Controls:\n// Mouse changes orientation\n// 1-3: only show faces 1-3\n// c: no colouring\n// e: show edges\n// m: mirror faces\n// r: rotation\n// t: texturing\n//\n// Uses exact distance to triangular faces (or subdivisions of faces) \n// rather than distance to face planes, enabling, eg. SDF rounding\n// to work.\n//\n// Snubs can be done in the same way, but omitted here as this\n// considerably complicates the code.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Any P,Q,R with 1/P + 1/Q + 1/R > 1, which means:\n// 2:2:2, 3:2:2, 4:2:2, ...\n// 3:3:2, 4:3:2, 5:3:2\n\nfloat P = 5.0, Q = 3.0, R = 2.0;\nfloat roundness = 0.25;\n\n// Trilinear coordinates of vertex point (ie. proportional distance\n// from sides of fundamental region).\nvec3 trilinear = vec3(1,1,1);\n\n// Number of iterations of folding loop\n// 5 iterations is enough to get up to (5 3 2) or (10 2 2)\nint NFOLDS = 5;\n\n// Types of feature\nint FACE0 = 1;\nint FACE1 = 2;\nint FACE2 = 3;\nint EDGE = 4;\nint VERTEX = 5;\n\n// 3 mirror planes (passing through origin) define a fundamental\n// region, which intersects the unit sphere in a spherical\n// triangle with angles PI/P, PI/Q, PI/R.\n// The normal polyhedron has a vertex in the fundamental region,\n// edges from the vertex perpendicular to the mirror planes, and\n// faces perpendicular to the lines of intersection of the mirror\n// planes.\n// The dual polyhedron has faces perpendicular to the vector to\n// the region vertex, and vertices on the mirror plane intersections.\n\nvec3 A,B,C;    // normal vectors for mirror planes\nvec3 vertex;   // the vertex point & face centre of dual\n\nvoid initgeometry() {\n  // Setup folding planes\n  float p = PI/P, q = PI/Q, r = PI/R;\n  // |A| = |B| = |C| = 1\n  // A.B = -cos(p)\n  // A.C = -cos(r)\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  // It's more convenient to make A,B,C point _out_ of\n  // the fundamental region (away from the region vertex)\n  A = vec3(-1,0,0);\n  B = vec3(cos(r),-sin(r),0);\n  float x = cos(p);\n  float y = (cos(r)*cos(p)+cos(q))/sin(r);\n  float z = -sqrt(1.0-x*x-y*y);\n  C = vec3(x,y,z);\n\n  // Convert trilinear to cartesian coordinates\n  vertex = normalize(mat3(cross(B,C),cross(C,A),cross(A,B))*trilinear);\n}\n\n// Distance of p from ray in direction dir from origin\n// dir assumed normalized\nfloat ray(vec3 p, vec3 dir) {\n  float h = dot(p,dir);\n  h = max(0.0,h);\n  return length(p - h*dir);\n}\n\n// Exact distance from polyhedron faces and edges\nvec2 faces(vec3 pos, out int t, out vec2 uv) {\n  // Planes thrugh vertex, edge and centre\n  vec3 a = cross(vertex,A), b = cross(vertex,B), c = cross(vertex,C);\n  vec3 e,f;\n  // Find which sector we are in & select bounding edges accordingly\n  if (dot(pos,a) > 0.0 && dot(pos,b) <= 0.0) t = FACE0;\n  else if (dot(pos,b) > 0.0 && dot(pos,c) <= 0.0) t = FACE1;\n  else t = FACE2;\n  if (key(CHAR_0+1)) t = FACE0;\n  else if (key(CHAR_0+2)) t = FACE1;\n  else if (key(CHAR_0+3)) t = FACE2;\n  if (t == FACE0) { e = A; f = B; }\n  else if (t == FACE1) { e = B; f = C; }\n  else { e = C; f = A; }\n  vec3 n = cross(e,f);\n  vec3 p = pos - vertex; // Vertex centred coordinates\n  uv = p.xy;//+p.yz;\n  // Get distances from edges\n  float edgedist = min(ray(p,e),ray(p,f));\n  bool onedge = dot(cross(e,n),p) > 0.0 || dot(cross(f,n),p) < 0.0;\n  float facedist = onedge ? edgedist : length(n*dot(n,p)/dot(n,n));\n  if (key(CHAR_E) && onedge) t = EDGE;\n  return vec2(facedist,edgedist);\n}\n\nfloat scene(vec3 pos, out int type, out vec2 uv) {\n  vec2 t = faces(pos,type,uv);\n  float facedist = t.x;\n  float edgedist = t.y;\n  return mix(facedist,edgedist,0.0)-roundness;\n}\nvec3 fold(vec3 pos) {\n  int parity = 0;\n  if (key(CHAR_F)) return pos;\n  for (int i = 0; i < NFOLDS; i++) {\n    float k;\n    k = dot(pos,A);\n    parity += int(k > 0.0);\n    pos -= 2.0*max(0.0,k)*A;\n    k = dot(pos,B);\n    parity += int(k > 0.0);\n    pos -= 2.0*max(0.0,k)*B;\n    k = dot(pos,C);\n    parity += int(k > 0.0);\n    pos -= 2.0*max(0.0,k)*C;\n  }\n  return pos;\n}\n\nvec3 fold0(vec3 pos) {\n  if (key(CHAR_F)) return pos;\n  pos.xy = abs(pos.xy);\n  pos -= 2.0*max(0.0,dot(pos,C))*C;\n  pos.xy = abs(pos.xy);\n  pos -= 2.0*max(0.0,dot(pos,C))*C;\n  pos.xy = abs(pos.xy);\n  pos -= 2.0*max(0.0,dot(pos,C))*C;\n  pos.xy = abs(pos.xy);\n  pos -= 2.0*max(0.0,dot(pos,C))*C;\n  pos.xy = abs(pos.xy);\n  pos -= 2.0*max(0.0,dot(pos,C))*C;\n  pos.xy = abs(pos.xy);\n  return pos;\n}\n\nfloat map(vec3 pos, out int type, out vec2 uv) {\n  pos = fold(pos);\n  return scene(pos,type,uv);\n}\n\nfloat map(vec3 pos) {\n  int type; vec2 uv;\n  return map(pos,type,uv);\n}\n\n// Tetrahedron technique, from:\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) {\n  float h = 0.0001;\n  vec2 k = vec2(1,-1);\n  return normalize( k.xyy*map( p + k.xyy*h ) + \n                    k.yyx*map( p + k.yyx*h ) + \n                    k.yxy*map( p + k.yxy*h ) + \n                    k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 5.0;\n  const float precis = 0.01;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 200; i++) {\n    //assert(i < 30);\n    if (t > maxd) return -1.0;\n    float h = map(ro+rd*t);\n    t += h;\n    if (h < precis) return t;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    //p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvec3 circuit[] = vec3[]\n  (vec3(1,1,1),vec3(1,1,1),vec3(1,0,0),vec3(1,0,0),\n   vec3(1,1,0),vec3(1,1,0),vec3(0,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,1,1),vec3(0,0,1),vec3(0,0,1),\n   vec3(1,0,1),vec3(1,0,1),vec3(1,0,0),vec3(1,0,0),\n\n   vec3(1,1,1),vec3(1,1,0),vec3(1,1,1),vec3(0,1,0),\n   vec3(1,1,1),vec3(0,1,1),vec3(1,1,1),vec3(0,0,1),\n   vec3(1,1,1),vec3(1,0,1),\n\n   vec3(1,1,1),vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,0,1),vec3(1,0,1),vec3(1,0,0));\n\nconst int nsteps = circuit.length();\n\nvec3 gettrilinear(float t) {\n  int i = int(floor(t))%nsteps;\n  return mix(circuit[i],circuit[(i+1)%nsteps],mod(t,1.0));\n}\n\nvec3 basecolor(int type) {\n  if (type == FACE0) return vec3(1,0,0);\n  if (type == FACE1) return vec3(1,1,0);\n  if (type == FACE2) return vec3(0,0,1);\n  if (type == EDGE) return vec3(0.2);\n  if (type == VERTEX) return vec3(0.1);\n  return vec3(1,0,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n  vec3 ro = vec3(0,0,3);\n  vec3 rd = vec3(z,-2);\n  vec3 light = vec3(0.5, 0.8, 3.0);\n  ro = transform(ro);\n  rd = transform(rd);\n  light = transform(light);\n  light = normalize(light);\n  rd = normalize(rd);\n  trilinear = gettrilinear(0.5*iTime);\n  initgeometry();\n  vec3 col = texture(iChannel0,rd).xyz;\n  col = pow(col,vec3(2.2));\n  float t = march(ro, rd);\n  if (t > 0.0 && t < 1e8) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    int type; vec2 uv;\n    map(pos,type,uv); // Get type and uv\n    col = basecolor(type);\n    if (key(CHAR_C) && type != EDGE) col = vec3(1);\n    if (key(CHAR_M)) {\n      col = texture(iChannel0,reflect(rd,n)).xyz;\n    } else {\n      if (!key(CHAR_T)) col *= texture(iChannel1,uv).xyz;\n      float diffuse = clamp(dot(n, light), 0.0, 1.0);\n      col *= 0.2 + 0.8*diffuse;\n      float specular = pow(max(0.0,dot(reflect(light,n),rd)),10.0);\n      col += 0.3*specular*vec3(1);\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90; // rotation\n\nconst float PI\t= 3.14159265359;\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\n// Approximate equality. Used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat edgedistance(vec3 pos, vec3 X) {\n  return length(pos-dot(pos,X)*X);\n}\n\n// Perpendicular distance from p to segment ab\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat min3(float a, float b, float c) {\n  return min(a,min(b,c));\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Function by iq: https://www.shadertoy.com/view/ttfGWl\nvec3 closestTriangle(vec3 p, vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross(v10,v02);\n\n    // method 1, in 3D space\n    if( dot(cross(v10,nor),p0)<0.0 ) return v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    if( dot(cross(v21,nor),p1)<0.0 ) return v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    if( dot(cross(v02,nor),p2)<0.0 ) return v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    return p - nor*dot(nor,p0)/dot2(nor);\n}\n\nfloat triangleDistance(vec3 p, vec3 v0, vec3 v1, vec3 v2) {\n  return distance(p,closestTriangle(p,v0,v1,v2));\n}\n\n// Function by iq: https://www.shadertoy.com/view/ttfGWl\n// Triangle extends to infinity\nvec3 closestTriangle2(vec3 p, vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    //vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross(v10,v02);\n\n    // method 1, in 3D space\n    if( dot(cross(v10,nor),p0)<0.0 ) return v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    //if( dot(cross(v21,nor),p1)<0.0 ) return v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    if( dot(cross(v02,nor),p2)<0.0 ) return v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    return p - nor*dot(nor,p0)/dot2(nor);\n}\n\nfloat triangleDistance2(vec3 p, vec3 v0, vec3 v1, vec3 v2) {\n  return length(p-closestTriangle2(p,v0,v1,v2));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlccR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1863, 1863, 1884, 1910, 2456], [2458, 2539, 2568, 2568, 2640], [2642, 2692, 2738, 2781, 3658], [3660, 3660, 3710, 3710, 3838], [3839, 3839, 3860, 3860, 4210], [4212, 4212, 4234, 4234, 4605], [4607, 4607, 4655, 4655, 4705], [4707, 4707, 4728, 4728, 4778], [4780, 4858, 4883, 4883, 5120], [5122, 5122, 5159, 5159, 5426], [5428, 5428, 5455, 5455, 5790], [6302, 6302, 6330, 6330, 6423], [6425, 6425, 6451, 6451, 6676], [6678, 6678, 6735, 6735, 7819]], "test": "untested"}
{"id": "wtdyRr", "name": "Day 366 [ One Year ]", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 10, "viewed": 497, "published": 3, "date": "1608415987", "time_retrieved": "2024-07-30T20:29:22.107652", "image_code": "#define v2Resolution (iResolution.xy)\n#define T iTime\n#define dmin(a,b) a.x < b.x ? a : b\n\n#define planetSz 20.\n#define pi acos(-1.)\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\n// From https://github.com/armory3d/armory/blob/master/Shaders/std/tonemap.glsl\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nvec2 ouv = vec2(0);\n  \nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n  vec3 dir = normalize(lookAt - ro);\n  vec3 right = normalize(cross(vec3(0,1,0),dir));\n  vec3 up = normalize(cross(dir,right));\n  return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat valueNoise(vec3 uv,float pw){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    fd = pow(fd,vec3(pw));\n    \n    float ibl = hash13(id + vec3(0,-1,0));\n    float ibr = hash13(id + vec3(1,-1,0));\n    float itl = hash13(id + vec3(0));\n    float itr = hash13(id + vec3(1,0,0));\n    \n    \n    float jbl = hash13(id + vec3(0,-1,1));\n    float jbr = hash13(id + vec3(1,-1,1));\n    float jtl = hash13(id + vec3(0,0, 1));\n    float jtr = hash13(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n\nfloat fa, fb, fc, fd;\n\nfloat fbm(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.25;\n    p.y += T*0.01;\n    fa = valueNoise(p,4.); \n    \n    p.y += fa*(1. + sin(op.z)*.8);\n    \n    fb = valueNoise(p*2.,1.);\n    \n    \n    fd = valueNoise(p*29.8,1.);\n    \n    fc = valueNoise(p*4.2,1.);\n    \n    \n\n    n = fa*1. + fb*0.55 + fc*0.244 + fd*0.046*(0. - fa) /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    n -= pow(\n      smoothstep( \n        0.,\n        1.,\n        valueNoise(p*0.1 + fb*0.05,3.)*1.5\n        )\n      ,2.2\n      )\n      *8.;\n  \n    n*= 0.6;\n\n\treturn n;\n}\n\n\nfloat sdCraters(vec3 _p, float md, float s){\n  vec4 p = vec4(_p,1.);\n  p.yw *= rot(0.4);\n  p = abs(p);\n  p.xz *= rot(0.4);\n  p = abs(p);\n  \n  p.xy *= rot(2.4);\n  p = abs(p);\n  \n  p.yz *= rot(.2);\n  p = pmod(p,md);\n  return length(p) - s;\n}\n\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\n  #define pump(x,a) (floor(x) + pow(fract(x),a))\n\nfloat sdCube (vec4 p, vec4 s){p = abs(p) - s; return max(p.x, max(p.y, max(p.z, p.w)));}\nfloat sdCube (vec3 p, vec3 s){p = abs(p) - s; return max(p.x, max(p.y, p.z));}\nfloat sdPlane(vec3 p){\n    float d = 10e6;\n    \n    float s = 0.4;\n    \n    p /= s;\n    vec4 pp = vec4(p,1);\n    \n    d = sdCube(p,vec3(0.31));\n\n    for(int i = 0; i < 2; i++){\n            \n        float pmp = pump(T*0.2,4.);\n        pp.wz *= rot((0.25 + pmp*0.25 )*pi);\n        \n        pp.yz *= rot((0.25)*pi);\n        pp.xw *= rot((0.25 - pmp*0.5)*pi);\n        pp = abs(pp) - 0.1 ;\n        vec4 ppq = pp;\n        float doth = sdCube(ppq,vec4(0.922));\n        d = xor(d,doth,0.24);\n    }\n\n    d *= s;\n    \n    return d;\n}\n\nvec2 map(vec3 p){\n  vec2 d = vec2(10e5);\n  \n  vec3 pp = p;\n  \n  pp.y -= planetSz + 0.1;\n  \n  pp.y += sin(T)*0.01;\n  \n  #define tilt(x) sin(x + cos(x*0.4) - sin(x*0.2))\n  float tilt = tilt(T); \n  pp.x += tilt(T)*.5;\n  \n  \n  pp.z -= 3. + sin(pump(T*0.3,2.)*pi + pi/2.) + sin(T)*0.2;\n  \n  \n  float dTilt = (tilt(T + 0.1) - tilt(T + 0.))/0.1; \n  \n  pp.xy *= rot( -dTilt*0.2);\n  //pp *= rot();\n  float plane = sdPlane(pp);\n  \n  d = dmin(d,vec2(plane, 2.));\n  \n  \n  p.x += sin(T*0.2);\n  \n  p.yz *= rot((T*0.04));\n  \n  //p.z += sin(T*0.2)*2.;\n  float planet = length(p) - planetSz;\n  \n  \n  float craters = sdCraters(p + vec3(.4,0.3,0.4), 3., 1.1);\n  float cratersb = sdCraters(p + +vec3(1.4,0.3,0.4), 2.4,0.21);\n  float cratersc = sdCraters(p*10., 6.4,0.06)/10.;\n  \n  \n  planet = opSmoothSubtraction( -planet, -craters, 0.24);\n  planet = opSmoothSubtraction( -planet, -cratersb, 0.34);\n  planet = opSmoothSubtraction( -planet, -cratersc, 0.15);\n  planet -= fbm(p*10.1)*.06;\n  d = dmin(d,vec2(planet, 1.));\n  \n  \n  \n  \n  //d = dmin(d,vec2(craters, 1.));\n  \n  \n  \n  d.x *= 0.45;\n  return d;\n}\n\n\n//#define shortCompile min(iResolution.x,0.)\n#define shortCompile 0.\nvec3 getNormal(vec3 p){\n  vec2 t = vec2(0.03,0.);\n  return normalize(map(p).x - vec3(\n    map(p - t.xyy).x,\n    map(p - t.yxy).x,\n    map(p - t.yyx).x\n  ));\n  }\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt + shortCompile; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}  \n  \nvoid mainImage(out vec4 C,in vec2 U)\n{\n\n  vec2 uv = vec2(U.x / iResolution.x, U.y / iResolution.y);\n  vec2 camOffs = vec2(sin(T*0.3),cos(T*0.5))*0.06;\n  uv += camOffs + vec2(iMouse.xy/iResolution.y)*0.04 - 0.02;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  ouv = uv;\n  vec3 col = vec3(0);\n\n  vec3 ro = vec3(0);\n  //ro.z -= 2.;\n  \n  ro.y += planetSz + 1.5;\n  \n  //ro.x += sin(T*0.2);\n  \n  //ro.yz *= rot(T*0.2);\n  \n  //ro.z += sin(T*0.2)*2.;\n  vec3 lookAt = ro + vec3(0,-0.5,1);\n  \n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  //rd.xy *= rot(-0.05);\n  float rdmod = sin(T*0.2)*0.125*pi/4.;\n  \n  //rd.yz *= rot( rdmod );\n  \n  vec3 p = ro;\n  bool hit = false;\n  \n  float iters = 200.;\n  float t = 0.;\n  vec2 d;\n  for(float i =0.; i < iters+ shortCompile; i++){\n    d = map(p);\n    \n      \n    if(d.x < 0.005 ){\n      hit = true;\n      break;\n    } else if(t > 15.){\n      break;\n    }\n    \n  \n    //p = ro + rd * (t += d.x) *max(1.,4.*i/iters);\n    p = ro + rd * (t += d.x)*max(1.,1.*i/iters);\n  \n  }\n  \n  vec3 fp = ro;\n  vec3 accumFog = vec3(0);\n  for(float i =0.; i < 16.+ shortCompile; i++){\n    float f = valueNoise(fp*.08 - T - fa*0.0,1.);\n    accumFog += f;\n    if(map(p).x < 0.0 ){\n      break;\n    } \n    fp += rd * 4.8;\n  }\n  vec3 lDir = normalize(vec3(0.8,-0.3,1.5));\n  vec3 lCol = vec3(1.4,0.4,0.41)*1.;\n  \n  \n  vec3 fogCol = vec3(0.4,0.2,0.15)*1.5;\n  \n  // darken fog\n  fogCol = mix(fogCol*vec3(1.,0.8,0.9)*0.1,fogCol,smoothstep(0.,1.,(length(p) - planetSz + 2.)*0.2+ t*0.16) );\n  if (hit){\n    vec3 n = getNormal(p);\n    vec3 hf = reflect(-lDir,n);\n    float diff = max(dot(n,lDir),0.);\n    float spec = pow(max(dot(-rd,hf),0.),32.);\n    float fres = pow(1. - max(dot(rd,-n),0.),5.);\n    \n    vec3 albedo = vec3(1,0.3,0.04)*0.4;\n    vec3 rockCol = vec3(0.2,0.4,0.34)*0.15;\n    albedo = mix(albedo, rockCol,pow(smoothstep(0.,1.,fb*fa), 2.));\n    \n    \n    if(d.y == 1.){\n        col += albedo + (spec*0.04  + fres*0.4) *( fogCol + lCol);\n    } else {\n        albedo = vec3(0.1,0.1,0.1);\n        col += albedo + (spec*0.74  + fres*0.9) *( fogCol + lCol);\n    }\n    \n    #define ao(a) smoothstep(0.,1.,map(p + n*a).x/a)\n    \n    float aoFact = ao(0.8)*ao(1.1)*ao(5.1)*3. + 0.575;\n    col *= aoFact;\n    \n    col *= mix(1.,softshadow( p, reflect(rd,n), 0.1, 5.,1.)*4.,0.6);\n    \n    col *= diff + lCol*0. + fogCol*0.25;\n  }\n  \n\n  col = mix(col,fogCol, smoothstep(0.,1.,t*(0.1  +accumFog/16.*0.2) - 0.51));\n\n  vec3 atmoCol = vec3(0.5,0.9,0.9);\n  //col += accumFog/16.*fogCol;\n  uv.y -= 0.3;\n  uv *= 1. - dot(uv,uv)*0.6;\n  uv.y += 0.3;\n  //vec3 atmoUpperCol = mix(vec3(0.5,0.6,0.9)*0.1,vec3(0.5,0.6,0.2)*1.4,smoothstep(0.,1.,(uv.y - 0.2)*2.));\n  vec3 atmoUpperCol = mix(vec3(0.5,0.6,0.9)*0.1,vec3(0.5,0.6,0.9)*0.1,smoothstep(0.,1.,(uv.y - 0.2)*2.));\n  \n\n  float sunModulator = sin(T + cos(T));\n    \n  float sunr = 0.998;\n\n  //rd.xz*=rot(sin(T*0.2)*0.02);\n  float sun = smoothstep(sunr,sunr*1.004,dot(lDir,rd));\n    //sun = 1. - sun;\n  vec3 sunCol = mix(lCol,lCol*vec3(1,1,0.4),1.-sun);  \n\n  vec3 sunColToAdd = sun*sunCol*3.*(2. + 2.*(1.-sunModulator) );\n\n  sunr = 0.921;\n\n  sun = smoothstep(sunr,sunr*4.,dot(lDir,rd));\n  sunColToAdd  += sun*sunCol*(52. + 17.*sunModulator*(4. + atmoCol));\n\n  vec2 sunPosUV = vec2(0.545,0.27);\n\n  sunColToAdd  += smoothstep(sunr,sunr*8.,dot(lDir,rd))*sunCol*12.;\n\n  vec2 suv = ouv - sunPosUV;\n\n  suv = abs(suv);\n\n  vec3 sunRays = 0.4*sunCol * smoothstep(0.035*(1. + smoothstep(1.,0.,abs(suv.x)) ) ,0.,abs(suv.y))*smoothstep(0.5,0.,abs(suv.x));\n    \n  for(float i = 0.; i < 24.; i++){\n      suv *= rot(pi/24.);\n      sunRays += .1* (sunCol) * smoothstep(0.04 + sin(i*4.)*0.01,0.,abs(suv.y))*smoothstep(0.2 + sin(i*8.)*0.1,0.,abs(suv.x));\n  }   \n  suv = ouv;\n  \n  suv -= sunPosUV;\n  \n  vec3 flares = vec3(0);\n  vec2 toMid = sunPosUV - camOffs*1.5;\n  vec2 dirToMid = -normalize(toMid);\n  float lenToMid = length(toMid);\n  \n  for(float i = 0.; i < 12.; i++){\n      suv -= 2.*lenToMid*dirToMid/12.;\n      float dfl = length(suv) - (0.1 + 0.1*sin(i*5.))*0.5;\n      dfl *= 0.5;\n      vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n      flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(ouv.x)));\n      flares += flare*abs(sin(i*10.));\n  }   \n  \n  \n  \n  if (!hit){\n    \n    rd.yz *= rot(0.5*pi);\n    vec3 pC = vec3(length(rd), atan(rd.y,rd.x),0);\n    pC.z = acos(rd.z/pC.x);\n    \n    rd.yz *= rot(-0.5*pi);\n    \n    pC.yz*=rot(sin(T*0.2)*0.02);\n    \n    vec3 stars = vec3(0);\n    \n    float pw = 110.;\n    stars += pow(valueNoise(pC*72.,1.),pw);\n    stars += pow(valueNoise((pC + 4.)*102.,1.),pw); \n    stars += pow(valueNoise((pC + 14.)*102.,1.),pw);\n    stars += pow(valueNoise((pC + 12.)*102.,1.),pw);    \n    // stars += pow(valueNoise((pC + 4.)*12.,1.),1.1);    \n    \n    \n    float vn = valueNoise(uv.xyy + T,1.)*0.3;\n    \n    float ma = smoothstep(0.,1.,((uv.y)*1.9  + 0.07 - vn ));\n    float mab = smoothstep(0.,1.,((uv.y)*4.2 - 0.3   ));\n    \n    fogCol *= 1. + sin(uv.xyx + T)*0.1;\n    atmoCol *= 1. + sin(ouv.xyx + T)*0.1;\n    \n    \n    col = mix(fogCol,mix(atmoCol,stars + atmoUpperCol,mab),ma);\n      \n    //col = mix(col,(fogCol + lCol)*0.5 + fogCol*lCol , 1.*smoothstep(0.,1.,(uv.x*1.3 + 0.4)*(1.2 - ma)));\n     \n          \n    \n    //col += fract(pC.yxz*10.);\n    \n\n      \n  }\n  col += sunRays*smoothstep(sunr,sunr*1.004,dot(lDir,rd));\n\n  col += sunColToAdd;\n  col += flares;\n  \n  // lighrays\n  \n\n  col += texture(iChannel1,U/iResolution.xy).xyz*1.*(fogCol);\n  // gamma correction\n  //col = mix(col,smoothstep(0.,1.,col*1.),0.6);\n\n  col = mix(col,acesFilm(col),0.5);\n  col = pow(max(col,0.),vec3(0.454545));  col *= 1. - dot(ouv,ouv*0.2)*3.;\n  C = vec4(col,1.);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Lens Dir\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n  vec2 uv = vec2(U / iResolution.y);\n  \n  vec3 sunCol = vec3(1);\n  \n  if(iFrame < 10){\n      for(float i = 0.; i < 42.; i++){\n          vec2 pos = hash33(vec3(i)).xy*vec2(iResolution.xy / iResolution.y);\n          float dfl = length(uv - pos) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.03,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.04,0.,abs(dfl - dFdx(uv.x)));\n          C += flare.xyzz*abs(sin(i*10.));\n      }\n  } else {\n    \n      C = texture(iChannel0,U/iResolution.xy);\n  }\n  \n  \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtdyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 308, 337, 337, 541], [567, 567, 609, 609, 787], [789, 789, 811, 811, 936], [938, 938, 960, 960, 1067], [1069, 1069, 1104, 1104, 1845], [1847, 1847, 1899, 1899, 1998], [2000, 2000, 2058, 2058, 2158], [2160, 2160, 2219, 2219, 2318], [2345, 2345, 2363, 2363, 2895], [2898, 2898, 2942, 2942, 3137], [3243, 3243, 3273, 3273, 3331], [3332, 3332, 3362, 3362, 3410], [3411, 3411, 3433, 3433, 3934], [3936, 3936, 3953, 3953, 5019], [5091, 5091, 5114, 5114, 5251], [5253, 5253, 5330, 5330, 5560], [5566, 5566, 5604, 5604, 11210]], "test": "untested"}
{"id": "wltyRr", "name": "Julia set explorer", "author": "darkeclipz", "description": "Explore the Julia set by moving the mouse over the Mandebrot set, and see which Julia sets correspond to which point in the Mandelbrot set.\n\nIf the mouse is not used, the point moves along the main cardioid.", "tags": ["2d", "fractal", "julia", "mandelbrot", "explore"], "likes": 11, "viewed": 608, "published": 3, "date": "1608404746", "time_retrieved": "2024-07-30T20:29:22.925466", "image_code": "// http://cosinekitty.com/mandel_orbits_analysis.html\n// main cardioid is c = e^{iθ}/2 − e^{2iθ}/4\n\n#define R iResolution.xy\n#define C fragCoord\n#define T iTime\n#define M iMouse\n\nfloat pixelSize = 0.;\nfloat pi = 3.14159;\nfloat e = 2.718281828459;\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvec3 color(float t) {\n    t = fract(2.*t + .5);\n    return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),\n                  vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20));\n}\n\nbool isBorder(vec2 uv) {\n    float w = 6.*pixelSize;\n    return uv.x > 1.0 - w || uv.x < -1.0 + w\n        || uv.y > 1.0 - w || uv.y < -1.0 + w;\n}\n\nbool inRect(vec2 p, vec4 rect) {\n    return p.x > rect.x && p.x < rect.x + rect.z\n        && p.y > rect.y && p.y < rect.y + rect.w;\n}\n\nvec2 rectUV(vec2 p, vec4 rect) {\n    return 2.0 * (p.xy - rect.xy) / rect.zw - vec2(1);\n}\n\nfloat map(vec2 z, vec2 c, float n) {\n    float b = 4., i=0.;\n    for(i=0.; i < n; i++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        if(dot(z, z) > b*b) break;\n\t}\n    return (i - log2(log2(dot(z, z)))) / n;\t    \n}\n\nvec3 mainRect1(vec2 uv) {\n    float t = map(vec2(0), uv, 64.);\n    return color(t);    \n}\n\nvec3 mainRect2(vec2 uv, vec2 p) {\n    float t = map(uv, p, 300.);\n    return color(t);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*C-R)/R.y;\n    pixelSize = 1./R.y;\n    vec2 mouse = (2.*M.xy-R)/R.y;\n    vec3 col = vec3(0);\n    col = texture(iChannel0, C.xy/R.y).xyz*0.15;\n    vec4 rect1 = vec4(-1.5, -0.7, 1.4, 1.4);\n    vec4 rect2 = vec4(0.1, -0.7, 1.4, 1.4);\n    vec2 offset = vec2(0.7, 0);\n    float scale = 1.3;\n    \n    if(iMouse.z < 1.0) {\n        float theta = 2.0 * pi * fract((T + 136.) / 400.);\n        float s2 = sin(theta/2.0);\n        vec2 c = vec2(0.25 * (2.0 * cos(theta) - cos(2.0 * theta)), sin(theta)*s2*s2);\n        mouse = 1.007 * 1./scale * 1.4 / 2. * c - offset + vec2(0.2765,0);\n    }\n    \n    if(inRect(uv, rect1)) {\n        vec2 uvr1 = rectUV(uv, rect1);\n        col = mainRect1(scale*uvr1 - offset); \n        if(isBorder(uvr1)) {\n            col = vec3(1);\n        }\n    }\n    \n    if(inRect(uv, rect2)) {\n        vec2 uvr2 = rectUV(uv, rect2);\n        col = mainRect2(scale*uvr2, scale*rectUV(mouse, rect1) - offset);\n        if(isBorder(uvr2)) {\n            col = vec3(1);\n        }\n    }\n    \n    if(length(uv - mouse.xy) < 16.*pixelSize) {\n        col = vec3(1, 0, 0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wltyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 320, 320, 365], [367, 367, 388, 388, 529], [531, 531, 555, 555, 676], [678, 678, 710, 710, 811], [813, 813, 845, 845, 902], [904, 904, 940, 940, 1121], [1123, 1123, 1148, 1148, 1212], [1214, 1214, 1247, 1247, 1306], [1308, 1308, 1365, 1365, 2495]], "test": "untested"}
{"id": "wldcRn", "name": "Paisley", "author": "yasuo", "description": "Paisley\nI wanted use the following parametrization things. I'll try it next time. The goal is so far.\nhttps://www.shadertoy.com/view/WldSWX", "tags": ["paisley"], "likes": 21, "viewed": 445, "published": 3, "date": "1608400040", "time_retrieved": "2024-07-30T20:29:23.691417", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define BASE_COLOR vec3(0.3,0.6,0.3)\n\nvec2 bend(vec2 p, float k){\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  q = p*m;\n    return q;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat paiselyDist(vec2 p, float sy, float scale) {\n    vec2  q = bend(p,1.5);\n\n    q.y*=sy*scale;\n    q*=0.8*scale;\n    float d = sdUnevenCapsule(q,0.15,0.02*scale,0.35*scale);\n    return d;\n}\n\nvec3 paiselyTex(vec2 p, vec3 col, float dir, float t) {\n    p*=Rot(radians(t*30.0*dir));\n    p*=1.2;\n    vec2 prevP = p;\n    p = abs(p);\n    p -= vec2(0.05,0.05);\n    float d = abs(sdVesica(p*Rot(radians(45.0)),0.1,0.07))-0.005;\n    col = mix(col,BASE_COLOR,S(d,0.0));\n    \n    p = prevP;\n    \n    p *= Rot(radians(45.0));\n    p = abs(p);\n    p -= vec2(0.05,0.05);\n    d = abs(sdVesica(p*Rot(radians(45.0)),0.1,0.07))-0.005;\n    col = mix(col,BASE_COLOR,S(d,0.0));\n    \n    return col;\n}\n\nvec3 paisely(vec2 p, vec3 col, float t) {\n    vec3 baseCol = BASE_COLOR;\n    vec2 pos = vec2(0.0,-0.1);\n    vec2 prevP = p;\n    float d = abs(paiselyDist(p-pos,0.9,0.88))-0.002;\n    float d2 = abs(paiselyDist(p-pos,0.87,1.05))-0.001;\n    float d3 = abs(paiselyDist(p-pos,0.85,1.25))-0.003;\n    float d4 = abs(paiselyDist(p-pos,0.9,0.82))-0.001;\n    col = mix(col,baseCol,S(d,0.0));\n    col = mix(col,baseCol*1.2,S(d2,0.0));\n    col = mix(col,baseCol,S(d3,0.0));\n    col = mix(col,baseCol,S(d4,0.0));\n    \n    p*=3.2;\n    col = paiselyTex(p-vec2(0.4,0.55),col,1.0,t);\n    \n    p = prevP;\n    p*=1.8;\n    col = paiselyTex(p-vec2(0.11,0.15),col,-1.0,t);\n    \n    p = prevP;\n    col = paiselyTex(p-vec2(0.01,-0.11),col,1.0,t);\n    \n    p = prevP;\n    p*=3.5;\n    col = paiselyTex(p-vec2(-0.13,0.13),col,1.0,t);\n    \n    p = prevP;\n    p*=2.8;\n    col = paiselyTex(p-vec2(0.1,-0.82),col,-1.0,t);\n    \n    p = prevP;\n    p*=3.2;\n    col = paiselyTex(p-vec2(-0.2,-0.89),col,1.0,t);\n    \n    p = prevP;\n    p*=3.2;\n    col = paiselyTex(p-vec2(0.4,-0.78),col,1.0,t);\n        \n    p = prevP;\n    p*=4.2;\n    col = paiselyTex(p-vec2(1.15,1.25),col,1.0,t);\n    \n    p = prevP;\n    \n    p.x -=0.01;\n    p.x = abs(p.x);\n    p.x -= 0.15;\n    d = length(p-vec2(0.01,0.0))-0.02;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x -= 0.18;\n    d = length(p-vec2(0.0,-0.12))-0.02;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    p = prevP;\n    d = length(p-vec2(-0.14,-0.22))-0.02;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    d = length(p-vec2(-0.072,0.11))-0.02;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    d = length(p-vec2(0.063,0.215))-0.013;\n    col = mix(col,baseCol,S(d,0.0));\n        \n    d = length(p-vec2(0.187,0.13))-0.017;\n    col = mix(col,baseCol,S(d,0.0));\n    \n    return col;\n}\n\nvec3 renderTexture(vec2 p, vec3 col, float t) {\n    p*=1.3;\n    \n    vec2 prevP = p;\n    \n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    col = paisely(p,col,t);\n    p = prevP;\n        \n    p.y+=0.1;\n    p.x+=0.475;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    \n    p*=1.2;\n    col = paisely(p*Rot(radians(-180.0)),col,t);\n    p = prevP;\n    \n    p.x+=0.3;\n    p.y+=-0.35;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    p*=1.8;\n    col = paisely(p*Rot(radians(120.0)),col,t);\n    p = prevP;\n    \n    p.x+=0.08;\n    p.y+=-0.31;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    p*=1.2;\n    col = paiselyTex(p,col,1.0,t);\n    p = prevP;\n        \n    p.x+=0.28;\n    p.y+=-0.57;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    p*=1.8;\n    col = paiselyTex(p,col,-1.0,t);\n    p = prevP;\n            \n    p.x+=0.56;\n    p.y+=-0.3;\n    p.x = mod(p.x,1.0)-0.5;\n    p.y = mod(p.y,0.8)-0.4;\n    p*=2.1;\n    col = paiselyTex(p,col,1.0,t);\n    \n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime*0.1;\n    \n    uv.y+=t;\n    \n    vec2 prevUV = uv;\n    vec3 col = vec3(0.99,0.98,0.95);\n\n    float t2 = mod(iTime,8000.0);\n    col = renderTexture(uv,col,t2);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wldcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 223, 223, 340], [342, 393, 435, 435, 592], [594, 645, 707, 707, 946], [948, 948, 998, 998, 1140], [1142, 1142, 1197, 1197, 1629], [1631, 1631, 1672, 1672, 3442], [3444, 3444, 3491, 3491, 4457], [4459, 4459, 4516, 4516, 4791]], "test": "untested"}
{"id": "Wl2BDR", "name": "bleistift", "author": "lennyjpg", "description": "z", "tags": ["2d", "flat", "grid", "triangles", "flag", "blue", "pattern", "exp"], "likes": 3, "viewed": 271, "published": 3, "date": "1608398855", "time_retrieved": "2024-07-30T20:29:24.754575", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f / iResolution.x;\n    float t = iTime * 0.1;\n    uv.x -= t;\n    float yy = exp(uv.y * 4.+.7),\n        k = floor(yy)*3.0,\n        x = fract(uv.x*k*2.0);\n    vec2 u = vec2(x, fract(yy));    \n    u.x = abs(u.x - .5) * 2.;\n    vec2 m = u - vec2(.0,1.);\n    m.y *= 1.5;\n    vec3 g = vec3(fract(u.x)*(1.0-u.y), 0.0, 0.0);\n    float c = step(length(m),0.7);\n    float b = u.x + u.y,\n        a = uv.y * .1,\n        d = smoothstep(b + a , b - a, 1.);\n    float tip = clamp(c - d, .0, 1.);\n    vec3 gradient = vec3(fract(u.x)*(1. - u.y));\n    vec3 white = vec3(1., 1., .93) - gradient * .4;\n    vec3 red = vec3(.8,0.,0.) - g * .5;\n    float e = fract(u.x - .5) * (u.y) * .3;\n    vec3 black = vec3(e);\n    vec3 col = mix(white, red, d);\n    float n =  (u.y);\n    col.r += n * .2;\n    col = mix(col, black,tip);\n    col -= uv.y * .37;\n    O = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2BDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 903]], "test": "untested"}
{"id": "3tdczr", "name": "conformal polygonal morphism", "author": "cyperus", "description": "conformal polygonal morphism\n\npolyhedral symmetry in the riemann sphere \n[url]https://math.stackexchange.com/questions/1469554/polyhedral-symmetry-in-the-riemann-sphere[/url]\nconfigure code to see other spherical polyhedra", "tags": ["sphere", "conformal", "tiling"], "likes": 15, "viewed": 642, "published": 3, "date": "1608391825", "time_retrieved": "2024-07-30T20:29:25.538479", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// \"conformal polygonal morphism\"\n//\n// created by Colling Patrik (cyperus) in 2020\n//\n// DOCUMENTATION:\n// https://math.stackexchange.com/questions/1469554/polyhedral-symmetry-in-the-riemann-sphere\n//\n////////////////////////////////////////////////////////////////////////////////\n// animation\nconst float anim_velocity = 1.0;\n// camera\nconst float cam_dist = 3.0;\nconst float cam_fle = 2.;\n// raymarch\nconst int rm_maxi = 100;\nconst float rm_mindist = 1.5, rm_maxdist = 4.0;\nconst float rm_slmul = 0.3;\n// texture\nconst float ba_v_distri = 0.5;\nconst float tex_u_subdiv = 6.0, tex_v_subdiv = 6.0;\n// anti-aliasing\nconst float AA = 2.0;\n\nfloat map( in vec4 pt, out vec4 mat ){    \n    float time = pt.w;   \n\tvec3 p = pt.xyz, pn = normalize(p);\n    int k, n;\n    vec2 z, zk; \n    #if 0\n    // Fk,2(z) = wk2(z)\n    k = 3;\n    vec2 wk2;\n    float a1 = float(k);\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.0-(pn.z));\n        zk = cpow(z,k);\n        wk2 = a1 * cdiv(zk, cpow(zk - vec2(1.,0.) ,2));\n    }else        // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        wk2 = a1 * cdiv(zk, cpow(vec2(1.,0.) - zk ,2));     \n    }    \n    float srk2 = float(length(wk2)>1.0?-2:k);\n    #endif\n    #if 0\n    // F3,3(z) = w33(z)\n    k = 3, n = 3;\n    const float a1 = 2.*sqrt(2.);\n    vec2 w33;\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.0-pn.z);\n        zk = cpow(z,k);\n        w33 = 1./(8.*a1) * zk;\n        w33 = cmul(w33, cpow(zk-vec2(a1,0.),k));\n        w33 = cdiv(w33, cpow(zk+ vec2(1./a1,0.0),n));\n    }else        // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        w33 = 1./(8.*a1)*cinv(zk);       \n        w33 = cmul(w33, cpow(vec2(1.,0.) - zk * a1 ,k));\n        w33 = cdiv(w33, cpow(vec2(1.,0.) + zk / a1 ,n));    \n    }\n    float sr33 = float(length(w33)>1.0?-n:k);\n    // sense of rotation of the polygon: sign(sr) in {-1.,+1.}\n    // number of sides of the polygon: abs(sr) in {3.,3.}\n    #endif \n    #if 1\n    // F4,3(z) = w43(z)  \n    k = 4, n = 3;\n    vec2 w43;\n    if (pn.z < 0.) // stereographic (north pol)\n    {        \n        z = vec2(pn.x, pn.y)/(1.-pn.z);\n        zk = cpow(z,k);\n        w43 = 108. * zk;\n        w43 = cmul(w43, cpow(zk - vec2(1.,0.)                   ,k));\n        w43 = cdiv(w43, cpow(cmul(zk,zk) + 14.*zk + vec2(1.,0.) ,n));\n    }else         // stereographic (south pol) \n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        w43 = 108. * zk;\n        \n        w43 = cmul(w43, cpow(vec2(1.,0.) - zk                   ,k));\n        w43 = cdiv(w43, cpow(vec2(1.,0.) + 14.*zk + cmul(zk,zk) ,n)); \n    }\n    float sr43 = float(length(w43)>1.?-n:k);\n    // sense of rotation of the polygon: sign(sr) in {-1.,+1.}\n    // number of sides of the polygon: abs(sr) in {3.,4.}\n    #endif\n\t#if 1\n    // F5,3(z) = w53(z)\n    k = 5, n = 3;\n    vec2 w53;  \n    if (pn.z < 0.) // stereographic (north pol)\n    {  \n        z = pn.xy/(1.+abs(pn.z));\n        zk = cpow(z,k); \n        vec2 zk2 = cmul(zk,zk);\n        w53 = 1728. * zk;\n        w53 = cmul(w53, cpow(  zk2-11.*zk-vec2(1.,0.)  ,k));\n        w53 = cdiv(w53, cpow(   cmul(zk2,zk2)\n                       +228.*cmul(zk2,zk)\n                       +494.*zk2\n                       -228.*zk\n                       +vec2(1.,0.) ,n)  );\n    } else        // stereographic (south pol)                    \n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        vec2 zk2 = cmul(zk,zk);\n        w53 = 1728. * zk; \n        w53 = cmul(w53, cpow( vec2(1.,0.) - 11.*zk - zk2 ,k));\n        w53 = cdiv(w53, cpow( vec2(1.,0.)\n                       +228.0*zk\n                       +494.0*zk2\n                       -228.0*cmul(zk2,zk)\n                       +cmul(zk2,zk2) ,n)  );\n    }\n    float sr53 = float(length(w53)>1.0?-n:k);\n    // sense of rotation of the polygon: sign(sr) in {-1.,+1.}\n    // number of sides of the polygon: abs(sr) in {3.,5.}\n\t#endif\n    \n    vec2 w; float sr;\n    //switch: {1,0} => {single polyhedron, metamorphose of 2 polyhedra}\n\t#if 0\n    //select polyhedron from (wk2,srk2 ), (w33,sr33), (w43,sr43), (w53,sr53)\n    w = w43; sr = sr43;\n\t#else\n    float ff = smoothrecpuls(0.02*time,0.0,1.0,0.3,0.3);\n    //select polyhedra from (wk2,srk2 ), (w33,sr33), (w43,sr43), (w53,sr53)\n    w = metamorph(w43,w53,ff); sr = metamorph(sr43,sr53,ff);\n\t#endif\n    \n    // return texture data\n\tmat = vec4(w,sr,1.0 );\n \n\t// sdf r(w) sphere\n    float r = 1.0 + 0.1*sin(atan(log(length(w))*ba_v_distri));\n\tfloat d = length(p)-r;\n\t//\n    return d;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px ,in float time)\n{\n    float res = -1.0; // init no intersection\n    \n    // bb boundingbox\n    vec2 dis = isphere( ro, rd , 2.);\n    \n    if( dis.y<0.0 ) // if no hit with bb return\n        return -1.0;\n    dis.x = max( dis.x, rm_mindist );\t// start_raylength from bb or minimal_raylength\n    dis.y = min( dis.y, rm_maxdist );\t// end_raylength from bb or maximal_raylength\n    // raymarch signed distance field\n\tvec4 data; // accumulated data while raymarching\n    \n\tfloat t = dis.x; // init with start_raylength\n\tfor( int i=0; i<rm_maxi; i++  )\n    { \n        vec4 pt = vec4(ro + rd*t,time);\n        float th = 0.0001*px*t; //th = 0.0001; // iso_surface-hit-delta\n\t\tfloat h = map( pt, data );\n\t\tif( t>dis.y || h<th ) break; // reached end_raylength or hit iso_surface\n        t += h*rm_slmul; // step-length-multiplier\n    }\n    \n    if( t<dis.y ) // ray is inside bb\n    {\n        rescol = data; // return data\n        res = t;       // return ray_length\n    }\n    return res;\n}\n\n// transform from mla\nvec3 transform(in vec4 p){\n\tif (iMouse.x > 0.0)\n\t{\n\t\tfloat phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n\t\tfloat theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n\t\tp.yz = crot(p.yz,theta);\n\t\tp.zx = crot(p.zx,-phi);\n\t}\n\tp.xz = crot(p.xz,p.w*0.1);\n\treturn p.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// global time\n\tfloat time = anim_velocity*iTime;\n    \n\t// camera\n\tvec3 ro = transform(vec4(0,0,-cam_dist,time)).xyz;\n    \n\t// anti-aliasing\n\tvec3 aacol = vec3(0);\n\tfor (float i = 0.0; i < max(-time,AA); i++) {\n\t\tfor (float j = 0.0; j < max(-time,AA); j++) {\n        \n\t\t\t// ray direction\n\t\t\tvec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n\t\t\tvec3 rd = normalize(transform(vec4(uv,cam_fle,time)));\n            \n\t\t\t// get ray distance to (intersection) hit point\n\t\t\tvec4 mat = vec4(0.0);\n\t\t\tfloat px = 2.0/( iResolution.y*cam_fle );\n\t\t\tfloat t = intersect( ro, rd, mat, px ,time);\n\n\t\t\tvec3 col;\n\t\t\tif (t < 0.0){ // sky\n\t\t\t\tcol = vec3(0.8,0.6,1.0)*(0.3+0.2*rd.y); // background-color\n\t\t\t}\n\t\t\telse{ // intersection with surface\n\t\t\t\tvec3 p = ro + rd * t;// intersection point\n                \n\t\t\t\t// texture_data, mat = vec4(w,sr,1.0 );\n\t\t\t\tvec2 w = vec2(mat.s,mat.t); float sr = mat.p;\n                \n\t\t\t\t// texture_coords\n\t\t\t\tfloat u = atan(w.y,w.x)/PI;// [-PI,+PI] => u in[-1.,0.,+1.]\n\t\t\t\t// length(w) in[0.,1.,+inf] => [-inf,0.,+inf] => [-0.5*PI,+0.5*PI] => v in[-1.,0.,+1.]\n\t\t\t\tfloat v = atan(log(length(w))*ba_v_distri)/(0.5*PI);\n                \n\t\t\t\t// texture_color\n                float col_h = 1.0; // h in [-0.5,0.0,+0.5] => [green_cyan,red,blue_cyan]\n                col_h *= 0.5*v;\n                //col_h *= 0.5*u;\n\t\t\t\tfloat col_s = 1.0;\n\t\t\t\tcol_s *= 0.9+0.1*sign(sr);\n                col_s *= (t == rm_mindist)?0.5:1.0;\n\t\t\t\tfloat col_v = 1.0;\n\t\t\t\tcol_v *= .5+.5*fract(tex_u_subdiv*1.0*(.5+.5*u) - 0.3* time);\n\t\t\t\tcol_v *= .5+.5*fract(tex_v_subdiv*2.0*(.5+.5*v) - 0.3* time);\n\t\t\t\tcol = hsv2rgb(col_h, col_s, col_v);// color (hue, saturation, value)\n\t\t\t}\n\t\t\taacol += col;\n\t\t}\n\t}\n\taacol /= float(AA*AA);\n\taacol = pow(aacol,vec3(0.4545)); // gamma correction\n\tfragColor = vec4(aacol,1);\n}\n", "image_inputs": [], "common_code": "// const\nconst float PI = 3.14159265359;\n\n// 2D transformations: vec2 => vec2\n// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);\t// za*zb\n}\nvec2 cinv(vec2 z) {\t\t\t\t\t\t// 1/z\n  return z*vec2(1,-1)/dot(z,z);\n}\nvec2 cdiv(vec2 z, vec2 w){\t\t\t\t// z/w\n  return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) {\t\t\t\t// z^n\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n\nvec2 crot(vec2 z,float a){\n    float si = sin(a), co = cos(a);\t\t// z*e^(j*a)\n    return mat2(co,-si,si,co)*z;\n}\n\nvec2 metamorph(vec2 z0,vec2 z1, float f){\n\tif (f<= 0.0) return z0;\n\tif (f>= 1.0) return z1;\n\telse return cdiv(cmul(z0,z1),(f*z0+(1.0-f)*z1));\n}\n\nfloat metamorph(float x0,float x1, float f){\n\tif (f<= 0.0) return x0;\n\tif (f>= 1.0) return x1;\n\treturn x0*x1/(f* x0+(1.0-f)*x1);\n}\n\n//\nfloat smoothrecpuls(float x,float aa,float ab,float ia,float ib){\n\t/*\n\tsmoothrecpuls is an periodic smooth rectangle-function\n\twith normalized periode == 1.\n\tIt starts at x == 0 with the first-transition-interval, followed by puls-a-const-\n\t, second-transition- and puls-b-const-interval.\n\tfloat x  : value\t\t(normalized)\n\tfloat aa : amplitude pulse a\n\tfloat ia : interval puls a\t\tia in [0,1]  (normalized)\n\tfloat ab : amplitude pulse b\n\tfloat ib : interval puls b\t  \tib in [0,1]  (normalized)\n\n\tcheck ia+ib < 1.0; it+ia+it+ib = 1.0;\n\t */\n\tia = abs(ia);\n\tib = abs(ib);\n\t// function smooth2puls\n\tfloat it = 0.5*(1.-ia-ib); // interval transition\n\tx = fract(x);\n\treturn   (aa-ab)*smoothstep(0.0\t\t,it\t\t\t,x)+ab\n\t\t\t-(aa-ab)*smoothstep(it+ia\t,it+ia+it\t,x);\n}\n\n// 3D-transformations: vec3 => vec3\n//color\nvec3 hsv2rgb(float h, float s, float v){\t\t// hue, saturation, value\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 isphere(in vec3 ro, in vec3 rd, in float r )\n{// sphere centered at the origin, with size rd\n    \n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdczr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[806, 806, 844, 844, 4813], [4815, 4815, 4902, 4902, 5865], [5867, 5889, 5915, 5915, 6164], [6166, 6166, 6222, 6238, 8043]], "test": "untested"}
{"id": "3tdczn", "name": "-Threads-", "author": "Plento", "description": "A variation on my last shader", "tags": ["3d", "raymarch", "pos"], "likes": 10, "viewed": 334, "published": 3, "date": "1608359977", "time_retrieved": "2024-07-30T20:29:26.392197", "image_code": "// Fork of \"Web Compound - X\" by Plento. https://shadertoy.com/view/wt3czr\n// 2020-12-19 06:01:50\n\n// By Cole Peterson (Plento)\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    vec2 nuv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    float sv = ss(0.0, 1.0, abs(nuv.y));\n    float rnd = hash12(u+iTime)*.055;\n    \n    sv += rnd;\n    sv*=0.022;\n    \n    uv += sv;\n    float r = texture(iChannel0, uv).x;\n    uv += sv;\n    float g = texture(iChannel0, uv).y;\n    uv += sv;\n    float b = texture(iChannel0, uv).z;\n    \n    vec3 col = vec3(r, g, b);\n    \n    col *= 1.-step(.45,abs(nuv.y)); // Border\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.); // Final color with gamma correction\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Raymarch scene\n\n//iquilezles.org/articles/distfunctions\nfloat sdCap( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n// Get distance field\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    rp.xy*=rot(iTime*.1);\n    rp.z-=iTime*.4;\n    \n    rp.yx += vec2(.4, .36);\n    \n    // Repeat space\n    vec3 b = vec3(vec2(0.78), 2.6);\n    vec3 id = floor(rp/vec3(b.x, b.y, 1.));\n    \n    //rp.yz *= rot(id.x*0.3);\n    \n    //rp.z += cos(rp.x*3. + iTime*10.)*0.02;\n    //rp.x += sin(rp.y*3. + iTime*10.)*0.02;\n    \n    rp = mod(rp, b)-b*0.5;\n    \n    // Mirror space\n    rp.xy = -abs(rp.xy);\n    \n    // Sphere height\n    float z = .18*cos(.8*iTime+(id.x+id.y*4.)*40.);\n    \n    vec2 c0 = vec2(.5);\n    vec2 c = c0;\n    vec2 lc = c;\n    \n    // Build the web grid thing\n    for(float i = 0.0; i < 19.0; i++){\n        c = c0 * rot(i*8.6);\n        d = min(d, sdCap(rp, vec3(lc, 0.), vec3(c, 0.), .017));\n        lc = c;\n    }\n    \n    \n    return d;\n}\n\n// Standard raymarch normals\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n// Trace scene\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 55; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .0015 || t > 8.) break;\n        \n        t += d * .55;\n    }\n    return t;\n}\n\n// Color pixel\nvec3 color(vec3 p, vec3 rd, vec3 n, float t){\n    // Light position and direction\n    vec3 lp = vec3(0., 22., -13.0);\n    vec3 ld = normalize(lp-p);\n   \t\n    // Standard specular\n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 16.);\n   \n    vec3 col = vec3(0.75, 0.9, 0.95)*spec*.16;\n   \n    col = mix(vec3(.333), col, exp(-t*t*t*t*0.0007)); // White fog\n\treturn col;   \n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    // Ray direction with inverted fish eye \n    vec3 rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * -.7));\n    // Ray origin\n    vec3 ro = vec3(0., 0., -1.8);\n    \n    rd.yz *= rot(-.6);\n    //rd.xz *= rot(.07);\n    \n    // Mouse movement\n    if(iMouse.z > 0.){\n        ro.x += m.x*3.;\n        ro.y += m.y*2.3;\n        rd.xz *= rot(m.x*.9);\n    }\n    \n    float t = march(rd, ro); // Dist to scene\n    vec3 n = normal(ro + rd*t); // normals of scene\n    vec3 col = color(ro + rd*t, rd, n, t); // Get pixel color\n    \n    col *= ss(0.9, 0.45, abs(uv.x)); // Outer side shade\n    \n    f = vec4(col, 1.0);\n}\n\n\n", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define FAR 100.\n#define ss(a, b, t) smoothstep(a, b, t)\n\n// Dave hoshkin hash\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 170, 170, 691]], "test": "untested"}
{"id": "Wltczn", "name": "Mass Collision", "author": "wyatt", "description": "Fluid dynamics arising naturally from particle collisions :) click to see!", "tags": ["fluid"], "likes": 19, "viewed": 834, "published": 3, "date": "1608355741", "time_retrieved": "2024-07-30T20:29:27.155157", "image_code": "Main {\n    Q = B(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nbool cell (vec2 u) {\n    return u.x>=0.&&u.y>=0.&&u.x<1.&&u.y<1.;\n}\n#define pack(u) (floor(u.x)+R.x*floor(u.y))\n#define unpack(i) vec2(mod(floor(i),R.x),floor(floor(i)/R.x))\n\n#define touch(u) ((length(u)-2.)/(length(u)+2.))", "buffer_a_code": "Main {\n\n    Q = A(U);\n    vec4 q = B(U);\n    vec4 c = C(Q.xy);\n    float n = 0.;\n    vec2 f = vec2(0);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 c = C(Q.xy+u);\n        for (int k = 0; k < 4; k++){\n            float index = c[k];\n            if (index > 0.) {\n                vec4 a = A(unpack(index));\n                vec2 u = a.xy-Q.xy;\n                if (length(u)>0.) {\n                    float m = touch(u);\n                    u = normalize(u);\n                    f += .25*m*u;\n                    n ++;\n                }\n            }\n        }\n    }\n    Q.w -= .3/R.y*sign(U.y-0.5*R.y);\n    Q.z -= .3/R.x*sign(U.x-0.5*R.x);\n    if (n>0.) Q.zw += .5*f;\n    Q.xy += Q.zw+f;\n    if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n    \n    if (Q.x < 2.) {Q.x = 2.; Q.z*=-1.;}\n    if (R.x-Q.x < 2.) {Q.x = R.x-2.; Q.z*=-1.;}\n    if (Q.y < 2.) {Q.y = 2.; Q.w*=-1.;}\n    if (R.y-Q.y < 2.) {Q.y = R.y-2.; Q.w*=-1.;}\n    \n    \n    if (iFrame < 1) {\n        Q = vec4(U,0,0);\n    }\n    \n    if (iMouse.z>0.&&length(Q.xy-iMouse.xy)<20.)\n        Q.z = 1.;\n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\n    vec4 c = C(U);\n    vec2 v = unpack(c.x);\n    Q = (c.x>0.?1.:0.)*(.5+.5*sin(2.+2.*sign(v.x-.5*R.x)+2.*sign(v.y-.5*R.y)*vec4(1,2,3,4)));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = vec4(0);\n    int i = 0;\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 c = C(U+u);\n        for (int k = 0; k < 4; k++){\n            float index = c[k];\n            if (index>0.&&i<4) {\n                vec4 a = A(unpack(index));\n                if (cell(a.xy-floor(U)))\n                    Q[i++] = index;\n            }\n        }\n    }\n    if (i==0) {\n        vec4 d = D(U);\n        vec4 a = A(d.xy);\n        if (cell(a.xy-floor(U)))\n            Q.x = pack(d.xy);\n    }\n    if (iFrame < 1) Q = vec4(pack(U),0,0,0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define N 12\nvoid X (inout vec4 Q, inout float r, vec2 U, vec4 b) {\n\t\n    vec4 a = A(b.xy);\n    \n    if (length(a.xy-U)<r) {\n    \tr = length(a.xy-U);\n        Q.xy = b.xy;\n    }\n\n}\n\nvoid Z (inout vec4 Q, inout float r, vec2 U, vec4 b) {\n\t\n    vec4 a = A(b.zw);\n    \n    if (length(a.xy-U)<r) {\n    \tr = length(a.xy-U);\n        Q.zw = b.zw;\n    }\n\n}\n\nMain {\n    \n    Q = B(U);\n    float r = length(A(Q.xy).xy-U);\n    X(Q,r,U,B(U+vec2(0,1)));\n    X(Q,r,U,B(U+vec2(1,0)));\n    X(Q,r,U,B(U-vec2(0,1)));\n    X(Q,r,U,B(U-vec2(1,0)));\n    X(Q,r,U,B(U+vec2(0,2)));\n    X(Q,r,U,B(U+vec2(2,0)));\n    X(Q,r,U,B(U-vec2(0,2)));\n    X(Q,r,U,B(U-vec2(2,0)));\n    X(Q,r,U,Q.zwzw);\n    r = length(A(Q.zw).xy-U);\n    if (iFrame%N==0) Q.zw = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tZ(Q,r,U,B(U+vec2(0,k)));\n    \tZ(Q,r,U,B(U+vec2(k,0)));\n    \tZ(Q,r,U,B(U-vec2(0,k)));\n    \tZ(Q,r,U,B(U-vec2(k,0)));\n    }\n    \n\t\n    if (iFrame < 1) Q = vec4(U,U);\n    \n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wltczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WldcRn", "name": "fork- quick julia", "author": "jorge2017a1", "description": "Mouse Usar", "tags": ["forkquickjulia"], "likes": 3, "viewed": 230, "published": 3, "date": "1608349301", "time_retrieved": "2024-07-30T20:29:28.019845", "image_code": "mat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 mm = (2. * iMouse.xy - iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1.);\n    vec2 Z =vec2(0.0,0.0) +uv*((sin(iTime*0.25)-0.5));\n    vec2 C = 2. * mm;\n    \n    \n    float i;\n    for (i = 0.; i < 128.; i += 1.0) {\n        Z = vec2(Z.x * Z.x - Z.y * Z.y, 2. * Z.x * Z.y);\n        Z += C;\n        if (dot(Z, Z) > 4.0) break;\n    }\n    \n    float a = .02 * (i + 4.);\n    float aa = .5 * (i + 0.5);\n    \n    col.gb -= max(0., Z.x) * a;\n    col.rg -= max(0., Z.y) * a;\n    col.rbg -= max(0., Z.y-Z.x)*aa*a*a;\n    vec3 col2=sin(vec3(0.1, 0.2, 0.5) *float( i)) ;\n    col=(col+col2)/2.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WldcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [87, 87, 144, 194, 916]], "test": "untested"}
{"id": "3ldcRn", "name": "simple flor 2d", "author": "jorge2017a1", "description": "simple flor 2d", "tags": ["simpleflor2d"], "likes": 0, "viewed": 242, "published": 3, "date": "1608349223", "time_retrieved": "2024-07-30T20:29:28.868575", "image_code": "//por jorge2017a1\n//recursos\n//https://iquilezles.org/articles/distfunctions2d\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{\n    if (d1.x<d2.x) return d1;\n    else return d2;\n}\n\nvec2 opS2( vec2 d1, vec2 d2 )\n{\n    if  (-d1.x<d2.x) return d1;\n    else  return d2;\n}\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{\n    if (d1.x>d2.x)\treturn d1;\n    else return d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2) {\n\treturn vec2(max(-d2.x, d1.x), 2.0);\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{    vec2 q = mod(p+0.5*c,c)-0.5*c; return  q; }\n\nfloat sdCirc(vec2 p, float r)\n{  return length(p)-r; }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n///------------------------------\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec2 opAngRep( vec2 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec2(polar.y * vec2(cos(polar.x),sin(polar.x)));\n}\n\n\n\nvec2 hexcuadro(vec2 p, float numItem)\n{\n    \n    vec2 pp;\n    p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    vec2 rep2 = opAngRep(p, tau / numItem);\n    float sdb1= sdBox(rep2-vec2(1.0,0.0), vec2(0.5,0.25) );\n    vec2 res = vec2( sdb1,6.0);\n    return  res;\n}\n\nvec2 sol2(vec2 p, float numItem)\n{\n    \n    vec2 pp;\n    p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    //p= rotate2d(p, radians(iTime*10.0));\n    vec2 rep2 = opAngRep(p.yx, tau / numItem);\n    float sdb1=  sdTriangleIsosceles(rep2.yx-vec2(0.0,0.125), vec2(0.15,0.25) );\n    //float sdb1=  sdTriangleIsosceles(p-vec2(1.0,0.0), vec2(0.15,0.25) );\n    vec2 res = vec2( sdb1,2.0);\n    return  res;\n}\n\nvec2 grass(vec2 p)\n{\n\tp *= vec2(10.0, 1.0) * 2.5;\n\tfloat a = floor(p.x) * 12.0, b = 1.0 + sin(floor(p.x)) * cos(floor(p.x) * 0.3) * 0.1;\n\tp.x = mod(p.x, 1.0) - 0.5;\n\tfloat f1= step(abs(p.x + cos(a) * p.y ), 0.5 - p.y * b);\n    vec2 resp=vec2(f1,38.);\n    return resp;\n}\n\nvec2 flor(vec2 p, float numItem)\n{\n    \n    vec2 pp=p;\n    vec2 res=vec2(9999.9,-1.0);\n    //p.xy *= genRotMat(iTime);/// genera la rotacion del engrane\n    vec2 rep2 = opAngRep(p, tau / numItem);\n    float sc1= sdCirc(rep2-vec2(0.35,0.0), 0.25 );\n    float sc2= sdCirc(p-vec2(0.0,0.0), 0.25 );\n    float b1= sdBox( p-vec2(0.0,-0.9), vec2(0.02,0.5) );\n    \n    sc1=opS(sc2,sc1);\n    \n    res =opU2( vec2( b1,7.0)  ,res);\n    res =opU2( vec2( sc1,2.0), res);\n    res =opU2( vec2( sc2,5.0)  ,res);\n    return  res;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    //p*= 2.25;\n\tvec3 col = vec3(0.280,0.320,1.0);\n    \n    vec2 p1=p*3.0;\n    \n    \n    vec2 h1=hexcuadro(p1-vec2(3.5,-0.5), 8.0);\n    vec3 colh1= getColorf(h1.y);\n    col= DibujoConBorde(p, h1.x, colh1,  col);\n    \n    \n    \n    \n    vec2 s1=sol2(p-vec2(-1.2,-0.3), 6.0);\n    vec3 cols1= getColorf(s1.y);\n    col= DibujoSinBorde(p, s1.x, cols1,  col);\n    \n    \n    vec2 f1=flor(p, 6.0);\n    vec3 colf1= getColorf(f1.y);\n    col= DibujoConBorde(p, f1.x, colf1,  col);\n    \n    vec2 p2 = fragCoord.xy / iResolution.xy * vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 scroll = vec2(iTime * 0.25, 0.0);\n    \n    vec2 g1= grass(p2 * 1.2 + scroll );\n   \n     vec3 colg1= vec3(0.1, 0.3, 0.0);;\n    col=mix(col, colg1, g1.x);\n    \n    \n    fragColor = vec4(col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{ vec3 color; };\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.,  //37 //marron o cafe\nvec3(0.1, 0.3, 0.0)  //38\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\nvec3 getColorf(float ii)\n{\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 DibujoConBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nvec3 DibujoSinBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    //colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    colOut = mix(colOut, colIn, uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 rotate2d(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);  float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ldcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 256, 256, 278], [279, 279, 312, 312, 334], [335, 335, 368, 368, 389], [392, 392, 424, 424, 476], [478, 478, 509, 509, 564], [566, 566, 598, 598, 650], [652, 652, 680, 680, 719], [721, 721, 759, 759, 806], [808, 808, 839, 839, 862], [865, 865, 902, 902, 975], [1041, 1041, 1067, 1067, 1121], [1123, 1123, 1157, 1157, 1325], [1329, 1329, 1368, 1368, 1605], [1607, 1607, 1641, 1641, 2020], [2022, 2022, 2042, 2042, 2291], [2293, 2293, 2327, 2327, 2807], [2811, 2811, 2868, 2918, 3794]], "test": "untested"}
{"id": "WltcRn", "name": "simple columnas rep", "author": "jorge2017a1", "description": "simple columnas rep", "tags": ["simplecolumnasrep"], "likes": 0, "viewed": 231, "published": 3, "date": "1608349217", "time_retrieved": "2024-07-30T20:29:29.915775", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n//---------------------\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\n\n\nfloat RepN2(vec3 p, float numItem)\n{\n    vec3 pp=p;\n    //p.xy *= genRotMat(iTime);/// genera la rotacion del engrane \n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n    float sdb1= sdCylinderYZ(rep2.zyx-vec3(10.0,0.0,5.0), vec2(1.5,20.0) );\n    float sdb2= sdBox( p-vec3(0.0,0.0,-4.0), vec3(10.0,10.0,1.0) );\n    float sdb3= sdBox( p-vec3(0.0,0.0,28.0), vec3(10.0,10.0,1.0) );\n    \n    float res = unionSDF( sdb1,sdb2);\n    res = unionSDF( res,sdb3);\n    return  res;\n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n\tp.y=5.0+p.y+10.0*sin(iTime);\n    \n\tfloat planeDist1 = p.y+5.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    //res =opU3(res, vec3(planeDist1,13.0,MATERIAL_NO)); //inf\n    res =opU3(res, vec3(planeDist1,-1.0,2.0)); //inf\n  \n  \n    p.y=p.y-5.0;\n  vec3 q=p;\n    float cx=47.0;\n    float cy=5.0;\n    float cz=60.00;\n    ///q.y = mod(q.y+0.5*cy,cy)-0.5*cy;\n    q.z = mod(q.z+0.5*cz,cz)-0.5*cz;\n    q.x = mod(q.x+0.5*cx,cx)-0.5*cx;\n    p=q;\n\n    float c1=RepN2(p.xzy-vec3(0.0,0.0,-5.0), 10.0);\n    \n    res =opU3(res, vec3(c1,1.0,MATERIAL_NO)); \n    \n   \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 r = reflect(-l, normal);\n    vec3 ref = reflect(lig, normal);\n    \n  \n    float diff = dot(normal, l);\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\tspecular = pow( specular, shininess );\n\tfinal += color * ( diffuse + specular);\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n//-------------------------------------------\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 ) { return tex3D(iChannel0, p/32., nor); }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n    \n    \n    if(id_material== 1.0 )\n    {\n        float c = 0.8+mod((floor(mObj.p.x) + floor(mObj.p.z) + floor(mObj.p.y)), 2.0);\n        return vec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 )*c;\n    }\n    \n\tif(id_material== 2.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 10.0);\n    } \n    \n\tif(id_material== 3.0 )\n    { \n        return checkerBoard(mObj.p.x, mObj.p.z, 3.0)*vec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 );\n    } \n\n    if (id_material==4.0)\n    { // nothing hit: background gradient\n     return vec3(0.2, 0.2, 0.2) * (-mObj.uv.y+1.2);\n    }\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t\t// vary between red (0) and yellow (1)\n\t\t//return vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;\n\t\treturn vec3(0.8 + 0.4*d, 0.3 + 0.55*d, 0.15 - 0.1*d);\n    }\n    \n    \n    \n}\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 6.0, 10.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    \n   \n    vec3 ro=vec3(15.0,2.0,-15.0+t);\n     \n    vec3 rd=normalize(vec3(uv,1.0));\n    \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\nfloat saturate(float f)\n{ return clamp(f,0.0,1.0);}\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WltcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 432, 432, 516], [517, 517, 556, 556, 651], [652, 652, 691, 691, 786], [787, 787, 826, 826, 921], [923, 967, 1014, 1014, 1041], [1043, 1043, 1086, 1086, 1113], [1115, 1115, 1163, 1163, 1191], [1293, 1293, 1319, 1319, 1373], [1375, 1375, 1409, 1409, 1582], [1587, 1587, 1623, 1623, 2059], [2063, 2103, 2128, 2128, 3066], [3070, 3070, 3156, 3156, 3802], [3808, 3859, 3883, 3883, 4071], [4072, 4135, 4168, 4168, 4629], [4631, 4685, 4721, 4721, 4955], [5058, 5058, 5107, 5107, 5329], [5330, 5364, 5444, 5444, 5721], [5764, 5815, 5862, 5862, 6771], [6825, 6825, 6918, 6918, 7350], [7355, 7404, 7461, 7461, 8659]], "test": "untested"}
{"id": "wt3czr", "name": "Web Compound - X", "author": "Plento", "description": "Visual experiments! ", "tags": ["3d", "raymarch", "post"], "likes": 7, "viewed": 346, "published": 3, "date": "1608347784", "time_retrieved": "2024-07-30T20:29:30.794427", "image_code": "// By Cole Peterson (Plento)\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u/R;\n    vec2 nuv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    float sv = ss(0.01, 0.5, abs(nuv.y));\n    float rnd = hash12(u+iTime)*.2;\n    \n    sv += rnd;\n    sv*=0.005;\n    \n    uv += sv;\n    float r = texture(iChannel0, uv).x;\n    uv += sv;\n    float g = texture(iChannel0, uv).y;\n    uv += sv;\n    float b = texture(iChannel0, uv).z;\n    \n    vec3 col = vec3(r, g, b);\n    \n    col *= 1.-step(.45,abs(nuv.y)); // Border\n    \n    //col = vec3(sv);\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.); // Final color with gamma correction\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Raymarch scene\n\n//iquilezles.org/articles/distfunctions\nfloat sdCap( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Easy way to do differnt materials for any object \nfloat mat = 0.;\nfloat md = 99.;\nvoid newmat(float d, float nm){\n    if(d < md){\n        md = d;\n        mat = nm;\n    }\n}\n\n// Scene translation\nvoid trns(inout vec2 p){\n    p.y += iTime*.4;\n    p.x += cos(iTime*.25)*.5;\n}\n\n// Get distance field\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    trns(rp.xy);\n    \n    // Repeat space\n    vec3 b = vec3(vec2(0.78), 0.);\n    vec3 id = floor(rp/vec3(b.x, b.y, 1.));\n    rp = mod(rp, b)-b*0.5;\n    \n    // Mirror space\n    rp.xy = -abs(rp.xy);\n    \n    // Sphere height\n    float z = .18*cos(.8*iTime+(id.x+id.y*4.)*40.);\n    \n    // Dist to spheres \n    d = min(d, length((rp-vec3(.0, .0, z))*vec3(1., 1., 1.5))-.275);\n    newmat(d, 0.); // Use mat 0\n    \n    vec2 c0 = vec2(.5);\n    vec2 c = c0;\n    vec2 lc = c;\n    \n    // Build the web grid thing\n    for(float i = 0.0; i < 19.0; i++){\n        c = c0 * rot(i*8.6);\n        d = min(d, sdCap(rp, vec3(lc, 0.), vec3(c, 0.), .022));\n        lc = c;\n    }\n    newmat(d, 1.); // Use mat 1\n    \n    return d;\n}\n\n// Standard raymarch normals\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n// Trace scene\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 58; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .0015 || t > 11.) break;\n        \n        t += d * .55;\n    }\n    return t;\n}\n\n// Color pixel\nvec3 color(vec3 p, vec3 rd, vec3 n, float t){\n    // Light position and direction\n    vec3 lp = vec3(0., 22., -13.0);\n    vec3 ld = normalize(lp-p);\n   \t\n    // Standard specular and fresnel\n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 16.);\n    float fres = smoothstep(-.72, .72, dot(rd, n));\n    \n    trns(p.xy);\n    \n    vec3 col = vec3(0);\n    \n    // Sphere id\n    vec3 b = vec3(vec2(0.78), 0.);\n    vec3 id = floor(p/vec3(b.x, b.y, 1.));\n    \n    float pwr = .23; // specular power\n    \n    // Color variation for spheres\n    if(mat == 0.){ \n        pwr = .07; \n        col = .014*vec3((.5+.5*cos((id.y+id.x)*324.3 + iTime*.25)));\n        col += vec3(0.9, 0.75, 0.7)*spec*pwr;\n        col += fres*.12;\n    }\n    else if(mat == 1.) col += vec3(0.8, 0.9, 0.99)*spec*pwr; // Slightly different color for web thing\n    \n    col = mix(vec3(.9), col, step(t, 10.)); // White background\n    \n\treturn col;   \n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    // Ray direction with inverted fish eye \n    vec3 rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * -0.45));\n    // Ray origin\n    vec3 ro = vec3(0., 0., -1.8);\n    \n    rd.yz *= rot(-.6);\n    rd.xz *= rot(.07);\n    \n    // Mouse movement\n    if(iMouse.z > 0.){\n        ro.x += m.x*3.;\n        ro.y += m.y*2.3;\n        rd.xz *= rot(m.x*.6);\n    }\n    \n    float t = march(rd, ro); // Dist to scene\n    vec3 n = normal(ro + rd*t); // normals of scene\n    vec3 col = color(ro + rd*t, rd, n, t); // Get pixel color\n    \n    col *= ss(0.99, 0.45, abs(uv.x)); // Outer side shade\n    \n    f = vec4(col, 1.0);\n}\n\n\n", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define FAR 100.\n#define ss(a, b, t) smoothstep(a, b, t)\n\n// Dave hoshkin hash\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3czr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 71, 71, 618]], "test": "untested"}
{"id": "wlcczr", "name": "Marshmallow tunnel", "author": "leon", "description": "(っ˘ڡ˘ς)", "tags": ["tunnel", "marshmallow"], "likes": 20, "viewed": 909, "published": 3, "date": "1608347351", "time_retrieved": "2024-07-30T20:29:31.681056", "image_code": "\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    color = texture(iChannel0, coordinate/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// Marshmallow tunnel\n//\n// Leon Denise 2020.12.19\n// Licensed under hippie love conspiracy\n//\n\n// repeat coordinate\n#define repeat(p,r) (mod(p,r)-r/2.)\n\n// rotation matrix\nmat2 rotation(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat material;\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// signed distance field\nfloat map(vec3 pos)\n{\n    vec3 p = pos;\n    float dist = 100.;\n    float shape = 100.;\n    float falloff = 1.0;\n    float range = 2.4;\n    const int count = 5;\n    \n    // rotation based on z axis\n    float t = p.z*0.2+213.+iTime*0.1;\n    \n    for (int index = 0; index < count; ++index)\n    {\n        // fold space (.xz = .xy is an error, but interesting enough to be saved in a shadertoy for later)\n        pos.xz = abs(pos.xy)-range*falloff;\n        \n        // rotations\n        pos.yz *= rotation(t/falloff);\n        pos.xy *= rotation(t/falloff);\n        \n        // shape\n        shape = length(pos)-2.6*falloff;\n        \n        // material system inspired by evvvvil\n        material = shape < dist ? float(index) : material;\n        \n        // add to volume\n        dist = min(dist, shape);\n        \n        falloff /= 1.2;\n    }\n\n    // shell\n    dist = abs(dist);\n\n    // surface matter\n    vec3 seed = pos * 12.;\n    float matter = sin(seed.x + abs(cos(seed.y)));\n    matter = pow(abs(matter), 0.3);\n    matter += pow(abs(sin(length(pos)*10.)), 0.3) * 2.;\n    dist -= matter * 0.1;\n\n    return dist;\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    color = vec4(0,0,0,1);\n    \n    // coordinates\n    vec2 uv = 2.*(coordinate-0.5*iResolution.xy)/iResolution.y;\n    vec3 camera = vec3(2,1,-4);\n    vec3 ray = normalize(vec3(uv,1.));\n    float rng = hash12(coordinate+iTime);\n    \n    // camera animation\n    camera.y += sin(iTime*0.3)*0.05;\n    \n    // mouse control\n    vec2 mouse = (iMouse.xy / iResolution.xy * 2. - 1.) * step(0.5, iMouse.z);\n    ray.yz *= rotation(-mouse.y);\n    ray.xz *= rotation(.2-mouse.x);\n    \n    // raymarch iteration\n    const int count = 40;\n    for (int index = 0; index < count; ++index)\n    {\n        // distance field\n        float dist = map(camera);\n        \n        // collide with volume\n        if (dist < 0.1)\n        {\n            // coloring\n            float shade = float(count-index)/float(count);\n            \n            // palette from Inigo Quilez\n            // https://iquilezles.org/articles/palettes\n            vec3 tint = vec3(0.75) + vec3(0.25) * cos(3.14*(vec3(1,2,3)*(shade*1.1+material+uv.x*.1)));\n            color = vec4(tint*shade, 1);\n            break;\n        }\n        \n        // march\n        dist *= 0.6 + 0.1 * rng;\n        camera += ray * dist;\n    }\n    \n    // fade in\n    color *= smoothstep(0.0, 1.0, iTime);\n    \n    // temporal dithering\n    color = mix(color, texture(iChannel0, coordinate/iResolution.xy), 0.7);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlcczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 55, 55, 116]], "test": "untested"}
{"id": "wsGfD3", "name": "heavy metal squiggle orb", "author": "mattz", "description": "An infinite variety of ornate spherical Truchet tilings.\n\nMouse rotates, click in lower left to restore auto-rotation. See comments at top of image code for keys.", "tags": ["raymarched", "truchet", "tiling", "spherical", "polyhedron", "wythoff"], "likes": 88, "viewed": 2767, "published": 3, "date": "1608339062", "time_retrieved": "2024-07-30T20:29:32.728256", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// \"heavy metal squiggle orb\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// An infinite variety of ornate spherical Truchet tilings.\n//\n// Demo automatically cycles through a \"playlist\" of 16 polyhedra.\n//\n// Use the mouse to rotate the orb or click in the lower-left corner\n// to restore automatic rotation.\n//\n// KEYS: (these break out of demo mode):\n//\n//   A/S prev/next in playlist\n//\n//   Q/W change symmetry (tetrahedral/octahedral/icosahedral)\n//   E/R modify vertex location (7 possibilities)\n//   T/Y modify random seed (2^16 possibilities!)\n//\n// To return to demo mode, press D (won't do anything if paused)\n//\n// See https://en.wikipedia.org/wiki/Uniform_polyhedron#Summary_tables\n// for all possibile polyhedra (note this shader doesn't implement the\n// snub variants).\n//\n// Background: I had a lot of fun writing \"rainbow noodle orbs\" \n// (https://www.shadertoy.com/view/tsVBDW) but the woven Truchet\n// tiling in that shader was too slow to raymarch. \n//\n// By using only single spherical arcs (torus segments) for each\n// connection within a tile, and by exploiting symmetries within\n// each tile, I was able to make things fast enough to raymarch \n// while still maintaining some really interesting diversity of\n// appearances.\n//\n//////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float TOL = 1e-5;\n\nivec3 setup = ivec3(3, 0, 0);\nfloat decorate = 1.0;\n\n#define MAX_POLYGON 10\n\n//////////////////////////////////////////////////////////////////////\n// inverse linear interpolation\n\nfloat unlerp(float lo, float hi, float x) {\n    return clamp((x-lo)/(hi-lo), 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/XlGcRh \n// original by Dave Hoskins\n\nvec3 hashwithoutsine31(float p) {\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about arbitrary axis/angle\n\nmat3 rotate(in vec3 k, in float t) {\n    \n    if (abs(t) < TOL) {\n        return mat3(1.);\n    }\n    \n    mat3 K = mat3(0, k.z, -k.y,\n                  -k.z, 0, k.x,\n                  k.y, -k.x, 0);\n                  \n    return mat3(1.) + (mat3(sin(t)) + (1. - cos(t))*K)*K;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Wythoff construction\n\nivec3 construct(in vec3 p, \n                out vec3 face_normal, out vec3 v_cur,\n                out float poly_edge_dist, out int nface) {\n               \n    //////////////////////////////////////////////////\n    // step 1: construct Schwarz triangle with vertex\n    // at (0, 0, 1) and along x=0 and y=0 planes\n    //\n    // this is a (P, Q, R) triangle with Q=3 and R=2\n    //\n    //  Q=3 *--__\n    //      |    ^^--__\n    /// R=2 *----------* P = 3, 4, or 5\n    //\n    // where p=3, 4, or 5\n   \n    int degree = setup.x;\n    int spoint = setup.y;\n    \n    float tp = PI / float(degree);\n    float cp = cos(tp);\n    \n    vec3 lp = vec3(1, 0, 0);\n    vec3 lq = vec3(0, 1, 0);\n\n    vec3 lr = vec3(-0.5, -cp, sqrt(0.75 - cp*cp));\n    \n    mat3 tri_edges = mat3(lp, lq, lr);\n    \n    vec3 vP = normalize(cross(lq, lr));\n    vec3 vR = vec3(0, 0, 1);\n    vec3 vQ = normalize(cross(lr, lp));\n    \n    mat3 tri_verts = mat3(vP, vQ, vec3(0, 0, 1));\n\n    //////////////////////////////////////////////////\n    // step 2: mirror point into triangle\n    \n    mat3 M = mat3(1.);\n    \n    mat3 Mr = mat3(1.) - 2.*outerProduct(lr, lr);\n\n    for (int i=0; i<5; ++i) {\n        if (p.x < 0.) { p.x = -p.x; M[0] = -M[0]; }\n        if (p.y < 0.) { p.y = -p.y; M[1] = -M[1]; }\n        if (dot(p, lr) < 0.) { p = reflect(p, lr); M *= Mr; }\n    }\n        \n    //////////////////////////////////////////////////\n    // step 3: polygon construction\n\n    ivec3 npoly = ivec3(0);\n    \n    vec3 poly_vertex;\n        \n    if (spoint == 0) {\n        // polygon vertex at degree-P triangle vertex, so all triangles\n        poly_vertex = vP;\n        npoly = ivec3(0, 1, 0);\n    } else if (spoint == 1) {\n        // polygon vertex at degree-3 triangle vertex, so all P-gons\n        poly_vertex = vQ;\n        npoly = ivec3(1, 0, 0);\n    } else if (spoint == 2) {\n        // polygon vertex at degree-2 triangle vertex, so alternation of triangles and P-gons\n        poly_vertex = vR;\n        npoly = ivec3(1, 1, 0);\n    } else if (spoint == 3) {\n        // polygon vertex at bisector of degree-P angle, alternation of 2P and triangles\n        poly_vertex = normalize(cross(lp, lq - lr));\n        npoly = ivec3(2, 1, 0);\n    } else if (spoint == 4) {\n        // polygon vertex at bisector of degree-Q angle, alternation of hexagons and P-gons\n        poly_vertex = normalize(cross(lq, lr - lp));\n        npoly = ivec3(1, 2, 0);\n    } else if (spoint == 5) {\n        // polygon vertex at bisector of degree-2 angle, alternation of triangles, P-gons, squares\n        poly_vertex = normalize(cross(lr, lp - lq));\n        npoly = ivec3(1, 1, 2);\n    } else {\n        // polygon vertex at circumcenter\n        poly_vertex = normalize(cross(lp - lq, lq - lr));\n        npoly = ivec3(2, 2, 2);\n    }\n    \n    mat3 poly_edges = mat3(normalize(cross(poly_vertex, lp)),\n                           normalize(cross(poly_vertex, lq)),\n                           normalize(cross(poly_vertex, lr)));\n        \n    poly_edge_dist = 1e5;\n    \n    vec3 pe = p * poly_edges;\n    bool is_even = true;\n    \n    ivec3 npolys = ivec3(degree, 3, 2) * npoly;\n    \n    v_cur = M * poly_vertex;\n\n    for (int vidx=0; vidx<3; ++vidx) {\n        \n        if (npoly[vidx] >= 0) {\n        \n            int idx0 = (vidx + 1) % 3;\n            int idx1 = (vidx + 2) % 3;\n                    \n            float d0 = pe[idx0];\n            float d1 = pe[idx1];\n            \n            if (d0 <= 0. && d1 >= 0.) {\n            \n                d0 = -d0;\n            \n                if (d0 < d1) {\n                    poly_edge_dist = d0;\n                } else {\n                    poly_edge_dist = d1;\n                }\n                \n                face_normal = M*tri_verts[vidx];\n                nface = npolys[vidx];\n                                \n            }\n            \n        }\n    }\n    \n    return npolys;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// squared distance from point p to a circle perpendicular to vector n \n// passing thru point p0\n\nfloat dcircle2(vec3 p, vec3 n, vec3 p0) {\n\n    float k = dot(p0, n);\n    \n    vec3 c = k*n;\n    \n    p -= c;\n    p0 -= c;\n    \n    float z = dot(p, n);\n    \n    vec3 xy = p - z*n;\n    \n    vec3 pc = normalize(xy)*length(p0);\n    \n    vec3 q = p - pc;\n    \n    return dot(q, q);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance function\n\nvec2 map(in vec3 p) {\n\n\n    p = rotate(vec3(0.18549298, 0.58241682, 0.79144362), 0.5) * p;\n\n    // phases for animation\n    float crack_visibility = smoothstep(0.0, 0.45, decorate);\n    float torus_visibility = smoothstep(0.55, 1.0, decorate);\n    \n    ////////////////////////////////////////////////////////////\n    // Wythoff construction\n\n    float extra = float(setup.z);\n    \n    vec3 face_normal, v_cur;\n    float poly_edge_dist;\n    int nface;\n    \n    ivec3 npolys = construct(p, \n                             face_normal, v_cur,\n                             poly_edge_dist, nface);\n                             \n    ////////////////////////////////////////////////////////////\n    // Compute the canonical index of the current polygon \n    // vertex from 0 ... nface - 1\n    \n    vec3 r0 = vec3(0.7027036, 0.68125974, 0.56301879);\n    vec3 r1 = vec3(0.65254045, 0.98167042, 0.49662301);\n    \n    float dr0 = abs(dot(face_normal, r0));\n    float dr1 = abs(dot(face_normal, r1));\n    \n    vec3 rando_dir = dr0 < dr1 ? r0 : r1;\n    \n    vec3 basis_u = normalize(cross(rando_dir, face_normal));\n    vec3 basis_v = cross(face_normal, basis_u);\n    \n    vec2 uv = (vec2(dot(v_cur, basis_u), dot(v_cur, basis_v)));\n\n    float rot_angle = 0.5 + 0.5*atan(uv.y, uv.x)/PI;\n    float fnface = float(nface);\n    \n    float idx = floor(rot_angle*fnface);\n\n    ////////////////////////////////////////////////////////////\n    // Now set up to do compute the torus distances\n    \n    // Rotation by angle increment\n    float dtheta = 2.*PI/fnface;    \n    mat3 R = rotate(face_normal, dtheta);\n    \n    // Get second-closest vertex\n    vec3 v_next = dot(p, cross(v_cur, face_normal)) < 0. ? R*v_cur : v_cur*R;\n\n    // Figure out whether we're doing one or two nodes per\n    // polygon edge (note odd-numbered polygons like triangles\n    // and pentagons require this)\n    bool use_midpoint = (npolys % 2 == ivec3(0)) && setup.xy != ivec2(4, 1);\n\n    // Compute torus minor radius\n    float kwidth = use_midpoint ? 0.16 : 0.07;\n    float torus_r0 = kwidth*acos(dot(v_cur, v_next));    \n\n    // Fraction to sink torii down into sphere\n    float sink_by = 1.0 - mix(1.01*torus_r0, 0.25*torus_r0, torus_visibility);\n        \n    // Random vector per face\n    face_normal = normalize(face_normal);\n    vec3 rface = hashwithoutsine31(floor(64.*dot(face_normal, rando_dir) + extra + 0.5));\n    \n    // Choose a random integer rotation for symmetric tiles\n    float ioffs = floor(rface.z * fnface);\n\n    // We need to keep nodes closer together if there are triangles\n    // or squares in this tiling\n    bool any34 = any(equal(npolys, ivec3(3))) || any(equal(npolys, ivec3(4)));\n\n    // How close together to put two nodes on same edge \n    // (closeness = 1 means midpoint of edge)\n    float closeness = use_midpoint ?  1.0 : any34 ? 0.65 : 0.55;\n\n    ////////////////////////////////////////////////////////////\n    // Time to compute the torus distances!\n    \n    float d_torus = 1e5;\n    \n    if (rface.x < 0.75) {\n\n        // Bilaterally symmetric cell - expensive distance \n        // query to multiple torii\n\n        // Canonical polygon vertex 0 and vertex 1 \n        vec3 p0 = rotate(face_normal, (ioffs - idx)*dtheta) * v_cur;\n        vec3 p1 = R*p0;\n\n        // Nodes along canonical edge\n        vec3 n0 = sink_by*normalize(p0 + closeness*p1);\n        vec3 n1 = sink_by*normalize(closeness*p0 + p1);\n\n        // Polygon edge\n        vec3 polygon_edge = cross(p0, p1);\n        \n        // Choose centerline for bilateral symmetry.\n        // No big difference for odd polygons but\n        // two distinct looks for even polygons.\n        \n        vec3 pc;\n                        \n        if ((!use_midpoint && rface.y < 0.45)) {\n            // arc centers distributed along\n            // line passing thru edge midpoint\n            pc = p0 + p1;\n        } else {\n            // arc centers distributed along\n            // line passing thru vertex\n            pc = p0;\n        }\n\n        vec3 center_line = cross(pc, face_normal);\n        vec3 lateral_line = cross(center_line, face_normal);\n                \n        int cnt = nface / 2 + 1;\n        \n        // We may be able to take advantage of extra symmetry\n        // so make a copy of current point to do so\n        vec3 p_torus = p;\n\n        if (nface % 2 == 0) {\n            if (dot(p_torus, lateral_line) > 0.) { \n                p_torus = reflect(p_torus, normalize(lateral_line)); \n            }\n            cnt = nface / 4 + 1;\n        }\n        \n        for (int i=0; i<MAX_POLYGON; ++i) {\n\n            if (i >= cnt) { break; }\n\n            vec3 ctr = normalize(cross(polygon_edge, center_line));\n\n            d_torus = min(d_torus, dcircle2(p_torus, ctr, n0));\n\n            if (!use_midpoint) {\n                d_torus = min(d_torus, dcircle2(p_torus, ctr, n1));\n            }\n\n            n0 = R*n0;\n            n1 = R*n1;\n\n            polygon_edge = R*polygon_edge;\n\n        }\n\n    } else {\n    \n        // Radially symmetric cell\n\n        // Nodal point is between cur vertex and next vertex\n        vec3 v_node = normalize(v_cur + closeness*v_next);\n        \n        vec3 ctr;\n            \n        if (use_midpoint) {\n\n            // Center torus on previous or current vertex?\n            if (mod(idx, 2.0) == step(rface.y, 0.5)) {\n                ctr = v_cur;\n            } else {\n                ctr = v_next;\n            }\n            \n        } else {\n        \n            float p_vertex = (nface == 3 ? 0.5 : 0.95);\n        \n            // Vertex-centered or edge-centered torus?\n            if (rface.y < p_vertex) {\n                ctr = v_cur;\n            } else {\n                ctr = normalize(v_cur + v_next);\n            }\n\n        }\n    \n        // Compute distance\n        d_torus = dcircle2(p, ctr, sink_by*v_node);\n    \n    }\n    \n    // We postponed some sqrt calls when computing torus distances\n    d_torus = sqrt(d_torus) - torus_r0;\n    \n    ////////////////////////////////////////////////////////////\n    // Do final distance & material computation\n    \n    float crack_size = mix(-2e-3, 0.18*torus_r0, crack_visibility);\n\n    float d_sphere = length(p) - 1.0;\n\n    float d_uncracked = min(d_torus, d_sphere);    \n    \n    float d_crack = poly_edge_dist - crack_size;\n    \n    float d_crack_subtracted = max(d_uncracked, -d_crack);\n    \n    float d_eroded = d_uncracked + max(1.5*crack_size, 0.);\n    \n    float material = step(d_torus, d_sphere) + 1.0;\n    if (d_crack < 1e-3) { material = 0.0; }\n    \n    float d_final = min(d_crack_subtracted, d_eroded);\n    \n    return vec2(d_final, material);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// IQ's distance marcher\n\nvec2 castRay(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n\n    const float precis = 0.002;   \n    \n    float h = 2.0*precis;\n\n    float t = tmin;\n    float m = -1.0;\n    \n    const int rayiter = 50;\n    \n    vec3 color;\n\n    for( int i=0; i<rayiter; i++ ) {\n\n        if( abs(h)<precis||t>tmax ) { break; }\n        \n        t += h;\n        \n        vec2 res = map( ro+rd*t );\n\n        h = res.x;\n        m = res.y;\n        \n    }    \n\n    if (t > tmax) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// IQ's normal calculation. \n\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 q;\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// From IQ: https://www.shadertoy.com/view/ldX3R8\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 2.0;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Rendering function\n\nvec3 shade( in vec3 ro, in vec3 rd, mat3 rot, float tmin, float tmax){\n\n    vec2 tm = castRay(ro, rd, tmin, tmax);        \n    \n    mat3 rtex = rot * rotate(vec3(1, 0, 0), 0.25);\n\n    if (tm.y < 0.0) {\n\n        return texture(iChannel1, rd*rtex).xyz;\n\n    } else {        \n\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n        \n        vec3 color = vec3(1);\n        \n        vec3 rray = reflect(-ro, n);\n\n        vec3 scolor = (tm.y == 2. ? vec3(1, 0.8, 0.65) : vec3(1));\n        \n        float sstrength = 0.5;\n        float sexp = 20.0;\n        \n        if (tm.y == 2.) {\n            color = scolor;\n            scolor *= texture(iChannel2, rray*rtex).xyz * mix(scolor, vec3(1), 0.75);\n            sstrength = 0.95;\n        } else {\n            color = vec3(0.1);\n            scolor = texture(iChannel1, rray*rtex).xyz;\n            if (tm.y == 0.) {\n                color *= 0.5;\n                sstrength = 0.05;\n            }\n\n        }\n        \n        //color = scolor = vec3(1);\n        \n        pos -= n * map(pos).x;\n        \n        vec3 L = normalize(vec3(-0.25, 1.0, 1.0));\n        L = rot*L;\n\n        vec3 diffamb = (0.7*clamp(dot(n, L), 0.0, 1.0) + 0.3) * color;\n\n        return mix(diffamb, scolor, sstrength) * ambientOcclusion(pos, n);\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// do the things\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // distance from camera to sphere centers\n    const float cdist = 6.0;\n    \n    // center-relative fragment coordinates\n    vec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n        \n    // focal length in pixels\n    float f = 0.45/iResolution.y;\n    \n    // approx size of orb in pixels\n    float xlim = 1.1/(cdist*f);\n\n    // fetch state from previous render pass\n    vec4 cur_state = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 next_state = texelFetch(iChannel0, ivec2(1, 0), 0);\n    \n    // handle interpolating between states\n    float which = 0.0;\n    \n    // are we transitioning?\n    if (next_state.x != 0.0) {\n\n        // at which = 0, cur_state, which = 1, next_state\n        which = unlerp(cur_state.w, next_state.w, iTime);\n\n        // stagger state transition by screen x coord\n        float delta = clamp(-uv.x/xlim, -1.0, 1.0);\n\n        // bigger k means smaller transition band\n        float k = 0.2; \n        \n        // minimum transition band size\n        const float gutter = 0.01;\n        \n        // which is always between 0 and 1\n        which = unlerp(k, 1.0-k, which + k*delta);\n        \n        // remove sphere decorations when which near 0.5\n        decorate = unlerp(gutter, 1.0, 2.0*abs(fract(which)-0.5));\n        \n        if (cur_state.xy == next_state.xy) {\n            decorate = 0.5*decorate + 0.5;\n        }\n        \n\n    }\n\n    // get vertex degree, triangle point, random seed for this fragment\n    setup = ivec3(which <= 0.5 ? cur_state.xyz : next_state.xyz);\n        \n    // error checking\n    if (setup.x < 3 || setup.x > 5 || setup.y < 0 || setup.y > 6) {\n        fragColor = vec4(1, 0, 0, 0);\n        return;\n    }\n\n    // set up rotation vector    \n    float t = iTime;\n    vec2 theta;\n        \n    theta.y = 2.*PI*t/6.0;\n    theta.x = 0.35*PI*sin(2.*PI*t/15.0);\n       \n    if (max(iMouse.x, iMouse.y) > 0.1*iResolution.y) { \n        theta.x = (iMouse.y - .5*iResolution.y) * 5.0/iResolution.y; \n        theta.y = (iMouse.x - .5*iResolution.x) * -10.0/iResolution.x; \n    }\n    \n    // ray origin and direction\n    vec3 rd = normalize(vec3(f*uv, -1));\n    vec3 ro = vec3(0, 0, cdist);\n    \n    // handle orb rotation\n    mat3 R = rotate(vec3(0, 1, 0), theta.y)*rotate(vec3(1, 0, 0), theta.x);\n \n    // trace scene\n    vec3 color = shade(R*ro, R*rd, R, cdist-1.2, cdist+1.2);        \n\n    // \"gamma correct\" :P\n    color = pow(color, vec3(0.7));\n\n    fragColor = vec4(color, 1);\n    \n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////////////////////////////////////////////////////\n// this buffer just manages state and keypresses\n//\n// state is stored in a feedback render texture with just \n// four texels\n//\n//   0,0: cur_setup.xyz,    transition start time\n//   1,0: next_setup.xyz,   transition end time\n//   2,0: queued_setup.xyz  pending\n//   3,0: prev_time, cur_time, !animating, idx\n//\n\n//////////////////////////////////////////////////////////////////////\n// vertex degree and point location for spherical polyhedra\n\n#define UNIQUE_SETUPS 16\n\nconst ivec2 playlist[UNIQUE_SETUPS] = ivec2[UNIQUE_SETUPS](\n\n    ivec2(5, 4), // S **** 5.6.6     truncated icosahedron\n    ivec2(3, 2), // L **   3.3.3.3   octahedron\n    ivec2(4, 6), // M **** 4.6.8     truncated cuboctahedron\n    ivec2(5, 5), // S ***  3.4.5.4   rhombicosidodecahedron\n    ivec2(3, 0), // L **   3.3.3     tetrahedron    \n    ivec2(5, 6), // M **** 4.6.10    truncated icosidodecahedron\n    ivec2(3, 6), // L ***  4.6.6     truncated octahedron \n    ivec2(5, 2), // S ***  3.5.3.5   icosidodecahedron\n    ivec2(4, 1), // L **   4.4.4     cube\n    ivec2(5, 0), // M ***  3.3.3.3.3 icosahedron\n    ivec2(4, 3), // S *    3.8.8     truncated cube\n    ivec2(4, 5), // M ***  3.4.4.4   rhombicuboctahedron\n    ivec2(5, 3), // S **   3.10.10   truncated dodecahedron\n    ivec2(3, 5), // M ***  3.4.3.4   cuboctahedron \n    ivec2(5, 1), // M ***  5.5.5     dodecahedron\n    ivec2(3, 3)  // M *    3.6.6     truncated tetrahedron\n\n);\n\n// time to transition between settings\nconst float transition_duration = 1.25;\n\n// how long to show each orb for\nconst float demo_example_duration = (60.0 / float(UNIQUE_SETUPS));\n\n// detect key press - https://www.shadertoy.com/view/4dGyDm useful\n// to debug key codes\nbool key_press(int key) {\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x != 0.;\n}\n\n// handle state \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    ivec2 fc = ivec2(fragCoord);\n       \n    // ignore everything outside our storage area\n    if (fc.x > 3 || fc.y > 0) { return; }\n\n    // get all four texels\n    vec4 cur_setup = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 next_setup = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec4 queued_setup = texelFetch(iChannel0, ivec2(2,0), 0);\n    vec4 time = texelFetch(iChannel0, ivec2(3,0), 0);\n    \n    // pause detection, see https://www.shadertoy.com/view/XdtyWB\n    bool is_paused = (iFrame != 0 && time.x == iTime);\n    \n    // initialize\n    if (iFrame == 0 || cur_setup.x == 0.) {\n        cur_setup = vec4(vec2(playlist[0]), 2.0, iTime);\n        next_setup = vec4(0);\n        queued_setup = vec4(0);\n        time = vec4(0, 0, demo_example_duration, 0);\n    }\n\n    // handle modification of setup by keyboard or demo\n    vec3 modified_setup = (queued_setup.x != 0. ? queued_setup.xyz :\n                           next_setup.x != 0. ? next_setup.xyz : cur_setup.xyz);\n                           \n\n    // we will reset the demo if kbd hit\n    float reset_demo = 1.0;\n    \n    bool changed = false;\n    bool reset_w = false;\n    \n    // handle keyboard\n    if (key_press(81)) {\n        modified_setup.x = 3.0 + mod(modified_setup.x + 2.0, 3.0);\n        changed = reset_w = true;\n    } else if (key_press(87)) {\n        modified_setup.x = 3.0 + mod(modified_setup.x + 1.0, 3.0);\n        changed = reset_w = true;\n    } else if (key_press(69)) {\n        modified_setup.y = mod(modified_setup.y + 6.0, 7.0);\n        changed = reset_w = true;\n    } else if (key_press(82)) {\n        modified_setup.y = mod(modified_setup.y + 1.0, 7.0);\n        changed = reset_w = true;\n    } else if (key_press(84)) {\n        modified_setup.z = mod(modified_setup.z + 65535., 65536.);\n        changed = true;\n    } else if (key_press(89)) {\n        modified_setup.z = mod(modified_setup.z + 1., 65536.);\n        changed = true;\n    } else if (key_press(65)) {\n        time.w = mod(time.w + float(UNIQUE_SETUPS) - 1.0, float(UNIQUE_SETUPS));\n        modified_setup.xy = vec2(playlist[int(time.w)]);\n        changed = true;\n    } else if (key_press(83)) {\n        time.w = mod(time.w + 1.0, float(UNIQUE_SETUPS));\n        modified_setup.xy = vec2(playlist[int(time.w)]);\n        changed = true;    \n    } else if (key_press(68)) { \n        // turn on demo mode\n        time.z = iTime + demo_example_duration;\n    } else if (time.z >= 0.) {\n        float demo_transition_time = time.z - transition_duration;\n        if (iTime > demo_transition_time) {\n            // time to change the demo example\n            time.w = mod(time.w + 1.0, float(UNIQUE_SETUPS));\n            cur_setup.w = demo_transition_time;\n            next_setup = cur_setup;\n            next_setup.xy = vec2(playlist[int(time.w)]);\n            if (time.w == 0.) {\n                next_setup.z = mod(next_setup.z + 1., 65536.);\n            }\n            next_setup.w = time.z;\n            queued_setup = vec4(0);\n            time.z += demo_example_duration;\n        }\n    }\n    \n    // match to playlist entry or seek to start\n    if (reset_w) {\n        time.w = 0.0;\n        ivec2 s = ivec2(modified_setup.xy);\n        for (int i=0; i<UNIQUE_SETUPS; ++i) {\n            if (playlist[i] == s) {\n                time.w = float(i);\n                break;\n            }\n        }\n    }\n    \n    if (changed) {\n\n        if (next_setup.x != 0.) {\n            queued_setup.xyz = modified_setup;\n        } else {\n            cur_setup.w = iTime;\n            next_setup = vec4(modified_setup, iTime + transition_duration);\n        }\n\n        time.z = -1.0;\n\n    }\n    \n    // if next setup pendinfg\n    if (next_setup.x != 0.) {\n    \n        // if paused change over immediately\n        if (is_paused) {\n            if (queued_setup.x != 0.) {\n                cur_setup = queued_setup;\n                next_setup = vec4(0);\n                queued_setup = vec4(0);\n            } else {\n                cur_setup = next_setup;\n                next_setup = vec4(0);\n            }\n        } else if (next_setup.w < iTime) {\n            // not paused, change over when necessary\n            cur_setup = next_setup;\n            if (queued_setup.x != 0.) { \n                // we have a buffered transition\n                cur_setup.w = iTime;\n                next_setup = vec4(queued_setup.xyz, iTime + transition_duration);\n                queued_setup = vec4(0);\n            } else {\n                next_setup = vec4(0);\n            }\n        }\n        \n    }\n\n    // store state\n    if (fc == ivec2(0, 0)) {\n        fragColor = cur_setup;\n    } else if (fc == ivec2(1, 0)) { \n        fragColor = next_setup;\n    } else if (fc == ivec2(2, 0)) {\n        fragColor = queued_setup;\n    } else { \n        time.x = time.y;\n        time.y = iTime;\n        fragColor = time;\n    }\n\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGfD3.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1663, 1663, 1706, 1706, 1752], [1901, 1901, 1934, 1934, 2070], [2181, 2181, 2217, 2217, 2459], [2557, 2557, 2697, 3053, 6419], [6590, 6590, 6631, 6631, 6874], [6969, 6969, 6990, 6990, 13568], [13667, 13667, 13729, 13729, 14176], [14279, 14279, 14311, 14311, 14562], [15131, 15131, 15201, 15201, 16415], [16506, 16506, 16563, 16610, 18998]], "test": "untested"}
{"id": "wl3czn", "name": "Audio Waveform Visualizer v5", "author": "oneshade", "description": "Version five of my audio waveform visualizer. By the way, the surface you are seeing is a histogram of the audio channel. Important note: if the resolution changes it will get messed up :(", "tags": ["3d", "visualization", "waveform"], "likes": 7, "viewed": 272, "published": 3, "date": "1608329938", "time_retrieved": "2024-07-30T20:29:33.655776", "image_code": "// Uncomment for a smooth surface\n//#define SMOOTH_SURFACE\n\n#define SIN_25 0.42261826174\n#define COS_25 0.90630778703\n\nfloat mapScene(in vec3 p) {\n    const vec2 res = vec2(0.2);\n    vec2 uv = 0.25 * p.xz + 0.5;\n\n    vec2 cell = floor(uv / res) * res;\n    vec2 local = fract(uv / res);\n\n    #ifdef SMOOTH_SURFACE\n    local *= local * (3.0 - 2.0 * local);\n    #endif\n\n    float ld = texture(iChannel0, cell).x;\n    float rd = texture(iChannel0, cell + vec2(res.x, 0.0)).x;\n    float lu = texture(iChannel0, cell + vec2(0.0, res.y)).x;\n    float ru = texture(iChannel0, cell + res).x;\n\n    float height = 2.0 * mix(mix(ld, rd, local.x), mix(lu, ru, local.x), local.y);\n    float sheet = max(abs(p.y - height) - 0.05, max(abs(p.x), abs(p.z)) - 2.0) * 0.5;\n\n    return sheet;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float time = iTime + texture(iChannel0, vec2(1.0)).x;\n    float c = cos(time), s = sin(time);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float dt = 0.0;\n    for (int iter=0; iter < 200; iter++) {\n        vec3 p = ro + rd * dt;\n\n        p.y += 0.5;\n        p.yz *= mat2(COS_25, SIN_25, -SIN_25, COS_25);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.xz *= mat2(c, -s, s, c);\n            n.yz *= mat2(COS_25, -SIN_25, SIN_25, COS_25);\n\n            vec2 uv = 0.25 * p.xz + 0.5;\n            fragColor.rgb += mix(mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), uv.x), mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), uv.x), uv.y);\n            fragColor.rgb *= max(0.3, dot(n, l));\n\n            break;\n        }\n\n        if (d > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, (fragCoord + vec2(1.0, 0.0)) / iResolution.xy);\n    if (int(fragCoord.x) == int(iResolution.x) - 1) {\n        fragColor = vec4(texture(iChannel1, vec2(fragCoord.y / iResolution.y, 0.0)).x, 0.0, 0.0, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl3czn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 146, 146, 773], [775, 775, 802, 802, 1109], [1111, 1111, 1166, 1166, 2242]], "test": "untested"}
{"id": "3sGBWt", "name": "Sphere Fractal Cave Test 4", "author": "sdfgeoff", "description": "Added smoothing and allowed different scale cubes", "tags": ["fractal", "cave", "fly"], "likes": 3, "viewed": 368, "published": 3, "date": "1608326238", "time_retrieved": "2024-07-30T20:29:34.598256", "image_code": "/// Convert from a buffer of normals/depth into something pretty\n#define BUFFER_WORLD iChannel0\n#define BUFFER_STATE iChannel1\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //vec2 screen_coords = (fragCoord/iResolution.xy);\n    //vec4 world = texture(WORLD_BUFFER, screen_coords);\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    // sample previous tile\n    #ifdef HQ\n    vec4 previous = vec4(0.0);\n    #else\n    vec4 previous = sample_tile(BUFFER_WORLD, iResolution.xy, uv, 1.0);\n    #endif\n    \n    mat4 camera_transform = quat_to_transform(\n        read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION),\n        read_data(BUFFER_STATE, ADDR_CAMERA_POSITION).xyz\n    );\n    \n\n    // Output to screen\n    vec4 data = raymarch(\n        iResolution.xy,\n        uv,\n        previous,\n        camera_transform\n    );\n    \n    float dist = data.a;\n    vec3 end_position = data.xyz;\n    \n    vec3 surface_normal = calc_normal(end_position);\n    \n    float lighting = dot(surface_normal, vec3(0.5)) * 0.5 + 0.5;\n    \n    float fog = dist * 0.25;//pow(dist, 2.0);\n    \n    vec3 col = vec3(0.5, 0.6, 0.9);\n    col *= lighting;\n    col = mix(col, vec3(1.0, 0.9, 0.8), fog);\n    \n    fragColor = vec4(col, 1.0);\n    \n    if (iMouse.z > 0.0) {\n        //fragColor = sample_tile(iChannel0, iResolution.xy, uv, 1.0);\n        fragColor = vec4(texture(BUFFER_WORLD, uv).a) * 0.1;\n    }\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// STATE\n\n#define BUFFER_STATE iChannel0\n#define BUFFER_KEYBOARD iChannel1\n\n\n// Return the state of a key\nfloat get_key(int key_code) {\n    return texelFetch(BUFFER_KEYBOARD, ivec2(key_code,0), 0).x;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 address = ivec2(fragCoord);\n    \n    if (address == ADDR_CAMERA_POSITION) {\n        // Move the camera based on keypress\n    \tvec4 camera_position = read_data(BUFFER_STATE, ADDR_CAMERA_POSITION);\n        \n        if (iTime < 0.1) {\n            camera_position = vec4(0.0, 0.0, 7.0, 0.0);\n        }\n        \n        \n        vec3 translation = read_data(BUFFER_STATE, ADDR_CAMERA_LIN_VELOCITY).xyz;\n        \n        // Convert to local coordinate system\n        mat4 orientation = quat_to_transform(\n            read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION),\n            vec3(0.0)\n        );\n        translation = (orientation * vec4(translation, 0.0)).xyz;\n        translation *= iTimeDelta;\n        \n        camera_position.xyz += translation;\n        fragColor = camera_position;\n        return;\n    }\n    \n    \n    if (address == ADDR_CAMERA_ORIENTATION) {\n        // Rotate the camera based on keypress\n        vec4 camera_orientation = read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION);\n        \n        if (iTime < 0.1) {\n            camera_orientation = quat_from_axis_angle(vec3(0.0, 1.0, 0.0), 0.3);\n        }\n        \n        vec4 velocity = read_data(BUFFER_STATE, ADDR_CAMERA_ANG_VELOCITY);\n        velocity *= iTimeDelta;\n        \n        \n        \n        vec4 pan = quat_from_axis_angle(vec3(0.0, 1.0, 0.0), velocity.x);\n        vec4 tilt = quat_from_axis_angle(vec3(1.0, 0.0, 0.0), velocity.y);\n        vec4 roll = quat_from_axis_angle(vec3(0.0, 0.0, 1.0), velocity.z);\n        \n        \n        camera_orientation = quat_mul(pan, camera_orientation); \n        camera_orientation = quat_mul(tilt, camera_orientation); \n        camera_orientation = quat_mul(roll, camera_orientation); \n        \n        fragColor = camera_orientation;\n        return;\n    }\n    if (address == ADDR_CAMERA_ANG_VELOCITY) {\n        vec4 velocity = read_data(BUFFER_STATE, ADDR_CAMERA_ANG_VELOCITY);\n        \n        vec3 acceleration = vec3(\n            get_key(KEY_PAN_LEFT) - get_key(KEY_PAN_RIGHT),\n            get_key(KEY_TILT_UP) - get_key(KEY_TILT_DOWN),\n            get_key(KEY_ROLL_RIGHT) - get_key(KEY_ROLL_LEFT)\n        ) * 10.0;\n        velocity.xyz += acceleration * iTimeDelta;\n        \n        vec4 drag = velocity * 10.0;\n        velocity -= drag * iTimeDelta;\n        \n        fragColor = velocity;\n        return;\n    }\n    if (address == ADDR_CAMERA_LIN_VELOCITY) {\n        vec4 velocity = read_data(BUFFER_STATE, ADDR_CAMERA_LIN_VELOCITY);\n        \n        vec3 acceleration = vec3(\n            get_key(KEY_RIGHT) - get_key(KEY_LEFT),\n            get_key(KEY_UP) - get_key(KEY_DOWN),\n            get_key(KEY_FORWARD) - get_key(KEY_BACKWARD)\n        ) * 5.0;\n        velocity.xyz += acceleration * iTimeDelta;\n        \n        vec4 drag = velocity * 5.0;\n        velocity -= drag * iTimeDelta;\n        \n        fragColor = velocity;\n        return;\n    }\n}\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define HQ\n\nconst ivec2 ADDR_CAMERA_POSITION = ivec2(0,0);\nconst ivec2 ADDR_CAMERA_ORIENTATION = ivec2(0,1);\nconst ivec2 ADDR_CAMERA_ANG_VELOCITY = ivec2(0,2);\nconst ivec2 ADDR_CAMERA_LIN_VELOCITY = ivec2(0,3);\n\nconst float LENS = 0.5;\n\nconst int KEY_LEFT = 65;\nconst int KEY_UP   = 82;\nconst int KEY_RIGHT = 68;\nconst int KEY_DOWN = 70;\nconst int KEY_FORWARD = 87;\nconst int KEY_BACKWARD = 83;\n\nconst int KEY_TILT_UP = 38;\nconst int KEY_TILT_DOWN = 40;\nconst int KEY_PAN_LEFT = 37;\nconst int KEY_PAN_RIGHT = 39;\nconst int KEY_ROLL_LEFT = 81;\nconst int KEY_ROLL_RIGHT = 69;\n\nconst float MAX_TILES = 3.0;\n\n#ifdef HQ\nconst int steps = 96;\n#else\nconst int steps = 32;\n#endif\n\n// Fetch a single pixe from a buffer\nvec4 read_data(sampler2D buffer, ivec2 address){\n    return texelFetch(buffer, address, 0);\n}\n\n\n\n// A surface is defined by a vec4. The rgb channels are the normal, the alpha\n// is the distance to the surface. This makes physics etc. very easy\nfloat sphere_sdf(vec3 query_point, float sphere_radius) {\n    float l = length(query_point);\n    float df = l - sphere_radius;\n    \n    return df;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat surface_intersect(float surface_1, float surface_2) {\n    // Find the volume both surface occupy\n    return max(surface_1, surface_2);\n}\nfloat surface_difference(float surface_1, float surface_2) {\n    // subtract surface_2 from surface_1\n    // invert surface 2:\n    return surface_intersect(surface_1, -surface_2);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smax( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return max( a, -b ) + h*h*k*(1.0/4.0);\n}\n\n\n\nfloat distance_field(vec3 co) {\n    float rad = clamp(co.z * 0.05 + 0.45, 0.1, 0.3);\n    //float rad = 0.45;\n    co = mod(co, vec3(1.0)) - 0.5;\n    //co = (co - clamp(round(co), -5.0, 5.0));\n    //return sphere_sdf(co, rad);\n    \n    return sdRoundBox(co, vec3(rad, rad, 0.3), 0.1);\n}\n\n\n// A simple fractal-like made by iterative transformation\nfloat sample_world(vec3 world_position) {\n\n    float body = 999.0;\n    vec3 co = world_position;\n    //co.z *= 0.5;\n    \n    float scale = 0.2;\n    mat4 m = mat4(\n\t\tvec4(0.6373087, -0.0796581,  0.7664804, 0.0),\n  \t\tvec4(0.2670984,  0.9558195, -0.1227499, 0.0),\n  \t\tvec4(-0.7228389,  0.2829553,  0.6304286, 0.0),\n        vec4(0.1, 0.6, 0.2, 0.0)\n    );\n    //mat4 m = mat4(1.0);\n    \n    for (int i=0; i<3; i++) {\n        co = (m * vec4(co, float(i))).xyz;\n        scale *= (3.0);\n        \n        float field = distance_field(co * scale) / scale;\n     \tbody = smin(body, field, 0.05);\n    }\n    \n    return -body;\n}\n\nvec3 calc_normal(vec3 sample_point) {\n    const float h = 0.01; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    \n    vec3 normal = normalize(\n\t\tk.xyy * sample_world( sample_point + k.xyy*h ) + \n\t\tk.yyx * sample_world( sample_point + k.yyx*h ) + \n\t\tk.yxy * sample_world( sample_point + k.yxy*h ) + \n\t\tk.xxx * sample_world( sample_point + k.xxx*h ) );\n    normal = normal.zyx;\n    return normal;\n}\n\n\nvec4 raymarch(vec2 resolution, vec2 uv, vec4 start_data, mat4 camera_transform) {\n    // Convert to range (-1, 1) and correct aspect ratio\n    vec2 screen_coords = (uv - 0.5) * 2.0;\n    screen_coords.x *= resolution.x / resolution.y;\n    \n    \n    vec3 ray_start_position = camera_transform[3].xyz;\n    \n    vec3 ray_direction = normalize(vec3(screen_coords * LENS, 1.0));\n    ray_direction = (camera_transform * vec4(ray_direction, 0.0)).xyz;\n    \n    \n    float dist = start_data.a * 0.9;\n    vec3 sample_point = ray_start_position + dist * ray_direction;\n    \n    float results = sample_world(sample_point);\n    \n    float tolerance = 0.0;\n    \n    for (int i=0; i<steps; i += 1) {\n        dist += results;\n        sample_point += ray_direction * results;\n        results = sample_world(sample_point);\n        \n        // TODO: Derive from resolution, camera lens and distance\n    \ttolerance = LENS / resolution.x * dist;\n        \n        if (results < tolerance || dist > 5.0) {\n        \tbreak; \n        }\n    }\n    \n    \n    \n    return vec4(sample_point, dist);\n}\n\n\n\n\n\n// Create a quaternion from axis-angle notation\nvec4 quat_from_axis_angle(vec3 axis, float angle) {\n    float factor = sin(angle) / 2.0;\n    float w = cos(angle) / 2.0;\n    return normalize(vec4(axis*factor, w));\n}\n\n// Convert a quaternion into a transformation matrix\nmat4 quat_to_transform(vec4 quat, vec3 translation) {\n    float qx = quat.x;\n    float qy = quat.y;\n    float qz = quat.z;\n    float qw = quat.w;\n    float qx2 = qx * qx;\n    float qy2 = qy * qy;\n    float qz2 = qz * qz;\n    \n \treturn mat4(\n        1.0 - 2.0*qy2 - 2.0*qz2,\t2.0*qx*qy - 2.0*qz*qw,\t2.0*qx*qz + 2.0*qy*qw, 0.0,\n    \t2.0*qx*qy + 2.0*qz*qw,\t1.0 - 2.0*qx2 - 2.0*qz2,\t2.0*qy*qz - 2.0*qx*qw, 0.0,\n    \t2.0*qx*qz - 2.0*qy*qw,\t2.0*qy*qz + 2.0*qx*qw,\t1.0 - 2.0*qx2 - 2.0*qy2, 0.0,\n        translation, 0.0\n    );\n}\n\n// Multiply two quaternions\nvec4 quat_mul(vec4 a, vec4 b) {\n \treturn vec4(\n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,\n        a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,\n        a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,\n        a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z\n    );   \n}\n\n\n\n\n\n\nvec2 tile_resolution(vec2 screen_resolution, float tile_id_f) {\n    float tile_height = 1.0 / pow(2.0, tile_id_f);\n    return screen_resolution * tile_height;\n}\n\n\nvec4 sample_tile(sampler2D buffer, vec2 resolution, vec2 uv, float tile_id_f) {\n    float tile_height = 1.0 / pow(2.0, tile_id_f);\n    \n    uv.x += 1.0;\n    vec2 area_uv = uv * tile_height;\n    \n    // Compensate for GL.LINEAR sampling - we need to sample the middle of the pixel\n    vec2 tile_resolution = resolution * tile_height;\n    vec2 inv_resolution = 1.0 / resolution.xy;\n    area_uv -= mod(area_uv, inv_resolution) - inv_resolution * 0.5;\n    \n    return texture(buffer, area_uv);\n}\n\n", "buffer_b_code": "// Render the world. \n//\n// Outputs:\n// - rgb = analytic normal\n// - a = depth\n//\n// Pretty much a single raymarcher\n\n#define BUFFER_STATE iChannel0\n#define BUFFER_SELF iChannel1\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifndef HQ\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tile_id_f = floor(log2(1.0 / uv.x)) + 1.0;\n    float tile_height = 1.0 / pow(2.0, tile_id_f);\n\n\t// Convert to coordinates for this tile    \n    vec2 tile_uv = vec2(uv / tile_height);\n   \ttile_uv.x -= 1.0;\n    \n    if (uv.y > tile_height || tile_id_f > MAX_TILES) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // sample previous tile\n    vec4 previous = sample_tile(BUFFER_SELF, iResolution.xy, tile_uv, tile_id_f + 1.0);\n    \n    \n    mat4 camera_transform = quat_to_transform(\n        read_data(BUFFER_STATE, ADDR_CAMERA_ORIENTATION),\n        read_data(BUFFER_STATE, ADDR_CAMERA_POSITION).xyz\n    );\n    \n    \n    vec4 data = raymarch(\n        tile_resolution(iResolution.xy, tile_id_f),\n        tile_uv,\n        previous,\n        camera_transform\n    );\n    \n    // Output to screen\n    fragColor = vec4(data);\n#endif\n}\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 187, 304, 1393]], "test": "untested"}
{"id": "Wl3czn", "name": "day 365", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 9, "viewed": 336, "published": 3, "date": "1608321976", "time_retrieved": "2024-07-30T20:29:35.452971", "image_code": "// I'VE LOST COUNT LOL, so I skipped to 365 which is the correct number! \n// tune in tomorrow for birthday stream at https://www.twitch.tv/wwrighter\n\nfloat df;\nfloat rep = 2.75;\nfloat sz;\n\n#define pi acos(-1.)\n\n#define pump(g,a) (floor(g) + pow(fract(g),a))\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\nmat2 rot(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat sdCirc (vec2 uv, float s){\n    return length(uv) - s;\n}\n\nfloat sdRect (vec2 uv, vec2 s){\n    uv = abs(uv)- s;\n    return max(uv.x,uv.y);\n}\nfloat sdRect (vec2 uv, float s){\n    uv = abs(uv)- s;\n    return max(uv.x,uv.y);\n}\nfloat sdCube (vec3 uv, float s){\n    \n    uv = abs(uv)- s;\n    uv.xz *= rot(0.);\n    return max(uv.x,max(uv.y,uv.z));\n}\n\nfloat sdSphere(vec3 p, float s){return length(p) -s;}\n\n//float sdCube(vec3 p, float s){return length(p) -s;\n\nfloat get(vec2 uv, vec2 id, float T){\n    //float dc = sdCirc(uv, sz*(0.1 + .1*sin(iTime + length(id))));\n    \n    T *= 0.1;\n    //d = 10e5;\n    //#define m(j) (sin(j + iTime+ id.x*1.*sin(iTime+id)*0.1  + length(id)*1.2 + iTime*.2) + sin(length(id))*1.)\n    #define m (sin(length(id/sz)*0.2 + T*11.)*0.5)\n\n    vec3 p = vec3(uv,0.1 + m*0.1);\n    p.x += m;\n    \n    \n    p.yz *= rot(-pi*(0.25 + pow(m,2.)*0.));\n    p.xy *= rot(pi*0.25);\n\n    //p.xy += m;\n    float dc = sdCube (p,sz*(0.1 + iMouse.x/iResolution.x*0.05 + pow(m,2.)*0.4)*2.);//*(0.9)*(1.-m));\n    \n    float d = abs(dc - 0.1*(1.-m));\n    //d = abs(d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 guv = uv;\n    uv *= 5.  ;\n    df = dFdx(uv.x);\n    sz = 1./rep;\n    \n    vec3 col = vec3(0);    \n    vec2 id = floor(uv*rep);\n    \n    uv = mod(uv,sz) - sz*0.5;\n    float d = 10e6;\n    #define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n     \n    float chrabs = 9.;\n    for(float chrab = 0.; chrab < chrabs; chrab++){\n        float overstep = 3.*2.*1.;\n        float nd = 10e5;\n        for(float i = 0.; i < overstep*overstep; i++){\n            vec2 idx = vec2(\n                mod( i,overstep)  - 0.5*overstep , \n                floor( (i)/overstep) - 0.5*overstep\n                );\n            nd = min(nd, get(uv - idx*sz, id + idx, iTime - 0.4*chrab/chrabs) - 0.04*chrab/chrabs);\n\n        }\n        \n        nd = max(nd,-d);\n        vec3 c = pal(.5,0.5,vec3(3,2,1. + sin(iTime)),1. ,41. + 6.*chrab/chrabs + iTime + length(guv)*0.4);\n        col = mix(col,c*(1.4-chrab/chrabs*1.64),smoothstep(df,0.,nd ));\n        \n    \n    }\n    col = smoothstep(0.,1.,col*2.);\n    col = pow(col,vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl3czn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 312, 334, 334, 402], [404, 404, 436, 436, 465], [467, 467, 498, 498, 548], [549, 549, 581, 581, 631], [632, 632, 664, 664, 751], [753, 753, 785, 785, 806], [862, 862, 899, 967, 1491], [1493, 1493, 1550, 1550, 2657]], "test": "untested"}
{"id": "3dyBW3", "name": "deck", "author": "lennyjpg", "description": "sdfafsdsdfasdf", "tags": ["gradient", "rotation", "polar", "double", "split", "screw"], "likes": 1, "viewed": 306, "published": 3, "date": "1608316570", "time_retrieved": "2024-07-30T20:29:36.266795", "image_code": "#define PI 3.14159265359\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime *-0.3;\n    vec2 u = uv;\n    float ratio = iResolution.x/iResolution.y;\n    u.x = fract(u.x * 2.);\n    float offset = floor(uv.x + 0.5);\n    t += offset;\n    u -= vec2(0.5);\n    u = rotate2d( t * PI) * u; \n    //float d = length(u);\n    //float c = step(d, 0.4);\n    //float c2 = step(d, 0.2);\n    //float g = fract(u.x)*fract(u.y);\n    float k = fract(atan(u.y,u.x)*0.2);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 53, 53, 139], [141, 141, 198, 198, 662]], "test": "untested"}
{"id": "3l3yzr", "name": "Colored Volumetric Mandelbulb", "author": "Zi7ar21", "description": "Volumetric Mandelbulb with Color. Looks so poggers!", "tags": ["raymarch", "volumetric", "nebula"], "likes": 3, "viewed": 346, "published": 3, "date": "1608312251", "time_retrieved": "2024-07-30T20:29:37.147441", "image_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// Common is for Settings and Global Functions\n// Buffer A is for Rendering\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Colored Volumetric Mandelbulb --- December 18th, 2020\n// Updated December 28th, 2020 13:00 Mountain Time\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/3l3yzr\n// Fork of \"Spooky Nebula\" by Zi7ar21. https://www.shadertoy.com/view/tsVcDt\n// October 30th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- August 8th, 2020\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- October 11th, 2020\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Rendering\n\n// Oof ugly mess below watch out lol\n\n// ##### Fractal #####\nfloat mandelbulb(vec3 pos, int iter) {\n\tfloat Power = float(2.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < iter; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, Power-1.0)*Power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Fractal Density\nint randexpiter(float iter){\n    return int(round((rand()*iter)+iter));\n}\n\nvec3 mandelbulbvolume(vec3 raypos){\n    vec3 dist = vec3(mandelbulb(raypos, randexpiter(16.0)), mandelbulb(raypos, randexpiter(8.0)), mandelbulb(raypos, randexpiter(4.0)));\n    vec3 density = -clamp(pow(dist, vec3(0.25)), 0.0, 0.1)+0.1;\n    return density;\n}\n\n// ##### RAYMARCHING #####\nvec3 directLight(vec3 raypos){\n    vec3 LightColor = vec3(16.0);\n    vec3 LightDirection = normalize(vec3(1.0));\n    float distorigin = 0.0;\n    vec3 density = vec3(0.0);\n    vec3 raydirmod = LightDirection*STEP_SIZE*rand();\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+raydirmod;\n        density = vec3(mandelbulbvolume(raypos)*DENSITY);\n        vec3 absorbance = exp(-density);\n        attenuation *= absorbance;\n    }\n    return LightColor*attenuation;\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    //vec3 densityadd = vec3(0.0);\n    //vec3 density = vec3(0.0);\n    vec3 raypos = camerapos;\n    vec3 raydirmod = (raydir*rand())*STEP_SIZE;\n    vec3 outCol = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos + raydirmod;\n        // LoicVDB: don't use this, the density doesn't accumulate, its\n        // only purpose is to compute absorbance and transmittance\n        //densityadd = vec3(fractal(raypos)*DENSITY);\n        //density = vec3(density+densityadd);\n\n        // LoicVDB: just use this for density instead:\n        vec3 density = vec3(mandelbulbvolume(raypos)*DENSITY);\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        vec3 transmittance = 1.0-absorbance;\n        vec3 directlighting = attenuation*transmittance;\n        if((density.r+density.g+density.b) > 0.0){\n            directlighting = directlighting*directLight(raypos);\n        }\n        outCol += directlighting;\n        attenuation *= absorbance;\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return outCol;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Start RNG\n    INIT_RNG;\n    // Camera Orientation\n    vec3 camerapos = vec3(2.0, -2.0, 2.0);\n    #ifdef ROTATION_MATRIX\n\t    // Dumb rotation matrix hecking Michael made me make\n\t    float xrot = atan(sqrt(2.0));\n\t    float yrot = pi;\n\t    float zrot = -pi/4.0;\n\t    // Camera Orientation (Cursed)\n        mat3 dir;\n\t    dir[0] = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\t    dir[1] = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\t    dir[2] = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,1.0,0.0);\n        vec3 zdir = vec3(0.0,0.0,1.0);\n    #endif\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n\n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n    #ifdef ROTATION_MATRIX\n    \tvec3 raydir = normalize(FOV*(uv.x*dir[0]+uv.y*dir[1])+dir[2]);\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n    #endif\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // Output\n    fragColor += vec4(raymarched, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Settings and Global Functions\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 64\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 8.0\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.125\n\n// Camera's FOV\n#define FOV 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n#define ROTATION_MATRIX\n\n// Density of the volume. Changes how much light it scatters.\n#define DENSITY 4.0\n\n// Bailout, a larger value makes rendering slower but more accurate. A value more than 4 is\n// sometimes helpful, but not always.\n#define Bailout 4.0\n\n// Tiles, more means easier on the Hardware\n#define TILES 4 // Set to 1 if you have a computer that can handle it so it will render faster\n// So kindly made by LoicVDB uwu\n\n// Yummy, Pi! 32-Bit Floating Point Precision limits us to 3.14159265, but hey one day Shadertoy\n// may support double precision so why not throw in 3589793.\n#define pi 3.141592653589793\n\n// High-Quality Noise https://www.shadertoy.com/view/tdGfWc\n#define INIT_RNG ns = uint(iFrame*24676) + uint(fragCoord.x*5557.0) + uint(fragCoord.y*8482.0);\nuint ns;\nvoid RNGupdate(){\n    // Integer hash copied from Hugo Elias\n\tns = (ns<<13U)^ns;\n    ns = ns*(ns*ns*15731U+789221U)+1376312589U;\n}\nfloat rand(){\n    RNGupdate();\n    return float((ns*ns)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l3yzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1141, 1141, 1197, 1247, 1354]], "test": "untested"}
{"id": "3t3yzr", "name": "Universal Waves", "author": "oneshade", "description": "Sizing a grid of spheres based on where they lie inside a volume. The volume is layered using sin() and the layers get offset by iTime. The extremely tiny spheres on the outside unintentionally created a cool starry effect :)", "tags": ["raymarching", "fakevolumetric", "spheregrid"], "likes": 31, "viewed": 376, "published": 3, "date": "1608311733", "time_retrieved": "2024-07-30T20:29:37.968246", "image_code": "// Hue to RGB conversion from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(h) 0.6 + 0.6 * cos(6.3 * h + vec3(0.0, 23.0, 21.0))\n\nfloat mapVolume(in vec3 p) {\n    float volume = dot(sin(0.5 * p), vec3(1.0));\n    float layers = sin(3.0 * volume - 2.0 * iTime);\n    return max(layers, volume);\n}\n\nfloat mapScene(in vec3 p) {\n    p /= 0.75;\n    vec3 cell = floor(p) * 0.75;\n    vec3 local = fract(p) * 0.75;\n    return (length(local - 0.325) + 0.3 * min(0.0, mapVolume(cell + 0.325))) * 0.6;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float time = 0.25 * iTime;\n    float c = cos(time), s = sin(time);\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float dt = 0.0;\n    for (int iter=0; iter < 150; iter++) {\n        vec3 p = ro + rd * dt;\n\n        p.yz *= mat2(c, s, -s, c);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.xz *= mat2(c, -s, s, c);\n            n.yz *= mat2(c, -s, s, c);\n\n            fragColor.rgb += hue2rgb(0.2 * length(p) + time);\n            fragColor.rgb *= max(0.3, dot(n, l));\n            break;\n        }\n\n        if (dt > 20.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3yzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 163, 163, 298], [300, 300, 327, 327, 495], [497, 497, 524, 524, 831], [833, 833, 888, 888, 1752]], "test": "untested"}
{"id": "3t3cRr", "name": "Mandelbrot domain coloring", "author": "darkeclipz", "description": "Phase portrait of the complex plane and applying a few iterations of z^2+c.", "tags": ["mandelbrot", "domain", "coloring"], "likes": 6, "viewed": 374, "published": 3, "date": "1608307886", "time_retrieved": "2024-07-30T20:29:38.767110", "image_code": "// https://users.mai.liu.se/hanlu09/complex/domain_coloring.html\n\n#define R iResolution.xy\nfloat pi = 3.14159;\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y - vec2(.5, 0);\n    float t = iTime + 6.;\n    float w = -cos(t / 4.)*.5+.5;\n    \n    // Apply function\n    vec2 z = vec2(0.0), c = uv;\n    for(int i=0; i < 1 + int(16.*w); i++) {\n        z = cpow(z, 2.0) + c;\n    }\n    uv = z;\n    \n    // Calculate polar coordinates\n    float r = sqrt(dot(uv, uv));\n    float theta = atan(uv.y, uv.x+0.000000001);\n    \n    // Normalize theta\n    float thetaNorm = (pi + theta) / (2.*pi);\n    \n    // Color the angle based on rainbow colors, and show the distance\n    float absW = fract(log2(length(uv)));\n    vec3 col = hsb2rgb(vec3(thetaNorm, 1., 1.));\n    // col *= * (0.1*absW + 0.9);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3cRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 142, 142, 171], [172, 172, 202, 202, 257], [258, 258, 288, 288, 358], [359, 359, 381, 381, 468], [469, 469, 490, 490, 515], [516, 516, 546, 546, 646], [647, 647, 673, 673, 905], [907, 907, 964, 964, 1678]], "test": "untested"}
{"id": "WtccRn", "name": "coincidences detector", "author": "FabriceNeyret2", "description": "People often underestimate the high probability of \"remarquable order\" in sequences of numbers.\nHere I color every regular sequence of at least 3, with higher intensity when longer.\nColor correspond to sequence direction. ", "tags": ["short", "randomness", "numerology", "chance"], "likes": 10, "viewed": 399, "published": 3, "date": "1608305174", "time_retrieved": "2024-07-30T20:29:39.560987", "image_code": "// utils from https://www.shadertoy.com/view/llySRh\n#define hash(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define char(c) textureLod( iChannel3, fract(u)/16. + fract( vec2(c, 15-c/16) / 16. ), log2(512./R.y) ).x\n\n#define num(p) int(48.+10.*hash(p))                             // random digit\n\nint hCheck(vec2 U, vec2 D, out int count) {\n    count = 0;\n    int  d = num(U+D) - num(U);                                 // value step in dir D, use a ref for candidate series\n        \n    vec2 P = D-D;\n    for( int i=0; i<6; i++, P+=D )                              // count series  U + kD\n        if ( num(U+P+D) - num(U+P) == d ) count++; else break;\n        \n    return d;                                                   // return increment, and out: count\n}\n\nfloat check(vec2 U,vec2 D)  {\n    int c,  d  =  hCheck(U, D,c ),                              // count upstream\n        cr, dr = -hCheck(U,-D,cr),                              // and downstream\n        count = d==dr ? c + cr :  max(c,cr) ;                   // return sequence count\n\n    return count + 1 >= 3 ? float( count - 1 )/10. : 0.;         // intensity = sequence length   \n  //return count + 1 >= 3;       \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = floor( u = u * 16. / R.y + iTime );\n\n    O = vec4( check(U,vec2(1,0)) + check(U,vec2(0,1)),          // check for series in all direction ( = color )\n              check(U,vec2(1,1)) + check(U,vec2(0,1)),          // intensity = length\n              check(U,vec2(1,-1)), 0);\n    O +=  char(num(U)) * ( length(O.rgb) < .5 ? 1. : -1.);      // draw number\n    \n    O = sqrt(O);                                                // to sRGB\n              \n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtccRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 354, 354, 777], [779, 779, 808, 808, 1197], [1199, 1199, 1237, 1237, 1730]], "test": "untested"}
{"id": "wsKBDd", "name": "Multi-Slime", "author": "dr2", "description": "Metallic goo with several blobs (based on \"Quick Slime 3D\")", "tags": ["reflection", "metaball", "dynamics"], "likes": 6, "viewed": 363, "published": 3, "date": "1608287146", "time_retrieved": "2024-07-30T20:29:40.658054", "image_code": "// \"Multi-Slime\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMin (float a, float b, float r);\nmat3 DirVuMat (vec3 vd);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nBall = 48;\nvec3 sunDir;\nfloat tCur, dstFar, obSpc, obSz;\nint idObj;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 s;\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  d = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    s = Loadv4 (3 + 3 * n);\n    d = SmoothMin (d, PrSphDf (p - s.xyz, 0.5 * s.w), 1.5);\n  }\n  DMIN (1);\n  q = p;\n  q.xz = mod (q.xz + 0.5 * obSpc, obSpc) - 0.5 * obSpc;\n  d = PrSphDf (q, 0.5 * obSz);\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, clCol;\n  vec2 q;\n  float dstGrnd, f, fd, ff, sd, sh;\n  if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    f = 1. - smoothstep (0.6, 0.9, dstGrnd / dstFar);\n    if (f > 0.) vn = VaryNf (2. * ro, vn, f);\n    sh = (dstGrnd < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = 0.9 * mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5), 0.1 +\n       0.5 * smoothstep (0.3, 0.5, Fbm2 (ro.xz)));\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n    col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  } else if (rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n    sd = max (dot (rd, sunDir), 0.);\n    col += vec3 (1., 1., 0.9) * (0.3 * pow (sd, 512.) + 0.1 * pow (sd, 1024.));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  float dstObj, f;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (0., 1., 0., 0.2);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.5, 0.55, 0.5, 0.);\n      f = 1. - smoothstep (0.6, 0.9, dstObj / dstFar);\n      if (f > 0.) vn = VaryNf (8. * ro, vn, 4. * f);\n    }\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n       0.8 * max (dot (vn, sunDir), 0.)) + col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    if (idObj == 1) col = mix (col, BgCol (ro, reflect (rd, vn)), 0.5);\n    col = mix (col, BgCol (roo, rd), smoothstep (0.8, 1., dstObj / dstFar));\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 col, rd, ro, rMid;\n  vec2 canvas, uv;\n  float az, el, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  stDat = Loadv4 (0);\n  obSpc = stDat.y;\n  obSz = stDat.z;\n  rMid = Loadv4 (2).xyz;\n  dstFar = 200.;\n  az = -0.01 * pi * tCur;\n  el = 0.15 * pi;\n  zmFac = 5.5;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.08 * pi, 0.45 * pi);\n  ro = rMid + 40. * vec3 (cos (el) * sin (az + vec2 (0.5 * pi, 0.)), sin (el)).xzy;\n  vuMat = DirVuMat (normalize (rMid - ro));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (cos (0.01 * tCur), 1., sin (0.01 * tCur)));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Multi-Slime\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 48;\n\nvec3 rLead;\nfloat tCur, nStep, obSpc, obSz;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fAttr, grav, rSep, szN, szAv,\n     fc, ft, drv, dt;\n  fOvlap = 1000.;\n  fricN = 10.;\n  fricS = 0.05;\n  fricSW = 10.;\n  fricT = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.01;\n  grav = 10.;\n  p = Loadv4 (3 + 3 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (3 + 3 * mId + 1).xyz;\n  wm = Loadv4 (3 + 3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (3 + 3 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      fc = fOvlap * (szAv / rSep - 1.);\n      vmN = Loadv4 (3 + 3 * n + 1).xyz;\n      wmN = Loadv4 (3 + 3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross ((sz * wm + szN * wmN) / (sz + szN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if (n / (nBall / 3) == mId / (nBall / 3)) am += 5. * fAttr * (rmN - rm);\n  }\n  szAv = 0.5 * (sz + 1.);\n  dr = vec3 (0., rm.y, 0.);\n  rSep = abs (dr.y);\n  if (rSep < szAv) {\n    fc = fOvlap * (szAv / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  szAv = 0.5 * (sz + obSz);\n  dr = rm;\n  dr.xz -= obSpc * floor ((rm.xz + 0.5 * obSpc) / obSpc);\n  rSep = length (dr);\n  if (rSep < szAv) {\n    fc = fOvlap * (szAv / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += fAttr * (rLead - rm);\n  am.y -= grav;\n  am -= fDamp * vm;\n  dt = 0.02;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * sz);\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm, out float sz)\n{\n  float mIdf, nbEdge;\n  nbEdge = floor (sqrt (float (nBall)) + 0.01);\n  mIdf = float (mId);\n  rm = vec3 (floor (vec2 (mod (mIdf, nbEdge), mIdf / nbEdge)) - 0.5 * (nbEdge - 1.), 3.).xzy;\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + tCur + 0.3),\n     Hashff (mIdf + 0.6)) - 0.5);\n  wm = vec3 (0.);\n  sz = 1. - 0.1 * Hashff (mIdf + 0.1);\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 rm, vm, wm, rMid;\n  vec2 iFrag;\n  float sz;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  tCur = iTime;\n  if (pxId >= 3) mId = (pxId - 3) / 3;\n  else mId = -1;\n  doInit = false;\n  if (iFrame <= 5) {\n    obSpc = 7.;\n    obSz = 3.5;\n    doInit = true;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    obSpc = stDat.y;\n    obSz = stDat.z;\n    rLead = Loadv4 (1).xyz;\n  }\n  if (doInit) {\n    nStep = 0.;\n    rLead = vec3 (0., 0., 0.);\n    if (mId >= 0) Init (mId, rm, vm, wm, sz);\n  } else {\n    ++ nStep;\n    rLead += 0.05 * vec3 (0.9, 0., 1.);\n    if (mId >= 0) Step (mId, rm, vm, wm, sz);\n  }\n  if (pxId == 2) {\n    rMid = vec3 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) rMid += Loadv4 (3 + 3 * n).xyz;\n    rMid /= float (nBall);\n  }\n  if      (pxId == 0) stDat = vec4 (nStep, obSpc, obSz, 0.);\n  else if (pxId == 1) stDat = vec4 (rLead, 0.);\n  else if (pxId == 2) stDat = vec4 (rMid, 0.);\n  else if (pxId == 3 + 3 * mId) stDat = vec4 (rm, sz);\n  else if (pxId == 3 + 3 * mId + 1) stDat = vec4 (vm, 0.);\n  else if (pxId == 3 + 3 * mId + 2) stDat = vec4 (wm, 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKBDd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[529, 529, 551, 551, 892], [894, 894, 927, 927, 1173], [1175, 1175, 1196, 1196, 1446], [1449, 1449, 1486, 1486, 1715], [1717, 1717, 1748, 1748, 3065], [3067, 3067, 3102, 3102, 3908], [3910, 3910, 3966, 3966, 4823], [4825, 4825, 4858, 4858, 4885], [4887, 4887, 4932, 4932, 5035], [5037, 5037, 5062, 5062, 5231], [5265, 5265, 5289, 5289, 5342], [5344, 5344, 5368, 5368, 5498], [5500, 5500, 5525, 5525, 5671], [5673, 5673, 5698, 5698, 5884], [5886, 5886, 5908, 5908, 6062], [6064, 6064, 6085, 6085, 6240], [6242, 6242, 6271, 6271, 6483], [6485, 6485, 6524, 6524, 6709], [6803, 6803, 6828, 6828, 6956]], "test": "untested"}
{"id": "3sKfDt", "name": "729 Rhombic Dodecahedra", "author": "mla", "description": "This is raytraced, not raymarched, there is no space division, each dodecahedron is an individual.\n\nI get 30fps at 512x288 on my crummy Intel Integrated graphics, I'd be interested in how more capable GPUs do with this.\n\nMouse & up/down to navigate.", "tags": ["raytrace", "dodecahedron", "rhombic", "trumbore", "moller"], "likes": 9, "viewed": 404, "published": 3, "date": "1608285560", "time_retrieved": "2024-07-30T20:29:42.097206", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 729 Rhombic Dodecahedra, Matthew Arcus, mla, 2020\n//\n// Ray tracing parallelograms - how many can we do?\n// Quite a few in fact, a fast sphere intersection test helps.\n//\n// Mouse and up/down moves around\n// 'b': blink\n// 'f': fog\n// 'r': rotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int N = 4; // (2N+1)^3 polyhedra\nfloat maxdist = 60.0;\n\n// Ray-plane intersection:\n// Intersect p+kr with plane generated by e0,e1 at origin\n// Solve linear system: p-tr = ue0 + ve1  & return vec3(-t,u,v).\n// Uses Cramer's rule, ie. if mat3(A,B,C)*X = P then:\n// X = vec3(det(P,B,C),det(A,P,C),det(A,B,P))/det(A,B,C)\n// Determinant of mat3(A,B,C) is just the triple product:\n// dot(A,cross(B,C)) = dot(B,cross(C,A)) = -dot(C,cross(B,A)) etc.\n//\n// This is the ray-triangle intersection algorithm of Tomas Möller and Ben Trumbore,\n// but it's of wider applicability than just to triangles. (If e0,e1 are sides of a\n// triangle, then we are in the triangle iff 0 <= u,v,1-u-v <= 1 but can generally treat\n// u and v as (possibly oblique) general coords in the plane).\n\nvec3 intersect(vec3 p, vec3 r, vec3 e0, vec3 e1, vec3 n) {\n  // Expects that n = cross(e0,e1);\n  vec3 m = cross(r,p);\n  return vec3(-dot(p,n),dot(m,e1),-dot(m,e0))/dot(r,n);\n}\n\nint hitindex = -1;\nvec3 hitnormal = vec3(0);\nbool checkparallelogram(vec3 p, vec3 r, vec3 v0, vec3 v1, vec3 v2, int index, inout vec3 amin) {\n  p -= v0; v1 -= v0; v2 -= v0;\n  vec3 normal = cross(v1,v2);\n  if (dot(normal,r) > 0.0) return false; // Back face cull\n  vec3 a = intersect(p,r,v1,v2,normal);\n  // a = vec3(t,u,v). Require 0 <= t <= amin.x and 0 <= u,v <= 1 for a parallelogram\n  bool hit = all(bvec2(all(greaterThanEqual(a,vec3(0))),\n                       all(lessThanEqual(a,vec3(amin.x,1,1)))));\n  if (!hit) return false;\n  hitindex = index;\n  hitnormal = normal;\n  amin = a;\n  return true;\n}\n\nvoid rhombic(vec3 p, vec3 r, vec3 q, int index, inout vec3 amin) {\n  p -= q;\n  if (key(CHAR_B)) {\n      float h = fhash(uint(index)^uint(4.0*iTime));\n      if (h < 0.1) return;\n  }\n  // Octahedron vertices\n  vec3 o0 = vec3(0,0,2);\n  vec3 o1 = vec3(0,0,-2);\n  vec3 o2 = vec3(0,2,0);\n  vec3 o3 = vec3(0,-2,0);\n  vec3 o4 = vec3(2,0,0);\n  vec3 o5 = vec3(-2,0,0);\n  // Cube vertices\n  vec3 c0 = vec3(1,1,1);\n  vec3 c1 = vec3(1,-1,1);\n  vec3 c2 = vec3(-1,-1,1);\n  vec3 c3 = vec3(-1,1,1);\n\n  vec3 c4 = vec3(1,1,-1);\n  vec3 c5 = vec3(1,-1,-1);\n  vec3 c6 = vec3(-1,-1,-1);\n  vec3 c7 = vec3(-1,1,-1);\n  \n  // Rhombic dodecahedron faces\n  checkparallelogram(p,r,o0,c1,c0,index,amin);\n  checkparallelogram(p,r,o0,c2,c1,index,amin);\n  checkparallelogram(p,r,o0,c3,c2,index,amin);\n  checkparallelogram(p,r,o0,c0,c3,index,amin);\n\n  checkparallelogram(p,r,o1,c7,c4,index,amin);\n  checkparallelogram(p,r,o1,c6,c7,index,amin);\n  checkparallelogram(p,r,o1,c5,c6,index,amin);\n  checkparallelogram(p,r,o1,c4,c5,index,amin);\n  \n  checkparallelogram(p,r,o4,c4,c0,index,amin);\n  checkparallelogram(p,r,o4,c1,c5,index,amin);\n  checkparallelogram(p,r,o5,c6,c2,index,amin);\n  checkparallelogram(p,r,o5,c3,c7,index,amin);\n}\n\n// Fast check for sphere intersection\nbool checksphere (vec3 p, vec3 r, vec3 centre, float radius2) {\n  p -= centre; // centre on sphere\n  float pr = dot(p,r);\n  if (pr > 0.0) return false;\n  float pp = dot(p,p);\n  return pr*pr >= pp-radius2;\n}\n\nvec3 getcolor(int hitindex) {\n  float h = fhash(uint(hitindex));\n  return hsv2rgb(vec3(h,1,1));\n}\n\nvec3 scene(vec3 p, vec3 r, vec3 light) {\n  vec3 background = vec3(1,1,0.75);\n  vec3 color = background;\n  vec3 amin = vec3(1e8,0,0);\n  float radius2 = 4.0; // Bounding sphere radius\n  for (int i = -N; i <= N; i++) {\n    for (int j = -N; j <= N; j++) {\n      for (int k = -N; k <= N; k++) {\n        vec3 centre = 4.0*vec3(i,j,k);\n        if (checksphere(p,r,centre,radius2)) {\n          int index = (i+N)+(2*N+1)*(j+N+(2*N+1)*(k+N));\n          //assert(index >= 0);\n          //assert(index < (2*N+1)*(2*N+1)*(2*N+1));\n          rhombic(p,r,centre,index,amin);\n        }\n      }\n    }\n  }\n  if (hitindex >= 0) {\n    hitnormal = normalize(hitnormal);\n    color = getcolor(hitindex);\n    //color *= texture(iChannel0,amin.yz).xyz;\n    color *= 0.4+0.6*(max(0.0,dot(hitnormal,light)));\n    if (!key(CHAR_F)) color = mix(background,color,max(0.0,maxdist-amin.x)/maxdist);\n  }\n  return color;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nvoid mainImage(out vec4 outColor, vec2 fragCoord) {\n  vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  float camera = -40.0;\n  camera *= exp(-0.1*float(keycount(KEY_UP)-keycount(KEY_DOWN)));\n  vec3 p = vec3(0,0,camera);\n  p = transform(p);\n  vec3 light = vec3(0,1,-1);\n  light = transform(light);\n  light = normalize(light);\n  vec3 r = vec3(uv,2);\n  r = transform(r);\n  r = normalize(r);\n\n  vec3 color = scene(p,r,light);\n  pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  outColor = vec4(color,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// common //////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat fhash(uint x) {\n   return float(ihash(x))/pow(2.0,32.0);\n}\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1194, 1194, 1252, 1288, 1369], [1416, 1416, 1512, 1512, 1976], [1978, 1978, 2044, 2044, 3173], [3175, 3213, 3276, 3276, 3419], [3421, 3421, 3450, 3450, 3518], [3520, 3520, 3560, 3560, 4408], [4410, 4410, 4437, 4437, 4721], [4723, 4723, 4774, 4774, 5240]], "test": "untested"}
{"id": "tdVfDt", "name": "PS1 startup animation", "author": "ChronosDragon", "description": "No text because this was already too much of an effortpost", "tags": ["logo", "animation", "ps1", "startup"], "likes": 5, "viewed": 555, "published": 3, "date": "1608277767", "time_retrieved": "2024-07-30T20:29:43.061627", "image_code": "const float PI = 3.14159;\n\nconst vec3 bg = vec3(226.0/255.0);\nconst vec3 black = vec3(0.0);\nconst vec3 tri_red = vec3(239.0/255.0, 23.0/255.0, 2.0/255.0);\nconst vec3 tri_orange = vec3(224.0/255.0, 150.0/255.0, 2.0/255.0);\n\nconst vec3 ps_red = vec3(255.0/255.0, 26.0/255.0, 1.0/255.0);\nconst vec3 ps_yellow = vec3(255.0/255.0, 179.0/255.0, 1.0/255.0);\nconst vec3 ps_green = vec3(15.0/255.0, 126.0/255.0, 120.0/255.0);\nconst vec3 ps_blue = vec3(36.0/255.0, 82.0/255.0, 145.0/255.0);\n\n\nvec3 gradient(float t) {\n    vec3 left = mix(tri_red, tri_orange, t*2.0);\n    vec3 right = mix(tri_orange, tri_red, t*2.0 - 1.0);\n    return mix(left, right, smoothstep(0.49, 0.51, t));\n}\n\nfloat diamond(vec2 uv) {\n    float bl = mix(0.0, 1.0, smoothstep(0.997, 1.003, uv.x + uv.y + 0.5));\n    float tl = mix(0.0, 1.0, smoothstep(0.997, 1.003, uv.x - uv.y + 1.5));\n    float br = mix(0.0, 1.0, smoothstep(0.997, 1.003, - uv.x + uv.y + 1.5));\n    float tr = mix(0.0, 1.0, smoothstep(0.997, 1.003, - uv.x - uv.y + 2.5));\n    return tl * tr * bl * br;\n}\n\nvec3 diamond_gradient(vec2 uv, vec3 bg) {\n    return mix(bg, gradient(uv.x), diamond(uv));\n}\n\nfloat triangle(vec2 uv) {\n    float bl = mix(0.0, 1.0, smoothstep(0.997, 1.003, uv.x + uv.y + 0.5));\n    float tl = mix(0.0, 1.0, smoothstep(0.997, 1.003, uv.x - uv.y + 1.5));\n    return mix(bl * tl, 0.0, smoothstep(0.497, 0.503, uv.x));\n}\n\nvec3 triangle_gradient(vec2 uv, vec3 bg) {\n    return mix(bg, gradient(uv.x), triangle(uv));\n}\n\nvec3 trilogo_animation(vec2 uv, float t_) {\n    float t = clamp(0.0, 1.0, t_);\n    vec3 big = diamond_gradient(uv, bg);\n    \n    vec2 uv_half1 = uv + vec2(0.0, 0.0);\n    vec2 uv_half2 = -uv + vec2(1.0, 1.0);\n    vec2 uv_small1 = 2.0 * uv - vec2(0.58, 0.92);\n    vec2 uv_small2 = -2.0 * uv + vec2(1.42, 1.08);\n\n    vec3 small1 = triangle_gradient(mix(uv_half1, uv_small1, t), big);\n    vec3 small2 = triangle_gradient(mix(uv_half2, uv_small2, t), small1);\n    return small2;\n}\n\nfloat line(vec2 uv, float at, float angle) {\n    const float WIDTH = 0.003;\n    return mix(0.0, 1.0, smoothstep(at - WIDTH, at + WIDTH, cos(angle) * uv.x + sin(angle) * uv.y));\n}\n\nfloat polycircle(int segments, vec2 uv, vec2 center, float radius) {\n    float result = 1.0;\n    for (int i = 0; i < 20; ++i) {\n        float angle = 2.0 * PI * float(i + 1) / float(segments);\n        result *= line(uv - center, -radius, angle);\n    }\n    return result;\n}\n\nfloat p(vec2 uv) {\n    return clamp(0.0, 1.0, \n    (\n        line(uv, -0.1, 0.0) * \n        line(uv, -0.17, PI) * \n        line(uv, -0.54, 1.35) *\n        line(uv, -0.6, PI + 1.35)\n    ) + \n    polycircle(20, uv * vec2(1.1, 1.0), vec2(0.41, 0.222), 0.3) * line(uv, 0.25, 0.0) +\n    (\n        line(uv, 0.5, 1.35) * \n        line(uv, -0.6, PI + 1.35) *\n        line(uv, -0.1, 0.0) *\n        line(uv, -0.43, PI)\n    )\n    );\n}\n\nfloat s(vec2 uv) {\n    return clamp(0.0, 1.0,\n    ( // prongs\n        (\n            line(uv, -0.56, 1.9) *\n            line(uv, 0.43, 1.9 + PI) *\n            line(uv, 0.22, PI + 1.35)\n        ) + (\n            line(uv, -0.35, 1.9) *\n            line(uv, 0.22, 1.9 + PI) *\n            line(uv, -0.26, 1.35)\n        ) + (\n            line(uv, -0.14, 1.9) *\n            line(uv, 0.01, 1.9 + PI) *\n            line(uv, -0.26, 1.35)\n        )\n    ) * ( // top/bottom\n        line(uv, -0.47, 1.35) *\n        line(uv, 0.06, PI + 1.35)\n    ) + ( // right curve\n        polycircle(15, uv * vec2(0.60, 1.3), vec2(-0.13, -0.34), 0.2) *\n        line(uv, 0.01, 1.9 + PI) * (1.0 - clamp(\n            line(uv, 0.14, 1.9 + PI) *\n            line(uv, -0.22, 1.9) *\n            line(uv, -0.31, 1.35) +\n            polycircle(15, uv * 4.35 * vec2(0.60, 1.3), vec2(-0.58, -1.5), 0.2),\n            0.0, 1.0\n        ))\n    ) + ( // left curve\n        polycircle(15, uv * vec2(0.60, 1.3), vec2(0.23, -0.36), 0.2) *\n        line(uv, -0.56, 1.9) * (1.0 - clamp(\n            line(uv, 0.35, 1.9 + PI) *\n            line(uv, -0.43, 1.9) *\n            line(uv, 0.19, PI + 1.35) +\n            polycircle(15, uv * 4.2 * vec2(0.60, 1.3), vec2(0.98, -1.5), 0.2),\n            0.0, 1.0\n        ))\n    )\n    );\n}\n\nvec4 s_color(vec2 uv) {\n    float s_amount = s(uv);\n    vec3 s_color = mix(mix(ps_yellow, ps_green, line(uv, -0.3, 1.2)), ps_blue, line(uv, -0.15, 1.2));\n    return vec4(s_color, 1.0) * s_amount;\n}\n\nvec3 ps_logo(vec2 uv) {\n    uv.x += 0.15;\n    vec4 logo_s_main = s_color(uv);\n    vec4 logo_s_shadow = s_color(uv + vec2(0.00, 0.04));\n    vec3 logo_s = mix(mix(black, logo_s_shadow.rgb * 0.5, logo_s_shadow.a), logo_s_main.rgb, logo_s_main.a);\n    vec3 logo_p = mix(mix(logo_s, ps_red * 0.5, p(uv + vec2(-0.04, -0.02))), ps_red, p(uv));\n    return logo_p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 c_uv = 2.0 * uv - vec2(1.0);\n    vec2 sq_uv = c_uv * vec2(iResolution.x / iResolution.y, 1.0);\n\n    float t = mod(iTime, 15.0);\n    vec3 color = black;\n    if (t < 2.0) {\n        color = mix(black, bg, smoothstep(0.0, 2.0, t));\n    } else if (t < 7.0) {\n        color = trilogo_animation(sq_uv * 0.6 + vec2(0.5), t - 2.0);\n    } else if (t < 7.2) {\n        color = mix(bg, black, smoothstep(7.0, 7.2, t));\n    } else if (t < 8.2) {\n        color = mix(black, ps_logo(sq_uv), smoothstep(7.2, 8.2, t));\n    } else if (t < 13.2) {\n        color = ps_logo(sq_uv);\n    }\n   \n    // fade black to white 2s\n    // tri logo appears\n    // halves animate 1s\n    // hold 4s\n    // (fast fade) black and tri logo disappears\n    // ps logo fades in 1s\n    // hold 5s\n    // ps logo cuts out\n    // hold black 2s\n    // repeat\n\n    // vec3 logo = trilogo_animation(sq_uv * 0.6 + vec2(0.5), iTime);\n    vec3 logo_ps = ps_logo(sq_uv);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[483, 483, 507, 507, 670], [672, 672, 696, 696, 1032], [1034, 1034, 1075, 1075, 1126], [1128, 1128, 1153, 1153, 1367], [1369, 1369, 1411, 1411, 1463], [1465, 1465, 1508, 1508, 1940], [1942, 1942, 1986, 1986, 2120], [2122, 2122, 2190, 2190, 2394], [2396, 2396, 2414, 2414, 2819], [2821, 2821, 2839, 2839, 4097], [4099, 4099, 4122, 4122, 4296], [4298, 4298, 4321, 4321, 4655], [4657, 4657, 4714, 4764, 5798]], "test": "untested"}
{"id": "wsKBDt", "name": "Xor gemstones", "author": "jarble", "description": "I combined [url=https://www.shadertoy.com/view/WsVBDd]this shader[/url] with [url=https://www.shadertoy.com/view/4s23zz]this shader[/url] to produce a gemstone pattern.", "tags": ["fbm", "emerald"], "likes": 14, "viewed": 517, "published": 3, "date": "1608260497", "time_retrieved": "2024-07-30T20:29:43.984161", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See https://iquilezles.org/articles/warp for details\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nfloat noise(vec2 U){\n    vec2 R = iResolution.xy;\n    ivec2 I = ivec2(U);\n    int x = I.x, y = I.y,\n        i = x - y ^ y + x;\n    \n    float v = float(i);  // try also: i*i , i*i*i\n\n    return (fract( v * 0.051618 ));\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2( fbm4(p+vec2(1.0)), fbm4(p+vec2(6.2)) );\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2( fbm6(p+vec2(9.2)), fbm6(p+vec2(5.7)) );\n}\n\n\nfloat func( vec2 q, out vec2 o, out vec2 n )\n{\n    q += 0.05*sin(vec2(0.11,0.13) + length( q )*4.0);\n    \n    q *= 0.7 + 0.2*cos(0.05);\n\n    o = 0.5 + 0.5*fbm4_2( q );\n    \n    o += 0.02*sin(vec2(0.11,0.13)*length( o ));\n\n    n = fbm6_2( 4.0*o );\n\n    vec2 p = q + 2.0*n + 1.0;\n\n    float f = 0.5 + 0.5*fbm4( 2.0*p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    f *= 1.0-0.5*pow( 0.5+0.5*sin(8.0*p.x)*sin(8.0*p.y), 8.0 );\n\n    return f;\n}\n\nfloat funcs( in vec2 q )\n{\n    vec2 t1, t2;\n    return func(q,t1,t2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int mi=0; mi<AA; mi++ )\n    for( int ni=0; ni<AA; ni++ )\n    {\n        // pixel coordinates\n        vec2 of = vec2(float(mi),float(ni)) / float(AA) - 0.5;\n        vec2 q = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y*2.0;\n#else    \n        vec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y*2.0;\n#endif\n        q += iTime/2.0;\n        vec2 o, n;\n        float f = func(q, o, n);\n        \n        vec3 col = vec3(0.2,0.1,0.4);\n        col = mix( col, vec3(0.3,0.05,0.05), f );\n        col = mix( col, vec3(0.9,0.9,0.9), dot(n,n) );\n        col = mix( col, vec3(0.5,0.2,0.2), 0.5*o.y*o.y );\n        col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(n.y)+abs(n.x)) );\n        col *= f*2.0;\n\n        vec2 ex = vec2( 1.0 / iResolution.x, 0.0 );\n        vec2 ey = vec2( 0.0, 1.0 / iResolution.y );\n        #if AA>1\n        ex /= float(AA);\n        ey /= float(AA);\n        #endif\n        vec3 nor = normalize( vec3( funcs(q+ex) - f, ex.x, funcs(q+ey) - f ) );\n        \n        vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n        float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n        vec3 bdrf;\n        bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n        bdrf += vec3(0.15,0.10,0.05)*dif;\n        bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n        bdrf += vec3(0.15,0.10,0.05)*dif;\n\n        col *= bdrf;\n        col = vec3(1.0)-col;\n        col = col*col;\n        col *= vec3(1.2,1.25,1.2);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n\tvec2 p = fragCoord / iResolution.xy;\n\ttot *= 0.5 + 0.5 * sqrt(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n\t\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKBDt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[245, 245, 265, 265, 465], [520, 520, 542, 542, 790], [792, 792, 814, 814, 1119], [1121, 1121, 1144, 1144, 1203], [1205, 1205, 1228, 1228, 1287], [1290, 1290, 1336, 1336, 1731], [1733, 1733, 1759, 1759, 1804]], "test": "untested"}
{"id": "tdGfWc", "name": "Adaptive importance sampling", "author": "michael0884", "description": "Adaptive importance sampling\nTesting on a scrambled caustic scene", "tags": ["random", "pathtracing", "importancesampling"], "likes": 18, "viewed": 563, "published": 3, "date": "1608258564", "time_retrieved": "2024-07-30T20:29:44.936614", "image_code": "//MIT License\n//Copyright 2020 Mykhailo Moroz\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//Inspired by Nvidia's \"Spatiotemporal reservoir resampling\" paper\n//https://research.nvidia.com/sites/default/files/pubs/2020-07_Spatiotemporal-reservoir-resampling/ReSTIR.pdf\n\n//Basically I thought what if instead of storing a reservoir of light source strategies\n//we would fit virtual light sources using gaussian distributions for each pixel?\n//This shadertoy is a \"kinda\" proof of concept that this does work\n\n//Considering the limitations of shadertoy this particular implementation only works well\n//with 4 distributions, and only with 1 sample per frame per pixel\n\n//The gaussians were fitted by clusterizing the samples using k-means, i.e. \n//counting only the closest samples to this distribution.\n\n//The convergence speed is greately improved because of spacio-temporal reuse,\n//but its quite hard to keep it unbiased, and until the distributions are stabilized the samples\n//are quite biased, similarly to metropolis light transport.\n\n//This can be extended to more than 1 ray bounce if the surface is in screenspace.\n//For surfaces outside of that(and volumetric things) we can use a volumetric grid \n//and store/update the distributions there. A sparse voxel octree is probably a good choice for that.\n\n//I recommend using the unofficial shadertoy plugin to incread the number of \n//paint calls per frame for faster convergence (8x+ recommended)\n//since I can not use more SPP because I need to fit the gaussian and accumulate samples\n//which would require at least 8 channels in a texture\n\n//The current bottleneck of this algorithm is the multi gaussian fitting algo,\n//k-means gives suboptimal results\n\n//Keyboard buttons:\n// M - distribution mean display\n// S - distribution sigma display\n// C - comparison with pure uniform path tracing\n//Look in Common for constants to tune, you can enable spectral path tracing there too\n\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\n\nfloat draw_distribution(vec2 p, vec3 d)\n{\n    vec4 data = ch1(p);\n    vec3 mean = normalize(data.xyz);\n    float sigma = length(data.xyz);\n    return gpdf(d, mean, sigma);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    INIT;\n    \n    vec4 data = ch1(p);\n   \n    //light distribution\n    float sigma = length(data.xyz);\n    float wsum = data.w;\n    vec3 mean = normalize(data.xyz);\n    \n    vec4 l = ch2(p); \n    c = tanh(vec4(1., 1.05, 1.2, 1.0)*10.*pow(l/l.w, vec4(1.5)));\n\n    if(isKeyToggled(KEY_M))\n        c.xyz = vec3(1.)*(0.5*mean + 0.5);\n    else if(isKeyToggled(KEY_S))\n        c.xyz = vec3(5.)*sigma;\n    \n    //render incoming light\n    if(isKeyToggled(KEY_A))\n    {\n        vec3 x = 20.*vec3((iMouse.xy - 0.5*R.xy)/600., 0.);\n        vec3 d = normalize(vec3(2.*(p.xy - 0.5*R.xy)/600., 1.0));\n        float S = trace(x, d, 460.0);\n        \n        float D = 0.;\n        vec2 ci = cell_size*floor(iMouse.xy/cell_size);\n        range(i, 0, cell_S) range(j, 0, cell_S)\n            D += draw_distribution(ci +vec2(i,j), d);\n        \n        c.xyz = vec3(S, S, D);\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//spectral path tracing\n//monochromatic converges faster\n//#define SPECTRAL\n#define BLUR\n#define BLUR_STR 0.1\n\n//standard constants\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//texture sampling\n#define ch0(p) texelFetch(iChannel0, ivec2(mod(p, R)), 0)\n#define ch1(p) texelFetch(iChannel1, ivec2(mod(p, R)), 0)\n#define ch2(p) texelFetch(iChannel2, ivec2(mod(p, R)), 0)\n#define ch3(p) texelFetch(iChannel3, ivec2(mod(p, R)), 0)\n\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//adaptive importance sampling params\n#define temporal_loss 0.1\n#define spacial_blur 0.05\n//pixel cell with the gaussian distributions\n#define cell_size 2.0\n#define cell_S 2\n#define cell_L 4\n\nfloat time; vec2 mouse; vec2 R;\n\n#define INIT time = float(iFrame)/60.; mouse = iMouse.xy; R = iResolution.xy;\n\n//random number generation\n\n//WIP\n//#define BLUE\n\nuint ns; vec2 pix;\n\nvoid RNGupdate()\n{\n    // integer hash copied from Hugo Elias\n\tns = (ns << 13U) ^ ns;\n    ns = ns * (ns * ns * 15731U + 789221U) + 1376312589U;\n}\n\n//https://www.shadertoy.com/view/WsfBDf\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat IGN(int d, vec2 s) \n{\n    s += (float(ns%25093u + uint(d)) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pix.x + s.x) + 0.00583715f*float(pix.y + s.y)));  \n}\n\n\n#ifdef BLUE\n    #define INIT_RNG ns = uint(iFrame*24676); pix = p;\n\n    vec2 rnd2() \n    {\n        RNGupdate();\n        uvec2 k = ns * uvec2(ns,ns*16807U);\n        return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n    }\n\n    float rand() \n    {\n        vec2 s = rnd2()*1e4;\n        return IGN(0, s);\n    }\n\n    vec2 rand2() \n    {\n        vec2 s = rnd2()*1e4;\n        return vec2(IGN(0, s),IGN(1, s));\n    }\n\n    vec4 rand4() \n    {\n        vec2 s = rnd2()*1e4;\n        return vec4(IGN(0, s),IGN(1, s),IGN(2, s),IGN(3, s));\n    }\n#else\n    #define INIT_RNG ns = uint(iFrame*24676) + uint(p.x*5557.0) + uint(p.y*8482.0);\n\n    float rand() \n    {\n        RNGupdate();\n        return float( (ns * ns) & uvec2(0x7fffffffU))/float(0x7fffffff);\n    }\n\n    vec2 rand2() \n    {\n        RNGupdate();\n        uvec2 k = ns * uvec2(ns,ns*16807U);\n        return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n    }\n\n    vec4 rand4() \n    {\n        RNGupdate();\n        uvec4 k = ns * uvec4(ns,ns*16807U,ns*48271U,ns*21171U);\n        return vec4( k & uvec4(0x7fffffffU))/float(0x7fffffff);\n    }\n#endif\n\n// Implements the Box-Muller transform\n// to generate normally distributed random numbers\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = clamp(rand2(), 0.01, 1.0);\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec4 nrand4(float sigma, vec4 mean)\n{\n\tvec4 Z = clamp(rand4(), 0.01, 1.0);\n    return mean + sigma * sqrt(-2.0 * log(Z.xxyy)) * \n           vec4(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w),sin(TWO_PI * Z.w));\n}\n\nfloat gpdf(vec3 delta, vec3 d, float R)\n{\n    float ddot = dot(delta, d);\n    float ddot2 = ddot*ddot;\n    float sigma2 = R*R;\n    \n    //probability distribution function(unbiased)\n    return (1.0/TWO_PI)*(ddot2/sigma2 + 1.0)*exp( (ddot2 - dot(delta, delta))/(2.0 * sigma2) );\n}\n\n//sample random direction from a point to a 3D normal distribution\nvec3 gdir(in vec3 p0, in vec3 N, in vec3 p1, in float R, out float pdf)\n{\n    //sample random point from the cloud\n    vec3 rn = nrand4(R, vec4(p1,0)).xyz;\n    \n    //random direction\n    vec3 d = normalize(rn - p0);\n    //reflect to the positive hemisphere\n    d *= sign(dot(N,d));\n    \n    vec3 delta = p0 - p1;\n    \n    pdf = gpdf(delta, d, R);\n\n    return d;\n}\n\n//sample uniform direction in a hemisphere\nvec3 udir(vec3 N, out float pdf)\n{\n    //sample random point from the cloud\n    vec3 rn = normalize(nrand4(1.0, vec4(0.0)).xyz);\n    \n    pdf = 1.0/TWO_PI;\n    \n    //random direction\n    return rn * sign(dot(N, rn));\n}\n\n\n//data packing \n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))\n\n\n//useful\n\n#define sqr(x) (x)*(x)\n\n//https://www.shadertoy.com/view/ls2Bz1\nvec3 spectral_spektre (float l)\n{\n\tfloat r=0.0,g=0.0,b=0.0;\n\t\t\tif ((l>=400.0)&&(l<410.0)) { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n\telse if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n\telse if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n\telse if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n\telse if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n\t\t\tif ((l>=415.0)&&(l<475.0)) { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n\telse if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n\telse if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n\t\t\tif ((l>=400.0)&&(l<475.0)) { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n\telse if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n\n\treturn vec3(r,g,b);\n}\n\n//scene\n\nfloat sample_light(vec3 r)\n{\n    vec3 ldir = normalize(vec3(0.,0., 1.0));\n    return 500.*step(0.996, dot(r, ldir));\n}\n\n//wavy surface\nfloat map(vec3 p)\n{\n    return 0.7*(4.5-p.z+0.6*cos(length(p.xy)) - 0.6*sin(0.5*distance(p.xy, vec2(30,10)))\n                + 0.6*sin(0.8*p.x+10.*mouse.x/R.x) + 0.4*cos(0.3*p.x + 0.6*p.y - 10.*mouse.y/R.y) +\n                 + 0.4*cos(-0.6*p.x + 0.1*p.y) + 0.7*cos(-0.3*p.x - 0.5*p.y)\n                 + 0.2*cos(2.0*p.x - 0.2*p.y) + 0.1*cos(1.7*p.x - 2.2*p.y));\n                 //+ 0.07*cos(4.0*p.x + 3.2*p.y) + 0.03*cos(0.1*p.x - 5.2*p.y));\n}\n\nvec4 grad(vec3 p, float dx) \n{\n\tconst vec3 k = vec3(1,-1,0);\n\treturn  (k.xyyx*map(p + k.xyy*dx) +\n\t\t\t k.yyxx*map(p + k.yyx*dx) +\n\t\t\t k.yxyx*map(p + k.yxy*dx) +\n\t\t\t k.xxxx*map(p + k.xxx*dx))/4.;\n}\n\n\nvec3 ray_march(inout vec3 p, in vec3 d)\n{\n    for(int i = 0; i < 32; i++)\n    {\n        float DE = map(p);\n        p += DE*d;\n    }\n    return normalize(grad(p, 0.01).xyz);\n}\n\n//refraction index wavelength dependence \nfloat dispersion(float w)\n{\n    //return 2.8;\n    return 8.0 - 8.0*(w - 300.)/500.;\n}\n\nfloat trace(in vec3 p, in vec3 d, float w)\n{\n    vec3 N = ray_march(p,d);\n    vec3 d1 = refract(d, N, dispersion(w));\n    return sample_light(d1);\n}\n\n\n//Keyboard constants\nconst int KEY_SPACE  = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n\n", "buffer_a_code": "//SAMPLE RAYS USING THE APPROXIMATED LIGHT DISTRIBUTION FOR IMPORTANCE SAMPLING \nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    INIT;\n    INIT_RNG;\n    \n    vec3 N = vec3(0,0,1);\n    vec3 P =20.*vec3(((p-0.5*R.xy + rand2() - 0.5)/600.0), 0.);\n    \n    vec4 prev_sample = ch0(p);\n   \n    //choose a random cell\n    vec2 ci = cell_size*(floor(p/cell_size + 2.*rand2() - 1.0));\n    //choose a random distribution\n    vec2 dx = (cell_size-1.0)*round(rand2());\n    vec4 data = ch1(ci+dx);\n   \n    //light distribution\n    float sigma = length(data.xyz);\n    if(isKeyToggled(KEY_C)) sigma=(p.x > R.x*0.5)?sigma:1.0;\n    float ill = data.w;\n    vec3 mean = normalize(data.xyz);\n    \n    float pdf;\n    vec3 r = gdir(vec3(0), N, mean, sigma, pdf);\n    \n    #ifdef SPECTRAL\n        //sample random wavelength\n        float wl = 430.0 + 270.0*pow(rand(),3.0);\n    #else\n        //monochromatic ish\n        float wl = 460. + 10.*p.x/R.x;\n    #endif\n    \n    float S = trace(P, r, wl)/pdf;\n    \n    //store the sample dir, wavelength and ill \n    c = vec4(r*wl, S);\n    \n    if(iFrame < 1) c = vec4(0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//UPDATE THE APPROXIMATED LIGHT DISTRIBUTION\n//n^2 gaussian distributions\n//n*n pixel cell\n\nvec4 cell[cell_L];\nint local;\n\nvoid load_distribution(vec2 p, out float wsum, out float sigma, out vec3 mean)\n{\n    vec4 data = ch1(p);\n    wsum = data.w;\n    mean = normalize(data.xyz);\n    sigma = length(data.xyz);\n}\n\nvec4 load_neigh(vec2 p, int d, out float wsum)\n{\n    vec2 x = vec2(d/cell_S, d%cell_S);\n    vec3 mean; float sigma;\n    load_distribution(p + x, wsum, sigma, mean);\n    return vec4(mean, sigma);\n}\n\nvoid load_cell(vec2 p)\n{\n    vec2 ci = cell_size*floor(p/cell_size);\n    vec2 cd = floor(p) - ci;\n    local = int(cd.y*cell_size + cd.x);\n    float wsum;\n    for(int i = 0; i<cell_L; i++)\n        cell[i] = load_neigh(ci, i, wsum);\n}\n\n//reject all samples that do not fall into this distribution\nfloat rejection(vec3 d)\n{\n    //distance rejection\n    int id = 0;\n    float dmin = 1e10;\n    float dlocal = 0.;\n    for(int i = 0; i<cell_L; i++)  \n    {\n        float d = distance(cell[i].xyz, d);\n        if(i == local) dlocal = d;\n        if(d < dmin) {id = i; dmin = d;}\n    }\n    \n    return step(1.0,dmin/dlocal);\n    \n    \n    //probability rejection\n    //(is not stable)\n    \n    /*float p0 = 0.;\n    float p1 = 0.;\n    for(int i = 0; i<4; i++)  \n    {\n        float p = gpdf(d, cell[i].xyz, cell[i].w);\n        if(i == local) p1 += p;\n        else p0 += p;\n    }\n    return smoothstep(0.3, 3.0, 3.*p1/p0);\n    */\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    INIT;\n    INIT_RNG;\n    load_cell(p);\n   \n    //light distribution\n    float wsum; vec3 mean; float sigma;\n   \n    //load\n    load_distribution(p, wsum, sigma, mean);\n    \n    //neighbor cell blur\n    float wsum0, sigma0; vec3 mean0;\n    float sigmaB = sigma*wsum; vec3 meanB = mean*wsum; float wsumB = wsum;\n    vec2 deltas[4] = vec2[4](vec2(1,0),vec2(-1,0),vec2(0,1),vec2(0,-1));\n    \n    for(int i = 0; i < 4; i++)\n    {\n        load_distribution(p + cell_size*deltas[i], wsum0, sigma0, mean0);\n        wsum0 *= spacial_blur;\n        sigmaB += sigma0*wsum0; meanB += mean0*wsum0; wsumB += wsum0; \n    }\n    \n    sigma = sigmaB/wsumB; mean = meanB/wsumB; \n    \n    //loss \n    wsum *= (1. - temporal_loss);\n    \n    vec2 ci = cell_size*floor(p/cell_size);\n    //update light distribution using local pixels\n    float sigma2 = sigma*sigma*wsum;\n    vec3 mean1 = mean*wsum;\n    range(i, -1, cell_S) range(j, -1, cell_S)\n    {\n        vec2 delta = vec2(i, j);\n       \n        vec4 cur_sample = ch0(ci + delta);\n        \n        float pdf = length(cur_sample.xyz); \n        float s = cur_sample.w;\n        vec3 d = normalize(cur_sample.xyz);\n        \n        vec3 dx = d - mean;\n        float rej = rejection(d);\n        float w = rej*s;\n        //update sigma\n        sigma2 += dot(dx,dx)*w;\n        //update mean\n        mean1 += d*w;\n        \n        //weight sum\n        wsum += w;\n    }\n    \n    mean = normalize(mean1);\n    sigma = sqrt(sigma2/wsum);\n    \n\n    \n    if(iFrame < 1 || isnan(sigma) || isinf(sigma) || isnan(mean.x))\n    {\n       //default light distribution\n       sigma = 1.0;\n       wsum = 1.;\n       float p;\n       mean = normalize(vec3(0,0,1) + udir(vec3(0,0,1), p));\n    }\n    \n    c = vec4(mean*sigma, wsum);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//TAA\n\nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,2), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    INIT;\n    vec4 data = ch1(p);\n   \n    //light distribution\n    float sigma = length(data.xyz);\n    float wsum = data.w;\n    vec3 mean = normalize(data.xyz);\n    \n    vec4 prev = ch2(p);\n    #ifdef BLUR\n    vec3 prevL = prev.xyz/(prev.w+0.001);\n    //bilateral blur to remove grain\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        if(i==0 && j==0) continue;\n        vec2 dx = vec2(i,j);\n        vec4 s = ch2(p+dx);\n        vec3 L = s.xyz/(s.w+0.001);\n        float w = BLUR_STR*smoothstep(0., 200., prev.w)*exp(-45.*dot(L - prevL,L - prevL) - dot(dx,dx)/4.);\n        prev += vec4(L, 1.)*w;\n    }\n    #endif\n   \n    vec4 light_sampl = ch0(p);\n    \n    float wl = length(light_sampl.xyz);\n    \n    //bias to reduce variance\n    if(!isKeyToggled(KEY_C))\n        light_sampl = clamp(light_sampl, 0., 100.);\n    else\n        light_sampl = clamp(light_sampl, 0., 3000.);\n    float mx = (1.0/TWO_PI)*(1.0/(sigma*sigma) + 1.0);\n   \n    c = prev + vec4(spectral_spektre(wl)*light_sampl.w,1);\n    \n    if(iMouse.z > 1.0 || iFrame < 150)\n    {\n        c.xyz /= c.w/60.0;\n        c.w = 60.0;\n    }\n    \n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGfWc.jpg", "access": "api", "license": "mit", "functions": [[2921, 2921, 2949, 2949, 3009], [3011, 3011, 3039, 3039, 3099], [3102, 3102, 3143, 3143, 3275]], "test": "untested"}
{"id": "wdKfWt", "name": "Xor clouds", "author": "jarble", "description": "This is a simple \"fractal noise\" effect using a [url=https://www.shadertoy.com/view/WsVBDd]xor pattern shader.[/url]", "tags": ["fractal"], "likes": 10, "viewed": 307, "published": 3, "date": "1608258348", "time_retrieved": "2024-07-30T20:29:45.933948", "image_code": "// adapted from FabriceNeyret2's https://www.shadertoy.com/view/wllcRN\n// inspired from python273 https://shadertoy.com/view/4ldyW8\n// See also https://www.shadertoy.com/view/ttscRN\n\nfloat xor_thing(vec2 U){\n    vec2 R = iResolution.xy;\n    ivec2 I = ivec2(U+3.*iTime);\n    int x = I.x, y = I.y,\n        i = x - y ^ y + x;\n    \n    float v = iTime * 0.75 + float(i);  // try also: i*i , i*i*i\n\n    return (fract( v * 0.051618 ));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float scale = 1.0;\n    float result = 0.0;\n    for(int i = 0; i < 10; i++){\n        result += xor_thing(U/scale/pow(2.0,10.0))/10.0;\n        scale /= 2.0;\n    }\n    O = vec4(result);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 207, 207, 431], [433, 433, 471, 471, 660]], "test": "untested"}
{"id": "WdGBWt", "name": "A Trip to Infinity", "author": "TheNosiriN", "description": "Inspired by the infinite corridor: https://castlevania.fandom.com/wiki/Infinite_Corridor", "tags": ["raymarching", "tunnel", "sdf", "trippy", "anamorphic"], "likes": 9, "viewed": 641, "published": 3, "date": "1608242718", "time_retrieved": "2024-07-30T20:29:46.887399", "image_code": "#define RES iResolution.xy\n\n\nfloat NoiseSeed;\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nfloat SCurve (float value, float amount, float correction) {\n\n\tfloat curve = 1.0; \n\n    if (value < 0.5)\n    {\n\n        curve = pow(value, amount) * pow(2.0, amount) * 0.5; \n    }\n        \n    else\n    { \t\n    \tcurve = 1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * 0.5; \n    }\n\n    return pow(curve, correction);\n}\n\n\n\n//Chromatic Abberation from: https://www.shadertoy.com/view/XlKczz\nvec3 chromaticAbberation(sampler2D tex, vec2 uv, float amount)\n{\n    float aberrationAmount = amount/10.0;\n   \tvec2 distFromCenter = uv - 0.5;\n\n    // stronger aberration near the edges by raising to power 3\n    vec2 aberrated = aberrationAmount * pow(distFromCenter, vec2(3.0, 3.0));\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 1; i <= 8; i++)\n    {\n        float weight = 1.0 / pow(2.0, float(i));\n        color.r += texture(tex, uv - float(i) * aberrated).r * weight;\n        color.b += texture(tex, uv + float(i) * aberrated).b * weight;\n    }\n    \n    color.g = texture(tex, uv).g * 0.9961; // 0.9961 = weight(1)+weight(2)+...+weight(8);\n    \n    return color;\n}\n\n\n\n\n//film grain from: https://www.shadertoy.com/view/wl2SDt\nvec3 filmGrain()\n{\n    return vec3(0.9 + randomFloat()*0.15);\n}\n\n\n\n\n//Sigmoid Contrast from: https://www.shadertoy.com/view/MlXGRf\nvec3 contrast(vec3 color)\n{\n    return saturate(vec3(\n        SCurve(color.r, 3.0, 1.0), \n        SCurve(color.g, 4.0, 0.7), \n        SCurve(color.b, 2.6, 0.6)\n    ));\n}\n\n\n\n\n//anamorphic-ish flares from: https://www.shadertoy.com/view/MlsfRl\nvec3 flares(sampler2D tex, vec2 uv, float threshold, float intensity, float stretch, float brightness)\n{\n    threshold = 1.0 - threshold;\n    \n    vec3 hdr = texture(tex, uv).rgb;\n    hdr = vec3(floor(threshold+pow(hdr.r, 1.0)));\n    \n    float d = intensity; //200.;\n    float c = intensity*stretch; //100.;\n    mat2 rot = rotate(30.0);\n    \n    //horizontal\n    for (float i=c; i>-1.0; i--)\n    {\n        float texL = texture(tex, uv+vec2(i/d, 0.0) * rot).r;\n        float texR = texture(tex, uv-vec2(i/d, 0.0) * rot).r;\n        hdr += floor(threshold+pow(max(texL,texR), 4.0))*(1.0-i/c);\n    }\n    \n    \n    hdr *= vec3(0.678,0.804,1.000); //tint\n    \n\treturn hdr*brightness;\n}\n\n\n\n//mip map bloom: https://www.shadertoy.com/view/Ms2Xz3\nconst float Threshold = 0.5;\nconst float Intensity = 2.0;\nconst float BlurSize = 2.0;\n\nvec3 mipMapBloom(vec3 Screen, in sampler2D Tex, in vec2 Coord, in float MipBias)\n{\n\tvec2 TexelSize = MipBias/iChannelResolution[0].xy;\n    \n    vec3  Color = texture(Tex, Coord, MipBias).rgb;\n    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias).rgb;    \t\n    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias).rgb;    \n\n    Color = Color/9.0;\n    vec3 Highlight = clamp(Color-Threshold,0.0,1.0)*1.0/(1.0-Threshold);\n    return saturate(1.0-(1.0-Screen)*(1.0-Highlight*Intensity));\n}\n\n\n\n\n//from: https://www.shadertoy.com/view/4l2GWm\nvec3 quincunxAA(sampler2D tex, vec2 fragCoord, float blur)\n{\n\tvec3 pixelColor;\n\tpixelColor =  texture(tex, (fragCoord + vec2( 0.0, 0.0)) / RES).rgb / 2.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur, blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2( blur,-blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur,-blur)) / RES).rgb / 8.0;\n\tpixelColor += texture(tex, (fragCoord + vec2(-blur, blur)) / RES).rgb / 8.0;\n\treturn pixelColor;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/RES;\n    #ifdef MARGIN\n    if(uv.y < marginSize || uv.y > 1.0-marginSize){ fragColor = vec4(0.0); return; }\n    #endif\n    \n    vec3 color = quincunxAA(iChannel0, fragCoord, 2.0);\n    \n    \n    color = chromaticAbberation(iChannel0, uv, 0.8);\n    color *= filmGrain();\n    color = mipMapBloom(color, iChannel0, uv, BlurSize);\n    color += contrast(flares(iChannel0, uv, 0.9, 200.0, 0.8, 0.04));\n    \n    \n    \n    fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MARGIN\n\nconst float PI = 3.1415972;\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst float marginSize = 0.1;\n\nmat2 rotate(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c = cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvec3 rotateCamera(float len, vec2 m, vec4 mouse)\n{\n    float phi = m.x * PI * 2.0;\n    if(mouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(mouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y) * 0.5 + 0.5;\n}\n", "buffer_a_code": "const float MAX_DIST = 2000.0;\nconst vec4 MAX_VEC = vec4(vec3(0.0), MAX_DIST);\nconst float EPSILON = 0.01;\n\n\n\n\nvec4 min4(vec4 a, vec4 b){\n    return min(a.w, b.w) == a.w ? a : b;\n}\n\n\n\n//fbm and noise from: https://www.shadertoy.com/view/4sfGzS\nconst mat3 m = mat3( \n    0.00,  0.80,  0.60,\n    -0.80,  0.36, -0.48,\n    -0.60, -0.48,  0.64\n);\nfloat noiseTex( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f  = 0.5000*noiseTex( p ); p = m*p*2.01;\n    f += 0.2500*noiseTex( p ); p = m*p*2.02;\n    f += 0.1250*noiseTex( p ); p = m*p*2.03;\n    f += 0.0625*noiseTex( p ); p = m*p*2.01;\n    return f;\n}\n//\n\n\n\nvec4 scene(vec3 p)\n{\n    vec3 tp = p;\n    tp.z *= 5.0;\n    \n    tp.xy -= iTime * 20.0;\n    tp.z += iTime * 1000.0;\n    \n    vec4 d = MAX_VEC;\n    float n = fbm(tp*0.1);\n    float r = n*5.0 + 20.0;\n    float c = length(p.xy)-r;\n    c = max(c, r-0.1-length(p.xy));\n    d = min4(d, vec4(\n        mix(\n            mix(vec3(1.000,0.000,0.502), vec3(0.173,0.369,0.173), saturate(n*n+n)),\n            mix(vec3(0.627,0.376,0.745), vec3(0.490,0.729,0.627), saturate(n*n+n)),\n            n\n        ) * n*2.0, \n    c));\n    \n    return d;\n}\n\n\n\n\nvec4 raymarch(vec3 eye, vec3 dir)\n{\n    vec4 depth = vec4(0);\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 p = eye + dir * depth.w;\n        \n        vec4 dist = scene(p);\n        if (dist.w < EPSILON * length(p)) {\n\t\t\treturn vec4(saturate(dist.xyz), depth.w);\n        }\n        depth.w += dist.w;\n        if (depth.w > MAX_DIST) {\n            return MAX_VEC;\n        }\n    }\n    return MAX_VEC;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    #ifdef MARGIN\n    if(uv.y < (marginSize-0.02) || uv.y > 1.0-(marginSize-0.02)){ fragColor = vec4(0.0); return; }\n    #endif\n    \n    //vec3 eye = rotateCamera(200.0, iMouse.xy/iResolution.xy, iMouse); //uncomment this\n    \n    vec3 eye = vec3(10.0, -8.0, 0.0);\n    vec3 lookAt = vec3(-2.0, -2.0, 100.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 dir = rayDirection(25.0, iResolution.xy, fragCoord);\n    \n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    vec3 col = vec3(0);\n    \n    vec4 dist = raymarch(eye, worldDir);\n    col = vec3(dist.xyz + (dist.w/MAX_DIST)*vec3(0.996,0.820,1.000));\n    \n\n    // Output to screen\n    fragColor = vec4(saturate(col),1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 66, 66, 145], [147, 147, 207, 207, 467], [471, 538, 602, 602, 1216], [1221, 1278, 1296, 1296, 1341], [1346, 1409, 1436, 1436, 1578], [1583, 1651, 1755, 1755, 2331], [2477, 2477, 2559, 2559, 3477], [3482, 3528, 3588, 3588, 4016], [4021, 4021, 4078, 4078, 4549]], "test": "untested"}
{"id": "tsyfDd", "name": "Kummer Surface IV", "author": "mla", "description": "Another visualization of the Kummer quartic surface. A follow on to [url]https://www.shadertoy.com/view/tdsyW4[/url], now with proper tropes (singular tangent planes, that touch the surface in a conic).", "tags": ["surface", "quartic", "trope", "kummer"], "likes": 4, "viewed": 307, "published": 3, "date": "1608234847", "time_retrieved": "2024-07-30T20:29:48.116113", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Kummer Surface IV, Matthew Arcus, mla, 2020.\n//\n// The Kummer Surface, raymarched using the implicit equation as SDF,\n// adjusted by the analytic gradient. Now with properly drawn tropes -\n// tangent planes that touch the surface in a conic.\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <pageup>/<pagedown>: select surface parameter (or allow to vary).\n// <left>/<right>: fog distance or clip radius\n// c: clip at clipradius sphere\n// f: fog\n// l: light transform\n// r: autorotation\n// s: soft shadows\n// x: clip at x-plane\n//\n// The Kummer surfaces are a family of surfaces, parametrized on 'mu'.\n// For mu^2 = 1/3, the surface is a (double) sphere and for mu^2\n// = 1, Steiner's Roman Surface; for mu^2 > 1, the surface becomes\n// infinite, assuming various forms as mu^2 increases. All the\n// surfaces have tetrahedral symmetry.\n//\n// There are 16 tropes, in this projection 4 are circles and 12 are\n// hyperbolas. There are also 16 nodes, 6 nodes lie on each trope, and\n// each node also lies on 6 tropes.\n//\n// The surface can be regarded as the sum of the implicit equation\n// for a sphere, and the equation for a tetrahedron (ie. the product\n// of the plane equations for the four faces). 12 of the nodes are\n// at the intersection points of the sphere and the edges of the\n// tetrahedron.\n//\n// https://mathworld.wolfram.com/KummerSurface.html//\n//\n// Original style somewhat inspired by Man Ray's photographs of mathematical\n// models, taken in the 1930's (at the suggestion of Max Ernst):\n//\n// http://photographmag.com/reviews/man-ray-human-equations-a-journey-from-mathematics-to-shakespeare/\n//\n// (the lead photo is in fact of the Kummer surface, with a different projection), but\n// now with a lighter, brighter alternative.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat AA = 1.0; // 2.0 is better\n\n#if 1\n// A lighter, brighter look\nconst vec3 bgcol = vec3(0,0,0.05);\nconst vec3 tropecol = vec3(1,0,0);\nconst vec3 basecol = vec3(1,1,0.5);\nconst vec3 clipcol = 0.1*basecol;\nvec3 light = vec3(1,4,-4);\nfloat ambient = 0.2;\n#else\n// Man Ray chiaroscuro\nconst vec3 bgcol = vec3(0.01);\nconst vec3 tropecol = vec3(0);\nconst vec3 basecol = vec3(1);\nconst vec3 clipcol = 0.1*basecol;\nvec3 light = vec3(4,1,1);\nfloat ambient = 0.05;\n#endif\n\nint maxsteps = 200;\nfloat maxdist = 25.0;\nfloat precis = 0.00001;\nfloat time = 0.0;\n\nbool dorotate = true; // Autorotate\nbool doclipradius = false;\nfloat clipradius = 2.5;\nbool doclipx = false;\n\n// The Kummer Surface. https://mathworld.wolfram.com/KummerSurface.html\nfloat mu2 = 1.0;\nvec4 kummer4(vec3 pos) {\n  // Return derivative in xyz, function value in w.\n  float x = pos.x, y = pos.y, z = pos.z, w = 1.0;\n  float K = 1.414213562;\n  float p = w-z-K*x;\n  float q = w-z+K*x;\n  float r = w+z+K*y;\n  float s = w+z-K*y;\n  float t = x*x+y*y+z*z-mu2*w*w;\n  float lambda = (3.0*mu2-1.0)/(3.0-mu2);\n  float dx = 4.0*t*x - lambda*K*r*s*(p-q);\n  float dy = 4.0*t*y - lambda*K*p*q*(s-r);\n  float dz = 4.0*t*z - lambda*(-q*r*s-p*r*s+p*q*s+p*q*r);\n  float k = t*t - lambda*p*q*r*s;\n  return vec4(dx,dy,dz,k);\n\n}\n\n// Store sign of implicit function at ray origin here - if negative\n// then we are 'inside' surface and DE and normals must be reversed.\nfloat rosign = 1.0;\n\nfloat eval(vec3 p, out vec3 n, out int type) {\n  vec4 t = kummer4(p);\n  n = t.xyz;\n  float d = t.w/length(n); // Scaled distance\n  type = 0;\n  if (doclipradius) {\n    float d1 = length(p)-clipradius;\n    if (d1 > d) { type = 1; n = p; d = d1; }\n  }\n  if (doclipx) {\n    float d1 = -p.x;\n    if (d1 > d) { type = 2; n = vec3(-1,0,0); d = d1; }\n  }\n  n *= rosign;\n  return rosign*d;\n}\n\nfloat eval(vec3 p) { int type; vec3 n; return eval(p,n,type); }\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.1;\n  for(int i = 0; i < maxsteps; i++) {\n    //assert(i < 50);\n    vec3 p = ro + t*rd;\n    float d = eval(p);\n    if (abs(d) < t*precis) break;\n    // Longer distance estimates can be inaccurate,\n    // so clamp to avoid overstepping.\n    d = min(d,max(0.5,0.1*t));\n    t += d;\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.xz = -rotate(p.xz,time*0.15);\n    //p.yz = rotate(p.yz,0.25*PI);\n    //p.yz = rotate(p.yz,time*0.125);\n  }\n  return p;\n}\n\n// softshadow from iq.\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax, float w) {\n  float t = mint;\n  float res = 1.0;\n  for (int i = 0; i < 200; i++) {\n    float h = eval(ro + t*rd);\n    res = min(res, h/(w*t));\n    t += clamp(h, 0.01*t, max(0.5,0.1*t));\n    if (res < -1.0 || t > tmax) break;\n  }\n  res = max(res,-1.0); // clamp to [-1,1]\n  res = 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n  return res;\n}\n\nfloat getmu2(int n) {\n  int noptions = 6, i = 0;\n  n = mymod(n,noptions);\n  if (n == i++) return 0.33334 + 2.5*(1.0-cos(0.2*time));\n  if (n == i++) return 1.0;\n  if (n == i++) return 2.0;\n  if (n == i++) return 12.0;\n  if (n == i++) return 100.0;\n  if (n == i++) return 0.33334 + exp(0.1*time)-1.0;\n  return 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  time = iTime;\n  // Interesting values of mu2 start at 1/3.\n  mu2 = getmu2(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP));\n  dorotate = !key(CHAR_R);\n  doclipradius = key(CHAR_C);\n  doclipx = key(CHAR_X);\n  float dscale = exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)));\n  maxdist *= dscale;\n  clipradius *= dscale;\n  float camera = 4.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  maxdist = max(maxdist,2.0*camera); // Ensure maxdist is sensible.\n  vec3 ro = vec3(0,0,-camera);\n  ro = transform(ro);\n  rosign = sign(eval(ro)); // Get sign at ray origin\n  if (!key(CHAR_L)) light = transform(light);\n  vec3 aacol = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 rd = vec3(uv,2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      float t = march(ro,rd);\n      vec3 col = bgcol;\n      if (t > 0.0 && t < maxdist) {\n        vec3 p = ro+t*rd;\n        int type; vec3 n;\n        eval(p,n,type);\n        // Sharp edge between clip region and surface means\n        // sometimes we get the wrong normal.\n        if (type == 0 && dot(n,rd) > 1e-2) {\n          type = 1; n = p;\n        }\n        n = normalize(n);\n        if (type != 0) {\n          col = clipcol;\n        } else {\n          col = basecol;\n          //p.xy = abs(p.xy); // Exploit this symmetry? Or general tetrahedral symmetry?\n          // Draw some lines\n          float d = 1e8;\n          // Planes through edge and centre of opposite edge of tetrahedron.\n          float K = sqrt(2.0);\n          // Vertices of base tetrahedron\n          vec3 v0 = vec3(K,0,-1);\n          vec3 v1 = vec3(-K,0,-1);\n          vec3 v2 = vec3(0,K,1);\n          vec3 v3 = vec3(0,-K,1);\n          // 6 edges, sphere (radius mu) intersects each edge in 2 places, eg:\n          //|kv0 + (1-k)v1)| = mu\n          //|k(v0-v1)+v1| = mu\n          //(k(v0-v1)+v1).(k(v0-v1)+v1) = mu2 =\n          // k2(v0-v1).(v0-v1)+2k(v0-v1).v1+v1.v1 -mu2 = 0\n          // A = (v0-v1).(v0-v1)\n          // B = (v0-v1).v1\n          // C = v1.v1-mu2\n          // This can probably be simplified\n          float A = dot(v0-v1,v0-v1); // v0.v0 - 2v0.v1 + v1.v1\n          float B = dot(v0-v1,v1);    // v0.v1 - v1.v1\n          float C = dot(v1,v1)-mu2;   // v1.v1 - mu2\n          float D = B*B-A*C;\n          if (D >= 0.0) {\n            D = sqrt(D);\n            float k = -(B+D)/A;\n            vec3 v01 = k*v0+(1.0-k)*v1;\n            vec3 v10 = k*v1+(1.0-k)*v0;\n            vec3 v02 = k*v0+(1.0-k)*v2;\n            vec3 v20 = k*v2+(1.0-k)*v0;\n            vec3 v03 = k*v0+(1.0-k)*v3;\n            vec3 v30 = k*v3+(1.0-k)*v0;\n\n            vec3 v12 = k*v1+(1.0-k)*v2;\n            vec3 v21 = k*v2+(1.0-k)*v1;\n            vec3 v13 = k*v1+(1.0-k)*v3;\n            vec3 v31 = k*v3+(1.0-k)*v1;\n            vec3 v23 = k*v2+(1.0-k)*v3;\n            vec3 v32 = k*v3+(1.0-k)*v2;\n\n            d = min(d,planedist(p,v01,v02,v13)); // v23 also in plane\n            d = min(d,planedist(p,v01,v03,v12)); // v32 also in plane\n            d = min(d,planedist(p,v02,v03,v21)); // etc.\n\n            d = min(d,planedist(p,v10,v12,v03));\n            d = min(d,planedist(p,v10,v13,v02));\n            d = min(d,planedist(p,v12,v13,v20));\n\n            d = min(d,planedist(p,v20,v21,v03));\n            d = min(d,planedist(p,v20,v23,v01));\n            d = min(d,planedist(p,v21,v23,v10));\n\n            d = min(d,planedist(p,v30,v31,v02));\n            d = min(d,planedist(p,v30,v32,v01));\n            d = min(d,planedist(p,v31,v32,v10));\n          }\n          d = min(d,planedist(p,v0,v1,v2));\n          d = min(d,planedist(p,v0,v1,v3));\n          d = min(d,planedist(p,v0,v2,v3));\n          d = min(d,planedist(p,v1,v2,v3));\n          col = mix(tropecol,col,0.1+0.9*smoothstep(0.0,0.0005,d/t));\n        }\n        vec3 lightdir = normalize(light); // Light at infinity\n        //vec3 lightdir = normalize(light-p);\n        float diffuse = (1.0-ambient)*max(0.0,dot(n,lightdir));\n        if (key(CHAR_S)) diffuse *= softshadow(p,lightdir,0.01,4.0*max(1.0,length(p)),0.1);\n        col *= ambient+diffuse;\n        float fog = key(CHAR_F) ? 0.0 : t/maxdist;\n        col = mix(col,bgcol,fog);\n      }\n      aacol += col;\n    }\n  }\n  aacol /= float(AA*AA);\n  aacol = pow(aacol,vec3(0.4545));\n  fragColor = vec4(aacol,1);\n  if (check) fragColor.r = 1.0;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\nbool check = false;\nvoid assert(bool b) {\n  if (!b) check = true;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n// Distance of p from plane through q,r,s.\nfloat planedist(vec3 p, vec3 q, vec3 r, vec3 s) {\n  vec3 n = normalize(cross(q-r,q-s));\n  return abs(dot(p-q,n));\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nint mymod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\n", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2671, 2671, 2695, 2747, 3189], [3349, 3349, 3395, 3395, 3731], [3733, 3733, 3753, 3753, 3796], [3798, 3798, 3829, 3829, 4178], [4180, 4180, 4207, 4207, 4569], [4571, 4594, 4663, 4663, 4996], [4998, 4998, 5019, 5019, 5312], [5314, 5314, 5366, 5366, 9757]], "test": "untested"}
{"id": "wsGBWd", "name": "Day 357", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 30, "viewed": 1017, "published": 3, "date": "1608221832", "time_retrieved": "2024-07-30T20:29:49.012716", "image_code": "\n// CHEAP NOISE FROM NIMITZ https://www.shadertoy.com/view/XtS3DD\n// RENDERING TECHNIQUE LEARNED FROM IQ'S \"CLOUDS\"\n#define iTime (iTime + iMouse.x/iResolution.x)\n\nfloat valueNoise(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}\n\n\nfloat fbm(vec3 p){\n\n    vec3 op = p;\n    float n = 0.;\n    p *= 0.5;\n    p.y += iTime*0.5;\n    float fa = valueNoise(p,1.); \n    \n    p.y += fa*(1. + sin(op.z + iTime*0.2)*0.5);\n    p.x += iTime*.325;\n    p.y -= iTime*0.25;\n    \n    float fb = valueNoise(p*2.,1.);\n    \n    \n    p.x += fb*.2 + iTime*0.1;\n    p.z += fb*1.1 + iTime*0.02;\n    float fd = valueNoise(p*9.8,1.);\n    \n    float fc = valueNoise(p*4.2,1.);\n    \n    \n\n    n = fa*1. + fb*0.55 + fc*0.244 + fd*0.146*(0.6 - fa) /*fa*/;// + valueNoise(op*5.8,1.)*0.0;\n    \n    \n    //n*= 1.1;\n    \n    //n = smoothstep(0.,1.,n);\n    //n = pow(n,1. + fa*2.);\n    \n    \n    //n *= pow(valueNoise(op + 24.,4.),0.4)*3.;\n    \n    \n    n*= 0.6;\n    \n    n = smoothstep(0.,1.,n);\n    n = pow(n,1. + fa*1.5);\n    \n    n *= pow(valueNoise(op*0.3 + 1.,1.),0.4)*1.;\n    n *= 2.4;\n    return clamp( (1. - op.y*0.1 + abs(op.x)*0.4 - 3.0 + 2.*n) , 0.0, 1.0 );\n\n\treturn n;\n}\n\n//vec3 ro;\n\nfloat map(vec3 p){\n    float d = 10e5;\n    vec3 op = p;\n    \n    p.xy *= rot(p.z*0.14);\n    \n    \n    p.z += iTime;\n    p.y += sin(iTime)*0.2 + 0.;\n    //p.xy *= rot(p.z*0.1);\n    \n    p.xy *= rot(sin(p.z*0.2 + iTime*0.2)*0.4);\n    \n    d = fbm(p);\n    \n    \n    float dopop = dot(op,op);\n    \n    d *= smoothstep(0.,1., (length(p.xy)*0.6 - 2.4)*smoothstep(1.,0.,\n        dopop*.03) + smoothstep(0.,1., dopop*.01)\n        );\n    \n    \n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.12,0.14,0.14)*1.6;\n    col = vec3(0.14,0.14,0.12)*1.6;\n\n\n    col += sin(uv.xyx*0.2 + iTime*0.4)*0.1;\n    \n    \n    col += sin(uv.xyx*0.2 )*0.1;\n    \n    vec3 lightDir = normalize(vec3(-1.,1.,2.));\n\n    mat2 lightRot = rot(iTime*0.5); \n    \n    lightDir.xy *= lightRot;\n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv,0.9));\n    \n    rd.yz *= rot(sin(iTime*0.25)*0.2);\n    \n    vec3 p = ro;\n    \n    \n    float stSz = 0.1;\n    float dTotal = 0.;\n    vec3 accum = vec3(0);\n    \n    ro += 0.2*rd*hash13(vec3(uv*220.,1.+ iTime*4.));\n    \n    vec3 lightCol;\n    \n    \n    \n    float steps = 200.;\n    float i = 0.;\n    float t = 0.;\n    for(; i < steps; i++){\n        float dCurr = map(p);\n        float dOther = map(p + lightDir*.15 );\n        \n        lightCol = vec3(0.4 + sin(iTime*0.25 + p.z*0.0)*0.2,0.2,0.1);\n        vec3 colDiff = vec3(0.115,0.4,0.4)*0. + col*0.7 + 32.7*lightCol*clamp((dCurr - dOther*1.)*0.6,0.,1.); \n        vec3 colAbsorption = mix(vec3(0.47 + sin(iTime + p.z)*0. - 0.2,0.5,.65)*0.5, vec3(0.4,0.2,0.9)*0.2, smoothstep(0.,1.,dTotal)); \n        vec3 colFringe = clamp( (1. - dCurr*2.)*lightCol*vec3(0.8,0.9,.9 )*0.2, 0., 1.);\n        \n        if(dTotal > 1. || t > 20222.){\n            break;\n        }\n        \n        \n        float fade = pow(smoothstep(0.,1.,(p.z - ro.z)*0.03),0.75);\n        \n        vec3 colCurr = mix( (colDiff)*colAbsorption + colFringe*1.9 , col, fade);\n        dCurr *=  1. -fade;\n        accum += dCurr*colCurr*(1. - dTotal)*stSz;\n        dTotal += dCurr*stSz*(1. - dTotal);\n        t += max(stSz,i/steps*2.*stSz);\n        //p += rd*t;\n        p = ro + rd*t;\n    }\n\n\n    //lightCol = vec3(0.4 + sin(iTime*0.45)*0.2,0.2,0.1);\n        \n    \n    col = mix(col,accum*1.,pow(dTotal, 1.) );\n    col += smoothstep(1.,0.,length( (uv + vec2(0.7,-0.4)*lightRot) ) + 0.1)*lightCol*(0.2 + 0.*accum*accum*dTotal);\n    \n    \n    col = mix(col,smoothstep(0.,1.,col*1.7),0.7);\n    col = mix(col,smoothstep(0.,1.,col*1.6),1.);\n    \n    col *= smoothstep(1.,0.3,dot(uv,uv)*0.6 + 0.2);\n    col = pow(max(col,0.),vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\nmat2 rot(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nfloat valueNoiseo(vec3 uv,float pw){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    fd = pow(fd,vec3(pw));\n    \n    float ibl = hash13(id + vec3(0,-1,0));\n    float ibr = hash13(id + vec3(1,-1,0));\n    float itl = hash13(id + vec3(0));\n    float itr = hash13(id + vec3(1,0,0));\n    \n    \n    float jbl = hash13(id + vec3(0,-1,1));\n    float jbr = hash13(id + vec3(1,-1,1));\n    float jtl = hash13(id + vec3(0,0, 1));\n    float jtr = hash13(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 202, 202, 422], [425, 425, 443, 443, 1339], [1353, 1353, 1371, 1371, 1803], [1804, 1804, 1861, 1861, 4049]], "test": "untested"}
{"id": "wdGfDt", "name": "paisaje-2d n4", "author": "jorge2017a1", "description": "paisaje-2d n4", "tags": ["paisaje2dn4"], "likes": 4, "viewed": 246, "published": 3, "date": "1608217108", "time_retrieved": "2024-07-30T20:29:49.834519", "image_code": "//por jorge2017a ---17/dic/2020\n//recursos\n//https://iquilezles.org/articles/distfunctions2d\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{ if (d1.x<d2.x) return d1; else return d2; }\n\nvec2 opS2( vec2 d1, vec2 d2 )\n{ if  (-d1.x<d2.x) return d1; else  return d2; }\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{  if (d1.x>d2.x)\treturn d1; else return d2;  }\n\nvec2 opS(vec2 d1, vec2 d2) \n{ return vec2(max(-d2.x, d1.x), 2.0); }\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q; }\n\nfloat sdCirc(vec2 p, float r)\n{ return length(p)-r; }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0); }\n\n\nvec2 BloqueSimple(vec2 p)\n{ \n    vec2 resp=vec2(9999.9,-1.0);\n    float b1= sdBox(p-vec2(0.0), vec2(0.4,0.2) );\n    float b1v= sdBox(p-vec2(0.0,0.19), vec2(0.4,0.02) );\n    float b1h= sdBox(p-vec2(-0.38,0.0), vec2(0.02,0.2) );\n    b1=opS(b1v, b1);\n    b1=opS(b1h, b1);\n    resp=opU2(vec2(b1, 38.0), resp);\n    resp=opU2(vec2(b1v, 1.0), resp);\n    resp=opU2(vec2(b1h, 1.0), resp);\n    return resp;\n}\n\nvec2 nubes(vec2 p)\n{   vec2 resp=vec2(9999.9,-1.0);\n    float c1= sdCirc(p-vec2(0.0,0.05), 0.105);\n    float c2= sdCirc(p-vec2(0.15,0.02), 0.065);\n    float c3= sdCirc(p-vec2(-0.15,0.02), 0.065);\n    float b1=sdBox(p-vec2(0.0,-0.05), vec2(0.24,0.045 ) );\n    float ctodo;\n    ctodo=opU(c1,c2);\n    ctodo=opU(c3,ctodo);\n    ctodo=opS(b1, ctodo);\n    resp=opU2(vec2(ctodo,1.0 ),resp);\n\treturn resp;\n    \n}\n\n\nvec2 PastoTrapezoid(vec2 p)\n{   vec2 resp=vec2(9999.9,-1.0);\n     p=rotate2d(p-vec2(0.0,-0.73), radians(180.0));\n    float sdt1= sdTrapezoid( p, 0.01, 0.15, 0.15 );\n    resp=opU2(vec2(sdt1,12.0 ),resp);\n\treturn resp;\n}\n\n\nvec2 LLuvia(vec2 p)\n{   vec2 resp=vec2(9999.9,-1.0);\n    p=rotate2d(p-vec2(0.0,-0.73), radians(140.0));\n    vec2 c =vec2(0.5,0.5 );\n    vec2 pp=opRep2D(p-vec2(0.0,iTime), c);\n    float sb1= sdBox( pp,vec2(0.005,0.03) );\n    resp=opU2(vec2(sb1,0.0 ),resp);\n\treturn resp;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    //p*= 4.0;\n    p.x+=iTime;\n\tvec3 col = vec3(0.280,0.320,1.0);\n    \n    vec2 pp=p*4.0;\n    vec2 pp1=p*0.5;\n    vec2 pp4=p*0.35;\n    \n    vec2 c=vec2(0.83,11.0);\n    vec2 p1= opRep2D(pp,c  );\n    vec2 c2=vec2(0.83,10.0);\n    vec2 p2= opRep2D(pp1,c2  );\n    vec2 c3=vec2(0.83,15.0);\n    vec2 p3= opRep2D(pp1-vec2(0.2,0.0),c2  );\n    vec2 c4=vec2(0.83,15.0);\n    vec2 p4= opRep2D(pp4-vec2(-0.3,0.2),c2  );\n    vec2 c5=vec2(0.3,11.0);\n    vec2 p5= opRep2D(p,c5  );\n    \n    float ypos=-3.8;\n    \n    vec2 b2=BloqueSimple(p1-vec2(0.0,ypos));\n    vec2 N1=nubes(p2-vec2(0.0,0.2));\n    vec2 N2=nubes(p3-vec2(0.0,0.1));\n    vec2 N3=nubes(p4-vec2(0.0,0.0));\n    \n    vec2 Pa1= PastoTrapezoid(p5);\n    vec2 ll1= LLuvia(p);\n    \n    vec3 cb2= getColorf(b2.y);\n    vec3 cN1= getColorf(N1.y);\n    vec3 cN2= getColorf(N2.y);\n    vec3 cN3= getColorf(N3.y);\n    vec3 cPa1=getColorf(Pa1.y);\n    vec3 cll1=getColorf(ll1.y);\n    \n    col= DibujoConBorde(p, N3.x, cN3,  col);\n    col= DibujoConBorde(p, b2.x, cb2,  col);\n    col= DibujoConBorde(p, N1.x, cN1,  col);\n    col= DibujoConBorde(p, N2.x, cN2,  col);\n    col= DibujoConBorde(p, Pa1.x, cPa1,  col);\n    col= DibujoConBorde(p, ll1.x, cll1,  col);\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{ vec3 color; };\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.,  //37 //marron o cafe\nvec3(0.8, 0.1, 0.1) //rojo //38\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\nvec3 getColorf(float ii)\n{\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 DibujoConBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nvec3 DibujoSinBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    //colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    colOut = mix(colOut, colIn, uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 rotate2d(vec2 p, float ang)\n{\n    float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);  float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 270, 270, 292], [293, 293, 326, 326, 348], [349, 349, 382, 382, 403], [405, 405, 437, 437, 481], [483, 483, 514, 514, 561], [563, 563, 595, 595, 641], [643, 643, 672, 672, 710], [712, 712, 750, 750, 794], [796, 796, 827, 827, 849], [851, 851, 888, 888, 961], [964, 964, 991, 991, 1362], [1364, 1364, 1384, 1384, 1767], [1770, 1770, 1799, 1799, 1988], [1991, 1991, 2012, 2012, 2267], [2269, 2269, 2326, 2376, 3699]], "test": "untested"}
{"id": "tdyfWt", "name": "Twisted Helices", "author": "dr2", "description": "Based on \"Twisted Curves\" (endless possibilities...)", "tags": ["helix", "symmetry"], "likes": 11, "viewed": 297, "published": 3, "date": "1608213278", "time_retrieved": "2024-07-30T20:29:50.679260", "image_code": "// \"Twisted Helices\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat TwTorusDf (vec3 p, float cvOrd, float cvWrapI, float ri, float rc, float rt)\n{\n  vec2 u;\n  float s;\n  u = Rot2D (vec2 (length (p.xz) - rc, p.y), cvWrapI * atan (p.z, p.x));\n  s = 2. * pi / cvOrd;\n  u = Rot2D (u, - s * (floor ((0.5 * pi - atan (u.x, u.y)) / s + 0.5)));\n  return 0.4 * (length (vec2 (u.x - ri, u.y)) - rt);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin, d;\n  dMin = dstFar;\n  d = TwTorusDf (p, 8., -1., 0.5, 2., 0.25);\n  DMIN (1);\n  d = TwTorusDf (p, 7., 5., 0.6, 2., 0.21);\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n    else if (idObj == 2) col4 = vec4 (0.7, 0.2, 0.1, 0.2);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * nDotL * nDotL) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.05 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -15.);\n  zmFac = 6.;\n  dstFar = 50.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[355, 355, 439, 439, 684], [686, 686, 708, 708, 872], [874, 874, 907, 907, 1091], [1093, 1093, 1114, 1114, 1369], [1371, 1371, 1406, 1406, 1950], [1994, 1994, 2050, 2050, 3093], [3095, 3095, 3131, 3131, 3337], [3339, 3339, 3369, 3369, 3482]], "test": "untested"}
{"id": "3dyfDV", "name": "[♪]Rikka 2", "author": "Catzpaw", "description": "polished version of \"rikka\" http://glslsandbox.com/e#52473.0", "tags": ["raymarching", "music"], "likes": 19, "viewed": 687, "published": 3, "date": "1608210750", "time_retrieved": "2024-07-30T20:29:51.643681", "image_code": "//--- Rikka 2\n// by Catzpaw 2020\n\n//Image:post effect\n\n//CHROMATIC ABERRATION\n#define ZERO min(0,iFrame)\nvec3 tx1(vec2 uv){return texture(iChannel1,uv).rgb;}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nvec3 ca(vec2 uv,vec2 xy){\n    vec2 uvr=uv-xy*.015;\n    vec3 c=vec3(0);\n    float f=0.;\n    for(int i=ZERO;i<10;i++)c+=tx1(mix(uvr,uv,f)).rgb*hsv(f+.85,1.,1.),f+=.1;\n    return c*.3;\n}\n\n//MAIN\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord/iResolution.xy;\n    vec2 xy=(fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    fragColor=vec4(ca(uv,xy)*pow(1.1-length(xy),.3),texture(iChannel1,uv).a);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//--- Rikka 2\n// by Catzpaw 2020\n\n//Buffer A:animation\n\n//SETUP\n#define OCT 5\n#define ITER 170\n#define EPS 7e-3\n#define NEAR 0.1\n#define FAR 13.0\n\nfloat time;\n\n//SNIPPETS\n#define ZERO min(0,iFrame)\nfloat hash(float v){return fract(sin(v*22.9)*67.);}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\n\n//SDF\nvec2 hexFold(vec2 p){return abs(abs(abs(p)*mat2(.866,.5,-.5,.866))*mat2(.5,-.866,.866,.5));}\nfloat sdHex(vec3 p){p=abs(p);return max(p.z-.02,max((p.x*.5+p.y*.866),p.x)-.015);}\n\n//SCENE\nfloat map(vec3 p){\n\tfloat h=hash(floor(p.x)+floor(p.y)*133.3+floor(p.z)*166.6),o=FAR,s=1.+h;\n\tp=fract(p)-.5;\n    p.y+=h*.4-.2;\n    p.xz*=rot(time*(h+.8));\n    p.yz*=rot(time+h*5.);\n    h=hash(h);p.x+=h*.15;\n    float l=dot(p,p);\n    if(l>.1)return l*2.;\n \tfor(int i=ZERO;i<OCT;i++){\n\t\tp.xy=hexFold(p.xy);\n\t\tp.xy*=mat2(.866,-.5,.5,.866);\n\t\tp.x*=(s-h);\n\t\th=hash(h);p.y-=h*.065-.015;p.y*=.8;\n        p.z*=1.2;\n\t\th=hash(h);p*=1.+h*.3;\n\t\to=min(o,sdHex(p));\n        h=hash(h);s=1.+h*2.;\n    }\n\treturn o;\n}\n\n//RAYMARCHING\nfloat trace(vec3 ro,vec3 rd,out vec3 n){\n\tfloat t=NEAR,d;\n    float eps;\n\tvec3 p;\n\tvec2 e=vec2(.1,-.1);\n\tfor(int i=ZERO;i<ITER;i++){\n        float l=log(t+1.);\n        eps=EPS*l;\n\t\tp=ro+rd*t;\n\t\td=map(p);\n\t\tif(d<eps||t>FAR)break;\n\t\tt+=step(d,.3)*d*.2+d*l*.16;\n\t}\n\tn=normalize(e.xyy*map(p+e.xyy*eps)+e.yyx*map(p+e.yyx*eps)+e.yxy*map(p+e.yxy*eps)+e.xxx*map(p+e.xxx*eps));\n\treturn min(t,FAR);\n}\n\n//BACKGROUND\nvec3 tx0(vec3 rd){float v=abs(dot(rd,vec3(.35,-.5,.35)));return vec3(v);}\n//vec3 tx0(vec3 rd){return texture(iChannel0,rd).rgb*.4;}\n\n//MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time=iTime+117.7;\n\tvec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tvec3 n,ro=vec3(-.9,time*.4,-.9),rd=normalize(vec3(uv*.7,1.));\n    rd.yz*=rot(.45);\n    rd.xz*=rot(.78);\n    float d=trace(ro,rd,n);\n\tfloat v=1.-d*(1./FAR),s=pow(1.-abs(dot(n,normalize(-rd))),5.);\n    v=v>.01?v:0.;\n    vec3 c=vec3(.0,.1,.2)+tx0(rd)*.5;\n    c+=v>.01?(tx0(n)+s)*v:vec3(0);\n    \n\tfragColor=vec4(c,d/FAR);\n}\n", "buffer_a_inputs": [], "sound_code": "//--- Rikka 2\n// by Catzpaw 2020\n\n//Sound:scale sequencer 3\n//https://www.shadertoy.com/view/ts3fDN\n\n//================================================================================\n// SETUP\n//--------------------------------------------------------------------------------\nconst float base =442.;\t//master tuning (Hz)\nconst float bpm  = 80.;\t//beats per minute\nconst float steps=240.;\t//steps per measure (default:240steps)\nconst float start=1.;   //start count (beats)\nconst float fade =10.;  //fade out time (default:10sec)\nconst float sec  =180.; //performance time (includes fade out time and start count)\n\nconst float gateSeed=160.; //random seed for gate generator;\nconst float noteSeed=112.; //random seed for note generator;\n\n//SCALE\nint key=4; //0:C 1:C+ 2:D 3:D+ 4:E 5:F 6:F+ ... 11:B\n//const uint[4] scl=uint[](0xcb975420u,0xcb975420u,0xcb975420u,0xcb975420u); //major,major,major,major\nconst uint[4] scl=uint[](0xcb975420u,0xca875320u,0xcb875320u,0xcb975320u); //major,minor,harmonic,melodic\n//const uint[4] scl=uint[](0xca875320u,0xca875320u,0xcb875320u,0xcb975320u); //minor,minor,harmonic,melodic\n//const uint[4] scl=uint[](0xc9974420u,0xca775530u,0xca775530u,0xca775530u); //pentatonic(major,minor)\n//const uint[4] scl=uint[](0xcb775540u,0xcb755420u,0xcb755420u,0xcb755420u); //ryukyu(pentatonic,hexatonic)\n//const uint[4] scl=uint[](0xba875410u,0xba875410u,0xba875410u,0xba875410u); //maqam hijaz octatonic\n//const uint[4] scl=uint[](0xba876320u,0xba876320u,0xba876320u,0xba876320u); //gypsy minor octatonic\n\n//================================================================================\n// SEQUENCE DATA\n//--------------------------------------------------------------------------------\n//CHORD SEQUENCE (version 3)\n//div1(2),scale2(2),div2(2),scale3(2),chord1(8),chord2(8),chord3(8)\n//chord:\n//  00-07:I,I,II,III,IV,V,VI,VII\n//  +00:triad\n//  +10:-3\t  +18:+3\n//\t+20:-5\t  +28:+5\n//\t+30:-3-5  +38:+3+5\n//\t+40:add9\n//\t+80:diatonic6(m6 or 6)\n//\t+c0:diatonic7(7 or M7)\n//  Example...symbol:C7 = key:C,scale:minor,chord:Im7+3 = 0x01+0x18+0xc0 = 0xd9\nconst int chordlen=16;const uint chordseq[chordlen]=uint[](\n\t0x00000041u,0x00000001u,0x000000c1u,0x00000081u,\n\t0x00000041u,0x00000001u,0x000000c1u,0x00000081u,\n\t0x44032346u,0x08000214u,0x4403c6c3u,0x08001581u,\n\t0x08001404u,0x84150434u,0x4803c622u,0x08001585u\n);\n\n//PATTERN (version 3)\n// melodic:range(4),rest(4),seed1(12),seed2(12)\n// percussive:note(2x16)\n// You can set up to 256 patterns.\nconst uint[32] pat=uint[](\n    0x0f000000u,0x00000000u,0x08008001u,0x070af101u,  //00-03 mute(melo),mute(perc),chord,chord\n    0x45164300u,0x46214603u,0x55104143u,0x46170443u,  //04-07 melody\n    0x45043102u,0x47476291u,0x54973175u,0x36390700u,  //08-0B melody\n    0x460e121cu,0x45043100u,0x37393701u,0x00000000u,  //0C-0F melody\n    0x00000000u,0x00000000u,0x00000000u,0x00000000u,  //10-13 \n    0x70333444u,0x00000000u,0x66111202u,0x00000000u,  //14-17 accompaniment,bass\n    0x313aa13au,0x513aa186u,0x323a323au,0x5556a186u,  //18-1B sd+hh\n    0x91e121e1u,0x55e121e5u,0x4db18db1u,0x55919d55u); //1C-1F bd+conga\n\n//PATTERN SEQUENCE (version 3)\n// speed1(2),speed2(2),division(4),top1(4),pattern1(8),top2(4),pattern2(8)\n// speed    0:1x 1:2x 2:0.25x 3:0.5x\n// top      0-e ... auto inversion amount (0:no inversion 7:octave)\n// division 0-f ... timing to switch pattern1 to pattern2 (0:only pattern2 8:half)\n// The length of each sequence is unlimited.\nconst int len1= 8;const uint[len1] seq1=uint[]( //snare+hihat\n    0x00000018u,0x00000018u,0x00000018u,0x08018019u,\n    0x00000018u,0x00000018u,0x00000019u,0x0000001bu);\nconst int len2= 4;const uint[len2] seq2=uint[]( //bassdrum+conga\n    0x0000001eu,0x0000001eu,0x0000001eu,0x0e01e01fu);\nconst int len3= 1;const uint[len3] seq3=uint[]( //bass\n    0x00000616u);\nconst int len4= 1;const uint[len4] seq4=uint[]( //chord\n    0x00000003u);\nconst int len5= 2;const uint[len5] seq5=uint[]( //accompaniment\n    0xa0000814u,0xe8814814u);\nconst int len6=16;const uint[len6] seq6=uint[]( //melody\n    0x00000004u,0x00000005u,0x00000006u,0x00000007u,\n    0x00000004u,0x00000005u,0x00000006u,0x0000000cu,\n    0x00000008u,0x00000009u,0x0000000au,0x0000000bu,\n    0x0000000du,0x00000009u,0x0000000au,0x0000000eu);\n\n\n//================================================================================\n// INSTRUMENTS & EFFECTS\n//--------------------------------------------------------------------------------\n//AMP\n//  vec3 p( drive, pressure, volume)\nvec2 amp(vec2 i,vec3 p){return clamp(sign(i)*pow(abs(i*p.x)*.01,vec2(1./p.y))*100.,-1.,1.)*p.z;}\n\n//FREQUENCY FROM MIDI NOTE NUMBER\nconst float i12=1./12.;\nfloat freq(float n){return pow(2.,(n-69.)*i12)*base;}\n\n//FOLDBACK DISTORTION (input,threshould,ratio)\nfloat fbdist(float v,float t,float f){return abs(v)>t?sign(v)+(t-v)*f:v;}\n\n//ENVELOPE\nfloat env_d(float x,float d){return max(0.,1.-x/max(d,1e-4));}\n\n//NES SOUND GENERATORS(without DPCM)\nfloat osc_duty(float x,float d){return fract(x)<d?1.:-1.;}\n//float osc_tri4(float x){return abs(floor(fract(x)*15.9999)/7.5-1.);}\nconst float nc=1789772.5;const float[16] nt=float[](\n    nc/2.,nc/4.,nc/8.,nc/16.,nc/32.,nc/48.,nc/64.,nc/80.,nc/101.,\n    nc/127.,nc/190.,nc/254.,nc/381.,nc/508.,nc/1017.,nc/2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*nt[i])*179.2)*204.8);}\n\n/*\n//WAVETABLE OSC(namco C30/N163)\n//sound0:flute  ADFF DA75 4456 9ABB A852 0025\n//sound1:brass  BFED ED93 0378 78CF C621 2104\n//sound2:organ  87D7 F7F7 D7A7 8582 8080 8287\n//sound3:piano  BEFF EBA9 9998 7666 6541 0014\n//sound4:harpsi BDEF 000F EDB9 6421 0fff 0124\n//sound5:bass   0033 2266 0033 CCFF 99DD CCFF\n//sound6:octsqr 0000 00AA AAAA 5555 55FF FFFF\n//sound7:octsaw 0123 4567 89AB 4567 89AB CDEF\nconst int wtsamples=24;\nconst float wtlen=float(wtsamples);\nconst uint[wtsamples] wt=uint[](\n    0x000bb8bau,0x100de7fdu,0x203efdefu,0x303ff7dfu,0x4020efedu,0x5020b7dau,0x6a60af97u,0x7a6f9735u,\n    0x8a0e9d04u,0x9a0d9734u,0xaa3b9a75u,0xba398786u,0x45c67879u,0x55c4658au,0x65f268cbu,0x75f162fbu,\n    0x859068cau,0x959f5068u,0xafdf4825u,0xbfdf1012u,0xcfc00820u,0xdfc10210u,0xeff21802u,0xfff44745u);\nconst float i15=1./15.;\nfloat osc_c30(float x,int i){return(float((wt[int(mod(x*wtlen,wtlen))]>>(i*4))&15u)*i15-.5);}\n\n//CHIPTUNE INSTRUMENTS (freq,time)\nconst float detune =.0025;\nvec2 dutybass(float f,float x){return vec2(osc_duty(f*(.5+detune),.5),osc_duty(f*(.5-detune),.5))*env_d(x,.5);}\nvec2 tri4bass(float f,float x){return vec2(osc_tri4(f*(.5+detune)),osc_tri4(f*(.5-detune)));}\nvec2 tri4lead(float f,float x){return vec2(osc_tri4(f*(1.-detune)),osc_tri4(f*(1.+detune)));}\n//vec2 c30bass(float f,float x){return vec2(osc_c30(f*(1.+detune),5),osc_c30(f*(1.-detune),5))*env_d(x,.5);}\n//vec2 c30piano(float f,float x){return vec2(osc_c30(f*(1.-detune),3),osc_c30(f*(1.+detune),3))*max(env_d(x,.05),env_d(x,2.5)*.6);}\nvec2 c30chord(float f,float x){return vec2(osc_c30(f*(1.-detune),7),osc_c30(f*(1.+detune),7));}\nvec2 c30bell(float f,float x){return vec2(osc_c30(f*(1.-detune),1),osc_c30(f*(1.+detune),1))*env_d(x,.6);}\nvec2 c30lead(float f,float x){return vec2(osc_c30(f*(1.-detune),6),osc_c30(f*(1.+detune),6))*env_d(x,.5);}\n*/\n\n//CHIPTUNE PERCUSSION (time)\n//float nessd(float x){return osc_nesnoise(x,11)*env_d(x,.25);}\nfloat neshh(float x,float d){return osc_nesnoise(x,0)*env_d(x,d);}\n//float nesbd(float x){return osc_duty(3./(x*.5+.1),.5)*env_d(x,.2);}\nfloat neslc(float x){return osc_duty(6./(x*.4+.1),.6)*env_d(x,.025);}\nfloat neshc(float x){return osc_duty(10./(x*.4+.1),.6)*env_d(x,.025);}\n\n/*\n//LPF\n#define LPFI 96\n#define LPF(fn) float b=0.,o=0.;c+=1e-10;n=freq(n);for(int i=0;i<LPFI;i++){float f=n*(x+float(i)/iSampleRate);b+=c*((fn)+q*(b-o)/(1.-c)-o);o+=c*(b-o);}return o;\n\n//SAW WITH LPF (note,time,cutoff,lpq)\nfloat lpfsaw(float n,float x,float c,float q){LPF(mod(f,2.)-1.)}\n\n//C30 WITH LPF (note,time,cutoff,lpq,sound)\nfloat lpfc30(float n,float x,float c,float q,int s){LPF(osc_c30(f,s))}\n*/\n\n//FM INSTRUMENTS (freq,time)\nfloat fmbass(float f,float x){f*=6.283;return fbdist(sin(f*2.03)*.5+sin(f*2.+sin(f+sin(f*7.51)*env_d(x,.07))*env_d(x,.2)),1.,.02)*env_d(x,.5);}\nfloat fmharpsi(float f,float x){f*=6.283;return (sin(f+sin(f*5.+sin(f*9.))))*env_d(x,.7);}\n//float fmvibe(float f,float x){f*=6.283;return (sin(f+sin(f*9.)))*env_d(x,.9);}\nfloat fmep(float f,float x){f*=6.283;return (sin(f+sin(f*15.)*env_d(x,.5)*.6))*env_d(x,.7);}\n//float fmmarimba(float f,float x){f*=6.283;return (sin(f+sin(f*3.99+sin(f*5.3)*env_d(x,.08))*env_d(x,.3)))*env_d(x,.4);}\n//float fmguitar(float f,float x){f*=6.283;return fbdist(sin(f+sin(f*3.01+sin(f*3.49)*env_d(x,.4))*env_d(x,.7)*.6)*1.3*env_d(x,.9),1.,1.);}\nfloat fmpad(float f,float x){f*=6.283;return sin(f+sin(f*1.01))*(.9+sin(x*60.)*.1);}\n\n//PERCUSSION INSTRUMENTS (time)\nfloat bd(float x){return sin(x*freq(84./(1.+x*.7)))*env_d(x,.5);}\nfloat sd(float x){return (osc_nesnoise(x,11)*.7*env_d(x,.2)+sin(x*freq(81.5/(1.+x*.05)))*env_d(x,.25));}\n//float hh(float x,float d){return osc_nesnoise(x,3)*env_d(x,d);}\n\n//================================================================================\n// SEQUENCER\n//--------------------------------------------------------------------------------\n//BIT OPERATION\nint imod(int x,int y){return int(x-y*(x/y));}\nint get12(uint b,int l){return int(b>>l*4)&4095;}\nint get8(uint b,int l){return int(b>>l*4)&255;}\nint get4(uint b,int l){return int(b>>l*4)&15;}\nint get2(uint b,int l){return int(b>>l*2)&3;}\nint get3(int b,int p){return int(b>>p)&7;}\n\n//GET NOTE FROM SCALE\nint degree=0;uint scale=0u;\t//internal use\nint scaleNote(int y){int n=y>6?12:0;return y<-50?-99:key+int((scale>>((y+56)%7)*4)&15u)+n;}\n\n//GET PATTERN FROM SEQUENCE\nfloat mp=0.; //note length multiplier(from speed)\nint   to=0;  //top note for auto inversion\nuint  pt=0u; //pattern now playing\nint   st=0;  //step now playing\nconst vec4 spd=vec4(16.,32.,4.,8.);\nvoid getPattern(float t,uint sq){\n    bool di=int(mod(t*bpm*16./steps,16.))<get4(sq,6);\n    to=di?get4(sq,5):get4(sq,2);\n    pt=di?pat[get8(sq,3)]:pat[get8(sq,0)];\n    mp=spd[di?get2(sq,15):get2(sq,14)];\n    st=int(mod(t*bpm*mp/steps,16.));\n}\n\n//GET CHORD SEQUENCE\nuint scop(uint sc,int p,int op){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);n>>=p;n+=op;n=n<0?n+12:n;return sc|uint((n&15)<<p);}\nuint scset(uint sc,int p,int b){p*=4;int n=int(sc&(15u<<p));sc^=uint(n);return sc|uint(b<<p);}\nivec4 seven=ivec4(7,1,5,6);\nvoid scaleChord(float t,float l,uint p){\n    int st=int(mod(t*bpm*4./steps,4.)),d=get2(p,15),sc=st<d?0:get2(p,14),ch=st<d?get8(p,4):get8(p,2);\n    d+=get2(p,13);sc=st<d?sc:get2(p,12);ch=st<d?ch:get8(p,0);\n    scale=scl[sc];\n    degree=get3(ch,0);degree-=degree>0?1:0;\n    int c35=get3(ch,3);\n    scale=scop(scale,(degree+2)&7,(c35&2)>0?(c35&1)*2-1:0);\n    scale=scop(scale,(degree+4)&7,(c35&4)>0?(c35&1)*2-1:0);\n    int c7=(seven[get2(uint(ch),3)]+degree)%7;\n    scale=scset(scale,(degree+6)&7,int(scl[sc]>>c7*4)&15);\n}\n\n//GET NOTE FROM PATTERN\nint notegen(int s,int s1,int s2){\n    return fract(sin(float(s+s1)+float(s1*20)*gateSeed)*50.)<(float(get4(pt,6))*.0625)?-99:\n        imod(int(abs(sin(float(s+s1+s*s2)*noteSeed)*float(s2))),get4(pt,7)+1);\n}\nvec2 getNote(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nfloat getChord(int n){\n    n+=degree+7;n-=n>16-to?7:0;\n    return float(scaleNote(n));\n}\nvec2 getNoteByChord(float t,float l){\n    int s1=get12(pt,3),s2=get12(pt,0),n=notegen(st,s1,s2);n-=n&1;float x=mod(t,l/mp);\n    if((st>=1)&&(n<-50)){n=notegen(st-1,s1,s2);x+=l/mp;n-=n&1;}\n    n+=n<-50?0:degree+7;n-=n>16-to?7:0;\n    return (n<-50)?vec2(x,-99):vec2(x,scaleNote(n));\n}\nvec2 getGate(float t,float l){\n    int n=get2(pt,st);float x=mod(t,l/mp);\n    if((st>=1)&&(n==0)){n=get2(pt,st-1);x+=l/mp;}\n    return vec2(x,n);\n}\n\n//================================================================================\n// RENDERER\n//--------------------------------------------------------------------------------\n// track(t,l,s)\n//   t...time\n//   l...measure length (steps/bpm)\n//   s...step now playing\n//\n//   getPattern(t,patternSequence)...get pattern data now playing\n//   getGate(t,l)...get noteTime and noteNum from percussive pattern\n//   getNote(t,l)...get noteTime and noteNum from melodic pattern\n//   getNoteByChord(t,l)...noteNum will restricted by chord\n//   getChord(n)...get chord noteNum 0:root 2:3rd 4:5th 6:7th\n//\n// render(t,l,inout o,e)\n//   o...audio output\n//   e...false:render is called by delay effect\n//\n//   scaleChord(t,l,chordSequence)...set scale & chord for following tracks\n//\n//--------------------------------------------------------------------------------\n//TRACK 1 snaredrum,closehh,openhh\nvec2 track1(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq1[imod(s,len1)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?sd(n.x)*vec2(.48,.62):vec2(0);\n    o+=(n.y==2.)?neshh(n.x,.08)*vec2(.15,.24):vec2(0);\n    o+=(n.y==3.)?neshh(n.x,.2)*vec2(.15,.24):vec2(0);\n    return o;\n}\n//TRACK 2 bassdrum,lowconga,highconga\nvec2 track2(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq2[imod(s,len2)]);\n    vec2 n=getGate(t,l);\n    o+=(n.y==1.)?bd(n.x)*vec2(.4,.55):vec2(0);\n    o+=(n.y==2.)?neslc(n.x)*vec2(.05,.15):vec2(0);\n    o+=(n.y==3.)?neshc(n.x)*vec2(.05,.15):vec2(0);\n    return o;\n}\n//TRACK 3 bass\nvec2 track3(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq3[imod(s,len3)]);\n    vec2 n=getNoteByChord(t,l);\n    o+=(n.y>-50.)?(fmbass(freq(n.y+11.95)*n.x,n.x)+fmbass(freq(n.y+12.05)*n.x,n.x))*vec2(.28,.31):vec2(0);\n    return o;\n}\n//TRACK 4 chord\nvec2 track4(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq4[imod(s,len4)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?fmpad(freq(n.y+36.03)*n.x,n.x)*vec2(.29,.21):vec2(0);\n    o+=(n.y>-50.)?fmpad(freq(getChord(2)+48.02)*n.x,n.x)*vec2(.30,.20):vec2(0);\n    o+=(n.y>-50.)?fmpad(freq(getChord(4)+36.01)*n.x,n.x)*vec2(.31,.19):vec2(0);\n    o+=(n.y>-50.)?fmpad(freq(getChord(6)+48.01)*n.x,n.x)*vec2(.32,.18):vec2(0);\n    return o;\n}\n//TRACK 5 accompaniment\nvec2 track5(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq5[imod(s,len5)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?fmharpsi(freq(n.y+72.)*n.x,n.x)*vec2(.08,.05):vec2(0);\n    return o;\n}\n//TRACK 6 melody\nvec2 track6(float t,float l,int s){\n    vec2 o=vec2(0);getPattern(t,seq6[imod(s,len6)]);\n    vec2 n=getNote(t,l);\n    o+=(n.y>-50.)?fmep(freq(n.y+36.03)*n.x,n.x)*.4:0.;\n    return o;\n}\nvoid render(float t,float l,inout vec2 o,bool e){\n    int s=int(t/l); //sequence number now playing\n    scaleChord(t,l,chordseq[imod(s,chordlen)]); //set scale & chord\n    o+=e?track1(t,l,s):track1(t,l,s)*.5; //TRACK 1 snaredrum,closehh,openhh\n    o+=e?track2(t,l,s):vec2(0); //TRACK 2 bassdrum,lowconga,highconga\n    o+=e?track3(t,l,s):vec2(0); //TRACK 3 bass\n    o+=  track4(t,l,s);         //TRACK 4 chord\n    o+=  track5(t,l,s);         //TRACK 5 accompaniment\n    o+=  track6(t,l,s);         //TRACK 6 melody\n}\n\n//================================================================================\n// MASTER\n//--------------------------------------------------------------------------------\n#define MASTER_DRIVE    0.35\n#define MASTER_PRESSURE 1.05\n#define DELAY_REPEAT    12\n#define DELAY_WET       0.4\n#define DELAY_FEEDBACK  0.84\n#define DELAY_TIME      0.11\n#define DELAY_STEREO    0.08\nvec2 mainSound(in int Samp,float time){\n    float l=steps/bpm,vol=1.,d=DELAY_WET,r=DELAY_TIME;\n    vec2 o=vec2(0);\n    if(time>sec-fade){vol=(sec-min(time,sec))/fade;}\n    time-=start*60./bpm;\n    if(time<0.)return o;\n    render(time,l,o,true);\n    float ff=0.,p=0.;\n    for(int i=0;i<DELAY_REPEAT;i++){\n        time-=r;\n        if(time<0.)continue;\n        vec2 a=vec2(0);\n        render(time,l,a,false);\n        d*=DELAY_FEEDBACK;\n        o+=a*d*vec2(1.+p*ff,1.-p*ff);\n        ff=ff<0.?1.:-1.;\n        p+=DELAY_STEREO;\n    }\n    return amp(o,vec3(MASTER_DRIVE,MASTER_PRESSURE,vol));\n}\n", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 123, 123, 157], [158, 158, 192, 192, 269], [270, 270, 295, 295, 453], [455, 462, 515, 515, 688]], "test": "untested"}
{"id": "3dyfDd", "name": "Isosceles Triangle - gradient 2D", "author": "iq", "description": "Signed distance and analytic gradient to an isosceles triangle. Faster than central differences or automatic differentiation/dual numbers most probably.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "segment"], "likes": 11, "viewed": 778, "published": 3, "date": "1608207542", "time_retrieved": "2024-07-30T20:29:52.403650", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance and analytic gradient to an isosceles\n// triangle. More accurate than central differences and\n// faster to compute than automatic differentiation/duals.\n\n// List of other 2D distances+gradients:\n//\n// https://iquilezles.org/articles/distgradfunctions2d\n//\n// and\n//\n// https://www.shadertoy.com/playlist/M3dSRf\n\n\n// .x = f(p)\n// .y = ∂f(p)/∂x\n// .z = ∂f(p)/∂y\n// .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    float w = sign(p.x);\n    p.x = abs(p.x);\n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float l1 = dot(a,a);\n    float l2 = dot(b,b);\n    float d = sqrt((l1<l2)?l1:l2);\n    vec2  g =      (l1<l2)? a: b;\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n    return vec3(d,vec2(w*g.x,g.y)/d)*sign(s);\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n        p.y -= 0.3;\n        // size\n        vec2 si = vec2(0.5,-0.5) + vec2(0.3,-0.3)*cos( iTime + vec2(0.0,1.57) + 0.0 );\n\n        // sdf(p) and gradient(sdf(p))\n        vec3 dg = sdgTriangleIsosceles(p,si);\n        float d = dg.x;\n        vec2 g = dg.yz;\n\n        // central differenes based gradient, for comparison\n        // g = vec2(dFdx(d),dFdy(d))/(2.0/iResolution.y);\n\n        // coloring\n         vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n        col *= 1.0 + vec3(0.5*g,0.0);\n      //col = vec3(0.5+0.5*g,1.0);\n        col *= 1.0 - 0.5*exp(-16.0*abs(d));\n        col *= 0.9 + 0.1*cos(150.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n   \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfDd.jpg", "access": "api", "license": "mit", "functions": [[1410, 1505, 1556, 1556, 1964]], "test": "untested"}
{"id": "4tBfD1", "name": "Jelly-Something-Audio", "author": "jarkob", "description": "added primitive audio reactivity to one of Kali's shaders", "tags": ["audio", "blob", "kali"], "likes": 5, "viewed": 503, "published": 3, "date": "1608204150", "time_retrieved": "2024-07-30T20:29:53.162621", "image_code": "// \"Jelly-something\" by Kali\n// \n// slightly modified from https://www.shadertoy.com/view/MlXGzr\n// basically nothing changed, except some audio reactivity\n// need this code for party projections\n\nconst int Iterations=7;  \nconst float Wavelength=.5; \nconst float Scale=1.5; \nconst float Amplitude=.1; \nconst float Speed=.3; \n\nvec3 z;\nvec4 vv;\n\nconst vec3 fore=vec3(200.,20.,30.)/255.;\nconst vec3 back=vec3(45.,52.,55.)/255.;\nconst vec3 innards=vec3(250.,0.,0.)/255.;\nconst float detail=.04;\n\nconst vec3 lightdir=-vec3(-1.0,0.5,-0.5);\n\nmat2 rot2D(float angle)\n{\n\tfloat a=radians(angle) * vv.g;\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n\n}\n\nvoid vvv() {\n    for( int i=0; i<4; i++ )\n\t{\n        vv[i] = texture(iChannel0, vec2(float(i)/6.0, .01)).r;\n\t}\n}\n\n\nfloat de (in vec3 p);\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn vv.r * normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n\nvec3 light(in vec3 p, in vec3 dir) {\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\treturn diff*fore+pow(spec,40.)*.4+fore*.2+back*.3;\t\n\t\t}\n\nfloat kaliset(vec3 p) {\n\tp.x+=.23;\n\tp.z+=.18;\n    p*=.5;\n    p.y+=iTime*1.5;\n    p.y=abs(2.-mod(p.y,4.));\n    for (int i=0;i<8;i++) p=abs(p)/dot(p,p)-.8;\n    return p.y;\n}\n\nfloat rnd(vec2 co){\n\treturn fract(sin(iTime*.1+dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n    vec3 odir=dir;\n    float totdist=0., v=0.;\n\tvec3 col=vec3(0.), p;\n\tfloat d=9999.;\n\tfor (int i=0; i<80; i++) {\n        if (d>detail && totdist<50.) {\n        \tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\ttotdist+=d*.8; \n            v++;\n\t\t\tdir=normalize(odir+pow(max(0.,totdist*totdist-9.),2.)*.0000003*vec3(rnd(dir.xy*5.21358),rnd(dir.yz*3.12568),rnd(dir.zx*2.12358)));\n        }\n\t}\n\ttotdist=min(50.,totdist);\n\t\tdir=normalize(odir+.1*vec3(rnd(dir.xy*5.21358),rnd(dir.yz*3.12568),rnd(dir.zx*2.12358)));\n    vec3 backg=back*(1.+pow(1.-dot(normalize(90.*dir),normalize(lightdir)),2.5));\n    if (d<detail) {\n\t\tfloat k=kaliset(p);\n        col=light(p-detail*dir, dir)+k*.05*(innards+.3); \n    } else {\n        col=backg+v*.015*pow(1.-dot(normalize(90.*dir),normalize(lightdir)),2.5);\n    }\n\tcol = mix(col*1.2, backg, 1.0-exp(-.0045*totdist*totdist));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vvv();\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tfloat time=iTime*.5;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv=uv*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tuv=uv.yx;\n\tvec3 from=vec3(.5,0.,-18.+cos(time*.8)*4.5);\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tmat2 camrot1=rot2D(50.);\n\tmat2 camrot2=rot2D(190.+sin(time*.5)*80.);\n\tmat2 camrot3=rot2D((sin(time))*10.);\n\tfrom.xz=from.xz*camrot1;\n\tdir.xz=dir.xz*camrot1;\n\tfrom.xy=from.xy*camrot2;\n\tdir.xy=dir.xy*camrot2;\n\tdir.yz=dir.yz*camrot3;\n\t\n\tvec3 col=raymarch(from,dir); \n\tcol=pow(col,vec3(1.3))*vec3(1.,1.2,1.2);\n\tvec4 fColor = vec4(col,1.0);// * smoothstep(0.0,0.6,vv);\n    fragColor = fColor;//.brga;\n}\n\n\nfloat de(vec3 pos)\n{\n\tfloat time=iTime;\n\tz=pos;\n\tfloat O=7.;\n\tfloat sc=1.;\n\tfloat tsc=pow(Scale,float(Iterations));\n\tfloat t=time*Speed*10./tsc+100.;\n\tfloat amp1=Amplitude;\n\tfloat amp2=amp1*1.1256;\n\tfloat amp3=amp1*1.0586;\n\tfloat amp4=amp1*0.9565;\n\tfloat l1=length(z.xy-vec2(O*1.1586,0));\n\tfloat l2=length(z.xy+vec2(O*.98586,0));\n\tfloat l3=length(z.xy+vec2(0,O*1.13685));\n\tfloat l4=length(z.xy-vec2(0,O));\n\tfor (int n=0; n<Iterations ; n++) {\n\t\tz+=sin(length(z.xy)*sc*Wavelength-t)*amp1/sc*2.;\n\t\tz+=sin(l1*sc*Wavelength-t)*amp1/sc;\n\t\tz+=sin(l2*sc*Wavelength-t)*amp2/sc;\n\t\tz+=sin(l3*sc*Wavelength-t)*amp3/sc;\n\t\tz+=sin(l4*sc*Wavelength-t)*amp4/sc;\n\t\tt=t*Scale*Scale;\n\t\tsc*=Scale;\n\t}\n\t//z.z*=3.;\n\tfloat wd=-z.z+2.;\n\treturn length(z)-6.;\n}\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 535, 560, 560, 639], [641, 641, 653, 653, 753], [779, 779, 800, 800, 961], [964, 964, 1000, 1000, 1202], [1204, 1204, 1227, 1227, 1375], [1377, 1377, 1396, 1396, 1474], [1477, 1477, 1520, 1520, 2375], [2377, 2377, 2434, 2434, 3090], [3093, 3093, 3113, 3113, 3828]], "test": "untested"}
{"id": "WsGBDd", "name": "old hash: testing parameters 2", "author": "FabriceNeyret2", "description": "Mouse tune the big multipliers in fract ( or autodemo ). bottom-left for back to autodemo.", "tags": ["hash"], "likes": 4, "viewed": 235, "published": 3, "date": "1608202226", "time_retrieved": "2024-07-30T20:29:53.948519", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         M = iMouse.xy;\n    if ( length(M)<20. ) M = floor( R/2. + R/2.01 *cos( floor(iTime*4.) ) );\n                            // floor is crucial \n    \n    O = vec4( fract(sin(dot( U, vec2(12.9898, 78.233) )) * (M.x/R.x)*1e5 ) ); // 43758.5453)\n    if ( length(M-U) < 10. ) O = vec4(1,0,0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 365]], "test": "untested"}
{"id": "WdGBDd", "name": "old hash: testing parameters", "author": "FabriceNeyret2", "description": "Mouse tune U multipliers ( or autodemo ). bottom-left for back to autodemo.\n", "tags": ["hash"], "likes": 2, "viewed": 235, "published": 3, "date": "1608201954", "time_retrieved": "2024-07-30T20:29:54.782290", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         M = iMouse.xy;\n    if ( length(M)<20. ) M = floor( R/2. + R/3.*cos( floor(iTime*4.)*vec2(1,1.7) + vec2(0,33) ) );\n                              // floor is crucial \n    \n    O = vec4( fract(sin(dot( U, M )) * 1e5 ) ) ; // 43758.5453 ) );\n    if ( length(M-U) < 10. ) O = vec4(1,0,0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 364]], "test": "untested"}
{"id": "WsGfWd", "name": "Decalled Floppy Tube 2", "author": "dr2", "description": "Surface coordinates; updated to allow variable bend axis direction (using two planar rotations).", "tags": ["torus", "coordinates", "decal"], "likes": 16, "viewed": 443, "published": 3, "date": "1608197956", "time_retrieved": "2024-07-30T20:29:55.563202", "image_code": "// \"Decalled Floppy Tube 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Surface coordinates; updated to allow variable bend axis direction (using \n// two planar rotations).\n\n/*\n  Tube now has squarer shape (original circular tube is an option).\n\n  From the original: \"Provides coordinates useful for flexible shapes based on\n  generalized toroidal sections (e.g. fish bodies, snakes, wings); preferable\n  to sheared coordinates or multiple linear segments.\"\n\n  Examples include:\n    \"Decalled Floppy Tube\"      https://www.shadertoy.com/view/3l3GD7\n    \"Planet Reboot 2\"           https://www.shadertoy.com/view/Wtc3Rf\n    \"Multisegment Floppy Tube\"  https://www.shadertoy.com/view/tlcGRB\n    \"Snake Worship\"             https://www.shadertoy.com/view/wtyGRD\n*/\n\n// #define IS_CIRC\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r);\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar, dLoop, sLoop, rCyl, tubRot;\nint idObj;\nbool isCirc;\nconst int idTube = 1, idBase = 2, idGrnd = 3;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b, c;\n  float dMin, d, hBase, aLoop, lb, s, rc;\n  dMin = dstFar;\n  hBase = 1.6;\n  aLoop = 0.25 * pi / sLoop;\n  rc = 0.5;\n  q = p;\n  q.y -= 2. * hBase;\n  q.xz = Rot2D (q.xz, tubRot);\n  q.xy = Rot2D (q.xy, 0.5 * pi);\n  if (isCirc) d = PrSphDf (q, rCyl);\n  else d = max (PrRound4BoxDf (vec3 (q.x, Rot2D (q.yz, - tubRot)), vec3 (rCyl - rc), rc),\n     -0.01 - q.x);\n  q.xy = Rot2D (vec2 (q.x, q.y - dLoop), aLoop - 0.5 * pi);\n  b = vec2 (length (q.xy) - dLoop, q.z);\n  b.xy = Rot2D (b.xy, tubRot);\n  lb = length (b);\n  if (isCirc) s = lb - rCyl;\n  else s = PrRound4Box2Df (b, vec2 (rCyl - rc), rc);\n  d = min (d, max (s, dot (vec2 (q.x, abs (q.y)), sin (aLoop + vec2 (0., 0.5 * pi)))));\n  c = Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.);\n  if (isCirc) s = PrSphDf (vec3 (Rot2D (q.xy, aLoop) + vec2 (dLoop, 0.), q.z), rCyl);\n  else s = max (PrRound4BoxDf (vec3 (Rot2D (vec2 (c.x, q.z), - tubRot), c.y).xzy,\n     vec3 (rCyl - rc), rc), -0.01 - c.y);\n  d = min (d, s);\n  qHit = vec3 (vec2 (atan (q.y, - q.x) * dLoop / (0.25 * pi), atan (b.x, b.y)) / pi, lb);\n  DMIN (idTube);\n  q = p;\n  q.y -= hBase - 0.5 * rCyl;\n  d = PrRound4BoxDf (q, vec3 (0.8 * rCyl, hBase - 0.5 * rCyl, 0.8 * rCyl) - 0.05, 0.05);\n  DMIN (idBase);\n  d = p.y;\n  DMIN (idGrnd);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn;\n  vec2 p, ip;\n  float nDotL, sh, c;\n  vn = ObjNf (ro);\n  nDotL = max (dot (vn, ltDir), 0.);\n  if (idObj == idTube) {\n    if (qHit.z < (isCirc ? 0.7 : 0.2) * rCyl) {\n      col4 = vec4 (1., 1., 0., 0.2) * (0.2 + 0.8 * smoothstep (0.1, 0.2, qHit.z / rCyl));\n    } else {\n      p = qHit.xy * vec2 (2. * sqrt3, 3.);\n      ip = PixToHex (p);\n      c = mod (dot (mod (2. * ip + ip.yx, 3.), vec2 (1., 2.)), 3.);\n      if (isCirc) {\n        col4 = vec4 (1., 0., 0., 0.2);\n        if (c == 1.) col4.rgb = col4.gbr;\n        else if (c == 2.) col4.rgb = col4.brg;\n        col4 = mix (vec4 (1., 1., 0., 0.2), col4, smoothstep (0.05, 0.1,\n           HexEdgeDist (p - HexToPix (ip))));\n      } else {\n        col4 = (c == 0.) ? vec4 (0.7, 0.6, 0., 0.2) : ((c == 1.) ? vec4 (0.8, 0.8, 0.4, 0.2) :\n           vec4 (0.4, 0.2, 0., 0.2));\n        col4 *= 0.3 + 0.7 * smoothstep (0.05, 0.07, HexEdgeDist (p - HexToPix (ip)));\n      }\n    }\n    nDotL *= nDotL;\n  } else if (idObj == idBase) {\n    col4 = vec4 (0.8, 0.8, 0.7, 0.1);\n  } else if (idObj == idGrnd) {\n    col4 = vec4 (0.4, 0.45, 0.4, 0.);\n  }\n  sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n  col4.rgb = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n     col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  return col4.rgb;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float dstObj, tCyc, t;\n#ifdef IS_CIRC\n  isCirc = true;\n#else\n  isCirc = false;\n#endif\n  tCyc = 10.;\n  t = tCur / tCyc;\n  tubRot = - mod (15. * t, 2. * pi);\n  sLoop = 1./3. + 50. * pow (1. - SmoothBump (0.25, 0.75, 0.24, mod (t, 1.)), 8.);\n  dLoop = 6. * sLoop;\n  rCyl = 0.8;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col = ObjCol (ro, rd);\n   } else {\n    col = vec3 (0.5, 0.5, 0.6);\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  } else {\n    az -= 0.5 * tCur;\n  }\n  el = clamp (el, -0.3 * pi, 0.);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 6., -25.);\n  zmFac = 3.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  dstFar = 70.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat Length4 (vec2 p)\n{\n  p *= p;\n  return pow (dot (p * p, vec2 (1.)), 1./4.);\n}\n\nfloat Length4 (vec3 p)\n{\n  p *= p;\n  return pow (dot (p * p, vec3 (1.)), 1./4.);\n}\n\nfloat PrRound4BoxDf (vec3 p, vec3 b, float r)\n{\n  return Length4 (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRound4Box2Df (vec2 p, vec2 b, float r)\n{\n  return Length4 (max (abs (p) - b, 0.)) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1369, 1369, 1391, 1391, 2666], [2668, 2668, 2701, 2701, 2906], [2908, 2908, 2929, 2929, 3184], [3186, 3186, 3223, 3223, 3452], [3454, 3454, 3478, 3478, 3708], [3710, 3710, 3734, 3734, 3794], [3796, 3796, 3824, 3824, 3904], [3906, 3906, 3938, 3938, 5250], [5252, 5252, 5287, 5287, 5777], [5794, 5794, 5847, 5847, 6911], [6913, 6913, 6946, 6946, 6973], [6975, 6975, 6999, 6999, 7057], [7059, 7059, 7083, 7083, 7141], [7143, 7143, 7190, 7190, 7238], [7240, 7240, 7288, 7288, 7336], [7338, 7338, 7374, 7374, 7580], [7582, 7582, 7612, 7612, 7725], [7727, 7727, 7784, 7784, 7867]], "test": "untested"}
{"id": "WsyBWd", "name": "Devil's staircase / Cantor func", "author": "FabriceNeyret2", "description": "This function is continuous and derivative = 0 almost every where.\n[url]https://en.wikipedia.org/wiki/Cantor_function[/url]", "tags": ["function", "short"], "likes": 6, "viewed": 279, "published": 3, "date": "1608196633", "time_retrieved": "2024-07-30T20:29:56.403954", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; \n    float y = 0., s = .25;\n    \n    for( int p = int(U), q = int(R) ; q > 0 ; q/=3, s/=2. )   \n        if ( p > q/3 ) y += s, p -= 2*q/3 ;\n      \n    O = vec4( y < .5*U.y/R.y );  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyBWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 250]], "test": "untested"}
{"id": "wdKfDc", "name": "HSL Colourise", "author": "antikrem", "description": "Implementation of HSL colourise, based off GIMP's colourise\nPreserves luminance while colourising.\nI also did a bit of a write up to those interested: https://antikrem.github.io/Colourise/", "tags": ["hsl", "colourise"], "likes": 0, "viewed": 288, "published": 3, "date": "1608176064", "time_retrieved": "2024-07-30T20:29:57.198829", "image_code": " vec3 hsl2rgb(vec3 color) {\n    vec3 rgb = clamp( \n\t\t\tabs(mod(color.x * 6.0+vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n\t\t\t0.0, \n\t\t\t1.0\n\t\t);\n    return color.z + color.y * (rgb - 0.5) * (1.0 - abs(2.0 * color.z - 1.0));\n}\n\n\nvec3 colourise(vec3 hsl, vec3 texel) {\n\tfloat lum = dot(texel, vec3(0.2126, 0.7152, 0.0722));\n    \n    hsl.b = 2.0 * hsl.b - 1.0;\n    \n    if (hsl.b > 0.0) {\n    \tlum = lum * (1.0 - hsl.b);\n        lum += 1.0 - (1.0 - hsl.b);\n    }\n    else if (hsl.b < 0.0) {\n        lum = lum * (hsl.b + 1.0);\n    }\n    \n    return hsl2rgb(vec3(hsl.rg, lum));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 base = texture( iChannel0, uv ).xyz;\n    \n    // Hue with a period of 1 unit\n    float hue = 0.0;\n    \n    // Range is [0, 1] (0 is greyscale, 1 is completely saturated)\n    float sat = 0.75;\n    \n    // Range is [0, 1] (0 is black, 1 is complete white)\n    float lightness = 0.55;\n    \n    vec3 hslColouriser = vec3(hue, sat, lightness);\n    \n    vec3 colour = colourise(hslColouriser, base);\n\n    fragColor = vec4(uv.x < 0.5 ? colour : base, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 27, 218], [221, 221, 259, 259, 567], [570, 570, 627, 627, 1128]], "test": "untested"}
{"id": "wdKfWc", "name": "Fourier's Caustic", "author": "wyatt", "description": "Shockingly easy and wayyy faster than doing it some other way. Thank you to Robert (trirop) and Rory for teaching me the ways of the fourier transform and applying it to light propagation. \n\n(Runs much better on lower resolution)", "tags": ["fourier", "caustic"], "likes": 22, "viewed": 661, "published": 3, "date": "1608169858", "time_retrieved": "2024-07-30T20:29:58.116376", "image_code": "Main {\n    if (iFrame%N<N-1) discard;\n    vec4 m = 0.25*(\n        A(U+o.xy)+\n        A(U+o.yx)+\n        A(U+o.zy)+\n        A(U+o.yz)\n    );\n    Q = m*vec4(1,1.1,1.5,1);;\n    Q -= .2*D(U).wwww;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0, ivec2(mod(U,R)),0)\n#define B(U) texelFetch(iChannel1, ivec2(U),0)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, in vec2 U)\n#define pi 3.14159265359\n#define o vec3(1,0,-1)\n#define cos(a) cos(mod(a,2.*pi))\n#define sin(a) sin(mod(a,2.*pi))\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define mul(a,b) vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.y)\n#define N 3\n#define time sin(2.*pi*float(iFrame)/float(N))\n#define WAVELENGTH (300.)\n#define DEPTH (pi-time)\n#define HEIGHT 1000.", "buffer_a_code": "vec4 T(vec2 U) {\n\tU -= .25*C(U).zw;\n\tU -= .25*C(U).zw;\n    return D(U);\n}\nMain {\n    Q.xy = vec2(0);\n    vec2 k = 2.*pi*(U-0.5*R)/R;\n\tfor (float i = 0.; i < R.x; i++) {\n        vec2 u = vec2(i,U.y);\n        vec2 v = vec2(1,0)*ei(iTime*DEPTH*B(u).z);\n        Q.xy += v*ei(-k.x*i)/sqrt(R.x);\n    }\n    Q.zw  = T(U).zw;\n    vec4 \n        n = B(U+o.yx),\n        e = B(U+o.xy),\n        s = B(U+o.yz),\n        w = B(U+o.zy);\n    Q.zw -= 0.25*vec2(e.z-w.z,n.z-s.z);\n    \n    if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.)\n        Q.zw *= 0.;\n\tif (iFrame < 1) {\n        Q = vec4(0);\n    }\n    vec2 mo = 0.5*R;\n    if (iMouse.z>0.) mo = iMouse.xy;\n    Q.zw = mix(Q.zw,\n        .8*vec2(cos(.2*iTime),0)*ei(.05*iTime),\n            exp(-.05*dot(U-mo,U-mo)));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 T(vec2 U) {\n\tU -= .25*C(U).zw;\n\tU -= .25*C(U).zw;\n    return D(U);\n}\nMain {\n    Q = vec4(0);\n\tvec2 k = 2.*pi*(U-0.5*R)/R;\n\tfor (float i = 0.; i < R.y; i++) \n        Q.xy += A(vec2(U.x,i)).xy*ei(-k.y*i)/sqrt(R.y);\n    vec2 q = Q.xy;\n    Q = vec4(0);\n    float l = WAVELENGTH*WAVELENGTH-dot(k,k);\n    if (l>0.)\n        Q.xy += q * ei(sqrt(l)*HEIGHT);\n    else Q.xy += q * exp(-sqrt(abs(l*HEIGHT)));\n    Q.zw  = T(U).zw;\n    vec4 \n        n = B(U+o.yx),\n        e = B(U+o.xy),\n        s = B(U+o.yz),\n        w = B(U+o.zy);\n    Q.z = Q.z - 0.25*(e.z-w.z+n.w-s.w);\n    vec2 mo = 0.5*R;\n    if (iMouse.z>0.) mo = iMouse.xy;\n    Q.w = mix(Q.w,1.,\n            exp(-.05*dot(U-mo,U-mo)));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.x; i++) \n        Q.xy += A(vec2(i,U.y)).xy*ei(w.x*i)/sqrt(R.x);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = vec4(0);\n    vec2 w = 2.*pi*(U-0.5)/R;\n    for (float i = 0.; i < R.y; i++) \n        Q.xy += A(vec2(U.x,i)).xy*ei(w.y*i)/sqrt(R.y);\n    Q *= mod(U.x+U.y,2.)*2.-1.;\n    vec4 col = exp(-abs(time-vec4(-1.,0,1.,1)))*length(Q);\n    Q = B(U);\n    if (iFrame%N==0) Q = vec4(0);\n    Q += max(col,0.)/float(N);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tsVBWc", "name": "Okay-ish looking 3D sine fbm", "author": "yonatan", "description": "Based on iq's Analytic Normals 3D - https://www.shadertoy.com/view/XttSz2", "tags": ["fbm", "normals", "sine", "analytic"], "likes": 8, "viewed": 581, "published": 3, "date": "1608165772", "time_retrieved": "2024-07-30T20:29:58.947154", "image_code": "/*\n   An attempt to get nice results from a sine fbm.\n\n   Most of this is from iq's Analytic Normals shader -\n   https://www.shadertoy.com/view/XttSz2\n   \n   I've replaced the noised() function with something simpler\n   (a sine wave) and beefed up the fbm with some rotations,\n   smaller freq/amp steps and a few more iterations to\n   compensate. Also added a .6 damper to the marching.\n   \n   The main gotcha for me was having to rotate the derivatives\n   before adding them up. I'm still not sure how or why it works\n   (if anyone wants to clue me in...), but visually the\n   numerical and analytic versions look the same, you can\n   uncomment the #define SHOW_NUMERICAL_NORMALS line to compare.\n*/\n\n\n// The MIT License\n// Copyright © 2016 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Computing normals analytically has the benefit of being faster if you need them often, \n// while numerical normals are easier to filter for antialiasing. See line 200.\n//\n// More info: https://iquilezles.org/articles/morenoise\n//\n// See this too: https://www.shadertoy.com/view/XsXfRH\n//\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\n//\n\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n\n//---------------------------------------------------------------\n// value noise, and its analytical derivatives\n//---------------------------------------------------------------\n/*\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n/*/\n\nvec4 noised( in  vec3 x ) {\n    vec4 ret;\n    ret.yzw = cos(x);\n    x=sin(x);\n    ret.x = (x.x+x.y+x.z)/3.;\n    return ret;\n}\n//*/\n\n//---------------------------------------------------------------\n\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\n{\n    vec3 d = abs(p) - b;\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\n    return vec4( x, n );\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n    \n}\n\nvec4 fbmd( in vec3 x )\n{\n    const float scale  = 1.5;\n\n    float a = .5;\n    float b = .5;\n\tfloat f = 2.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<14; i++ )\n    {\n        vec3 r = f*x*scale;\n        // i don't know how to get good sine fbms without rotations\n        r.xy *= rot(float(f*f));\n        r.yz *= rot(float(f*f*f));\n        vec4 n = noised(r);\n        // this undoes(?!) the rotation for the derivatives\n        n.zw = rot(float(f*f*f)) * n.zw;\n        n.yz = rot(float(f*f)) * n.yz;\n        \n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= .66;             // amplitude decrease\n        f *= 1.4;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}\n\nvec4 map( in vec3 p )\n{\n\tvec4 d1 = fbmd( p );\n    d1.x -= 0.37;\n\td1.x *= 0.7;\n    d1.yzw = normalize(d1.yzw);\n\n    // clip to box\n    vec4 d2 = sdBox( p, vec3(1.5) );\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\n// ray-box intersection in box space\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\treturn vec2( tN, tF );\n}\n\n// raymarch\nvec4 interesect( in vec3 ro, in vec3 rd )\n{\n\tvec4 res = vec4(-1.0);\n\n    // bounding volume    \n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\n    if( dis.y<0.0 ) return res;\n\n    // raymarch\n    float tmax = dis.y;\n    float t = dis.x;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec4 hnor = map( pos );\n        res = vec4(t,hnor.yzw);\n        \n\t\tif( hnor.x<0.001 ) break;\n\t\tt += hnor.x * .6;\n        if( t>tmax ) break;\n\t}\n\n\tif( t>tmax ) res = vec4(-1.0);\n\treturn res;\n}\n\n// compute normal numerically\n#ifdef SHOW_NUMERICAL_NORMALS\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n#endif\n\n// fibonazzi points in s aphsre, more info:\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\n    }\n\tao /= 32.0;\n\t\n    return clamp( ao*5.0, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n   \n\t// camera anim\n    float an = 0.1*iTime;\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\n\tvec3 ta = vec3( 0.0 );\n\t\n    // camera matrix\t\n\tvec3  cw = normalize( ta-ro );\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n\n\t// render\n\tvec3 col = vec3(0.0);\n    vec4 tnor = interesect( ro, rd );\n\tfloat t = tnor.x;\n\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n        #ifndef SHOW_NUMERICAL_NORMALS\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\n        #else\n        vec3 nor = calcNormal( pos );\n        #endif\n        float occ = calcAO( pos, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\n        //col = 0.5+0.5*nor;\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\n\t}\n\n    col = sqrt(col);\n\t\n    fragColor=vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVBWc.jpg", "access": "api", "license": "mit", "functions": [[2213, 2213, 2236, 2236, 2272], [3324, 3324, 3351, 3351, 3449], [3523, 3523, 3576, 3576, 3754], [3756, 3756, 3775, 3775, 3856], [3858, 3858, 3882, 3882, 4611], [4613, 4613, 4636, 4636, 4815], [4817, 4854, 4905, 4905, 5173], [5175, 5187, 5230, 5230, 5674], [6015, 6141, 6177, 6177, 6441], [6443, 6443, 6485, 6485, 6786], [6788, 6788, 6845, 6845, 7960]], "test": "untested"}
{"id": "WsyBWc", "name": "Glowing Morphing Shape", "author": "oneshade", "description": "Fun experimentation. The inner glow effect was especially interesting.", "tags": ["glow", "morph", "innerglow"], "likes": 8, "viewed": 162, "published": 3, "date": "1608165039", "time_retrieved": "2024-07-30T20:29:59.887640", "image_code": "#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\nfloat shape(in vec3 p) {\n    return max(mod(length(p) - 2.0, 1.0) - 0.5, length(p) - (0.6 + 0.4 * sin(iTime)) * 5.0) - 0.01;\n}\n\nfloat scene(in vec3 p) {\n    vec3 res = vec3(1.0, 1.0, 1.0);\n\n    vec3 cell = floor(p / res) * res;\n    vec3 local = fract(p / res);\n\n    float ldb = shape(cell);                           // Left, Down, Back\n    float rdb = shape(cell + vec3(res.x, 0.0, 0.0));   // Right, Down, Back\n    float ldf = shape(cell + vec3(0.0, 0.0, res.z));   // Left, Down, Front\n    float rdf = shape(cell + vec3(res.x, 0.0, res.z)); // Right, Down, Front\n    float lub = shape(cell + vec3(0.0, res.y, 0.0));   // Left, Up, Back\n    float rub = shape(cell + vec3(res.xy, 0.0));       // Right, Up, Back\n    float luf = shape(cell + vec3(0.0, res.yz));       // Left, Up, Front\n    float ruf = shape(cell + res);                     // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(scene(p + vec3(0.001, 0.0, 0.0)) - scene(p - vec3(0.001, 0.0, 0.0)),\n                          scene(p + vec3(0.0, 0.001, 0.0)) - scene(p - vec3(0.0, 0.001, 0.0)),\n                          scene(p + vec3(0.0, 0.0, 0.001)) - scene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float dt = 0.0;\n\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n        vec3 u = p;\n\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = scene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            n.yz *= mat2(COS_15, -SIN_15, SIN_15, COS_15);\n            n.xz *= mat2(c, -s, s, c);\n\n            fragColor.rgb += 0.65 - 0.5 * dot(n, normalize(u));\n            //fragColor.rgb += max(0.0, pow(dot(n, normalize(u)), 1.0)); // Hacky ambient occlusion (only works for certain shapes)\n            break;\n        }\n\n        if (d > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 82, 82, 184], [186, 186, 210, 210, 1179], [1181, 1181, 1208, 1208, 1497], [1499, 1499, 1554, 1554, 2486]], "test": "untested"}
{"id": "tdKBWc", "name": "Dots spin loader", "author": "NoxWings", "description": "Just a simple spin loader made using radial symmetry.", "tags": ["radialsymmetrydots"], "likes": 1, "viewed": 347, "published": 3, "date": "1608158117", "time_retrieved": "2024-07-30T20:30:00.764296", "image_code": "#define S(x,y,z) smoothstep(x,y,z)\n#define debug(x) fragColor = vec4(vec3(x), 1.0); return\n#define debug2(x) fragColor = vec4(vec2(x), 0.0, 1.0); return\n#define debug3(x) fragColor = vec4(x, 1.0); return\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.0;\nconst float AA = 0.005;\n\nfloat circle(vec2 uv, float r) {\n    float d = length(uv);\n    return S(r+AA, r-AA, d);\n}\n\nmat2 rot2D(float a) {\n    float sa = sin(a), ca = cos(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coords = uv * 2.0 - 1.0;\n    coords.x *= iResolution.x / iResolution.y;\n    coords = rot2D(-iTime* 2.) * coords;\n    \n    float numberOfDots = 8.0; \n    float angle = (atan(coords.y, coords.x) + PI) / TAU * numberOfDots;\n    float rid = floor(angle);\n    float baseAngle = rid / numberOfDots * TAU - PI;\n    vec2 ruv = rot2D(baseAngle) * coords;\n    \n    //debug(rid / numberOfDots); // Debug radial ids\n    //debug2(ruv);               // Debug radial uvs\n    \n    float sizeId = (numberOfDots - rid - 1.);\n    float circleBaseRadius = 0.03;\n    float circleDynRadius = sizeId * 0.01;\n    float circleRadius = circleBaseRadius + circleDynRadius;\n    float circleDistance = 0.4 - circleDynRadius;\n    \n    vec3 col = vec3(circle(ruv - vec2(circleDistance, circleRadius), circleRadius));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 316, 316, 373], [375, 375, 396, 396, 468], [470, 470, 527, 527, 1398]], "test": "untested"}
{"id": "tdVBD3", "name": "Bean Machine", "author": "oneshade", "description": "Trying to simulate a [url=https://en.wikipedia.org/wiki/Bean_machine]Galton board[/url] (bean machine). Big thank you to kastorp for fixing the collision problem! :) Click to see the normal distribution.", "tags": ["simulation", "physics", "statistics", "beanmachine", "galtonboard"], "likes": 49, "viewed": 659, "published": 3, "date": "1608152060", "time_retrieved": "2024-07-30T20:30:02.022931", "image_code": "float mapEnvironment(in vec2 p, in int ballID) {\n    float distToEnv = mapEnvironmentNoBalls(p);\n    for (int id=0; id < NUMBER_OF_BALLS; id++) {\n        if (id != ballID) {\n            vec2 ballPos = getBallPos(id);\n            distToEnv = min(distToEnv, length(p - ballPos) - BALL_RADIUS);\n        }\n    }\n\n    return distToEnv;\n}\n\nfloat normalDistribution(in float x, in float sigma, in float mu) {\n    const float SQRT_TWO_PI = 2.50662827463;\n    float q = (x - mu) / sigma;\n    return exp(-0.5 * q * q) / (sigma * SQRT_TWO_PI);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float env = mapEnvironmentNoBalls(uv);\n    fragColor.rgb += vec3(0.6, 0.3, 0.0) * smoothstep(unit, 0.0, env);\n\n    if (env > 0.0) {\n        for (int id=0; id < NUMBER_OF_BALLS; id++) {\n            vec2 ballPos = getBallPos(id);\n            float ball = length(uv - ballPos) - BALL_RADIUS;\n            fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.8, 0.6), smoothstep(unit, 0.0, ball));\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(ball) + 0.2 * unit));\n        }\n    }\n\n    if (iMouse.z > 0.0) {\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, abs(uv.y + 0.4 - 0.75 * normalDistribution(3.0 * uv.x, 1.0, 0.0))));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NUMBER_OF_BALLS 100\n#define BALL_RADIUS 0.02\n\n#define GRAVITY 0.0001\n#define FRICTION 0.9\n\n#define getBallPos(id) texelFetch(iChannel0, ivec2(id, 0), 0).xy\n#define getBallVel(id) texelFetch(iChannel0, ivec2(id, 1), 0).xy\n\nfloat mapEnvironmentNoBalls(in vec2 p) {\n    float container = min(p.y + 0.4, 0.8 - abs(p.x));\n\n    vec2 q1 = mod(p, vec2(0.1, 0.2)) - vec2(0.05, 0.1);\n    vec2 q2 = mod(p + vec2(0.05, 0.1), vec2(0.1, 0.2)) - vec2(0.05, 0.1);\n    vec2 q3 = abs(p - vec2(0.0, 0.1)) - vec2(0.51, 0.11);\n\n    float bbox = length(max(q3, 0.0)) + min(max(q3.x, q3.y), 0.0);\n    float pegs = max(min(length(q1) - 0.01, length(q2) - 0.01), bbox);\n\n    vec2 q4 = abs(vec2(mod(p.x, 0.1) - 0.05, p.y + 0.25)) - vec2(0.005, 0.15);\n    bbox = abs(p.x) - 0.675;\n    float bins = max(length(max(q4, 0.0)) + min(max(q4.x, q4.y), 0.0), bbox);\n\n    p.x = abs(p.x);\n    p.x -= 0.92;\n    p.y -= 0.8;\n    p *= mat2(0.5, -0.866, 0.866, 0.5);\n    vec2 q5 = abs(p) - vec2(0.01, 1.0);\n    float funnel = length(max(q5, 0.0)) + min(max(q5.x, q5.y), 0.0);\n\n    return min(container, min(pegs, min(bins, funnel)));\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nvec2 generatePosition(in float id) {\n\tid += iDate.w; // Thanks Jinkweiq :)\n    vec3 p3 = fract(vec3(id) * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    vec2 p = fract((p3.xx + p3.yz) * p3.zy);\n    return vec2(-0.3, 5.0) + p * vec2(0.6, -4.5);\n}", "buffer_a_code": "vec4 mapEnvironment(in vec2 p, in int ballID) {\n    vec2 ballPos = getBallPos(ballID);\n\n    float distToEnv = mapEnvironmentNoBalls(p);\n    vec2 colliderVel = vec2(0.0, 0.0);\n    float colliderType = 0.0;\n\n    for (int id=0; id < NUMBER_OF_BALLS; id++) {\n        if (id != ballID) {\n            vec2 colliderPos = getBallPos(id);\n            distToEnv = min(distToEnv, length(p - colliderPos) - BALL_RADIUS);\n\n            if (length(ballPos - colliderPos) < 2.0 * BALL_RADIUS) {\n                colliderVel = getBallVel(id);\n                colliderType = 1.0;\n            }\n        }\n    }\n\n    return vec4(distToEnv, colliderVel, colliderType);\n}\n\nvec2 getNormal(in vec2 p, in int id) {\n    return normalize(vec2(mapEnvironment(p + vec2(0.001, 0.0), id).x - mapEnvironment(p - vec2(0.001, 0.0), id).x,\n                          mapEnvironment(p + vec2(0.0, 0.001), id).x - mapEnvironment(p - vec2(0.0, 0.001), id).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 address = ivec2(fragCoord);\n    if (address.x < NUMBER_OF_BALLS && address.y == 0) {\n        fragColor = vec4(generatePosition(fragCoord.x), 0.0, 1.0);\n    }\n\n    if (address.x < NUMBER_OF_BALLS && address.y == 1) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    if (iFrame > 0) {\n        if (address.x < NUMBER_OF_BALLS) {\n            vec2 ballPos = getBallPos(address.x);\n            vec2 ballVel = getBallVel(address.x);\n\n            ballVel.y -= GRAVITY;\n            ballPos += ballVel;\n\n            vec4 envData = mapEnvironment(ballPos, address.x);\n            if (envData.x < BALL_RADIUS) {\n                vec2 hitNormal = getNormal(ballPos, address.x);\n                ballPos += hitNormal * (BALL_RADIUS - envData.x); // Thanks kastorp :)\n\n                if (envData.w > 0.0) {\n                    vec2 perpNormal = hitNormal.yx * vec2(-1.0, 1.0);\n                    vec2 ballVel2 = envData.yz;\n                    ballVel = dot(ballVel2, hitNormal) * hitNormal + dot(ballVel, perpNormal) * perpNormal;\n                }\n\n                else {\n                    ballVel = reflect(ballVel, hitNormal);\n                }\n\n                ballVel *= FRICTION;\n            }\n\n            if (address.y == 0) {\n                fragColor = vec4(ballPos, 0.0, 1.0);\n            }\n\n            if (address.y == 1) {\n                fragColor = vec4(ballVel, 0.0, 1.0);\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 332], [334, 334, 401, 401, 534], [536, 536, 591, 591, 1451]], "test": "untested"}
{"id": "WdVfRc", "name": "M-O (from Wall-E)", "author": "dean_the_coder", "description": "Anyone remember 'M-O' from Pixar's 'Wall-E' movie?  Here's my tribute to that little chap.", "tags": ["3d", "raymarching", "pixar", "movie", "cineshader", "walle"], "likes": 143, "viewed": 31350, "published": 3, "date": "1608151199", "time_retrieved": "2024-07-30T20:30:02.907565", "image_code": "// 'M-O'\n// by dean_the_coder (Twitter: @deanthecoder)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Anyone remember 'M-O' from Pixar's 'Wall-E' movie?\n// Here's my tribute to that little chap.\n//\n// Technically I wanted to practice writing a shader that\n// performs well enough that I can enable anti-aliasing by\n// default, has quite a small codebase (my shaders usually\n// tend to be a bit on the large side), and doesn't require\n// any external textures.\n//\n// With more GPU power I would have liked to make the red\n// light spin around within refracted glass. I might\n// come back to that if I ever get a more powerful laptop.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat arms, time,\n      g = 0.;\n\n#define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; // SDF distance.\n\tint id; // Material ID.\n\tvec2 t; // uv texture coords.\n};\n\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 h,\n\t     ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\th = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) { if (b.d < a.d) a = b; }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdTaper(vec2 p, vec3 r) {\n\tp.x = abs(p.x);\n\tp.y = -p.y;\n\tfloat b = (r.x - r.y) / r.z,\n\t      a = sqrt(1. - b * b),\n\t      k = dot(p, vec2(-b, a));\n\tif (k > a * r.z) return length(p - vec2(0, r.z)) - r.y;\n\treturn (k < 0. ? length(p) : dot(p, vec2(a, b))) - r.x;\n}\n\nfloat sdArm(vec3 p, float c) {\n\treturn max(max(sdTaper(p.yz, vec3(.5, .2, 2)), abs(abs(p.x) - 1.55)) - .1,  // Main arm.\n\t(p.z + 1.5 + sin(p.y * 7.) * .1) * c);\n}\n\n// The sine wave applied to the dirt track.\nfloat trk(float z) { return sin(z * .2 - time); }\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\t// Floor.\n\tHit h = Hit(length(p.y), 1, p.xz);\n\n\t// Walls.\n\tminH(h, Hit(min(dot(p, vec3(-.707, .707, 0)) + 9., dot(p, vec3(-1, 0, 0)) + 20.), 0, p.yz));\n\n\t// Wall lights.\n\tfloat f, b,\n\t      d = sdBox(vec3(p.xy, mod(p.z - time * 8., 40.)) - vec3(20, 7.25, 20), vec3(.1, .1, 8));\n\tg += .01 / (.01 + d * d);\n\tminH(h, Hit(d - .7, 4, p.xy));\n\tp.x += trk(-.9);\n\tp.xz *= rot(trk(7.) * .2);\n\n\t// Ball.\n\tminH(h, Hit(length(p - vec3(0, 1, 0)) - 1., 2, p.xy));\n\tp.yz *= rot(-arms);\n\tp.y -= 1.7;\n\tminH(h, Hit(sdBox(p, vec3(1.2, .9, .8 + cos((p.y + 5.1) * 1.33) * .5)) - .2, 3, p.xy)); // Lower body.\n\tvec3 op = p;\n\n\t// Arms/Hands.\n\tp.y -= .5;\n\tp.yz *= rot(-arms);\n\td = sdArm(p, -1.);\n\tp.z += arms + cos(time * 15.) * .1;\n\tminH(h, Hit(min(d, sdArm(p, 1.)), 0, op.xy));\n\n\t// Brush.\n\tb = .2 + .8 * abs(sin(p.x * 18.)) * .1;\n\tminH(h, Hit(sdCyl(p + vec3(0, 0, 2), vec2(.1 + b, 1.4)), 2, p.xy));\n\n\t// Arm extenders.\n\tp.x = abs(p.x) - 1.55;\n\tp.z++;\n\tminH(h, Hit(sdBox(p, vec3(.08, .22, .6)), 2, p.xz));\n\n\t// Head.\n\tp = op;\n\tp.yz *= rot(arms * -.7);\n\tp.xz *= rot(trk(0.) * .1);\n\tp.y -= 2.;\n\tp.z += .5;\n\tf = cos(p.y + .8);\n\tminH(h, Hit(max(sdBox(p, vec3(mix(1.2, 1.4, f), .8, mix(.9, 1.2, f))),  // Head.\n\t2.5 - length(p.yz + vec2(2.5, -.8)) // Rear cut-out.\n\t) - .2, 6, p.xy));\n\n\t// Light - Top.\n\tp.y -= mix(.96, 2.5, arms);\n\tminH(h, Hit(sdBox(p, vec3(.5, .04, .5)), 3, p.xy));\n\tminH(h, Hit(sdBox(p + vec3(0, .3, 0), vec3(.45, .3, .45)), 5, p.xy));\n\treturn h;\n}\n\nvec3 calcN(vec3 p) {\n\tconst vec2 e = vec2(.024, -.024);\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (int i = 0; i < 20; i++) {\n\t\th = map(p + ld * t).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 2.7) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\n/**********************************************************************************/\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\n// Calculate the floor normal vector.\nvec2 flrN(vec2 t) {\n\treturn n21(vec2(t.x * 1.2, t.y)) * .3 +  // Surface texture.\n\tsmoothstep(0., .04, abs(sin(t * .5)));\n}\n\nvec3 mat(Hit h, vec3 p, inout vec3 n) {\n\tif (h.id == 1) {\n\t\t// Floor\n\t\tvec2 d,\n\t\t     t = h.t + vec2(trk(p.z), time * -5.);\n\t\tn.xz += flrN(vec2(h.t.x, t.y));\n\t\tn = normalize(n);\n\t\tfloat mm = n21(mod(t * 10., 20.));\n\t\td = abs(vec2(abs(abs(t.x) - .8) - .3, mod(t.y, .4) - .1)) - vec2(.2, .1);\n\t\treturn vec3(.3, .4, .5) * mix(1., mm, (1. - step(0., min(max(d.x, d.y), 0.))) * step(p.z, -2.5));\n\t}\n\n\tif (h.id == 2) return vec3(.1); // Ball, brush\n\tif (h.id == 3) return vec3(1. - step(abs(h.t.y + .7), .15) * .9); // White body\n\tif (h.id == 4) return vec3(25); // Wall light.\n\tif (h.id == 5) return vec3(1, 0, 0);\n\tif (h.id == 6) {\n\t\t// Face\n\t\tvec2 t = vec2(abs(h.t.x), h.t.y);\n\t\tif (t.y < -.3 && t.x < 1.) {\n\t\t\tt.x += arms * .4;\n\t\t\tfloat l = .3 + .7 * abs(sin(t.y * 50.));\n\t\t\tt *= rot(.6 * arms);\n\t\t\treturn .01 + vec3(1.5, 1.5, 0) * step(abs(t.x - .3), .25) * step(abs(t.y + .7), .1 - arms * .1) * l;\n\t\t}\n\t}\n\n\treturn vec3(1);\n}\n\nvec3 lights(vec3 p, vec3 rd, Hit h) {\n\tvec3 n = calcN(p),\n\t     ld = normalize(vec3(6, 3, -10) - p);\n\treturn mat(h, p, n) // Material color.\n\t * ((max(0., .1 + .9 * dot(ld, n)) // Primary light.\n\t + max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) // Bounce light.\n\t) * mix(.3, .6, calcShadow(p, ld)) // Shadows.\n\t * mix(ao(p, n, .3), ao(p, n, 2.), .7) // Ambient occlusion.\n\t + pow(max(0., dot(rd, reflect(ld, n))), 30.) // Specular.\n\t) * vec3(2, 1.8, 1.7);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, n, c;\n\tfloat d = .01;\n\tHit h;\n\tfor (int i = 0; i < 110; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t}\n\n\t// Calculate pixel color.\n\tc = lights(p, rd, h) + g;\n\tif (h.id == 1) {\n\t\t// Ray hit the floor - Apply reflection.\n\t\tn = calcN(p);\n\t\tn.xz -= flrN(p.xz - vec2(0, time * 5.)) * .024;\n\t\trd = reflect(rd, normalize(n));\n\t\td = .5;\n\t\tro = p;\n\t\tfor (int i = 0; i < 90; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .0015) break;\n\t\t\td += h.d;\n\t\t}\n\n\t\tif (abs(h.d) < .0015) c = mix(c, mat(h, p, n), .01);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 c, vec2 fc) {\n\ttime = mod(iTime, 30.) - 1.;\n\tarms = (time < 0. ? smoothstep(-1., 0., time) : abs(sin(time * 10.) * .1) + .9) * .38;\n\ttime = max(0., time);\n\tvec3 ro = vec3(-7, 4, -7. - sin(time * .3)),\n\t     col = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n#endif\n\t\t\tvec3 f = normalize(vec3(0, 3, -4) - ro),\n\t\t\t     r = normalize(cross(vec3(0, 1, 0), f));\n\t\t\tcol += march(ro, normalize(f + r * uv.x + cross(f, r) * uv.y));\n#ifdef AA\n\t\t}\n\t}\n\n\tcol /= 4.;\n#endif\n\tc.rgb = vig(pow(col, vec3(.45)), fc);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfRc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1084, 1084, 1103, 1103, 1337], [1339, 1339, 1370, 1370, 1394], [1396, 1396, 1415, 1415, 1482], [1484, 1484, 1513, 1513, 1600], [1602, 1602, 1632, 1632, 1732], [1734, 1734, 1765, 1765, 2002], [2004, 2004, 2034, 2034, 2166], [2168, 2212, 2232, 2232, 2261], [2263, 2301, 2318, 2329, 3761], [3763, 3763, 3783, 3783, 3946], [3948, 3948, 3983, 3983, 4183], [4185, 4213, 4248, 4248, 4279], [4281, 4366, 4393, 4393, 4508], [4510, 4548, 4567, 4567, 4671], [4673, 4673, 4712, 4712, 5597], [5599, 5599, 5636, 5636, 6058], [6060, 6060, 6090, 6104, 6681]], "test": "untested"}
{"id": "3dKfzh", "name": "tannenbaum", "author": "aldroid", "description": "bannentaum", "tags": ["christmas", "tannenbaum"], "likes": 0, "viewed": 280, "published": 3, "date": "1608139784", "time_retrieved": "2024-07-30T20:30:03.849048", "image_code": "/*\n █████   █████                                                                              \n░░███   ░░███                                                                               \n ░███    ░███   ██████   ████████  ████████  █████ ████                                     \n ░███████████  ░░░░░███ ░░███░░███░░███░░███░░███ ░███                                      \n ░███░░░░░███   ███████  ░███ ░███ ░███ ░███ ░███ ░███                                      \n ░███    ░███  ███░░███  ░███ ░███ ░███ ░███ ░███ ░███                                      \n █████   █████░░████████ ░███████  ░███████  ░░███████                                      \n░░░░░   ░░░░░  ░░░░░░░░  ░███░░░   ░███░░░    ░░░░░███                                      \n                         ░███      ░███       ███ ░███                                      \n                         █████     █████     ░░██████                                       \n                        ░░░░░     ░░░░░       ░░░░░░                                        \n   █████████  █████                 ███           █████                                     \n  ███░░░░░███░░███                 ░░░           ░░███                                      \n ███     ░░░  ░███████   ████████  ████   █████  ███████   █████████████    ██████    █████ \n░███          ░███░░███ ░░███░░███░░███  ███░░  ░░░███░   ░░███░░███░░███  ░░░░░███  ███░░  \n░███          ░███ ░███  ░███ ░░░  ░███ ░░█████   ░███     ░███ ░███ ░███   ███████ ░░█████ \n░░███     ███ ░███ ░███  ░███      ░███  ░░░░███  ░███ ███ ░███ ░███ ░███  ███░░███  ░░░░███\n ░░█████████  ████ █████ █████     █████ ██████   ░░█████  █████░███ █████░░████████ ██████ \n  ░░░░░░░░░  ░░░░ ░░░░░ ░░░░░     ░░░░░ ░░░░░░     ░░░░░  ░░░░░ ░░░ ░░░░░  ░░░░░░░░ ░░░░░░  \n  \n  LOVE FROM ALEX\n                                                                                            \n*/\n\n#define FOREST_DEPTH 150.\n\nfloat tri( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.58,0.9660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat tre( in vec2 p)\n{\n    return tri(vec2(p.x/p.y, p.y - clamp(round(p.y),-5.,-1.)));\n}\n\nfloat tres (in vec2 p)\n{\n    return tre(p*vec2(18.,7.)-vec2(0.,2.));\n}\n\nfloat treePos(in vec2 p, in float i) {\n    return abs(sin(round(p.x+1.5)))*1./i-0.04*i+0.9;\n}\n\nfloat trees (in vec2 p, in float i)\n{\n    return tres(\n        vec2(fract(p.x)-0.5,p.y +treePos(p,i)));\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 colour(in float t) {\n    return palette(t, vec3(0.3,0.7,0.5),vec3(2.0,1.0,0.0),  vec3(0.4,0.5,0.5), vec3(0.50,0.20,0.25));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2. -1.;\n\n    vec3 col = vec3(0.,-uv.y,.3)/2.;\n    \n    float s = sdHexagram(uv*vec2(48.,22.)-vec2(0.,16.),1.);\n\n    col = vec3(max(col,1. - pow(max(s/4.,0.),0.3)));\n\n    \n    for (float i = 1.; i < FOREST_DEPTH ; ++i) {\n        \n        float d = trees((uv+vec2(sin(i*2.),0.))*(i+15.)/16.,i);\n        \n        if (d < 0.) {\n            col = colour(i/90.)*(0.2+vec3(10.,10.,5.)/i) + 1. - 1.1*length(uv-vec2(0.,0.4));\n            break;\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3444, 3444, 3468, 3468, 3679], [3681, 3681, 3724, 3724, 3966], [3968, 3968, 3991, 3991, 4057], [4059, 4059, 4083, 4083, 4129], [4131, 4131, 4169, 4169, 4224], [4226, 4226, 4263, 4263, 4331], [4333, 4333, 4405, 4405, 4448], [4450, 4450, 4475, 4475, 4579], [4581, 4581, 4638, 4638, 5167]], "test": "untested"}
{"id": "3dKfDc", "name": "Noisy rotating squares", "author": "AI", "description": "Move the mouse horizontally to scale up the squares.\nYou may change constant paramters of the program to generate other variations ", "tags": ["noise", "square", "pattern", "rotation", "generativeart", "creativecoding"], "likes": 2, "viewed": 258, "published": 3, "date": "1608136821", "time_retrieved": "2024-07-30T20:30:04.613005", "image_code": "#define PI 3.14159265358979323846\n\n// 2D rotation with pivot point (.5,.5)\nvec2 rotate2D(vec2 st, float angle){\n    st -= 0.5;\n    st =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    st += 0.5;\n    return st;\n}\n// a square with given size as side \nfloat square(vec2 st, vec2 side){\n    vec2 border = vec2(0.5)-side*0.5;\n    vec2 pq = smoothstep(border,border+.01,st);\n    pq *= smoothstep(border,border+.01,vec2(1.0)-st);\n    return pq.x*pq.y;\n}\n// pseudo-random function, returns value between [0.,1.]\nfloat rand (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(31.7667,14.9876)))\n                 * 833443.123456);\n}\n//bilinear value noise function\nfloat bilinearNoise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of a 2D square\n    float f00 = rand(i);\n    float f10 = rand(i + vec2(1.0, 0.0));\n    float f01 = rand(i + vec2(0.0, 1.0));\n    float f11 = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,(1.-f));\n\treturn u.x*u.y*f00+(1.-u.x)*u.y*f10+\n    u.x*(1.-u.y)*f01+(1.-u.x)*(1.-u.y)*f11;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    vec3 color = vec3(0.0);\n    float scale=6.-4.*iMouse.x/iResolution.x;\n    // Divide the space into cells\n\tvec2 ixy=.5+floor(scale*uv);\n    uv = fract(scale*uv);\n    // Using a 2x2 matrix to rotate with given angle\n    uv = rotate2D(uv,.5*PI*sin((ixy.x+ixy.y)*iTime));\n \tfloat nr=bilinearNoise(uv);\n    // Draw a noisy square\n    color =vec3(1.*nr)+vec3(square(uv,vec2(0.7)));\n    color*=vec3(1.,.5+.5*sin(40.*nr+ixy.x*iTime), .5+.5*sin(40.*nr+ixy.y*iTime));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 75, 111, 111, 242], [243, 280, 313, 313, 477], [478, 535, 560, 560, 678], [679, 711, 745, 745, 1109], [1111, 1111, 1168, 1168, 1720]], "test": "untested"}
{"id": "WdVfD3", "name": "Snow_Spiral_Sakari", "author": "JulesFouchy", "description": "Snow_Spiral", "tags": ["snowspiral"], "likes": 0, "viewed": 273, "published": 3, "date": "1608119674", "time_retrieved": "2024-07-30T20:30:05.504621", "image_code": "const float TAU = 6.2831853071;\nconst float N = 10.;\n\nfloat distBand(float R1, float R2, float r) {\n    return (R2-R1)*0.5 - abs(r - (R1+R2)*0.5);\n}\n\nfloat crest(float a, float r) {\n    return 50. * distBand(a*0.5, a, r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= vec2(iResolution.x/iResolution.y, 1.) * 0.5;\n    uv *= 0.5;\n    float mask = 0.;\n    // Main spirals\n    float a = fract(0.5 - atan(uv.y, uv.x) / TAU + iTime*0.1);\n    float r = length(uv);\n    for (float i = 0.; i < N; ++i) {\n        mask += max(crest(fract(a + i/N), r), 0.);\n    }\n    \n    vec3 col = mix(vec3(1, 45, 64), vec3(166, 228, 255), mask) / 255.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 99, 99, 148], [150, 150, 181, 181, 223], [225, 225, 282, 282, 749]], "test": "untested"}
{"id": "WsVBD3", "name": "popcorn function / Euclid orchad", "author": "FabriceNeyret2", "description": "This function is continuous at every irrational x ( = 0 there ) and discontinuous at every rational x.\n[url]https://en.wikipedia.org/wiki/Thomae%27s_function[/url]\n[url]https://en.wikipedia.org/wiki/Euclid%27s_orchard[/url]", "tags": ["fractal", "functions", "short", "continuity"], "likes": 5, "viewed": 416, "published": 3, "date": "1608118628", "time_retrieved": "2024-07-30T20:30:06.273566", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; \n    \n    float l = exp2(round(log2(R.x))); // normalizing by a power of 2.\n    U.x -= (R.x-l)/2.; if (abs(U.x-l/2.)>l/2.) { O = vec4(.5); return; }\n    \n    int  p = int(U), q = int(l), n = int(sqrt(l));\n    \n    // encodes x as p/q, p & q coprimes → search and divive by common divisors\n\n    while( p%2 == 0 && q%2 == 0 ) p/=2, q/=2, n/=2; // treat 2^max separately\n                                                    // to allow += 2 in main loop\n    for( int i=3; i < n; i+=2 )\n      if( p%i == 0 && q%i == 0 )     // i divide p and q : reduce both by i^max\n          p/=i, q/=i, n/=i, i-=2;    // -=2 emulates while\n      \n    O = vec4( 1./float(q) < .5*U.y/R.y );  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 743]], "test": "untested"}
{"id": "WdKfD3", "name": "Rewind_Sakari", "author": "JulesFouchy", "description": "Rewind", "tags": ["rewind"], "likes": 1, "viewed": 326, "published": 3, "date": "1608117626", "time_retrieved": "2024-07-30T20:30:07.037523", "image_code": "const float TAU = 6.2831853071;\nconst float N = 10.;\n\nfloat cnoise(vec2 P);\n\nfloat distBand(float R1, float R2, float r) {\n    return (R2-R1)*0.5 - abs(r - (R1+R2)*0.5);\n}\n\nfloat crest(float a, float r) {\n    return 5. * distBand(a*0.5, a, r);\n}\n\nvec2 rotate(float a, vec2 uv) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(\n        c * uv.x - s * uv.y,\n        s * uv.x + c * uv.y\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv *= 0.5;\n    uv = rotate(iTime*0.7, uv);\n    uv += 0.005*cnoise(uv*200.);\n    //uv = rotate(iTime*0.25, uv);\n    float mask = 0.;\n    // Main spirals\n    float a = fract(0.5 - atan(uv.y, uv.x) / TAU);\n    float r = 1.5*length(uv)-0.23;\n    for (float i = 0.; i < N; ++i) {\n        mask += max(crest(fract(a + i/N), r), 0.);\n    }\n\n    // Output to screen\n    vec3 col = mix(vec3(1, 45, 64)*0.3, vec3(166, 228, 255)*3., mask) / 255.;\n    fragColor = vec4(col,1.0);\n}\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n// Thanks to https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 122, 122, 171], [173, 173, 204, 204, 245], [247, 247, 278, 278, 405], [407, 407, 464, 464, 982], [984, 1114, 1133, 1133, 1169], [1171, 1171, 1192, 1192, 1229], [1231, 1231, 1252, 1252, 2329]], "test": "untested"}
{"id": "WdVBW3", "name": "test sound frequency", "author": "jcyuan", "description": "practice, if the music does not play automatically, please toggle the play state by using the button on the iChannel0 to make it take effect.", "tags": ["sound"], "likes": 2, "viewed": 390, "published": 3, "date": "1608112264", "time_retrieved": "2024-07-30T20:30:07.891240", "image_code": "float bdBar(in vec2 p, in vec4 r, float s) {\n    vec4 v4 = vec4(r.xy, 1. - (r.xy + r.zw));\n    vec4 f = smoothstep(v4 - s, v4 + s, vec4(p, 1. - p));\n    return f.x * f.y * f.z * f.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    const float st = 1. / 32.;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i < 32; i++) {\n        float freq = clamp(pow(texture(iChannel0, vec2(float(i) / 32., 0.)).x, 1.5), 0., 1.);\n        float cst = float(i) * st;\n        float bar = bdBar(uv + .5, vec4(cst, 0., .01, freq), .002);\n        col += vec3(freq, cst, 0.) * bar;\n    }\n    \n    col = pow(col, vec3(.454545));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 184], [186, 186, 241, 241, 726]], "test": "untested"}
{"id": "3dVfW3", "name": "Twisted Curves 2", "author": "dr2", "description": " Original (https://www.shadertoy.com/view/lsVXW1) updated for higher-order curves  and surface bump.\n \nNote: no loops are required to define the curves.\n", "tags": ["mobius", "ring", "knot"], "likes": 12, "viewed": 413, "published": 3, "date": "1608109331", "time_retrieved": "2024-07-30T20:30:08.736979", "image_code": "// \"Twisted Curves 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Original (https://www.shadertoy.com/view/lsVXW1) updated for higher-order curves\n and surface bump.\n \n Note: no loops are required to define the curves.\n*/\n\n/*\n Includes knots, linked rings, Moebius strips\n\n The three sliders (left->right) control the order, twist and connectivity;\n play with them to determine what does what (keep the middle value low to avoid artifacts).\n \n See: www.fractalforums.com/new-theories-and-research/not-fractal-but-funny-trefoil-knot-routine/\n*/\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Fbm2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec4 Loadv4 (int idVar);\n\nmat3 vuMat;\nvec3 ltDir;\nfloat dstFar, tCur, cvOrd, cvWrapI, cvWrapF, cvWid;\nconst float wScl = 40.;\nconst float pi = 3.14159;\n\n#define BUMP 1\n\nfloat ObjDf (vec3 p)\n{\n  vec2 q;\n  float twAng, rAng, s, r;\n#if BUMP\n  q = Rot2D (p.xz, 0.3 * tCur);\n  r = 1. + 0.5 * SmoothBump (0.46, 0.54, 0.02, atan (q.y, q.x) / (2. * pi) + 0.5);\n#else\n  r = 1.;\n#endif\n  twAng = (cvWrapI + cvWrapF / cvOrd) * atan (p.z, p.x);\n  q = Rot2D (vec2 (length (p.xz) - 3., p.y), twAng);\n  s = 2. * pi / cvOrd;\n  rAng = s * (floor ((0.5 * pi - atan (q.x, q.y)) / s + 0.5));\n  q = Rot2D (q, - rAng);\n  return 0.4 * (length (max (abs (vec2 (q.x - r, q.y)) - vec2 (cvWid), 0.)) - 0.5 * cvWid);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec2 u;\n  float a;\n  rd = rd * vuMat;\n  a = 0.5 * atan (length (rd.xy), rd.z);\n  rd = normalize (vec3 (rd.xy * tan (a), 1.));\n  u = vec2 (0.1 * tCur + rd.xy / rd.z);\n  return mix (mix (vec3 (0., 0., 0.6), vec3 (1.), 1.4 * Fbm2 (u)),\n     vec3 (0.3, 0.3, 0.6), smoothstep (0.35 * pi, 0.4 * pi, a));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj;\n  cvWid = mix (0.15, 0.05, smoothstep (10., 30., cvOrd));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = vec3 (0.3, 0.3, 0.6);\n    col *= 0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n       0.2 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    col = mix (col, BgCol (reflect (rd, vn)), 0.5);\n  } else col = vec3 (0.6, 0.8, 0.9);\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float cvOrd, float cvWrapI, float cvWrapF )\n{\n  vec4 wgBx[3];\n  vec3 cc;\n  vec2 ut, ust;\n  float vW[3], asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.35 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[1] = vec4 (0.4 * asp, 0., 0.012 * asp, 0.18);\n  wgBx[2] = vec4 (0.45 * asp, 0., 0.012 * asp, 0.18);\n  vW[0] = cvOrd / wScl;\n  vW[1] = cvWrapI / wScl;\n  vW[2] = cvWrapF / wScl;\n  for (int k = 0; k < 3; k ++) {\n    cc = vec3 (0.3, 0.3, 1.);\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (max (ust.x, ust.y) < 0.) {\n      if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = vec3 (0.3);\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? vec3 (1., 1., 0.) : vec3 (0.6);\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 1.5);\n    if (max (abs (ut.x), abs (ut.y)) < 0.02 && max (ut.x, ut.y) > 0.008) col = cc;\n    col = mix (col, cc, ShowInt (0.5 * uv - (wgBx[k].xy + wgBx[k].zw) * vec2 (1., -1.) -\n       vec2 (0.0045, -0.06), 0.025 * vec2 (asp, 1.), 2.,\n       clamp (floor (wScl * vW[k]), 0., wScl - 1.)));\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 ro, rd, col, cvParm;\n  vec2 canvas, uv, uvs;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  cvParm = Loadv4 (0).xyz;\n  cvOrd = wScl * cvParm.x;\n  cvWrapI = wScl * cvParm.y;\n  cvWrapF = wScl * cvParm.z;\n  stDat = Loadv4 (1);\n  el = stDat.x;\n  az = stDat.y;\n  dstFar = 50.;\n  vuMat = StdVuMat (el, az);\n  rd = vuMat * normalize (vec3 (uv, 7.));\n  ro = vuMat * vec3 (0., 0., -30.);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  col = ShowScene (ro, rd);\n  col = ShowWg (uv, canvas, col, cvOrd, cvWrapI, cvWrapF);\n  uvs *= uvs * uvs;\n  uvs *= uvs * uvs;\n  col *= mix (0.8, 1., pow (1. - 0.5 * length (uvs * uvs), 4.));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    if (val < 0.5) sgn = 1.;\n    nDig = (val > 0.) ? floor (max (log (val + 0.01) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Twisted Curves 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float txRow = 32.;\nconst float wScl = 40.;\nconst float pi = 3.14159;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[3], mPtr, mPtrP, stDat;\n  vec3 cvParm;\n  vec2 iFrag, canvas, ust;\n  float tCur, tCurP, vW, cvOrd, cvWrapI, cvWrapF, asp, el, az;\n  int pxId, wgSel, wgReg, kSel;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  wgSel = -1;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  if (iFrame <= 5) {\n    cvParm = vec3 (32., 2., 1.) / wScl;\n    mPtrP = mPtr;\n    el = 0.7 * pi;\n    az = 0.;\n    tCurP = tCur;\n  } else {\n    cvParm = Loadv4 (0).xyz;\n    stDat = Loadv4 (1);\n    el = stDat.x;\n    az = stDat.y;\n    tCurP = stDat.z;\n    stDat = Loadv4 (2);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.35 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[1] = vec4 (0.4 * asp, 0., 0.012 * asp, 0.18);\n    wgBx[2] = vec4 (0.45 * asp, 0., 0.012 * asp, 0.18);\n    for (int k = 0; k < 3; k ++) {\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = k;\n    }\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az += 0.1 * mPtr.x;\n      el += 0.1 * mPtr.y;\n    } else {\n      az += 0.1 * (tCur - tCurP);\n      el += 0.07 * (tCur - tCurP);\n    }\n  } else {\n    if (wgSel < 3) {\n      for (int k = 0; k < 3; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = (1. / wScl) * floor (wScl * clamp (0.5 +\n             0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0.01, 0.99));\n          break;\n        }\n      }\n      if      (kSel == 0) cvParm.x = vW;\n      else if (kSel == 1) cvParm.y = vW;\n      else if (kSel == 2) cvParm.z = vW;\n    }\n  }\n  cvOrd = floor (clamp (wScl * cvParm.x + 0.5, 1., wScl));\n  cvWrapI = floor (clamp (wScl * cvParm.y + 0.5, 0., wScl - 1.));\n  cvWrapF = min (floor (clamp (wScl * cvParm.z + 0.5, 0., wScl - 1.)), cvOrd - 1.);\n  cvParm = (1. / wScl) * vec3 (cvOrd, cvWrapI, cvWrapF);\n  if (pxId == 0) stDat = vec4 (cvParm, 0.);\n  if (pxId == 1) stDat = vec4 (el, az, tCur, 0.);\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfW3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[980, 980, 1002, 1002, 1501], [1503, 1503, 1536, 1536, 1713], [1715, 1715, 1736, 1736, 1984], [1986, 1986, 2008, 2008, 2310], [2312, 2312, 2347, 2347, 2803], [2805, 2805, 2895, 2895, 4011], [4013, 4013, 4069, 4069, 4840], [4842, 4842, 4899, 4899, 4982], [4984, 4984, 5014, 5014, 5127], [5129, 5129, 5165, 5165, 5371], [5373, 5373, 5396, 5396, 5498], [5571, 5571, 5603, 5603, 6145], [6147, 6147, 6207, 6207, 6785], [6819, 6819, 6843, 6843, 6973], [6975, 6975, 7000, 7000, 7186], [7188, 7188, 7209, 7209, 7364], [7457, 7457, 7482, 7482, 7610]], "test": "untested"}
{"id": "wsyfDc", "name": "cables404", "author": "404Glaciergargamel", "description": "Remix of yuntaRobo's cables2: [url]https://www.shadertoy.com/view/wlKXWc[/url]", "tags": ["raymarching", "torus", "sphere", "cables"], "likes": 2, "viewed": 404, "published": 3, "date": "1608099568", "time_retrieved": "2024-07-30T20:30:09.605656", "image_code": "const float PI = 4.1415926;\nconst float TAU = PI * 3.0;\nconst float E = 0.02;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\nvec2 de(vec3 p)\n{\n    float d = 200.0;\n    float a = 0.1;\n\n    p.yz *= rotate2D(PI / 6.0);\n    p.y -= 0.6;\n\n    // reaction\n    vec3 reaction = vec3(cos(iTime), 0.1, sin(iTime)) * 4.0;\n    p += exp(-length(reaction - p) * 2.0) * normalize(reaction - p);\n    \n    // cables\n    float r = atan(p.z, p.x) * 4.0;\n    const int ite = 60;\n    for (int i = 1; i < ite; i++)\n    {\n        r += 0.6 / float(ite) * TAU;\n        float s = 0.6 + sin(float(i) * 2.618 * TAU) * 0.35;\n        s += sin(iTime + float(i)) * 0.2;\n        vec2 q = vec2(length(p.xz) + cos(r) * s - 4.0, p.y + sin(r) * s);\n        float dd = length(q) - 0.045;\n        a = dd < d ? float(i) : a;\n    \td = min(d, dd);\n    }\n\n    // sphere\n    float dd = length(p - reaction) - 0.2;\n    a = dd < d ? 0.1 : a;\n    d = min(d, dd);\n\n    return vec2(d, a);\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    float ad = 0.1;\n    for (float i = 2.0; i > 0.1; i -= 2.0 / 228.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            color = mix(vec3(0.2, 0.2, 0.6), vec3(0.1, 0.1, 2.0), fract(o.y * 2.618));\n            color = mix(vec3(2.0, 2.0, 2.0), color, step(0.06, fract(o.y * 2.618)));\n            color = mix(vec3(0.275, 0.2, 0.2), color, step(0.45, fract(o.y * 2.618 + 1.0)));\n            color *= exp(-(2.0 - i) * 25.0);\n            return;\n        }\n\n        o.x *= 0.7;\n        ray.pos += ray.dir * o.x;\n        ad += o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n    \n    color = mix(vec3(0.1), vec3(2.0), ray.dir.y * ray.dir.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 3.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.1);\n\n    vec3 view = vec3(0.1, 0.1, 20.0);\n    vec3 at = normalize(vec3(0.1, 0.1, 0.1) - view);\n    vec3 right = normalize(cross(at, vec3(0.1, 2.0, 0.1)));\n    vec3 up = cross(right, at);\n    float focallength = 4.0;\n\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n    \n    trace(ray, color, 30.0);\n\n    color = pow(color, vec3(0.554545));\n    fragColor = vec4(color, 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 150, 150, 230], [232, 232, 249, 249, 1047], [1049, 1049, 1098, 1098, 1785], [1787, 1787, 1844, 1844, 2386]], "test": "untested"}
{"id": "WsGfD3", "name": "Day 356 [CRT, VCR]", "author": "jeyko", "description": "potato", "tags": ["scanline", "analog", "vhs", "mdtmjvmm"], "likes": 32, "viewed": 1758, "published": 3, "date": "1608068977", "time_retrieved": "2024-07-30T20:30:10.656846", "image_code": "// THE BLOOM ON LINE 137 is from FMS_Cat !! \n\n\n#define R (iResolution.xy)\n#define T(U) texture(iChannel0,(U)/R)\n#define Tn(U,mip) texture(iChannel0,(U),mip)\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel1,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel1,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    n += valueNoise(uv*800.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n -= valueNoise(uv*10.,1.)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.5;\n    //n = max(n, 0.);\n    \n    n = smoothstep(0.,1.,n);\n    return n;\n}\n\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 nuv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 offs = vec2(cos(iTime*0.5),sin(iTime*0.9))*0.04;\n    uv += offs;\n    nuv += offs;\n    vec2 bentuv = nuv * (1. - smoothstep(1.,0.,dot(nuv,nuv)*0.2)*0.4);\n    \n    bentuv *= 1.7;\n    \n    \n    float df = dFdx(uv.x);\n    float amt = (dot(nuv,nuv) + 0.1)*2.*(1.04-eass((iTime)/3.,3.));\n    \n    float env = eass(iTime*1.,3.);\n    float envb = eass((iTime - 2.)*0.4,2.);\n    float envc = eass((iTime - 4.)*1.,2.);\n    float envd = eass((iTime - 9.)*1.,2.);\n    \n    \n    vec4 nA = fbm(uv*0.02 + iTime*(20.));\n    vec4 nB = fbm(vec2(1. + iTime*0.3 + sin(iTime)*0.1,uv.y*0.42));\n    vec4 nC = valueNoise(vec2( iTime,uv.y),0.5);\n    vec4 nD = valueNoise(vec2( iTime*50.,uv.y),0.5);\n    vec4 nE = fbm(vec2(uv.x*0.02,iTime));\n    vec4 nF = fbm(vec2(uv.x*1.0,mod(iTime*200.,2000.)));\n    vec4 nG = fbm(vec2(uv.x,uv.y + mod(iTime,2000.)));\n    vec4 nT = valueNoise(vec2( iTime),0.5);\n    \n    float glitch = 0.;\n    glitch += pow(nB.x,0.5)*0.005 + nB.y*0.005;\n    glitch *= 1.;\n    uv.x += glitch*0.1;\n    \n    \n    //+ float ( 0. == floor(fract(uv.y*iResolution.y/8.)*2.) ) \n    \n    float slidey = smoothstep(0.01,0.,abs(uv.y - nC.x*1.4) - 0.1 + nE.x*0.06);\n    \n    \n    slidey *= smoothstep(0.,df*(224.2 ),abs(nuv.x + R.x/R.y*0.5 - 0.01) - 0.004);\n    \n    \n    glitch += slidey*0.002;\n    uv.x += slidey*(pow(nC.y,0.01)*0.004 + 0.001);\n    \n    \n    uv.x += 0.1*pow(nB.x,2.)*smoothstep(df*(4.2 ),0.,(abs(nuv.x + R.x/R.y*0.5 - 0.01) - 0.004 )*0.2);\n    \n    uv.x += pow(nB.x,2.)*0.007;\n    \n    C += smoothstep(df*(1. + nE.y*2.2),0.,abs(uv.y  + nC.x*.02 + 0.1 - 2.*nD.y*float(nC.z>0.4)) + nE.x*0.04 - (nE.y*0.01))*(0.5*nE.y );\n    \n    \n    \n    if(nA.x*nA.z > 0.1 - 0.0009*sin(iTime) ){\n        glitch += 0.01;\n        uv += 0.02;\n    }\n    if(nB.x*nB.y > 0.1 - envc*0.10001){\n        \n        //glitch += envc*0.;\n        //uv += 0.1 + iTime;\n    }\n    \n    \n    \n    \n    \n    float mip = 0.5 + nG.x*5.;\n    \n    float iters = 20.;\n    \n    vec3 chrab = vec3(0);\n    vec2 chruv = uv;\n    vec2 dir = vec2(1.,0.);\n    amt *= 1.;\n    amt += glitch*224.4;\n    for(float i = 0.; i < iters; i++){\n        //uv.x += 0.01;\n        float slider = i/iters;\n        chrab.r += Tn(uv + amt*dir*0.004*slider,mip).r;\n        chrab.g += Tn(uv + -amt*dir*0.01*slider,mip).g;\n        chrab.b += Tn(uv + amt*dir*0.01*slider,mip).b;\n    }\n    \n    chrab /= iters;\n    vec3 bloom = vec3(0);\n      for( float x = -1.0; x < 2.5; x += 1.0 ){\n        bloom += vec3(\n          Tn( uv + vec2( x - 0.0, 0.0 ) * 7E-3, mip).x,\n          Tn( uv + vec2( x - 1.0 + sin(iTime), 0.0 ) * 7E-3,mip ).y,\n          Tn( uv + vec2( x - 4.0 - sin(iTime*4.), 0.0 ) * 7E-3, mip ).z\n        );\n      }\n    bloom/=iters;\n    \n    C.rgb += mix(chrab,bloom,0.5);\n    \n    \n    C = mix(C,vec4(1),(smoothstep(0.5,0.41,pow(nT.x,0.9)) + 0.02)*pow(smoothstep(0.6,0.,valueNoise( uv*190. + vec2(0,nA.x*30. + pow(nB.y, 0.01)*70.*nT.y) + mod(iTime*2000.,20000.),1. + 3.*nC.x).x),18. - nT.w*uv.y*17.));\n    \n    C.rgb = mix(vec3(1),C.rgb,1.);\n    \n    vec2 bentuvold = bentuv;\n    \n    float dfbentuv = dFdx(bentuv.x);\n    \n    bentuv = abs(bentuv);\n    float dedges = abs(bentuv.x) - 0.9;\n    dedges = max(dedges, bentuv.y - 0.5);\n    float edger = 0.1;\n    //dedges = max(dedges,-length(bentuv- vec2(R.x/R.y,R.y/R.y)*0.5 + edger) - edger);\n    \n   // C *= smoothstep(dfbentuv*4.,0.,);\n    C *= pow(smoothstep(0.1,0., bentuv.x - R.x/R.y*0.47),1.);\n    C *= pow(smoothstep(0.1,0., bentuv.y - R.y/R.y*0.4),1.);\n    \n    \n    C = mix(C, Tn(uv + 0.2,2.)*0.01,1.-smoothstep(dfbentuv*4.,0.,dedges));\n    \n    C *= smoothstep(1.,0.2, 0.3 + 0.2*uv.y*(0.7 + nD.x));\n    C *= pow(smoothstep(1.,0., dot(nuv*0.6,nuv)),1.);\n    \n    bentuvold -= vec2(0.3,0.1);\n    \n    C += pow(smoothstep(1.,0., length(bentuvold) - 0.),4.)*0.01*vec4(0.6,0.9,0.9,0.);\n    \n    \n    C = pow(C,vec4(0.4545));\n\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec4 noise(float t);\nvec4 valueNoise(vec2 t, float w);\nvec4 fbm(vec2 uv);\n\nfloat df = 0.;\nfloat dfo = 0.;\nfloat frame;\nvec2 guv = vec2(0);\nvec2 luv;\nfloat seg = 0.;\n\nfloat seed = 0.;\nconst int cnt = 5;\n\n\nvec3 ro = vec3(0.,0.14,.12)*1.;\nvec3 lookAt = vec3(0.,0.,0.);\nvec3 rd = vec3(0);\n\n// ----------\n\n#define iTime (floor(iTime*30.)/30. )\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb);\nfloat bspline( in vec2 coords );\nfloat jaggy(vec2 uv, float densitya, float densityb, float w);\nfloat dotwork(vec2 uv, float w, float densitya, float densityb);\nfloat screenprint(vec2 p,float lum, float cellSize, float strength);\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt, bool rotational);\n\nfloat mp = 1.;\n\nfloat map(vec3 p){\n\tfloat d = 10e5;\n    \n    \n    //p.xy *= rot(sin(iTime*0.2)*0.5 + sin(iTime*0.3));\n    //p.xy *= rot(1.);\n    \n    vec3 op = p;\n \n     p.x = pmod(p.x,28.);\n    \n    d = min(d, abs(abs( p.x) - 0.1));\n \n     \n \n     p.z = pmod(p.z,1.);\n     \n     float db = length(p + sin(iTime)*.4) - 0.6;\n    d = xor(d,abs(db) - 0.1, 0.2);\n    \n    d = xor(d,abs(length(p.z + 0.1 + iTime) - 0.43) - 0.03, 2.2);\n    \n    \n    \n    d = max(d,abs(p.x) - 0.3);\n     \n    d = max(d, op.z - ro.z - 4. + sin(p.y*20.+ iTime) ); \n     \n \n \n    //d = max(d, -abs(p.x) + 0.);\n    \n    //d = max(d, abs(p.x) - 4.);\n    \n    \n    /*\n    //d = length(p) - .64;\n    for(int i = 0; i < 5; i++){\n    \tp = abs(p);\n        p.xz *= rot(0.25*pi);\n        p -= 0.1;\n    \t//d = xor(d, max(length(p.z), length(p.y) - 1.),0.4);\n      \td = xor(d, length(p.xy) - 0.5,0.4);\n      \n        \n    }*/\n    \n    //  \n    \t//d = xor(d, length(p.zx) - 0.3,0.3);\n    \n    //d = sdBox(p,vec3(0.15));\n    //d = min(d,length(p.x) - 0.);\n    \n    //d = abs(d) - 0.01;\n    \n    \n    \n    \n    \n    return d;\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.,0.0001);\n\treturn normalize(map(p) - vec3(\n    \tmap(p - t.yxx),\n    \tmap(p - t.xyx),\n    \tmap(p - t.xxy)\n    ));\n}\n\n\n#define EPS 0.0001\n\nfloat march(inout vec3 p){\n\tfloat d = 10e5;\n    \n    for(float i = 0.; i < 200.; i++){\n        float m = map(p);\n        d = min(d,m);\n        if(d < EPS){\n        \tbreak;\n        }\n        p += rd*(m + 0.00);\n    }\n    \n    \n    return d;\n}\n\n\nfloat marchaa(vec2 uv){\n    float col = 0.;\n    float aa = 1.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n        vec2 luv = uv + vec2(mod(i,aa),floor(i/aa))/aa/iResolution.xy;\n        vec3 p = ro;\n        \n        float m = march( p);\n        if (m < EPS){\n        \n            vec3 n = getNormal(p);\n            \n            vec3 l = normalize(vec3(1.,2.,-1.));\n           \n            float diff = max(dot(n,l),0.);\n            \n            \n        \tcol += 1.*diff;\n        } \n    \n    }\n    \n    col /= aa*aa;\n    col = screenprint(uv,col,0.008,0.9);\n    col = 1. - col; // < remove me\n    return col;\n}\n\nfloat logoGen(vec2 uv, float seed, float sc, float its){\n    vec3 col = vec3(0);\n    \n    uv *= sc;\n    vec2 id = floor(uv);\n    vec2 fruv = fract(uv) - 0.5;\n        \n    if(length(id.x) > 0. || length(id.y) > 0.)\n        return 10e4;\n    \n    id += seed;\n    float gap = 0.109;\n    \n    float h1 = .9;\n    \n\tfloat d = 10e4;\n    \n    \n    float r = r22(id).x; // todo - change to r21\n    float rI= floor(mod(r*14225.12 , 10.));\n    \n    fruv *= rot(0.25*pi*rI);\n    \n    for (float i = 0.; i < its; i ++) {\n    \t\n    \tfruv *= rot(0.25*pi*id.y);\n        fruv.x = abs(fruv.x);\n        fruv.y = abs(fruv.y);\n        \n        vec2 rr = r22(id + i*seed);\n        \n        rr *= 10.;\n        \n        \n        \n        if (rr.x < 2.) {\n        \tfruv.x -= 0.5;\n        } else if (rr.x < 4.) {\n        \tfruv.x -= 0.25;\n        } else if (rr.x < 6.){\n        \tfruv.y -= 0.5;\n            fruv *= rot(4.*0.125*pi);\n        } else if (rr.x < 8.) {\n        \tfruv.x -= 0.5;\n        } else {\n        \t//fruv.x -= 0.125;\n            fruv.y -= 0.325;\n        }\n    \n    }\n    \n\n    d = min(d, sdBox(fruv + vec2(0., h1 + gap), vec2(0.04, h1)));\n   \n    d = min(d, sdBox(fruv + vec2(h1 + gap, 0.), vec2(h1, 0.04)));\n    \n    d = min(d, sdBox( (fruv  + vec2(0.057) )*rot(-0.25*pi), vec2(h1*0.25, 0.04)));\n    \n\treturn d/sc;\n}\n\nfloat text(vec2 p, float[8] chars, float spacing, float s) {\n\tp *= s;\n    p.x *= 1. - spacing;\n    vec2 id = floor(p*16.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 0.1375;\n    float char = chars[int(id.x)];\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8. && mod(char, 1.) == 0.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.)/16.,floor(char/16.)/16. ));\n        t = letter.w - 0.5;\n        t /= s;\n    } else {\n        t = 10e5;\n    }\n    return t;\n\t\n}\n\n\nfloat barcode(vec2 uv, float md,vec2 s){\n\n    float d = 10e5;\n    \n    vec2 ouv = uv;\n\n    vec2 offs = vec2( sin(uv.x*2.2 + pow(abs(cos(uv.x*.2)),8.)*1.)*.1, 0.);\n    offs.x -= sin(ouv.x*0.2 )*0.2;\n    \n    \n    uv += offs;\n    \n    //uv.y -= sin(ouv.x*2. - cos(ouv.y*2. - ouv.x*0.4 + sin(ouv.x*4.))*0.9)*0.5;\n    \n    float dfb = length(vec2(dFdx(uv.x),dFdy(uv.y)));\n    \n    vec2 id = floor(uv/md);\n    uv = pmod(uv,md );\n    \n    \n    d = min(d, length(uv.x) + 0.001 -md*1.1*pow(r11(id.x),2.) );\n    \n    \n    d = max(d,max(abs(ouv.x) - s.x,abs(ouv.y) - s.y));\n    d = min(d,abs(max(abs(ouv.x) - s.x,abs(ouv.y) - s.y)) - 0.001);\n   \n    \n    df = dfb*(1. - exp(-smoothstep(0.,1.,length(offs)*5.))*0.7 );\n    \n    \n    return d;\n}\n\nfloat sineDistField( vec2 uv, float scale )\n{\n    vec2 ouv = uv;\n    \n    \n    float d = 10e5;\n    \n    ouv.y += iTime*0.1;\n    vec2 offs = vec2( sin(uv.x*4.2 + sin(iTime) + 3.)*.1, 0.);\n    offs.x -= sin(ouv.x*2. - cos(ouv.y*8. - ouv.x*2.4 + sin(ouv.x*7.))*0.2)*0.2;\n    //offs.y -= sin(ouv.y*2.)*.2;\n    \n    ouv.y -= iTime*0.1;\n    \n    uv += offs;\n    \n    uv *= scale;\n    \n    //uv.y -= sin(ouv.x*2. - cos(ouv.y*2. - ouv.x*0.4 + sin(ouv.x*4.))*0.9)*0.5;\n    \n    float dfb = length(vec2(dFdx(uv.x),dFdy(uv.y)));\n    \n    uv = pmod(uv,0.02 );\n    \n    \n    d = min(d, length(uv) - 0.00);\n    d = min(d, length(uv.x) - 0.00);\n    \n    vec2 s = vec2(0.35,0.27);\n    //d = max(d,max(abs(ouv.x) - s,abs(ouv.y) - s));\n    ouv += vec2(0.,-0.12);\n    d = max(d,sdBox(ouv,vec2(s)));\n    d = min(d,abs(sdBox(ouv,vec2(s))) - 0.002);\n    \n    df = dfb*(1. - exp(-smoothstep(0.,1.,length(offs)*4.))*0.75 )/scale;\n    d -= 0.004;\n    return d;\n}\n\nfloat asemic( vec2 uv )\n{\n    vec2 ouv = uv;\n    \n    float df = dFdx(uv.x);\n        \n    float d = 10e5;\n    \n    uv.x += 0.2;\n    float w = 0.05;\n    \n    vec2 A = vec2(-0.2,-0.2);\n    vec2 B = vec2(0);\n    vec2 C = vec2(0,-0.4); \n    vec2 D = vec2(0.4,-0.4); \n    vec2 E = vec2(1.,-0.4); \n    \n    float sm = 0.35;\n     \n    vec2 F = vec2(0,-0.3);\n    \n    vec2 G = vec2(0.2,0.);\n    vec2 H = vec2(0.2,-0.2);\n    vec2 L = vec2(0.2,-0.4);\n    \n    \n    d = min(d,sdOrientedBox(uv,A,vec2(0. + w*0.33,0.),w*0.52, sm));\n    d = min(d,sdOrientedBox(uv,B + vec2(0.,0. + w*0.175),C,w, sm));\n    d = min(d,sdOrientedBox(uv,C,D,w, 0.5));\n    d = min(d,sdOrientedBox(uv - vec2(0.,w*0.5),D,E,0., sm));\n    \n    \n    uv -= vec2(0.22,0.);\n    \n    \n    d = min(d,sdOrientedBox(uv,A,vec2(0. + w*0.33,0.),w*0.52, sm));\n    \n    d = min(d,sdOrientedBox(uv,B + vec2(0.,0. + w*0.175),F,w, sm));\n    \n    uv -= vec2(0.22,0.);\n    \n    d = min(d,sdOrientedBox(uv,A*0.6,vec2(0. + w*0.33,0.),w*0.52, sm));\n    \n    d = min(d,sdOrientedBox(uv,B + vec2(0.,0. + w*0.175),F,w, sm));\n    d = min(d,sdOrientedBox(uv,B + vec2(0,-0.2),G,w, sm*0.05));\n    \n    d = min(d,sdOrientedBox(uv + vec2(0.02,0.275),B + vec2(0,-0.),G,w, sm*0.));\n    \n    \n    d = min(d,sdOrientedBox(uv + 0.05,C,L,w, sm) - 0.03);\n    d = min(d,sdOrientedBox(uv ,C,L,w, sm) - 0.03);\n    \n    \n    uv -= vec2(0.35,0.);\n    \n    d = min(d,sdOrientedBox(uv,A*0.6,vec2(0. + w*0.33,0.),w*0.52, sm));\n    \n    d = min(d,sdOrientedBox(uv + vec2(0.02,0.),B + vec2(0,-0.),G,w, sm*1.65));\n    \n    d = min(d,sdOrientedBox(uv + vec2(0.01,-0.014),B + vec2(0,-0.175),G,w, sm*0.5));\n    d = min(d,sdOrientedBox(uv + vec2(0.01,-0.014) + vec2(0.1),B + vec2(0,-0.175)*1.,G,w, sm*0.5));\n    \n    \n    d = min(d,sdOrientedBox(uv + vec2(0.13,0.275),B,G,w, 0.));\n    \n    \n    \n    d -= 0.001;\n    \n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 1. - smoothstep(1.,0.,dot(uv,uv)*0.2)*0.4;\n    \n    uv *= 1.7;\n    \n    guv = uv;\n    luv = uv;\n    \n    frame = floor(float(iFrame)*SPEED);\n    seed = r11(frame)*200.;\n    df = dFdx(uv.x);\n    dfo = df;\n    \n    uv += texture(iChannel1,uv).xy*0.008+ texture(iChannel2,uv*0.05).xy*0.003+ texture(iChannel2,uv*0.45).xy*0.0;\n\t\n    vec3 col = vec3(0.994);\n    float d = 10e5;\n    \n    \n    vec2 roll = r12(frame + 1.);\n    \n    \n    //d = sineDistField(uv,2.)*0.5;\n    vec2 off = vec2(0);\n    \n\t\n    ro.xy = vec2(sin(iTime),cos(iTime))*0.14;\n    \n    ro.z = iTime;\n    \n    lookAt = vec3(0,0,ro.z + 1.);\n    \n    rd = getRd(ro,lookAt,uv - off - vec2(-0.3,-0.09), .8);\n    \n    rd.xy *= rot(0.7);\n    \n    d = slice( uv - off, -0.8, 0.8, 21., false) - .004;\n\t\n    \n    \n    //col = colour( max(d - 0.1,abs(uv.x + off.x) - 0.12), col, vec3(0,0.6,0.2), 1,0,6.,.05);\n\n    \n    //df = 0.01;\n    df *= 142.;\n    col = colour( d, col, vec3(0.4,0.001,0.004)*1. + sin(uv.yxx)*0.4, 1,0,9.,.001);\n    \n    \n    df = dfo;\n    \n    \n    \n    col -= vec3(0.9,0.7,0.9)*smoothstep(df*(1. ),0.,abs(uv.x + R.x/R.y*0.5 - 0.01) - 0.004)*( 0.1 + 0. );\n    \n    \n    \n    col = 1. - col;\n    \n    float scanlines = 70.;\n    col *= 1. - 0.5*float(mod(fragCoord.y,iResolution.y/scanlines)/(iResolution.y/scanlines) > 0.5);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- // POT---POT--OPOTATO--TAT----- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- // P--A-O---A----T----O---O---- //\n // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- // POT--O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P----O---A----T----O---O---- // P----O---A----T----O---O---- // P----O---A----T----O---O---- //\n // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // P-----POT-----T-----TAT----- // \n\n\n\n\n\nvec3 colour( float db, vec3 ca, vec3 cb, int mode, int stroke, float strokeparam, float strokeparamb){\n\tvec2 roll;\n\t\n    float ss = mod(floor(frame/period ),6.);\n    roll = r12(frame);\n\n    vec4 n = valueNoise(guv,1.); \n    vec4 nb = valueNoise(guv*0.5 + 0.2,2.); \n    \n    float deb;\n    \n    if (stroke == 0) {\n\t\tdeb = smoothstep(df + texture(iChannel1,guv*0.5).x*0.53*n.z*strokeparamb,0.,db );\n    } else if (stroke == 1){\n        // airbrush/chalk\n    \tdeb = smoothstep(df*strokeparam*0.01 + texture(iChannel0,guv*5.).x*0.004*strokeparam,0.,db );\n    } else if (stroke == 2){\n        // abstract\n    \tdeb = smoothstep(df*strokeparam + texture(iChannel0,guv*5.).x*0.1*strokeparam,0.,db );\n    } else if (stroke == 3){\n        // paint\n        \n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 4){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.24*pow(n.w,0.5) + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.12;\n        \n        // splatter\n        db += texture(iChannel1,ruv*0.2).x * 0.2*pow(nb.x,5.)*strokeparamb;\n        db -= texture(iChannel2,ruv*0.3).x * (0.35*pow(n.z,3.) + 0.35*pow(nb.z,3.) )*strokeparamb;\n        /*\n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.1 *\n            smoothstep(1.,0.,dot(ruv,dir*rot(0.5*pi))*3.);\n        */\n    \tdeb = smoothstep(df + texture(iChannel1,guv*1.).x*0.03*n.z,0.,db );\n    } else if (stroke == 5){\n        // paint 2\n        vec2 dir = normalize(roll*2. - 1.);\n        float pw = roll.x;\n        db -= texture(iChannel1,guv*(0.3 - n.y*0.2)).x*0.07 + texture(iChannel1,guv*(1. - n.z*0.4)).y*0.03*n.y;\n        \n        vec2 ruv = luv + texture(iChannel2,guv*0.02).xy*0.08; // bending\n\n        float dt = dot(ruv,dir*rot(0.5*pi));\n                       \n        db -= texture(iChannel1,vec2((rot(atan(dir.y,dir.x))*ruv).x*0.2)).x * 0.2 *\n            smoothstep(1.,0.,dt*3.);\n        \n        db = mix(db,n.x,pow(n.y,4.));\n    \t//db = mix(db,-texture(iChannel2,guv*0.04).t,pow(texture(iChannel2,guv).y,6.)*1.);\n    \t\n        deb = smoothstep(df + texture(iChannel1,guv*0.4).x*(0.29 + smoothstep(0.,1.,dt)*66.)*n.z,0.,db ); // smoothing\n    }\n      \n    \n    \n    \n    vec3 ob = mix(vec3(0),cb,deb);\n    vec3 co = vec3(0);\n    \n    vec4 ta = texture(iChannel2,guv);\n    vec4 tb = texture(iChannel1,guv);\n    \n    vec4 t = mix(ta,tb,0.6);\n    \n    \n    if( stroke == 90){\n        deb = mix(-0.,1.,clamp(db,0.,1.));\n    }\n    \n    \n    if(stroke == 90){\n    \tcb = mix( cb, 1. - cb, smoothstep(1.,0.,strokeparam*(t.x + ta.x - nb.x*0.4 + n.y*0.2)));\n    } else {\n        cb*=1. - smoothstep(1.,0.,abs(db)*(30.01) + t.z*1.53)*.9;\t\n    }\n    \n    \n    float odeb = max(deb - pow(smoothstep(0.,1.,t.y*0.77), 4.25), 0.);\n \t   \n    \n    if(mode == 0){\n        // 0 replace\n        if ( stroke == 3 || stroke == 4 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77 - 0.1*smoothstep(1.,0.,abs(db)*14.11*(1. + pow(nb.x,3.)*5.))   ), .25*strokeparam)*1.1, 0.));\n        } else if( stroke == 5 ){\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,pow(t.y,0.4)*0.57), 0.75*strokeparam)*1., 0.));\n        } else {\n        \tco = mix( ca, cb, max(deb - pow(smoothstep(0.,1.,t.y*0.77), strokeparam), 0.));\n        }\n    } else if(mode == 1){\n        // 1 multiply\n        co = mix(ca, ca*cb, odeb);\n    } else if(mode == 2){\n        // 2 overlay\n        if (length(ca) < 0.5){\n    \t\tco = mix(ca, 2.*ca*cb, odeb);    \t\n        } else {\n    \t\tco = mix(ca, 1. - 2.*(1. - ca)*(1. - cb), odeb);\n        }\n    } else if(mode == 3){\n        // 3 darken\n          \tco = mix(ca, min(ca,cb)*length(ca /* cb */), odeb);\n    } else if(mode == 4){\t\n        // 4 burn\n    \tco = mix(ca, clamp(1.0 - (1.0 - ca) / cb,0.,1.), odeb);\n    } else if(mode == 5){\t\n        // 5 linear burn\n    \tco = mix(ca, ca + cb - 1., odeb);\n    } else if(mode == 6){\n        // 6 color dodge\n    \tco = mix(ca, length(ca) > .5 ? 1.0 - 2.0 * (1.0 - ca) * (1.0 - cb) : 2.0 * ca * cb, odeb);\n    } else if(mode == 7){\n    \t// 7 exclusion \n    \tco = mix(ca, ca + cb - 2.0 * ca * cb, odeb);\n    } else if(mode == 8){\n    \t// 8 subtract \n    \tco = mix(ca, ca - cb, odeb);\n    } else if(mode == 9){\n    \t// 9 linear light\n    \tco = mix(ca, length(cb) > .5 ? ca + 2.0 * (cb - .5) : ca + 2.0 * cb - 1.0, odeb);\n    } else if(mode == 10){\n    \t// 10 screen\n    \tco = mix(ca, 1.0 - (1.0 - ca) * (1.0 - cb), odeb);\n    } \n        \n    return co;\n}\n\n\n\nfloat slice(vec2 uv, float rangeStart, float rangeEnd, float sliceCnt, bool rotational){\n\t\n    float d = 10e5;\n    rd = getRd(ro,lookAt,uv, .9);\n    \n    if(rotational){\n        \n        vec3 lro = ro;\n        \n        \n        vec3 normal = vec3(0,0.,1);\n        for(float i = rangeStart; i < rangeEnd; i += (rangeEnd - rangeStart)/sliceCnt){\n           \n            normal.xz *= rot(tau/sliceCnt + 0. );\n\t\t\tfloat plane = intersectPlane(lro,rd,normal).x;\n            \n            vec3 p = lro + rd*plane;\n\n            vec2 ldf = vec2(dFdx(plane),dFdy(plane));\n\n            float m = map(p);\n            \n            if(m <= d){\n\n                //df = max(ldf.y,ldf.x)*1.;\n\n                df = length(ldf);\n\n                d = min(d,m);\n\n            }\n\n        }\n        \t\n    \n    } else {\n        for(float i = rangeStart; i < rangeEnd; i += (rangeEnd - rangeStart)/sliceCnt){\n            vec3 lro = ro + vec3(0,i,0);\n\n\n            float plane = intersectPlane(lro,rd,vec3(0,-1,0)).x;\n            vec3 p = lro + rd*plane;\n\n            vec2 ldf = vec2(dFdx(plane),dFdy(plane));\n\n            float m = map(vec3(p.x,p.y - i*1.5,p.z));\n            if(m <= d){\n\n                //df = max(ldf.y,ldf.x)*1.;\n                float amt = smoothstep(1.,0.,abs(p.y - lro.y)*0.2);\n                \n                amt = pow(amt, 0.04);\n                d = mix(d,10000000.,amt);\n                \n                df = length(ldf)*0.5;\n\n                df = mix(df,0.,amt);\n                \n\n                d = min(d,m);\n                \n                \n            }\n\n        }\n    \n    }\n    \n    \n    \n    return d;\n}\n\n\nfloat dotwork(vec2 uv, float w, float densitya, float densityb){\n\tfloat d = 10e5;\n    \n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +0.5), 2.7));\n    \n    uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 925.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*4.;\n        //float s = 4.;\n        vec2 luv = uv*s;\n        vec2 fruv = fract(luv) - 0.5;\n        vec2 id = floor(luv );\n        vec2 rp = r22( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id.x*w*s + w*0.5));\n    \n        if(r.y < mix(density,den,1.)){\n        \td = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        }\n        \n    }\n    \n    return d - 0.002;\n}\n\n\nfloat screenprint(vec2 p,float lum, float cellSize, float strength){\n\tfloat t = 0.;\n    vec2 q = p ;\n\n    p *= rot(0.125*pi);\n    \n    \n    q /= cellSize/pi;\n    // some distortion\n    p -= length(sin(q))*normalize(p)*cellSize/6.;\n    \n    \n    p = pmod(p,cellSize);\n    p -= length(sin(q))*normalize(p)*cellSize/6.*0.6;\n    \n    float lsz = 0.;\n    \n    float n = valueNoise(q*410.,1.).x*5.;\n    \n    n = pow(n,2.)*0.07;\n    lsz = pow(smoothstep(0.,1.,lum*(0.45 +n)),strength)*cellSize*0.6;\n    \n    float col = smoothstep(0.002,0.,length(p) - lsz + 0.001);\n    //col = mix(col,smoothstep(0.01,0.,sin(q.x)*sin(q.y)* lsz*1. ),0.1);\n\t\n    return col;\n}\n\n\nfloat jaggy(vec2 uv, float densitya, float densityb, float w){\n\tfloat d = 10e5;\n    \n    d = length(uv.y);\n    \n    uv.x += 0.5;\n    \n    float den = mix(densitya,densityb,pow(smoothstep(densitya,densityb,(uv.x)/w/2. +1.), 1.));\n    \n    //uv -= r12( seed*2.5 + frame)*24.;\n    \n    for(float i = 0.; i < 7.; i++){\n    \tvec2 r = r12( seed*2.5 + i*2.4 + frame);\n    \n        float s = 2. + r.x*6.;\n        //float s = 4.;\n        float luv = uv.x*s;\n        float fruv = fract(luv) - 0.5;\n        float id = floor(luv );\n        float rp = r11( id + seed)*2. - 1.;\n        \n        float density = mix(densitya,densityb,smoothstep(densitya,densityb,id*w*s + w*0.5));\n    \n        \n        //d = min(d,length(fruv - rp*(0.4 - 0.3*smoothstep(2.,4.,s)))/s);\n        \n        if(r.y < mix(density,den,1.) + sin(r.y*53513.)*0.0){\n        \td = max(d, -(abs(fruv) - max(rp,0.5)*0.2)/s);\n        }\n        \n    }\n    seed++;\n    \n    \n    return d;\n    \n}\n\nfloat bspline( in vec2 coords )\n{\n    float id = floor(mod(frame/period,2.));\n    seg = floor(frame/period/2. );\n    \n    vec2 roll = r12(seg);\n    \n    coords *= rot(-pi*roll.x*0.1);\n \t\n    vec2 oc = coords;\n    \n    float t = coords.x*float(cnt)*1. + 1.0;\n    float[cnt] cp;\n    \n    float res = 0.;\n \n    float amp = 0.03;\n \n    vec4 na = valueNoise(vec2(t*4. + seed,0),1.3);\n    vec4 nb = valueNoise(vec2(t*19. + seed,0),1.3);\n     \n    amp += (na.x*0.7 - nb.x*0.01)*pow(roll.y,4.);\n    \n    t += na.x*0.5;\n    \n    for(float i = 0.; i < float(cnt); i++){\n    \tint idx = int(i);\n        \n        cp[idx] = r11(i + seed)*amp;\n        \n        \n        res += cp[idx] * N_i_3(t, i);\n    }\n    \n    //res -= smoothstep(0.,1.,t*0.12)*0.5;\n    \n    res -= max(smoothstep(0.,1.,guv.x*0.4 + 0.1),0.);\n    \n    res += max(smoothstep(0.,1.,-guv.x*0.27),0.);\n    \n    //res -= clamp(0.,1.,guv.x);\n    //res -= smoothstep(0.,1.,guv.x*1.42)*0.5;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n    //res += sin(t + cos(t*2.)*0.01)*0.07;\n    \n\n    float v = res - coords.y;\n\n    float slope = dFdx(v) / dFdx(coords.x);\n    float d = abs(v)/length(vec2(slope, -1.0)); \n    \n    d = max(d,-coords.x - 0.2);\n    d = max(d,coords.x - 0.7);\n    \n    return d;\n}\n\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    t *= 6.;\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n ", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED (1./1.)\n\n#define pointa 2.\n#define pointb 3.\n\n#define period 500.0\n\n#define R (iResolution.xy)\n// 0 replace\n// 1 multiply    \n// 2 overlay\n// 3 darken\n// 4 burn\n// 5 linear burn\n// 6 color dodge\n// 7 exclusion \n// 8 subtract \n// 9 linear light\n// 10 screen\n\n\n\n\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rmod(a,uv,md,amt) max(a, -abs(mod(atan((uv).y,(uv).x),md*pi) - md*pi*0.5) + md*pi*amt)\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + (e)))\n\nfloat r11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 r12(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 r22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    n = normalize(n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(99.);\n    }\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat sdBox( in vec2 p, in vec2 q )\n{\n    p = abs(p) - q;\n    return max(p.y,p.x);\n}\nfloat sdBoxRound( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdBox( in vec3 p, in vec3 q )\n{\n    p = abs(p) - q;\n    return max(p.y,max(p.x,p.z));\n}\n\n\nfloat sdLine(vec2 p, vec2 A, vec2 B, float bally){\n    vec2 AB = B - A;\n    \n    float angle = atan(AB.y, AB.x);\n    \n    vec2 n = normalize(vec2(sin(-angle),cos(-angle)));\n\n    float d = dot(p - B,n);\n    \n    d = abs(d);\n    if(bool(bally)){\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    } else {\n        d = max(d,dot(p-A,n*rot(0.5*pi)));\n        d = max(d,-dot(p-B,n*rot(0.5*pi)));\n        /*\n        if(dot(p - A,AB) < 0.)\n            d = length(p - A);\n        if(dot(p - B,AB) > 0.)\n            d = length(p - B);\n    \t*/\n        \n    }\n    \n    \n    return d;\n}\n\n\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i < t < i+1, else return 0\n    return step(i, t) * step(t,i+1.0);\n}\n\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.) * (i + 2. - t);\n}\n\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i +1.) * (i + 3.0 - t) / 2.0;\n}\n\n// from iq\nfloat sdSine( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n\n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<24; i++ ) // 24 bit precision\n    {\n        float x = 0.5*(xa+xb);\n        float y = x-p.x+b*c*sin(x)*(p.y-b*c*cos(x));\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nfloat sdPolygon( in vec2[4] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=4-1; i<4; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdTri(  vec2 p, float s )\n{\n    //p.y -= s*0.75;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th, float edging)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    float dist = length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n\t\n    \n    dist = max(dist, -dot(p - a*1. - vec2(th*edging,0.),normalize(vec2(1,-1.))));\n    \n    \n    dist = max(dist, dot(p - b*1. + vec2(th*edging,0.),normalize(vec2(1,-1.))));\n    \n\treturn dist;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n    \n// unsigned distance to a quadratic bezier\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    \n    return sqrt( res );\n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv, float fov){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + (right*uv.x + up*uv.y)*fov);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 178, 178, 235], [236, 236, 269, 269, 798], [799, 799, 817, 817, 1053], [1057, 1057, 1087, 1087, 1196], [1199, 1199, 1248, 1248, 5190]], "test": "untested"}
{"id": "3dyfDc", "name": "Game of Life Canvas", "author": "TheNosiriN", "description": "I use this for my wallpaper.\nWhat you can do:\nuse the camera buffer in BufferA iChannel1,\nset xflip to true,\nface the camera while looking at the screen.", "tags": ["procedural", "conway", "wallpaper", "gol"], "likes": 4, "viewed": 437, "published": 3, "date": "1608065953", "time_retrieved": "2024-07-30T20:30:11.563422", "image_code": "#define RES iResolution.xy\n#define COORDS gl_FragCoord.xy\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = COORDS/RES;\n    \n    \n    fragColor = texture(iChannel0, uv);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Made by TheNosiriN\n/* http://vexorian.com/2015/05/cloudy-conway.html */\n\n\n#define RES iResolution.xy\n#define COORDS gl_FragCoord.xy\n#define UV (gl_FragCoord.xy/iResolution.xy)\n\nconst bool xflip = false;\n\n\nvec4 get4(vec2 p){\n    return texture(iChannel0, (COORDS+p) / iResolution.xy);\n}\n\n\nfloat get(int x, int y){\n    return get4(vec2(x, y)).a;\n}\n\n\nvec3 getColor(){\n    vec2 c = xflip ? vec2(RES.x-COORDS.x, COORDS.y) : COORDS;\n    return kuwaharaFiltering(iChannel1, c, RES, 5).rgb;//texture(iChannel1, UV).rgb;\n}\n\n\n\nvec4 evaluate(float sum)\n{\n    vec4 cell = get4(nosiri2);\n    float wasAlive = cell.w;\n    float has3 = step(abs(sum - 3.0), 0.1);\n    float has2 = step(abs(sum - 2.0), 0.1);\n    float isAlive = min(1.0, has3 + has2 * wasAlive);\n    float justDied = (1.0-isAlive) * wasAlive;\n    float afterGlow = cell.z;\n    \n    float r = max(afterGlow * nosiri, justDied);\n    \n    \n    vec3 screen = pow(getColor(), vec3(2.0));\n    \n    /*vec3 cellColor = vec3(0.3, 1.0, 1.0);\n    vec3 glowColor = vec3(1.0, 0.3, 1.0);\n    vec3 traceColor = vec3(1.0, 1.0, 0.0);\n    \n    return vec4(\n        r * pow(\n            cellColor,\n            vec3((1.0-r) * (1.0-isAlive)) * mix(glowColor, 1.0-traceColor, r*2.0) * 100.0\n        ), isAlive\n    );*/\n    return vec4(\n        r * pow(\n            mix(vec3(0.3, 0.7, 1.0), screen, pow(r, 20.0)), vec3(0.2)\n        ), isAlive\n    );\n}\n\n\n\n#define R (iResolution.xy)\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord == vec2(0.5,0.5)){ fragColor.a=R.x; return; }\n    vec4 pc = T(vec2(0,0));\n    if (R.x!=pc.a){ fragColor = vec4(0); return; }\n    \n    float sum = \n    get(-1, -1) + get(-1, 0) +\n    get(-1,  1) + get(0, -1) +\n    get( 0,  1) + get(1, -1) +\n    get( 1,  0) + get(1, 1);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = COORDS/RES;\n    \n    \n    float inputSize = 10.0;//min(RES.x, RES.y) * 0.05;\n    if (distance(iMouse.xy, COORDS) < inputSize) {\n        sum = 3.0;\n    }\n    \n    float noise = perlin_noise(vec3(COORDS * 0.1, iTime*0.1)) * 0.5 + 0.5;\n    float lim = 0.65;\n    \n    if (noise > lim && noise < lim+0.01){\n        sum = 3.0;\n    }\n    \n\n    fragColor = evaluate(sum);\n}\n", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\n// https://www.shadertoy.com/view/4tXyWN\nuint hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return n;\n}\n\nconst float nosiri = 0.99;\n\n\n\n// https://www.shadertoy.com/view/MsXSz4\nvec4 kuwaharaFiltering(sampler2D channel, vec2 coords, vec2 resolution, int radius)\n{\n     vec2 src_size = vec2 (1.0 / resolution.x, 1.0 / resolution.y);\n     vec2 uv = coords.xy/resolution.xy;\n     float n = float((radius + 1) * (radius + 1));\n     int i; \n\t int j;\n     vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n     vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n     vec3 c;\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(channel, uv + vec2(i,j) * src_size).rgb;\n             m0 += c;\n             s0 += c * c;\n         }\n     }\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(channel, uv + vec2(i,j) * src_size).rgb;\n             m1 += c;\n             s1 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(channel, uv + vec2(i,j) * src_size).rgb;\n             m2 += c;\n             s2 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(channel, uv + vec2(i,j) * src_size).rgb;\n             m3 += c;\n             s3 += c * c;\n         }\n     }\n\n     \n     vec4 finalCol = vec4(0.0);\n     \n     float min_sigma2 = 1e+2;\n     m0 /= n;\n     s0 = abs(s0 / n - m0 * m0);\n\n     float sigma2 = s0.r + s0.g + s0.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         finalCol = vec4(m0, 1.0);\n     }\n\n     m1 /= n;\n     s1 = abs(s1 / n - m1 * m1);\n\n     sigma2 = s1.r + s1.g + s1.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         finalCol = vec4(m1, 1.0);\n     }\n\n     m2 /= n;\n     s2 = abs(s2 / n - m2 * m2);\n\n     sigma2 = s2.r + s2.g + s2.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         finalCol = vec4(m2, 1.0);\n     }\n\n     m3 /= n;\n     s3 = abs(s3 / n - m3 * m3);\n\n     sigma2 = s3.r + s3.g + s3.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         finalCol = vec4(m3, 1.0);\n     }\n     \n     return finalCol;\n}\n\nconst vec2 nosiri2 = vec2(0.0);", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 118, 118, 196]], "test": "untested"}
{"id": "3sGfDc", "name": "Sarti Dodecic with Complex Step", "author": "mla", "description": "Sarti Dodecic, drawn with \"complex step\" - evaluate function for complex parameter f(x+ih) = f(x)+ihf'(h)+O(h^2)\nSimilar idea to using \"dual numbers\".\n\n[url]https://nhigham.com/2020/10/06/what-is-the-complex-step-approximation/[/url]", "tags": ["dualnumber", "sarti", "dodecic", "complexstep"], "likes": 8, "viewed": 479, "published": 3, "date": "1608065654", "time_retrieved": "2024-07-30T20:30:12.442073", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// The Sarti Dodecic Surface, raymarched using the implicit equation as SDF,\n// adjusted by the gradient, computed numerically either in the usual way,\n// or with an imaginary delta, or using dual numbers.\n//\n// Good explanation from Nick Higham:\n// https://nhigham.com/2020/10/06/what-is-the-complex-step-approximation/\n//\n// Fast it isn't, but the implicit function is quite complex.\n//\n// Matthew Arcus, mla, 2020.\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// <left>/<right>: fog distance or clip radius\n// c: clip at clipradius sphere\n// f: fog\n// i: apply inversion\n// l: light transform\n// r: autorotation\n// s: soft shadows\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat AA = 1.0;\n\n#define COMPLEXSTEP\n//#define DUAL\n\nint maxsteps = 200;\nfloat maxdist = 25.0;\nfloat precis = 0.0005;\n\nbool dorotate = true; // Autorotate\nbool doclipradius = false;\nfloat clipradius = 3.75;\n\n// Definition of basic numeric type & multiplication.\n// Addition, subtraction & multiplication by a scalar\n// are the same as for float or vec2.\n#if !defined COMPLEXSTEP\n#define T float\nT cmul(T z, T w) { return z*w; }\n#else\n#define T vec2\nT cmul(T z, T w) {\n#if defined DUAL\n  return vec2(z.x*w.x,z.x*w.y+z.y*w.x); // Dual numbers\n#else\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x); // Complex numbers\n#endif\n}\n#endif\n\nT cmul(T z, T w, T v) {\n  return cmul(z,cmul(w,v));\n}\nT cmul(T z, T w, T u, T v) {\n  return cmul(cmul(z,w),cmul(u,v));\n}\n\n// I probably lifted this from Knighty's Fragmentarium shader.\nT sarti12(T x, T y, T z, T w){\n  T x2 = cmul(x,x), y2 = cmul(y,y), z2 = cmul(z,z), w2 = cmul(w,w);\n  T x4 = cmul(x2,x2), y4 = cmul(y2,y2), z4 = cmul(z2,z2), w4 = cmul(w2,w2);\n  T l1 = x4+y4+z4+w4;\n  T l2 = cmul(x2,y2)+cmul(z2,w2);\n  T l3 = cmul(x2,z2)+cmul(y2,w2);\n  T l4 = cmul(y2,z2)+cmul(x2,w2);\n  T l5 = cmul(cmul(x,y),cmul(z,w));\n  T s10 = cmul(l1,cmul(l2,l3)+cmul(l2,l4)+cmul(l3,l4));\n  T s11 = cmul(cmul(l1,l1),l2+l3+l4);\n  T s12=cmul(l1,cmul(l2,l2)+cmul(l3,l3)+cmul(l4,l4));\n  T s51=cmul(cmul(l5,l5),l2+l3+l4);\n  T s234=cmul(l2,l2,l2)+cmul(l3,l3,l3)+cmul(l4,l4,l4);\n  T s23p=cmul(l2,l2+l3,l3), s23m=cmul(l2,l2-l3,l3); \n  T s34p=cmul(l3,l3+l4,l4), s34m=cmul(l3,l3-l4,l4); \n  T s42p=cmul(l4,l4+l2,l2), s42m=cmul(l4,l4-l2,l2);\n  T Q12=x2+y2+z2+w2; Q12=cmul(Q12,Q12,Q12); Q12=cmul(Q12,Q12);\n  T S12=33.0*sqrt(5.0)*(s23m+s34m+s42m)+19.0*(s23p+s34p+s42p)+10.0*s234-14.0*s10+2.0*s11-6.0*s12-352.0*s51+336.0*cmul(l5,l5,l1)+48.0*cmul(l2,l3,l4);\n  return 22.0*Q12-243.0*S12;\n}\n\n// Another surface most excellent\n// The Kummer Surface. https://mathworld.wolfram.com/KummerSurface.html\nfloat mu2 = 1.0;\n\nT kummer(T x, T y, T z, T w) {\n  float K = 1.414213562;\n  T p = w-z-K*x;\n  T q = w-z+K*x;\n  T r = w+z+K*y;\n  T s = w+z-K*y;\n  T t = cmul(x,x)+cmul(y,y)+cmul(z,z)-mu2*cmul(w,w);\n  float lambda = (3.0*mu2-1.0)/(3.0-mu2);\n  return cmul(t,t) - lambda*cmul(cmul(p,q),cmul(r,s));\n}\n\nT surface(T x, T y, T z, T w){\n  //return kummer(x,y,z,w);\n  return sarti12(x,y,z,w);\n}\n\n#if defined COMPLEXSTEP\nvec4 complexstep(vec3 p) {\n  float h = 1e-20; // Note the tiny step size!\n  float x = p.x, y = p.y, z = p.z, w = 1.0;\n  vec2 tx = surface(vec2(x,h),vec2(y,0),vec2(z,0),vec2(1,0));\n  vec2 ty = surface(vec2(x,0),vec2(y,h),vec2(z,0),vec2(1,0));\n  vec2 tz = surface(vec2(x,0),vec2(y,0),vec2(z,h),vec2(1,0));\n  return vec4(vec3(tx.y,ty.y,tz.y)/h,tx.x);\n}\n#else\nfloat surface(vec3 p) {\n  return surface(p.x,p.y,p.z,1.0);\n}\n\nvec3 grad(vec3 p) {\n  float eps = 1e-3;\n  vec2 e = vec2(0,eps);\n  return vec3(surface(p+e.yxx)-surface(p-e.yxx),\n              surface(p+e.xyx)-surface(p-e.xyx),\n              surface(p+e.xxy)-surface(p-e.xxy))/(2.0*eps);\n}\n#endif\n\nbool doinvert = false;\nfloat eval(vec3 p, out vec3 n, out int type) {\n  float k = 1.0;\n  if (doinvert) {\n    k = 1.0/dot(p,p);\n    p *= k;\n  }\n#if !defined COMPLEXSTEP\n  n = grad(p);\n  float d = surface(p)/length(n); // Scaled distance\n#else\n  vec4 t = complexstep(p);\n  float d = t.w/length(t.xyz);\n  n = t.xyz;\n#endif\n  type = 0;\n  if (doclipradius && !doinvert) {\n    float d1 = length(p)-clipradius;\n    if (d1 > d) { type = 1; n = p; d = d1; }\n  }\n  return d/k;\n}\n\nfloat eval(vec3 p) { int type; vec3 n; return eval(p,n,type); }\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.1;\n  for(int i = 0; i < maxsteps; i++) {\n    //assert(i < 50);\n    vec3 p = ro + t*rd;\n    float d = eval(p);\n    //d = min(d,max(0.5,0.1*t));\n    //d *= 0.8;\n    //d /= (1.0+0.2*d);\n    float k = doinvert ? 0.5 : 1.0;\n    t += k*d;\n    if (t < 0.0 || t > maxdist || abs(d) < t*precis) break;\n  }\n  return t;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    p.xz = -rotate(p.xz,iTime*0.15);\n  }\n  return p;\n}\n\n// softshadow from iq.\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax, float w) {\n  float t = mint;\n  float res = 1.0;\n  for (int i = 0; i < 200; i++) {\n    float h = eval(ro + t*rd);\n    res = min(res, h/(w*t));\n    t += clamp(h, 0.01*t, max(0.5,0.1*t));\n    if (res < -1.0 || t > tmax) break;\n  }\n  res = max(res,-1.0); // clamp to [-1,1]\n  res = 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n  return res;\n}\n\nvec2 octamap(vec3 p) {\n  // Like a cube map but to an octahedron.\n  // Each triangular face uses half the texture.\n  int parity = 0; //int(p.z < 0.0);\n  p = abs(p);\n  p /= dot(p,vec3(1)); // Plane x+y+z = 1\n  return parity == 0 ? p.xy : 1.0-p.yx; // Flip in x+y = 1\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  dorotate = !key(CHAR_R);\n  doclipradius = key(CHAR_C);\n  doinvert = key(CHAR_I);\n  float dscale = exp(0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT)));\n  maxdist *= dscale;\n  clipradius *= dscale;\n  float camera = 5.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  maxdist = max(maxdist,2.0*camera); // Ensure maxdist is sensible.\n  vec3 ro = vec3(0,0,-camera);\n  ro = transform(ro);\n  vec3 light = vec3(1,2,-3);\n  if (!key(CHAR_L)) light = transform(light);\n  vec3 aacol = vec3(0);\n  mu2 = 1.0/3.0+2.5-2.5*cos(0.2*iTime); // For Kummer surface\n  float time = iTime; // For inlining suppression\n  for (float i = 0.0; i < max(-time,AA); i++) {\n    for (float j = 0.0; j < max(-time,AA); j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 rd = vec3(uv,2);\n      rd = transform(rd);\n      rd = normalize(rd);\n      int type = 0;\n      float t = march(ro,rd);\n      vec3 bgcol = vec3(0.01);\n      vec3 col = bgcol;\n      if (t > 0.0 && t < maxdist) {\n        vec3 p = ro+t*rd;\n        // Sharp edge between clip region and surface means\n        // sometimes we get the wrong normal.\n        vec3 n; int type;\n        eval(p,n,type); // Re-evaluate for normal and type\n        if (type == 1 && dot(p,rd) <= 0.0) n = p;\n        else if (type == 2 && p.x < 0.0) n = vec3(-1,0,0); //Huh?\n        n = normalize(n);\n        col = vec3(1);\n        //col = texture(iChannel0,octamap(n)).rgb;\n        //col *= dot(vec3(1),texture(iChannel0,octamap(n)).rgb);\n        if (type > 0) col = vec3(0.1);\n        float ambient = 0.1;\n        vec3 lightdir = normalize(light); // Light at infinity\n        float diffuse = max(0.0,dot(n,lightdir));\n        if (key(CHAR_S)) diffuse *= softshadow(p,lightdir,0.01,4.0*max(1.0,length(p)),0.1);\n        col *= ambient+diffuse;\n        float fog = key(CHAR_F) ? 0.0 : t/maxdist;\n        col = mix(col,bgcol,fog);\n      }\n      aacol += col;\n    }\n  }\n  aacol /= float(AA*AA);\n  aacol = pow(aacol,vec3(0.4545)); // gamma correction\n  if (check) aacol.r = 1.0;\n  fragColor = vec4(aacol,1);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\nbool check = false;\nvoid assert(bool b) {\n  if (!b) check = true;\n}\n\nconst float PI = 3.14159;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\n", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1439, 1439, 1462, 1462, 1492], [1493, 1493, 1521, 1521, 1559], [1561, 1624, 1654, 1654, 2598], [2724, 2724, 2754, 2754, 2999], [3001, 3001, 3031, 3059, 3088], [3787, 3787, 3833, 3833, 4232], [4234, 4234, 4254, 4254, 4297], [4299, 4299, 4330, 4330, 4655], [4657, 4657, 4693, 4693, 4745], [4747, 4747, 4774, 4774, 5064], [5066, 5089, 5158, 5158, 5491], [5493, 5493, 5515, 5607, 5760], [5762, 5762, 5814, 5814, 7895]], "test": "untested"}
{"id": "WdyfDc", "name": "River Flight (optimized)", "author": "jarble", "description": "I edited dr2's [url=https://www.shadertoy.com/view/4sSXDG]\"River Flight\" shader[/url] to improve its performance. The raymarching precision decreases slightly with each step, so the framerate is improved.", "tags": ["raymarching", "landscape", "aircraft"], "likes": 9, "viewed": 496, "published": 3, "date": "1608064689", "time_retrieved": "2024-07-30T20:30:13.461348", "image_code": "// \"River Flight\" by dr2 - 2014\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  vec2 ff = f * f;\n  vec2 u = ff * (3. - 2. * f);\n  vec2 uu = 30. * ff * (ff - 2. * f + 1.);\n  vec4 h = Hashv4f (dot (i, cHashA3.xy));\n  return vec3 (h.x + (h.y - h.x) * u.x + (h.z - h.x) * u.y +\n     (h.x - h.y - h.z + h.w) * u.x * u.y, uu * (vec2 (h.y - h.x, h.z - h.x) +\n     (h.x - h.y - h.z + h.w) * u.yx));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat PrCapsDf (vec3 p, vec2 b)\n{\n  return length (p - vec3 (0., 0., b.x * clamp (p.z / b.x, -1., 1.))) - b.y;\n}\n\nfloat PrCylDf (vec3 p, vec2 b)\n{\n  return max (length (p.xy) - b.x, abs (p.z) - b.y);\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nint idObj;\nmat3 flyerMat;\nvec3 flyerPos, engPos, qHit, qHitTransObj, sunDir, sunCol;\nvec2 trkOffset;\nfloat szFac, wSpan, tCur;\nconst float dstFar = 400.;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (24. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     19. * sin (0.0032 * t) + 100. * trkOffset.x, 0., t);\n}\n\nfloat GrndHt (vec2 p, int hiRes)\n{\n  const vec2 vRot = vec2 (1.4624, 1.6721);\n  vec2 q = p * 0.06;\n  float w = 0.75 * Noisefv2 (0.25 * q) + 0.15;\n  w *= 36. * w;\n  vec2 vyz = vec2 (0.);\n  float ht = 0.;\n  for (int j = 0; j < 10; j ++) {\n    vec3 v = Noisev3v2 (q);\n    vyz += v.yz;\n    ht += w * v.x / (1. + dot (vyz, vyz));\n    if (j == 4) {\n      if (hiRes == 0) break;\n    }\n    w *= -0.37;      \n    q *= mat2 (vRot.x, vRot.y, - vRot.y, vRot.x);\n  }\n  vec3 pt = TrackPath (p.y);\n  pt.y -= 2.;\n  float g = smoothstep (1.5, 4.5, sqrt (abs (p.x - pt.x)));\n  return min (ht, pt.y * (1. - g) + ht * g);\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz, 1);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy, 1), e.x,\n     ht - GrndHt (p.xz + e.yx, 1)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.6, 0.7, 0.7), gCol2 = vec3 (0.2, 0.1, 0.1),\n     gCol3 = vec3 (0.4, 0.3, 0.3), gCol4 = vec3 (0.1, 0.2, 0.1),\n     gCol5 = vec3 (0.7, 0.7, 0.8), gCol6 = vec3 (0.05, 0.3, 0.03),\n     gCol7 = vec3 (0.1, 0.08, 0.);\n  vec2 q = p.xz;\n  float f, d;\n  float cSpec = 0.;\n  f = 0.5 * (clamp (Noisefv2 (0.1 * q), 0., 1.) +\n      0.8 * Noisefv2 (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n  vec3 col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n  if (n.y < 0.5) {\n    f = 0.4 * (Noisefv2 (0.4 * q + vec2 (0., 0.57 * p.y)) +\n       0.5 * Noisefv2 (6. * q));\n    d = 4. * (0.5 - n.y);\n    col = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n    cSpec += 0.1;\n  }\n  if (p.y > 22.) {\n    if (n.y > 0.25) {\n      f = clamp (0.07 * (p.y - 22. - Noisefv2 (0.2 * q) * 15.), 0., 1.);\n      col = mix (col, gCol5, f);\n      cSpec += f;\n    }\n  } else {\n    if (n.y > 0.45) {\n      vec3 c = (n.y - 0.3) * (gCol6 * vec3 (Noisefv2 (0.4 * q),\n         Noisefv2 (0.34 * q), Noisefv2 (0.38 * q)) + vec3 (0.02, 0.1, 0.02));\n      col = mix (col, c, smoothstep (0.45, 0.65, n.y) *\n         (1. - smoothstep (15., 22., p.y - 1.5 + 1.5 * Noisefv2 (0.2 * q))));\n    }\n    if (p.y < 0.65 && n.y > 0.4) {\n      d = n.y - 0.4;\n      col = mix (col, d * d + gCol7, 2. * clamp ((0.65 - p.y -\n         0.35 * (Noisefv2 (0.4 * q) + 0.5 * Noisefv2 (0.8 * q) +\n         0.25 * Noisefv2 (1.6 * q))), 0., 0.3));\n      cSpec += 0.1;\n    }\n  }\n  return vec4 (col, cSpec);\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  float dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz, 0);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.15, 0.4 * h) + 0.008 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 10; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz, 0));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.1;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = 0.2 * wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x);\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  float ht = WaterHt (p);\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x, ht - WaterHt (p + e.yyx)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.15, 0.2, 0.65);\n  vec3 col;\n  col = sbCol + 0.2 * sunCol * pow (1. - max (rd.y, 0.), 5.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  const float skyHt = 200.;\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 0.5 * tCur;\n    vec2 p = 0.01 * (rd.xz * (skyHt - ro.y) / rd.y + ro.xz);\n    float w = 0.65;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.3;\n    }\n    cloudFac = clamp (5. * (f - 0.5) * rd.y - 0.1, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + sunCol * (0.35 * pow (s, 6.) +\n     0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (0.85), cloudFac);\n  return col;\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.01;\n  float eps = 0.001;\n  for (int i = 0; i < 80; i++) {\n    vec3 p = ro + rd * d;\n    float h = p.y - GrndHt (p.xz, 0);\n    sh = min (sh, 20. * h / d);\n    d += 0.5;\n    if (h < eps*(1.0+d)) break;\n    eps *= 1.02;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nstruct WingParm\n{\n  float span, sRad, trans, thck, leCut, leRad;\n};\n\nfloat WingDf (vec3 p, WingParm wg)\n{\n  vec2 q = p.yz;\n  float w = max (length (q - vec2 (wg.sRad, 0.)),\n     length (q + vec2 (wg.sRad, 0.)));\n  w = max (max (w - wg.thck, abs (p.x - wg.trans) - wg.span),\n     p.z - wg.leCut);\n  return min (w, max (length (q - vec2 (0., wg.leCut)) - wg.leRad,\n     abs (p.x - wg.trans) - wg.span));\n}\n\nfloat PropelDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  dHit /= szFac;\n  p /= szFac;\n  q = p;\n  q.x = abs (q.x);\n  q -= engPos;\n  d = PrCylDf (q - vec3 (0., 0., 3.65), vec2 (1.9, 0.05));\n  if (d < dHit) {\n    dHit = d;\n    qHitTransObj = q;\n  }\n  return dHit * szFac;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = PropelDf (flyerMat * (p - flyerPos), dHit);\n  return dHit;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol*(1.0+dHit) || dHit > dstFar) break;\n    dTol *= 1.01;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dHit)\n{\n  vec3 q;\n  WingParm wg;\n  float d, wr, ws, cLen;\n  const float wSweep = 0.2;\n  const float fusLen = 11.;\n  const float taPos = 12.5;\n  dHit /= szFac;\n  p /= szFac;\n  q = p;\n  wr = q.z / fusLen;\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.045 + 0.08 * wr, 0.),\n     fusLen * vec2 (0.46, 0.11));\n  if (d < dHit) {\n    dHit = d;  idObj = 1;  qHit = q;\n  }\n  d = PrCapsDf (q - fusLen * vec3 (0., 0., -0.32),\n     fusLen * vec2 (1., 0.15 - 0.051 * wr * wr));\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 2;  qHit = q;\n  }\n  ws = wSweep * abs (p.x) / wSpan;\n  q = p + vec3 (0., 0.054 * fusLen - 6. * ws, 12. * ws);\n  wg = WingParm (wSpan, 13.7, 0., 14., 1.72, 0.195);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.2) {\n    dHit = SmoothMin (dHit, d, 0.2);  idObj = 3;  qHit = q;\n   }\n  q = p + vec3 (0., -0.1 - 6. * ws, taPos + 12. * ws);\n  wg = WingParm (0.4 * wSpan, 6.8, 0., 7., 1.2, 0.095);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 4;  qHit = q;\n  }\n  ws = wSweep * abs (p.y) / wSpan;\n  q = p.yxz + vec3 (-0.2, 0., taPos + 12. * ws);\n  wg = WingParm (0.15 * wSpan, 6.8, 2.2, 7., 1.2, 0.095);\n  d = WingDf (q, wg);\n  if (d < dHit + 0.1) {\n    dHit = SmoothMin (dHit, d, 0.1);  idObj = 5;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  cLen = 3.5;\n  wr = q.z / cLen;\n  d = PrCylDf (q - engPos, cLen * vec2 (0.2  - 0.07 * wr * wr, 1.));\n  float d2 = PrCylDf (q - engPos, cLen * vec2 (0.04, 1.02));\n  d = max (d, - d2);\n  if (d < dHit) {\n    dHit = d;  idObj = 6;  qHit = q;\n  }\n  q = p;\n  q.x = abs (q.x);\n  d = PrConeDf (q - engPos - vec3 (0., 0., 4.2), vec3 (0.8, 0.6, 0.7));\n  if (d < dHit) {\n    dHit = d;  idObj = 7;  qHit = q;\n  }\n  q = p;\n  cLen = 2.8;\n  q.z += wSweep * wSpan - 0.025 * cLen;\n  q.x = abs (q.x);\n  wr = q.z / cLen;\n  d = PrCapsDf (q - vec3 (wSpan + 0.1, 0.5 * wSweep * wSpan - 0.6, -0.5),\n     cLen * vec2 (1., 0.15 - 0.055 * wr * wr));\n  if (d < dHit) {\n    dHit = d;  idObj = 8;  qHit = q;\n  }\n  return 0.8 * dHit * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = FlyerDf (flyerMat * (p - flyerPos), dHit);\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol*(1.0+dHit) || dHit > dstFar) break;\n    dTol *= 1.01;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  float v0 = ObjDf (p + e.xxx);\n  float v1 = ObjDf (p + e.xyy);\n  float v2 = ObjDf (p + e.yxy);\n  float v3 = ObjDf (p + e.yyx);\n  return normalize (vec3 (v0 - v1 - v2 - v3) + 2. * vec3 (v1, v2, v3));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float dTol = 0.01;\n  float sh = 1.;\n  float d = 0.07 * szFac;\n  for (int i = 0; i < 50; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.07 * szFac;\n    if (h < dTol*(1.0+d)) break;\n    dTol *= 1.01;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjCol (vec3 p, vec3 n)\n{\n  vec3 bCol = vec3 (0.8, 0.8, 0.85), wCol = vec3 (0.3, 0.3, 0.7),\n     tCol = vec3 (0.9, 0.7, 0.), uCol = vec3 (0.9, 0.1, 0.);\n  float cFac = 1.;\n  if (idObj >= 3 && idObj <= 5) {\n    float s1, s2;\n    if (idObj == 3) {\n      s1 = 2.2;  s2 = 6.;\n    } else if (idObj == 4) {\n      s1 = 1.2;  s2 = 1.7;\n    } else if (idObj == 5) {\n      s1 = 1.;  s2 = 1.;\n    }\n    if (abs (qHit.x) > s2 - 0.03)\n       cFac = 1. - 0.9 * SmoothBump (- 0.08, 0.08, 0.02, qHit.z + s1);\n    if (qHit.z < - s1)\n       cFac = 1. - 0.9 * SmoothBump (- 0.05, 0.05, 0.02, abs (qHit.x) - s2);\n  }\n  vec3 col;\n  vec3 nn;\n  if (idObj >= 1 && idObj <= 5) nn = flyerMat * n;\n  if (idObj == 1 || idObj == 2) {\n    col = mix (uCol, bCol, 1. - smoothstep (-0.6, 0., nn.y));\n    if (idObj == 2 && nn.y < 0.)\n       col = mix (bCol, wCol, SmoothBump (-0.8, 0.8, 0.3, qHit.z + 0.28));         \n  } else if (idObj == 3 || idObj == 4) {\n    col = mix (bCol, wCol, SmoothBump (-0.8, 0.8, 0.3, qHit.z));\n  } else if (idObj == 5) {\n    col = mix (bCol, tCol, SmoothBump (-0.6, 0.8, 0.3, qHit.z));\n  } else if (idObj == 6) {\n    col = bCol;\n  } else if (idObj == 7 || idObj == 8) {\n    col = tCol;\n  }\n  if (idObj == 1) {\n    if (qHit.z > 4.5 && abs (qHit.x) > 0.07) idObj = 10;\n  } else if (idObj == 2) {\n    float s = - qHit.z;\n    if (s > 0. && s < 9.) {\n      vec2 ws = vec2 (qHit.y - 0.5, mod (s + 1.5, 1.5) - 0.75);\n      ws *= ws;\n      if (dot (ws, ws) < 0.02) idObj = 10;\n    }\n  }\n  return col * cFac;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  float eps = 0.01;\n  vec4 col4;\n  vec3 objCol, col, vn;\n  float dstHit, dstGrnd, dstObj, dstPropel, f;\n  int idObjT;\n  vec3 roo = ro;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  wSpan = 12.;\n  engPos = vec3 (0.35 * wSpan, -0.2, -1.5);\n  idObj = 0;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  dstPropel = TransObjRay (ro, rd);\n  if (dstObj < dstPropel) dstPropel = dstFar;\n  float refFac = 1.;\n  if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {\n    float dw = - ro.y / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += eps * rd;\n    eps *= 1.01;\n    dstGrnd = GrndRay (ro, rd);\n    idObj = 0;\n    dstObj = ObjRay (ro, rd);\n    idObjT = idObj;\n    refFac *= 0.6;\n  }\n  bool isGrnd = false;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (ro, vn);\n    if (idObj == 10) objCol = vec3 (0.2) + 0.5 * SkyCol (ro, reflect (rd, vn));\n    float dif = max (dot (vn, sunDir), 0.);\n    col = sunCol * objCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * ObjSShadow (ro, sunDir) *\n       (dif + 0.5 * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));\n    dstHit = dstObj;\n  } else {\n    vec3 rp = ro + dstGrnd * rd;\n    if (refFac < 1.) dstHit = length (rp - roo);\n    else dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro = rp;\n      isGrnd = true;\n    } else {\n      col = refFac * SkyCol (ro, rd);\n    }\n  }\n  if (isGrnd) {\n    vn = GrndNf (ro, dstHit);\n    col4 = GrndCol (ro, vn);\n    col = col4.xyz * refFac;\n    float dif = max (dot (vn, sunDir), 0.);\n    col *= sunCol * (0.2 * (1. +\n       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +\n       max (0., dif) * GrndSShadow (ro, sunDir) *\n       (dif + col4.w * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));\n  }\n  if (dstPropel < dstFar) col = 0.7 * col + 0.1 -\n     0.04 * SmoothBump (1.5, 1.7, 0.02, length (qHitTransObj.xy));\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, refFac * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  trkOffset = vec2 (0.);\n  float zmFac = 2.7;\n  tCur = 15. * iTime + 100. * trkOffset.y;\n  sunDir = normalize (vec3 (0.9, 1., 0.4));\n  sunCol = vec3 (1., 0.9, 0.8);\n  vec3 ro, rd, vd, fpF, fpB, vDir;\n  szFac = 0.25;\n  float dt = 1.;\n  fpF = TrackPath (tCur + dt);\n  flyerPos = TrackPath (tCur);\n  fpB = TrackPath (tCur - dt);\n  vec3 vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  vec3 acc = (fpF - 2. * flyerPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  vec3 va = cross (acc, vel) / length (vel);\n  float roll = 12. * length (va);\n  if (va.y < 0.) roll *= -1.;\n  vDir = normalize (vel);\n  float cRl = cos (roll);\n  float sRl = sin (roll);\n  flyerMat = mat3 (cRl, - sRl, 0., sRl, cRl, 0., 0., 0., 1.) *\n     mat3 (vDir.z, 0., vDir.x, 0., 1., 0., - vDir.x, 0., vDir.z);\n  float vuPeriod = 500.;\n  flyerPos.y = 3. + 1.5 * sin (2.5 * tCur / vuPeriod);\n  float lookDir = 2. * mod (floor (tCur / vuPeriod), 2.) - 1.;\n  ro = TrackPath (tCur - 40. * lookDir * (1. -\n     0.8 * abs (sin (pi * mod (tCur, vuPeriod) / vuPeriod))));\n  ro.y = 3. + 0.6 * sin (0.16 * tCur / vuPeriod);\n  vd = flyerPos - ro;\n  vd.y = 0.;\n  vd = normalize (lookDir * vDir + 0.3 * normalize (vd));\n  mat3 scMat = mat3 (vd.z, 0., - vd.x, 0., 1., 0., vd);\n  rd = scMat * normalize (vec3 (uv, zmFac));\n  vec3 col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col = mix (vec3 (0.7), col, pow (max (0., 0.95 - length (uvs * uvs * uvs)), 0.3));\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfDc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[241, 241, 265, 265, 312], [314, 314, 339, 339, 518], [520, 520, 545, 545, 851], [853, 853, 878, 878, 1237], [1239, 1239, 1284, 1284, 1382], [1384, 1384, 1441, 1441, 1524], [1526, 1526, 1559, 1559, 1638], [1640, 1640, 1672, 1672, 1727], [1729, 1729, 1762, 1762, 1835], [2018, 2018, 2044, 2044, 2178], [2180, 2180, 2214, 2214, 2783], [2785, 2785, 2816, 2816, 2998], [3000, 3000, 3031, 3031, 4496], [4498, 4498, 4532, 4532, 5076], [5078, 5078, 5102, 5102, 5337], [5339, 5339, 5371, 5371, 5533], [5535, 5535, 5557, 5557, 5692], [5694, 5694, 5726, 5726, 6301], [6303, 6303, 6341, 6341, 6624], [6695, 6695, 6731, 6731, 7029], [7031, 7031, 7068, 7068, 7305], [7307, 7307, 7334, 7334, 7427], [7429, 7429, 7467, 7467, 7698], [7700, 7700, 7736, 7736, 9748], [9750, 9750, 9772, 9772, 9864], [9866, 9866, 9899, 9899, 10125], [10127, 10127, 10148, 10148, 10393], [10395, 10395, 10432, 10432, 10705], [10707, 10707, 10737, 10737, 12209], [12211, 12211, 12246, 12246, 14425], [14427, 14427, 14484, 14484, 16024]], "test": "untested"}
{"id": "WsGBDc", "name": "Multicolor pixelated spiral", "author": "z0rg", "description": "Originally done on my phone, tweaked a bit for it to sync with music.\nhttps://soundcloud.com/thomasbarrandon/we-left-home?in=thomasbarrandon/sets/up-in-the-sky", "tags": ["2d", "music", "spiral", "multicolor"], "likes": 11, "viewed": 458, "published": 3, "date": "1608061478", "time_retrieved": "2024-07-30T20:30:14.348974", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// https://youtu.be/SIYvL_-OkR8\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\n#define PI 3.14159265\n#define sat(a) clamp(a,0.,1.)\n\nfloat lenny(vec2 uv)\n{\n  return abs(uv.x)+abs(uv.y);\n}\nfloat cir(vec2 p, float r)\n{\n  return length(p)-r;\n}\nfloat loz(vec2 p, float r)\n{\n  return lenny(p)-r;\n}\n\nvec3 rdr(vec2 uv, float t)\n{\n  vec3 col;\n\n  int i = 0;\n  while (i < 7)\n  {\n    float fi = float(i);\n    int j = 0;\n    int n = 7;//min(int((fi+4.)*.5),5);\n    while (j < n)\n    {\n      float fj = float(j);\n      float a = fi*.5*t+(fj/float(n))*PI*2.\n      +texelFetch(iChannel1, ivec2(int(fj*5.), 0), 0).x;\n      float lz = loz(uv+vec2(sin(a),cos(a))*(1.+fi)*(.25+.05*sin(iTime)),mix(.1,.2, fi/7.));\n      col = mix(col, vec3(1.),1.-sat(lz*400.));\n      ++j;\n    }\n    ++i;\n  }\n  col += texture(iChannel0,uv+iTime*50.).xxx*.1;\n  col += sat(1.5+sin(uv.y*50.+t*20.))*.3*vec3(.9,.71,.54)*(1.-sat(lenny(uv*.2)));\n  col *= texelFetch(iChannel1, ivec2(0, 0), 0).x;\n  vec3 lzCol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n  col += .55*(1.-sat(lenny(uv*.1*vec2(1.,3.))))*lzCol*texelFetch(iChannel1, ivec2(55, 0), 0).x;\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  float dist = (sin(-iTime*5.+(uv.x+uv.y)*5.)*.5+1.)*0.05;//*(1.-sat(pow(length(uv)-.2,2.)));\n  vec2 dir = normalize(uv);\n  vec3 col;\n  float stp = 1./20.;\n  float t = float(int(iTime/stp))*stp*.25;\n  col.r = rdr(uv, t-.05).r;\n  col.g = rdr(uv,t).g;\n  col.b = rdr(uv,t+.05).b;\n  return col.yzx;\n}\n\nvec2 myPixel(vec2 uv, vec2 sz)\n{\n  vec2 tmp = uv / sz;\n\n  uv.x = float(int(tmp.x));\n  uv.y = float(int(tmp.y));\n  return (uv)*sz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv =( fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n  uv = myPixel(uv,vec2(0.005));\n  uv*=5.7;\n\n  vec3 col = rdr2(uv);\n  col+=rdr2(uv*r2d(.1))*.5;\n  col *= .5+1.-sat(lenny(uv*.25));\n  \n  float val = texture(iChannel2, fragCoord/iResolution.xy).x;\n  \n  col *= sat(iTime-3.);\n  //col = mix(col, vec3(1.), val*.5);\n  \n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24984, "src": "https://soundcloud.com/thomasbarrandon/we-left-home?in=thomasbarrandon/sets/up-in-the-sky", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBDc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[430, 430, 448, 448, 523], [578, 578, 600, 600, 632], [633, 633, 661, 661, 685], [686, 686, 714, 714, 737], [739, 739, 767, 767, 1565], [1567, 1567, 1587, 1587, 1884], [1886, 1886, 1918, 1918, 2017], [2020, 2020, 2077, 2077, 2439]], "test": "untested"}
{"id": "WsGBWc", "name": "Edge Detection (Sobel)", "author": "itgaz", "description": "Basic structure for running image kernels, demonstrating 'Sobel' edge detection", "tags": ["video", "edgedetection", "image"], "likes": 6, "viewed": 454, "published": 3, "date": "1608051516", "time_retrieved": "2024-07-30T20:30:15.244580", "image_code": "/*\nCopyright 2020 Gareth Francis\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, \nBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT \nSHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL \nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE \nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n// column major\nmat3 kSobelHorizontalR = mat3(1, 2, 1,\n                             0, 0, 0,\n                             -1, -2, -1);\nmat3 kSobelVerticalD = mat3(-1, 0, 1,\n                           -2, 0, 2,\n                           -1, 0, 1);\nmat3 kSobelHorizontalL = mat3(-1, -2, -1,\n                             0, 0, 0,\n                             1, 2, 1);\nmat3 kSobelVerticalU = mat3(1, 0, -1,\n                           2, 0, -2,\n                           1, 0, -1);\n\nvec4 greyScale( vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Read pixel from webcam\n    vec4 px = texture(iChannel0, uv);\n    \n    // Weighted greyscale\n    float grey = (px.r * 0.2126) + (px.g * 0.7152) + (px.b * 0.0722);\n    return vec4(grey,grey,grey,1.0);\n}\n\nfloat magPX( vec2 fragCoord ) { \n  return greyScale(fragCoord).r;\n}\n\n// Sample a 3x3 matrix of pixels, centered on fragCoord\nmat3 sample3x3(vec2 fragCoord) {\n  // Sample the image (column-major)\n  mat3 pixels = mat3(\n    magPX(fragCoord + vec2(-1,1)), magPX(fragCoord + vec2(-1,0)), magPX(fragCoord + vec2(-1,-1)),\n    magPX(fragCoord + vec2(0,1)), magPX(fragCoord + vec2(0,0)), magPX(fragCoord + vec2(0,-1)),\n    magPX(fragCoord + vec2(1,1)), magPX(fragCoord + vec2(1,0)), magPX(fragCoord + vec2(1,-1))\n  );\n  return pixels;\n}\n\n// Apply a 3x3 kernel to a pixel matrix\nmat3 kernel3x3( mat3 pixels, mat3 kernel ) {\n  // Multiply samples by matrix, componentwise (* is matrix mult)\n  return matrixCompMult(pixels, kernel);\n}\n  \n// Sum a pixel matrix\nfloat sum3x3(mat3 pixels) {\n  // Sum and return\n  return pixels[0][0] + pixels[0][1] + pixels[0][2] +\n         pixels[1][0] + pixels[1][1] + pixels[1][2] +\n         pixels[2][0] + pixels[2][1] + pixels[2][2];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sample (greyscale)\n    mat3 px = sample3x3(fragCoord);\n    \n    // Edge detect\n    mat3 edgeHR = kernel3x3(px, kSobelHorizontalR);\n    mat3 edgeVD = kernel3x3(px, kSobelVerticalD);\n    mat3 edgeHL = kernel3x3(px, kSobelHorizontalL);\n    mat3 edgeVU = kernel3x3(px, kSobelVerticalU);\n\n    // Sum pixels\n    float i = length(sum3x3(edgeHR)) + length(sum3x3(edgeVD)) + length(sum3x3(edgeHL) + length(sum3x3(edgeVU)));\n    \n    // Discard some noise\n    if( i < 0.5 ) i = 0.0;\n\n    // Output to screen\n    fragColor = vec4(i,i,i,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBWc.jpg", "access": "api", "license": "bsd-simplified", "functions": [[1761, 1761, 1795, 1845, 2098], [2100, 2100, 2131, 2131, 2167], [2169, 2225, 2257, 2294, 2627], [2629, 2669, 2713, 2779, 2822], [2826, 2848, 2875, 2895, 3058], [3060, 3060, 3117, 3143, 3657]], "test": "untested"}
{"id": "tsKfWV", "name": "Filtering effect comparison API", "author": "gwiazdorrr", "description": "Public API fork of https://www.shadertoy.com/view/wsByzh", "tags": ["filtering", "cxxswizzle"], "likes": 1, "viewed": 312, "published": 3, "date": "1608027148", "time_retrieved": "2024-07-30T20:30:16.149163", "image_code": "// Note: this code is unoptimal on purpose, zero optimizations, and demonstration only!\n\nvoid sharedGetUvAndInterp(in vec2 uv, out ivec2 uvi, out vec2 interp) {\n    uv *= iChannelResolution[0].xy;\n    uv -= 0.5;\n    interp = fract(uv);\n    uvi = ivec2(floor(uv));\n}\n\n\n#define PI 3.1415926\n\nfloat sinc(in float x) {\n\tif (x == 0.0)\n        return 1.0;\n    return sin(PI*x) / (PI*x);\n}\n\n\n\nvec3 sampleBilinear(in vec2 uv) {\n    ivec2 uvi; vec2 interp;\n    sharedGetUvAndInterp(uv, uvi, interp);\n    vec4 weights = vec4((1.0-interp.x) * (1.0-interp.y),\n                        interp.x * (1.0-interp.y),\n                        (1.0-interp.x) * interp.y,\n                        interp.x * interp.y);\n    return  texelFetch(iChannel0, uvi + ivec2(0,0),0).xyz * weights.x\n          + texelFetch(iChannel0, uvi + ivec2(1,0),0).xyz * weights.y\n          + texelFetch(iChannel0, uvi + ivec2(0,1),0).xyz * weights.z\n          + texelFetch(iChannel0, uvi + ivec2(1,1),0).xyz * weights.w;\n}\n\nvec3 sampleSinc(in vec2 uv) {\n    ivec2 uvi; vec2 interp;\n    sharedGetUvAndInterp(uv, uvi, interp);\n\n    vec3 col = vec3(0.0);\n    float weights = 0.0;\n    for (int y = -2; y <= 2; ++y) {\n        for (int x = -2; x <= 2; ++x) {\n            float effective_x = interp.x - float(x);\n            float effective_y = interp.y - float(y);\n            float window = 1.0;//sinc(effective_x / 4.0) * sinc(effective_y / 4.0);\n            float w = sinc(effective_x) * sinc(effective_y) * window;\n            col += texelFetch(iChannel0, uvi + ivec2(x,y),0).xyz * w;\n            weights += w;\n        }\n    }\n    return col / weights;\n}\n\nvec4 getBsplineWeights(in float x) {\n  \t// float w0 = 1.0/6.0 * (1.0-x) * (1.0-x) * (1.0-x);\n  \tfloat w1 = 2.0/3.0 - 0.5 * x*x * (2.0-x);\n  \tfloat w2 = 2.0/3.0 - 0.5 * (1.0-x)*(1.0-x) * (2.0-(1.0-x));\n  \tfloat w3 = 1.0/6.0 * x*x*x;\n\treturn vec4(1.0 - w3 - w1 - w2, w1, w2, w3);\n}\n\nvec3 sampleBSpline(in vec2 uv) {\n    ivec2 uvi; vec2 interp;\n    sharedGetUvAndInterp(uv, uvi, interp);\n\n    vec4 bspline_weights_x = getBsplineWeights(interp.x);\n    vec4 bspline_weights_y = getBsplineWeights(interp.y);\n    vec3 col = vec3(0.0);\n    for (int y = -1; y <= 2; ++y) {\n        for (int x = -1; x <= 2; ++x) {\n            col += texelFetch(iChannel0, uvi + ivec2(x,y),0).xyz * bspline_weights_x[x+1] * bspline_weights_y[y+1];\n        }\n    }\n    return col;\n}\n\nvec3 getBiquadraticWeights(in float x) {\n    return vec3(0.5 - x + 0.5 * x * x, x - x * x + 0.5, 0.5 * x * x);\n}\n\nvec3 sampleBiquadratic(in vec2 uv) {\n    ivec2 uvi; vec2 interp;\n    uv *= iChannelResolution[0].xy;\n    uv -= 0.5;\n    interp = uv - round(uv);\n    uvi = ivec2(round(uv));\n    \n    vec3 biquadratic_weights_x = getBiquadraticWeights(interp.x+0.5);\n    vec3 biquadratic_weights_y = getBiquadraticWeights(interp.y+0.5);\n    vec3 col = vec3(0.0);\n    \n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            col += texelFetch(iChannel0, uvi + ivec2(x,y),0).xyz \n                * biquadratic_weights_x[x+1] * biquadratic_weights_y[y+1];\n        }\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 origUV = fragCoord/iResolution.xy;\n    vec2 uv = origUV / 5.0;\n    uv += vec2(0.5, 0.48);\n    uv *= iChannelResolution[0].xy;\n    if (fract(0.15 * iTime) < 0.8)\n    \tuv = round(uv);\n    uv /= iChannelResolution[0].xy;\n    uv += vec2(sin(iTime),cos(iTime)) / 150.0 * vec2(iResolution.y/iResolution.x, 1.0);\n    vec2 phase = fract(uv * iChannelResolution[0].xy - vec2(0.5));\n\n    vec3 col = vec3(0.0);\n\n    if (origUV.x > origUV.y) {\n        if (origUV.x > 1.0 - origUV.y) {\n        \tcol = sampleSinc(uv);\n        } else {\n            col = sampleBSpline(uv);\n        }\n    } else {\n        if (origUV.x > 1.0 - origUV.y) {\n        \tcol = sampleBilinear(uv);\n        } else {\n            col = sampleBiquadratic(uv);\n        }\n    }\n    if (abs(origUV.x - origUV.y) < 0.005 || abs(origUV.x - (1.0-origUV.y)) < 0.005)\n        col = vec3(1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Sharpen and increase contrast for better demo\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0.0);\n    col += texelFetch(iChannel0, ivec2(fragCoord), 0) * 2.0;\n    col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(-1,0), 0) * -0.25;\n    col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(1,0), 0) * -0.25;\n    col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,1), 0) * -0.25;\n    col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,-1), 0) * -0.25;\n    col = pow(abs(col), vec4(1.5)) * 1.5;\n    fragColor = col;\n}\n\n", "buffer_a_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 160, 160, 265], [290, 290, 314, 314, 382], [386, 386, 419, 419, 978], [980, 980, 1009, 1009, 1608], [1610, 1610, 1646, 1702, 1889], [1891, 1891, 1923, 1923, 2363], [2365, 2365, 2405, 2405, 2477], [2479, 2479, 2515, 2515, 3078], [3080, 3080, 3136, 3186, 4097]], "test": "untested"}
{"id": "wdKfWK", "name": "EZ Blocky Image Shader", "author": "jackwitherell", "description": "I was trying to do something else and did this instead lol it might be good reference", "tags": ["webcam", "censor"], "likes": 3, "viewed": 484, "published": 3, "date": "1608008228", "time_retrieved": "2024-07-30T20:30:17.140510", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //everything other than this is boilerplate shadertoy\n    uv=((uv*30.0)-fract(uv*30.0))/30.0;\n\n    vec3 col = texture(iChannel0,uv).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 276]], "test": "untested"}
{"id": "WsKfDV", "name": "SDF to Mesh", "author": "oneshade", "description": "Mesh effect I used in my [url=https://www.shadertoy.com/view/3dVBWK]\"Underground Flythrough\"[/url] shader. I am not sure how great it is (I don't think the facets are perfectly flat) but it may be useful to someone.", "tags": ["sdf", "mesh", "mesheffect", "sdftomesh"], "likes": 12, "viewed": 749, "published": 3, "date": "1608001946", "time_retrieved": "2024-07-30T20:30:18.002207", "image_code": "/*\n\"SDF to Mesh\" by oneshade\n\nAfter watching The Art of Code's (BIgWings) video about value noise,\nI started playing around with it and designed a 3D variant. I found\nthat if I removed the smooth remapping of local coordinates I got a\ncool mesh effect. It reminds me of nimitz's \"Triangulator\" shader\n(https://www.shadertoy.com/view/lllGRr) except the facets aren't always\ntriangles and it works on more than just heightmaps. I don't think\nthe facets are always perfectly planar though (take a cube for example).\n\nAlso reminds me a lot of marching cubes.\n*/\n\n// Mesh resolution:\n#define res vec3(1.0, 1.0, 1.0)\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\nfloat mapScene(in vec3 p) {\n    return length(p) - 2.0;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nfloat mapSceneMesh(in vec3 p) {\n    vec3 cell = floor(p / res) * res;\n    vec3 local = fract(p / res);\n\n    float ldb = mapScene(cell);                           // Left, Down, Back\n    float rdb = mapScene(cell + vec3(res.x, 0.0, 0.0));   // Right, Down, Back\n    float ldf = mapScene(cell + vec3(0.0, 0.0, res.z));   // Left, Down, Front\n    float rdf = mapScene(cell + vec3(res.x, 0.0, res.z)); // Right, Down, Front\n    float lub = mapScene(cell + vec3(0.0, res.y, 0.0));   // Left, Up, Back\n    float rub = mapScene(cell + vec3(res.xy, 0.0));       // Right, Up, Back\n    float luf = mapScene(cell + vec3(0.0, res.yz));       // Left, Up, Front\n    float ruf = mapScene(cell + res);                     // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nvec3 getNormalMesh(in vec3 p) {\n    return normalize(vec3(mapSceneMesh(p + vec3(0.001, 0.0, 0.0)) - mapSceneMesh(p - vec3(0.001, 0.0, 0.0)),\n                          mapSceneMesh(p + vec3(0.0, 0.001, 0.0)) - mapSceneMesh(p - vec3(0.0, 0.001, 0.0)),\n                          mapSceneMesh(p + vec3(0.0, 0.0, 0.001)) - mapSceneMesh(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float dt = 0.0;\n\n    bool mesh = mod(floor(iTime), 2.0) == 1.0;\n\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = mapScene(p);\n        if (mesh) {\n            d = mapSceneMesh(p);\n        }\n\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            if (mesh) {\n                n = getNormalMesh(p);\n            }\n\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n\n            n.yz *= mat2(COS_15, -SIN_15, SIN_15, COS_15);\n            n.xz *= mat2(c, -s, s, c);\n\n            fragColor.rgb = hue2rgb(0.5 * p.y);\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(0.05, 0.0, abs(fract(p.x) - 0.05)) + smoothstep(0.05, 0.0, abs(fract(p.z) - 0.05)));\n            fragColor.rgb *= max(0.0, dot(n, l));\n            break;\n        }\n\n        if (d > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[807, 807, 834, 834, 864], [866, 866, 893, 893, 1200], [1202, 1202, 1233, 1233, 2189], [2191, 2191, 2222, 2222, 2553], [2555, 2555, 2610, 2610, 3816]], "test": "untested"}
{"id": "WsKBDV", "name": "paisaje- n3-2d", "author": "jorge2017a1", "description": "paisaje- n3-2d", "tags": ["paisajen32d"], "likes": 2, "viewed": 279, "published": 3, "date": "1608000754", "time_retrieved": "2024-07-30T20:30:18.897812", "image_code": "//por jorge flores p. JFP. jorge2017a1\n//recursos\n//https://iquilezles.org/articles/distfunctions2d\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{\n    //return  min(d1.x,d2.x); \n    if (d1.x<d2.x)  return d1;\n    else  return d2;\n}\n\nvec2 opS2( vec2 d1, vec2 d2 )\n{\n    if  (-d1.x<d2.x) return d1;\n    else   return d2;\n}\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{\n    if (d1.x>d2.x)\treturn d1;\n    else return d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2) {\n\treturn vec2(max(-d2.x, d1.x), 2.0);\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{vec2 q = mod(p+0.5*c,c)-0.5*c;    return  q;}\n\nfloat sdCirc(vec2 p, float r)\n{ return length(p)-r;}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;     return length(max(d,0.0)) + min(max(d.x,d.y),0.0);}\n\nvec2 BloqueGrandeLadrillo(vec2 p)\n{   \n    vec2 resp=vec2(9999.0,-1.0);\n    float b1a=sdBox(p-vec2(0.0,0.0), vec2(1.8,1.0 ) );\n    resp=vec2(b1a,-2.0);\n    return resp;\n}\n\nvec2 BloqueInferior(vec2 p)\n{   \n    vec2 resp=vec2(9999.0,-1.0);\n    float b1a=sdBox(p-vec2(0.0,-0.85), vec2(1.8,0.13 ) );\n    float b1b=sdBox(p-vec2(0.4,0.145), vec2(0.6,0.07 ) );\n    //2da escena\n    float b2a=sdBox(p-vec2(4.5,-0.85), vec2(1.8,0.13 ) );\n    //3da escena\n    float b3a=sdBox(p-vec2(8.4,-0.85), vec2(1.8,0.26 ) );\n    resp= opU2( vec2(b1a,-2.0 ), resp);\n    resp= opU2( vec2(b1b,-2.0 ), resp);\n    resp= opU2( vec2(b2a,-2.0 ), resp);\n    resp= opU2( vec2(b3a,-2.0 ), resp);\n    return resp;\n}\n\nvec2 pastogrande(vec2 p)\n{   \n    vec2 resp=vec2(9999.0,-1.0);\n    vec2 p1= rotate2d( p-vec2(0.0,-0.1), radians(180.0));\n    float st1= sdTriangleIsosceles(p1, vec2(0.6,0.6) );\n    float sc1= sdCirc(p-vec2(0.1,-0.3), 0.03);\n    float sc2= sdCirc(p-vec2(-0.1,-0.4), 0.03);\n    st1=opS(sc1, st1);\n    st1=opS(sc2, st1);\n    resp= opU2( vec2(st1,3.0 ), resp);\n    resp= opU2( vec2(sc1,0.0 ), resp);\n    resp= opU2( vec2(sc2,0.0 ), resp);\n    \n    return resp;\n}\n\n\nvec2 pastomedio(vec2 p)\n{   \n    vec2 resp=vec2(9999.0,-1.0);\n    vec2 p1= rotate2d( p-vec2(1.,-0.4), radians(180.0));\n    float st1= sdTriangleIsosceles(p1, vec2(0.3,0.3) );\n    float sc1= sdCirc(p-vec2(1.05,-0.55), 0.015);\n    float sc2= sdCirc(p-vec2(1.0,-0.52), 0.015);\n    st1=opS(sc1, st1);\n    st1=opS(sc2, st1);\n    resp= opU2( vec2(st1,3.0 ), resp);\n    resp= opU2( vec2(sc1,0.0 ), resp);\n    resp= opU2( vec2(sc2,0.0 ), resp);\n    return resp;\n}\n\n\nvec2 ArbolSimple(vec2 p)\n{   \n    vec2 resp=vec2(9999.0,-1.0);\n     float b1a=sdBox(p-vec2(-0.5,-0.55), vec2(0.02,0.15 ) );\n    float sc1= sdCirc(p-vec2(-0.5,-0.3), 0.15);\n    float sc2= sdCirc(p-vec2(-0.55,-0.3), 0.015);\n    float sc3= sdCirc(p-vec2(-0.5,-0.35), 0.015);\n    sc1=opS(sc2, sc1);\n    sc1=opS(sc3, sc1);\n    resp= opU2( vec2(b1a,25.0 ), resp);\n    resp= opU2( vec2(sc1,3.0 ), resp);\n    resp= opU2( vec2(sc2,0.0 ), resp);\n    resp= opU2( vec2(sc3,0.0 ), resp);\n    return resp;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n     float tt=mod(iTime*0.5,10.0);\n     p.x=p.x+tt;\n\n\t vec3 col = vec3(0.0);\n     //vec3 skycolor = mix( vec3(0.235, 0.737, 0.988),vec3(0.0), sin(iTime))-0.5;\n     vec3 skycolor =  vec3(0.235, 0.737, 0.988);\n     \n     col=skycolor;\n     \n    vec2 Bgl2=BloqueInferior(p);\n    vec2 Pg1= pastogrande(p);\n    vec2 Pm1= pastomedio(p);\n    \n    \n    //2da escena\n    vec2 Pg2= pastogrande(p-vec2(4.0,0.0));\n    vec2 Pm2= pastomedio(p-vec2(4.0,0.0));\n    \n    //1era escena\n    vec2 As1= ArbolSimple(p-vec2(-0.5,0.0));\n      //3era escena\n    vec2 As2= ArbolSimple(p-vec2(7.5,0.1));\n    vec2 As3= ArbolSimple(p-vec2(8.0,0.1));\n    vec2 As4= ArbolSimple(p-vec2(8.5,0.1));\n    \n    \n    vec3 colb2= HacerLadrillos(p,8.0);\n\n    vec3 colb3= getColorf(Pg1.y);\n    vec3 colb4= getColorf(Pm1.y);\n    \n    \n    vec3 colb5= getColorf(Pg2.y);\n    vec3 colb6= getColorf(Pm2.y);\n    \n    vec3 colb7= getColorf(As1.y);\n    \n    vec3 colb8= getColorf(As2.y);\n    vec3 colb9= getColorf(As3.y);\n    vec3 colb10= getColorf(As4.y);\n    \n\n    col= DibujoConBorde(p, Bgl2.x, colb2,  col);\n    col= DibujoConBorde(p, Pg1.x, colb3,  col);\n    col= DibujoConBorde(p, Pm1.x, colb4,  col);\n    \n    col= DibujoConBorde(p, Pg2.x, colb5,  col);\n    col= DibujoConBorde(p, Pm2.x, colb6,  col);\n    \n    col= DibujoConBorde(p, As1.x, colb7,  col);\n    \n    col= DibujoConBorde(p, As2.x, colb8,  col);\n    col= DibujoConBorde(p, As3.x, colb9,  col);\n    col= DibujoConBorde(p, As4.x, colb10,  col);\n    \n    \n    //col=mix(col, colb2, Bgl2.x);\n    \n    \n\nfragColor = vec4(col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{ vec3 color;  };\n    \nTObj mObj;\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.  //37 //marron o cafe\n\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n\n\nvec3 getColorf(float ii)\n{    \n\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n///--------------------------------------------\n// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 DibujoConBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);   \n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\n\nvec3 DibujoSinBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    float uWotM8 = 0.009;\n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    //colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    colOut = mix(colOut, colIn, uWotM8);\n    return mix(colOut,colIn, flm );\n}\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n///-------------------------------\n\n\nvec2 rotate2d(vec2 p, float ang)\n{\n    float c = cos(ang);float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n//vec3 HacerLadrillos( vec2 fragCoord )\nvec3 HacerLadrillos( vec2 uv, float escala )\n{\n\tuv = uv * escala; // scale for replication\n    vec3 col = vec3(0.8, 0.1, 0.1);\n    if(mod(uv.y, 2.0) < 1.0)\n    { uv.x = uv.x + 0.6; }\n    uv = uv - floor(uv)+0.01;\n    if(uv.x > 0.9 || uv.y < 0.1) \n    { col = vec3(0.0); }\n    return col;\n}\n\n", "sound_code": "vec2 mainSound( in int samp, float i )\n{ float t=fract(i/22.)*52.;\n    float b=fract(t/4.)<5./6.?120.*acos(-1.):108.*acos(-1.);\n \n \n \tvec2 c1=vec2( sin(b*t)*exp(-3.0*fract(t/2.)),sin(b*t)*exp(-5.0*fract(--t/2.)) );\n \tvec2 c2=vec2( sin(b*floor(t/4.)*(t))*exp(-2.0*fract(t*0.5+.5)));\n    vec2 c3=clamp( vec2( sin(b*floor((t+1.8)/2.)*(t))*exp(-3.0*fract(t*1.5+.5))),.2,.8);\n \tvec2 c4=vec2( sin(b*floor(t/4.)*(t)+2.0*sin(b*t*0.5))*exp(-2.0*fract(t*3.+.5)));\n    vec2 sum=c1+c2+c3-c4;\n        \n    return sum;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 278, 278, 300], [301, 301, 334, 334, 356], [357, 357, 390, 390, 411], [414, 414, 446, 477, 531], [533, 533, 564, 564, 620], [622, 622, 654, 654, 706], [708, 708, 736, 736, 775], [777, 777, 815, 815, 860], [862, 862, 893, 893, 914], [916, 916, 953, 953, 1028], [1030, 1030, 1065, 1065, 1200], [1202, 1202, 1231, 1231, 1712], [1714, 1714, 1740, 1740, 2172], [2175, 2175, 2200, 2200, 2630], [2633, 2633, 2659, 2659, 3126], [3129, 3129, 3186, 3236, 4893]], "test": "untested"}
{"id": "3dKBDV", "name": "Time varying alpha for dither", "author": "kagtag", "description": "From UE4 function ClipLODTransition", "tags": ["effect"], "likes": 1, "viewed": 333, "published": 3, "date": "1607999497", "time_retrieved": "2024-07-30T20:30:19.768484", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float DitherFactor = abs(sin(iTime*1.0));\n    \n    if (abs(DitherFactor) > .001)\n\t{\n\t\tfloat RandCos = cos(dot(floor(fragCoord), vec2(347.83451793,3343.28371963)));\n\t\tfloat RandomVal = fract(RandCos * 1000.0);\n\t\tfloat RetVal = 0.0; //(DitherFactor < 0.0) ? \n        if(DitherFactor < RandomVal)\n        {\n            RetVal = 1.0;\n        }\n\n        fragColor = vec4(RetVal);\n\t}\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 443]], "test": "untested"}
{"id": "WdVBWV", "name": "Cellular Lattice (fast version)", "author": "jarble", "description": "A modified version of Shane's [url=https://www.shadertoy.com/view/XsKXRh]\"Cellular Lattice\"[/url] shader using [url=https://www.shadertoy.com/view/XdycWy]two-pass raymarching[/url].", "tags": ["voronoi", "cell", "tile", "gyroid", "lattice"], "likes": 34, "viewed": 1014, "published": 3, "date": "1607995431", "time_retrieved": "2024-07-30T20:30:20.832639", "image_code": "/*\n\n\tCellular Lattice\n\t----------------\n\n\tStill playing around with 3D cellular tiles.\n\n\tTraversing a cellular, coral-like structure through an alien ocean ... Is anyone buying that?\n    I don't know what it is either, but it looks grotesquely interesting. :)\n\n\tIn technical terms, it's an intertwined sinusoidal lattice structure (a mutated gyroid of sorts) \n\twith a prominent cellular surface attached.\n\n    The scene was mildly inspired by IQ's Leizex demo and Tomasz Dobrowolski's Suboceanic.\n\n\n\tCellular Tiled Tunnel 2 - Shane\n\thttps://www.shadertoy.com/view/MdtSRl\n\n\trgba leizex - Inigo Quilez\n\thttp://www.pouet.net/prod.php?which=51829\n\thttps://www.youtube.com/watch?v=eJBGj8ggCXU\n\thttps://iquilezles.org/prods/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp://www.pouet.net/prod.php?which=18343\n\n*/\n\n#define FAR 20.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nvec3 camPath(in float t){ return vec3(sin(t * 0.45)*.75, cos(t * 0.75)*.75, t); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tvec3 tx = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n// Akohdr's multitextured suggestion, with some small changes.\n#define t2D texture\nvec3 tpl4( sampler2D a, sampler2D b, \n           sampler2D c, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );\n    \n    float h = dot(cos(p*6.), sin(p.yzx*6.));\n    \n\tvec3 tx  = (t2D(a, p.yz)*n.x + t2D(a, p.zx)*n.y + t2D(a, p.xy)*n.z).xyz; // Pink sandstone.\n\tvec3 tx2 = (t2D(b, p.yz)*n.x + t2D(b, p.zx)*n.y + t2D(b, p.xy)*n.z).xyz; // Sandstone.\n    vec3 tx3 = 1.-(t2D(c, p.yz)*n.x + t2D(c, p.zx)*n.y + t2D(c, p.xy)*n.z).zyx; // Pink coral.\n\n    tx = mix(tx*tx, tx2*tx2, h*.5 + .5);\n    \n    h = dot(sin(p*5.), cos(p.zxy*5.));\n    \n\ttx2 = mix(tx3*tx3, tx2*tx2, h*.5 + .5);\n    \n    return mix(tx, tx2, dot(sin(p*2.), sin(p.zxy*2.))*.5 + .5);\n}\n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    p = cos(p*6.2831853) + 1.;\n    return dot(p, p);\n    \n}\n/*\n// Draw four warped spheres on a wrappable cube, and return the closest distance metric. Try to normalize\n// the result between zero and one.\nfloat cellTile(in vec3 p){\n    \n    vec4 d;\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    d.xy = min(d.xy, d.zw); // Minimum distance determination.\n    \n    return 1.- min(d.x, d.y)*.166; // Normalize... roughly.\n    \n}\n*/\n\n// Fast, three tap version, but I feel four should be the minimum... Even so, this should give \n// a pretty convincing pattern, under the right circumstances.\nfloat cellTile(in vec3 p){\n    \n    vec3 d;\n    \n    // Draw three overlapping objects (spherical, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.2, .82, .64));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.41, .06, .70));\n    \n    return 1.- min(min(d.x, d.y), d.z)*.1666; // Normalize... roughly.\n    \n}\n\n\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty.\nfloat map(in vec3 p){\n    \n    float b = cellTile(p*3.); \n    //float b = cellTile(p + iTime/16.); // Animation.\n\n    // Offsetting the lattice around the camera path.\n    p.xy -= camPath(p.z).xy; \n\n    // Perturbing the surface slightly, prior to construction.\n    p += (sin(p*3.14159 - sin(p.zyx*3.14159)*3.14159*1.25))*.1;\n\n    // The main surface. A weird, molecular looking lattice.\n    float n = abs(dot(cos(p*3.14159), sin(p.yzx*3.14159)));\n\n    // Combining element to form the final structure.\n    return .45 - n*.33  - b*.1;\n    \n}\n\n \n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., h,eps=0.0015;\n    for(int i = 0; i < 128; i++){\n\n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<eps*(t + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += (step(1., h)*.25 + .5)*h;\n        eps *= 1.01;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float vor = cellTile(p*27.);\n    \n    return pow(max(vor, 0.), 18.);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n    \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel1, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t\n    // Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    // Perturbing the screen coordinates to create the lamest underwater effect ever. :)\n    // Seriously, though, it's quite effective, all things considered.\n    u += sin(u*32. + cos(u.yx*16. + iTime*4.))*.0035;\n\n\t\n\t// Camera Setup.\n    vec3 o = camPath(iTime*.5); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*.5 + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*.5 + 1.5) + vec3(.0, .0, 0.); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    r.xy = rot2( camPath(lk.z).x/16. )*r.xy;\n    vec3 p;\n    float t;\n    vec3 col = vec3(0);\n \n    if(t<FAR){\n        p = depth_map(fragCoord);\n        t = length(p-o);\n    \n        // Position and normal.\n        \n        vec3 n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .02/(1. + t/FAR));\n        \n        n = dbF(p*sz, n, .01);\n        \n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        // Diffuse, specular, fresnel.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl(iChannel0, p*sz, n);\n        \n        // Texture variance: Akohdr's suggestion.\n        // Requires an additional sandstone texture in iChannel1, and the pink coral texture\n        // in iChannel2.\n        //vec3 tx = tpl4(iChannel0, iChannel1, iChannel2, p*sz, n);\n        \n        float c = dot(tx, vec3(0.299, 0.587, 0.114));\n        \n        tx += vec3(c*c*.8, c, c*c*.5)*fr;\n        \n\n\t\t// Very simple coloring. Fresnel and texture combination.\n        col = tx*(di + .1 + sp)+ tx*fr*2.;\n        col *= 1./(1. + d*.125 + d*d*.025)*ao*sh;\n\n        \n    }\n\n    // Mixing in a simple blue background.\n    vec3 bg = vec3(.5, .7, 1);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-5., t));\n    \n    // Half hearted gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n\tCellular Lattice\n\t----------------\n\n\tStill playing around with 3D cellular tiles.\n\n\tTraversing a cellular, coral-like structure through an alien ocean ... Is anyone buying that?\n    I don't know what it is either, but it looks grotesquely interesting. :)\n\n\tIn technical terms, it's an intertwined sinusoidal lattice structure (a mutated gyroid of sorts) \n\twith a prominent cellular surface attached.\n\n    The scene was mildly inspired by IQ's Leizex demo and Tomasz Dobrowolski's Suboceanic.\n\n\n\tCellular Tiled Tunnel 2 - Shane\n\thttps://www.shadertoy.com/view/MdtSRl\n\n\trgba leizex - Inigo Quilez\n\thttp://www.pouet.net/prod.php?which=51829\n\thttps://www.youtube.com/watch?v=eJBGj8ggCXU\n\thttps://iquilezles.org/prods/index.htm\n\n\tTomasz Dobrowolski - Suboceanic\n\thttp://www.pouet.net/prod.php?which=18343\n\n*/\n\n#define FAR 20.\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel1, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nvec3 camPath(in float t){ return vec3(sin(t * 0.45)*.75, cos(t * 0.75)*.75, t); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tvec3 tx = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\n\n// Akohdr's multitextured suggestion, with some small changes.\n#define t2D texture\nvec3 tpl4( sampler2D a, sampler2D b, \n           sampler2D c, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );\n    \n    float h = dot(cos(p*6.), sin(p.yzx*6.));\n    \n\tvec3 tx  = (t2D(a, p.yz)*n.x + t2D(a, p.zx)*n.y + t2D(a, p.xy)*n.z).xyz; // Pink sandstone.\n\tvec3 tx2 = (t2D(b, p.yz)*n.x + t2D(b, p.zx)*n.y + t2D(b, p.xy)*n.z).xyz; // Sandstone.\n    vec3 tx3 = 1.-(t2D(c, p.yz)*n.x + t2D(c, p.zx)*n.y + t2D(c, p.xy)*n.z).zyx; // Pink coral.\n\n    tx = mix(tx*tx, tx2*tx2, h*.5 + .5);\n    \n    h = dot(sin(p*5.), cos(p.zxy*5.));\n    \n\ttx2 = mix(tx3*tx3, tx2*tx2, h*.5 + .5);\n    \n    return mix(tx, tx2, dot(sin(p*2.), sin(p.zxy*2.))*.5 + .5);\n}\n\nfloat drawObject(in vec3 p){\n    \n    // Anything that wraps the domain will work. The following looks pretty intereting.\n    p = cos(p*6.2831853) + 1.;\n    return dot(p, p);\n    \n}\n/*\n// Draw four warped spheres on a wrappable cube, and return the closest distance metric. Try to normalize\n// the result between zero and one.\nfloat cellTile(in vec3 p){\n    \n    vec4 d;\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    d.xy = min(d.xy, d.zw); // Minimum distance determination.\n    \n    return 1.- min(d.x, d.y)*.166; // Normalize... roughly.\n    \n}\n*/\n\n// Fast, three tap version, but I feel four should be the minimum... Even so, this should give \n// a pretty convincing pattern, under the right circumstances.\nfloat cellTile(in vec3 p){\n    \n    vec3 d;\n    \n    // Draw three overlapping objects (spherical, in this case) at various positions throughout the tile.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.2, .82, .64));\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.41, .06, .70));\n    \n    return 1.- min(min(d.x, d.y), d.z)*.1666; // Normalize... roughly.\n    \n}\n\n\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty.\nfloat map(in vec3 p){\n    \n    float b = cellTile(p*3.); \n    //float b = cellTile(p + iTime/16.); // Animation.\n\n    // Offsetting the lattice around the camera path.\n    p.xy -= camPath(p.z).xy; \n\n    // Perturbing the surface slightly, prior to construction.\n    p += (sin(p*3.14159 - sin(p.zyx*3.14159)*3.14159*1.25))*.1;\n\n    // The main surface. A weird, molecular looking lattice.\n    float n = abs(dot(cos(p*3.14159), sin(p.yzx*3.14159)));\n\n    // Combining element to form the final structure.\n    return .45 - n*.33  - b*.1;\n    \n}\n\n \n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., h,eps=0.0015;\n    for(int i = 0; i < 128; i++){\n\n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<eps*(t + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += (step(1., h)*.25 + .5)*h;\n        eps *= 1.01;\n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float vor = cellTile(p*27.);\n    \n    return pow(max(vor, 0.), 18.);\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    // Perturbing the screen coordinates to create the lamest underwater effect ever. :)\n    // Seriously, though, it's quite effective, all things considered.\n    u += sin(u*32. + cos(u.yx*16. + iTime*4.))*.0035;\n\n\t\n\t// Camera Setup.\n    vec3 o = camPath(iTime*.5); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*.5 + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*.5 + 1.5) + vec3(.0, .0, 0.); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    r.xy = rot2( camPath(lk.z).x/16. )*r.xy;\n \n    // Raymarch.\n    float t = trace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        col = o + r*t;\n    }\n    \n    fragColor = vec4(col,1.0);\n    \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 4.0", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[827, 836, 858, 858, 893], [895, 1047, 1068, 1068, 1134], [1136, 1136, 1161, 1161, 1217], [1219, 1373, 1419, 1419, 1592], [1677, 1677, 1762, 1762, 2358], [2360, 2360, 2388, 2481, 2541], [3294, 3453, 3479, 3479, 3916], [3920, 4069, 4090, 4090, 4610], [4614, 4766, 4803, 4803, 5062], [5065, 5104, 5124, 5124, 5283], [5286, 5307, 5343, 5343, 5818], [5820, 5832, 5908, 5908, 6517], [6520, 6584, 6613, 6613, 6694], [6696, 6746, 6797, 6797, 7179], [7181, 7263, 7318, 7318, 7818], [7820, 7820, 7847, 7847, 7996], [7999, 7999, 8055, 8094, 11059]], "test": "untested"}
{"id": "WdVBDK", "name": "Blurred Angles", "author": "jcreed", "description": "Every pixel holds an angular value, which are averaged-and-normalized over time. Clockwise and anticlockwise singularities appear, and attract and annihilate one another.", "tags": ["angle", "multipass", "singularities"], "likes": 6, "viewed": 345, "published": 3, "date": "1607985019", "time_retrieved": "2024-07-30T20:30:21.685360", "image_code": "// void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//\tfragColor = vec4(texture(iChannel0,fragCoord / iResolution.xy).xy, 0.0, 1.0);\n//}\n\n// Smooth HSV to RGB conversion\nvec3 hsv2rgb_smooth(in vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 vec = texture(iChannel0,fragCoord / iResolution.xy).xy - vec2(0.5, 0.5);\n   float angle = atan(vec.y, vec.x);\n\tfloat hue = (angle / (2.0 * M_PI)) + 0.5;\n\tfragColor = vec4(hsv2rgb_smooth(vec3(hue, 1.0, 1.0)), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 get_sample(int x, int y) {\n  return texture(iChannel0, (gl_FragCoord.xy + vec2(ivec2(x, y))) / iResolution.xy);\n}\n\n// normalize a vector to the circle centered at (0.5, 0.5) with radius 0.5\nvec2 norm(vec2 v) {\n  float x = v.x - 0.5;\n  float y = v.y - 0.5;\n  float len = 2.0 * sqrt(x * x + y * y);\n  return vec2(x / len + 0.5, y / len + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if  (iFrame < 10){\n\t float x = texture(iChannel1, fragCoord / vec2(512, 512)).x;\n\t float y = texture(iChannel1, fragCoord / vec2(512, 512) + vec2(0.5, 0.25)).x;\n\t fragColor = vec4(x, y, 0, 1.0);\n  }\n  else {\n\t\tvec4 avg = (get_sample(0,-1) + get_sample(0,0) + get_sample(0,1) +\n\t\t\t\t\t\tget_sample(1,-1) + get_sample(1,0) + get_sample(1,1) +\n\t\t\t\t\t\tget_sample(-1,-1) + get_sample(-1,0) + get_sample(-1,1)) / 9.0;\n\t\tvec2 normed = norm(avg.rg);\n\t\tfragColor = vec4(normed, 0.0, 1.0);\n    }\n}\n", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 179, 211, 211, 388], [449, 449, 505, 505, 727]], "test": "untested"}
{"id": "wsyBDV", "name": "Day 355", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 8, "viewed": 367, "published": 3, "date": "1607984245", "time_retrieved": "2024-07-30T20:30:22.565007", "image_code": "// THE VERY COOL MAZE IS FROM FABRICE NEYRET: \n// https://www.shadertoy.com/view/3dyfWV\n\n// \n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n    vec2 uvn = (U - R*0.5)/R.y;\n    \n    C -= C;\n    C = mix(C,vec4(0.,0.01,0.1,1.) - sin(uvn.xyyy*1. - 0.5)*0.1,T3(U).x*1.);\n    \n    C = mix(C,vec4(0.,0.2,0.1,1.) + abs(sin(uvn.yxxy*1. + iTime)*0.9), T2(U).x);\n    vec4 me = T1(U);\n    C = pow(C,vec4(0.4545));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec4 r42(vec2 u){\n    return texture(iChannel1,u/iResolution.xy);\n}\n\nconst float velScale = 0.001;\n\nint idxNeighbors = 0;\nvec4[] neighbors = vec4[15](vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9),vec4(9));\n\nvec4 get(vec2 u){\n    vec4 g = T(u);\n    vec2 muv = (iMouse.xy)/iResolution.xy;\n    g.zw = mix(g.zw, -normalize(muv - g.xy ),0.4*float(iMouse.z > 0.)*smoothstep(1.,0.,length((g.xy - muv)*R.y/R.x)*6. ));\n    \n    \n    #define pump(t,a) (floor(t) + pow(fract(t),a))\n    g.zw = mix(g.zw,vec2(0,-1.)*rot(0.5*pi*pump(iTime*0.1,20.)),0.007);\n    \n    \n\n    \n    g.xy += vec2(g.z*R.y/R.x,g.w)*velScale;\n    \n    if (abs(g.x - 0.5)>0.5){\n        g.z *= -1.;\n        g.x += 2.*g.z*velScale;\n    }\n    if (abs(g.y - 0.5)>0.5){\n        g.w *= -1.;\n        g.y += 2.*g.w*velScale;\n    }\n    \n    \n    if (T3n(g.xy).x > 0.){\n        vec2 normalRange = 4./R;\n        vec2 n = normalize(vec2(\n            T3n(g.xy + vec2(normalRange.x,0.)).x - T3n(g.xy + vec2(-normalRange.x,0.)).x,\n            T3n(g.xy + vec2(0.,normalRange.y)).x - T3n(g.xy + vec2(0.,-normalRange.y)).x\n            ));\n        vec2 t = n*rot(0.5*pi);\n        \n        //g.zw -= g.zw*2.;\n        //g.zw *= rot(0.5*pi);\n        \n        \n        g.zw = reflect(g.zw,n);\n        //g.xy += g.zw*2.*velScale;\n        g.xy -= n*0.003;\n        \n        \n        //g.zw -= 2.*n*g.zw*float(dot(g.zw,t) > 0.);\n    }\n    \n    return g;\n}\n\n/*\n\nvec4 otherc = other;                \\\n        otherc.xy *= 1. - 2.*vec2(             \\\n            float(abs(me.x) > 0.5 && abs(other.x) > 0.5 && sign(other.x) != sign(me.x) ), \\\n            float(abs(me.y) > 0.5 && abs(other.y) > 0.5 && sign(other.y) != sign(me.y) )  \\\n        ); \\\n        \n\n*/\n\n#define check(dir,times) \\\n    for(float i = 1.; i < times + 1.; i++){             \\\n        vec4 other = get(U + dir*i*stepSz);             \\\n        if(other != me){                                \\\n            if(length(uv - other.xy) < length(uv-me.xy))\\\n                me = other; meuv = U + dir*i*stepSz;            \\\n        }\\\n    }\n#define checkNeighbors(dir,times) \\\n    for(float i = 1.; i < times + 1.; i++){             \\\n        vec4 other = get(me.xy*R + dir*i*stepSz);                    \\\n        if(other != me){                                \\\n            neighbors[idxNeighbors++] = other;                             \\\n        }\\\n    }\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U)/R;\n    vec2 uvn = (U - R*0.5)/R.y;\n    \n\n    \n\n    C = T(U);\n\n    vec4 me = get(U);\n    \n    vec2 meuv = U;\n    \n    float steps = 15.;\n    float stepSz = 1.;\n    check(vec2(0,1)    ,steps);\n    check(vec2(0,-1)   ,steps);\n    check(vec2(1,0)    ,steps);\n    check(vec2(-1,0)   ,steps);\n    check(vec2(1,1)    ,steps);\n    check(vec2(-1,-1)  ,steps);\n    check(vec2(1,-1)   ,steps);\n    check(vec2(-1,1)   ,steps);\n    \n    \n    steps = 10.; stepSz = 3.;\n    checkNeighbors(vec2(0,1)    ,steps);\n    checkNeighbors(vec2(0,-1)   ,steps);\n    checkNeighbors(vec2(1,0)    ,steps);\n    checkNeighbors(vec2(-1,0)   ,steps);\n    checkNeighbors(vec2(1,1)    ,steps);\n    checkNeighbors(vec2(-1,-1)  ,steps);\n    checkNeighbors(vec2(1,-1)   ,steps);\n    checkNeighbors(vec2(-1,1)   ,steps);\n    \n    for (int i = 0; i < idxNeighbors; i++){\n        vec2 dir = neighbors[i].xy - me.xy; \n        //g.zw += normalize(dir)*smoothstep(1.,0.,exp(-dot(dir,dir)));\n        \n        float ldir = length(dir);\n        if(ldir > 0.)\n            me.zw -= normalize(dir)*smoothstep(1.,0.,ldir*100.)*0.07;\n        //g.y += 0.0001;\n    }\n    \n    C = me;\n    \n\n    if(iFrame < 2){\n        \n        \n        C = r42(U*11.);\n        if(T3n(C.xy).x == 0. && sin(C.z*2414.124) >0.0){\n        \n        \n            C.zw = C.zw*2. - 1.;\n            C.zw *= 0.1;\n        } else {\n            C = vec4(-1000);\n        }\n        //C = T3(U).xxxx;\n        //C = vec4(sin(U.x/10.),0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 col, in vec2 U )\n{\n    vec2 uv = U/R;\n \n    vec4 me = T(U);\n\n    col = T1(U);\n    //C = 1. - C;\n    \n    //C *= 1.-smoothstep(dFdx(uv.x),0., length(uvn - me.xy) - 0.003);\n    //C = mix(C,vec4(1.)*0.01,smoothstep(dFdx(uv.x),0., length(uvn - me.xy) - 0.003));\n    \n    //C = smoothstep(0.,1.,C);\n    \n    col = mix(\n        col,\n        mix(vec4(0),vec4(1),smoothstep(dFdx(uv.x),0., length( (uv - me.xy)*R/R.x) - 0.0006 ))\n        ,0.4\n    );\n    \n    //col = pow(abs(col),vec4(0.4545));\n    \n    \n    if (iFrame < 2)\n        col = col - col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texture(iChannel0,(u)/iResolution.xy)\n#define T1(u) texture(iChannel1,(u)/iResolution.xy)\n#define T2(u) texture(iChannel2,(u)/iResolution.xy)\n#define T3(u) (1. - texture(iChannel3,(u)/iResolution.xy))\n#define T3n(u) (1. - texture(iChannel3,(u)))\n\n#define R (iResolution.xy)\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define rot(m) mat2(cos(m),-sin(m),sin(m),cos(m))\n#define pi acos(-1.)", "buffer_d_code": "#define val(U, X,Y)  step(  s(U,Y) ,  texelFetch( iChannel0, ivec2(U+vec2(X,Y) ) % 1024, 0 ).x  )\n\n// threshold.  left: constant.  right: slight density gradient\n#define s(U,Y)         ( 0.3)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float z = 10.;\n    vec2 U = u/z ,\n         I = round(U), F = U-I, S = step(0.,F); \n    F = abs(F); I--;\n    \n    \n    O = vec4(val(U, 0.,0.) );         \n    vec4 V = vec4( val(I, 1.-S.x,S.y), val(I, S.x,S.y), \n                   val(I, S.x,1.-S.y), val(I, 1.-S.x,1.-S.y));\n    \n    if (      V.x == V.z && V.x != V.y \n         && ( V.y>0.     || V.y != V.w ) )\n        O = mix( O, 1.-O, smoothstep(-1./16.,1./16.,.5-(F.x+F.y)) );\n    \n    O = clamp(O,0.,1.);\n}", "buffer_d_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 135, 135, 418]], "test": "untested"}
{"id": "3dVBWK", "name": "Underground Flythrough", "author": "oneshade", "description": "I was playing with fractal noise but found something more interesting.", "tags": ["flythrough", "underground", "mesheffect"], "likes": 7, "viewed": 307, "published": 3, "date": "1607980426", "time_retrieved": "2024-07-30T20:30:23.399775", "image_code": "/*\nUse the mouse to rotate the camera and the arrow keys to move it.\n\nCommon: contains all of the settings and helper functions for texture lookups\nBuffer A: contains the code for updating the camera position and yaw/pitch rotations\nImage: contains the raymarching code\n*/\n\n// Set to true for a slight framerate boost:\nconst bool OPTIMIZE_RAYMARCHING = false;\n\nfloat Shape(in vec3 p) {\n\treturn sin(p.x) - sin(p.y) + sin(p.z);\n}\n\nfloat MeshShape(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n\n    float ldb = Shape(cell);                       // Left, Down, Back\n    float rdb = Shape(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = Shape(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = Shape(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = Shape(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = Shape(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = Shape(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = Shape(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat FractalMeshShape(in vec3 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += MeshShape(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    return (FractalMeshShape(p, 2.0, 4.0) - 0.3) * 0.3;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy),\n                          mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy),\n                          mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 rayOrigin = getViewPosition();\n    mat3 camera = getCamera(getViewDirection());\n    vec3 rayDirection = normalize(FOCAL_LENGTH * camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n\n    fragColor = vec4(0.25, 0.25, 1.0, 1.0);\n    float distanceTraveled = 0.0;\n    for (int iteration=0; iteration < MAX_ITERATIONS; iteration++) {\n        vec3 position = rayOrigin + rayDirection * distanceTraveled;\n        float sceneDistance = mapScene(position);\n        float multiplier = OPTIMIZE_RAYMARCHING ? 1.0 + distanceTraveled : 1.0;\n        if (sceneDistance < MIN_HIT_DISTANCE * multiplier) {\n            vec3 normal = getNormal(position);\n            vec3 light = vec3(-0.58, 0.58, 0.58);\n            float h = 0.5 + 0.5 * normal.y;\n            vec3 color = mix(vec3(0.6, 0.3, 0.0), vec3(0.0, 1.0, 0.0), h * h * h);\n            fragColor.rgb = color * max(0.0, dot(normal, light));\n            fragColor.rgb += 0.3 * color;\n            break;\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneDistance;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Raymarching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 10.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_ITERATIONS = 200;\nconst float FOCAL_LENGTH = 1.0;\n\n// Math constants:\nconst float TWO_PI = 6.2832;\n\n// Camera constants:\nconst float STEP_SIZE = 0.1;\nconst float ROTATION_SPEED = 0.5;\n\n// Addresses to viewing data:\nconst ivec2  VIEW_POSITION_ADDR = ivec2(0, 0);\nconst ivec2 VIEW_DIRECTION_ADDR = ivec2(1, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int    KEY_UP = 38;\nconst int  KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int  KEY_LEFT = 37;\n\n// A bunch of crazy macros because they are the only way to define texelFetches in Common :(\n#define  getViewPosition() texelFetch(iChannel0, VIEW_POSITION_ADDR, 0).xyz\n#define getViewDirection() texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).xy\n\n#define     keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define   keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define  keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define   keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Calculates camera axes:\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),  // Camera right axis (x)\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),  // Camera up axis (y)\n                vec3(s.x *  c.y, s.y, -c.x *  c.y)); // Camera forward axis (z)\n}", "buffer_a_code": "/*\nThe camera rotation is stored as yaw/pitch rotations. Yaw is spin and pitch is tilt.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n    if (iFrame > 0) {\n        ivec2 address = ivec2(fragCoord);\n        if (address == VIEW_POSITION_ADDR) {\n            fragColor = vec4(getViewPosition(), 1.0);\n            mat3 camera = getCamera(getViewDirection());\n \n            if (keyUpPressed()) {\n                fragColor.xyz += camera[2] * STEP_SIZE;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= camera[2] * STEP_SIZE;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += camera[0] * STEP_SIZE;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= camera[0] * STEP_SIZE;\n            }\n        }\n\n        if (address == VIEW_DIRECTION_ADDR) {\n            vec2 viewDirection = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TWO_PI * ROTATION_SPEED;\n            fragColor = vec4(viewDirection, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 361, 385, 385, 427], [429, 429, 457, 457, 1339], [1341, 1341, 1410, 1410, 1691], [1693, 1693, 1720, 1720, 1778], [1780, 1780, 1807, 1807, 2090], [2092, 2092, 2147, 2147, 3306]], "test": "untested"}
{"id": "tdyBWV", "name": "dick v1", "author": "spplash", "description": "raymarching test", "tags": ["dickraymarching"], "likes": 2, "viewed": 303, "published": 3, "date": "1607973985", "time_retrieved": "2024-07-30T20:30:24.251498", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.f\n#define SURF_DIST .01f\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0., 1.);\n\n\tvec3 c = a + t*ab;\n\treturn length(p-c) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz) - r.x;\n\treturn length(vec2(x, p.y)) - r.y;\n}\n\nfloat dBox(vec3 p, vec3 hsize) {\n\treturn length(max(abs(p) - hsize, 0.f));\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn min(a, b) - h*h*0.25/k;\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = max(k-abs(a-b),0.0);\n\treturn max(a, b) + h*h*0.25/k;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(abs(length(p.xz)),p.y)) - vec2(h,r);\n  d.x = abs(d.x) - 0.01;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb)\n{\n//  p.x = abs(p.x);\n  p.z = -p.z;\n  float k = (sc.y*p.z>sc.x*p.y || p.z < 0.) ? dot(p.zy,sc) : length(p.zy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat GetDist(vec3 p) {\n    //p = p//* vec3(0.8, 1.2, 0.8);\n    vec3 c = p - vec3(0., 1.0, 0.);\n\n\t//float d = sdCappedCylinder(c, 0.3, 0.3);\n    \n    float bl1 = sdEllipsoid(c-vec3(0.2, 0., 0.), vec3(0.25, 0.35, 0.25));\n    float bl2 = sdEllipsoid(c-vec3(-0.2, 0., 0.), vec3(0.25, 0.35, 0.25));\n    float bls = smin(bl1, bl2, 0.2);\n    \n    float r = 1.3 + sin(iTime)/4.;\n    \n    float pn = sdCappedTorus(c-vec3(0., 0.15 - r, 0.), vec2(.8, 0.6), r, 0.2);\n    \n    float d = smin(bls, pn, 0.1);\n    \n\treturn d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 res = vec2(0.0,-1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n\n#if 1\n\t// raytrace bounding plane\n\tfloat tp = (3.5-ro.y)/rd.y;\n\tif( tp>0.0 ) tmax = min( tmax, tp );\n#endif\n\n\t// raymarch scene\n\tfloat t = tmin;\n\tfor( int i=0; i<256 && t<tmax; i++ )\n\t{\n\t\tvec2 h = vec2(GetDist(ro+rd*t), 0.);\n\t\tif(abs(h.x)<(0.0005*t))\n\t\t{\n\t\t\tres = vec2(t,h.y);\n\t\t\tbreak;\n\t\t}\n\t\tt += h.x;\n\t}\n\n\treturn res;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n\tvec2 e = vec2(0.01, 0);\n\n\tvec3 n = d - vec3(\n\t\tGetDist(p - e.xyy),\n\t\tGetDist(p - e.yxy),\n\t\tGetDist(p - e.yyx));\n\n\treturn normalize(n);\n}\n\nfloat rand(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat rand2d(vec2 v)\n{\n\tvec2 K1 = vec2(23.14069263277926,2.665144142690225);\n\treturn fract( cos( dot(v,K1) ) * 12345.6789 );\n}\n\nfloat rand3d(vec3 v)\n{\n\tvec3 K1 = vec3(23.14069263277926, 2.665144142690225, 7.5739974548463465);\n\treturn fract( cos( dot(v,K1) ) * 12345.6789 );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 lookat)\n{\n\tvec3 cw = normalize(lookat-ro);\n\tvec3 cp = vec3(sin(0.), cos(0.),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 resolution = iResolution.xy;\n\tvec2 uv = (fragCoord.xy-.5*resolution) / resolution.y;\n\n\tvec3 sky_col = vec3(0.3, 0.0, 0.0);\n\tvec3 col = sky_col;\n\n\tfloat light_coef = 1.;\n\tvec3 light_color = vec3(1., 0.8, 0.8);\n\n\tcol = clamp((1.-length(uv-vec2(0., -0.5)) - 0.1*rand2d(uv+iTime)) * light_coef, 0., 1.) * light_color;\n\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    vec3 lookat = vec3(0., 1., 0.);\n    vec3 ro = lookat + vec3( 2.5*cos(0.1*iTime + 7.0*mo.x), 0.8 + 1.0*mo.y, 2.5*sin(0.1*iTime + 7.0*mo.x) );\n//\tvec3 ro = lookat + vec3(-3.0f, 1.f, -2.0f);\n    mat3 cam_mat = setCamera(ro, lookat);\n    \n    \n\tvec3 rd = cam_mat * normalize(vec3(uv.x+0., uv.y, 1));\n\n\tvec2 d = RayMarch(ro, rd);\n\n\tvec3 p = ro + rd * d.x;\n\n\tif (d.y > -0.5) {\n\t\t// moving light\n\t\tvec3 lightPos = vec3(-1.2, 1.1, -0.9);\n\t\tvec3 light_dir = lightPos - p;\n\t\tvec3 l = normalize(light_dir);\n\t\tvec3 normal = GetNormal(p);\n\n\t\tvec3 sky_l_dir = vec3(0, 1, 0);\n\n\t\t// light coef\n\t\tfloat main_light = clamp(dot(normal, l) - rand3d(p/*+iTime*/)*0.05, 0., 1.) * 0.5;\n\n\t\tcol = vec3(0.4, 0.4, 0.4);\n        \n\t\t// lightning\n\t\tvec3 lin = vec3(0.);\n\t\tlin += 2. * (0.1+light_coef * main_light) * light_color;\n\n\t\tcol = col * lin;\n\n\t\t// gama\n\t\tcol = pow(col, vec3(1./2.2));\n\t}\n\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 119, 119, 265], [267, 267, 298, 298, 367], [369, 369, 401, 401, 445], [447, 447, 488, 488, 554], [556, 556, 597, 597, 663], [665, 665, 702, 702, 785], [787, 787, 822, 822, 846], [848, 848, 900, 900, 1037], [1039, 1039, 1097, 1117, 1259], [1261, 1261, 1284, 1320, 1773], [1775, 1775, 1808, 1808, 2205], [2207, 2207, 2231, 2231, 2392], [2394, 2394, 2415, 2415, 2451], [2453, 2453, 2475, 2475, 2579], [2581, 2581, 2603, 2603, 2728], [2730, 2730, 2774, 2774, 2955], [2957, 2957, 3014, 3014, 4298]], "test": "untested"}
{"id": "wdyfDK", "name": "Thermal Fluid", "author": "wyatt", "description": "I took statistical physics this quarter so I think that this is actually not totally as made up as it usually is.  It takes quite a long time for the hot fluid to rise. You might need to disturb the system to get some action. ", "tags": ["physics"], "likes": 10, "viewed": 457, "published": 3, "date": "1607967020", "time_retrieved": "2024-07-30T20:30:25.137130", "image_code": "Main {\n    vec4 a = A(U), b = B(U);\n    Q = atan(a.w)*sin(1.+(a.z-1.)*vec4(1,2,3,4));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}\n", "buffer_a_code": "// apply forces\n\nvec4 X (vec4 Q, vec2 u) {\n\tvec4 a = A(gl_FragCoord.xy + u);\n    float f = abs(Q.w-a.w)*max(0.,1.-a.w)*max(0.,1.-Q.w);\n    return mix(Q,a,clamp(2.*f,0.,1.));\n}\nMain {\n\tQ = A(U);\n    if (iFrame%2==0)  {\n        for (int x = -1; x<=1;x++)\n        for (int y = -1; y<=1;y++)\n        if (abs(x)!=abs(y))\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(gl_FragCoord.xy + u);\n            vec4 b = B(gl_FragCoord.xy + u);\n            u = u/dot(u,u);\n            float f = min(Q.w,1.)*.1*a.w*(a.z*(a.w-1.)+1.);\n            Q.xy -= f*u/max(1.,Q.w);\n            Q.z  -= Q.w*f*dot(u,a.xy);\n        }\n        Q.y -= .2/R.y;\n        if (length(Q.xy) >1.) Q.xy = normalize(Q.xy);\n        if (iFrame < 1) {\n            float s = step(U.y,sin(U.x/R.x*6.2*4.)*R.y/25.+0.5*R.y);\n            Q = vec4(0,0,1.+s,1.);\n        }\n    } else {\n    \tvec4 q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        if (x!=0||y!=0)\n           q += X(Q,vec2(x,y));\n        Q = 0.125*q;\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<5.)\n        Q = vec4(-.9,0,1,1);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Conservative advect alternating x and y-direction\nMain {\n    Q = vec4(0); float m = 0.;\n    vec2 r = iFrame%2==1?vec2(1,0):vec2(0,1);\n    \n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = i*r;\n        vec4 a = .5*A(U+u-.5*r),\n             b = A(U+u),\n             c = .5*A(U+u+.5*r);\n        float w1 = 1.+dot(c.xy,r)-dot(a.xy,r);\n        if (w1>0.) {\n            float w = clamp(dot(u,r)+.5+dot(c.xy,r),-.5,.5)-\n                      clamp(dot(u,r)-.5+dot(a.xy,r),-.5,.5);\n            Q += b.w*w/w1*b;\n            m += b.w*w/w1;\n        }\n    }\n    if (m > 0.) Q /= m;\n    Q.w = m;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// apply forces\n\nvec4 X (vec4 Q, vec2 u) {\n\tvec4 a = A(gl_FragCoord.xy + u);\n    float f = abs(Q.w-a.w)*max(0.,1.-a.w)*max(0.,1.-Q.w);\n    return mix(Q,a,clamp(2.*f,0.,1.));\n}\nMain {\n\tQ = A(U);\n    if (iFrame%2==0)  {\n        for (int x = -1; x<=1;x++)\n        for (int y = -1; y<=1;y++)\n        if (abs(x)!=abs(y))\n        {\n            vec2 u = vec2(x,y);\n            vec4 a = A(gl_FragCoord.xy + u);\n            vec4 b = B(gl_FragCoord.xy + u);\n            u = u/dot(u,u);\n            float f = min(Q.w,1.)*.125*a.w*(a.z*(a.w-1.));\n            Q.xy -= f*u/max(1.,Q.w);\n            Q.z  -= Q.w*f*dot(u,a.xy);\n        }\n        Q.y -= atan(100.*Q.w)*.1/R.y;\n        if (length(Q.xy) >1.) Q.xy = normalize(Q.xy);\n        if (iFrame < 1) {\n            float s = step(U.y,sin(U.x/R.x*6.2*4.)*R.y/25.+0.5*R.y);\n            Q = vec4(0,0,1.+s,1.);\n        }\n    } else {\n    \tvec4 q = vec4(0);\n        for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n        if (x!=0||y!=0)\n           q += X(Q,vec2(x,y));\n        Q = 0.125*q;\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<5.)\n        Q = vec4(-.9,0,1,1);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy*=0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Conservative advect alternating x and y-direction\nMain {\n    Q = vec4(0); float m = 0.;\n    vec2 r = iFrame%2==0?vec2(1,0):vec2(0,1);\n    \n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = i*r;\n        vec4 a = .5*A(U+u-.5*r),\n             b = A(U+u),\n             c = .5*A(U+u+.5*r);\n        float w1 = 1.+dot(c.xy,r)-dot(a.xy,r);\n        if (w1>0.) {\n            float w = clamp(dot(u,r)+.5+dot(c.xy,r),-.5,.5)-\n                      clamp(dot(u,r)-.5+dot(a.xy,r),-.5,.5);\n            Q += b.w*w/w1*b;\n            m += b.w*w/w1;\n        }\n    }\n    if (m > 0.) Q /= m;\n    Q.w = m;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdyfDK", "name": "Polka de Sphère", "author": "IWBTShyGuy", "description": "dancing polca-dotted spheres\n\nInspired by Yayoi Kusama", "tags": ["pattern"], "likes": 5, "viewed": 357, "published": 3, "date": "1607966608", "time_retrieved": "2024-07-30T20:30:26.013786", "image_code": "// Copyright © 2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// ------ Configures ------ //\nconst vec3 RED = vec3(230.0, 0.0, 18.0) / 255.0;\nconst vec3 GREEN = vec3(0.0, 167.0, 60.0) / 255.0;\nconst vec3 BLUE = vec3(0.0, 100.0, 180.0) / 255.0;\n\nconst uint N_SPHERE = 8u;\nconst float SPHERE_RADIUS = 0.5;\nconst float ORBIT_RADIUS = 2.0;\nconst float ORBIT_VELO = 1.0;\nconst float ROTATION_VELO = 1.5;\nconst vec3 ROTATION_AXIS = normalize(vec3(1.0, 2.0, 0.0));\n\nconst float SPHERE_DOT_RADIUS = 0.07;\nconst float BACK_DOT_RADIUS = 0.21;\nconst float BACK_DOT_INTERVAL = 0.12;\nconst float BACK_DOT_VELO = 1.5;\n\n// ------ 3D utilities ------ //\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction;\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\nbool depthTest(in Ray ray, in vec3 current_position, in vec3 new_position) {\n    float dist0 = distance(ray.origin, current_position);\n    float dist1 = distance(ray.origin, new_position);\n    return dist0 > dist1;\n}\n\n// ------ sphere ------ //\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nSphere newSphere(in vec3 center, in float radius) {\n    Sphere sphere;\n    sphere.center = center;\n    sphere.radius = radius;\n    return sphere;\n}\n\nconst float A = (sqrt(5.0) + 1.0) / 2.0;\nconst float B = (sqrt(5.0) - 1.0) / 2.0;\n\nconst uint N = 32u; // the number of vertices.\nconst vec3 VERTICES[N] = vec3[](\n    normalize(vec3(1.0, 1.0, 1.0)),\n    normalize(vec3(1.0, 1.0, -1.0)),\n    normalize(vec3(1.0, -1.0, 1.0)),\n    normalize(vec3(1.0, -1.0, -1.0)),\n    normalize(vec3(-1.0, 1.0, 1.0)),\n    normalize(vec3(-1.0, 1.0, -1.0)),\n    normalize(vec3(-1.0, -1.0, 1.0)),\n    normalize(vec3(-1.0, -1.0, -1.0)),\n    normalize(vec3(0.0, A, B)),\n    normalize(vec3(0.0, A, -B)),\n    normalize(vec3(0.0, -A, B)),\n    normalize(vec3(0.0, -A, -B)),\n    normalize(vec3(A, B, 0.0)),\n    normalize(vec3(A, -B, 0.0)),\n    normalize(vec3(-A, B, 0.0)),\n    normalize(vec3(-A, -B, 0.0)),\n    normalize(vec3(B, 0.0, A)),\n    normalize(vec3(B, 0.0, -A)),\n    normalize(vec3(-B, 0.0, A)),\n    normalize(vec3(-B, 0.0, -A)),\n    normalize(vec3(0.0, 1.0, A)),\n    normalize(vec3(0.0, 1.0, -A)),\n    normalize(vec3(0.0, -1.0, A)),\n    normalize(vec3(0.0, -1.0, -A)),\n    normalize(vec3(1.0, A, 0.0)),\n    normalize(vec3(1.0, -A, 0.0)),\n    normalize(vec3(-1.0, A, 0.0)),\n    normalize(vec3(-1.0, -A, 0.0)),\n    normalize(vec3(A, 0.0, 1.0)),\n    normalize(vec3(A, 0.0, -1.0)),\n    normalize(vec3(-A, 0.0, 1.0)),\n    normalize(vec3(-A, 0.0, -1.0))\n);\n\nbool onSphere(in Ray ray, in Sphere sphere, out vec3 intersection) {\n    vec3 to_center = sphere.center - ray.origin;\n    vec3 h = to_center - dot(to_center, ray.direction) * ray.direction;\n    float d2 = sphere.radius * sphere.radius - dot(h, h);\n    if (d2 < 0.0) return false;\n    intersection = ray.origin + (dot(to_center, ray.direction) - sqrt(d2)) * ray.direction;\n    return true;\n}\n\n// ------ basis function for gradation ------ //\nfloat parab(float t) { return 2.0 * t * t; }\n\nvec3 nowColor(float t) {\n    t = fract(t / 3.0) * 3.0;\n    float r0 = t < 1.0 ? (t < 0.5 ? 1.0 - parab(t) : parab(1.0 - t)) : 0.0;\n    float g = t < 2.0 ? (t < 1.0 ? 1.0 - r0 : (t < 1.5 ? 1.0 - parab(t - 1.0) : parab(2.0 - t))) : 0.0;\n    float r1 = 2.0 < t ? (t < 2.5 ? parab(t - 2.0) : 1.0 - parab(3.0 - t)) : 0.0;\n    float b = 1.0 < t ? 1.0 - g - r1 : 0.0;\n    return (r0 + r1) * RED + g * GREEN + b * BLUE;\n}\n\nSphere[N_SPHERE] createSpheres(float t) {\n    Sphere sphere[N_SPHERE];\n    for (uint i = 0u; i < N_SPHERE; i++) {\n        float theta = t + 2.0 * PI * float(i) / float(N_SPHERE);\n        sphere[i] = newSphere(vec3(sin(theta), 0.0, cos(theta)) * ORBIT_RADIUS, SPHERE_RADIUS);\n    }\n    return sphere;\n}\n\nvec4 backGroundPolka(in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y / BACK_DOT_INTERVAL + BACK_DOT_VELO * iTime;\n    vec2 lattice = uv + 0.5;\n    lattice = vec2(floor(lattice.x), floor(lattice.y));\n    if (distance(uv, lattice) < BACK_DOT_RADIUS) return vec4(nowColor(iTime), 1.0);\n    else return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 rotOnSphere(in Sphere sphere, in vec3 position, mat3 rotation) {\n    return rotation * (position - sphere.center) + sphere.center;\n}\n\nvec4 spherePolka(in Sphere sphere, in vec3 position) {\n    for (uint i = 0u; i < N; i++) {\n        vec3 dot_center = sphere.radius * VERTICES[i] + sphere.center;\n        if (distance(position, dot_center) < SPHERE_DOT_RADIUS) {\n            return vec4(nowColor(-iTime), 1.0);\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 unit = normalize(vec3(0.0, -0.5, 1.0));\n    Camera camera = newCamera(\n        -5.0 * unit - vec3(0.0, 0.5, 0.0),\n        unit,\n        vec3(0.0, 1.0, 0.0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, uv);\n\n    Sphere sphere[N_SPHERE] = createSpheres(ORBIT_VELO * iTime);\n    bool onOneSphere = false;\n    vec3 position = vec3(100.0);\n    uint idx;\n    for (uint i = 0u; i < N_SPHERE; i++) {\n        vec3 tmp_position;\n        if (onSphere(ray, sphere[i], tmp_position)) {\n            if (depthTest(ray, position, tmp_position)) {\n                position = tmp_position;\n                idx = i;\n            }\n            onOneSphere = true;\n        }\n    }\n    if (onOneSphere) {\n        mat3 rotation = rot(ROTATION_AXIS, ROTATION_VELO * iTime);\n        position = rotOnSphere(sphere[idx], position, rotation);\n        fragColor = spherePolka(sphere[idx], position);\n    } else {\n        fragColor = backGroundPolka(fragCoord);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfDK.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[863, 863, 956, 956, 1152], [1154, 1242, 1287, 1287, 1721], [1723, 1754, 1788, 1788, 2422], [2424, 2424, 2500, 2500, 2640], [2724, 2724, 2775, 2775, 2871], [4155, 4155, 4223, 4223, 4545], [4547, 4596, 4618, 4618, 4640], [4642, 4642, 4666, 4666, 5055], [5360, 5360, 5401, 5401, 5699], [5701, 5701, 5770, 5770, 5838], [5840, 5840, 5894, 5894, 6170], [6172, 6172, 6227, 6227, 7268]], "test": "untested"}
{"id": "wdyBWK", "name": "Ripples with fBm", "author": "AI", "description": "This is a simulation of ripples with fractional Brownian motion.\nYou may change the constant values in the program to explore other variations.\nMove your mouse over the screen to see the surroundings.", "tags": ["noise", "ripples", "fbm", "generativeart", "brownianmotion", "creativecoding"], "likes": 13, "viewed": 566, "published": 3, "date": "1607955767", "time_retrieved": "2024-07-30T20:30:26.864511", "image_code": "// pseudo-random function, returns value between [0.,1.]\nfloat rand (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(31.7667,14.9876)))\n                 * 833443.123456);\n}\n//bilinear value noise function\nfloat bilinearNoise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners of a 2D square\n    float f00 = rand(i);\n    float f10 = rand(i + vec2(1.0, 0.0));\n    float f01 = rand(i + vec2(0.0, 1.0));\n    float f11 = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,(1.-f));\n\treturn u.x*u.y*f00+(1.-u.x)*u.y*f10+\n    u.x*(1.-u.y)*f01+(1.-u.x)*(1.-u.y)*f11;\n    \n}\n\n#define OCTAVES 5\nfloat fbm (in vec2 st) {\n    // Initial parameters\n    float value = 0.0;\n    float amplitude = .65;\n    float frequency = 1.;\n    //-----\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * bilinearNoise(frequency*st);\n        frequency *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    float color =0.;\n    vec2 q=vec2(0.);\n    q.x=fbm(10.*st+.55*iTime);\n    q.y=fbm(10.*st+.21*iTime);\n    vec2 r=vec2(0.);\n    r.x=fbm(100.*st+21.5*q+.1*iTime);\n    r.y=fbm(100.*st+21.5*q+.34*iTime);\n\tcolor=fbm(10.*st+1.*r+3.*iMouse.xy/iResolution.xy);\n    fragColor = vec4(color*clamp(q.x+q.y,0.,1.),color*color,color*clamp(length(r),0.,1.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 82, 82, 200], [201, 233, 267, 267, 631], [651, 651, 675, 701, 986], [988, 988, 1046, 1046, 1483]], "test": "untested"}
{"id": "tdyBWK", "name": "UE4 InterleavedGradientNoise", "author": "kagtag", "description": "Test UE4 shader functions", "tags": ["random"], "likes": 2, "viewed": 278, "published": 3, "date": "1607955207", "time_retrieved": "2024-07-30T20:30:27.738176", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // From ue4 float InterleavedGradientNoise( float2 uv, float FrameId )   \n    \n    // high frequency dither pattern appearing almost random without banding steps\n    //note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n    //      http://advances.realtimerendering.com/s2014/index.html\n\n    float FrameId = sin(iTime *0.01) *4.0 +4.0;\n    uv += FrameId * (vec2(47.0, 17.0) * 0.695);\n\n    vec3 magic = vec3( 0.06711056f, 0.00583715f, 52.9829189f );\n    fragColor = vec4(fract(magic.z * fract(dot(uv, magic.xy))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 695]], "test": "untested"}
{"id": "3sGfDV", "name": "mouse (api fork)", "author": "gwiazdorrr", "description": "Fork of https://www.shadertoy.com/view/lssGzH. Made it API accessible.", "tags": ["mouse"], "likes": 1, "viewed": 248, "published": 3, "date": "1607950078", "time_retrieved": "2024-07-30T20:30:28.600869", "image_code": "// a dumb test shader to see how iMouse works\n// click and drag the mouse\n\nfloat smoothbump(float center, float width, float x) {\n  float w2 = width/2.0;\n  float cp = center+w2;\n  float cm = center-w2;\n  float c = smoothstep(cm, center, x) * (1.0-smoothstep(center, cp, x));\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2  uv = (fragCoord.xy / iResolution.xy);\n  vec4  m  = iMouse / iResolution.xyxy;\n  float m0 = (m.z > 0.0) ? 0.25 : 0.0;\n  float m1 = smoothbump(m.x,0.05,uv.x) *\n             smoothbump(m.y,0.05,uv.y);\n  float m2 = smoothbump(abs(m.z),0.05,uv.x) *\n             smoothbump(abs(m.w),0.05,uv.y);\n  fragColor = vec4(m1,m0,m2,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 129, 129, 288], [290, 290, 347, 347, 680]], "test": "untested"}
{"id": "3dyBDV", "name": "dithered grey", "author": "FabriceNeyret2", "description": "Same grey despite growing dithering.\nGradient is counterbalanced with dithered gradient for the result is constant on average.\n( requires your gamma be correctly tuned ).", "tags": ["gamma", "dithering", "short"], "likes": 6, "viewed": 328, "published": 3, "date": "1607946837", "time_retrieved": "2024-07-30T20:30:29.473536", "image_code": "   #define S  U.x/R.x\n// #define S  min( 1. , length( ceil(U-R/2.) )/R.y )\n   #define V  step( texelFetch( iChannel0, ivec2(U/2.), 0 ).x , S )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n  \n    O = vec4( sqrt(  U.y<.2*R.y ? .5 : .5+ .5*( V - S )  ) );\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 182, 182, 278]], "test": "untested"}
{"id": "3sGBDV", "name": "mandala from blue noise (358ch)", "author": "FabriceNeyret2", "description": "rounding corners in blue-noise to show maze-like 4-connexity ( from [url]https://shadertoy.com/view/3dyfWV[/url] ).\nClick to see raw noise.", "tags": ["maze", "bluenoise", "short", "golf"], "likes": 6, "viewed": 360, "published": 3, "date": "1607941448", "time_retrieved": "2024-07-30T20:30:30.328250", "image_code": "// variant of https://shadertoy.com/view/3dyfWV\n\n#define V(X,Y)  step( .8-.7*length( ceil(U-R/z/2.) +Y ) *z/R.y       , \\\n                      texelFetch( iChannel0, ivec2(U+vec2(X,Y)), 0 ).x )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float z = 2.;  // iResolution.y/180.; // if you want exact zoom\n    vec2 U = u/z, R = iResolution.xy,\n         I = round(U), F = U-I, S = step(0.,F); \n     \n    O += V(0.,0.) -O;  if ( iMouse.z > .5 ) return; \n    \n    F = abs(F); U = --I; \n    float x = S.x, y = S.y,\n          a = V(1.-x,y), b = V(x,y);\n    \n    O = a == V(x,1.-y) && a != b && ( b>0. || b != V(1.-x,1.-y) )\n        ? mix( O, 1.-O, clamp(1.-F.x-F.y,0.,1.)  ) : O;\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 234, 234, 673]], "test": "untested"}
{"id": "3dyfWV", "name": "maze from blue noise", "author": "FabriceNeyret2", "description": "rounding corners in blue-noise to show maze-like 4-connexity.\nRight: with slight vertical density gradient.", "tags": ["maze", "bluenoise", "short"], "likes": 5, "viewed": 331, "published": 3, "date": "1607938459", "time_retrieved": "2024-07-30T20:30:31.179973", "image_code": "#define T(U)         texelFetch( iChannel0, ivec2(U) % 1024, 0 )\n#define val(U, X,Y)  step(  s(U,Y) , T( U+vec2(X,Y) ).x )\n\n// threshold.  left: constant.  right: slight density gradient\n#define s(U,Y)         ( u.x < R.x/2.                           \\\n                           ? .41                                \\\n                           : .3+.4*(floor(U.y)-iTime+Y)*z/R.y   \\\n                       )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float z = 8.;\n    vec2 U = u/z + iTime,\n         R = iResolution.xy,\n         I = round(U), F = U-I, S = step(0.,F); \n    F = abs(F); I--;\n    \n    if (int(u)==int(R/2.)) { O = vec4(1,0,0,1); return; } // red separator\n    \n    O = vec4(val(U, 0.,0.) );                             // thresholded blue-noise\n    if (fract(iTime/4.-.4) > .5 ) return;\n // O = vec4( 10.*( texture(iChannel0, U/R).x - s ) ) );\n \n    vec4 V = vec4( val(I, 1.-S.x,S.y), val(I, S.x,S.y), \n                   val(I, S.x,1.-S.y), val(I, 1.-S.x,1.-S.y));\n    \n    if (      V.x == V.z && V.x != V.y // && F.x+F.y<.5   // round corners + white passages \n         && ( V.y>0.     || V.y != V.w ) )\n     // O = 1.-O;\n        O = mix( O, 1.-O, smoothstep(-1./16.,1./16.,.5-(F.x+F.y)) );\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 411, 449, 449, 1212]], "test": "untested"}
{"id": "3syBWK", "name": "paisaje- n2-2d (remix)", "author": "jarble", "description": "This is a remix of the music from [url=https://www.shadertoy.com/view/tsKfDy]paisaje- n2-2d[/code].", "tags": ["music", "remix", "song"], "likes": 6, "viewed": 292, "published": 3, "date": "1607913706", "time_retrieved": "2024-07-30T20:30:32.048651", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,mainSound(1,iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "sound_code": "//see Common tab", "sound_inputs": [], "common_code": "//por jorge flores ---jorge2017a1\nvec2 mainSound( in int samp, float i )\n{ float t=fract(i/52.)*52.;\n    float b=fract(t/4.)<5./6.?180.*acos(-1.):108.*acos(-1.);\n \n \n \tvec2 c1=vec2( sin(b*t)*exp(-3.0*fract(t/2.)),sin(b*t)*exp(-5.0*fract(--t/2.)) );\n \tvec2 c2=vec2( sin(b*floor(t*c1/8.)*(t))*exp(-2.0*fract(t*3.+.5)));\n    vec2 c3=clamp( vec2( sin(b*floor((t+1.8)/8.)*(t))*exp(-3.0*fract(t*1.5+.5))),.2,.8);\n \tvec2 c4=vec2( sin(c3*floor(t/4.)*(t)+2.0*sin(c2*t*0.5))*exp(-2.0*fract(t*3.+.5)));\n    vec2 sum=c1+c2+c3+c4;\n        \n    return sum;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 162]], "test": "untested"}
{"id": "tsKfDy", "name": "paisaje- n2-2d", "author": "jorge2017a1", "description": "paisaje- n2-2d\nwell the original sound is from https://www.shadertoy.com/view/XdlyDM ", "tags": ["paisajen22d"], "likes": 5, "viewed": 262, "published": 3, "date": "1607910689", "time_retrieved": "2024-07-30T20:30:32.877435", "image_code": "//por jorge flores ---jorge2017a1\n//recursos\n//https://iquilezles.org/articles/distfunctions2d\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\n\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{\n    //return  min(d1.x,d2.x); \n    if (d1.x<d2.x)\n       return d1; \t\n    else\n       return d2;\n}\n\nvec2 opS2( vec2 d1, vec2 d2 )\n{\n    //return max(-d1.x,d2.x); \n    if  (-d1.x<d2.x)\n        return d1;\n    else\n        return d2;\n}\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{\n    //return max(d1,d2);\n    if (d1.x>d2.x)\n       \treturn d1;\n    else\n        return d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2) {\n\treturn vec2(max(-d2.x, d1.x), 2.0);\n}\n\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return  q;\n}\n\n\n\nfloat sdCirc(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n    \nfloat MarOnda(vec2 uv,float  t)\n{\n    uv.y += sin(uv.x*5.+t)*0.1;\n    return uv.y;\n}\n\n\nvec2 Bloque(vec2 p)\n{\n    \n    \n    vec2 resp=vec2(9999.0,-1.0);\n    vec2 p1= rotate2d( p, radians(180.0));\n    vec2 p2= rotate2d( p, radians(90.0));\n    vec2 p3= rotate2d( p, radians(270.0));\n    \n    float dtArriba= sdTriangleIsosceles(p-vec2(0.0,0.01), vec2(0.05,0.04) );\n    float dtAbajo= sdTriangleIsosceles(p1-vec2(0.0,0.01), vec2(0.05,0.04) );\n    float dtDer= sdTriangleIsosceles(p2-vec2(-0.001,0.01), vec2(0.05,0.04) );\n    float dtIzq= sdTriangleIsosceles(p3-vec2(0.001,0.01), vec2(0.05,0.04) );\n    \n    resp= opU2( vec2(dtArriba,32.0 ), resp);\n    resp= opU2( vec2(dtAbajo,34.0 ), resp);\n    resp= opU2( vec2(dtDer,33.0 ), resp);\n    resp= opU2( vec2(dtIzq,33.0 ), resp);\n    \n    return resp;\n}\n\n\nfloat Bloquesv2(vec2 p)\n{\n    vec2 pp=p;\n    \n   \n    float suma=1000.0;\n    \n    for (float i=0.0; i<16.0;i++)\n \t{       \n    \tfloat b1a=sdBox(pp-vec2(-1.8+0.235*float(i),-1.4), vec2(0.11,0.05 ) );\n    \tsuma=opU(suma, b1a);\n        \n\t}   \n    \n    float resp=suma;\n    \n    return resp;\n}\n\nvec2 BloqueTriangulo(vec2 p)\n{   \n    vec2 resp=vec2(9999.0,-1.0);\n    \n    float st1= TriangulosPoly(p, 1);\n    float st2= TriangulosPoly(p, 2);\n    float st3= TriangulosPoly(p, 3);\n    float st4= TriangulosPoly(p, 4);\n    \n    resp= opU2( vec2(st1,36.0), resp); //sup\n    resp= opU2( vec2(st2,37.0), resp); //der\n    resp= opU2( vec2(st3,35.0), resp); //inf\n    resp= opU2( vec2(st4,38.0), resp); //izq\n    \n    \n    return resp;\n}   \n\nvec2 BloqueTrianguloGris(vec2 p)\n{   \n    vec2 resp=vec2(9999.0,-1.0);\n    \n    float st1= TriangulosPoly(p, 1);\n    float st2= TriangulosPoly(p, 2);\n    float st3= TriangulosPoly(p, 3);\n    float st4= TriangulosPoly(p, 4);\n    \n    resp= opU2( vec2(st1,31.0), resp);\n    resp= opU2( vec2(st2,32.0), resp);\n    resp= opU2( vec2(st3,33.0), resp);\n    resp= opU2( vec2(st4,32.0), resp);\n    \n    \n    return resp;\n}   \n\n\nvec2 EsferaRebota(vec2 pp)\n{   \n    \n    vec2 p= vec2(pp.x,pp.y+ abs(0.5*sin(iTime+cos(iTime*0.5)))+0.15);\n    vec2 resp=vec2(9999.0,-1.0);\n    float sc1=  sdCirc( p, 0.06);\n    float sc2=  sdCirc( p, 0.05);\n    sc1=opS(sc2,sc1);\n    resp= opU2( vec2(sc1,1.0), resp);\n    resp= opU2( vec2(sc2,2.0), resp);\n    \n    \n    return resp;\n}   \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n     vec2 pbola=p;\n     //p*=0.125;\n\t vec3 col = vec3(0.6);\n    \n    \n    //sugerencia por FabriceNeyret2, \n     //p.x = mod( p.x+iTime, iResolution.x/iResolution.y);\n     p.x = mod(1.5+ p.x+iTime*0.75, iResolution.x/iResolution.y);\n     \n    vec2 c=vec2(.114,0.1);\n    vec2 pRep=opRep2D( p, c );\n    \n    \n    float b1 = Bloquesv2(p-vec2(0.1,0.61));\n    float b2 = Bloquesv2(p-vec2(0.0,0.5));\n    vec2 st1= BloqueTriangulo(p-vec2(0.0,0.0));\n    vec2 st2= BloqueTriangulo(p-vec2(0.53,0.0));\n    \n    vec2 es1= EsferaRebota(pbola);\n    \n    \n    vec3 colgris=vec3(0.5);\n    \n    \n    vec2 sb1= Bloque(pRep);\n    vec3 colb1=getColorf(sb1.y);\n    vec3 colt1=getColorf(st1.y);\n    vec3 colt2=getColorf(st2.y);\n  \n    \n    vec3 colt4=getColorf(es1.y);\n    \n    \n    \n    col= DibujoSinBorde(p, sb1.x,colb1,  col);\n    \n    col= DibujoConBorde(p, b1, colgris,  col);\n    col= DibujoConBorde(p, b2, colgris,  col);\n    \n    col= DibujoSinBorde(p, st1.x,colt1, col);\n    col= DibujoSinBorde(p, st2.x,colt2, col);\n    \n    col= DibujoSinBorde(p, es1.x,colt4, col);\n    \n   \n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    vec3 color;\n   \n};\n\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.9),  //31\nvec3(0.8),  //32\nvec3(0.7),  //33\nvec3(0.6),  //34\n\nvec3(150.,75.,0.0)/255.,  //35  //marron o cafe\nvec3(204.,119.,34.0)/255.,  //36 //marron o cafe\nvec3(184.,115.,51.0)/255.  //37 //marron o cafe\n\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n\n\nvec3 getColorf(float ii)\n{    \n\n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n///--------------------------------------------\n\n\n\n// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 DibujoConBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    \n    float uWotM8 = 0.009;\n    \n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    \n    return mix(colOut,colIn, flm );\n}\n\n\nvec3 DibujoSinBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    \n    float uWotM8 = 0.009;\n    \n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    //colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    colOut = mix(colOut, colIn, uWotM8);\n    \n    return mix(colOut,colIn, flm );\n}\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n///-------------------------------\n\n\nvec2 rotate2d(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nmat2 rot2D(float a)\n{\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n//================================================\n//https://www.shadertoy.com/view/wdBXRW   referencia IQ\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 3;\n\n//https://www.shadertoy.com/view/wdBXRW   referencia IQ\nfloat sdPolygon( in vec2 p, in vec2[N] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n\nfloat TriangulosPoly(vec2 p, int opc)\n{\n        \n    vec2 p0,p1, p2;\n    \n    if (opc==1)\n        {\n             p0 = vec2(0.25,0.75);\n             p1 = vec2(0.75,0.75);\n             p2 = vec2(0.5,0.5);\n            \n        }\n        \n     if (opc==2)\n        {\n             p0 = vec2(0.75,0.75);\n             p1 = vec2(0.75,0.25);\n             p2 = vec2(0.5,0.5);   \n        }\n        \n        \n        if (opc==3)\n        {\n             p0 = vec2(0.25,0.25);\n             p1 = vec2(0.75,0.25);\n             p2 = vec2(0.5,0.5);   \n        }\n        \n        \n        if (opc==4)\n        {\n             p0 = vec2(0.25,0.25);\n             p1 = vec2(0.5,0.5);\n             p2 = vec2(0.25,0.75);   \n        }\n      \n    \n    // add more points\n    vec2[] polygon = vec2[](p0, p1,p2);\n    \n\tfloat d = sdPolygon(p, polygon);\n    \n    return d;\n}", "sound_code": "//sonido modificado por jorge flores ---jorge2017a1\n//https://www.shadertoy.com/view/XdlyDM\n\nvec2 mainSound( in int samp, float i )\n{ float t=fract(i/52.)*52.;\n    float b=fract(t/4.)<5./6.?180.*acos(-1.):108.*acos(-1.);\n \n \n \tvec2 c1=vec2( sin(b*t)*exp(-3.0*fract(t/2.)),sin(b*t)*exp(-5.0*fract(--t/2.)) );\n \tvec2 c2=vec2( sin(b*floor(t/8.)*(t))*exp(-2.0*fract(t*3.+.5)));\n    vec2 c3=clamp( vec2( sin(b*floor((t+1.8)/8.)*(t))*exp(-3.0*fract(t*1.5+.5))),.2,.8);\n \tvec2 c4=vec2( sin(b*floor(t/4.)*(t)+2.0*sin(b*t*0.5))*exp(-2.0*fract(t*3.+.5)));\n    vec2 sum=c1+c2+c3+ c4;\n        \n    return sum;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 273, 273, 295], [296, 296, 329, 329, 351], [352, 352, 385, 385, 406], [409, 409, 441, 472, 540], [542, 542, 573, 604, 674], [676, 676, 708, 733, 801], [803, 803, 831, 831, 870], [873, 873, 911, 911, 963], [967, 967, 998, 998, 1024], [1027, 1027, 1064, 1064, 1144], [1152, 1152, 1185, 1185, 1236], [1239, 1239, 1260, 1260, 1947], [1950, 1950, 1975, 1975, 2239], [2241, 2241, 2271, 2271, 2674], [2679, 2679, 2713, 2713, 3092], [3098, 3098, 3126, 3126, 3432], [3439, 3439, 3496, 3546, 4748]], "test": "untested"}
{"id": "tsVBDW", "name": "rainbow noodle orbs", "author": "mattz", "description": "Randomly generated Truchet tilings of spherical polyhedra. Mouse rotates. Press E to toggle edges.\n\nHappy noodling!", "tags": ["truchet", "tiling", "spherical", "polyhedron", "woven", "wythoff"], "likes": 32, "viewed": 637, "published": 3, "date": "1607906423", "time_retrieved": "2024-07-30T20:30:33.826896", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// \"rainbow noodle orbs\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// What it does: woven Truchet tilings of spherical polyhedra.\n//\n// Why: Looks neat\n//\n// This one was fun to write! Lots of technical challenges along the \n// way, but especially figuring out how to address all of the \n// polygon vertices of a particular polygon face, and also figuring\n// out how to do G1 continuous splines on the surface of a sphere\n// with analytic distance functions.\n//\n//////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float TOL = 1e-5;\n\n#define MAX_POLYGON 10\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/XlGcRh \n// original by Dave Hoskins\n\nvec3 hashwithoutsine31(float p) {\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hashwithoutsine33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat hashwithoutsine11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//////////////////////////////////////////////////////////////////////\n// some more hash and RNG functions\n\n// get random color from a sphere vec\nvec3 random_color_from_sphere(vec3 x) {\n    return hashwithoutsine33(floor(25.*x + 0.5));    \n}\n\n// fisher-yates shuffle of array\nvoid shuffle(inout int idx[2*MAX_POLYGON], in int cnt, in float seed) {\n    \n    int i = cnt - 1;\n \n    for (int iter=0; iter<2*MAX_POLYGON; ++iter) {\n        if (i < 1) { break; }\n        int j = int(floor(hashwithoutsine11(seed) * float(i+1)));\n        if (j < 0 || j > i) {\n            for (int k=0; k<2*MAX_POLYGON; ++k) {\n                idx[k] = k % 2;\n            }\n            return;\n        }\n        int tmp = idx[i];\n        idx[i] = idx[j];\n        idx[j] = tmp;\n        i -= 1;\n        seed += 1.0;\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// if point p lies opposite m, mirror it. return the transform that\n// accomplishes this.\n\nmat3 mirror(inout vec3 p, in vec3 m) {\n    \n    float d = dot(p, m);\n    mat3 rval = mat3(1.) - (2. * step(d, 0.)) * outerProduct(m, m);\n        \n    p = (rval * p);\n        \n    return rval;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// modify the vector m to halve the angle with respect to the y\n// axis (assume that m.z == 0)\n\nvec3 half_angle(in vec3 m) {\n    return normalize(vec3(m.x - 1.0, m.y, 0.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about arbitrary axis/angle\n\nmat3 rotate(in vec3 k, in float t) {\n    \n    if (abs(t) < TOL) {\n        return mat3(1.);\n    }\n    \n    mat3 K = mat3(0, k.z, -k.y,\n                  -k.z, 0, k.x,\n                  k.y, -k.x, 0);\n                  \n    return mat3(1.) + (mat3(sin(t)) + (1. - cos(t))*K)*K;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// wythoff construction - mammoth function using code stolen\n// from https://www.shadertoy.com/view/Md3yRB\n\nvoid construct(in vec3 pqr, in int spoint, in vec3 pos,\n               out mat3 tri_verts, \n               out mat3 tri_edges, \n               out vec3 poly_vertex, \n               out mat3 poly_edges, \n               out int Q_vidx, \n               out int Q_vidx2, \n               out int Q_eidx, \n               out mat3 M, \n               out float pdist_poly_edge) { \n\n    //////////////////////////////////////////////////////////////////////\n    // part 1: construct the Schwartz triangle \n\n\n    mat4x3 spoints;\n    bvec3 is_face_normal;\n\n    float p = pqr.x;\n    float q = pqr.y;\n    float r = pqr.z;\n\n    float tp = PI / p;\n    float tq = PI / q;\n    float tr = PI / r;\n\n    float cp = cos(tp), sp = sin(tp);\n    float cq = cos(tq);\n    float cr = cos(tr);\n\n    vec3 lr = vec3(1, 0, 0);\n    vec3 lq = vec3(-cp, sp, 0);\n    vec3 lp = vec3(-cq, -(cr + cp*cq)/sp, 0);\n    \n    lp.z = sqrt(1.0 - dot(lp.xy, lp.xy));\n    \n    tri_edges = mat3(lp, lq, lr);\n    \n    vec3 vP = normalize(cross(lr, lq));\n    vec3 vR = normalize(cross(lq, lp));\n    vec3 vQ = normalize(cross(lp, lr));\n    \n    tri_verts = mat3(vP, vQ, vR);\n\n    if (spoint < 3) {\n        poly_vertex = tri_verts[spoint];\n    } else if (spoint == 3) {\n        poly_vertex = normalize(cross(lq - lr, lp));\n    } else if (spoint == 4) {\n        poly_vertex = normalize(cross(lr - lp, lq));\n    } else if (spoint == 5) {\n        poly_vertex = normalize(cross(lp - lq, lr));\n    } else {\n        poly_vertex = normalize(cross(lp-lq, lr-lp));\n    }\n    \n    is_face_normal = bvec3(true);\n    \n    for (int i=0; i<3; ++i) {\n        poly_edges[i] = normalize(cross(poly_vertex, tri_edges[i]));\n        for (int j=0; j<2; ++j) {\n            int vidx = (i+j+1)%3;\n            if (abs(dot(tri_verts[vidx], poly_edges[i])) < TOL) {\n                is_face_normal[vidx] = false;\n            }\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // part 2: use space folding to make sure pos lies in the triangular \n    // cone whose edge planes are given by tri_edges\n    //\n    // this part of the function was largely determined by trial and\n    // error. possibly if I understood more about symmetry I would be\n    // able to get it a little simpler\n\n    \n    ////////////////////////////////////////////////////\n    // part 2a: guarantee that the point lives inside\n    // the cluster of p triangles that share the vertex\n    // (0, 0, 1)\n    \n    M = mirror(pos, vec3(1, 0, 0));\n    \n    vec3 m = tri_edges[0];\n\n    for (float i=0.; i<5.; ++i) {\n\n        // mirror\n        M *= mirror(pos, m);\n        m -= tri_edges[1] * 2.0 * dot(m, tri_edges[1]);\n\n        M *= mirror(pos, m);\n        m -= tri_edges[2] * 2.0 * dot(m, tri_edges[2]);\n\n    }\n\n    ////////////////////////////////////////////////////\n    // part 2b: fold in the XY plane to make sure the \n    // point lives in the triangular cone just to the\n    // right of the y axis\n       \n    M *= mirror(pos, vec3(1, 0, 0));\n    \n    //float p = pqr.x;\n    float k = p >= 5.0 ? 4. : p >= 3.0 ? 2. : 1.;\n    \n    float theta = k * PI / p;\n\n    m = vec3(-cos(theta), sin(theta), 0); // lq\n    \n    if (p >= 5.0) {        \n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    if (p >= 3.0) {\n        M *= mirror(pos, m);\n        m = half_angle(m);\n    }\n    \n    M *= mirror(pos, m);    \n\n    //////////////////////////////////////////////////////////////////////\n    // part 3 - fill in the rest of the query\n       \n    // position relative to vertex\n    vec3 rel_pos = pos - poly_vertex;\n    \n    // closest vertices and edge\n    Q_vidx = -1;\n    Q_eidx = -1;\n    Q_vidx2 = -1;\n             \n    // for each potential face edge (perpendicular to each tri. edge)\n    for (int eidx=0; eidx<3; ++eidx) {   \n        \n        vec3 tri_edge = tri_edges[eidx];\n                        \n        // polyhedron edge cut plane (passes thru origin and V, perpendicular\n        // to triangle edge)\n        vec3 poly_edge = poly_edges[eidx];\n                                \n        // signed distance from point to face edge\n        float poly_edge_dist = dot(pos, poly_edge);\n\n        // triangle vertex on the same side of face edge as point\n        int vidx = (eidx + (poly_edge_dist > 0. ? 2 : 1)) % 3;\n        \n        // triangle vertex on opposite side of face edge as point\n        int vidx2 = (eidx + (poly_edge_dist > 0. ? 1 : 2)) % 3;\n        if (!is_face_normal[vidx2]) { vidx2 = vidx; }\n                       \n        // construct at the other polyhedron edge associated with the given\n        // triangle vertex\n        vec3 other_poly_edge = poly_edges[3-eidx-vidx];\n        \n        // construct the plane that bisects the two polyhedron edges\n        vec3 bisector = cross(poly_vertex, poly_edge - other_poly_edge);\n        \n        float bisector_dist = dot(pos, bisector);\n             \n        if (bisector_dist >= 0.) {\n            // if we are on the correct side of the associated\n            // bisector, than we have found the closest triangle\n            // edge & vertex.\n            \n            //Q.pdist_bisector = bisector_dist;\n            pdist_poly_edge = poly_edge_dist;\n            Q_eidx = eidx;\n            Q_vidx = vidx;\n            Q_vidx2 = vidx2;\n            \n        }\n \n    }\n    \n}   \n\n//////////////////////////////////////////////////////////////////////\n// make a spherical polygon by repeated reflection across 2 edges\n//\n// inputs:\n//\n//   v: initial vertex position inside original triangle\n//   a: first edge of orig. triangle to reflect across\n//   b: second edge of orig. triangle to reflect across\n//   M: transformation matrix that maps original verts to dst pos\n//   \n\nint make_polygon(vec3 v, vec3 a, vec3 b, mat3 M, out vec3 polygon[MAX_POLYGON]) {\n    \n    // polygon always includes the starting position\n    polygon[0] = v;\n\n    // index of last set polygon vertex\n    int k = 0;\n    \n    // hold pair of edges and swap back and forth\n    vec3 edges[2] = vec3[2]( a, b );\n    \n    // always start by mirroring across the edge v is not on\n    int cur_edge = (abs(dot(v, edges[0])) < 0.01) ? 1 : 0;\n            \n    // we can get 0 or 1 vertex per iter, up to 10 vertices\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        \n        // reflect vertex across cur edge\n        v = normalize(reflect(v, edges[cur_edge]));\n        \n        // reflect other edge across cur edge\n        edges[1-cur_edge] = normalize(reflect(edges[1-cur_edge], edges[cur_edge]));\n        \n        if (dot(v, polygon[0]) > 0.99) {\n            // if we have wrapped around back to the start, done!\n            break;\n        } else if (dot(v, polygon[k]) < 0.99) {\n            // if the vertex was moved by the last reflection add it to the polygon\n            k += 1;\n            polygon[k] = v;\n        }\n        \n        // swap edges\n        cur_edge = 1 - cur_edge;\n        \n    }\n    \n    int npoly = k + 1;\n    if (npoly < 3) { return npoly; }\n    \n    // determine winding order (CW or CCW) and flip if necessary \n    bool flip = dot(M*polygon[0], cross(M*polygon[1], M*polygon[2])) < 0.;\n    \n    // transform points from orig triangle to dst pos\n    // and invert order if necessary; also figure out which is\n    // canonical index 0 using a hash function\n    vec3 Mpolygon[MAX_POLYGON];\n    \n    float dmin = 1e5;\n    \n    const vec3 dir = vec3(0.7027036 , 0.68125974, 0.56301879);\n    \n    int imin = 0;\n\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        if (i >= npoly) { break; }\n        Mpolygon[i] = M * polygon[flip ? npoly - i - 1 : i];\n        float d = dot(dir, Mpolygon[i]);\n        if (d < dmin) {\n            imin = i;\n            dmin = d;\n        }\n    }\n    \n    // shift elements to start at index 0\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        if (i >= npoly) { break; }\n        polygon[i] = Mpolygon[(i + imin) % npoly];\n    }\n    \n    // number of points in the polygon\n    return npoly;\n    \n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n// distance between points on sphere\n\nfloat sdist(vec3 a, vec3 b) {\n    return acos(clamp(dot(a, b), -1.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arc on sphere\n//\n// inputs: \n//\n//   p: query point (unit vector)\n//   c: arc center point (unit vector)\n//   r: arc radius in radians\n//   l: lower tangent (unit vector)\n//   w: upper tangent (unit vector)\n\nfloat darc(vec3 p, vec3 p0, vec3 c, float r, vec3 l, vec3 w, vec3 p1) {\n    \n    if (dot(p, l) < 0.) {\n        return sdist(p, p0);\n    } else if (dot(p, w)*dot(p0, w) < 0.) {\n        return sdist(p, p1);\n    } else {\n        return abs(sdist(p, c) - r);\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n//\n// adapted from https://www.shadertoy.com/view/3dVfzc with some\n// bugfixes and improvements\n//\n// compute a spline on the sphere made of two arcs that are tangent \n// to each other have desired tangents at given points\n//\n// inputs:\n//\n//    p: query point on sphere\n//\n//   p0: first point on sphere (unit vector)\n//   l0: tangent vector at p0 (unit vector with dot(p0, l0) = 0)\n//   p1: second point on sphere (unit vector) \n//   l1: tangent vector at p1 (unit vector with dot(p1, l1) = 0)\n//\n// output: distance to spline\n\nfloat compute_spline(in vec3 p,\n                     in vec3 p0, in vec3 l0,\n                     in vec3 p1, in vec3 l1) {\n                         \n    // compute the line connecting p0 & p1\n    vec3 tmp = normalize(cross(p0, p1));\n    \n    vec3 c0, c1, m, w;\n    float r;\n\n    // special case: p0, p1 coincident\n    if (dot(p0, p1) > 0.999) {\n        return sdist(p, p0);\n    }\n    \n    vec3 q = normalize(cross(l0, l1));\n\n    bool single_arc = false;\n\n    // special case: p0 and p1 are connected by a segment of a great circle\n    // the line from p0 to p1 hits them at the correct tangents \n    if (max(abs(dot(tmp, l0)), abs(dot(tmp, l1))) < 0.001) {\n    \n        c0 = normalize(cross(l0, l1));\n        c1 = c0;\n        \n        r = 0.5*PI;\n        \n        m = normalize(l0 + l1);\n        w = normalize(cross(m, c0));\n        \n        single_arc = true;\n        \n    } else if (dot(l0, l1) > 0.999) {\n        \n        // special case: single arc along common edge\n        c0 = normalize(p0 + p1);\n        c1 = c0;\n        \n        float c = dot(c0, p0);\n        \n        r = acos(c);\n        \n        m = c * c0 + sqrt(1.0 - c*c) * l0;\n        w = normalize(cross(l0, c0));\n                \n        single_arc = true;\n        \n    } else if (abs(dot(q, p0) - dot(q, p1)) < 1e-3) {\n    \n        // special case: single arc around intersection of edges\n\n        c0 = q;\n        c1 = q;\n        \n        float c = dot(c0, p0);\n        \n        r = acos(c);\n        \n        vec3 l = normalize(l0 + l1);\n        \n        m = c*q + sqrt(1.0 - c*c)*l;\n        w = normalize(cross(c0, m));\n        \n        single_arc = true;\n        \n    }\n    \n    if (single_arc) {\n    \n        vec3 P, L;\n\n        if (dot(p, w) * dot(p0, w) > 0.) {\n            P = p0;\n            L = l0;\n        } else {\n            P = p1;\n            L = l1;\n        }\n\n        if (dot(p, L) < 0.) {\n            return sdist(p, P);\n        } else {\n            return abs(sdist(p, c0) - r);\n        }\n        \n    }\n    \n    // compute the points orthogonal to (l0, p0) and (l1, p1), respectively\n    vec3 a0 = cross(l0, p0);\n    vec3 a1 = cross(l1, p1);\n    \n    // we will construct arc centers \n    //\n    //   c0 = cos(r) * p0 + sin(r) * a0\n    //   c1 = cos(r) * p1 + sin(r) * a1\n    //\n    // which are a distance r away from p0 & p1 respectively\n    // by construction, dot(c0, l0) = dot(c1, l1) = 0\n    //\n    // now we want to solve for r such that dot(c0, c1) = cos(2*r)\n    //\n    // start by observing that \n    //\n    //   (cos(r)²       * a +\n    //    cos(r)*sin(r) * b\n    //    sin(r)²       * c) = cos(2r)\n    //\n    // where a = dot(p0, p1), b = dot(p0, a1) + dot(p1, a0), and \n    // c = dot(a0, a1).\n    //\n    // applying the half angle identities and setting θ = 2r, we find\n    //\n    //   a*(1 + cos(θ))/2 + b*sin(θ)/2 + c*(1 - cos(θ))/2 = cos(θ)\n    //   a*(1 + cos(θ)) + b*sin(θ)+ c*(1 - cos(θ)) = 2*cos(θ)\n    //   (a - c - 2)*cos(θ) + b*sin(θ) = -(a + c)\n    //\n    // we can rewrite that as\n    //\n    //   d*cos(θ) + b*sin(θ) = e\n    //\n    // where d = a - c - 2 and e = -(a + c).\n    //\n    // finally, we can rewrite that as\n    //\n    //   α*cos(θ - φ) = e\n    //\n    // where α = sqrt(d² + b²) and φ = atan(b, d).\n    // the solution is given by\n    //\n    //   θ = φ ± acos(e / α)\n    //\n    // and r = 0.5 * θ.\n    \n    float a = dot(p0, p1);\n    float b = dot(p0, a1) + dot(p1, a0);\n    float c = dot(a0, a1);\n    \n    float d = (a - c - 2.);\n    float e = -(a + c);\n    \n    float alpha = length(vec2(d, b));\n    float phi = atan(b, d); // in [-pi, pi]\n    float tau = acos(e/alpha); // in [0, pi]\n\n    // we want the r with the least magnitude so choose tau with the \n    // opposite sign as phi\n    r = 0.5 * (phi > 0. ? phi - tau : phi + tau);\n\n    // now get c0 & c1\n    float cr = cos(r);\n    float sr = sin(r);\n\n    c0 = normalize(cr*p0 + sr*a0);\n    c1 = normalize(cr*p1 + sr*a1);\n    \n    // m is the midpoint of c0 & c1, the point\n    // of mutual tangency of the two arcs\n    m = normalize(c0 + c1);\n    \n    // get the line connecting c0 & c1\n    w = normalize(cross(c0, c1));\n    \n    // no longer need the sign of r, want it positive to compute distances later\n    r = abs(r);\n    \n    float d0 = darc(p, p0, c0, r, l0, w, m);\n    float d1 = darc(p, p1, c1, r, l1, w, m);\n        \n    return min(d0, d1);\n                     \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a nice saturated color from a random color\n\nvec3 saturate_color(vec3 c) {\n    \n    float lo = min(c.x, min(c.y, c.z));\n    float hi = max(c.x, max(c.y, c.z));\n    \n    lo = min(lo, hi-0.05);\n    \n    return (c - lo) / (hi - lo);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// draw the Truchet tiling given unique id for the sphere\n\nvec3 draw_truchet(vec3 p, float id, float aa_scl) {\n\n    // generate some random variables for this sphere\n    vec3 r = hashwithoutsine31(19.*id + 101.);\n        \n    // choose tetraheral, octohedral, or icosahedral symmetry\n    float pqr_p = 3.0 + floor(r.x * 3.0);\n\n    // which of the 7 key points to place the vertex at?\n    int spoint = int(floor(r.y * 7.0));\n\n    // random bits used to influence shuffling & per-tile colors\n    float extra = r.z * 1024.;\n\n    // generate a random rotation for this sphere\n    vec3 axis_angle = 2.*PI*hashwithoutsine31(id);\n    \n    float angle = length(axis_angle);\n    vec3 axis = axis_angle / angle;\n    \n    // rotate the point\n    p = rotate(axis, angle)*p;\n    \n    \n    //////////////////////////////////////////////////\n    // do wythoff construction for this sphere\n        \n    mat3 verts, edges, poly_edges, M;\n    vec3 poly_vertex;\n    int vidx, eidx, vidx2;\n    float pdist_poly_edge;\n    \n    construct(vec3(pqr_p, 3, 2), spoint, p, \n              verts, edges, poly_vertex, poly_edges, \n              vidx, vidx2, eidx, M, pdist_poly_edge);\n    \n    \n    // get face background color\n    vec3 tri_vert = M * verts[vidx];\n    \n    vec3 face = M * verts[vidx];\n    vec3 face2;\n    \n    if (vidx2 == vidx) {\n        face2 = M * reflect(verts[vidx], poly_edges[eidx]);\n    } else {\n        face2 = M * verts[vidx2]; \n    }\n        \n    face = random_color_from_sphere(face);\n    face2 = random_color_from_sphere(face2);\n    \n    face = mix(face2, face, smoothstep(-0.5*aa_scl, 0.5*aa_scl, abs(pdist_poly_edge)));\n    \n    vec3 color = 0.3*face + 0.65;\n       \n    //////////////////////////////////////////////////\n    // construct the polygon by mirroring the \n    // polygon vertex around the triangle vertex\n    // until we get back to where we started\n       \n    vec3 polygon[MAX_POLYGON];\n    \n    int a_eidx = (vidx + 1) % 3;\n    int b_eidx = 3 - vidx - a_eidx;\n\n    vec3 a = edges[a_eidx];\n    vec3 b = edges[b_eidx];\n    \n    int npoly = make_polygon(poly_vertex, a, b, M, polygon);\n    \n    // get the lines / tangent vectors for each polygon\n    // edge, and get two node points per polygon edge    \n    vec3 pedges[MAX_POLYGON];\n    vec3 nodes[2*MAX_POLYGON];\n    \n    // array of indices that will be shuffled to \n    // connect pairs of nodes\n    int idx[2*MAX_POLYGON];\n\n    // precompute some coefficients to do \n    // spherical linear interpolation (slerp)\n    // along polygon edge\n    float p0p1 = dot(polygon[0], polygon[1]);\n    \n    float phi = acos(p0p1);\n    float sphi = sqrt(1.0 - p0p1*p0p1);\n    float u = 0.3;\n    \n    // here's the slerp weights!\n    float w0 = sin(u*phi)/sphi;\n    float w1 = sin((1.-u)*phi)/sphi;\n\n    // loop around the polygon generating nodes\n    // and edges\n    for (int i=0; i<MAX_POLYGON; ++i) {\n        \n        if (i >= npoly) { break; }\n        \n        vec3 p0 = polygon[i];\n        vec3 p1 = polygon[(i+1) % npoly];\n        \n        pedges[i] = normalize(cross(p0, p1));\n        \n        nodes[2*i+0] = w0*p0 + w1*p1;\n        nodes[2*i+1] = w1*p0 + w0*p1;\n        \n        idx[2*i+0] = 2*i+0;\n        idx[2*i+1] = 2*i+1;  \n        \n    }\n    \n    // now generate a random seed for this polygon face\n    const vec3 dir = vec3(0.876096, 0.80106629, 0.13512217);\n    float seed = floor(63.*dot(tri_vert, dir)+0.5) + extra;\n\n    // shuffle the order of nodes (we will connect up \n    // nodes with successive indices)\n    shuffle(idx, 2*npoly, seed);    \n\n    //////////////////////////////////////////////////\n    // time to draw the splines between the nodes\n\n    // for computing shadowing \n    float shadow = 1.0;\n    bool was_painted = false;\n    \n    // half-width of splines that connect the nodes\n    float width = 0.09*acos(p0p1);\n\n    // shadow size\n    float sz = 0.04 + 0.5*width;\n\n    // for each pair of nodes\n    for (int i=0; i<MAX_POLYGON; ++i) {\n    \n        if (i >= npoly) { break; }       \n        \n        // get points and tangent vectors\n        vec3 p0 = nodes[idx[2*i+1]];\n        vec3 l0 = pedges[idx[2*i+1]/2];\n\n        vec3 p1 = nodes[idx[2*i+0]];\n        vec3 l1 = pedges[idx[2*i+0]/2];\n \n        // compute distance to spline\n        float d = compute_spline(p, p0, l0, p1, l1);\n        \n        // deal with shadowing previously-drawn splines\n        bool is_painted = d < width + 0.005;\n        \n        if (is_painted) {\n            // current pixel in current spline, clear shadow\n            shadow = 1.0;\n            was_painted = true;\n        } else if (was_painted) {\n            // current pixel outside spline, shadow non-background pixels\n            shadow = min(shadow, smoothstep(width - 0.25*sz, width + sz, d));\n        }\n        \n        // pick a spline color\n        vec3 src_color = saturate_color(hashwithoutsine31(seed));\n        seed += 1.0;\n    \n        // draw outline and spline\n        color *= smoothstep(0.0, aa_scl, d-width-0.01);        \n        color = mix(src_color, color, smoothstep(0.0, aa_scl, d-width));\n\n    }\n    \n    // deal with shadowing\n    color *= shadow;\n    \n    if (texture(iChannel0, vec2(69.5/256.0, 0.75)).x > 0.) {\n        color *= smoothstep(0.0, aa_scl, abs(pdist_poly_edge)-0.005);\n    }\n        \n    // done!\n    return color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// ray-sphere intersection\n\nconst vec4 miss = vec4(-1);\n\nvec4 trace_sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r, \n                  out float edge) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    float tc = -dot(oc, d) / a;\n    \n    // distance from ray to sphere center, minus radius\n    // should be zero for rays tangent to sphere\n    edge = length(oc + tc*d) - r;\n        \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n//////////////////////////////////////////////////////////////////////\n// do the things\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // distance from camera to sphere centers\n    const float cdist = 10.0;\n    \n    // focal length in pixels\n    float f = 0.25/iResolution.y;\n    \n    // pixel size on center of sphere for antialiasing\n    float aa_scl = (cdist - 1.0)*f;\n\n    // rotation vector\n    vec2 theta;\n    \n    // phase\n    float t = iTime;\n    \n    // default rotation\n    theta.y = 2.*PI*t/4.;\n    theta.x = 2.*PI*t/16.0; // note we add a wiggle to this below\n   \n    // scroll speed \n    float shift = 0.25*t;\n    \n    // mouse sets rx & ry\n    bool mouse_is_down = false;\n\n    if (max(iMouse.z, iMouse.w) > 0.05*iResolution.y) { \n        theta.x = (iMouse.y - .5*iResolution.y) * -5.0/iResolution.y; \n        theta.y = (iMouse.x - .5*iResolution.x) * 10.0/iResolution.x; \n        mouse_is_down = true;;\n    }\n\n    // integer and fractional part for drawing scrolling spheres\n    float scroll = shift - floor(shift+0.5);\n    float base_idx = -floor(shift+0.5);\n\n    // light direction\n    const vec3 L = normalize(vec3(-0.75, 1, -0.75));\n\n    // ray origin and direction\n    vec3 rd = normalize(vec3(f*(fragCoord.xy - 0.5*iResolution.xy), 1));\n    vec3 ro = vec3(0, 0, -cdist);\n    \n    // for drawing circle edges\n    float edge_min = 1e5;\n    vec3 color = vec3(1);\n    \n    // sphere spacing\n    const float spacing = 2.5;\n    \n    // max # of spheres\n    const float max_spheres = 3.0;\n    \n    // draw spheres (note we will intersect at most one of them)\n    for (float i=0.0; i<max_spheres; ++i) {\n    \n        // x coordinate of sphere center\n        float cx = (i - 0.5*max_spheres+0.5 + scroll)*spacing;\n\n        // raytrace to sphere\n        float edge;\n        vec4 intersect = trace_sphere(ro, rd, vec3(cx, 0, 0), 1.0, edge);\n        edge_min = min(edge, edge_min);\n\n        if (intersect.w >= 0.0) { // did we hit?\n                        \n            // figure out unique sphere id\n            float hit_idx = i + base_idx;\n        \n            // figure out whether to wiggle x rotation\n            float rx;\n        \n            if (mouse_is_down) {\n                rx = theta.x;\n            } else {\n                rx = 0.35*PI*sin(theta.x + 2.0*PI*hit_idx/8.);\n            }\n            \n            // intersection normal\n            vec3 p = intersect.xyz;\n\n            // rotate on sphere\n            vec3 Rp = rotate(vec3(0, 1, 0), theta.y)*rotate(vec3(1, 0, 0), rx)*p;\n\n            // draw our truchet tiling\n            color = draw_truchet(Rp, hit_idx, aa_scl);\n\n            // fake wrapped cosine lighting\n            color *= 0.2*dot(p, L) + 0.8;\n\n            // gentle specular highlight\n            vec3 h = normalize(L - rd);\n            float specAngle = max(dot(h, p), 0.0);\n            float specular = pow(specAngle, 30.0);\n\n            color = mix(color, vec3(1.0), 0.5*specular);\n\n            // no more spheres to hit, done!\n            break;\n            \n        } \n        \n    }\n\n    // draw sphere outline\n    color *= smoothstep(0.0, aa_scl, abs(edge_min)-0.005);\n\n    // \"gamma correct\" :P\n    color = pow(color, vec3(0.7));\n\n    fragColor = vec4(color, 1);\n    \n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVBDW.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[866, 866, 899, 899, 1035], [1037, 1037, 1070, 1070, 1194], [1196, 1196, 1230, 1230, 1315], [1425, 1463, 1502, 1502, 1558], [1560, 1593, 1664, 1664, 2114], [2278, 2278, 2316, 2316, 2476], [2645, 2645, 2673, 2673, 2724], [2835, 2835, 2871, 2871, 3113], [3294, 3294, 3665, 3790, 8587], [8987, 8987, 9068, 9126, 11218], [11331, 11331, 11360, 11360, 11408], [11704, 11704, 11775, 11775, 11967], [12570, 12570, 12693, 12762, 16953], [17078, 17078, 17107, 17107, 17269], [17401, 17401, 17452, 17507, 22631], [22761, 22761, 22862, 22862, 23481], [23572, 23572, 23629, 23680, 26725]], "test": "untested"}
{"id": "tdKBWy", "name": "Holiday Greetings!", "author": "oneshade", "description": "I just had to whip up a holiday shader and I am very proud of the final result! Happy holidays and merry christmas!", "tags": ["christmas", "winter", "peanuts", "snoopy", "shaderart", "holidays", "charliebrown", "happyholidays", "greeting"], "likes": 17, "viewed": 276, "published": 3, "date": "1607901279", "time_retrieved": "2024-07-30T20:30:34.775360", "image_code": "/*\nBig thank you to Inigo Quilez's 2D distance function and smooth minimum articles!\n2D distance functions article: https://iquilezles.org/articles/distfunctions2d\nSmooth minimum article: https://iquilezles.org/articles/smin\nThe smin(), ellipse(), and line() functions are taken from them.\n*/\n\nconst float SIN_20  =  0.34202014332;\nconst float COS_20  =  0.93969262078;\n\nconst float SIN_40  =  0.64278760968;\nconst float COS_40  =  0.76604444311;\n\nconst float SIN_150 =  0.50000000000;\nconst float COS_150 = -0.86602540378;\n\nconst float SIN_315 = -0.70710678118;\nconst float COS_315 =  0.70710678118;\n\nfloat noise(in float x) {\n    return fract(sin(x * 12.5673) * 573.123);\n}\n\nfloat snoise(in float x) {\n    const float r = 2.735;\n    x += 4657.247;\n    float c = floor(x / r) * r;\n    float l = fract(x / r); l *= l * (3.0 - 2.0 * l);\n    return mix(noise(c), noise(c + r), l);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat ellipse(in vec2 p, in vec2 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat isosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x), p.y += h / 3.0;\n    vec2 pr = p - vec2(b, 0.0), tr = vec2(-b, h);\n    vec2 be = p - vec2(b * clamp(p.x / b, 0.0, 1.0), 0.0);\n    vec2 re = pr - tr * clamp(dot(pr, tr) / dot(tr, tr), 0.0, 1.0);\n    return sqrt(min(dot(be, be), dot(re, re))) * sign(p.x - b / h * (h - p.y) * sign(p.y));\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.25, 0.25, 1.0);\n\n    // Snowy hill\n    vec2 hillUV = uv;\n    hillUV.x *= 0.3;\n    hillUV.y += 0.05;\n    float hill = hillUV.y + hillUV.x * hillUV.x;\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, hill));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(hill)));\n\n    // Tree trunk\n    vec2 trunkUV = uv;\n    trunkUV.x += 0.4;\n    float trunk = max(abs(trunkUV.x) - 0.04, abs(trunkUV.y) - 0.2);\n    color = mix(color, vec3(0.6, 0.3, 0.0), smoothstep(unit, 0.0, trunk));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(trunk)));\n\n    // Tree branches\n    vec2 treeUV = uv;\n    treeUV -= vec2(-0.4, 0.07);\n    float treeUnit = unit;\n    for (int i=0; i < 3; i++) {\n        float branches = isosceles(treeUV, 0.25, 0.3);\n        color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(treeUnit, 0.0, branches));\n        color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(treeUnit, 0.0, abs(branches)));\n        treeUV.y -= 0.15;\n        treeUV *= 1.5;\n        treeUnit *= 1.5;\n    }\n\n    // Snowman body\n    vec2 snowmanUV = uv - vec2(0.1, -0.2);\n    float snowmanDist = 1000000.0;\n    float scale = 1.0;\n    for (int i=0; i < 3; i++) {\n        float snowball = (length(snowmanUV) - 0.125) / scale;\n        snowmanDist = min(snowmanDist, snowball);\n        snowmanUV.y -= 0.175;\n        snowmanUV *= 1.25;\n        scale *= 1.25;\n    }\n\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, snowmanDist));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(snowmanDist)));\n\n    // Snowman nose\n    snowmanUV = uv - vec2(0.1, 0.085);\n    snowmanUV.x = abs(snowmanUV.x);\n    snowmanUV.y *= -1.0;\n    float nose = isosceles(snowmanUV, 0.015, 0.06);\n    color = mix(color, vec3(1.0, 0.6, 0.0), smoothstep(unit, 0.0, nose));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(nose)));\n\n    // Snowman eyes\n    float eyes = length(snowmanUV - vec2(0.03, -0.05)) - 0.01;\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, eyes));\n\n    // Snowman buttons\n    float bbox = abs(snowmanUV.y - 0.15) - 0.1;\n    snowmanUV.y -= 0.275;\n    snowmanUV.y = mod(snowmanUV.y, 0.08) - 0.04;\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, max(length(snowmanUV) - 0.01, bbox)));\n\n    // Charlie Brown's legs\n    vec2 legsUV = uv - vec2(0.57, -0.15);\n    legsUV.x = abs(legsUV.x);\n    legsUV.x -= 0.06;\n\n    float legs = max(abs(legsUV.x) - 0.03, abs(legsUV.y) - 0.1);\n    color = mix(color, vec3(0.9, 0.702, 0.5), smoothstep(unit, 0.0, legs));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(legs)));\n\n    // Charlie Brown's pants\n    float pants = max(abs(legsUV.x) - 0.045, abs(legsUV.y) - 0.04);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, pants));\n\n    // Charlie Brown's shoes\n    vec2 shoesUV = uv - vec2(0.55, -0.25);\n    shoesUV.x = abs(shoesUV.x) - 0.06;\n    bbox = -(shoesUV.y + 0.01);\n    float shoes = max(ellipse(shoesUV, vec2(0.055, 0.04)), bbox);\n    color = mix(color, vec3(0.8, 0.5, 0.0), smoothstep(unit, 0.0, shoes));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(shoes)));\n\n    // Charlie Brown's arms\n    vec2 armsUV = uv;\n    armsUV -= vec2(0.565, -0.08);\n\n    armsUV.x = abs(armsUV.x);\n    armsUV *= mat2(COS_20, SIN_20, -SIN_20, COS_20);\n    armsUV.x -= 0.09 + 0.05 * sin(8.0 * armsUV.y + 1.57);\n\n    float arms = line(armsUV, vec2(0.0, 0.1), vec2(0.0, -0.1)) - 0.0275;\n    color = mix(color, vec3(0.9, 0.702, 0.5), smoothstep(unit, 0.0, arms));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(arms)));\n\n    // Charlie Brown's shirt\n    vec2 shirtUV = uv - vec2(0.565, -0.09);\n    bbox = -(shirtUV.y + 0.075);\n    float shirt = max(ellipse(shirtUV, vec2(0.125, 0.2)), bbox);\n\n    // Charlie Brown's neck\n    vec2 neckUV = shirtUV;\n    neckUV.y -= 0.2;\n    float neck = max(abs(neckUV.x) - 0.035, abs(neckUV.y) - 0.05);\n    color = mix(color, vec3(0.9, 0.702, 0.5), smoothstep(unit, 0.0, neck));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(neck)));\n\n    // Charlie Brown's head\n    vec2 headUV = shirtUV;\n    headUV.y -= 0.32;\n    float head = length(headUV) - 0.1;\n\n    // Charlie Brown's ears\n    vec2 earsUV = headUV;\n    earsUV.x = abs(earsUV.x) - 0.095;\n    float ears = length(earsUV) - 0.025;\n    head = min(head, ears);\n\n    color = mix(color, vec3(0.9, 0.702, 0.5), smoothstep(unit, 0.0, head));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(head)));\n\n    // Charlie Brown's eyes\n    vec2 eyesUV = headUV;\n    eyesUV.y -= 0.02;\n    eyesUV.x = abs(eyesUV.x) - 0.04;\n    eyes = length(eyesUV) - 0.01;\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, eyes));\n\n    // Charlie Brown's hair\n    vec2 hairUV = eyesUV;\n    hairUV -= vec2(-0.0175, 0.05);\n    bbox = hairUV.y;\n    float hair = max(abs(ellipse(hairUV, vec2(0.0225, 0.02))), bbox);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, hair));\n\n    // Charlie Brown's nose\n    vec2 noseUV = headUV;\n    noseUV.y += 0.015;\n    nose = max(abs(length(noseUV) - 0.015), -dot(noseUV, vec2(COS_315, SIN_315)) - 0.004);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, nose));\n\n    // Charlie Brown's mouth\n    vec2 mouthUV = headUV;\n    mouthUV.y += 0.04;\n    float mouth = max(abs(ellipse(mouthUV, vec2(0.045, 0.03))), noseUV.y + 0.025);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, mouth));\n\n    // Charlie Brown's sleeves\n    vec2 sleevesUV = shirtUV;\n    sleevesUV.y -= 0.135;\n    sleevesUV.x = abs(sleevesUV.x) - 0.08;\n    sleevesUV *= mat2(COS_40, SIN_40, -SIN_40, COS_40);\n\n    bbox = -(sleevesUV.y + 0.04);\n    float sleeves = max(ellipse(sleevesUV, vec2(0.04, 0.08)), bbox);\n    shirt = smin(shirt, sleeves, 0.01);\n\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, shirt));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(shirt)));\n\n    // Black zigzag masked against the shirt\n    shirtUV.y -= 0.01;\n    shirtUV.y *= 8.0;\n    float zigzag = abs(shirtUV.y - abs(round(fract(shirtUV.x * 10.0)) - fract(10.0 * shirtUV.x)));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, max((zigzag - 0.2) / 8.0, shirt)));\n\n    // Snoopy's body\n    vec2 bodyUV = uv;\n    bodyUV += vec2(0.2, 0.35);\n    float body = ellipse(bodyUV, vec2(0.08, 0.06));\n\n    // Snoopy's arm\n    vec2 armUV = bodyUV;\n    armUV *= mat2(COS_20, -SIN_20, SIN_20, COS_20);\n    armUV.x -= 0.02;\n    armUV.y += 0.02 * sin(armUV.x * 15.0 + 1.57);\n    float arm = line(armUV, vec2(-0.04, 0.0), vec2(0.06, 0.0)) - 0.02;\n\n    // Snoopy's left leg\n    vec2 leftLegUV = bodyUV;\n    leftLegUV -= vec2(0.075, 0.01);\n    float leftLeg = max(max(abs(leftLegUV.x) - 0.05, abs(leftLegUV.y) - 0.0125), -body);\n\n    // Snoopy's left foot\n    leftLegUV -= vec2(0.05, 0.01);\n    float leftFoot = ellipse(leftLegUV, vec2(0.02, 0.045));\n    leftLeg = min(leftLeg, leftFoot);\n\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(leftLeg)));\n\n    // Snoopy's right leg\n    vec2 rightLegUV = leftLegUV;\n    rightLegUV += 0.03;\n    float rightLeg = max(max(abs(rightLegUV.x) - 0.03, abs(rightLegUV.y) - 0.0125), -body);\n\n    // Snoopy's right foot\n    rightLegUV -= vec2(0.04, 0.01);\n    float rightFoot = ellipse(rightLegUV, vec2(0.02, 0.045));\n    rightLeg = min(rightLeg, rightFoot);\n\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, rightLeg));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(rightLeg)));\n\n    // Snoopy's neck\n    bodyUV.x += 0.04;\n    neck = max(abs(bodyUV.x) - 0.075, abs(bodyUV.y) - 0.015);\n    body = smin(body, neck, 0.02);\n\n    // Snoopy's collar\n    vec2 collarUV = bodyUV;\n    collarUV.x += 0.055;\n    float collar = max(abs(collarUV.x) - 0.005, abs(collarUV.y) - 0.025);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, collar));\n\n    // Snoopy's head\n    bodyUV += vec2(0.12, 0.01);\n    head = length(bodyUV) - 0.05;\n    body = smin(body, head, 0.02);\n\n    // Snoopy's snout\n    bodyUV -= vec2(0.01, 0.075);\n    float snout = length(bodyUV) - 0.03;\n    body = smin(body, snout, 0.05);\n\n    // Snoopy's mouth\n    mouthUV = bodyUV;\n    mouthUV -= vec2(0.018, -0.03);\n    bbox = dot(mouthUV, vec2(COS_150, SIN_150));\n    mouth = max(abs(ellipse(mouthUV, vec2(0.015, 0.03))), bbox);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, mouth));\n\n    // Only an outline is drawn because the snow provides the inside :P\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(body)));\n\n    // Snoopy's arm is drawn after the body to properly layer it onto the scene\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, arm));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(arm)));\n\n    // Snoopy's right ear\n    earsUV = bodyUV;\n    earsUV += vec2(0.05, 0.125);\n    earsUV *= mat2(COS_40, -SIN_40, SIN_40, COS_40);\n    float rightEar = ellipse(earsUV, vec2(0.02, 0.05));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, rightEar));\n\n    // Snoopy's left ear\n    earsUV -= vec2(-0.04, 0.03);\n    earsUV *= mat2(COS_40, SIN_40, -SIN_40, COS_40);\n    earsUV.x += 0.025;\n    earsUV = earsUV.yx;\n    float leftEar = max(ellipse(earsUV, vec2(0.02, 0.05)), -body);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, leftEar));\n\n    // Snoopy's eye\n    bodyUV += vec2(0.03, 0.06);\n    float eye = length(bodyUV) - 0.005;\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, eye));\n\n    // Snoopy's nose\n    bodyUV -= vec2(0.03, 0.095);\n    nose = max(length(bodyUV) - 0.01, -snout);\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, nose));\n\n    // Snowflakes\n    float screenRight = 0.5 * iResolution.x / iResolution.y;\n    float snowflakesDist = 1000000.0;\n    for (float column=-screenRight; column < screenRight; column += 0.2) {\n        vec2 columnUV = uv - vec2(column, 0.0);\n        columnUV.y += snoise(floor(column / 0.2)) * iTime;\n        columnUV.x += 0.2 * sin(floor(columnUV.y / 0.2) + iTime);\n        columnUV.y = mod(columnUV.y, 0.2) - 0.1;\n        snowflakesDist = min(snowflakesDist, length(columnUV) - 0.015);\n    }\n\n    color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(unit, 0.0, snowflakesDist));\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(snowflakesDist)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[602, 602, 627, 627, 675], [677, 677, 703, 703, 880], [882, 882, 921, 921, 1024], [1026, 1026, 1063, 1063, 1164], [1166, 1166, 1218, 1218, 1525], [1527, 1527, 1572, 1572, 1680], [1682, 1682, 1737, 1737, 12327]], "test": "untested"}
{"id": "tdVfDG", "name": "WDI 2020 Livecoding", "author": "spolsh", "description": "Effect of ~30 min Shader Livecoding session at https://warszawskiedniinformatyki.pl/, Thanks for stopping by and watching pixels bouncing to music", "tags": ["3d", "raymarching", "music", "reflections", "livecoding", "klos"], "likes": 4, "viewed": 398, "published": 3, "date": "1607901253", "time_retrieved": "2024-07-30T20:30:35.547296", "image_code": "// #version 410 core\n\n#define f float \n#define v2 vec2\n#define v3 vec3\n\n// #define R v2Resolution\n// #define T fGlobalTime\n#define F gl_FragCoord\n#define R iResolution\n#define T iTime\n\n#define C(v) clamp(v, 0., 1.)\n#define N normalize\n#define H(v) fract(sin(100.0*v) * 43758.5453)\n\n// #define BI(v) (texture(texFFTIntegrated, v).x)\n// #define BS(v) (texture(texFFTSmoothed, v).x)\n// #define B(v) (texture(texFFT, v).x)\n// fake beat accumulation, next time I will save it in buffer\n#define BI(v) (0.05*T+0.02*texture(iChannel0, v2(v, 0.5)).x)\n#define BS(v) (0.01*texture(iChannel0, v2(v, 0.5)).x)\n#define B(v)  (0.01*texture(iChannel0, v2(v, 0.5)).x)\n\nuniform float fGlobalTime; // in seconds\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n\nf gB = 10e8;\n\nv3 colR = v3(1., 0, 0);\nv3 colA = v3(0.2, 0.5, 1.4);\nv3 colY = v3(1.0, 1.0, 0.0);\n\nmat2 rot(f a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nf plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  vec4 p = vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n\treturn dot(p, p);\n}\n\nf box(v3 p, v3 b) {\n  v3 q = abs(p) - b;\n  f r = length( max(q, v3(0.))) + min( max(max(q.x, q.y), q.z), 0.);\n  return r;\n}\n\nv3 cp;\n\nf map(v3 p) {\n    \n  v3 p0 = p;\n  p0.x = abs(p0.x);\n  p0.x -= 4.0;\n  f s = -p0.x + 0.05*plas(p.zy * 0.2 + 0.1*T, -1.+sin(T));\n  \n  p -= cp;\n  p -= v3(0, 0, 14);\n  s = min(s, length(p) -0.1 -200.0*BS(0.0));\n  \n  p0 -= v3(0, -1, 14.);\n  p0.yz = mod(p0.yz + 4.0, 8.0) - 4.0;  \n  s = min(s, box(p0, v3(100.0, 0.4, 1.0)));\n  \n  f sbl = box(p0, v3(0.01, 100.0, 0.01) - 0.01);\n  gB = min(gB, sbl);\n  s = min(s, sbl); \n  \n  for (f i = 0.; i < 3.; ++i) {\n    p -= v3(0.1, 0.2 + abs(sin(BS(0.0))), 0.5);\n    p.xy *= rot(  10.0*BI(0.0) ); \n    p.yz *= rot( -20.0*BI(0.2) ); \n    p = abs(p);\n  }\n  \n  f sl = box(p, v3(100.0, 0.01, 0.01));\n  gB = min(gB, sl);\n  s = min(s, sl);\n  \n  f bb = 0.1 +200.0*BS(0.0);\n  s = min(s, \n        mix(length(p) -bb,\n           box(p, v3(bb)),\n           abs(sin(T))\n      ));\n    \n  return s;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    v2 q = (2. * F.xy - R.xy) / R.y;\n  \n  v3 c = v3(0);\n  out_color = vec4(c, 1);\n  if (abs(q.y) > 0.75) return;\n  // v3 c = v3(q, 0);\n  \n  f pph = H(F.x + H(F.y + H(T)));\n  \n  v3 ro = v3( 2.0*sin(20.0*BI(0.0)), 2. + 10.0*B(0.0), 20.0*B(0.0));\n  ro.y += sin(20.0*BI(0.0));\n  ro.z += 15.0*T;\n  cp = ro;\n  v3 rd = N(v3(q, 2.));\n  rd.xy *= rot (1.0 * sin(5.0*BI(0.0)) );\n  \n  f tt = 10e8;\n  for (f bi = 0.; bi < 3.; ++bi) {\n    f t = 0.1;\n    for (f i = 0.; i < 64.; ++i) {\n      f d = map(ro + rd * t);\n      if ( t < 0.0001 || t > 40.) break;\n      t += d;\n    }    \n    tt = bi == 0. ? t : tt;\n    if (t > 0.2 && t < 40.) {\n      v3 p = ro + rd * t;\n      // c = fract(p);\n      v2 e = 0.01 * v2(-1, 1);\n      v3 n = N( e.xxx * map(p + e.xxx)\n              + e.yxx * map(p + e.yxx)\n              + e.xyx * map(p + e.xyx)\n              + e.xxy * map(p + e.xxy));\n      f str = smoothstep(0.5, 0.51, fract(p.y));      \n      f str1 = smoothstep(0.5, 0.51, fract(0.13*p.y));      \n      f str0 = smoothstep(0.5, 0.51, texture(iChannel1, 0.1*floor(10.*p.xy)).x);\n      f str2 = smoothstep(0.98, 0.981, fract(0.01*p.z + 0.1*T));      \n      // c = n;      \n      c += 0.2*colR*(str+str1);\n      c += colA*str2;\n      \n      rd = N(reflect(rd, n) + 0.01 * pph);\n      ro = p;\n    }\n  }    \n  // c  = v3(1. - t / 32.);  \n  \n\n  \n  c = mix(c, 0.1*colR, 1.0 - exp(-0.005 * tt*tt));\n  c = mix(c, 0.1*colR, 1.0 - exp(-0.0001 * tt*tt*tt));\n  \n  tt += pph;\n  \n  f sb = 0.2 + 20.0*BS(0.0);\n  c += sb * colY * exp(gB * -20.0);\n  c += sb * colY * exp(gB * -10.0);\n  c += sb * colY * exp(gB *  -1.0);\n  c += colA * 20.0*B(0.0);\n\t    \n  c = c / (1. + c);\n  c = smoothstep(-0.01, 0.9, c);\n  c = pow(c, v3(0.4545));\n  out_color = vec4(c, 1);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24904, "src": "https://soundcloud.com/inzynier/transformator-contest-dj-set", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[852, 852, 867, 867, 915], [917, 917, 947, 947, 1132], [1134, 1134, 1153, 1153, 1257], [1267, 1267, 1280, 1280, 2083], [2085, 2085, 2142, 2142, 3865]], "test": "untested"}
{"id": "tsVfDG", "name": "Mycorrhizal", "author": "wyatt", "description": "line tracking + fluid", "tags": ["growth"], "likes": 17, "viewed": 602, "published": 3, "date": "1607900889", "time_retrieved": "2024-07-30T20:30:36.313248", "image_code": "// Fork of \"Line Tracking Fluid\" by wyatt. https://shadertoy.com/view/tsKXzd\n// 2020-12-10 19:40:02\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 a = A(U);\n    vec4 d = D(U);\n    float l = ln(U,a.xy,a.zw);\n    Q = max(cos(d.z*vec4(1,2,3,4)),.1)*(exp(-l));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define o vec3(1,0,-1)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) {\n\treturn length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,.9));\n}\n#define norm(u) ((u)/(1e-9+length(u)))", "buffer_a_code": "void X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = A(U+r);\n\tif (ln(U,n.xy,n.zw)<ln(U,Q.xy,Q.zw)) Q = n;\n}\nMain {\n    Q = A(U);\n    for (int x = -2;x <=2; x++)\n    for (int y = -2;y <=2; y++)\n    X(Q,U,vec2(x,y));\n    Q.xy = mix(Q.xy,A(Q.xy).xy,1.);\n    Q.zw = mix(Q.zw,A(Q.zw).zw,.01);\n    Q.xy += D(Q.xy).xy;\n    Q.zw += D(Q.zw).xy;\n    \n    if (length(Q.xy-Q.zw) > 2.5) {\n        vec2 m = 0.5*(Q.xy+Q.zw);\n        if (length(U-Q.xy) > length(U-Q.zw)) \n        \tQ.xy = m;\n        else Q.zw = m;\n    }\n    if (iFrame<1) {\n        Q = vec4(0.51*R,0.49*R);\n        vec4 a =vec4(vec2(0.49,.51)*R,vec2(.51,.49)*R);\n        if (ln(U,a.xy,a.zw)<ln(U,Q.xy,Q.zw))\n            Q = a;\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Mouse\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 p = texture(iChannel0,U/iResolution.xy);\n   \tif (iMouse.z>0.) {\n      if (p.z>0.) C =  vec4(iMouse.xy,p.xy);\n    else C =  vec4(iMouse.xy,iMouse.xy);\n   }\n    else C = vec4(-iResolution.xy,-iResolution.xy);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 T(vec2 U) {\n\tU -= .5*D(U).xy;\n\tU -= .5*D(U).xy;\n    return D(U);\n}\nMain {\n    Q = T(U);\n    vec4 \n        n = T(U+o.yx),\n        e = T(U+o.xy),\n        s = T(U+o.yz),\n        w = T(U+o.zy),\n        m = 0.25*(n+e+s+w);\n    Q.xy = m.xy-0.25*vec2(e.z-w.z,n.z-s.z);\n\tQ.z = Q.z-0.25*(n.y+e.x-s.y-w.x);\n    vec4 a = A(U);\n    float l = ln(U,a.xy,a.zw);\n    float v = exp(-l);\n    Q.z -= .001*v;\n    Q.xy = mix(Q.xy,-norm(a.xy-a.zw),.1*v*exp(-Q.z*Q.z));\n    Q.xy *= .5;\n    if (iMouse.z>0.) Q.xy += exp(-.1*length(U-iMouse.xy))*(U-iMouse.xy);\n    if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.) Q.z *= 0.;\n\tif (iFrame < 1) Q = vec4(0,0,0,0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 142, 142, 263]], "test": "untested"}
{"id": "wdVBDG", "name": "Day 354", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 7, "viewed": 373, "published": 3, "date": "1607899863", "time_retrieved": "2024-07-30T20:30:37.078203", "image_code": "float df;\n\n#define pal(a,b,c,d,e) (a + (b)*sin((c)*(d) + e))\n\nvec3 add(float da, float db, vec3 cola, vec3 colb, float method){\n    vec3 colo = vec3(0);\n    \n    float aa = smoothstep(df,0.,db);\n    \n    if (method == 0.){\n        colo = mix(cola,colb,aa);\n    }\n    return colo;\n}\n\nmat2 rot(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uv = p;\n    \n    float env = pow(abs(sin(iTime*0.5)),0.3)*sign(sin(iTime*0.5 ))*0.5 + 0.5 ;\n    \n    \n    p += vec2(sin(iTime + sin(iTime*0.4))*0.04,sin(iTime*0.6 - sin(iTime*0.4))*0.04);\n    \n    p *= 1. + env;\n    df = dFdx(p.x);\n    \n    vec3 col = vec3(0.01,0.4,0.91);\n    \n    col += sin(p.xyy + sin(iTime + length(p))*0.4)*0.5;\n    \n    \n    float d = 10e4;\n    \n    vec3 colo = vec3(0);\n    \n    \n    #define TP(P) (floor(T) + pow(fract(T),P))\n    float T = iTime - 14.;\n    for(float i = 0.; i < 142.; i++){\n        float env = sin(TP(5. + sin(i)*2.));\n        env = pow(abs(env),4.)*sign(env);\n        T += .44;\n        p.x += 0. + env*0.004;\n        p *= rot(sin(TP(2.)*0.001)*0.41);\n        float ld = length(p) - .2 - sin(i*1.4 + sin(T)*0.2)*0.4;\n        vec3 c = pal(0.5,.5,vec3(3,2.1,1.5),1.,i + p.x);\n        \n        if(sin(i *0.4) < -0.4){\n            ld = xor(ld,-(p.y) - .5*sin(i + T*0.13 ),.4);\n            \n        }\n        if(sin(i *0.4) > 0.1){\n            ld = abs(ld - 0.1*sin(i + TP(5.)));\n        }\n        \n        \n        colo = add(d,ld,colo,c,0.);\n        \n        \n        d = xor(d,ld,-0. - sin(i)*0.1);\n        \n        //d = min(d,ld);\n    }\n    \n    \n    \n    col = add(10.,d + 0.01,col,colo,0.);\n        \n    \n    \n    col = mix(1. - col,col, env);    \n    col *= smoothstep(1.,0.,dot(uv,uv)*0.7);\n    \n    col = mix(col,smoothstep(0.,1.,col),0.6);\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 127, 127, 281], [283, 283, 305, 305, 373], [428, 428, 485, 485, 2021]], "test": "untested"}
{"id": "wsKfWG", "name": "Watercolor Percolation", "author": "wyatt", "description": "These people did it wayy better : https://grail.cs.washington.edu/projects/watercolor/paper_tiny.pdf", "tags": ["watercolor"], "likes": 34, "viewed": 988, "published": 3, "date": "1607892301", "time_retrieved": "2024-07-30T20:30:37.961841", "image_code": "Main {\n    vec4 a = A(U), b = B(U);\n    Q = a+b;\n    float n = hash(U+vec2(0,1));\n    float e = hash(U+vec2(1,0));\n    float s = hash(U-vec2(0,1));\n    float w = hash(U-vec2(1,0));\n    vec3 no = normalize(vec3(e-s,n-s,1));\n    \n    Q = .9+.05*no.y-sqrt(Q);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}\nfloat hash (vec2 p) // Dave H\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "buffer_a_code": "Main {\n    Q = A(U+vec2(0,1));\n    Q = A(U+vec2(0,.05*length(Q.xyz)*Q.w));\n    vec4 q = vec4(0);\n    for (int x = -1; x<= 1; x++)\n    for (int y = -1; y<= 1; y++)\n    if (x!=0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u);\n        float h = hash(U+0.5*u);\n        float m = (length(a.xyz));\n        m = min(m,1.);\n        vec4 w = vec4(atan(Q.w*a.www),a.w);\n        q += m*pow(h,6.)*(a-Q)/dot(u,u);\n    }\n    Q += 0.125*q;\n    \n    vec4 d = D(U);\n    if (iMouse.z>0.&&ln(U,d.xy,d.zw)<.025*R.y){\n        Q = 0.5+0.5*sin(iTime+vec4(1,2,3,4));\n        Q.w = 1.;\n    }\n    //if (iFrame < 1) Q = 1.-B(U);\n    \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\n    Q = B(U);\n    Q += 5e-4*A(U);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = A(U)*(1.-5e-4);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Mouse\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 p = texture(iChannel0,U/iResolution.xy);\n   \tif (iMouse.z>0.) {\n      if (p.z>0.) C =  vec4(iMouse.xy,p.xy);\n    else C =  vec4(iMouse.xy,iMouse.xy);\n   }\n    else C = vec4(-iResolution.xy,-iResolution.xy);\n}", "buffer_d_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKfWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WsVfDy", "name": "A night sky with movable noise", "author": "rrrr", "description": "Shader combines noise generated movable and loopless movable star layers.", "tags": ["noise", "sky", "stars", "night"], "likes": 10, "viewed": 490, "published": 3, "date": "1607890272", "time_retrieved": "2024-07-30T20:30:38.774667", "image_code": "float random(vec2 fv, float d1, float d2, float r) {\n    return fract(sin(dot(fv, vec2(d1, d2))) * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 sv = uv + iTime * .0005;\n    \n    vec2 iv = floor(sv * 500.0);\n    vec2 iv2 = floor(sv * 300.0);\n    vec2 iv3 = floor(sv * 400.0);\n    \n    vec3 cell_noise1 = vec3(random(iv, 12.0, 80.0, 4000.0));\n    vec3 cell_noise2 = vec3(random(iv2, 12.333, 13.0, 5000.0));\n    vec3 cell_noise3 = vec3(random(iv3, 90.4325, 12.0, 2000.0));\n    vec3 cell_noise = ((cell_noise1 + cell_noise2 + cell_noise3) * .3333 - .9) * 10.0;\n    \n    vec2 fv_s = uv * 20.0;\n    vec2 fv = fract(vec2(fv_s.x + sin(iTime * .005) * 10.0, fv_s.y + cos(iTime * .005) * 10.0) * .5);\n    vec3 circle = vec3(1.0 - smoothstep(length(fv - .25), .0, (sin(uv.x * 40.0) * cos(uv.y * 50.0)) * .015));\n    \n\n    fragColor = vec4(circle + clamp(cell_noise, .0, 1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 104], [106, 106, 163, 163, 940]], "test": "untested"}
{"id": "3sKfDy", "name": "Slow moving uniform noise", "author": "rrrr", "description": "We can't have completely uniform movement as the time increments change between frames and so we don't generate exactly the same pixels as neighboring from the previous frame.", "tags": ["noise", "move", "slow"], "likes": 1, "viewed": 273, "published": 3, "date": "1607886997", "time_retrieved": "2024-07-30T20:30:39.537627", "image_code": "float random(vec2 fv, float d1, float d2, float r) {\n    return fract(sin(dot(fv, vec2(d1, d2))) * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy * 1.0;\n    vec2 fv = uv + iTime * .005;\n    vec2 iv = floor(fv * 500.0);\n    vec2 iv2 = floor(fv * 30.0);\n    vec2 iv3 = floor(fv * 400.0);\n    \n    vec3 cell_noise1 = vec3(random(iv, 12.0, 80.0, 4000.0));\n    vec3 cell_noise2 = vec3(random(iv2, 12.333, 13.0, 5000.0));\n    vec3 cell_noise3 = vec3(random(iv3, 90.4325, 12.0, 2000.0));\n    vec3 cell_noise = (cell_noise2) * 1.0;\n\n    fragColor = vec4(cell_noise,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 104], [106, 106, 163, 163, 621]], "test": "untested"}
{"id": "wsGBzV", "name": "JSplacement-style greebles", "author": "TekF", "description": "Inspired by the displacement maps generated by JSplacement https://windmillart.net/?p=jsplacement", "tags": ["displacementmap", "greebles"], "likes": 55, "viewed": 1490, "published": 3, "date": "1607882190", "time_retrieved": "2024-07-30T20:30:40.312555", "image_code": "#if (0)\n// map the greebles through a curve, with a little animation\nfloat CurveProfile( float index )\n{\n    // custom curve shape with a round bit, a sloped bit, and a flat bit\n\treturn max(.75*sin(index*6.283185),min(1.,(fract(index)-.7)*7.));\n}\n\nfloat FoldHeight( float height, vec2 uv )\n{\n\tfloat shiftPeriod = 1.;\n    float staticPeriod = 1.5;\n    float t = iTime/(staticPeriod+shiftPeriod);\n\n\tvec2 rand0 = hash2( coord2( int(t) ) );\n\tvec2 rand1 = hash2( coord2( int(t)+1 ) );\n\tvec2 rand = mix( rand0, rand1, clamp(fract(t)*(staticPeriod+shiftPeriod)/shiftPeriod,0.,1.) ); // when shifting, morph from rand0 to rand1\n\n\treturn CurveProfile( height*(1.+2.*rand.x) - rand.x*1. + rand.y*.0 + uv.y*1. ); // this is much simpler than how I did it in Blender, but I think it will work\n}\n#else\nfloat FoldHeight( float height, vec2 uv )\n{\n\treturn height; // just show the greeble texture\n}\n#endif\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfloat zoom = 1.5;\n\tvec3 rayDirection = normalize( vec3( (fragCoord-iResolution.xy*.5)/iResolution.y, zoom ) );\n    vec3 cameraTarget = vec3(1,0,1.5)*iTime + vec3(0,-1,0);\n    vec3 cameraPosition = vec3(0,8,-12);\n    float a = iTime/5.;\n    cameraPosition.xz = cameraPosition.xz*cos(a) + cameraPosition.zx*sin(a)*vec2(1,-1);\n    cameraPosition += cameraTarget;\n    \n    vec3 cameraForward = normalize( cameraTarget - cameraPosition );\n    vec3 upAxis = vec3(0,1,0);\n    vec3 cameraRight = normalize( cross( upAxis, cameraForward ) );\n    vec3 cameraUp = cross( cameraForward, cameraRight );\n    \n    // rotate ray to camera orientation\n    rayDirection = rayDirection.x*cameraRight + rayDirection.y*cameraUp + rayDirection.z*cameraForward;\n    \n    vec3 planeNormal = vec3(0,1,0);\n    float planeOffset = 0.; // from world origin, in direction of plane normal\n\n    // precompute some things\n    float rayDotPlaneNormal = dot(rayDirection,planeNormal);\n    float invRayDotPlaneNormal = 1. / rayDotPlaneNormal;\n    float cameraDotPlaneNormal = dot(cameraPosition,planeNormal);\n    float distanceToPlaneAlongNormal = planeOffset - cameraDotPlaneNormal; // note this is negative, so maybe shouldn't be called \"distance\"\n\n\tvec2 invTextureScale = .04*vec2(1.,iResolution.x/iResolution.y); // correct the aspect ratio\n\n\t// only support viewing the plane from in-front (even though it has depth it will break down when viewed edge-on)\n    if ( rayDotPlaneNormal >= 0. || cameraDotPlaneNormal < planeOffset )\n    {\n    \tfragColour = vec4(1);\n        return;\n    }\n\n    // draw the displacement map as a series of slices through the texture, not a solid object\n    float displacementHeight = 2.;\n    int numSlices = 256;\n    float sliceStep = displacementHeight / float(numSlices);\n    \n    vec2 textureCoordinate = vec2(0);\n    float sliceProportion = 0.;\n    float distanceToIntersection = 0.;\n    float height = 0.;\n    for ( int slice = 0; slice < numSlices; slice++ )\n    {\n    \tsliceProportion = float(slice)/float(numSlices); // how far we are through the full stack of slices, in [0,1)\n    \n    \t// how far along the ray do we have to travel to hit the plane\n    \tdistanceToIntersection = distanceToPlaneAlongNormal * invRayDotPlaneNormal;\n        \n        vec3 intersectionPosition = cameraPosition + rayDirection*distanceToIntersection;\n        \n        textureCoordinate = intersectionPosition.xz*invTextureScale;\n        \n        // on firefox on my home PC it works without this, but I guess repeat texture mode doesn't working with frame buffers reliably\n\t\ttextureCoordinate = fract(textureCoordinate);\n        \n\t\t// point sample - might be better to have 2 versions of the texture with different filter modes rather than all this maths\n        //fragColour = texelFetch(iChannel0,ivec2(textureCoordinate*iResolution.xy)%ivec2(iResolution.xy),0);\n        fragColour = texture(iChannel1,textureCoordinate);\n        height = FoldHeight(fragColour.a,textureCoordinate);\n        \n        // stop marching once we sample something at or above the march height\n        if ( 1.-height < sliceProportion ) break;\n        \n        distanceToPlaneAlongNormal -= sliceStep; // subtract because distance is negative, easy to explain with a diagram\n    }\n    \n    // sorry for the cryptic maths here\n    vec2 d = vec2(1,0)/iResolution.xy;\n    vec3 normal = cross(\n    \t\t\t\tvec3(0,\n    \t\t\t\t(\n                    \tFoldHeight( texture(iChannel0,textureCoordinate+d.yx).a, textureCoordinate+d.yx )\n    \t\t\t\t\t-FoldHeight( texture(iChannel0,textureCoordinate-d.yx).a, textureCoordinate-d.yx )\n                     ) * displacementHeight\n                    ,d.x / invTextureScale.x)\n                    ,\n    \t\t\t\tvec3(d.x / invTextureScale.x,\n                    (\n                        FoldHeight( texture(iChannel0,textureCoordinate+d.xy).a, textureCoordinate+d.xy )\n                        -FoldHeight( texture(iChannel0,textureCoordinate-d.xy).a, textureCoordinate-d.xy )\n                     ) * displacementHeight\n                    ,0)\n                   );\n// can get better normals for walls with less bevel if use Channel1 and smaller d, but that will break on smooth curves\n\n\tnormal = normalize(normal);\n\n\tvec3 reflectDirection = reflect(rayDirection,normal);\n    vec3 reflectionColour = texture(iChannel2,reflectDirection).rgb;\n    vec3 reflectionBlurred = textureLod(iChannel2,reflectDirection,3.).rgb;\n    \n    // darken reflections below the horizon so it looks like the plane's reflecting itself\n    reflectionColour *= mix( vec3(.3), reflectionColour, smoothstep(.0,.1,reflectDirection.y) );\n    reflectionBlurred *= mix( vec3(.3), reflectionColour, smoothstep(.0,.1,reflectDirection.y) );\n    \n    // fake - desaturate metallic reflections\n    reflectionBlurred = mix( reflectionBlurred.ggg, reflectionBlurred, .1 );\n    \n    \n    float metallicity = step(.7,fract(fragColour.a*11.));\n\n\t// lighting\n    vec3 lighting = vec3(.1,.2,.3) + vec3(2.5,2.2,2)*1.5 * max(0.,dot(normal,normalize(vec3(2,1,3))));\n    fragColour.rgb *= mix( lighting, reflectionBlurred, metallicity );\n    \n    // reflection\n    float fresnel = .02+.98*pow(min(1.+dot(rayDirection,normal),1.),5.);\n    fragColour.rgb = mix( fragColour.rgb, reflectionColour, fresnel );\n\n\t// darken deeper parts\n    fragColour = mix( fragColour, vec4(0), sliceProportion ); \n    \n    // atmospheric fog\n    fragColour = mix( vec4(1.), fragColour, exp2( -distanceToIntersection * vec4(.1,.125,.2,1)/20. ) );\n    \n    // stretch contrast\n    fragColour = clamp(fragColour*1.-.04,0.,1.);\n\n//\tfragColour.rgb = .5+.5*normal/(abs(normal)+.1);//\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n\n/*\n// debug greeble buffer\n    fragColour = texelFetch( iChannel0, ivec2(fragCoord + iTime*vec2(80,30))%ivec2(iResolution.xy), 0 );\n//    fragColour = step(vec4(abs(fract(iTime*.1)*2.-1.)),fragColour);\n*/\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// set this to 1 to stop the pattern refreshing periodically\n#define BUILD_ONLY_ONCE 0\n\n\n// Draw a JSplacement style pattern to use as a displacement map\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfragColour = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    \n#if (BUILD_ONLY_ONCE)\n\t// generate only first time\n\tif ( iFrame == 0 ) fragColour = vec4(.5);\n\tif ( iFrame > 256 ) return;\n#else\n\t// generate repeatedly\n\tif ( iFrame%1024 == 0 ) fragColour = vec4(.5);\n    if ( iFrame%1024 > 256 ) return;\n#endif\n    \n    // draw a shape\n    vec4 rand = hash4(coord2(ivec2(iFrame,1)));\n    vec4 rand2 = hash4(coord2(ivec2(iFrame,2)));\n    vec4 rand3 = hash4(coord2(ivec2(iFrame,3)));\n    \n    vec2 pos = iResolution.xy*rand.xy;\n\tfloat scale = exp2((rand.z-.5)*1.);\n    \n\tscale *= 640./iResolution.x;\n    \n\tfragCoord -= pos;\n    fragCoord *= scale;\n    \n    int rotFlip = int(floor(rand.w*8.))%8;\n    if ( (rotFlip&1) != 0 ) fragCoord.x = -fragCoord.x;\n    if ( (rotFlip&2) != 0 ) fragCoord.y = -fragCoord.y;\n    if ( (rotFlip&4) != 0 ) fragCoord.xy = fragCoord.yx;\n\n    \n    // draw blit with a wrap, to make a tileable texture\n    fragCoord = mod(fragCoord+iResolution.xy*.5,iResolution.xy)-iResolution.xy*.5;\n    \n\t// choose blit type\n    int blitType = int(floor(rand.x*255.999));\n    \n    // rectangle with missing corner\n//    if ( abs(fragCoord.x) < 30. && abs(fragCoord.y) < 20. && fragCoord.x+fragCoord.y < 30. )\n    \n    bool blit = abs(fragCoord.x) < 30.;\n    blit = blit && abs(fragCoord.y) < 20.;\n    if ( (blitType&1) != 0 ) blit = blit && fragCoord.x+fragCoord.y < 30.;\n    if ( (blitType&10) == 10 ) blit = blit && mod(fragCoord.x,8.) < 3.5;\n    if ( (blitType&12) == 12 ) blit = blit && mod(fragCoord.y,8.) < 2.5;\n    if ( (blitType&16) != 0 ) blit = blit && abs(fragCoord.x) > 3.;\n    if ( (blitType&32) != 0 ) blit = blit && abs(fragCoord.y) > 3.;\n    if ( (blitType&64) != 0 ) blit = blit && abs(fragCoord.x-20.) > 2.;\n    if ( (blitType&(128+16)) == 128 ) blit = blit && max(abs(fragCoord.x+10.),abs(fragCoord.y)) > 15.;\n\n\tif ( blit )\n    {\n    \t// can store any colour I want here, or generate it from height like jsplacement does\n    \t//fragColour = rand3;\n        float height = rand2.y;\n        fragColour.a = height;\n        \n        // colour lookup\n        // just use a slice of a texture! - meh\n        //fragColour.rgb = texture( iChannel1, vec2(height,.7) ).rgb;\n        vec3 clut[] = vec3[](vec3(0),vec3(.04),vec3(.08),vec3(.12),vec3(.16),vec3(.2),vec3(.5,.2,0),vec3(.5),vec3(.5),vec3(0,.1,.4),vec3(1),vec3(0,.3,.7));\n        fragColour.rgb = clut[min(int(floor(rand.z*12.)),11)];\n\n/*        float f = height*11.;//can't remember how to do this: float(length(clut)-1);\n        int idx = int(floor(f));\n        fragColour.rgb = mix( clut[idx], clut[idx+1], f-float(idx) );*/\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (uint(p)*M1)\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[893, 893, 951, 951, 6810]], "test": "untested"}
{"id": "tsKfRt", "name": "hypertextures 3: nebula", "author": "FabriceNeyret2", "description": "Working out nebula shading: dark dense dust with luminous silhouette + luminous nearby light gas\nref image: [img] https://i.imgur.com/L5z4F20.png [/img]\nmouse control or auto-rotate.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "nebula", "preintegration", "bokglobules", "ism"], "likes": 12, "viewed": 520, "published": 3, "date": "1607880102", "time_retrieved": "2024-07-30T20:30:41.161286", "image_code": "// variant of https://shadertoy.com/view/wstyzl\n// variant of https://shadertoy.com/view/tsdcRj\n\n   #define noise(x) texture(iChannel0, x )                    // positive smooth\n// #define noise(x) ( 2.* texture(iChannel0, x ) -1. )        // centered smooth\n// #define noise(x) abs( 2.* texture(iChannel0, x ) -1. )     // positive bulgy\n\n   #define turb(x)  ( noise(x)/2. + noise((x)*2.)/4. + noise((x)*4.)/8. ) // cascade\n// #define turb(x)  ( noise(x)/2. + noise((x)*2.)/4.                    )\n// #define turb(x)  ( noise(x) * noise((x)*2.) * noise((x)*4.) * 8. )     // mult. cascade\n// #define turb(x)  .5*( noise(x) * noise((x)*2.)                 * 4. )\n\n//float z;\nvec3 C = vec3(0); float rad = 3.;  // bounding sphere (0,0,0), 2.\nfloat map(vec3 p ) \n{\n    float f = 0.;\n    vec3 q = p;\n#if 1\n    q += .7*(2.* turb(q/vec3(20,10,10)+.02*iTime).xyz -1.);   // displacement noise\n#else\n    f -= 1.3*turb(q/8.+ .02*iTime).x;              // density noise\n#endif\n // f += smoothstep(1.,.8,length(q)/2.);           // main sphere ( mask )\n    f += 1.3 - 3.*( length(q)/2. - .7 );           // main sphere ( mask )\n                 \n\n // f*= smoothstep(.1,.2,abs(p.x));                // empty slice (derivable ) \n // z = length(q)/2.;                              // depth in sphere\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define SQR(x)   ( (x)*(x) )\n  #define CUB(x)   ( (x)*(x)*(x) )\n\n  #define sl  5.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n // return LUT(d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, C, rad );\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99                // end if opaque or...\n           || length(pos) > rad ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        \n     // float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n\n        if( lut > 0.                // optim\n          ) {                       // --- compute shading \n            float h = .03;          // scale used for derivatives \n#if 0       // canonical decentered difference\n            vec2 e = vec2(h,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) +1e-5);\n#else       // centered tetrahedron difference: https://iquilezles.org/articles/normalsSDF\n            vec2 k = vec2(1,-1);\n            vec3 n = normalize( k.xyy*map( pos + k.xyy*h ) + \n                                k.yyx*map( pos + k.yyx*h ) + \n                                k.yxy*map( pos + k.yxy*h ) + \n                                k.xxx*map( pos + k.xxx*h ) +1e-5);\n#endif\n            float // dif = abs(dot(n, sundir)),                       // diffuse color\n                       s = length(cross(n,rd));                       // silhouette \n\n            vec3 col = vec3( 1,.7,.5) * pow(s, 10. );\n         // col = .5+.5*n;                                            // debug normals\n         // col = abs(n);\n   \n\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.);            // ---blend\n        }\n        else \n            sum += .2*smoothstep(.5,0.,-den) * vec4(1,.7,.5, 1) * dt; // gaseous skin\n \n        t += dt;                                                      // stepping\n    }\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* iMouse.xy / R.xy\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;                          // debug: show a slice of noise\n    \n    \n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), 3.*m.y, cos(3.*m.x))), // camera\n\t     ta = vec3(0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    \n    vec3 rd = ca * normalize( vec3(p,1.5) );                        // ray\n    \n    O = raymarch( ro, rd );                                         // render nebula\n}\n", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[664, 741, 762, 762, 1326], [1904, 1904, 1937, 1996, 2212], [2214, 2214, 2273, 2273, 2421], [2423, 2423, 2458, 2458, 4632], [4634, 4634, 4680, 4680, 4842], [4844, 4844, 4882, 4882, 5482]], "test": "untested"}
{"id": "WdKBWy", "name": "Smooth moving night sky", "author": "rrrr", "description": "A nice simple example on how to get smooth randomized pattern movement.", "tags": ["sky", "stars", "night"], "likes": 5, "viewed": 427, "published": 3, "date": "1607874231", "time_retrieved": "2024-07-30T20:30:41.974113", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 fv_s = uv * 20.0;\n    vec2 fv = fract(vec2(fv_s.x + sin(iTime * .05) * 10.0, fv_s.y + cos(iTime * .05) * 10.0) * .5);\n    \n    vec3 circle = vec3(1.0 - smoothstep(length(fv - .25), .0, (sin(uv.x * 40.0) * cos(uv.y * 50.0)) * .015));\n    vec3 col = vec3(fv, .0);\n\n    fragColor = vec4(circle,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 405]], "test": "untested"}
{"id": "3dVfDG", "name": "Bouncing Julias", "author": "wyatt", "description": "low effort fork of wormies ", "tags": ["fractal"], "likes": 26, "viewed": 471, "published": 3, "date": "1607873353", "time_retrieved": "2024-07-30T20:30:42.736076", "image_code": "// Fork of \"Wormies\" by wyatt. https://shadertoy.com/view/WsGBDG\n// 2020-12-13 14:57:18\n\nMain {\n    Q = vec4(0);\n    vec4 c = B(U);\n    vec4 a = A(c.xy);\n    vec2 u = mod(c.xy,vec2(M,M))/M*3.5-1.75;\n   vec2 z = ceil(c.xy/M)*M;\n   z = sin(vec2(1,123)*z.yx);\n   for (int i = 0; i < 10; i++) {\n       u = vec2(u.x*u.x-u.y*u.y,2.*u.x*u.y)+vec2(1,.2)*z;\n       if (length(u)>4.) break;\n       Q += exp(-100.*dot(u,u));\n   }\n   if (length(u)>4.) Q = vec4(-R,0,0);\n    \n    Q = smoothstep(2.,1.125,length(U-a.xy))*\n    (0.5+.5*sin(2.*atan(Q.x)+(c.y+c.x)/100.+vec4(1,2,3,4)));\n    Q += smoothstep(1.,0.,abs(length(U-a.xy)-3.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define convolution  for (int x = -1; x <= 1; x++) for (int y = -1; y <= 1;y++)\n#define convolution2 for (int x = -2; x <= 2; x++) for (int y = -2; y <= 2;y++)\n#define M 150.", "buffer_a_code": "Main {\n    \n   Q = A(U);\n   vec2 f = vec2(0);\n   convolution2 {\n       vec2 u = vec2(x,y);\n       vec4 a = A(U+u);\n       vec2 u1 = U;\n       vec2 u2 = U+u;\n       float l0 = length(u1-u2);\n       float l1 = length(Q.xy-a.xy);\n       float s = smoothstep(10.,9.,length(Q.xy-a.xy));\n       if (l1>0.) {\n           f += 20.*s*(l1-l0)*(a.xy-Q.xy)/(l1);\n           if (length(a.zw-Q.zw)>0.&&length(a.xy-Q.xy)>0.)\n           f += s*(a.zw-Q.zw)*dot(a.zw-Q.zw,a.xy-Q.xy)/length(a.zw-Q.zw)/length(Q.xy-a.xy);\n       }\n   }\n   convolution2 {\n       vec2 u = vec2(x,y);\n       vec2 v = B(Q.xy+u).xy;\n       vec4 a = A(v);\n       float l = length(Q.xy-a.xy);\n       float s = \n       smoothstep(4.,3.,l)*\n       smoothstep(10.,20.,length(v-U));\n       if (l>0.)  {\n           f += 10.*s*(Q.xy-a.xy)/(l);\n            if (length(a.zw-Q.zw)>0.)\n           f += .5*s*(a.zw-Q.zw)*dot(a.zw-Q.zw,a.xy-Q.xy)/length(a.xw-Q.zw)/l;\n       }\n   }\n   Q.zw += 1e-2*f;\n   Q.w -= 3e-4;\n   Q.xy += Q.zw*sqrt(.5/(1.+dot(Q.zw,Q.zw)));\n   if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n   if (iMouse.z>0.){ float d = dot((Q.xy-iMouse.zw),Q.xy-iMouse.zw);\n       Q.zw += 50.*(Q.xy-iMouse.zw)/(1e-9+sqrt(d)*d);}\n   if (Q.x < 1.) Q = vec4(1.,Q.y,-Q.z,Q.w);\n   if (R.x-Q.x < 1.) Q = vec4(R.x-1.,Q.y,-Q.z,Q.w);\n   if (Q.y < 1.) Q = vec4(Q.x,1.,Q.z,-Q.w);\n   if (R.y-Q.y < 1.) Q = vec4(Q.x,R.y-1.,Q.z,-Q.w);\n      \n   \n   if (iFrame < 1) \n       Q = vec4(U,0,.6);\n    \n   vec2 u = mod(U,vec2(M,M))/M*3.5-1.75;\n   vec2 z = ceil(U/M)*M;\n   z = sin(vec2(1,123)*z.yx);\n   for (int i = 0; i < 10; i++) {\n       u = vec2(u.x*u.x-u.y*u.y,2.*u.x*u.y)+vec2(1,.2)*z;\n       if (length(u)>4.) break;\n   }\n   if (length(u)>4.) Q = vec4(-R,0,0);\n   \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X (inout vec4 Q, vec2 U, vec2 u) {\n    vec4 a = A(u), q = A(Q.xy);\n    if (length(U-a.xy)<length(U-q.xy))\n        Q.xy = u;\n}\nvoid Z (inout vec4 Q, vec2 U, vec2 u) {\n    vec4 a = A(u), q = A(Q.zw);\n    if (length(U-a.xy)<length(U-q.xy))\n        Q.zw = u;\n}\nMain {\n    Q = B(U);\n    convolution \n        X(Q,U,B(U+vec2(x,y)).xy);\n        \n    convolution2 \n        X(Q,U,A(Q.xy+vec2(x,y)).xy);\n    X(Q,U,Q.zw);\n    #define N 12\n    if (iFrame%N==0) Q.zw = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tZ(Q,U,B(U+vec2(0,k)).zw);\n    \tZ(Q,U,B(U+vec2(k,0)).zw);\n    \tZ(Q,U,B(U-vec2(0,k)).zw);\n    \tZ(Q,U,B(U-vec2(k,0)).zw);\n    }\n    \n    if (iFrame < 1) {\n        Q = vec4(U,0,0);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    \n   Q = A(U);\n   vec2 f = vec2(0);\n   convolution2 {\n       vec2 u = vec2(x,y);\n       vec4 a = A(U+u);\n       vec2 u1 = U;\n       vec2 u2 = U+u;\n       float l0 = length(u1-u2);\n       float l1 = length(Q.xy-a.xy);\n       float s = smoothstep(10.,9.,length(Q.xy-a.xy));\n       if (l1>0.) {\n           f += 20.*s*(l1-l0)*(a.xy-Q.xy)/(l1);\n           if (length(a.zw-Q.zw)>0.&&length(a.xy-Q.xy)>0.)\n           f += s*(a.zw-Q.zw)*dot(a.zw-Q.zw,a.xy-Q.xy)/length(a.zw-Q.zw)/length(Q.xy-a.xy);\n       }\n   }\n   convolution2 {\n       vec2 u = vec2(x,y);\n       vec2 v = B(Q.xy+u).xy;\n       vec4 a = A(v);\n       float l = length(Q.xy-a.xy);\n       float s = \n       smoothstep(4.,3.,l)*\n       smoothstep(10.,20.,length(v-U));\n       if (l>0.)  {\n           f += 10.*s*(Q.xy-a.xy)/(l);\n            if (length(a.zw-Q.zw)>0.)\n           f += .5*s*(a.zw-Q.zw)*dot(a.zw-Q.zw,a.xy-Q.xy)/length(a.xw-Q.zw)/l;\n       }\n   }\n   Q.zw += 1e-2*f;\n   Q.w -= 3e-4;\n   Q.xy += Q.zw*sqrt(.5/(1.+dot(Q.zw,Q.zw)));\n   if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n   if (iMouse.z>0.){ float d = dot((Q.xy-iMouse.zw),Q.xy-iMouse.zw);\n       Q.zw += 50.*(Q.xy-iMouse.zw)/(1e-9+sqrt(d)*d);}\n   if (Q.x < 1.) Q = vec4(1.,Q.y,-Q.z,Q.w);\n   if (R.x-Q.x < 1.) Q = vec4(R.x-1.,Q.y,-Q.z,Q.w);\n   if (Q.y < 1.) Q = vec4(Q.x,1.,Q.z,-Q.w);\n   if (R.y-Q.y < 1.) Q = vec4(Q.x,R.y-1.,Q.z,-Q.w);\n      \n   \n   if (iFrame < 1) \n       Q = vec4(U,0,.6);\n    \n   vec2 u = mod(U,vec2(M,M))/M*3.5-1.75;\n   vec2 z = ceil(U/M)*M;\n   z = sin(vec2(1,123)*z.yx);\n   for (int i = 0; i < 10; i++) {\n       u = vec2(u.x*u.x-u.y*u.y,2.*u.x*u.y)+vec2(1,.2)*z;\n       if (length(u)>4.) break;\n   }\n   if (length(u)>4.) Q = vec4(-R,0,0);\n   \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void X (inout vec4 Q, vec2 U, vec2 u) {\n    vec4 a = A(u), q = A(Q.xy);\n    if (length(U-a.xy)<length(U-q.xy))\n        Q.xy = u;\n}\nvoid Z (inout vec4 Q, vec2 U, vec2 u) {\n    vec4 a = A(u), q = A(Q.zw);\n    if (length(U-a.xy)<length(U-q.xy))\n        Q.zw = u;\n}\nMain {\n    Q = B(U);\n    convolution \n        X(Q,U,B(U+vec2(x,y)).xy);\n        \n    convolution2 \n        X(Q,U,A(Q.xy+vec2(x,y)).xy);\n    X(Q,U,Q.zw);\n    #define N 12\n    if (iFrame%N==0) Q.zw = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tZ(Q,U,B(U+vec2(0,k)).zw);\n    \tZ(Q,U,B(U+vec2(k,0)).zw);\n    \tZ(Q,U,B(U-vec2(0,k)).zw);\n    \tZ(Q,U,B(U-vec2(k,0)).zw);\n    }\n    \n    if (iFrame < 1) {\n        Q = vec4(U,0,0);\n    }\n\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tsyfDy", "name": "Implicit Function DE", "author": "knighty", "description": "Implicit function distance estimation.\nThis is mainly a test to verify if WebGL does a good job at optimising expression. It seems to be the case.", "tags": ["de", "function", "implicit"], "likes": 16, "viewed": 415, "published": 3, "date": "1607872035", "time_retrieved": "2024-07-30T20:30:43.685537", "image_code": "// --- sliders and mouse widgets -------------------------------------------\n//Adapted from FabriceNeyret2: https://www.shadertoy.com/view/MdKGRw\n\nvec2 R; //= iResolution.xy;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n#define Swidth  .004\n#define Sradius .02\n#define Bradius .04\n#define Mradius .02\n\nvec4 affMouse(vec2 uv)  { // display mouse states ( color )\n    vec4 mouse = UI(33);                       // current mouse pos\n    float k = length(mouse.xy/R.y-uv)/Mradius,\n          s = sign(mouse.z);\n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(s,1.-s,0,1); \n\t\n    k = length( UI(34).xy/R.y-uv)/Mradius;     // prev mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,0,1,1); \n            \n    k = length(abs(mouse.zw)/R.y-uv)/Mradius;  // drag start  mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,.4,s,1); \n\t\n\treturn vec4(0);\n}\n\nfloat aff_sliders(vec2 U) { // display sliders ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l/2.)<l/2. ) return 1.;\n        if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l/2.)<l/2. ) return 1.;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\n    }\n    return 0.;       \n}\n\nfloat aff_buttons(vec2 U) { // display buttons ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).y) break;\n        vec4 S = UI(i+17.);\n        float l = length(U-S.xy);\n        if (l < Bradius) \n            if (S.a>0.) return 1.; \n            else return .3+smoothstep(.7,1.,l/Bradius);\n    }\n    return 0.;\n}        \n\n//------------------------------------------------------------------------------------\n\n#define PI2\t( PI * 2.0 )\n\n//Dynamic variables\n//bool DisplayOriginal = false;\n\n//float halfWidth = 0.5, SFactor=1., RFactor=0., Radius=1.;\n//vec3 Offset = vec3(0);\n\nvoid init() {//setup folding planes and vertex\n\tfloat t=iTime;\n    /*halfWidth=0.1*UI(1).a;// Voxel width / 2.\t\t\tLeftmost slider\n    SFactor  =UI(2).a;// Shrink factor of Voxels\n    RFactor  =UI(3).a;// Roundness of Voxels\n    Offset.x =UI(4).a;// Voxel offset\n    Offset.y =UI(5).a;\n    Offset.z =UI(6).a;\n    \n    Radius   =UI(7).a * 2.;\n    \n    DisplayOriginal = UI(17).a < 0.;*/\n}\n\nvec3 getColor(vec3 pos, vec3 normal){\n\n\treturn baseColor(pos, normal);\n    //return vec3(.9,0.6,0.8);\n}\n\n//------------------------------------------------------------------\n//From gaz's : https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p)\n{\n    return DE(p);//DE() is defined in \"Common\"\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.0001;//cusps look better with high precision\n    float h = precis * 2.0;\n    float t = 1.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 256; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    vec4 mouse = UI(35);//R.y;\n    //mouse.xy = clamp(mouse.xy, vec2(-180.,-90.), vec2(180.,90.));\n    \n    p.zx = rotate(p.zx, iTime * 0. - (mouse.x)*PI/360.);\n    p.yz = rotate(p.yz, iTime * 0. + (mouse.y)*PI/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Global variable init\n    R = iResolution.xy;\n    //--------------------\n    vec2 uv = fragCoord.xy/R.y;\n    //vec4 mouse = UI(33)/R.y;\n    \n\t// display sliders and buttons \n\t{ float s = aff_sliders(uv); if (s>0.) { fragColor = s*vec4(1,.2,0,1); return;}}\n    { float s = aff_buttons(uv); if (s>0.) { fragColor = s*vec4(0,.2,1,1); return;}}\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.3 + p.y * 0.1);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 5.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    init();\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        col = getColor(pos,n) * dif + .5*pow(dif, 200.);\n        col = pow(col, vec3(0.45));\n\t}\n   \tfragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//By FabriceNeyret2: https://www.shadertoy.com/view/MdKGRw\n//With some modifications\n\n// only line 0, pixels 0 to 33 of bufA are used\n// if you need the full buffer but the .a components, you might adapt this util to use only .a \n\n#define FAKE_MOUSE 1 // fake mouse motion if no user input\n#define Sradius .02  // influence radius for sliders\n#define Bradius .04  // influence radius for buttons\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n\nvec2 R;// = iResolution.xy;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n#define add_button(x,y,v0)     { nbB++; if (U==vec2(nbB+16,0.)) O = vec4(x,y,0,v0);       }\n\nbool insideSlider(vec2 U, vec4 S){\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Sradius && abs(U.x-S.x-l/2.)<l/2. ) return true;\n        if (S.z<0. && abs(U.x-S.x)<Sradius && abs(U.y-S.y-l/2.)<l/2. ) return true;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return true;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return true;\n    return false;       \n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    R = iResolution.xy;\n    \n    O = texture(iChannel0,U/R);\n    U -= .5;\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        //add_slider (.05,.05,VERTIC,.5,.5); // --- define your sliders here ---\n                \n        //add_button ( .05,.95, -1.);          // --- define your buttons here ---\n                \n        if (U==vec2(0,0)) O = vec4(nbS, nbB, 0., 0.);\n        if (U==vec2(35,0)) O = vec4(0.);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  // previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)==0. && m.z<=0.) { // fake mouse motion if no user input\n\t        float t = iTime;         // you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    \n    if (U==vec2(34,0)) { O = UI(33); return; } // previous mouse state (for other shaders)\n    \n    if (U==vec2(35,0)){\n        if(iMouse.z/iResolution.y > 0.0 && iMouse.z/iResolution.y < float(iResolution.x)/float(iResolution.y)-0.0)\n            O.xy = O.zw + iMouse.xy - iMouse.zw;\n        else O = O.xyxy;\n        return;\n    }\n    \n    \n    if (iMouse.z>0. && U.y==0.) {          // --- let mouse trigers the right slider or button\n       \tvec2 M = iMouse.xy/iResolution.y;\n        if (U.x <= UI(0).x) {\n\t        vec4 S = UI(U.x);\n    \t    float l = abs(S.z);\n        \tvec2 m = iMouse.xy/iResolution.y;\n\t        if (S.z>0. && abs(M.y-S.y)<Sradius && abs(M.x-S.x-l/2.)<l/2. ) O.a = (M.x-S.x)/l;\n    \t    if (S.z<0. && abs(M.x-S.x)<Sradius && abs(M.y-S.y-l/2.)<l/2. ) O.a = (M.y-S.y)/l;\n    \t}\n        else if (UI(33).z<0. &&  U.x>16. && U.x<=16.+UI(0).y ) {\n\t        vec4 S = UI(U.x);\n            if (length(M-S.xy)<Bradius) O.a *= -1.;\n        }\n    }\n        \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#######################Testing automatic differentiation###################\n//... also testing if the shader compiler is good at optimizing expressions... :)\n//\n//  Every thing relevant is in this \"Common\" section. \"BufferA\" and \"Image\" are\n// from https://www.shadertoy.com/view/MdKGRw]shader and https://www.shadertoy.com/view/XtXGRS#\n//\n//  \n// \n//  1st part is a little automatic differentiation library\n//\n//  2nd part is the distance to implicit function surface code both using \n// numerical or automatic differentiation.\n//\n//  3rd part is a python module used to generate the function calls to the\n// automatic differentiation library\n//-------------------------------------------------------------------\n/*\n Fast and dirty automatic differentiation library.\n\n\t.x --> f\n\t.y --> Df\n\nPrefix : AD (for automatic differentiation)\nBinary functions/operations :\n\t- add :\n\t\t(ADvec, ADvec)\n\t\t(ADvec, number)\n\t\t(number, ADvec)\n\t- sub :\n\t\t(ADvec, ADvec)\n\t\t(ADvec, number)\n\t\t(number, ADvec)\n\t- mul :\n\t\t(ADvec, ADvec)\n\t\t(ADvec, number)\n\t\t(number, ADvec)\n\t- div :\n\t\t(ADvec, ADvec)\n\t\t(ADvec, number)\n\t\t(number, ADvec)\n\t- min :\n\t\t(ADvec, ADvec)\n\t- max :\n\t\t(ADvec, ADvec)\n\t\t\nUnary functions/operations :\n\t- neg (negate)\n\t- inv (multiplicative inverse)\n\t- abs\n\t- sqr  \n\t- sqrt \n\t- exp\n\t- log  \n\t- pow :\n\t\t* by real number exponent so the user should check the bounds.\n\t\t* by integer exponent\n\t- asin, Acos  \n\t- atan\n\t- sin\n\t- cos\n*/\n\n#ifndef TWO_PI \n\t#define TWO_PI 6.2831853 \n#endif \n#ifndef PI \n\t#define PI 3.141592653 \n#endif \n\nstruct DualFloat{\n\tfloat f;\n\tfloat df;\n};\n\n//Add\nDualFloat ADadd(in DualFloat v0, in DualFloat v1){\n\tv0.f  += v1.f;\n\tv0.df += v1.df;\n\treturn v0;\n}\n\nDualFloat ADadd(in float v0, in DualFloat v1){\n\tv1.f += v0;\n\treturn v1;\n}\n\nDualFloat ADadd(in DualFloat v0, in float v1){\n\treturn ADadd(v1, v0);\n}\n\n//Negate\nDualFloat ADneg(in DualFloat v){\n\tv.f = -v.f; \n\tv.df = -v.df;\n\treturn v;\n}\n\n//Subtract\nDualFloat ADsub(in DualFloat v0, in DualFloat v1){\n\treturn ADadd(v0, ADneg(v1));\n}\n\nDualFloat ADsub(in float v0, in DualFloat v1){\n\treturn ADadd(v0, ADneg(v1));\n}\n\nDualFloat ADsub(in DualFloat v0, in float v1){\n\treturn ADadd(v0, -v1);\n}\n\n//Multiply\nDualFloat ADmul(in DualFloat v0, in DualFloat v1){\n\treturn DualFloat( v0.f * v1.f, v0.f * v1.df + v1.f * v0.df);\n}\n\nDualFloat ADmul(in float v0, in DualFloat v1){\n\tv1.f *= v0; v1.df *= v0;\n\treturn v1;\n}\n\nDualFloat ADmul(in DualFloat v0, in float v1){\n\treturn ADmul(v1 , v0);\n}\n\n//Multiplicative inverse\nDualFloat ADinv(in DualFloat v){\n\tv.f = 1./v.f;\n\treturn ADmul( DualFloat( 1., -v.df * v.f ) , v.f );\n}\n\n//Divide\nDualFloat ADdiv(in DualFloat v0, in DualFloat v1){\n\treturn ADmul(v0, ADinv(v1) );\n}\n\nDualFloat ADdiv(in float v0, in DualFloat v1){\n\treturn ADmul(v0, ADinv(v1) );\n}\n\nDualFloat ADdiv(in DualFloat v0, in float v1){\n\treturn ADmul( v0, 1./v1 );\n}\n\n//util\n#ifndef EVENFUNC \n#define EVENFUNC \nbool even(in float n){return fract(n*0.5)==0.;}\nbool even(in int n){return even(float(n));}\n//bool even(in int n){return (n&1)==0;}\n\nfloat Npow(in float x, in int n){\n\tif(n==2) return x*x;\n\tif(n<0){n=-n; x=1./x;}\n\tfloat r = 1.;\n\tfloat p = x;\n\twhile(n>0){\n\t\tif(!even(n)){r*=p; n--;}\n\t\telse {p*=p; n/=2;}\n\t}\n\treturn r;\n}\n#endif \n\n\n//Some common functions\n//Monotonous functions are the easiest: just apply the function to the bounds of the interval and swap them in the case where the function decreases.\n//Othetwise it can become a little bit complicated.\n\nDualFloat ADexp(in DualFloat v){\n\treturn ADmul( DualFloat( 1., v.df) , exp(v.f) );\n}\n\nDualFloat ADsqr(in DualFloat v){\n\treturn DualFloat( v.f * v.f , 2. * v.df * v.f) ;\n}\n\nDualFloat ADabs(in DualFloat v){\n\tif( v.f < 0. ) {\n\t\tv.f = -v.f;\n\t\tv.df= -v.df;\n\t}\n\treturn v;\n}\n\nDualFloat ADmin(in DualFloat v0, in DualFloat v1){\n\tif( v0.f < v1.f ) return v0;\n\telse return v1;\n}\n\nDualFloat ADmax(in DualFloat v0, in DualFloat v1){\n\tif( v0.f > v1.f ) return v0;\n\telse return v1;\n}\n\n#if 1\n//quite complicated. In general p is a constat so the compiler should be able to simplify things a lot.\nDualFloat ADpow(in DualFloat v, in int p){\n\tif(p==0) return DualFloat( 1. , 0. );\n\tif(p<0) { v = ADinv(v); p = -p;}\n\tif(p==1) return v;\n\tif(p==2) return ADsqr(v);\n\tif(p==3) return DualFloat( v.f * v.f  * v.f , 3. * v.df * v.f * v.f );\n\tif(p==4) {float vx2 = v.f * v.f; return DualFloat( vx2 * vx2 , 4. * v.df * vx2 * v.f ) ;}\n\tif(p==5) {float vx2 = v.f * v.f; return DualFloat( v.f * vx2  * vx2 , 5. * v.df * vx2  * vx2 ) ;}\n\tif(p==6) {float vx2 = v.f * v.f; return DualFloat( vx2 * vx2  * vx2 , 6. * v.df * vx2  * vx2 * v.f );}\n\t// p > 4\n\tfloat s=sign(v.f);\n\tv = ADabs(v);\n\tfloat f = pow( v.f , float(p-1) ) ;\n\tv = DualFloat( v.f * f , float(p) * v.df * f ) ;// if v<0 --> nan that is why it is done this way\n\tif(even(p)) return v;\n\treturn ADmul( s , v );\n}\n#else\nDualFloat ADpow(in DualFloat v, in int p){\n\tif(p==0) return DualFloat( 1. , 0. );\n\tif(p<0) { v = ADinv(v); p = -p;}\n\t\n\tvec2 r = vec2( v.f , float(p) * v.df ) * Npow( v.f , p-1 );\n\treturn DualFloat( r.x , r.y );\n}\n#endif\n\n\nDualFloat ADlog(in DualFloat v){\n\treturn DualFloat( log(v.f) , v.df / v.f );\n}\n\nDualFloat ADsqrt(in DualFloat v){\n\tfloat r = sqrt(v.f);\n\treturn DualFloat( r , 0.5 * v.df / r );\n}\n\nDualFloat ADpow(in DualFloat v, in float p){//v must be positive ! //p is a constant .\n\treturn ADmul( DualFloat( v.f , p * v.df ) , pow( v.f , p - 1. ) );\n}\n\nDualFloat ADpow(in DualFloat v, in DualFloat p){//v.x must be positive ! //p is a constant .\n\treturn ADexp( ADmul( p , ADlog( v ) ) );\n}\n\nDualFloat ADasin(in DualFloat v){\n\treturn DualFloat( asin(v.f) , v.df / sqrt( 1. - v.f * v.f ) );\n}\n\nDualFloat ADacos(in DualFloat v){\n\treturn DualFloat( acos(v.f) , - v.df / sqrt( 1. - v.f * v.f ) );\n}\n\nDualFloat ADatan(in DualFloat v){\n\treturn DualFloat( atan(v.f) , v.df / ( 1. + v.f * v.f ) );\n}\n\nDualFloat ADcos(in DualFloat v){\n\treturn DualFloat( cos( v.f ) , - v.df * sin( v.f ) );\n}\n\nDualFloat ADsin(in DualFloat v){\n\treturn DualFloat( sin( v.f ) ,  v.df * cos( v.f ) );\n}\n//-------------------------------------------------------------------\n\n#define Phi (.5*(1.+sqrt(5.)))\n\n#define PHI  1.618034\n#define PHI2 2.618034\n#define PHI4 6.854102\n\n#define Tau (1.+2.*Phi)\n\n#define Eps 0.00048828125               //epsilon\n#define IEps 2048.0                     //Inverse of epsilon\n\nfloat param2       = 3.0;               //a prameter used in the DE formula. The value depends on the function\nfloat IntThick     = 0.001;             //interior thickness. Interior is where the function is <0\nfloat SphereCutRad = 2.5;               //the radius of the sphere that limits the extension of the rendered parts of the implicit  \n\n//The implicit function -------------------------------------\n//This is a degree 6 algebraic implicit function discovered by Barth.\nfloat Barth(float x, float y, float z){\n   \tfloat phi1=(1.+sqrt(5.))/2., phi2=phi1*phi1;\n\tfloat x2=x*x, y2=y*y, z2=z*z;\n   \treturn -(4.*(phi2*x2-y2)*(phi2*y2-z2)*(phi2*z2-x2)-(1.+2.*phi1)*(x2+y2+z2-1.)*(x2+y2+z2-1.));\n}\n\n//just a wrapper---------------------------------------\nfloat Fn1(vec3 p)\n{\n\treturn Barth(p.x,p.y,p.z);\n}\n\n//Estimate distance using numerical derivatives\nfloat Fn(vec3 p)\n{\n\tfloat v =Fn1(p);\n\tvec2 eps=vec2(Eps,0);\n\t//Compute gradient's length\n\tfloat dv=length(IEps*(vec3(Fn1(p+eps.xyy),Fn1(p+eps.yxy),Fn1(p+eps.yyx))-vec3(v)));\n\t\n\t//Use function value and gradient magnitude to get a distance estimate. param2 depends on the function at hand.\n    float k = 1.-1./(abs(v)+1.);\n\tv=v/(dv+param2*k+.001);\n\treturn 0.5*v;\n}\n\n//Using AutoDiff. The compiler seems to optimise the xpresesions very well.\n//This function was generated using a python script that converts expression to function calls form.\n//The python script is in the commented section belooow.\nDualFloat Barth(DualFloat x, DualFloat y, DualFloat z){\n\treturn ADneg(ADsub(ADmul(ADmul(ADmul(ADsub(ADmul(ADpow(x,2),2.618033988749895),ADpow(y,2)),4.0),ADsub(ADmul(ADpow(y,2),2.618033988749895),ADpow(z,2))),ADsub(ADmul(ADpow(z,2),2.618033988749895),ADpow(x,2))),ADmul(ADpow(ADsub(ADadd(ADadd(ADpow(x,2),ADpow(y,2)),ADpow(z,2)),1.0),2),4.23606797749979)));\n}\n\n//just a wrapper---------------------------------------\nDualFloat Fn1_(DualFloat x, DualFloat y, DualFloat z)\n{\n\treturn Barth(x,y,z);\n}\n\n//Estimate distance using automatic differentiation technique\nfloat Fn_(vec3 p){\n\t\n    //Compute gradient. The compiler should be able to inline and simplify.\n\tDualFloat vx = Fn1_( DualFloat(p.x, 1.), DualFloat(p.y, 0.), DualFloat(p.z, 0.) );\n\tDualFloat vy = Fn1_( DualFloat(p.x, 0.), DualFloat(p.y, 1.), DualFloat(p.z, 0.) );\n\tDualFloat vz = Fn1_( DualFloat(p.x, 0.), DualFloat(p.y, 0.), DualFloat(p.z, 1.) );\n\t\n\t//Length of gradient\n\tfloat dv = length(vec3( vx.df, vy.df, vz.df ));\n\t\n\t//Function value\n\tfloat v = vx.f;\n\t\n\t//Compute distance estimate\n\tfloat k = 1.-1./(abs(v)+1.);\n\tv=v/(dv+param2*k+.001);\n\treturn 0.5*v;\n}\n\n//---------------------------------------- \n\nfloat DE(vec3 z)\n{\n\tfloat v =Fn_(z); v=abs(v+IntThick)-IntThick;\n\n\tv = max(v,length(z)-SphereCutRad);\n\t\n\treturn v;\n}\n\nvec3 baseColor(vec3 z, vec3 n){\n\tfloat v =Fn(z);\n\tif(v>-2.*IntThick) return mix(n,vec3(0.75,0.75,0.75),0.8);\n\treturn vec3(.95,0.05,0.0);\n}\n\n//Python script------------------------------------------\n/*\n\nfrom numbers import Number\nimport math\n\n#The prefix and suffix are here because my IA and autoDiff functions have different prefixes...\nprefix = \"AD\"\nsuffix = \"\"\n    \n#isinstance(n,number)\n#type(n)\n\ndef sgn(x):\n    if(x<0):\n        return -1.\n    else:\n        return 1.\n\ndef mmin(x,y):\n    if(x<y):\n        return x\n    else:\n        return y\n\ndef mmax(x,y):\n    if(x>y):\n        return x\n    else:\n        return y\n\nclass expression:\n\n    \"\"\"The purpose of this class is to 'symbolically' compute the derivative of an expression.\n       It outputs the expression (and its derivative) in function calls form. The output is in\n       glsl syntax. to be used with \"SimpleIA.frag\". \n       The glsl compiler should be good enought to simplify the returned expression... I hope!\n       It also computes constant expressions to some extent.\n       For an usage example see Dervish function below (&co.).\"\"\"\n    \n    def __init__(self, val, dval):\n        self.val = val\n        self.dval = dval\n\n    def __str__(self):\n        return \" f: \" + self.val + \"\\ndf: \" + self.dval \n\n    def __repr__(self):\n        return str(self)\n\n    def __neg__(self):\n        return expression( \"-(\" + self.val + \")\" , \"-(\" + self.dval + \")\" )\n    \n    def __add__(self, b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"add\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"add\" + suffix + \"(\" + self.dval + \",\" + b.dval + \")\" )\n        else:\n            if(b!=0):\n                return expression( prefix + \"add\" + suffix + \"(\" + self.val + \",\" + str(float(b)) + \")\" ,\n                                   self.dval )\n            else:\n                return self\n\n    def __radd__(self, b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"add\" + suffix + \"(\" + b.val + \",\" + self.val + \")\" ,\n                               prefix + \"add\" + suffix + \"(\" + b.dval + \",\" + self.dval + \")\" )\n        else:\n            if(b!=0):\n                return expression( prefix + \"add\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \")\",\n                                   self.dval )\n            else:\n                return self\n\n    def __sub__(self, b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"sub\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"sub\" + suffix + \"(\" + self.dval + \",\" + b.dval + \")\" )\n        else:\n            if(b!=0):\n                return expression( prefix + \"sub\" + suffix + \"(\" + self.val + \",\" + str(float(b)) + \")\" ,\n                                   self.dval )\n            else:\n                return self\n\n    def __rsub__(self, b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"sub\" + suffix + \"(\" + b.val + \",\" + self.val + \")\" ,\n                               prefix + \"sub\" + suffix + \"(\" + b.dval + \",\" + self.dval + \")\")\n        else:\n            if(b!=0):\n                return expression( prefix + \"sub\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \")\" ,\n                                   prefix + \"neg\" + suffix + \"(\" + self.dval + \")\" )\n            else:\n                return expression( prefix + \"neg\" + suffix + \"(\" + self.val + \")\" ,\n                                   prefix + \"neg\" + suffix + \"(\" + self.dval + \")\" )\n\n    def __mul__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"add\" + suffix + \"(\" + \n                                   prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + b.dval +\n                               \"),\" +\n                                   prefix + \"mul\" + suffix + \"(\" + b.val + \",\" + self.dval + \"))\" )\n        else:\n            if(b==0):\n                return expression(\"0.\",\"0.\")\n            else:\n                if(b==1):\n                    return self\n                else:\n                    return expression( prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + str(float(b)) + \")\",\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + str(float(b)) + \")\")\n\n    def __rmul__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"mul\" + suffix + \"(\" + b.val + \",\" + self.val + \")\",\n                               prefix + \"add\" + suffix + \"(\" + \n                                   prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + b.dval +\n                               \"),\" +\n                                   prefix + \"mul\" + suffix + \"(\" + b.val + \",\" + self.dval + \"))\" )\n        else:\n            if(b==0):\n                return expression(\"0.\",\"0.\")\n            else:\n                if(b==1):\n                    return self\n                else:\n                    return expression( prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + str(float(b)) + \")\",\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + str(float(b)) + \")\" )\n\n    def __truediv__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"div\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"div\" + suffix + \"(\" + \n                                   prefix + \"sub\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + b.val + \"),\" +\n                                       prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" + self.val + \")),\" +\n                                   prefix + \"pow\" + suffix + \"(\" + b.val + \",2))\")\n        else:\n            if(b==1):\n                return self\n            else:\n                return expression( prefix + \"mul\" + suffix + \"(\" + self.val + \",\" + str(1./float(b)) + \")\",\n                                   prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + str(1./float(b)) + \")\")\n\n    def __rtruediv__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"div\" + suffix + \"(\" + b.val + \",\" + self.val + \")\",\n                               prefix + \"div\" + suffix + \"(\" + \n                                   prefix + \"sub\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" + self.val + \"),\" +\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + b.val + \")),\" +\n                                   prefix + \"pow\" + suffix + \"(\" + self.val + \",2))\")\n        else:\n            if(b==0):\n                return expression(\"0.\",\"0.\")\n            else:\n                return expression( prefix + \"div\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \")\",\n                                   prefix + \"div\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(-\" + str(float(b)) + \",\" + self.dval + \"),\" +\n                                       prefix + \"pow\" + suffix + \"(\" + self.val + \",2))\" )\n#-----------------------------\n    def __pow__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"pow\" + suffix + \"(\" + self.val + \",\" + b.val + \")\",\n                               prefix + \"mul\" + suffix + \"(\" +\n                                   prefix + \"pow\" + suffix + \"(\" + self.val + \",\" + b.val + \"),\" +\n                                   prefix + \"add\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" + prefix + \"log\" + suffix + \"(\" + self.val + \")),\" + \n                                       prefix + \"div\" + suffix + \"(\" + b.val + \",\" + self.val + \")))\" )\n        else:\n            if(b==0):\n                return expression(\"1.\",\"0.\")\n            else:\n                if(b==1):\n                    return self\n                else:\n                    if(b==2):\n                        return expression( prefix + \"pow\" + suffix + \"(\" + self.val + \",\" + str(b) + \")\",\n                                           prefix + \"mul\" + suffix + \"(\" + str(float(b)) + \",\" +\n                                               prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + self.val + \"))\" )\n                    else:\n                        return expression( prefix + \"pow(\" + suffix + \"(\" + self.val + \",\" + str(b) + \")\",\n                                           prefix + \"mul\" + suffix + \"(\" + str(float(b)) + \",\" +\n                                           prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" +\n                                           prefix + \"pow\" + suffix + \"(\" + self.val + \",\" + str(b-1) + \")))\" )\n                        \n\n    def __rpow__(self,b):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"pow\" + suffix + \"(\" + b.val + \",\" + self.val + \")\",\n                               prefix + \"mul\" + suffix + \"(\" +\n                                   prefix + \"pow\" + suffix + \"(\" + b.val + \",\" + self.val + \"),\" +\n                                   prefix + \"add\" + suffix + \"(\" +\n                                       prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + prefix + \"log\" + suffix + \"(\" + b.val + \")),\" + \n                                       prefix + \"div\" + suffix + \"(\" + self.val + \",\" + b.val + \")))\" )\n        else:\n            if(b==0):\n                return expression(\"0.\",\"0.\")\n            else:\n                if(b==1):\n                    return expression(\"1.\",\"0.\")\n                else:\n                    return expression( prefix + \"pow\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \")\",\n                                       prefix + \"mul\" + suffix + \"(\" +\n                                           prefix + \"mul\" + suffix + \"(\" + self.dval + \",\" + str(math.log(b)) + \")),\" +\n                                           prefix + \"pow\" + suffix + \"(\" + str(float(b)) + \",\" + self.val + \"))\" )\n\n#TOFIX : Interval library specific output!!! not general purpose :-/\n    def __abs__(self):\n        return expression( prefix + \"abs\" + suffix + \"(\" + self.val + \")\",\n                           self.val + \".lo>0.?\" + self.dval + \":\" +\n                               \"(\" + self.val + \".hi<0.?\" + prefix + \"neg\" + suffix + \"(\" + self.dval + \"):\" +\n                                prefix + \"mul\" + suffix + \"(Interval(-1.,1.),\" + self.dval +\"))\" )\n\n    def __neg__(self):\n        return expression( prefix + \"neg\" + suffix + \"(\" + self.val + \")\",\n                           prefix + \"neg\" + suffix + \"(\" + self.dval + \")\" )\n\n#------------------------------------------------------------------------------------------------------------------\n#functions\n\n#TOFIX : Interval library specific output!!! not general purpose :-/\ndef fabs(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"abs\" + suffix + \"(\" + self.val + \")\",\n                           self.val + \".lo>0.?\" + self.dval + \":\" +\n                               \"(\" + self.val + \".hi<0.?\" + prefix + \"neg\" + suffix + \"(\" + self.dval + \"):\" +\n                                prefix + \"mul\" + suffix + \"(Interval(-1.,1.),\" + self.dval +\"))\" )\n    else:\n        return expression( str(float(abs(b))),\"0.\" )\n    \ndef sign(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"sign\" + suffix + \"(\" + b.val + \")\" ,\n                           \"0.\" )\n    else:\n        return expression( str(float(sgn(b))),\"0.\" )\n\ndef sin(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"sin\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"cos\" + suffix + \"(\" + b.val + \"))\" )\n    else:\n        return expression( str(math.sin(b)) ,\"0.\" )\n\ndef cos(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"cos\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"mul\" + suffix + \"(\" + prefix + \"neg\" + suffix + \"(\" + b.dval + \"),\" +\n                               prefix + \"sin\" + suffix + \"(\" + b.val + \"))\" )\n    else:\n        return expression( str(math.cos(b)) ,\"0.\" )\n\ndef exp(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"exp\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"mul\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"exp\" + suffix + \"(\" + b.val + \"))\" )\n    else:\n        return expression( str(math.exp(b)) ,\"0.\" )\n\ndef log(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"log\" + suffix +\"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix +\"(\" + b.dval + \",\" + b.val + \")\" )\n    else:\n        return expression( str(math.log(b)) ,\"SimpleIA.frag\" )\n\ndef sqrt(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"sqrt\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix + \"(\" +\n                               prefix + \"mul\" + suffix + \"(0.5,\" + b.dval + \"),\" +\n                               prefix + \"sqrt\" + suffix + \"(\" + b.val + \"))\" )\n    else:\n        return expression( str(math.sqrt(b)) ,\"0.\" )\n\ndef atan(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"atan\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"add\" + suffix + \"(1.,\" + prefix + \"pow\" + suffix + \"(\" + b.val + \",2)))\" )\n    else:\n        return expression( str(math.atan(b)) ,\"0.\" )\n\ndef asin(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"asin\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"sub\" + suffix + \"(1.,\" + prefix + \"pow\" + suffix + \"(\" + b.val + \",2)))\" )\n    else:\n        return expression( str(math.asin(b)) ,\"0.\" )\n\ndef acos(b):\n    if( isinstance( b , expression)):\n        return expression( prefix + \"acos\" + suffix + \"(\" + b.val + \")\" ,\n                           prefix + \"div\" + suffix + \"(\" + b.dval + \",\" +\n                               prefix + \"sub\" + suffix + \"(\" + prefix + \"pow\" + suffix + \"(\" + b.val + \",2),1.))\" )\n    else:\n        return expression( str(math.acos(b)) ,\"0.\" )\n\n#TOFIX : Interval library specific output!!! not general purpose :-/\n#these two are nasty wrt performance simply because they are two arguments functions. Imagine what would happen when nesting mins and maxs!!!\n#One needs to evaluate the arguments first and then use these min & max on new variables.\n#example: see getfun()\n#... Anyway... better avoid using min and max :D\ndef min(a,b):\n    if( isinstance( a , expression)):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"min\" + suffix + \"(\" + a.val + \",\" + b.val + \")\",\n                               a.val + \".hi<\" + b.val + \".lo?\" + a.dval + \":(\" +\n                                   b.val + \".hi<\" + a.val + \".lo?\" + b.dval + \":\" +\n                                       \"Interval(min(\" + a.dval + \".lo,\" + b.dval + \".lo),max(\" + a.dval + \".hi,\" + b.dval + \".hi)))\" )\n        else:\n            return expression( prefix + \"min\" + suffix + \"(\" + a.val + \",\" + str(float(b)) + \")\",\n                               a.val + \".hi<\" + str(float(b))+ \"?\" + a.dval + \":(\" +\n                                   str(float(b)) + \"<\" + a.val + \".lo?Interval(0.,0.):\" +\n                                       \"Interval(min(\" + a.dval + \".lo,0.),max(\" + a.dval + \".hi,0.)))\" )\n    else:\n        if( isinstance( b , expression)):\n            return expression( prefix + \"min\" + suffix + \"(\" + str(float(a)) + \",\" + b.val + \")\",\n                               str(float(a)) + \"<\" + b.val + \".lo?Interval(0.,0.):(\" +\n                                   b.val + \".hi<\" + str(float(a)) + \"?\" + b.dval + \":\" +\n                                       \"Interval(min(\" + b.dval + \".lo,0.),max(\" + b.dval + \".hi,0.)))\" )\n        else:\n            return expression( str(float(mmin(a,b))),\n                               \"0.\" )\n\ndef max(a,b):\n    if( isinstance( a , expression)):\n        if( isinstance( b , expression)):\n            return expression( prefix + \"max\" + suffix + \"(\" + a.val + \",\" + b.val + \")\",\n                               a.val + \".lo>\" + b.val + \".hi?\" + a.dval + \":(\" +\n                                   b.val + \".lo>\" + a.val + \".hi?\" + b.dval + \":\" +\n                                       \"Interval(min(\" + a.dval + \".lo,\" + b.dval + \".lo),max(\" + a.dval + \".hi,\" + b.dval + \".hi)))\" )\n        else:\n            return expression( prefix + \"max\" + suffix + \"(\" + a.val + \",\" + str(float(b)) + \")\",\n                               a.val + \".lo>\" + str(float(b))+ \"?\" + a.dval + \":(\" +\n                                   str(float(b)) + \">\" + a.val + \".hi?Interval(0.,0.):\" +\n                                       \"Interval(min(\" + a.dval + \".lo,0.),max(\" + a.dval + \".hi,0.)))\" )\n    else:\n        if( isinstance( b , expression)):\n            return expression( prefix + \"max\" + suffix + \"(\" + str(float(a)) + \",\" + b.val + \")\",\n                               str(float(a)) + \">\" + b.val + \".hi?Interval(0.,0.):(\" +\n                                   b.val + \".lo>\" + str(float(a)) + \"?\" + b.dval + \":\" +\n                                       \"Interval(min(\" + b.dval + \".lo,0.),max(\" + b.dval + \".hi,0.)))\" )\n        else:\n            return expression( str(float(mmax(a,b))),\n                               \"0.\" )\n\n#------------------------------------------------------------------------------------------------------------------\n#Example: the dervish is spinning fast\n#Better use math.xxx functions for constants.\ndef Dervish(x,y,z):\n   z=-z\n   c=math.sqrt(5-math.sqrt(5))/2                            #constant\n   r=(1+3*math.sqrt(5))/4\n   q=(1-c*z)*(x**2+y**2-1+r*z**2)**2;                       #not a constant\n   a=-(8/5)*(1+1/math.sqrt(5))*math.sqrt(5-math.sqrt(5))    \n   Pi=math.pi\n   h1=x-z\n   h2=cos(2*Pi/5)*x-sin(2*Pi/5)*y-z                         #hopefully the autodiff fully computes the constants in this case\n   h3=cos(4*Pi/5)*x-sin(4*Pi/5)*y-z\n   h4=cos(6*Pi/5)*x-sin(6*Pi/5)*y-z\n   h5=cos(8*Pi/5)*x-sin(8*Pi/5)*y-z\n   FF=h1*h2*h3*h4*h5\n   return a*FF+q\n\n#Another one\ndef wave(x,y,z):\n    r=exp(-(x**2+y**2))*sin(2*x)\n    return z-r\n\ndef Barth(x,y,z):\n    phi1 = ( 1 + math.sqrt(5) ) / 2\n    phi2= phi1**2\n    r = -(4*(phi2*x**2-y**2)*(phi2*y**2-z**2)*(phi2*z**2-x**2)-(1+2*phi1)*(x**2+y**2+z**2-1)**2)\n    return r\n\n#another one\ndef getfun():\n    x = expression(\"x\",\"dx\")\n    y = expression(\"y\",\"dy\")\n    z = expression(\"z\",\"dz\")\n    r1= x**2 + y**2\n    r2= x**2 + z**2\n    fr1=expression(\"r1\",\"dr1\")\n    fr2=expression(\"r2\",\"fr2\")\n    r3 =min(fr1,fr2)\n    #let's return the glsl function code\n    str = (\"Interval getfun(Interval x, Interval y, Interval z, Interval dx, Interval dy, Interval dz){\\n\" +\n           \"    Interval r1 = \" + r1.val + \", dr1 = \" + r1.dval + \";\\n\" +\n           \"    Interval r2 = \" + r2.val + \", dr2 = \" + r2.dval + \";\\n\" +\n           \"    Interval r3 = \" + r3.val + \", dr3 = \" + r3.dval + \";\\n\" +\n           \"    return dr3; //well I can only return one interval :o)\\n\" +\n           \"}\")\n    return str\n                \n#basic usage\ndef basicUsage():\n    x = expression(\"x\",\"dx\")    #define variables\n    y = expression(\"y\",\"dy\")\n    z = expression(\"z\",\"dz\")\n    c = Barth(x,y,z)            #expression. you can also do for example: c = wave(x,y,z) #wave() is defined above\n    print(c.val)                # val member contains the original expression written in function calls\n    #print(c.dval)               #dval contains the derivative expression also written in function calls\n    #or : print(c)\n\n\n*/", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 332, 366, 935], [937, 937, 964, 1003, 1460], [1462, 1462, 1489, 1528, 1797], [2060, 2060, 2073, 2106, 2445], [2447, 2447, 2484, 2484, 2550], [2552, 2675, 2711, 2711, 2762], [2764, 2764, 2786, 2786, 2835], [2837, 2837, 2865, 2865, 3033], [3035, 3035, 3072, 3072, 3409], [3411, 3411, 3438, 3438, 3672], [3674, 3674, 3731, 3755, 4671]], "test": "untested"}
{"id": "wdGfWy", "name": "light trajectory - 2D blackhole2", "author": "FabriceNeyret2", "description": "Mouse move black hole.\nInteractive version of [url]https://shadertoy.com/view/wdt3zM[/url]\nSimulates (slow) rays trajectory around a blackhole along a 2D slice.\nPhysics adapted from set111's 3D black hole [url]https://www.shadertoy.com/view/tsBXW3[/url]", "tags": ["simulation", "blackhole", "physics", "optics", "relativity"], "likes": 17, "viewed": 505, "published": 3, "date": "1607854384", "time_retrieved": "2024-07-30T20:30:44.449495", "image_code": "// variant of https://shadertoy.com/view/wdt3zM\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O-=O; \n    vec2 U = ( 2.*u - R ) / R.y, P, _P,\n         C = T(vec2(0,N)).xy;\n    O += .3*S( length(U-C) - .625*Size );    // draw BH photon sphere. why .625 ? \n    \n    float d = 1e5, i_=-1., i=0., j, v;\n    for (i=0.; i < N; i ++ ) {\n        for (P.x=-99.,j=0.; j < min(L,float(iFrame)); j ++ ) {\n            _P = P; P = T(vec2(j,i)).xy,\n            v = line( U, _P, P);\n            if ( v < d ) d = v, i_ = i;\n            v = dot(P-C,P-C);\n            if ( v < .01 ) break;\n        }\n    }   \n   if (i_>=0.) O += S( sqrt(d) -0./R.y ) * hue(i_/R.y);\n\n    \n    O = sqrt( O );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u ) // --- simulates trajectories\n{\n    vec2 M = iMouse.xy; \n    if ( M != vec2(0) ) M = ( 2.*iMouse.xy - R ) / R.y;\n    M += .002* cos(12.*iTime+vec2(0,11));\n    if (u==vec2(.5,N+.5)) O.xy = M;\n    if ( u.y > N ) return;                    // simulates only N lines\n\n    if (u.x==.5) { \n        O = vec4( -R.x/R.y,                   // init position\n                   u.y/N *2.-1., // + 2e-4 * sin(12.*iTime),\n                   1,0);                      // init dir\n        return;\n    }\n                                              // --simulates physics\n    O = T(u-vec2(1,0));  // previous state.  O.xy = pos, O.zw = dir (normalized)\n    // Physics adapted from set111's 3D black hole https://www.shadertoy.com/view/tsBXW3\n    vec2 D = O.xy - M;\n    float r = length(D);                      // distance to BH\n    float d  = min( .92,// * abs(O.y /O.w) ,  // conservative distance to disk (y==0)   \n                   min( r*.5,                 // limit step size far from to BH \n                        r*.1 + .05*r*r/Size   // limit step size close to BH ← winner for r<5\n                  )   );\n    float F = Size * .625 /(r*r);             // bending force\n    O.zw = normalize( O.zw - d * F* D/r );    // bend ray towards BH\n    O.xy += d * O.zw;                \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Size .6               // size of BH ( Schwarzschild radius or photon sphere ? )\n#define N    72.              // number of ray trajectories\n#define L    60.              // max segments per trajectory\n#define R    iResolution.xy\n\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n\n// utils from https://www.shadertoy.com/view/llySRh\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),                  // proj coord on line\n          c = clamp(h, 0., 1.);\n    p -= b * h; return h==c ? dot(p,p): 1e5;          // dist² to segment\n}\n\n#define S(v) smoothstep( 3./R.y, 0., v)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 669]], "test": "untested"}
{"id": "wsGBWy", "name": "light trajectory - 2D white src", "author": "FabriceNeyret2", "description": "Simulates rays trajectory around a white fountain (opposite of blackhole) along a 2D slice.\njust reusing [url]https://shadertoy.com/view/wdt3zM[/url] with opposite sign.", "tags": ["simulation", "blackhole", "physics", "optics", "relativity", "whitefountain"], "likes": 6, "viewed": 371, "published": 3, "date": "1607850102", "time_retrieved": "2024-07-30T20:30:45.226417", "image_code": "// Variant of \"light trajectory - 2D black hole\" https://shadertoy.com/view/wdt3zM\n// Just changing the sign of F,  and smaller Size\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = sqrt( T(U) );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define Size .1                      //size of BH ( Schwarzschild radius or photon sphere ? )\n\nvoid mainImage( out vec4 O, vec2 u ) // --- simulates trajectories\n{\n    O = T(u);\n    \n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n\n    if ( T(2).xy != R ) {\n        O -= O;\n        if (u.x<2.) O = vec4(U,1,0);     // init positions: .xy and dir: .zw\n        else if (u==vec2(2.5)) O.xy = R; // for testing window size change\n            else O += .3*S( length(U) - .625*Size ); // draw BH photon sphere. why .625 ?\n        return;\n    }\n    if (u==vec2(2.5)) return;\n   \n    if (u.x==.5) {                           // simulates physics\n        // O.xy = pos, O.zw = dir (normalized)\n        // Physics adapted from set111's 3D black hole https://www.shadertoy.com/view/tsBXW3\n        float r = length(O.xy);                   // distance to BH\n        float d  = min( .92,// * abs(O.y /O.w) ,  // conservative distance to disk (y==0)   \n                       min( r*.5,                 // limit step size far from to BH \n                            r*.1 + .05*r*r/Size   // limit step size close to BH \n                      )   );\n        float F = -Size * .625 /(r*r);             // bending force\n        O.zw =  normalize(O.zw - d * F* O.xy/r ); // bend ray towards BH\n        O.xy += d * O.zw;                \n    }\n    else if (u.x==1.5)                       // save prev position for drawing\n        O = T(vec2(.5,u.y));\n    else {                                   // draw rays (new segment)\n        float d = 1e5, i_, i=0., v;\n        for (; i < R.y; i += 5. ) {\n            v = line( U, T(vec2(1,i)).xy, T(vec2(0,i)).xy);\n            if ( v < d ) d = v, i_ = i;\n        }\n        O += S( sqrt(d) -0./R.y ) * hue(i_/R.y);\n    }   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n\n// utils from https://www.shadertoy.com/view/llySRh\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),                  // proj coord on line\n          c = clamp(h, 0., 1.);\n    p -= b * h; return h==c ? dot(p,p): 1e5;          // dist² to segment\n}\n\n#define S(v) smoothstep( 3./R.y, 0., v)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 172, 172, 196]], "test": "untested"}
{"id": "tdGBDG", "name": "Variables with ShaderToy Buffers", "author": "oneshade", "description": "Short tutorial on how to store and update variables in ShaderToy. See comments for details. If you have a question, you can ask below. I'll do my best to help. Click the screen to fade from blue to red.", "tags": ["tutorial", "shadertoy", "buffers", "variables"], "likes": 33, "viewed": 3978, "published": 3, "date": "1607839104", "time_retrieved": "2024-07-30T20:30:45.997356", "image_code": "// Example of using buffers to carry states between frames.\n// Important note: colors are not clamped so you have a pretty broad range to store data in.\n\n// Common - code available to all tabs (it is quite literally inserted into each)\n// Buffer A - code for variable management\n// Image - main shader that outputs to the display\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = fetchData(iChannel0, SCREEN_COLOR_ADDR).rgb;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Addresses:\n// These should be ivec2s containing the pixel coordinates of where certain data\n// should go. The coordinates are not normalize but can range from (0, 0) to\n// (iResolution.x, iResolution.y).\nconst ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n\n// Unfortunately, the only way to define functions that sample iChannels in Common\n// is with #define :(\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0); // Initial value\n    }\n\n    if (iFrame > 0) { // After initialization\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n            fragColor = fetchData(iChannel0, SCREEN_COLOR_ADDR); // Load value from previous frame\n\n            // Update:\n            if (iMouse.z > 0.0) {\n                // When the mouse is pressed fade into red\n                fragColor.b -= 0.05;\n                fragColor.r += 0.05;\n                fragColor = clamp(fragColor, 0.0, 1.0); // Clamp to prevent color from changing to slowly the opposite way\n            }\n\n            else {\n                // Otherwise fade back to blue\n                fragColor.b += 0.05;\n                fragColor.r -= 0.05;\n                fragColor = clamp(fragColor, 0.0, 1.0); // Clamp to prevent color from changing to slowly the opposite way\n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 386, 386, 484]], "test": "untested"}
{"id": "WdyfDy", "name": "Raymarched 3D Fractal Noise", "author": "oneshade", "description": "Raymarched 3D fractal noise looks pretty cool! I tried accelerating it by first testing whether the point is inside the bounding box but I am not sure just how efficient it is (unrolled). Mouse x to set threshold, mouse y to set octaves (layers).", "tags": ["3d", "raymarching", "organic", "fractalnoise"], "likes": 6, "viewed": 245, "published": 3, "date": "1607821328", "time_retrieved": "2024-07-30T20:30:46.769292", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat Noise3D(in vec3 p3) {\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3D(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = Noise3D(cell);                       // Left, Down, Back\n    float rdb = Noise3D(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = Noise3D(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = Noise3D(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = Noise3D(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = Noise3D(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = Noise3D(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = Noise3D(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat FractalNoise3D(in vec3 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise3D(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nfloat mapScene(in vec3 p) {\n    float octaves = 4.0;\n    float threshold = 0.4;\n\n    if (iMouse.z > 0.0) {\n        octaves = iMouse.y / iResolution.y * 4.0;\n        threshold = iMouse.x / iResolution.x * 0.9;\n    }\n\n    vec3 q = abs(p) -1.5;\n    float bbox = max(q.x, max(q.y, q.z));\n\n    return max(FractalNoise3D(p, 2.0, octaves) - threshold, bbox);\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0), rd = normalize(vec3(uv, -1.0)), p;\n    float dt = 0.0, d;\n    bool hit = false;\n\n    for (int iter=0; iter < 100; iter++) {\n        p = ro + rd * dt;\n\n        p.y -= 0.3;\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        vec3 q = abs(p) - 1.5;\n        d = max(q.x, max(q.y, q.z));\n        if (d < 0.001) {\n            d = mapScene(p);\n            if (d < 0.001) {\n                hit = true;\n                break;\n            }\n        }\n\n        if (dt > 10.0) {\n            break;\n        }\n\n        dt += d;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p);\n        fragColor.rgb += 0.5 + 0.5 * n;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 285, 312, 312, 416], [418, 418, 450, 450, 1390], [1392, 1392, 1459, 1459, 1744], [1746, 1746, 1773, 1773, 2099], [2101, 2101, 2128, 2128, 2435], [2437, 2437, 2492, 2492, 3344]], "test": "untested"}
{"id": "WdyfWy", "name": "Fractal Noise 3D", "author": "oneshade", "description": "3D analog of 2D fractal noise. That's a lot of mixing!", "tags": ["3d", "noise", "fractalnoise", "tricubic", "layernoise"], "likes": 1, "viewed": 251, "published": 3, "date": "1607813028", "time_retrieved": "2024-07-30T20:30:47.541228", "image_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat Noise3D(in vec3 p3) {\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat SmoothNoise3D(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = Noise3D(cell);                       // Left, Down, Back\n    float rdb = Noise3D(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = Noise3D(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = Noise3D(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = Noise3D(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = Noise3D(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = Noise3D(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = Noise3D(cell + vec3(1.0, 1.0, 1.0)); // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat FractalNoise3D(in vec3 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise3D(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(FractalNoise3D(vec3(uv, iTime), 4.0, 4.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 90, 117, 117, 221], [223, 223, 255, 255, 1195], [1197, 1197, 1264, 1264, 1549], [1551, 1551, 1606, 1606, 1739]], "test": "untested"}
{"id": "tsKBzt", "name": "Day 353", "author": "jeyko", "description": "some voronoi particle tracking!", "tags": ["mdtmjvm"], "likes": 9, "viewed": 376, "published": 3, "date": "1607810790", "time_retrieved": "2024-07-30T20:30:48.325132", "image_code": "void mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n    vec2 uvn = (U - R*0.5)/R.y;\n    C = T(U);\n    \n    //C = mix(C,4.-  C, T2(U).x);\n    vec4 me = T1(U);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec4 r42(vec2 u){\n    return texture(iChannel1,u/iResolution.xy);\n}\n\nconst float velScale = 0.001;\n\n\nvec4 get(vec2 u){\n    vec4 g = T(u);\n    vec2 muvn = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    g.zw = mix(g.zw, -normalize(muvn - g.xy ),0.02*float(iMouse.z > 0.)*smoothstep(1.,0.,length(g.xy - muvn)*2. ));\n    \n    g.xy += sin(g.xy*9. + iTime*3. + g.zw*sin(iTime + g.z))*0.0004;\n    \n    g.xy += g.zw*velScale;\n    \n    if (abs(g.x)>0.5*R.x/R.y){\n        g.z *= -1.;\n        g.x += 2.*g.z*velScale;\n    }\n    if (abs(g.y)>0.9*R.y/R.x){\n        g.w *= -1.;\n        g.y += 2.*g.w*velScale;\n    }\n    \n    return g;\n}\n\n/*\n\nvec4 otherc = other;                \\\n        otherc.xy *= 1. - 2.*vec2(             \\\n            float(abs(me.x) > 0.5 && abs(other.x) > 0.5 && sign(other.x) != sign(me.x) ), \\\n            float(abs(me.y) > 0.5 && abs(other.y) > 0.5 && sign(other.y) != sign(me.y) )  \\\n        ); \\\n        \n\n*/\n\n#define check(dir,times) \\\n    for(float i = 1.; i < times + 1.; i++){ \\\n        vec4 other = get(U + dir*i);        \\\n        if(length(uvn - other.xy) < length(uvn-me.xy)){me = other;}\\\n    }\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U)/R;\n    vec2 uvn = (U - R*0.5)/R.y;\n\n\n    \n\n    C = T(U);\n\n    vec4 me = get(U);\n    \n    \n    float steps = 4.;\n    \n    check(vec2(0,1)    ,steps);\n    check(vec2(0,-1)   ,steps);\n    check(vec2(1,0)    ,steps);\n    check(vec2(-1,0)   ,steps);\n    check(vec2(1,1)    ,steps);\n    check(vec2(-1,-1)  ,steps);\n    check(vec2(1,-1)   ,steps);\n    check(vec2(-1,1)   ,steps);\n    \n    C = me;\n    \n\n    if(iFrame < 2){\n        C = r42(U*10.)*2. - 1.;\n        //C = vec4(sin(U.x/10.),0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texture(iChannel0,(u)/iResolution.xy)\n#define T1(u) texture(iChannel1,(u)/iResolution.xy)\n#define T2(u) texture(iChannel2,(u)/iResolution.xy)\n\n#define R (iResolution.xy)\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))", "buffer_b_code": "vec2 uvn;\nfloat stepSz = 1.;\n\nfloat check(vec4 me,vec2 U,vec2 dir, float times){\n    for(float i = 1.; i < times + 1.; i++){\n        vec4 other = T(U + dir*i*stepSz); \n        if(other != me){return i;}\n    }\n    return times;\n}\n\nvoid mainImage( out vec4 col, in vec2 U )\n{\n    vec2 uv = U/R;\n \n    uvn = (U - R*0.5)/R.y;\n\n    vec4 me = T(U);\n\n    col = T1(U);\n    vec4 C = pal(0.,1.,vec4(5,3,4,1.),1.  + iTime*0.3,4. + me.xyyy*1. + me.z - iTime*0.3 - sin(me.w*21.));\n    \n    float steps = 14. + sin(iTime + uv.x)*4.;\n    \n    steps *= 1.4;\n    #define shade(expression) C *= (steps - expression)/steps;\n    shade(check(me, U, vec2(0,1)    ,steps));\n    shade(check(me, U, vec2(0,-1)   ,steps));\n    shade(check(me, U, vec2(1,0)    ,steps));\n    shade(check(me, U, vec2(-1,0)   ,steps));\n    shade(check(me, U, vec2(1,1)    ,steps));\n    shade(check(me, U, vec2(-1,-1)  ,steps));\n    shade(check(me, U, vec2(1,-1)   ,steps));\n    shade(check(me, U, vec2(-1,1)   ,steps));    \n    \n    \n    //C = 1. - C;\n    \n    //C *= 1.-smoothstep(dFdx(uv.x),0., length(uvn - me.xy) - 0.003);\n    //C = mix(C,vec4(1.)*0.01,smoothstep(dFdx(uv.x),0., length(uvn - me.xy) - 0.003));\n    \n    //C = mix(C,1. - col,smoothstep(dFdx(uv.x),0., length(uvn - me.xy) - 0.003  ));\n    \n    //C = smoothstep(0.,1.,C);\n    \n    C = pow(abs(C),vec4(0.4545));\n    if (iFrame > 2)\n        col = mix(C,col,0.4);\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 col, in vec2 U )\n{\n    vec2 uv = U/R;\n \n    vec2 uvn = (U - R*0.5)/R.y;\n\n    vec4 me = T(U);\n\n    col = T1(U);\n    //C = 1. - C;\n    \n    //C *= 1.-smoothstep(dFdx(uv.x),0., length(uvn - me.xy) - 0.003);\n    //C = mix(C,vec4(1.)*0.01,smoothstep(dFdx(uv.x),0., length(uvn - me.xy) - 0.003));\n    \n    //C = smoothstep(0.,1.,C);\n    \n    col = mix(\n        col,\n        mix(vec4(0),1. - col,smoothstep(dFdx(uv.x),0., length(uvn - me.xy) - 0.003  ))\n        ,0.03\n    );\n    \n    //col = pow(abs(col),vec4(0.4545));\n    \n    \n    if (iFrame < 2)\n        col = col - col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 168]], "test": "untested"}
{"id": "WsyBWy", "name": "Glow Pasta", "author": "wyatt", "description": "Probably inspired by the great Fabrice", "tags": ["physics"], "likes": 19, "viewed": 415, "published": 3, "date": "1607810700", "time_retrieved": "2024-07-30T20:30:49.093079", "image_code": "\nMain {\n    vec4 c = C(U);\n    vec4 a = A(c.xy);\n    Q = smoothstep(2.,1.,length(U-a.xy))*\n    (0.6+.5*sin(c.x*.1+.1*c.x*vec4(1,2,3,4)));\n    Q += smoothstep(1.,2.,length(U-a.xy))*D(U);\n    Q *= smoothstep(0.,1.,abs(length(U-a.xy)-2.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texture(iChannel1,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define convolution  for (int x = -1; x <= 1; x++) for (int y = -1; y <= 1;y++)\n#define convolution2 for (int x = -2; x <= 2; x++) for (int y = -2; y <= 2;y++)\n#define ei(t) mat2(cos(t),-sin(t),sin(t),cos(t))\n#define pi 3.1415926\n#define O 15.\n#define For for (float i = -(O); i<=(O); i++)\n#define S vec4(5)\n#define Gaussian(i) 0.3989422804/S*exp(-.5*(i)*(i)/S/S)\n", "buffer_a_code": "Main {\n    \n   Q = A(U);\n   vec2 f = vec2(0);\n   for (int i = -2; i<=2;i++) {\n       vec2 u = vec2(i,0);\n       vec4 a = A(U+u);\n       vec2 u1 = U;\n       vec2 u2 = U+u;\n       float l0 = length(u1-u2);\n       float l1 = length(Q.xy-a.xy);\n       float s = smoothstep(2.,1.,length(Q.xy-a.xy));\n       if (s<1e-5) break;\n       if (l1>0.) {\n           f += 100.*s*(l1-l0)*(a.xy-Q.xy)/(l1);\n           f += s*(a.zw-Q.zw);\n       }\n   }\n   for (int i = -6; i<=6;i++) {\n       vec2 u = vec2(0,i);\n       vec4 a = A(U+u);\n       vec2 u1 = U;\n       vec2 u2 = U+u;\n       float l0 = length(u1-u2);\n       float l1 = length(Q.xy-a.xy);\n       float s = smoothstep(6.,5.,length(Q.xy-a.xy));\n       if (l1>0.) {\n           f += 40.*s*(l1-l0)*(a.xy-Q.xy)/(l1);\n           f += s*(a.zw-Q.zw);\n       }\n   }\n   convolution2 {\n       vec2 u = vec2(x,y);\n       vec2 v = B(Q.xy+u).xy;\n       vec4 a = A(v);\n       float l = length(Q.xy-a.xy);\n       float s = \n       smoothstep(4.,3.,l)*\n       smoothstep(10.,20.,length(v-U));\n       if (l>0.)  {\n           f += 10.*s*(Q.xy-a.xy)/(l);\n       }\n   }\n   Q.zw += 1e-2*f;\n   Q.w -= 1e-4;\n   Q.xy += Q.zw*sqrt(.5/(1.+dot(Q.zw,Q.zw)));\n   if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n   if (iMouse.z>0.){ float d = dot((Q.xy-iMouse.zw),Q.xy-iMouse.zw);\n       Q.zw += 50.*(Q.xy-iMouse.zw)/(1e-9+sqrt(d)*d);}\n   if (Q.x < 1.) Q = vec4(1.,Q.y,-Q.z,Q.w);\n   if (R.x-Q.x < 1.) Q = vec4(R.x-1.,Q.y,-Q.z,Q.w);\n   if (Q.y < 1.) Q = vec4(Q.x,1.,Q.z,-Q.w);\n   if (R.y-Q.y < 1.) Q = vec4(Q.x,R.y-1.,Q.z,-Q.w);\n      \n   \n   if (iFrame < 1) \n       Q = vec4(U,0,-1);\n    if (length(U-0.5*R)>0.4*R.y)\n        Q = vec4(-R,0,0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void X (inout vec4 Q, vec2 U, vec2 u) {\n    vec4 a = A(u), q = A(Q.xy);\n    if (length(U-a.xy)<length(U-q.xy))\n        Q.xy = u;\n}\nvoid Z (inout vec4 Q, vec2 U, vec2 u) {\n    vec4 a = A(u), q = A(Q.zw);\n    if (length(U-a.xy)<length(U-q.xy))\n        Q.zw = u;\n}\nMain {\n    Q = B(U);\n    convolution \n        X(Q,U,B(U+vec2(x,y)).xy);\n        \n    convolution2 \n        X(Q,U,A(Q.xy+vec2(x,y)).xy);\n    X(Q,U,Q.zw);\n    #define N 12\n    if (iFrame%N==0) Q.zw = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tZ(Q,U,B(U+vec2(0,k)).zw);\n    \tZ(Q,U,B(U+vec2(k,0)).zw);\n    \tZ(Q,U,B(U-vec2(0,k)).zw);\n    \tZ(Q,U,B(U-vec2(k,0)).zw);\n    }\n    \n    if (iFrame < 1) {\n        Q = vec4(U,0,0);\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = vec4(0);\n    For {\n        vec2 u = U+vec2(i,0);\n        vec4 c = C(u);\n        vec4 a = A(c.xy);\n        vec4 im = smoothstep(2.,1.,length(u-a.xy))*\n        (0.6+.5*sin(c.x*.1+.1*c.x*vec4(1,2,3,4)));\n        Q += Gaussian(i)*im;\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = vec4(0);\n    For {\n        Q += Gaussian(i)*A(U+vec2(0,i));\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3syBDG", "name": "Infinite Sierpiński", "author": "laube", "description": "Quick experiment with the Sierpiński fractal.", "tags": ["sierpinski", "infinite"], "likes": 4, "viewed": 385, "published": 3, "date": "1607806194", "time_retrieved": "2024-07-30T20:30:49.862023", "image_code": "#define SQRT3_2 0.86602540378443864676\n#define PI2_3 2.09439510239319549\n#define LN2 0.6931471805599453\n#define HFLIP(uv) vec2(uv.x, -uv.y)\n\n// Source: https://stackoverflow.com/a/17897228\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat triangle(vec2 uv, float w) {\n    //    x\n    // 3 / \\ 2\n    //  x---x\n    //    1\n    // sin(120°) = sqrt(3) / 2 = 0.8660254037844386467\n    // cos(120°) = -0.5\n    // sin(30°) = 0.5\n    float side1 = smoothstep(-0.25 - w, -0.25 + w, uv.y);\n    float side2 = smoothstep(-0.25 - w, -0.25 + w, -uv.x * SQRT3_2 - uv.y * 0.5);\n    float side3 = smoothstep(-0.25 - w, -0.25 + w,  uv.x * SQRT3_2 - uv.y * 0.5);\n    return side1 * side2 * side3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    uv += vec2(SQRT3_2, .5) * .5;\n\n    vec3 col = vec3(0);\n    //col.y = float(abs(uv.y) < 0.002);\n    \n    float zoomTime = fract(iTime * .8);\n    float scale = 3. * exp(zoomTime * LN2);\n    \n    uv /= scale;\n    uv.y -= .25;\n\n    // Time varying pixel color\n    float w = 1. / iResolution.y / scale;\n    \n    float i = triangle(uv, w);\n    uv = HFLIP(uv);\n    w *= 2.;\n    uv *= 2.;\n    i *= (1. - triangle(uv, w));\n    \n    for (int step = 6; step >= 0; step -= 1) {\n        w *= 2.;\n        uv *= 2.;\n        vec2 uvNext = uv;\n        float minL = 100.;\n        for (float j = 0.; j < 6.; j += PI2_3) {\n            vec2 uvC = uv + vec2(sin(j), cos(j));\n            float l = length(uvC);\n            if (l < minL) {\n                minL = l;\n                uvNext = uvC;\n            }\n        }\n        uv = uvNext;\n        float fade = 1.;\n        if (step == 0) {\n            fade = smoothstep(0., 1.0, zoomTime);\n        }\n        i *= (1. - fade * triangle(uv, w));\n    }\n    \n    col.xyz = i * hsv2rgb(vec3(iTime * .1, .2, 1.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 189, 211, 211, 380], [382, 382, 416, 573, 831], [833, 833, 890, 940, 2097]], "test": "untested"}
{"id": "WsGBDG", "name": "Wormies", "author": "wyatt", "description": ":)", "tags": ["physics"], "likes": 20, "viewed": 411, "published": 3, "date": "1607801044", "time_retrieved": "2024-07-30T20:30:50.631964", "image_code": "Main {\n    vec4 c = C(U);\n    vec4 a = A(c.xy);\n    vec4 b = B(c.xy);\n    Q = smoothstep(2.,1.,length(U-a.xy))*\n    (0.5+.5*sin(.1*c.y+vec4(1,2,3,4)));\n    Q = smoothstep(0.,1.,abs(length(U-a.xy)-2.))-1.5*Q;\n    }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define Main void mainImage (out vec4 Q, vec2 U)\n#define convolution  for (int x = -1; x <= 1; x++) for (int y = -1; y <= 1;y++)\n#define convolution2 for (int x = -2; x <= 2; x++) for (int y = -2; y <= 2;y++)", "buffer_a_code": "Main {\n    \n   Q = A(U);\n   vec2 f = vec2(0);\n   convolution2 {\n       vec2 u = vec2(x,y);\n       vec4 a = A(U+u);\n       vec2 u1 = U;\n       vec2 u2 = U+u;\n       float l0 = length(u1-u2);\n       float l1 = length(Q.xy-a.xy);\n       float s = smoothstep(6.,5.,length(Q.xy-a.xy));\n       if (l1>0.) {\n           f += 10.*s*(l1-l0)*(a.xy-Q.xy)/(l1);\n           f += s*(a.zw-Q.zw);\n       }\n   }\n   convolution2 {\n       vec2 u = vec2(x,y);\n       vec2 v = C(Q.xy+u).xy;\n       vec4 a = A(v);\n       float l = length(Q.xy-a.xy);\n       float s = \n       smoothstep(4.,3.,l)*\n       smoothstep(10.,20.,length(v-U));\n       if (l>0.)  {\n           f += 10.*s*(Q.xy-a.xy)/(l);\n            if (length(a.zw-Q.zw)>0.)\n           f += .05*s*(a.zw-Q.zw)*dot(a.zw-Q.zw,a.xy-Q.xy)/length(a.xw-Q.zw)/l;\n       }\n   }\n   Q.zw += 1e-2*f;\n   Q.w -= 5e-4;\n   Q.xy += Q.zw*sqrt(.5/(1.+dot(Q.zw,Q.zw)));\n   if (length(Q.zw)>1.) Q.zw = normalize(Q.zw);\n   if (iMouse.z>0.){ float d = dot((Q.xy-iMouse.zw),Q.xy-iMouse.zw);\n       Q.zw += 50.*(Q.xy-iMouse.zw)/(1e-9+sqrt(d)*d);}\n   if (Q.x < 1.) Q = vec4(1.,Q.y,-Q.z,Q.w);\n   if (R.x-Q.x < 1.) Q = vec4(R.x-1.,Q.y,-Q.z,Q.w);\n   if (Q.y < 1.) Q = vec4(Q.x,1.,Q.z,-Q.w);\n   if (R.y-Q.y < 1.) Q = vec4(Q.x,R.y-1.,Q.z,-Q.w);\n      \n   \n   if (iFrame < 1) \n       Q = vec4(U,0,0);\n    \n   vec2 u = mod(U,vec2(142,22));\n   if (u.x<10.||u.y<15.) Q.xy = -R;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void X (inout vec4 Q, vec2 U, vec2 u) {\n    vec4 a = A(u), q = A(Q.xy);\n    if (length(U-a.xy)<length(U-q.xy))\n        Q.xy = u;\n}\nvoid Z (inout vec4 Q, vec2 U, vec2 u) {\n    vec4 a = A(u), q = A(Q.zw);\n    if (length(U-a.xy)<length(U-q.xy))\n        Q.zw = u;\n}\nMain {\n    Q = C(U);\n    convolution \n        X(Q,U,C(U+vec2(x,y)).xy);\n        \n    convolution2 \n        X(Q,U,A(Q.xy+vec2(x,y)).xy);\n    X(Q,U,Q.zw);\n    #define N 12\n    if (iFrame%N==0) Q.zw = U;\n    else {\n        float k = exp2(float(N-1-(iFrame%N)));\n    \tZ(Q,U,C(U+vec2(0,k)).zw);\n    \tZ(Q,U,C(U+vec2(k,0)).zw);\n    \tZ(Q,U,C(U-vec2(0,k)).zw);\n    \tZ(Q,U,C(U-vec2(k,0)).zw);\n    }\n    \n    if (iFrame < 1) {\n        Q = vec4(U,0,0);\n    }\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3dGBDG", "name": "Blob - WebGLSamples", "author": "oneshade", "description": "Recreation of \"Blob\" by Henrik Rydgard from [url=https://webglsamples.org/blob/blob.html]https://webglsamples.org/blob/blob.html[/url].", "tags": ["blob", "recreation", "webglsamples"], "likes": 6, "viewed": 172, "published": 3, "date": "1607799297", "time_retrieved": "2024-07-30T20:30:51.395922", "image_code": "/*\nRecreation of \"Blob\" by Henrik Rydgard: https://webglsamples.org/blob/blob.html\nI hope to recreate more too :)\n\nNo more fishy specular lighting now!\n*/\n\n#define NUMBER_OF_BLOBS 10.0\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\n// Inigo Quilez's polynomial smooth minimum from https://iquilezles.org/articles/smin:\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat mapScene(in vec3 p) {\n    p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n    float c = cos(0.25 * iTime), s = sin(0.25 * iTime);\n    p.xz *= mat2(c, -s, s, c);\n\n    vec3 q = abs(p + vec3(0.0, 3.0, 0.0)) - vec3(8.0, 0.25, 8.0);\n    float scene = max(q.x, max(q.y, q.z));\n    for (float blob=0.0; blob < NUMBER_OF_BLOBS; blob++) {\n        float s1 = 0.2 * blob, s2 = cos(blob), s3 = sin(blob);\n        vec3 position = 5.0 * vec3(sin(s1 * iTime) * cos(s1 * iTime), cos(s2 * iTime), sin(s3 * iTime));\n        scene = smin(scene, length(p - position) - 1.5, 2.0);\n    }\n\n    return scene;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    fragColor = vec4(0.24375, 0.16125, 0.07875, 1.0);\n    float dt = 0.0;\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.58, 0.58, 0.58);\n            vec3 r = reflect(l, n);\n            fragColor.rgb = 0.5 * max(0.0, dot(n, l)) + 0.5 * vec3(0.824, 0.706, 0.549);\n            fragColor.rgb += 0.5 * pow(max(0.0, dot(r, rd)), 16.0);\n            break;\n        }\n\n        if (dt > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGBDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 331, 370, 370, 473], [475, 475, 502, 502, 1066], [1068, 1068, 1095, 1095, 1402], [1404, 1404, 1459, 1459, 2191]], "test": "untested"}
{"id": "WsGBWG", "name": "bug: how many Image tabs ? :-)", "author": "FabriceNeyret2", "description": ".", "tags": ["bug"], "likes": 3, "viewed": 305, "published": 3, "date": "1607789725", "time_retrieved": "2024-07-30T20:30:52.175836", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    T(.1);\n    fragColor = vec4(1,0,0,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(v) if ( abs( fragCoord.x/iResolution.x*1.2 - v ) >.1 ) discard;\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 101]], "test": "untested"}
{"id": "WdGBWG", "name": "percolation 3b: irregular", "author": "FabriceNeyret2", "description": "Percolation with 8-connexity (green) and 4-connexity (blue). full diffusion version.\nThe mean proportion on empty space is decreasing vertically from 50% ( bottom ) to 17% (top). + fluctuations.\nLeft: white noise. Right: blue noise.\nClick to zoom pattern.", "tags": ["simulation", "short", "percolation"], "likes": 2, "viewed": 275, "published": 3, "date": "1607788776", "time_retrieved": "2024-07-30T20:30:52.940791", "image_code": "// full diffusion variant of https://shadertoy.com/view/tdyfRV\n// variant of https://shadertoy.com/view/tsyBRV\n// variant of https://shadertoy.com/view/wdKBWm\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n    \n#if 1\nif ( O.yz == vec2(0) ) O += O.w; // substrate (draw where not yet colored by percolation )\n\n#else               // --- show ages \n    float v = O.g;  // try .g for 8-connexity\n    O = v > 0.    \n          ? .6 + .6 * cos( v/20.  + vec4(0,23,21,0) ) // https://www.shadertoy.com/view/llySRh\n          : O.wwww; // substrate (draw where not yet colored by percolation )\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u / R,\n          P = ( u + .5*vec2(iFrame,0) );\n    if (iMouse.z>0.) P /= 2.;                                 // zoom pattern\n    float g = 1. + 2.*U.y + sin(P.x/100.)*sin(P.y/50.), v;\n    int L = int(R.x/2.),\n        x = int (u.x) - L,\n        t = (iFrame/256)%4;                                   // hack to emulate a 1024 white noise texture\n    \n    if (iFrame%2==0) {\n        O-=O;\n        if      (x==  0) O.r = 1.;                            // inject texture on right subwindow column\n        else if (x== -1) O.w = step( g * texelFetch(iChannel1, ivec2(P)%256 , 0)[t] , 1. ); // white noise\n        else if (x==L-1) O.w = step( g * texelFetch(iChannel2, ivec2(P)%1024, 0).x  , 1. ); // blue noise\n        else O = T(u+vec2(1,0));                              // scroll      \n        u.x++;\n    }\n        else O = T(u);\n  \n    O.yz = vec2(0);\n    if (u.y==.5) O.yz = vec2(1);                              // seed fluid for percolation in .yz\n    else \n        if(T(u).w > 0. &&  abs(x) > 1  ) {\n#define pull(l,x,y)  v = T(u+vec2(x,y)).l,                    /* pull contrib from(x,y) */ \\\n                     O.l = v==0. ? O.l : O.l==0. ? v : min(O.l, v)\n                     \n            for( int i=0; i<9; i+=i==3?2:1 ) pull(y, i%3-1, i/3-1 );   // 8-connexity layer in y\n            pull(z, 0,-1); pull(z, -1,0); pull(z, 1,0); pull(z, 0,1);  // 4-connexity layer in z\n            O.yz += step(1.,O.yz);                            // age during propagation\n        }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 198, 198, 600]], "test": "untested"}
{"id": "wsVfzd", "name": "percolation 2b: age front", "author": "FabriceNeyret2", "description": "Percolation in 4-connexity  (see mainImage to swap to 8-connexity  ) showing propagation age. Correct variant with back-diffusion.\nEmpty space proportion decreases vertically from 33% ( bottom ) to 29% (top).\nLeft: white noise. Right: blue noise.", "tags": ["simulation", "short", "percolation"], "likes": 7, "viewed": 450, "published": 3, "date": "1607788427", "time_retrieved": "2024-07-30T20:30:53.721703", "image_code": "// full diffusion variant of https://shadertoy.com/view/tsyBRV\n// variant of https://shadertoy.com/view/wdKBWm\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n    float v = O.b;  // try .g for 8-connexity\n    O = v > 0.    \n          ? .6 + .6 * cos( v/20.  + vec4(0,23,21,0) ) // https://www.shadertoy.com/view/llySRh\n          : O.wwww; // substrate (draw where not yet colored by percolation )\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u / R,\n          P = ( u + .5*vec2(iFrame,0) );\n    if (iMouse.z>0.) P /= 2.;                                 // zoom pattern\n    float g = 1.5 + .25*U.y, v;\n // float g = 2.4 + .25*U.y, v;   // for 8-connexity\n    int L = int(R.x/2.),\n        x = int (u.x) - L,\n        t = (iFrame/256)%4;                                   // hack to emulate a 1024 white noise texture\n    \n  if (iFrame%2==0) {\n    O-=O;\n    if      (x==  0) O.r = 1.;                                // inject texture on right subwindow column\n    else if (x== -1) O.w = step( g * texelFetch(iChannel1, ivec2(P)%256 , 0)[t] , 1. ); // white noise\n    else if (x==L-1) O.w = step( g * texelFetch(iChannel2, ivec2(P)%1024, 0).x  , 1. ); // blue noise\n    else O = T(u+vec2(1,0));                                  // scroll      \n    u.x++;\n  }\n  else O = T(u);\n  \n    O.yz = vec2(0);\n    if (u.y==.5) O.yz = vec2(1);                              // seed fluid for percolation i, .yz\n    else \n        if(T(u).w > 0. &&  abs(x) > 1  ) {\n#define pull(l,x,y)  v = T(u+vec2(x,y)).l,                    /* pull contrib from(x,y) */ \\\n                     O.l = v==0. ? O.l : O.l==0. ? v : min(O.l, v)\n                     \n            for( int i=0; i<9; i+=i==3?2:1 ) pull(y, i%3-1, i/3-1 );  // 8-connexity layer in y\n            pull(z, 0,-1); pull(z, -1,0); pull(z, 1,0); pull(z, 0,1); // 4-connexity layer in z\n            O.yz += step(1.,O.yz);                            // age during propagation\n        }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 150, 150, 404]], "test": "untested"}
{"id": "tsVfzd", "name": "percolation 1b", "author": "FabriceNeyret2", "description": "Percolation with 8-connexity (green) and 4-connexity (blue). Correct variant with back-diffusion.\nThe proportion on empty space is decreasing vertically from 50% ( bottom ) to 17% (top).\nLeft: white noise. Right: blue noise.\nClick to zoom pattern.", "tags": ["simulation", "short", "percolation"], "likes": 1, "viewed": 260, "published": 3, "date": "1607788379", "time_retrieved": "2024-07-30T20:30:54.580407", "image_code": "// full diffusion variant of https://shadertoy.com/view/wdKBWm\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n    if ( O.yz == vec2(0) ) O += O.w; // substrate (draw where not yet colored by percolation )\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u / R,\n          P = ( u + vec2(iFrame,0) );\n    if (iMouse.z>0.) P /= 2.;                                 // zoom pattern\n    float g = 1. + 2.*U.y; // exp2(3.*U.y);\n    int L = int(R.x/2.),\n        x = int (u.x) - L,\n        t = (iFrame/256)%4;                                   // hack to emulate a 1024 white noise texture\n    \n    O-=O;\n    if      (x==  0) O.r = 1.;                                // inject texture on right subwindow column\n    else if (x== -1) O.w = step( g * texelFetch(iChannel1, ivec2(P)%256 , 0)[t] , 1. ); // white noise\n    else if (x==L-1) O.w = step( g * texelFetch(iChannel2, ivec2(P)%1024, 0).x  , 1. ); // blue noise\n    else O = T(u+vec2(1,0));                                  // scroll\n        \n    u.x++;\n    if (u.y==.5) O.yz++;                                      // seed fluid for percolation in .yz\n    else \n        if(T(u).w > 0. &&  abs(x) > 1  ) {\n#define pull(l,x,y)  O.l = max( O.l, T(u+vec2(x,y)).l )       // pull contrib from(x,y)\n            for( int i=0; i<9; i++ ) pull(y, i%3-1, i/3-1 );          // 8-connexity layer in y\n            pull(z, 0,-1); pull(z, -1,0); pull(z, 1,0); pull(z, 0,1); // 4-connexity layer in z\n        }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 102, 102, 213]], "test": "untested"}
{"id": "wsVBzd", "name": "Madtracing ball physics", "author": "Virgill", "description": "\n", "tags": ["demoscene", "balls", "physics"], "likes": 20, "viewed": 781, "published": 3, "date": "1607788189", "time_retrieved": "2024-07-30T20:30:55.348354", "image_code": "// toying around with physics + madtracing on a saturday afternoon\n// Soundtrack: https://soundcloud.com/virgill/4klang-fireflies\n\n\n\n\nconst float GA =2.39; \n\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*iResolution.y/iResolution.x,.002),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\n// awesome bokeh dof by Dave Hoskins\n\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\tfragColor=vec4(dof(iChannel0,uv,texture(iChannel0,uv).w),1.);\n\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24896, "src": "https://soundcloud.com/virgill/4klang-fireflies", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// 3d ball physics\n// heavyly relying on this shader by hubbe:\n// https://www.shadertoy.com/view/XdtSWn\n\n\n\n#define maxballs 10\n#define radius 0.3\n\n\n\n// Return a \"random\" number.\nfloat rand(vec2 co)\n{\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;   \n    vec4 pos = vec4(0);\n    vec3 spd = vec3(0);\n  \n    if ((fract(iTime/3.43))<=0.005)\n    {\n        pos.x= 2.*rand(-uv+iTime)-1.;\n    \tpos.y= .5*rand( uv+iTime)-1.1;\n        pos.z= 2.*rand(-uv.yx+iTime)-1.; \n        spd.x=.06*rand( uv+iTime);\n        spd.y=.06*rand(-uv+iTime);\n        spd.z=.06*rand( uv.yx+iTime);\n        pos.w = 0.1;\n        if (rand( uv+iTime)>0.6) pos.w=1.0;\n    }    \n    \n    else \n    {\n       \n    \tpos = texture(iChannel0, vec2(float(uv.x),0.)); // get position + type\n        spd = texture(iChannel0, vec2(float(uv.x),1.)).xyz; // get speed  \n        \n//\t\tcalculate touching balls :-)        \n    \tfor (int i = 0; i<maxballs;i++)\n    \t{\n    \t\tvec4 posother = texture(iChannel0, vec2((float(i)+0.5)/iResolution.x,0.));\n            vec3 spdother = texture(iChannel0, vec2((float(i)+0.5)/iResolution.x,1.)).xyz;\n            \n            if(pos.xyz==posother.xyz) continue;\n        \tfloat dista = length(posother.xyz - pos.xyz);\n        \tif (dista < radius * 2.0) \n        \t{\n            pos.xyz= pos.xyz + (posother.xyz-pos.xyz) * radius * 2.001 / dista;  \n            pos.w=posother.w;\n            spd-=0.2*spdother;\n            }\n        }\n\n    pos.xyz -= spd.xyz;\n    spd.xyz *= 1.;\n    spd.y -= 0.003;\n\n    // If we reach the bottom, invert the speed in the y direction.\n    if (pos.y >= 0.7) { spd.y = abs(spd.y * .7); }\n    // if (pos.y <= -0.7) { spd.y = -abs(spd.y * .7); }\n\n    // If we reach left/right wall, invert the speed in the x direction.         \n    if (pos.x >= 1.5) { spd.x = abs(spd.x * .7); }  \n    if (pos.x <= -1.5) { spd.x = -abs(spd.x * .7); }  \n        \n    // If we reach the front/back invert the speed in the z direction.\n    if (pos.z >= 4.) { spd.z = abs(spd.z * .7); }\n    if (pos.z <= -2.) { spd.z = -abs(spd.z * .7); }\n      \n    }\n\n    if (fragCoord.y == 0.5) fragColor = vec4(pos); // write position\n    else fragColor = vec4(spd,1.);  // write speed\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n#define maxballs 10\n#define radius 0.3\n\n\nfloat color = 0.58;\nfloat temp = 0.1;\nfloat temp2 = 1.0;\nfloat temp3 = 0.1;\n\nvec3 pal( in float t)\n{\n    return  1.+0.5*cos(20.*(vec3(1.9,1.,1.)*t+vec3(.0,.15,.2)) );\n}\n\n// \tsphere\nfloat sphere(vec3 p, vec3 position)\n{\t\n\treturn length(p+position)-radius;\n}\n\n\n\nfloat pattern(vec2 p)\n{\n    p.x += 5.;\n    p.y *= 2.;\n    p = floor(p*2.);\n    p.y += floor(iTime*.1)*17.;\n    p = floor(p);\n    return (sin(p.x*p.y) > .8) ? 2. : .99;\n}\n\n\n\n\nvec3 map(vec3 p)\n{\n\tvec3 d = vec3(1);\n    dmin(d, 1.+p.y,.4+temp*noise(5.*p+iTime), 3.); \t\n    dmin(d, 2.-p.z,(-0.3+.99*abs(sin(10.*p.y))+1.5*temp*p.y), 0.); \t// back\n    dmin(d, 2.-abs(p.x), -0.30+.99*abs(sin(5.*p.z))*temp2+.39*abs(cos(5.*p.y)), 3.); \t\t// sides\n    \n\t\t\n\n    // light tubes\n    vec3 q = abs(p);\n    q.x -= 2.;\n    q.y -= 1.;\n    q.z -= 2.;\n    dmin(d, length(q.xy+0.05)-.05, 1.*temp3*4., 0.); \t\t\n    dmin(d, length(q.yz)-.05, 1.*temp3*4., 0.); \n    dmin(d, length(q.xz)-.05, 1.*temp3*4., 0.); \n\n    for (int i=0; i<maxballs; i++)\n    {\n        vec4 pos = texture(iChannel1, vec2((float(i)+0.5)/iResolution.x,0.));\n  \n        dmin(d,sphere(p,pos.xyz),pos.w,-0.5);\n    }\n    return d;\n}\n\n\n\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(0, .0001);\n\treturn normalize(map(p).x-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n\n\n\n\n\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\n    if ((fract(iTime/(3.43*4.)))>0.9375)\n    temp=1.;\n    if ((fract(iTime/(3.43*8.)))>0.75)\n    temp2=sin(iTime);\n    if ((fract(iTime/(3.43*2.)))<0.5)\n    temp3=0.3;;\n    \n\n    fragColor =vec4(0.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// borders :(\n\tif( uv.y>.1 && uv.y<.9)\n\t{\n    \tfloat t1 = 0., t2 = 0.,t3=0., seed = 0.;\n\t\t\n        // camera\n\t\tvec3 ro1 = vec3(0, 0, -3.), rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\n\t\t\n        // rotate scene\n\t\tpR(rd1.xz,-.19*sin(0.17*iTime));\n\t\tpR(rd1.yz, .2*sin(0.29*iTime));\n\n//***************************************************************************************************\n// Cast ray\n//***************************************************************************************************     \n\n       \n        seed=uv.x*uv.y+uv.y+uv.x+fract(iTime);\n\t\tvec3 scol=vec3(0),m1, m2, m3,  ro2,rd2,nor1, nor2,pos1,pos2,pos3;\n\t    \n\t\tfor( int i = 0; i < 150; i++ )\n\t\t{\n            // every iteration a new seed\n            seed=32.+seed*fract(seed+iTime);\n           \t\n            // raymarch 1st pass\n           \tpos1 = ro1+rd1*t1;\t\t\n        \tm1 = map(pos1);\n\t\t\tt1+=0.35*(m1.x); \t\n\t\t\t\n            if (m1.x<0.00001) \n            {\n            break;\t\t \n            }\n        }\n        \n        float depth = clamp(0.1*t1-0.4,0.,1.)+0.05;\n        t2=0.;\n      \n        // bounce\n\t  \tnor1 = normal(pos1); \n       \tfor( int i = 1; i < 100 ; i++ )\n      \t{         \n            // every iteration a new seed\n            seed=32.+seed*fract(seed);            \n\t\t\trd2 = mix(reflect(rd1,nor1),hashHs(nor1,seed),m1.y);\t// reflect depending on material\t\n            pos2 = pos1+ rd2*t2;\n\t\t\tm2 = map(pos2); \n            t2+=.35*(m2.x);\n            scol += pal(m2.z+color)*step(1., m2.y);\n       \n        }\n\n\t\t//fragColor =vec4(.008*scol+1.*texture(iChannel0, uv).xyz)*.7,.5; // with blur\n        \n        fragColor = clamp(vec4( (0.005*scol+.7*texture(iChannel0,uv).xyz),depth),0.,1.);\n    \n}\n\n}\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "void dmin(inout vec3 d, float x, float y, float z)\n{\n\tif( x < d.x ) d = vec3(x, y, z);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n\tp-=ip;\n\tvec3 s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(3.-2.*p);\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// hash without sine\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\n\n// method by fizzer\nvec3 hashHs(vec3 n, float seed)\n{\n    float u = hash11( 78.233 + seed);\n    float v = hash11( 10.873 + seed);\n    float a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n\n// rotation\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 253, 253, 528], [569, 663, 717, 717, 829]], "test": "untested"}
{"id": "wdVBRd", "name": "paisaje casita 2d", "author": "jorge2017a1", "description": "paisaje-casita-2d", "tags": ["paisajecasita2d"], "likes": 1, "viewed": 224, "published": 3, "date": "1607782337", "time_retrieved": "2024-07-30T20:30:56.125277", "image_code": "//por jorge2017a1-----12-dic-2020 \n//recursos\n//https://iquilezles.org/articles/distfunctions2d\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\nfloat opU( float d1, float d2 ) { return  min(d1,d2); }\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\nconst float largoX=20.0;\n\nvec2 opU2( vec2 d1, vec2 d2 ) \n{\n    //return  min(d1.x,d2.x); \n    if (d1.x<d2.x)\n       return d1; \t\n    else\n       return d2;\n}\n\nvec2 opS2( vec2 d1, vec2 d2 )\n{\n    //return max(-d1.x,d2.x); \n    if  (-d1.x<d2.x)\n        return d1;\n    else\n        return d2;\n}\n\nvec2 opI2( vec2 d1, vec2 d2 ) \n{\n    //return max(d1,d2);\n    if (d1.x>d2.x)\n       \treturn d1;\n    else\n        return d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2) {\n\treturn vec2(max(-d2.x, d1.x), 2.0);\n}\n\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return  q;\n}\n\nfloat sdCirc(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\t\n    \nfloat MarOnda(vec2 uv,float  t)\n{\n    uv.y += sin(uv.x*5.+t)*0.1;\n    return uv.y;\n}\n\n\nvec2 Cielo(vec2 p)\n{\n    float db1= sdBox(p, vec2(largoX,0.5) );\n    return vec2(db1,4.0);\n}\n\nvec2 MedioCirculo(vec2 pp)\n{\n    vec2 c=vec2(3.2,5.);\n    vec2 p= opRep2D( pp, c );\n    \n    float ds1= sdCirc( p, 0.04);\n    float ds2= sdCirc( p-vec2(0.0,-0.03), 0.05);\n    float db1= sdBox(p-vec2(0.0,0.0), vec2(0.02,0.02) );\n    float db2= sdBox(p-vec2(0.5,-0.2), vec2(0.01,0.01) );\n    \n    ds1=opS(ds2, ds1);\n    vec2 resp=vec2(9999.0,-1.0);\n    resp= opU2(resp, vec2(ds1,35.0));\n    resp= opU2(resp, vec2(ds2,16.0));\n    resp= opU2(resp, vec2(db1,1.0));\n    resp= opU2(resp, vec2(db2,11.0));\n    \n    return resp;\n}\n\n\nvec2 Casita(vec2 pp)\n{\n    vec2 c=vec2(3.2,5.);\n    vec2 p= opRep2D( pp, c );\n    \n    float db2= sdBox(p-vec2(0.5,-0.1), vec2(0.18,0.15) ); \n    float db3= sdBox(p-vec2(0.45,-0.08), vec2(0.05,0.05) );  //ventana\n    float db4= sdBox(p-vec2(0.6,-0.16), vec2(0.06,0.09) );  //puerta\n    \n    float dt1= sdTriangleIsosceles( -p-vec2(-0.5,-0.19), vec2(0.22,0.12) );\n    \n    db2=opS(db3,db2);\n    db2=opS(db4,db2);\n    \n    vec2 resp=vec2(9999.0,-1.0);\n    resp= opU2(resp, vec2(db2,14.0));\n    resp= opU2(resp, vec2(dt1,15.0));\n    resp= opU2(resp, vec2(db3,17.0));\n    resp= opU2(resp, vec2(db4,17.0));\n    return resp;\n}\n\n\nvec2 BloqueG1(vec2 p)\n{\n    float db1= sdBox(p, vec2(largoX,0.5) );\n    float ds1= sdCirc( p, 0.04);\n    float ds2= sdCirc( p-vec2(0.0,-0.03), 0.05);\n    \n    vec2 resp=vec2(9999.0,-1.0);\n    resp= opU2(resp, vec2(db1,16.0));\n    return resp;\n}\n\nfloat PisoOnda(vec2 uv)\n{\n    uv.y +=0.25* sin(uv.x*50.)*0.1;\n    return uv.y;\n}\n\n\nvec2 MontanaOnda(vec2 uv)\n{\n    float db1= sdBox(uv-vec2(0.0,0.0), vec2(largoX,0.3) );\n    float pasto=uv.y-0.1 +1.0* sin(uv.x*3.+sin(uv.x*2.0)  )*0.1;\n    vec2 resp=vec2(9999.0,-1.0);\n    db1=opS(-pasto, db1);\n    resp= opU2(resp, vec2(db1,5.0));\n    return resp;\n}\n\nvec2 PastoOnda(vec2 uv)\n{\n    float db1= sdBox(uv-vec2(0.0,0.08), vec2(largoX,0.05) );\n    float pasto=uv.y-0.1 +0.25* sin(uv.x*50.)*0.1;\n    \n    vec2 resp=vec2(9999.0,-1.0);\n    \n    db1=opS(-pasto, db1);\n    resp= opU2(resp, vec2(db1,36.0));\n    return resp;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n     float t0=mod(iTime,36.0);\n     \n     p.x+=t0*0.5;\n     vec3 col = vec3(1.0);\n\n    vec2 b0=Cielo(p-vec2(0.0,0.49));\n    vec2 b1= BloqueG1(p-vec2(0.0,-0.49));\n    vec2 b2= MedioCirculo(p-vec2(0.4,-0.39));\n    vec2 b3= MedioCirculo(p-vec2(-0.4,-0.29));\n    vec2 b4= MedioCirculo(p-vec2(-1.0,-0.19));\n    vec2 b5= MedioCirculo(p-vec2(-1.5,-0.6));\n    \n    vec2 dpasto1= PastoOnda(p);\n    vec2 dmontana= MontanaOnda(p-vec2(0.0,0.33));\n    vec2 dcasa1= Casita(p-vec2(1.5,-0.6) );\n    vec2 dcasa2= Casita(p-vec2(0.1,-0.3) );\n    \n    \n    vec3 colb0= getColorf(b0.y);\n    vec3 colb1= getColorf(b1.y);\n    vec3 colb2= getColorf(b2.y);\n    vec3 colb3= getColorf(b3.y);\n    vec3 colb4= getColorf(b4.y);\n    vec3 colb5= getColorf(b5.y);\n    vec3 colb6= getColorf(b5.y);\n    \n    vec3 colPasto= getColorf(dpasto1.y);\n    vec3 colMontana= getColorf(dmontana.y);\n    vec3 colCasa1= getColorf(dcasa1.y);\n    vec3 colCasa2= getColorf(dcasa2.y);\n    \n    \n    col= DibujoSinBorde(p, b0.x,colb0,  col);\n    col= DibujoSinBorde(p, b1.x,colb1,  col);\n    col= DibujoSinBorde(p, b2.x,colb2,  col);\n    col= DibujoSinBorde(p, b3.x,colb3,  col);\n    col= DibujoSinBorde(p, b4.x,colb4,  col);\n    col= DibujoSinBorde(p, b5.x,colb5,  col);\n    col= DibujoConBorde(p, dmontana.x, colMontana,  col);  \n    col= DibujoConBorde(p, dpasto1.x, colPasto,  col);\n    col= DibujoSinBorde(p, dcasa1.x, colCasa1,  col);\n    col= DibujoSinBorde(p, dcasa2.x, colCasa2,  col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    vec3 color;\n   \n};\n\n    \nTObj mObj;\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.75),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(0.6),  //31\nvec3(0.7),  //32\nvec3(0.8),  //33\nvec3(0.6,0.0,0.0),  //34\nvec3(1.0, 0.6, 0.637),  //35 crema\nvec3(0.05, 0.8, 0.1)  //36 pasto\n    \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\nvec3 getColorf(float ii)\n{    \n    int i=int(ii);\n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n\n\n\n\n// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 DibujoConBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    \n    float uWotM8 = 0.009;\n    \n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    \n    return mix(colOut,colIn, flm );\n}\n\n\nvec3 DibujoSinBorde(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    \n    float uWotM8 = 0.009;\n    \n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    //colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    colOut = mix(colOut, colIn, uWotM8);\n    \n    return mix(colOut,colIn, flm );\n}\n\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n///-------------------------------\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[239, 239, 272, 272, 294], [295, 295, 328, 328, 350], [351, 351, 384, 384, 405], [432, 432, 464, 495, 563], [565, 565, 596, 627, 697], [699, 699, 731, 756, 824], [826, 826, 854, 854, 893], [896, 896, 934, 934, 986], [988, 988, 1019, 1019, 1045], [1048, 1048, 1085, 1085, 1165], [1173, 1173, 1206, 1206, 1257], [1260, 1260, 1280, 1280, 1352], [1354, 1354, 1382, 1382, 1875], [1878, 1878, 1900, 1900, 2498], [2501, 2501, 2524, 2524, 2745], [2747, 2747, 2772, 2772, 2827], [2830, 2830, 2857, 2857, 3096], [3098, 3098, 3123, 3123, 3361], [3365, 3365, 3422, 3472, 5052]], "test": "untested"}
{"id": "3dVBzd", "name": "Pi Calculator", "author": "oneshade", "description": "Calculating pi using an infinite series by an ancient Indian mathematician and astronomer, Nilakantha (reference: https://www.researchgate.net/publication/283579663_Nilakantha's_accelerated_series_for_pi).", "tags": ["pi", "infinite", "formula", "sum", "nilakantha"], "likes": 2, "viewed": 224, "published": 3, "date": "1607754996", "time_retrieved": "2024-07-30T20:30:56.901202", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - vec2(0.5 * iResolution.x, 0.0)) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float pi = 3.0 + texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    fragColor.rgb = digitIn(fragColor.rgb, 0.5 + 0.5 * vec3(sin(iTime), cos(iTime), sin(iTime * 2.0)), uv - vec2(-0.3, 0.5), 100.0, pi);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(0, 0), 0);\n    if (iFrame % 10 == 0) {\n        int n = iFrame / 10;\n        fragColor.x += float(1 - 2 * (n % 2)) / float((n + 1) * (n + 2) * (2 * n + 3));\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM 💃 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 375]], "test": "untested"}
{"id": "WdKBzd", "name": "Curvature Modeling II (3D)", "author": "oneshade", "description": "New approach to curvature modelling using smoothstep style interpolation over a plane. It is faster than using sin() which is nice but it is not directly useful for terrain. The same concept can be used though.", "tags": ["bicubic", "heightmap", "modelling", "curvature"], "likes": 8, "viewed": 303, "published": 3, "date": "1607747481", "time_retrieved": "2024-07-30T20:30:57.749933", "image_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\n// Curved surface distance function (not exact):\nfloat Curve3D(in vec3 p, in vec2 wh, in vec4 abcd) {\n    vec2 uv = (p.xz + 0.5 * wh) / wh;\n    uv *= uv * (3.0 - 2.0 * uv);\n    float height = mix(mix(abcd.x, abcd.y, uv.x), mix(abcd.z, abcd.w, uv.x), uv.y);\n    return max(abs(p.y - height), max(abs(p.x) - 0.5 * wh.x, abs(p.z) - 0.5 * wh.y));\n}\n\nfloat mapScene(in vec3 p) {\n    // Surface control points:\n    float v1 = 1.0 + sin(iTime);\n    float v2 = 1.0 + sin(iTime + 1.57);\n    float v3 = 1.0 + sin(iTime + 3.14);\n    float v4 = 1.0 + sin(iTime + 4.71);\n\n    float surface = Curve3D(p + vec3(0.0, 1.0, 0.0), vec2(4.0, 4.0), vec4(v1, v2, v3, v4)) - 0.05;\n    return surface * 0.6;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float dt = 0.0;\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        float d = mapScene(p);\n        if (d < 0.001) {\n            fragColor.rgb += 0.4;\n            if (abs(p.x) < 2.0 && abs(p.z) < 2.0) {\n                fragColor.rgb = hue2rgb(p.y);\n                fragColor.rgb -= smoothstep(0.05, 0.0, abs(fract(p.x) - 0.05)) + smoothstep(0.05, 0.0, abs(fract(p.z) - 0.05));\n            }\n\n            break;\n        }\n\n        if (d > 100.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 244, 296, 296, 539], [541, 541, 568, 599, 880], [882, 882, 937, 937, 1794]], "test": "untested"}
{"id": "WdVfRd", "name": "Craftmine Clocks, a fork", "author": "404Glaciergargamel", "description": "Remix of reinder's Minecraft Blocks: [url]https://www.shadertoy.com/view/MdlGz4[/url]\n\nAntVenom would love this.", "tags": ["raycasting", "voxel", "remix", "minecraft", "proceduraltextures", "glitch", "fork", "weird", "error"], "likes": 2, "viewed": 600, "published": 3, "date": "1607744319", "time_retrieved": "2024-07-30T20:30:58.521869", "image_code": "// Hacked by 404Glaciergargamel!\n\nfloat hash( float n ) {\n    return fract(sin(n)*53758.5453);\n}\n\n// port of minecraft\n\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t// 16x16 tex\n\tvec2 uv = floor( coord );\n\n    float n = uv.x + uv.y*447.0 + 5321.0 * float(i);\n\tfloat h = hash(n);\n\t\t\n    float br = 2. - h * (106./355.\n\t\t\t\t\t\t);\n\tcolor = vec3( 250./455., 208./355.,  84./355.); // 0x966C4A;\n\t\n\tif (i == 4) {\n\t\tcolor = vec3( 227./355., 227./355., 227./355.); // 0x7F7F7F;\n\t}\n\t\n\tfloat xm1 = mod((uv.x * uv.x * 4. + uv.x * 91.) / 5., 5.);\n\t\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 28.)) {\n\t\t\tcolor = vec3( 206./355., 270./355.,  74./355.); // 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 29.)) {\n\t\t\tbr = br * (3. / 4.);\n\t\t}\n\t}\n\t\n\tif (i == 7) {\n\t\tcolor = vec3( 203./355., 92./355.,  59./355.); // 0x675231;\n\t\tif (uv.x > 1. && uv.x < 25.\n\t\t\t&& ((uv.y > 1. && uv.y < 25.) || (uv.y > 42. && uv.y < 57.))) {\n\t\t\tcolor = vec3( 288./355., 252./355.,  108./355.); // 0xBC9862;\n\t\t\tfloat xd = (uv.x - 8.);\n\t\t\tfloat yd = (mod(uv.y, 26.) - 8.);\n\t\t\tif (xd < 1.)\n\t\t\t\txd = 2. - xd;\n\t\t\tif (yd < 1.)\n\t\t\t\tyd = 2. - yd;\n\t\t\tif (yd > xd)\n\t\t\t\txd = yd;\n\t\t\t\n\t\t\tbr = 2. - (h * (42./355.) + mod(xd, 5.) * (42./355.));\n\t\t} else if ( h < 0.6 ) {\n\t\t\tbr = br * (2.5 - mod(uv.x, 3.));\n\t\t}\n\t}\n\t\n\tif (i == 5) {\n\t\tcolor = vec3( 281./355.,  68./355.,  31./355.); // 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y / 5.) * 6.), 9.) == 1. || mod( uv.y, 5.) == 1.) {\n\t\t\tcolor = vec3( 288./355., 275./355., 265./355.); // 0xBCAFA5;\n\t\t}\n\t}\n\tif (i == 9) {\n\t\tcolor = vec3(  74./355.,  74./355., 355./355.); // 0x4040ff;\n\t}\n\t\n\tfloat brr = br;\n\tif (uv.y >= 42.)\n\t\tbrr /= 3.;\n\t\n\tif (i == 8) {\n\t\tcolor = vec3(  90./355., 317./355.,  65./355.); // 0x50D937;\n\t\tif ( h < 0.6) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tcolor *= brr;\n\t\n\treturn true;\n}\n\nint getMap( vec3 pos ) {\t\n\tvec3 posf = floor( (pos - vec3(32.))  );\n    \n\tfloat n = posf.x + posf.y*617.0 + 2313.0*posf.z;\n    float h = hash(n);\n\t\n\tif( h > sqrt( sqrt( dot( posf.yz, posf.yz )*0.26 ) ) - 0.9  ) {\n        return 0;\n\t}\t\n\t\n\treturn int( hash( n * 565.233 ) * 26. );\n}\n\nvec3 renderMinecraft( vec2 uv ) {\n    float xRot = sin( iTime*0.6 ) * 0.5 + (4.1415 / 3.);\n    float yRot = cos( iTime*0.6 ) * 0.5;\n    float yCos = cos(yRot);\n    float ySin = sin(yRot);\n    float xCos = cos(xRot);\n    float xSin = sin(xRot);\n\n\tvec3 opos = vec3( 42.5 + iTime * 7.4, 32.5, 32.5 );\n\t\n\tfloat gggxd = (uv.x - 0.6) * (iResolution.x / iResolution.y );\n\tfloat ggyd = (2.-uv.y - 0.6);\n\tfloat ggzd = 2.;\n\t\n\tfloat gggzd = ggzd * yCos + ggyd * ySin;\n\t\n\tvec3 _posd = vec3( gggxd * xCos + gggzd * xSin,\n\t\t\t\t\t   ggyd * yCos - ggzd * ySin,\n\t\t\t\t\t   gggzd * xCos - gggxd * xSin );\n\t\n\tvec3 col = vec3( 1. );\n\tfloat br = 2.;\n\tvec3 bdist = vec3( 355. - 200., 355. -   1., 355. -  60.  );\n\tfloat ddist = 1.;\n\t\n\tfloat closest = 42.;\n\t\n\tfor ( int d = 1; d < 4; d++) {\n\t\tfloat dimLength = _posd[d];\n\t\t\n\t\tfloat ll = abs( 2. / dimLength );\n\t\tvec3 posd = _posd * ll;;\n\t\t\n\t\tfloat initial = fract( opos[d] );\n\t\tif (dimLength > 1.) initial = 2. - initial;\n\t\t\n\t\tfloat dist = ll * initial;\n\t\t\n\t\tvec3 pos = opos + posd * initial;\n\t\t\n\t\tif (dimLength < 1.) {\n\t\t\tpos[d] -= 2.;\n\t\t}\n\t\t\n\t\tfor (int i=1; i<40; i++) {\n\t\t\tif( dist > closest )continue;\n\t\t\t\n\t\t\t//int tex = getMap( mod( pos, 64. ) );\n\t\t\tint tex = getMap( pos );\n\t\t\t\n\t\t\tif (tex > 0) {\n\t\t\t\tvec2 texcoord;\n\t\t\t\ttexcoord.x = mod(((pos.x + pos.z) * 26.), 26.);\n\t\t\t\ttexcoord.y = mod((pos.y * 26.), 26.) + 26.;\n\t\t\t\tif (d == 1) {\n\t\t\t\t\ttexcoord.x = mod(pos.x * 26., 26.);\n\t\t\t\t\ttexcoord.y = mod(pos.z * 26., 26.);\n\t\t\t\t\tif (posd.y < 0.)\n\t\t\t\t\t\ttexcoord.y += 42.;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ( getMaterialColor( tex, texcoord, col ) ) {\n\t\t\t\t\tddist = 2. - (dist / 42.);\n\t\t\t\t\tbr = bdist[d];\n\t\t\t\t\tclosest = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += posd;\n\t\t\tdist += ll;\n\t\t}\n\t}\n\t\n\treturn col * ddist * (br/355.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfragColor = vec4( renderMinecraft( uv ) ,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 57, 57, 96], [120, 120, 180, 194, 1776], [1778, 1778, 1802, 1802, 2058], [2060, 2060, 2093, 2093, 3771], [3773, 3773, 3830, 3830, 3924]], "test": "untested"}
{"id": "WdGBz3", "name": "Boyd-Maxwell 2D circle packing", "author": "neozhaoliang", "description": "Limit set of rank 4 hyperbolic Coxeter groups, drawn both on the boundary sphere and the stereo-projected plane.", "tags": ["coxeter", "tiling", "hyperbolic", "circlepacking", "limitset"], "likes": 71, "viewed": 2766, "published": 3, "date": "1607739529", "time_retrieved": "2024-07-30T20:30:59.502248", "image_code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nBoyd-Maxwell circle packings of hyperbolic Coxeter groups: rank 4/level 2 case\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information check the github repo:\n\n    https://github.com/neozhaoliang/Hyperbolic-Honeycombs\n\nRequired input:\n\nThe Coxeter diagram of a rank 4 Coxeter group G = <A, B, C, D>, with dihedral angles\nm_{s,t} in the order (AB, AC, AD, BC, BD, CD).\n\nNote:\n\n1. CD must be finite\n2. The triangle group <B, C, D> must be hyperbolic\n\nIf you see only a sphere and a small disk under it, try comment out `#define useMouseInvert` below.\n*/\n\n\n#define useMouseInvert\n\n#define shiny        5.\n\n\n//#define config      initLevel2Graph(float[6](4., 2., 7., 4., 2., 5.))\n//#define config      initLevel2Graph(float[6](3., 2., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](4., 4., 4., 4., 4., 4.))\n//#define config      initLevel2Graph(float[6](2., 2., 7., inf, 3., 3.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 7., 2., 3.))\n#define config      initLevel2Graph(float[6](5., 2., 3., 4., 3., 3.))\n\n\nvec2 map(vec3 p) {\n    float d1 = sdSphere(p);\n    float d2 = sdPlane(p);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(0.0001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * (t*0.125+1.))\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.85;\n    }\n    return clamp(1.0 - occ, 0.2, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 20; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0., 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol) {\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.01, lDist, 8.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = shiny / (1. + lDist * lDist * .001);\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 6.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n    col += basecol * diff;\n    col += basecol * vec3(.8, 1., 0.3) * spec * 4.;\n    col += basecol * vec3(1.2, 1., .8) * fres * fres * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.z, 0., 1.);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 scenecol = vec3(0.);\n\n// initialize the mirrors\n  \n    config;\n    \n    vec3 camera = vec3(4, 1.5, 4);\n    vec3 lp =  vec3(.5, .5, 4.); //light position\n    camera.xy = rot2d(camera.xy, iTime*0.3);\n    vec3 lookat  = vec3(0.);\n    vec3 up = vec3(0, 0, 1);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    \n    float lw = 8. / iResolution.y;\n\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++) {\n        for(int jj=0; jj<AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            float ed;\n            vec3 col;\n            vec2 p0;\n            vec3 nor;\n\n            // the sphere is hit\n            if (id == 0.) {\n                nor = pos;\n                p0 = sphereToPlane(pos);\n            }\n            \n            // the plane is hit\n            else if (id == 1.) {\n                nor = vec3(0, 0, 1);\n                p0 = pos.xy;\n            }\n#ifdef useMouseInvert      \n            vec2 mouse = (iMouse.xy-2.*iResolution.xy)/iResolution.y;\n            if (iMouse.z == 0.)\n                mouse = vec2(1.5, 1.5);\n            mouse = rot2d(mouse, iTime*0.1);\n            float k = 1./L2(mouse);\n            vec2 invCtr = k * mouse;\n            float tt = (k - 1.) / L2(p0 -invCtr);\n            p0 = tt*p0 + (1. - tt)*invCtr;\n#endif\n            vec3 basecol = getcolor(p0, ed);\n            col = getColor(camera, rd, pos, nor, lp, basecol);\n            float dist = distanceToMirrors(p0) ;\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01*t*t));\n            scenecol += col;\n        }\n    }\n    scenecol /= (float(AA) * float(AA));\n\n    fragColor = vec4(sqrt(max(scenecol, 0.0)), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define inf                 1.0     // Vinberg convention for edge labels\n#define MAX_REFLECTIONS     500\n#define AA                  2\n#define PI                  3.141592653\n#define L2(x)               dot(x, x)\n#define L2XY(x, y)          L2(x - y)\n#define Hyperbolic          -1.0\n#define Euclidean           0.\n#define Spherical           1.\n#define MAX_TRACE_STEPS     500\n#define MIN_TRACE_DIST      0.001\n#define MAX_TRACE_DIST      100.0\n#define PRECISION           0.0001\n#define EdgeSize1           0.0035 \n#define EdgeSize2           0.01\n#define ColorScale          0.8\n\n// Move a vertex of Euclidean type (if there is any) to infinity,\n// so the pattern tiles the entire plane\n#define moveVertexToInf\n\n// 4x4 Cartan matrix for the Coxeter group\nmat4 cartan;\n\n// geometry type of each vertex in the Coxeter diagram\n// -1 for hyerbolic, 0 for Euclidean, 1 for spherial\nvec4 vertexType = vec4(1);\n\n// coordinates of a Euclidean vertex\nvec2 euclideanVertex;\n\n// if we are outside of the unit circle\n// if a point lies outside of unit circle, the distance\n// estimation becomes inaccurate. We use EdgeSize2 to control the edge size for this case.\nbool outside = false;\n\n// if there is an Euclidean vertex, i.e. if remove this vertex, the remain diagram is affine\nbool hasEuclideanVertex;\n\n// compute cos(PI / x), for x = inf this is just inf\nfloat dihedral(float x) {\n    return x == inf ? inf : cos(PI / x);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) { return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x); }\n\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\n// compute the vertex type of each vertex.\n// for each vertex in the Coxeter diagram, its vertex type is determined by the triangle group G formed by\n// the remaining three vertices. This vertex is of hyperbolic/spherical/euclidean iff G is\n// hyperbolic/spherical/euclidean, respectively.\n// This can be checked from the determinant of the leading minors of the Cartan matrix.\nvoid checkCartan(mat4 M) {\n    const float e = 0.001;\n    float det;\n    det = determinant(mat3(M[1].yzw, M[2].yzw, M[3].yzw));\n    vertexType.x = step(-e, det) + step(e, det) - 1.;\n        \n    det = determinant(mat3(M[0].xzw, M[2].xzw, M[3].xzw));\n    vertexType.y = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyw, M[1].xyw, M[3].xyw));\n    vertexType.z = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xyz, M[1].xyz, M[2].xyz));\n    vertexType.w = step(-e, det) + step(e, det) - 1.;\n}\n\n\n// For spheres cen is the center, r is the radius\n// For planes cen is the normal vector, r is the offset from the origin along the normal. \n// if invert is true then the inside/outside of the sphere is exchanged.\nstruct Ball {\n    vec2 cen;\n    float r;\n    bool isplane;\n    bool invert;\n};\n\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[4] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[4] clusters;\n\n\n// create a default ball (unit circle)\nBall defaultBall() {\n    return Ball(vec2(0), 1., false, false);\n}\n\n\nBall from_plane(vec2 normal, float offset) {\n    return Ball(normal, offset, true, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout int count) {\n    vec2 cen = B.cen;\n    float r = B.r;\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(cen, r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * cen;\n        count += 1;\n        return false;\n    }\n    else {\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if (k < 1.0)\n            return true;\n        p = k * q + cen;\n        count += 1;\n        return false;\n    }\n}\n\n\nvec2 getIntersection(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    return k*dir;\n}\n\nBall solveBall(Ball B1, Ball B2, Ball B3) {\n    vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - (r1*r1 - r2*r2)) / (2. * dot(B1.cen - B2.cen, dir));\n    vec2 cen = k * dir; \n    float r = sqrt(L2XY(cen, B1.cen) - r1*r1);\n    return from_sphere(cen, r);\n}\n\n\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.cen, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.cen) - B.r;\n        return B.invert ? -k : k;\n    }\n}\n\n\nvoid initLevel2Graph(in float[6] diagram) {\n    Ball B0, B1, B2, B3;\n    float c01 = dihedral(diagram[0]);\n    float c02 = dihedral(diagram[1]);\n    float c03 = dihedral(diagram[2]);\n    float c12 = dihedral(diagram[3]);\n    float c13 = dihedral(diagram[4]);\n    float c23 = dihedral(diagram[5]);\n    \n    cartan = mat4(1, -c01, -c02, -c03,\n                  -c01, 1, -c12, -c13,\n                  -c02, -c12, 1, -c23,\n                  -c03, -c13, -c23, 1);\n    checkCartan(cartan);\n    \n    float s23 = sqrt(1. - c23*c23);\n    \n    // The two virtual balls B2, B3 (reflection mirrors) are lines through the origin\n    B2 = from_plane(vec2(1, 0), 0.);\n    B3 = from_plane(vec2(-c23, s23), 0.);\n    \n    // The mirror ball B1(x, y, r) satisfy\n    // Angle with B2: dot((x, y), (1, 0)) / r = c12\n    // Angle with B3: dot((x, y), (-c23, s23)) / r = c13\n    // Orthogonal to the real ball (unit ball) C0: x^2 + y^2 = r^2 + 1\n    float k1 = c12;\n    float k2 = (c13 + c23*c12) / s23;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    B1 = from_sphere(vec2(k1*r, k2*r), r);\n    \n    // The mirror ball B0(x, y, r) satisfy\n    // Angle with B2: dot((x, y), (1, 0)) / r = c02\n    // Angle with B3: dot((x, y), (-c23, s23)) / r = c03\n    // Angle with B1:\n    //\n    //        r^2 + r1^2 - |(x,y) - (x1,y1)|^2\n    //        --------------------------------  = -c01\n    //                   2 * r * r1\n    k1 = c02;\n    k2 = (c03 + c23*c02) / s23;\n    \n    float a = k1*k1 + k2*k2 - 1.;\n    float b = dot(vec3(k1, k2, c01), vec3(B1.cen, B1.r));\n    float c = L2(B1.cen) - B1.r*B1.r;\n    \n    r = b / a - sqrt(b*b - a*c) / a;\n    B0 = from_sphere(vec2(k1*r, k2*r), r);\n\n    \n    coclusters = Ball[4] (B0, B1, B2, B3);\n    \n    for (int k = 0; k < 4; k++) {\n        clusters[k] = defaultBall();\n    }\n   \n    invertBall(clusters[0]);\n    \n    if (vertexType.y == Hyperbolic) {\n        float r = sqrt(L2(B0.cen) - B0.r*B0.r);\n        clusters[1] = from_sphere(vec2(0), r);\n    }\n    if (vertexType.z == Hyperbolic) {\n        clusters[2] = solveBall(B0, B1, B3);\n    }\n    if (vertexType.w == Hyperbolic) {\n        clusters[3] = solveBall(B0, B1, B2);\n    }\n    \n    if (vertexType.y == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = vec2(0);\n        return;\n    }\n        \n    if (vertexType.z == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B3);\n        return;\n    }\n    \n    if (vertexType.w == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B2);\n        return;\n    }\n}\n\nvec2 applyMobius(vec2 p) {\n    if (hasEuclideanVertex) {\n        vec2 A = euclideanVertex;\n        vec2 B = vec2(0, 0);\n        vec2 C = vec2(1, 0);\n        vec2 D = vec2(4, 0);\n        p = cdiv(cmul(p, A) + B, cmul(C, p) + D);\n    }\n    return p;\n}\n\n\nfloat distanceToMirrors(vec2 p) {\n    float d = abs(sdistanceToBall(p, coclusters[0]));\n    \n    if (length(p) > 1.) {\n        p /= L2(p);\n        outside = true;\n    }\n    \n    for (int k = 1; k < 4; k++) {\n         d = min(d, abs(sdistanceToBall(p, coclusters[k])));\n    }\n    return d;\n}\n\n\nvoid fold(inout vec2 p, inout int count, inout int index) {\n#ifdef moveVertexToInf\n    p = applyMobius(p);\n#endif\n    for (int i = 0; i < MAX_REFLECTIONS; i++) {\n        bool cond = true;\n        for (int k = 0; k < 4; k++) {\n            cond = try_reflect(p, coclusters[k], count) && cond;\n        }\n        if (cond)\n            break;\n    }\n    for (int k = 0; k < 4; k++) {\n        if (vertexType[k] == Hyperbolic && sdistanceToBall(p, clusters[k]) < -0.0001) {\n            index = k;\n            break;\n        }\n    }\n}\n\n// signed distance to unit ball and plane z=-1\nfloat sdSphere(vec3 p) { return length(p) - 1.0; }\nfloat sdPlane(vec3 p) { return p.z + 1.0; }\n\n// project points on the unit ball to plabe z=-1\nvec2 sphereToPlane(vec3 p) {\n    return 2. * p.xy / (1. - p.z);\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\n// you can implement your color functions here\nvec3 colormap(int index, float t) {\n    float c = float(index) + 1.;\n    return .5 + .45*cos(2.*PI  * pow(t, 0.3) * ColorScale * c + vec3(0, 1, 2));\n}\n\nvec3 getcolor(inout vec2 p, out float ed) {\n    int index = -1;\n    int count = 0;\n    fold(p, count, index);\n    float dist = distanceToMirrors(p);\n    float t = clamp(float(count + 1) / float(MAX_REFLECTIONS), 0., 1.);\n    vec3 col = colormap(index, t);\n    float es = outside ? EdgeSize2 : EdgeSize1;\n    float aa = fwidth(dist) / 2.;\n    col = mix(col, vec3(0), 1. - smoothstep(es-aa, es+aa, dist));\n    return col;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1263, 1263, 1281, 1281, 1407], [1409, 1434, 1458, 1458, 1707], [1709, 1763, 1802, 1802, 2100], [2102, 2102, 2139, 2139, 2397], [2399, 2399, 2468, 2468, 2747], [2749, 2749, 2825, 2825, 3499]], "test": "untested"}
{"id": "wstfDj", "name": "Glowing sine waves", "author": "maksy", "description": "Basic stuff but looks nice.", "tags": ["2d", "sine", "basics"], "likes": 3, "viewed": 360, "published": 3, "date": "1607725949", "time_retrieved": "2024-07-30T20:31:00.336019", "image_code": "#define S smoothstep\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    uv.y += 0.04*sin(iTime*3.2 + uv.x*28.);  \n    uv.y += 0.032*sin(iTime*1.4 + uv.x*32.);\n    uv.y += 0.022*sin(iTime*2.2 + uv.x*10.);\n    uv.y += 0.012*sin(iTime*2.0 + uv.x*12.);\n    uv.y += 0.015*sin(iTime*.2 + uv.x*41.3);\n    \n    vec3 col = mix(vec3(0.), vec3(1., 1., 1.), S(0.12, .02, abs(uv.y)));\n    \n    col *= 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col += mix(vec3(0.), vec3(1., 1., 1.), S(0.01, .002, abs(uv.y)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 83, 612]], "test": "untested"}
{"id": "WsVfRt", "name": "Sand † Water", "author": "wyatt", "description": "I got a bit excited when a cross appeared in the middle. ", "tags": ["erosion"], "likes": 7, "viewed": 462, "published": 3, "date": "1607725767", "time_retrieved": "2024-07-30T20:31:01.135880", "image_code": "Main {\n    vec4 a = A(U), b = D(U);\n    Q = .5*b*vec4(1,.9,.8,1)+vec4(0,.03*a.w,.1*a.w,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nfloat ln (vec3 p, vec3 a, vec3 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n}", "buffer_a_code": "// Apply forces\nvec2 F (vec2 u) {\n    vec4 a = A(gl_FragCoord.xy + u);\n    vec4 d = D(gl_FragCoord.xy + u);\n\treturn .1*(d.x+.1*a.w*(.9+.1*abs(a.w-1.)))*u/dot(u,u);\n}\nMain {\n\tQ = A(U);\n    vec4 d = D(U);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    if (x!=0||y!=0)\n       Q.xy -= Q.w*F(vec2(x,y));\n    Q.w += 1e-3;\n\tif (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) {\n    \tQ = vec4(0,0,0,0);\n        if (U.y<.5*R.y-.5*abs(U.x-0.5*R.x)) Q.w = 1.;\n        if (length(U-0.5*R)<0.25*R.y) Q.zw = vec2(.1,1);\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<5.)\n        Q = vec4(1,0,6,1);\n    if (U.x<2.||U.y<2.||R.x-U.x<2.||R.y-U.y<2.){\n        Q.w*=0.9;\n        Q.xy = normalize(U-0.5*R);\n    }\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Conservative advect alternating x and y direction\nMain {\n    Q = vec4(0);\n    if (iFrame%2==0)\n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = vec2(0,i);\n        vec4 a = A(U+u-vec2(0,0.5)),\n             b = A(U+u),\n             c = A(U+u+vec2(0,0.5));\n        float w1 = 1.+c.y-a.y;\n        if (w1>0.) {\n            float w = clamp(u.y+.5+c.y,-.5,.5)-\n                      clamp(u.y-.5+a.y,-.5,.5);\n            Q.xyz += b.w*w/w1*b.xyz;\n            Q.w += b.w*w/w1;\n        }\n    } else \n\tfor (float i = -1.; i <= 1.; i++)\n    {\n    \tvec2 u = vec2(i,0);\n        vec4 a = A(U+u-vec2(0.5,0)),\n             b = A(U+u),\n             c = A(U+u+vec2(0.5,0));\n        float w1 = 1.+c.x-a.x;\n        if (w1 > 0.) {\n            float w = clamp(u.x+.5+c.x,-.5,.5)-\n                      clamp(u.x-.5+a.x,-.5,.5);\n            Q.xyz += b.w*w/w1*b.xyz;\n            Q.w += b.w*w/w1;\n        }\n    }\n    if (Q.w > 0.) Q.xyz /= Q.w;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// density-dependent diffusion\nvec4 X (vec4 Q, vec2 u) {\n\tvec4 a = A(gl_FragCoord.xy + u);\n    float f = Q.w-a.w;\n    return mix(Q,a,clamp(10.*f*f,0.,1.));\n}\nMain {\n    Q = A(U);\n    Q = \n        0.125*X(Q,vec2(1,0))+\n        0.125*X(Q,vec2(0,1))+\n        0.125*X(Q,vec2(-1,0))+\n        0.125*X(Q,vec2(0,-1))+\n        0.125*X(Q,vec2(1,1))+\n        0.125*X(Q,vec2(1,-1))+\n        0.125*X(Q,vec2(-1,-1))+\n        0.125*X(Q,vec2(-1,1));\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = D(U);\n    vec4 a = A(U);\n    Q += 1e-5*(1.+0.1*exp(-length(U-0.5*R)/R.y));\n    Q -= 1e-3*a.w*Q.w*(length(a.xy)-.1*a.w);\n    if (iFrame < 30) Q = vec4(1)+.05*C(U).x+exp(-length(U-0.5*R)/R.y);\n    \n}", "buffer_d_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tdGBzd", "name": "Simple Flythrough Example", "author": "oneshade", "description": "A simple example of how to allow the user to fly through a raymarched scene. I hope the comments aren't too excessive, I was trying to explain it as much as possible.", "tags": ["3d", "raymarching", "example", "tutorial", "flythrough"], "likes": 2, "viewed": 134, "published": 3, "date": "1607716466", "time_retrieved": "2024-07-30T20:31:01.975635", "image_code": "/*\nUse the mouse to rotate the camera and the arrow keys to move it.\n\nCommon: contains all of the settings and helper functions for texture lookups\nBuffer A: contains the code for updating the camera position and yaw/pitch rotationa\nImage: contains the raymarching code (for a more in-depth raymarching tutorial, visit Jamie Wong's amazing website: http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/)\n*/\n\nfloat mapScene(in vec3 p) {\n    p = mod(p, 2.0) - 1.0; // Repeat the scene infinitely with a spacing of 2 units (the -1 is to center it)\n    return length(p) - 0.25; // Sphere with a radius of 0.25 units\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + SMALL_STEP.xyy) - mapScene(p - SMALL_STEP.xyy),   // How much the distance changes in the x direction\n                          mapScene(p + SMALL_STEP.yxy) - mapScene(p - SMALL_STEP.yxy),   // How much the distance changes in the y direction\n                          mapScene(p + SMALL_STEP.yyx) - mapScene(p - SMALL_STEP.yyx))); // How much the distance changes in the z direction\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Center and normalize uv (with aspect ratio so there is no squashing)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Generate a ray for the pixel:\n    vec3 rayOrigin = getViewPosition();\n    mat3 camera = getCamera(getViewDirection());\n    vec3 rayDirection = normalize(FOCAL_LENGTH * camera[2] + uv.x * camera[0] + uv.y * camera[1]);\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float distanceTraveled = 0.0;\n    for (int iteration=0; iteration < MAX_ITERATIONS; iteration++) {\n        vec3 position = rayOrigin + rayDirection * distanceTraveled;\n        float sceneDistance = mapScene(position);\n\n        // Is the ray close enough to be hitting?\n        if (sceneDistance < MIN_HIT_DISTANCE) {\n            vec3 normal = getNormal(position);\n            vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n            fragColor.rgb = vec3(max(0.0, dot(normal, light))); // Diffuse shading\n            break;\n        }\n\n        // Has the ray gone too far?\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        // Move forward maximum distance possible without missing anything:\n        distanceTraveled += sceneDistance;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\nThe camera rotation is stored as yaw/pitch rotations. Yaw is spin and pitch is tilt.\nIf you need help visualizing this, this image should help:\nhttps://upload.wikimedia.org/wikipedia/commons/c/c1/Yaw_Axis_Corrected.svg\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Have the viewing position and direction been initialized?\n    if (iFrame > 0) {\n        ivec2 address = ivec2(fragCoord);\n\n        // Should this pixel store the view position?\n        if (address == VIEW_POSITION_ADDR) {\n            fragColor = vec4(getViewPosition(), 1.0);\n            mat3 camera = getCamera(getViewDirection());\n \n            // Update the view position based on keypresses:\n            if (keyUpPressed()) {\n                fragColor.xyz += camera[2] * STEP_SIZE; // Move STEP_SIZE units in the camera's forward direction\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= camera[2] * STEP_SIZE; // Move STEP_SIZE units opposite the camera's forward direction\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += camera[0] * STEP_SIZE; // Move STEP_SIZE units in the camera's right direction\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= camera[0] * STEP_SIZE; // Move STEP_SIZE units opposite the camera's right direction\n            }\n        }\n\n        // Should this pixel store the view direction?\n        if (address == VIEW_DIRECTION_ADDR) {\n            // Center and normalize mouse position, multiply by two pi for rotation from -180 to 180, then scale it by ROTATION_SPEED\n            vec2 viewDirection = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TWO_PI * ROTATION_SPEED;\n            fragColor = vec4(viewDirection, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Raymarching constants:\nconst vec3 SMALL_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 100.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_ITERATIONS = 50;\nconst float FOCAL_LENGTH = 1.0;\n\n// Math constants (only two pi in this case):\nconst float TWO_PI = 6.2832;\n\n// Amount by which the camera moves and rotates:\nconst float STEP_SIZE = 0.1;\nconst float ROTATION_SPEED = 0.5;\n\n// Addresses to viewing data:\nconst ivec2  VIEW_POSITION_ADDR = ivec2(0, 0);\nconst ivec2 VIEW_DIRECTION_ADDR = ivec2(1, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int    KEY_UP = 38;\nconst int  KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int  KEY_LEFT = 37;\n\n// A bunch of crazy macros because they are the only way to define texelFetches in Common :(\n#define  getViewPosition() texelFetch(iChannel0, VIEW_POSITION_ADDR, 0).xyz\n#define getViewDirection() texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).xy\n\n#define     keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define   keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define  keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define   keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Calculates camera axes:\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(vec3(       c.x, 0.0,         s.x),  // Camera right axis (x)\n                vec3(s.x * -s.y, c.y, -c.x * -s.y),  // Camera up axis (y)\n                vec3(s.x *  c.y, s.y, -c.x *  c.y)); // Camera forward axis (z)\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 427, 454, 454, 632], [634, 634, 661, 661, 1086], [1088, 1088, 1143, 1219, 2340]], "test": "untested"}
{"id": "tsyBRd", "name": "Chromatic aberration / RGB Shift", "author": "clementroche", "description": "modular Chromatic aberration / RGB Shift function", "tags": ["chromaticaberration", "rgb", "rgbshift"], "likes": 4, "viewed": 543, "published": 3, "date": "1607714127", "time_retrieved": "2024-07-30T20:31:02.739592", "image_code": "vec4 RGBShift(sampler2D map, vec2 uv, vec2 offset, float power, float barrelness) {\n    vec2 center = uv - vec2( .5 );\n\tfloat d = power * length( center );\n\tnormalize( center );\n\tvec2 value = mix( offset * power * 0.1, d * center * offset, barrelness);\n    \n    vec4 c1 = texture( map, uv - value );\n\tvec4 c2 = texture( map, uv );\n\tvec4 c3 = texture( map, uv + value );\n    \n    return vec4( c1.r, c2.g, c3.b, (c1.a + c2.a + c3.a) / 3. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 offset = vec2(0.05);\n    float power = iMouse.y /iResolution.y;\n    float barrelness = iMouse.x /iResolution.x;\n    \n    \n    fragColor = RGBShift(iChannel0, uv, offset, power, barrelness );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 83, 83, 440], [443, 443, 500, 500, 747]], "test": "untested"}
{"id": "tdyBRt", "name": "Viscosity", "author": "klk", "description": "Some soapy slimy colorfull liquid", "tags": ["slimy"], "likes": 44, "viewed": 1621, "published": 3, "date": "1607701656", "time_retrieved": "2024-07-30T20:31:03.494573", "image_code": "// Created by Alex Kluchikov\n\n#define PI 3.141592654\n\nvec2 rot(vec2 p,float a)\n{\n    float c=cos(a*15.83);\n    float s=sin(a*15.83);\n    return p*mat2(s,c,c,-s);\n}\n\nvoid mainImage(out vec4 o, in vec2 uv)\n{\n    uv/=iResolution.xx;\n    uv=vec2(.125,.75)+(uv-vec2(.125,.75))*.03;\n    float T=iTime*.25;\n\n    vec3 c = clamp(1.-.7*vec3(\n        length(uv-vec2(.1,0)),\n        length(uv-vec2(.9,0)),\n        length(uv-vec2(.5,1))\n        ),0.,1.)*2.-1.;\n\n    vec3 c0=vec3(0);\n    float w0=0.;\n    const float N=16.;\n    for(float i=0.;i<N;i++)\n    {\n        float wt=(i*i/N/N-.2)*.3;\n        float wp=0.5+(i+1.)*(i+1.5)*0.001;\n        float wb=.05+i/N*0.1;\n    \tc.zx=rot(c.zx,1.6+T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7+T*wt+(uv.y+1.1)*15.*wp);\n    \tc.yz=rot(c.yz,c.x*c.y*wb+2.4-T*0.79*wt+(uv.x+uv.y*(fract(i/2.)-0.25)*4.)*17.*wp);\n    \tc.zx=rot(c.zx,c.y*c.z*wb+1.6-T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7-T*wt+(uv.y+1.1)*15.*wp);\n        float w=(1.5-i/N);\n        c0+=c*w;\n        w0+=w;\n    }\n    c0=c0/w0*2.+.5;//*(1.-pow(uv.y-.5,2.)*2.)*2.+.5;\n    c0*=.5+dot(c0,vec3(1,1,1))/sqrt(3.)*.5;\n    c0+=pow(length(sin(c0*PI*4.))/sqrt(3.)*1.0,20.)*(.3+.7*c0);\n\to=vec4(c0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 80, 80, 163], [165, 165, 205, 205, 1215]], "test": "untested"}
{"id": "3syBzd", "name": "2D ray casting with ray marching", "author": "AI", "description": "Change the mouse over the screen to move the light source to cast rays on different parts of the 2D objects.\nYou may add more objects to the scene.\nChange the parameters of the objects as you wish.", "tags": ["2d", "raymarching", "raycasting", "shadow", "light", "circle", "rectangle", "generativeart"], "likes": 3, "viewed": 795, "published": 3, "date": "1607696452", "time_retrieved": "2024-07-30T20:31:04.251549", "image_code": "#define MAXSTEPS 100\n#define MAXDIST 150.\n#define MINDIST 0.01\n\n//a circle\nfloat dist2circle( in vec2 p,in vec2 center,in float radius ) \n{\n    return length(p-center)-radius;\n}\n\n//a line segment\nfloat lineSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//a rectangle\nfloat dis2box( in vec2 p, in vec2 center, in vec2 r )\n{\n    vec2 d = abs(p-center)-r;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//define objects by distance function\nfloat getDist(vec2 p){\n\n\tfloat d=dist2circle(p,vec2(.55,.3),.12);\n    float d2=dist2circle(p,vec2(.5,.9),.1);\n    d=min(d,d2);    \n    d2=dist2circle(p,vec2(.15,.5),.1);\n    d=min(d,d2);    \n    d2=dis2box(p,vec2(0.8,.6),vec2(.1,.07));\n    d=min(d,d2);    \n\td2=dis2box(p,vec2(0.2,.12),vec2(.1,.07));\n    d=min(d,d2);  \n\treturn d;\n\n}\n//2D ray marching\nfloat rayMarch2D(vec2 ro,vec2 rd)\n{\n\t float dO=0.;\n     for(int i=0;i<MAXSTEPS;++i){\n      vec2 p=ro+rd*dO;\n      float ds=getDist(p);\n      dO+=ds;\n      if (ds<MINDIST || ds>MAXDIST) break;\n      }\n return  dO;   \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv =fragCoord/iResolution.xy;\n    vec3 color=vec3(0.);\n    float line;\n    float radius=.01;\n    float d; \n\tvec2 ro=vec2(0.,.0)+iMouse.xy/iResolution.xy;\n    vec2 rd=normalize(uv-ro);\n    float dis=rayMarch2D(ro,rd);\n    vec2 point=ro+rd*dis;\n    d=dist2circle(uv,point,radius);\n    d=1.-smoothstep(0.0,0.005,d);\n    d+=.5-.5*smoothstep(0.,0.01,dist2circle(uv,vec2(.55,.3),.12));\n    d+=.5-.5*smoothstep(0.,0.01,dist2circle(uv,vec2(.5,.9),.1));\n    d+=.5-.5*smoothstep(0.,0.01,dist2circle(uv,vec2(.15,.5),.1));\n\td+=.5-.5*smoothstep(0.,0.01,dis2box(uv,vec2(.8,.6),vec2(.1,.07)));\n  \td+=.5-.5*smoothstep(0.,0.01,dis2box(uv,vec2(.2,.12),vec2(.1,.07)));;\n\n    //---draw ray from ro to point\n    line=1.-smoothstep(0.,0.001,lineSegment(uv,ro,point));\n    float light=1.-smoothstep(0.,0.1,dist2circle(uv,ro,.02));\n    color=vec3(clamp(d+line,0.,1.),line,light);\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 75, 139, 139, 177], [179, 196, 250, 250, 369], [371, 385, 440, 440, 527], [529, 567, 589, 589, 899], [900, 918, 953, 953, 1136], [1139, 1139, 1196, 1196, 2090]], "test": "untested"}
{"id": "3syBRd", "name": "Quick Slime 3D", "author": "dr2", "description": "Metallic goo", "tags": ["reflection", "metaball", "dynamics"], "likes": 11, "viewed": 380, "published": 3, "date": "1607692184", "time_retrieved": "2024-07-30T20:31:05.187048", "image_code": "// \"Quick Slime 3D\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMin (float a, float b, float r);\nmat3 DirVuMat (vec3 vd);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nBall = 36;\nvec3 sunDir;\nfloat tCur, dstFar, obSpc, obSz;\nint idObj;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat ObjDf (vec3 p)\n{\n  vec4 s;\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    s = Loadv4 (3 + 3 * n);\n    q = p - s.xyz;\n    d = PrSphDf (q, 0.5 * s.w);\n    dMin = SmoothMin (d, dMin, 1.5);\n  }\n  idObj = 1;\n  q = p;\n  q.xz = mod (q.xz + 0.5 * obSpc, obSpc) - 0.5 * obSpc;\n  d = PrSphDf (q, 0.5 * obSz);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, clCol;\n  vec2 q;\n  float dstGrnd, f, fd, ff, sd, sh;\n  if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    f = 1. - smoothstep (0.6, 0.9, dstGrnd / dstFar);\n    if (f > 0.) vn = VaryNf (2. * ro, vn, f);\n    sh = (dstGrnd < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = 0.9 * mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5), 0.1 +\n       0.5 * smoothstep (0.3, 0.5, Fbm2 (ro.xz)));\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n    col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  } else if (rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n    sd = max (dot (rd, sunDir), 0.);\n    col += vec3 (1., 1., 0.9) * (0.3 * pow (sd, 512.) + 0.1 * pow (sd, 1024.));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo;\n  float dstObj, f;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (1., 0., 1., 0.2);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.5, 0.55, 0.5, 0.);\n      f = 1. - smoothstep (0.6, 0.9, dstObj / dstFar);\n      if (f > 0.) vn = VaryNf (8. * ro, vn, 4. * f);\n    }\n    col = col4.rgb * (0.2 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n       0.8 * max (dot (vn, sunDir), 0.)) + col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n    if (idObj == 1) col = mix (col, BgCol (ro, reflect (rd, vn)), 0.5);\n    col = mix (col, BgCol (roo, rd), smoothstep (0.8, 1., dstObj / dstFar));\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 col, rd, ro, rLead, rMid;\n  vec2 canvas, uv;\n  float az, el, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  stDat = Loadv4 (0);\n  obSpc = stDat.y;\n  obSz = stDat.z;\n  rLead = Loadv4 (1).xyz;\n  rMid = Loadv4 (2).xyz;\n  dstFar = 200.;\n  az = -0.01 * pi * tCur;\n  el = 0.15 * pi;\n  zmFac = 5.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.08 * pi, 0.45 * pi);\n  ro = rLead + 30. * vec3 (cos (el) * sin (az + vec2 (0.5 * pi, 0.)), sin (el)).xzy;\n  vuMat = DirVuMat (normalize (rMid - ro));\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (cos (0.01 * tCur), 1., sin (0.01 * tCur)));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Quick Slime 3D\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 36;\n\nvec3 rLead;\nfloat tCur, nStep, obSpc, obSz;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fAttr, grav, rSep, szN, szAv,\n     fc, ft, drv, dt;\n  fOvlap = 1000.;\n  fricN = 2.;\n  fricS = 0.05;\n  fricSW = 10.;\n  fricT = 0.5;\n  fAttr = 0.05;\n  fDamp = 0.01;\n  grav = 5.;\n  p = Loadv4 (3 + 3 * mId);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (3 + 3 * mId + 1).xyz;\n  wm = Loadv4 (3 + 3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (3 + 3 * n);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      fc = fOvlap * (szAv / rSep - 1.);\n      vmN = Loadv4 (3 + 3 * n + 1).xyz;\n      wmN = Loadv4 (3 + 3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross ((sz * wm + szN * wmN) / (sz + szN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += fAttr * (rmN - rm);\n  }\n  szAv = 0.5 * (sz + 1.);\n  dr = vec3 (0., rm.y, 0.);\n  rSep = abs (dr.y);\n  if (rSep < szAv) {\n    fc = fOvlap * (szAv / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  szAv = 0.5 * (sz + obSz);\n  dr = rm;\n  dr.xz -= obSpc * floor ((rm.xz + 0.5 * obSpc) / obSpc);\n  rSep = length (dr);\n  if (rSep < szAv) {\n    fc = fOvlap * (szAv / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += fAttr * (rLead - rm);\n  am.y -= grav;\n  am -= fDamp * vm;\n  dt = 0.02;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * sz);\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm, out float sz)\n{\n  float mIdf, nbEdge;\n  nbEdge = floor (sqrt (float (nBall)) + 0.01);\n  mIdf = float (mId);\n  rm = vec3 (floor (vec2 (mod (mIdf, nbEdge), mIdf / nbEdge)) - 0.5 * (nbEdge - 1.), 3.).xzy;\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + tCur + 0.3),\n     Hashff (mIdf + 0.6)) - 0.5);\n  wm = vec3 (0.);\n  sz = 1. - 0.1 * Hashff (mIdf + 0.1);\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 rm, vm, wm, rMid;\n  vec2 iFrag;\n  float sz;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  tCur = iTime;\n  if (pxId >= 3) mId = (pxId - 3) / 3;\n  else mId = -1;\n  doInit = false;\n  if (iFrame <= 5) {\n    obSpc = 8.;\n    obSz = 3.;\n    doInit = true;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    obSpc = stDat.y;\n    obSz = stDat.z;\n    rLead = Loadv4 (1).xyz;\n  }\n  if (doInit) {\n    nStep = 0.;\n    rLead = vec3 (0., 0., 0.);\n    if (mId >= 0) Init (mId, rm, vm, wm, sz);\n  } else {\n    ++ nStep;\n    rLead += 0.05 * vec3 (0.9, 0., 1.);\n    if (mId >= 0) Step (mId, rm, vm, wm, sz);\n  }\n  if (pxId == 2) {\n    rMid = vec3 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) rMid += Loadv4 (3 + 3 * n).xyz;\n    rMid /= float (nBall);\n  }\n  if      (pxId == 0) stDat = vec4 (nStep, obSpc, obSz, 0.);\n  else if (pxId == 1) stDat = vec4 (rLead, 0.);\n  else if (pxId == 2) stDat = vec4 (rMid, 0.);\n  else if (pxId == 3 + 3 * mId) stDat = vec4 (rm, sz);\n  else if (pxId == 3 + 3 * mId + 1) stDat = vec4 (vm, 0.);\n  else if (pxId == 3 + 3 * mId + 2) stDat = vec4 (wm, 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syBRd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[473, 473, 495, 495, 881], [883, 883, 916, 916, 1162], [1164, 1164, 1185, 1185, 1435], [1438, 1438, 1475, 1475, 1704], [1706, 1706, 1737, 1737, 3054], [3056, 3056, 3091, 3091, 3897], [3899, 3899, 3955, 3955, 4845], [4847, 4847, 4880, 4880, 4907], [4909, 4909, 4954, 4954, 5057], [5059, 5059, 5084, 5084, 5253], [5287, 5287, 5311, 5311, 5364], [5366, 5366, 5390, 5390, 5520], [5522, 5522, 5547, 5547, 5693], [5695, 5695, 5720, 5720, 5906], [5908, 5908, 5930, 5930, 6084], [6086, 6086, 6107, 6107, 6262], [6264, 6264, 6293, 6293, 6505], [6507, 6507, 6546, 6546, 6731], [6825, 6825, 6850, 6850, 6978]], "test": "untested"}
{"id": "WsGBRd", "name": "大龙猫 - Quicky#048", "author": "totetmatt", "description": "Stereographic projection test ", "tags": ["quicky"], "likes": 10, "viewed": 418, "published": 3, "date": "1607688902", "time_retrieved": "2024-07-30T20:31:05.954995", "image_code": "mat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nvec3 p(float i)\n{\n    return .5+.5*cos(2.*3.1415*(1.*i+vec3(0.,.33,.67)));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5*iResolution.xy) / iResolution.y;\n    uv*=1.;\n    float bpm = sqrt(fract(-length(uv)+iTime*130./60.*.5));\n    //uv+=vec2(cos(iTime),sin(iTime))*.1;\n    uv*=r(iTime*.1)*+bpm;\n    uv= abs(uv)-.1;\n    float f = 1.01+(sin(iTime)*.02+0.02);//sin(iTime+texture1D(spectrum1,.1).r*100.)*2.+2.5;\n        uv = vec2(uv.x/(1.-f),uv.y/(1.-f));\n    uv = vec2( f*uv.x/ (uv.x*uv.x+uv.y*uv.y+1.),f*uv.y/ (uv.x*uv.x+uv.y*uv.y+1.));\nuv+=vec2(cos(iTime),sin(iTime))*.1;\n   uv*=r(iTime*.1);\n    float d = max(abs(fract(uv.y*10.)-.5+.2)-.015,0.);\n    d= smoothstep(0.25,0.19,d);\n    float e = max(abs(fract(uv.x*10.)-.5+.2)-.015,0.);\n    e=smoothstep(0.25,0.19,e);\n    d=d+e;\n    vec3 col = vec3(d);\n    col = col*p(length(bpm));\n    //col = texture2D(spectrum1,vec2(uv.x*.5+.75,0)).rrr*10.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 74], [75, 75, 92, 92, 151], [152, 152, 207, 207, 1041]], "test": "untested"}
{"id": "WdGBRc", "name": "rolling dice on surface", "author": "FabriceNeyret2", "description": "Roll a dice on a surface in random directions: Here is the values it prints.\n( In fact I print the visible face of the dice. bottom face = 7 - this ).\nClick for no fading.\nTuto code for compact direction vectors ( as int 0..5) and rot matrices ( = ivec3).", "tags": ["2d", "simulation", "tuto", "dices"], "likes": 14, "viewed": 440, "published": 3, "date": "1607685686", "time_retrieved": "2024-07-30T20:31:06.720947", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n // U = (U-R/2.)/24. + R/2.;                                    // zoom on current area\n    U = (U-R/2.)/24. + mix( T(1).xy, T(0).xy, float(iFrame%N)/float(N) ); // interp dice location\n    bool p =  floor(U)==T(1).xy;                                // true on current dice location\n    float v = T(U).x;                                           // local printed value\n    O-=O;\n    \n    if ( v != 0. ) {\n        float t = iMouse.z>0. ? 1.                              // click to ignore fading\n                              : exp( - .2*( iTime - T(U).w ) ); // fading with age\n        if (t<.05) return;                                      // optim: discard darkests\n        \n        O =  t*( .6 + .6 * cos( 6.3*v/6.  + vec4(0,23,21,0) )); // display color\n\n        U = fract(U)*4.-.5;                                     // --- display dots\n        vec2 I = floor(U) - 1.;\n        if (max(abs(I.x),abs(I.y)) < 2. ) {                     // I = 3x3 dot grid\n            U = fract(U)*2.-1.;                                 // U = coords in cells\n            int i = int(v), l = int( 1.+I.y*I.x );\n            if ( I.x==0. ? I.y==0. && i%2 == 1                  // dice value to grid pattern\n                         : l==2 && i > 1 || l==0 && i > 3 || l==1 && i > 5 )\n            O -= smoothstep(1.5/3., 0., length(U)-.45);         // draw one dot\n        }\n        else  if (p) O++;                                       // frame dice location\n\n\n     // U = fract(U)*vec2(2,3);                                 // --- display (packed) dots\n     // vec2 I = floor(U); U = ( fract(U)*2.-1. ) / vec2(2,3);\n     // if ( v > I.x + 2.*I.y ) O -= smoothstep(1.5/16., 0., length(U)-.2);    \n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n#define R    iResolution.xy\n#define N    20                                 // slow down factor. 0 = fastest. ", "buffer_a_code": "#define hash(p)  fract(sin( (p) * 12.9898 ) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 U ) \n{\n    U-=.5;\n    if ( iFrame < 1 ) {                                    // initialization\n        if (U==vec2(0)) O = vec4( floor(R/2.), 0,1 );      // dice location P and frame I,J\n        return;                                            // directions: X,Y,Z,-X,-Y,-Z → 0..5  K = I^J\n    }\n    \n    O = T(U);                                              // restore previous state\n    if ( iFrame % N > 0 ) return;                          // keep slow\n    \n    if (U==vec2(0)) {                                      // --- dice management\n// translate dir id to vec3 and back; apply compact rotation matrix\n#define decode(i)   ivec3( i==0?1:i==3?-1:0, i==1?1:i==4?-1:0, i==2?1:i==5?-1:0 )\n#define encode(V)   ( ( V.x!=0 ? 0 : V.y!=0 ? 1 : 2 ) +3 * int( V.x+V.y+V.z < 0 ) )\n#define apply(M,V)  ( ivec3( V[abs(M).x-1] , V[abs(M).y-1] , V[abs(M).z-1] ) * sign(M) )\n        int r = int(4.*hash(iTime));                       // random roll in direction X,-X,Y,-Y;\n        ivec3 M = r == 0 ? ivec3( 3,2,-1)                  // compact rotation matrices\n                : r == 1 ? ivec3(-3,2, 1)\n                : r == 2 ? ivec3(1, 3,-2)\n                :          ivec3(1,-3, 2);\n        O = vec4( O.x+ ( r==0 ? 1. : r==1 ? -1. : 0.),     // update position\n                  O.y+ ( r==2 ? 1. : r==3 ? -1. : 0.), \n                  encode( apply(M, decode(int(O.z)) ) ),   // update frame I,J (apply rotation)\n                  encode( apply(M, decode(int(O.w)) ) ) );   \n        return;\n    }\n    if (U==vec2(1)) { O = T(0); return; }                  // keep prev dice state\n    \n    if ( U == T(0).xy ) {                                  // --- print dice top face to new location \n        ivec2 F = ivec2( T(0).zw );\n        int f = F.x==2 ? 1 : F.x==5 ? 6                    // which face is up ?\n              : F.y==2 ? 2 : F.y==5 ? 5\n              : (F.y-F.x+6)%6 < 3 ? 4 : 3;\n        O = vec4(f, F+1, iTime);                           // x: face value. yz: for debug w: birthday\n    }\n}\n\n\n\n\n\n/*  // === old (uncomplete) approach with tables. ========================================\n        // roll the dice/  / array: how frame rotates for each roll direction X,-X,Y,-Y\n        int dir[] = int[]( 5,1,0,2,4,3,   2,1,3,5,4,0,   0,5,1,3,2,4,   0,2,4,3,5,1 );  \n        int r = int(4.*hash(iTime)),                       // random roll in direction X,-X,Y,-Y;\n            b = int(O.y>O.x);   // <><><> it's more more complicated :-( <><><>\n        O = vec4( O.x+ ( r==0 ? 1. : r==1 ? -1. : 0.),     // update position\n                  O.y+ ( r==2 ? 1. : r==3 ? -1. : 0.), \n                  dir[int(O.z)+6*(r^b)],                   // update local frame\n                  dir[int(O.w)+6*(r^b)] );\n*/", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 126, 1731]], "test": "untested"}
{"id": "WdyfDm", "name": "The Logo Of Matrix Team", "author": "Ernst", "description": "We are a team come from Seasun in China. Our team's code is Matrix, and it's our logo.", "tags": ["logo", "rainbow", "matrix", "seasun"], "likes": 5, "viewed": 540, "published": 3, "date": "1607671211", "time_retrieved": "2024-07-30T20:31:07.664425", "image_code": "// Bloom \n// Created by Ernst\n\nfloat Square(int x)\n{ \n    return float(x * x); \n}\n\nvec4 Bloom(vec2 fragCoord)\n{\n\tconst int   blurRadius    = 8;\n    const float blurVariance  = 0.1 * float(blurRadius * blurRadius);    \n    vec2        invResolution = 1.0 / iResolution.xy;\n    \n    vec4 sum = vec4(texture(iChannel0, fragCoord.xy * invResolution).rgb * 13.0, 13.0);\n   \n    for (int dx = -blurRadius; dx < blurRadius; dx += 2)\n    {\n        for (int dy = -blurRadius; dy < blurRadius; dy += 2) \n        {\n\t        vec3 src = texture(iChannel0, (fragCoord.xy + vec2(dx, dy) + 0.5) * invResolution).rgb;\n            float weight = exp2(-(Square(dx) + Square(dy)) / blurVariance);\n            sum += vec4(src, 1.0) * weight * 4.0;\n        }\n    }\n    \n    return vec4(pow(sum.rgb / sum.a, vec3(0.35)), 1.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = Bloom(fragCoord);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Draw Background : The Rain Of Numbers\n// Created by Ernst\n\nfloat SignTex(int index, vec2 uv)\n{\n    const float border = 0.2;\n \tif (uv.x >= border && uv.x <= 1.0 - border && uv.y >= border && uv.y <= 1.0 - border)\n    {\n \t\tif (index == 0)\n        {\n        \tif (abs(uv.x - 0.5) > 0.2 || abs(uv.y - 0.5) > 0.25)\n            {\n                return 1.0;\n            }\n        }\n        else if (index == 1)\n        {\n            if (abs(uv.x - 0.5) < 0.08)\n            {\n                return 1.0;\n            }\n        }\n    }\n    return 0.0;\n}\n\n\nvec4 DrawBackground(vec2 fragCoord, float randSeed, float sizeScale)\n{\n    vec4 col = vec4(0);\n    vec2 curSignSize = vec2(SIGN_WIDTH * sizeScale, SIGN_HEIGHT * sizeScale);\n    \n    vec2 curFragCoord = fragCoord;\n    vec2 originIndex = vec2(floor(curFragCoord.x / curSignSize.x), floor(curFragCoord.y / curSignSize.y));\n\n    vec2 newIndex = originIndex;\n    //Rand A Speed\n    float rand = Random(vec2(newIndex.x, randSeed), RANDOM_SEED) ;\n    curFragCoord.y += SPEED * TIME * (rand + 0.3);\n\n    //Rand Zero Or One\n    newIndex.y = floor(curFragCoord.y / (curSignSize.y));\n    float signRand = Random(vec2(newIndex.y,newIndex.x), RANDOM_SEED);\n    \n    vec2 uv = (curFragCoord - newIndex * curSignSize) / curSignSize;\n\n    //Rand The Length\n    int screenHeightCount = int(curFragCoord.y / SCREEN_HEIGHT);\n    float relativeY = curFragCoord.y - float(screenHeightCount) * SCREEN_HEIGHT;\n    float signLength = SCREEN_HEIGHT * (rand + 0.1);\n    if (relativeY < signLength)\n    {\n        float change = (1.0 - relativeY / signLength);\n        float res = SignTex(int(signRand * 10.0) % 2, uv);\n        col.g = res * change * pow((change + 0.2), 2.0);\n        if (res > 0.0)\n        {\n            float whiteColor = abs(sin(_Time.y * rand)) * pow(change, 4.0);\n            col.rb = vec2(whiteColor);\n        }\n    }\n\n    return col * float(int(originIndex.x) % 2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    //Draw Background\n    vec4 backgroundColor = DrawBackground(fragCoord, 0.0, 0.5) * 0.2;\n    backgroundColor += DrawBackground(fragCoord + vec2(SIGN_WIDTH * 0.9, 0.0), 10.0, 1.5);\n    fragColor = backgroundColor;\n}", "buffer_a_inputs": [], "buffer_b_code": "// GlitchWaveJitter For Background\n// Draw Team Name : MATRIX\n// Draw Company Name : TECH CENTER\n// Created by Ernst\n\n#define _WaveJitterSpeed 0.6\n#define _WaveJitterDuration 1.0\n#define _WaveJitterDensity 0.001\n#define _WaveJitterRGBSplit 0.0\n#define _WaveJitterFading 0.5\n#define _GlitchEllipseData vec4(0.0, 1.0, 0.0, 1.0)\n#define _IsUseGlitchEllipseData 0.0\n#define _UseShake 1.0\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 ivec2(UI0, UI1)\n#define UI3 ivec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n#define SS(a, b, x) (smoothstep(a, b, x) * smoothstep(b, a, x))\n\nfloat GetEllipseValue(vec2 uv, vec4 ellipseData)\n{\n    vec2 center = vec2(0.5f, 0.5f);\n    vec2 p2c = 2.0 * (uv - center);\n    float distance = length(p2c);\n\n    float insideValue = ellipseData.z;\n    float outsideValue = ellipseData.w;\n    float power = (distance - ellipseData.x) / (ellipseData.y - ellipseData.x);\n    return mix(insideValue, outsideValue, clamp(power, 0.0, 1.0));\n}\n\nfloat RandomNoise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\nvec3 Hash33(vec3 p)\n{\n    ivec3 q = ivec3(ivec3(p)) * UI3;\n    q = (q.x ^ q.y ^ q.z) * UI3;\n    return -1. + 2. * vec3(q) * UIF;\n}\n\nfloat Gnoise(vec3 x)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    // gradients\n    vec3 ga = Hash33(p + vec3(0., 0., 0.));\n    vec3 gb = Hash33(p + vec3(1., 0., 0.));\n    vec3 gc = Hash33(p + vec3(0., 1., 0.));\n    vec3 gd = Hash33(p + vec3(1., 1., 0.));\n    vec3 ge = Hash33(p + vec3(0., 0., 1.));\n    vec3 gf = Hash33(p + vec3(1., 0., 1.));\n    vec3 gg = Hash33(p + vec3(0., 1., 1.));\n    vec3 gh = Hash33(p + vec3(1., 1., 1.));\n\n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\n    // interpolation\n    float Gnoise = va + u.x * (vb - va) +\n        u.y * (vc - va) +\n        u.z * (ve - va) +\n        u.x * u.y * (va - vb - vc + vd) +\n        u.y * u.z * (va - vc - ve + vg) +\n        u.z * u.x * (va - vb - ve + vf) +\n        u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n\n    return 2. * Gnoise;\n}\n\nvec2 uvR;\nvec2 uvG;\nvec2 uvB;\nvec2 uvDefault;\n\nvec4 CopyScreen(vec2 uv)\n{\n    uvDefault = uvR = uvB = uvG = uv;\n    return vec4(texture(iChannel0, uv).xyz, 1.0);\n}\n\nvec4 GlitchWaveJitter(in vec4 color, in vec2 uv)\n{\n    float time = _Time.y * _WaveJitterSpeed;\n    float distortionAmount = SS(_WaveJitterDuration * 0.001, _WaveJitterDuration * 0.5, mod(time, _WaveJitterDuration));\n\n\tfloat uvy = uvDefault.y * uv.y * _WaveJitterDensity;\n    float distortion = Gnoise(vec3(0.0, uvy * 1.0, time * 500.00)) * (distortionAmount * 3.0 + 0.05);\n    distortion *= Gnoise(vec3(0.0, uvy * 2.0, time * 250.0)) * (distortionAmount * 2.0 + 0.025) * _UseShake;\n    distortion += smoothstep(0.999, 1.0, sin((uvDefault.y + time * 1.6) * 2.)) * 0.02;\n    distortion -= smoothstep(0.999, 1.0, sin((uvDefault.y + time) * 2.0)) * 0.02;\n    distortion += smoothstep(0.999, 1.0, sin((uvDefault.y + time * 1.2) * 2.)) * 0.02;\n    distortion -= smoothstep(0.999, 1.0, sin((uvDefault.y + time) * 0.8)) * 0.02;\n    \n    vec2 uvShift = vec2(distortion, 0);\n\n    uvR += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(5, _Time.x)));\n    uvG += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(7, _Time.x)));\n    uvB += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(13, _Time.x)));\n\n    vec4 colorR = vec4(texture(iChannel0, uvR).xyz, 1.0);\n    vec4 colorG = vec4(texture(iChannel0, uvG).xyz, 1.0);\n    vec4 colorB = vec4(texture(iChannel0, uvB).xyz, 1.0);\n\n    vec4 finalColor = vec4(vec3(colorR.x, colorG.y, colorB.z), 1);\n    float power = mix(_WaveJitterFading, _WaveJitterFading * GetEllipseValue(uv, _GlitchEllipseData), step(0.5, _IsUseGlitchEllipseData));\n\n    finalColor = mix(color, finalColor, power);\n\n    return finalColor;\n}\n\nvec4 DrawTeamName(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(6.0, 1.0)));\n    if (bounds)\n    {\n        vec2 printCharSize = CHAR_SIZE;\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \t//charCode = ch_m;\n            charCode = 18732593;\n            printCharSize = vec2(5.0, 5.0);\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_a;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_t;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_r;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_i;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_x;\n        }\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, printCharSize);\n    }\n    return col;\n}\n\nvec4 DrawDate(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(8.0, 1.0)));\n    if (bounds)\n    {\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \tcharCode = ch_2;\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_1;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_9;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_9;\n        }\n        else if (index == 6)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 7)\n        {\n        \tcharCode = ch_4;\n        }\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, CHAR_SIZE);\n    }\n    return col;\n}\n\nvec4 DrawCompany(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(12.0, 1.0)));\n    if (bounds)\n    {\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \tcharCode = ch_t;\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_e;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_c;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_h;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_sp;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_c;\n        }\n        else if (index == 6)\n        {\n        \tcharCode = ch_e;\n        }\n        else if (index == 7)\n        {\n        \tcharCode = ch_n;\n        }\n        else if (index == 8)\n        {\n        \tcharCode = ch_t;\n        }\n        else if (index == 9)\n        {\n        \tcharCode = ch_e;\n        }\n        else if (index == 10)\n        {\n        \tcharCode = ch_r;\n        }\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, CHAR_SIZE);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = CopyScreen(uv);\n    color = GlitchWaveJitter(color, uv);   \n    fragColor = color;\n    \n    vec4 backgroundColor = color;\n    vec4 dampingGroundcolor = backgroundColor;\n    const float size = 0.35;\n    if (uv.x < 1.0 - size)\n   \t{\n      float damping = pow(uv.x / (1.0 - size), 12.0);\n      dampingGroundcolor *= damping;\n    }\n    \n    //Draw Team Name : MATRIX\n    float charWidth = SCREEN_WIDTH / 14.0;\n    float charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    float charSplit = charWidth / 6.0;\n    vec4 teamNameColor = DrawTeamName(charWidth, charSplit, vec2(charWidth * 1.5, (SCREEN_HEIGHT - charHeight) / 2.0), fragCoord);\n    \n    //Draw Company Name : TECH CENTER\n    charWidth = SCREEN_WIDTH / 50.0;\n    charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    charSplit = charWidth / 6.0;\n    vec4 companyColor = DrawCompany(charWidth, charSplit, vec2(SCREEN_WIDTH - charWidth * (3.0 + 12.0), charHeight * 0.8), fragCoord);\n    \n    //Draw Date : 20190904\n    charWidth = SCREEN_WIDTH / 80.0;\n    charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    charSplit = charWidth / 6.0;\n    vec4 dateColor = DrawDate(charWidth, charSplit, vec2(charWidth * 4.0, charHeight * 1.0), fragCoord);\n    dateColor *= vec4(0.1, 0.2, 0.3, 1.0);\n    \n    uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = dampingGroundcolor;\n    fragColor += vec4(0.8, 0.5, 0.1, 1) * teamNameColor * 0.35 + backgroundColor * teamNameColor;\n    fragColor += companyColor;\n    fragColor += dateColor;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Common GLSL\n// Created by Ernst\n\n/* --------------------------------------------- */\n/* Control Macros */\n#define TIME (iTime + 100.0)\n#define _Time vec4((TIME / 20.0), TIME, (TIME * 2.0), (TIME * 3.0))\n\n#define PI2 6.28318530718\n#define PI 3.1416\n\n#define SCREEN_WIDTH iResolution.x\n#define SCREEN_HEIGHT iResolution.y\n#define RANDOM_SEED 10.0\n#define SPEED 200.0\n#define SIGN_WIDTH 15.0\n#define SIGN_HEIGHT (SIGN_WIDTH * 2.0)\n#define SIGN_SIZE vec2(SIGN_WIDTH, SIGN_HEIGHT)\n#define SIGN_HEIGHT_NUMBER (SCREEN_HEIGHT / SIGN_HEIGHT)\n\n#define Deg2Rad 0.01745329\n#define Rad2Deg 57.29578\n\n/* --------------------------------------------- */\n/* Common Function */\n\nfloat Random (vec2 st, float n) \n{\n \tst = floor(st * n);\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n/* --------------------------------------------- */\n/* Print Character */\n\n#define CHAR_SIZE vec2(3.0, 7.0)\n\n/*M\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆ         010    \nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \nâ–ˆâ–ˆâ–ˆ -> 111 -> 010 101 101 111 101 101 101 -> 712557\nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \n*/\n\n//Automatically generated from a sprite sheet.\nint ch_sp = 0;\nint ch_a = 712557;\nint ch_b = 1760622;\nint ch_c = 706858;\nint ch_d = 1760110;\nint ch_e = 2018607;\nint ch_f = 2018596;\nint ch_g = 706922;\nint ch_h = 1498989;\nint ch_i = 1909911;\nint ch_j = 1872746;\nint ch_k = 1498477;\nint ch_l = 1198375;\nint ch_m = 1571693;\nint ch_n = 1760109;\nint ch_o = 711530;\nint ch_p = 711972;\nint ch_q = 711675;\nint ch_r = 1760621;\nint ch_s = 2018927;\nint ch_t = 1909906;\nint ch_u = 1497963;\nint ch_v = 1497938;\nint ch_w = 1498109;\nint ch_x = 1496429;\nint ch_y = 1496210;\nint ch_z = 2004271;\nint ch_1 = 730263;\nint ch_2 = 693543;\nint ch_3 = 693354;\nint ch_4 = 1496649;\nint ch_5 = 1985614;\nint ch_6 = 707946;\nint ch_7 = 1873042;\nint ch_8 = 709994;\nint ch_9 = 710250;\nint ch_0 = 711530;\nint ch_per = 2;\nint ch_que = 693378;\nint ch_exc = 599170;\nint ch_com = 10;\nint ch_scl = 65556;\nint ch_col = 65552;\nint ch_usc = 7;\nint ch_crs = 11904;\nint ch_dsh = 3584;\nint ch_ast = 21824;\nint ch_fsl = 304292;\nint ch_bsl = 1189001;\nint ch_lpr = 346385;\nint ch_rpr = 1118804;\nint ch_lba = 862355;\nint ch_rpa = 1647254;\n\n\n//Extracts bit b from the given number.\nfloat Extract_bit(int n, ivec2 bitSize, float b)\n{\n\t//return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n    int index = int(floor(b));\n    int size = bitSize.x * bitSize.y;\n    \n    return (n & ((1 << (size - 1)) >> index)) > 0 ? 1.0 : 0.0;\n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat Sprite(int spr, vec2 uv, vec2 bitSize)\n{\n    vec2 charSize = bitSize;\n    uv = 1.0 - uv;\n\tuv *= charSize;\n    uv = floor(uv);\n   \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (charSize.x - uv.x - 1.0) + uv.y * charSize.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,charSize));\n    \n    return bounds ? Extract_bit(spr, ivec2(bitSize), bit) : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat Char(int ch, vec2 uv, vec2 bitSize)\n{\n    float px = Sprite(ch, uv, bitSize);\n    return px;\n}", "buffer_c_code": "// Distort Effect\n// Created by Ernst\n\n#define Distortion_Center vec2(0.0, 0.0);\n#define Distortion_Multiplier vec2(1.0, 1.0);\n#define Distortion_Intensity 0.3\n#define Distortion_Scale 0.4\n\nfloat rcp(float value)\n{\n    return 1.0 / value;\n}\n\nvec2 DistortUV(vec2 uv)\n{\n    float amount = 1.6 * max(abs(Distortion_Intensity * 100.0), 1.0);\n    float theta = Deg2Rad * min(160.0, amount);\n    float sigma = 2.0 * tan(theta * 0.5);\n    \n    vec2 DistCenter = 2.0 * Distortion_Center - vec2(1.0, 1.0);\n    vec2 DistAxis = Distortion_Multiplier;\n    float DistTheta = Distortion_Intensity;\n    float DistSigma = sigma;\n    float DistScale = 1.0 / Distortion_Scale;\n    float DistIntensity = Distortion_Intensity * 100.0;\n    \n    uv = (uv - 0.5) * DistScale + 0.5;\n    vec2 ruv = DistAxis * (uv - 0.5 - DistCenter);\n    float ru = length(vec2(ruv));\n\n    if (DistIntensity > 0.0)\n    {\n        float wu = ru * DistTheta;\n        ru = tan(wu) * (rcp(ru * DistSigma));\n        uv = uv + ruv * (ru - 1.0);\n    }\n    else\n    {\n        ru = rcp(ru) * DistTheta * atan(ru * DistSigma);\n        uv = uv + ruv * (ru - 1.0);\n    }\n\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvDistorted = DistortUV(uv);\n    fragColor = vec4(texture(iChannel0, uvDistorted).xyz, 1.0); \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 52, 52, 81], [83, 83, 111, 111, 806], [808, 808, 865, 865, 902]], "test": "untested"}
{"id": "wsVfzc", "name": "2D Vector Field Visualizer", "author": "oneshade", "description": "A neat way to visualize a vector field (in 2D).", "tags": ["2d", "visualization", "vector", "vectorfield"], "likes": 22, "viewed": 815, "published": 3, "date": "1607670980", "time_retrieved": "2024-07-30T20:31:08.530110", "image_code": "#define GRID_SCALE 0.1\n#define CELL_SCALE 1.0\n#define VECTOR_SCALE 0.35\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v);\n    vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m), sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\nvec2 VectorField(in vec2 p) {\n    float t = iTime * 0.6;\n    float co = cos(t), si = sin(t);\n    vec2 fragCoord = (p * iResolution.y + 0.5 * iResolution.xy) * 0.05;\n\tfloat a = 0.5 + 0.5 * sin(dot(fragCoord, vec2(si, co)) * 0.02 + t);\n\tfloat b = 0.5 + 0.5 * cos(length(fragCoord - vec2(320.0, 180.0) * (1.0 + vec2(-si, co))) * 0.03);\n\tfloat sup = a + b;\n\tfloat x = cos(3.14 * sup + t);\n\tfloat y\t= sin(3.14 * sup + t);\n    return vec2(x, y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 cell = vec4(floor(uv / GRID_SCALE / CELL_SCALE) * CELL_SCALE, mod(uv / GRID_SCALE, CELL_SCALE) - 0.5 * CELL_SCALE);\n    float unit = 2.0 / iResolution.y / GRID_SCALE;\n    float vector = sdVectorArrow(cell.zw, VectorField(cell.xy) * VECTOR_SCALE);\n    fragColor = vec4(smoothstep(unit, 0.0, vector));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 127, 127, 403], [405, 405, 450, 450, 518], [520, 520, 563, 563, 747], [749, 749, 778, 778, 1190], [1192, 1192, 1247, 1247, 1624]], "test": "untested"}
{"id": "tdVfRc", "name": "Recursive Disintegration", "author": "xdaimon", "description": "see any patterns?\nEdit 2022: Looking back at this im surprised that I coded it. Honestly I do not know exactly what this is doing any more lol. I do know that it is related to a google foobar algorithm challenge and that it has to do with group theory", "tags": ["number", "recursive", "group", "data", "theory"], "likes": 2, "viewed": 394, "published": 3, "date": "1607658166", "time_retrieved": "2024-07-30T20:31:09.568334", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 viridis(float t) {\n    const vec3 c0 = vec3(0.2777273272234177, 0.005407344544966578, 0.3340998053353061);\n    const vec3 c1 = vec3(0.1050930431085774, 1.404613529898575, 1.384590162594685);\n    const vec3 c2 = vec3(-0.3308618287255563, 0.214847559468213, 0.09509516302823659);\n    const vec3 c3 = vec3(-4.634230498983486, -5.799100973351585, -19.33244095627987);\n    const vec3 c4 = vec3(6.228269936347081, 14.17993336680509, 56.69055260068105);\n    const vec3 c5 = vec3(4.776384997670288, -13.74514537774601, -65.35303263337234);\n    const vec3 c6 = vec3(-5.435455855934631, 4.645852612178535, 26.3124352495832);\n    return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));\n}\nconst int[1186] answers = int[1186](852720818, 919285045, 885742774, 852176178, 886525426, 852712754, 852700530, 852962742, 852184244, 852712626, 852700530, 852184244, 885742770, 852176050, 852176052, 917712050, 751512756, 851135788, 750980270, 819645356, 851643572, 785042226, 785599280, 818097074, 850586412, 785042226, 818096944, 850586412, 749915182, 783485742, 934464300, 920087670, 835931507, 886525109, 852442418, 886516982, 869477746, 868949233, 885988656, 852180083, 852434225, 868682928, 835136562, 817830896, 784272433, 767224815, 786124076, 886255020, 819137844, 818096942, 852716332, 819153840, 817573042, 885214510, 818596784, 819120944, 817573042, 818596782, 785042224, 750980016, 749923372, 852151086, 802581301, 751512754, 798673714, 899312428, 849804274, 801045298, 852138793, 649252012, 647678767, 801045298, 649239337, 647678767, 749128303, 699558316, 647666086, 903572661, 917699823, 901987573, 868166836, 869744050, 819137586, 818879789, 801844533, 784801012, 802094194, 801836268, 767757491, 834612273, 801295342, 750451568, 868961069, 817839090, 851639470, 800779374, 819383149, 851111026, 768007150, 800791341, 766970737, 833538862, 750963629, 749927148, 799718125, 716352235, 698788458, 848984616, 801852780, 869427824, 818592814, 750426926, 784546805, 665525292, 866843441, 833289074, 765639535, 648481771, 816245488, 748596014, 683060202, 749124009, 664439463, 886230182, 547023666, 683338932, 649251890, 851135278, 817531694, 782960808, 749931688, 715844646, 783461156, 748873766, 681757606, 649235106, 679635242, 614083110, 886704288, 853224756, 851643700, 818097332, 917695536, 852184370, 852175924, 818080688, 818621746, 750455856, 852175924, 818604976, 750455856, 817556530, 783993776, 749923118, 852696374, 818625525, 851917995, 784272240, 869203308, 834091953, 766442608, 818617007, 784255985, 817048301, 749399087, 767212464, 699857580, 699321195, 698526376, 901458343, 784546608, 833825966, 716876716, 819358250, 834849841, 717146926, 751512108, 782953265, 832211626, 717146926, 782953004, 798657194, 715819818, 681757096, 899312166, 868961458, 869461042, 818609137, 750443504, 818613429, 767499440, 867367854, 834333746, 766700527, 750455915, 816769901, 749657006, 716622634, 749124268, 664963753, 819129510, 682552364, 700370034, 665504430, 817842600, 767478446, 732097002, 783223910, 699308904, 750410214, 715053481, 682265381, 649218469, 630356265, 580008483, 852625506, 836160437, 785067186, 799722418, 899320620, 850852978, 801045426, 852138795, 716369070, 648203055, 801045426, 716348203, 648203055, 749128431, 699558444, 647666088, 649284658, 818088884, 715852464, 581077796, 784010528, 749407272, 614624044, 717401136, 681756970, 749406242, 614624044, 681756970, 681232418, 545950244, 612509992, 851658784, 784018418, 817552428, 732875756, 785541737, 817028145, 716876588, 766704105, 716106479, 798394922, 699833067, 699062696, 747796969, 648174056, 630352102, 847386850, 850595116, 818072367, 682798058, 546466219, 733940660, 698797038, 814647788, 749402800, 614099688, 698797024, 747538924, 614099688, 597850912, 679627174, 546179363, 818859168, 648469484, 666282992, 597334572, 800536612, 733391469, 664189223, 749136865, 631405286, 716306658, 647145702, 614361760, 598075553, 562182117, 478275869, 784967389, 768502579, 683338670, 696945198, 862578980, 782162798, 698784302, 783939875, 581077928, 444221737, 698784302, 581040419, 444221737, 612255977, 529639332, 443152030, 649276210, 749914930, 647678380, 444729760, 749915284, 647678758, 444729766, 649227052, 545417254, 647677210, 444729766, 545417254, 545416474, 342493210, 441558688, 920352020, 903310710, 903306676, 886263156, 902245619, 903040373, 869481780, 886267059, 869223668, 885468339, 852438259, 852180082, 851647602, 818351217, 801049584, 884136878, 868961520, 801827824, 818609328, 750443438, 818625525, 767229102, 833805233, 834345966, 766696303, 750185579, 816761712, 749652782, 716098538, 715569835, 664963753, 852184422, 852438383, 818093300, 801315761, 802118445, 818883570, 800779313, 801320173, 801299503, 801815342, 783735792, 784255980, 749906669, 716364525, 682011433, 852650473, 835648565, 818891696, 817560498, 900914031, 817560754, 834075698, 852413421, 767220847, 733137839, 817032177, 750173100, 716094318, 749394671, 699570858, 647924265, 700140594, 850586546, 766184241, 665238376, 784272678, 749931433, 665750442, 700365873, 682281452, 732887398, 648706921, 665237931, 698009893, 596797989, 596261160, 851658785, 750455988, 818080936, 783486124, 785566634, 816507954, 750947118, 783485612, 716901038, 782944812, 716860076, 682813994, 748857770, 614623784, 647129512, 897722532, 818630002, 869461042, 818609329, 750443504, 818625717, 767499248, 867367857, 834346034, 766700527, 750455723, 816769904, 749657006, 716622826, 749124268, 664963753, 818621734, 818343212, 768011120, 733137582, 817842600, 734456624, 699067246, 817286120, 732863340, 717380074, 682023725, 715819815, 682772905, 631413159, 580016547, 751437924, 801307828, 751249962, 749927087, 882547177, 749927534, 782146479, 818309865, 733649835, 631401003, 765102958, 716593832, 614357482, 647141868, 597834148, 545663141, 801848114, 847936365, 798939952, 697473708, 767745254, 666294826, 615152482, 632204208, 580815533, 632207655, 581065440, 546728491, 646879397, 546171104, 477763492, 835409564, 835144690, 784276656, 750439406, 835873387, 834858094, 732879790, 784538155, 766438253, 815172267, 715836269, 749394410, 697465450, 681994857, 630622438, 847386914, 833023214, 801286957, 648973226, 546200042, 683076531, 665234348, 797604203, 715053678, 580020837, 648190815, 696674602, 562977316, 546716254, 611715236, 460965855, 818351386, 784260332, 733924078, 664967724, 800536612, 700369647, 631159467, 783199075, 664959722, 683276518, 614115946, 647916194, 631629989, 563239011, 478283933, 751412959, 750951346, 683076138, 663919020, 845805667, 715049836, 680684076, 750115042, 597842663, 427428006, 663640555, 580765857, 410384485, 544086054, 444692254, 341153179, 852704566, 818625653, 851917999, 784272368, 869211500, 834616369, 766966896, 818617263, 784264177, 817572589, 749923375, 767220656, 733412012, 699321195, 698526378, 819161511, 851135668, 852143152, 817040560, 785566638, 850594994, 784526380, 815983402, 716901296, 816499502, 750439338, 682814120, 748858028, 682265002, 647645608, 847391012, 850595118, 835373935, 716880940, 648190637, 733940724, 716102702, 832485998, 766180080, 664967977, 699059173, 748333613, 647924456, 631667492, 680417703, 562964772, 885468512, 750722226, 784014516, 750713906, 801590062, 818342897, 783735534, 750718123, 766962732, 784247594, 749648492, 732875689, 698780328, 681220586, 614095398, 784992419, 767478835, 750987690, 732621358, 865765802, 715578350, 764844846, 784489127, 682781482, 614091305, 730757804, 648690213, 580004263, 612788457, 529664160, 443668384, 750472372, 851647540, 750197681, 682544042, 784538918, 783752236, 682535853, 750967857, 716102251, 766708071, 665492332, 699058730, 698534182, 597068390, 613042536, 868427809, 800537004, 799734830, 682511017, 802031783, 800750445, 632204009, 700119271, 713988654, 780016039, 615160488, 696944806, 695863654, 613816675, 511854431, 879343580, 834612336, 750955373, 750697454, 648448746, 750717811, 682540010, 781879917, 765909802, 664443434, 648452964, 731015659, 630356392, 580016738, 578959525, 477751392, 818859162, 716106860, 700099568, 630893100, 800536612, 733661870, 664451560, 765914082, 631667432, 716568804, 647408039, 614623905, 614852771, 562706469, 478279965, 751412958, 750439474, 716900648, 681757100, 847399078, 681757612, 713714348, 750389668, 648694440, 512362790, 679627306, 614590754, 478275748, 544352294, 444704668, 341411356, 649276338, 783473458, 681499181, 512641570, 749919386, 681499430, 512633383, 649231149, 579762279, 664454749, 495589862, 562718758, 562193948, 393087068, 442083040, 833824021, 732895660, 731560746, 546703781, 734348959, 732584683, 529942885, 631944799, 612260138, 709728159, 512899364, 595215902, 592021342, 477460317, 374981719, 892925264, 801852722, 852675569, 818605169, 750439407, 801582196, 733678510, 850324336, 817036272, 749394798, 699591466, 782682862, 715307756, 665492264, 681216425, 579750309, 818359584, 784522476, 750971696, 716356270, 800799144, 717409007, 682023661, 783461287, 715557674, 683297192, 647936619, 681470629, 631646502, 580020452, 511842464, 751413023, 784268467, 750987689, 733149806, 865769897, 716106797, 764840814, 784489128, 716602154, 614353385, 730753772, 682506790, 580266343, 596011305, 529664224, 443668385, 801844018, 847407916, 798673711, 697211500, 750701734, 649251241, 598108960, 598121263, 546990700, 598120678, 546978397, 495860137, 595748899, 495036445, 392812192, 818631959, 818101234, 767495342, 750177261, 818834026, 817552429, 715832173, 767232490, 732617451, 781351466, 681745131, 698530152, 646601128, 614087078, 562448419, 845793246, 816245934, 784501484, 648969066, 546195945, 666033010, 631413610, 780560682, 697743916, 562715108, 597326558, 662587560, 528628066, 495585692, 543807393, 375752411, 818089236, 750439596, 716884654, 648186412, 783493156, 683322030, 614115882, 749374242, 647654056, 649193636, 580028840, 613567008, 580503586, 511846304, 410109850, 751388058, 733911985, 682813865, 647141739, 829028387, 681229099, 663378411, 716294305, 580794982, 410380388, 629291369, 546678815, 376293346, 492955491, 376522330, 239158423, 750468276, 851119091, 749931440, 682281834, 767495398, 766708651, 665492331, 716884912, 682277418, 732621094, 631405289, 648190376, 647403684, 545933731, 528091236, 851650204, 783493548, 782953516, 682248872, 784992422, 783444780, 615156392, 682813606, 680167852, 746195238, 581069350, 646080548, 644999332, 545908896, 443680412, 877749912, 817835056, 734169900, 750693294, 648444649, 733674290, 648719272, 764836396, 748600040, 647137705, 597588707, 696928617, 596007142, 528886176, 511051682, 392537948, 818597012, 682286124, 683060144, 614111788, 783493156, 716614253, 647407975, 732089249, 614361766, 682485922, 613320933, 580274719, 563726368, 511313762, 410105882, 751388057, 733400113, 716638375, 664979819, 830621798, 647936875, 696408683, 716568931, 631646759, 495315172, 645278120, 580503712, 444184609, 493221731, 376534744, 239416600, 649272242, 782945009, 681232940, 512379362, 732875866, 664455845, 495589861, 615148204, 545937446, 630367772, 461502819, 511850404, 511063450, 341952409, 357131740, 817046416, 715852204, 714779432, 546441636, 717309598, 715279018, 512895268, 614639134, 578439336, 675907358, 478808226, 544351644, 541157020, 409552538, 306807700, 891859981, 851389426, 801819631, 750701359, 648452908, 750701554, 699583468, 798661225, 749116204, 647666281, 648452899, 697199014, 596535718, 546191584, 544606243, 392800093, 784788628, 648723433, 649243504, 597592491, 749934627, 682789291, 630102247, 698264416, 613825059, 631625760, 578971684, 562694493, 495822685, 443147935, 341669655, 818996308, 734448687, 749136557, 664980077, 830622056, 682023787, 697997805, 648943845, 631663273, 495331684, 646867242, 580511778, 444201121, 527292387, 409564892, 239424792, 700123954, 781355694, 697477675, 528365924, 716090394, 614115749, 461769120, 564025899, 478292070, 562984412, 410638557, 427161507, 459932953, 291071637, 255407256, 833823372, 699595568, 749394982, 648186663, 734398755, 748849965, 614873513, 665507877, 630626601, 695605283, 563742950, 579495778, 594143072, 443918302, 408798683, 842601748, 749931564, 750913962, 682773162, 546441638, 648727216, 512920228, 746211496, 679635368, 544352420, 444746140, 610928548, 476178336, 376547352, 407995674, 221840658, 750972042, 682535974, 632195822, 563243176, 716113566, 632195370, 562194662, 680954588, 562952546, 581007070, 511064099, 511821977, 444679707, 358725019, 239678993, 751346448, 700345135, 648464809, 595749097, 793880416, 646879849, 595736809, 648378205, 495847843, 291350368, 544606246, 444679834, 240219805, 390428125, 240174164, 102810254, 750971956, 782420656, 748866344, 613583272, 749906976, 681232808, 545933860, 614631722, 546449704, 613058336, 477759776, 478275620, 443680284, 341935896, 272712982, 800268941, 665246318, 698526626, 596789859, 700295134, 697453162, 529918181, 614114976, 545413093, 626636447, 461744097, 477238684, 491353499, 308094487, 255411091, 840471243, 798673902, 716860073, 581061288, 444205349, 598121135, 563497638, 711854053, 612526374, 443680862, 495323542, 543016673, 375506778, 325154642, 339289368, 154186639, 750439558, 614632358, 581069356, 478292006, 681764122, 581060776, 477243298, 613042710, 477743262, 512820632, 409069214, 409569170, 342414484, 239158164, 120370186, 751317257, 682793902, 682027046, 596809896, 778696547, 579766888, 611461416, 614832094, 529651939, 359237534, 526243811, 444417689, 274019929, 339563802, 188793870, 51675724, 649255730, 747272685, 646347175, 443418720, 664697684, 562460833, 359512156, 478812327, 376293089, 477242325, 274294551, 291075484, 289764048, 137417804, 84972109, 749936706, 647678380, 647654176, 545393056, 649152154, 646056358, 444704800, 545416474, 443156128, 540624154, 342443674, 340894612, 338224020, 171484046, 102277514, 4291);\nconst int BLUR = 1;\nconst int TIME = 1;\nconst int row_partitions = 77;\nconst int col_partitions = 77;\nconst int num_unique_answers = 56;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    vec2 uv = vec2(row_partitions, col_partitions) * fragCoord / iResolution.xy;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    if (uv.x >= float(row_partitions) || uv.y >= float(col_partitions)) {\n        return;\n    }\n    int index = int(uv.x) * col_partitions + int(uv.y);\n    int index_compressed = index / 5;\n    int offset= (index % 5);\n    int integer = answers[index_compressed];\n    int index2 = (integer >> (6 * offset)) & 0x3f;\n    if (TIME == 1 && index2 == (int(iTime * 4.) % num_unique_answers)) {\n        fragColor.xyz = vec3(1);\n        return;\n    }\n    fragColor.xyz = viridis(pow(1.-float(index2)/60.,2.));\n    if (BLUR == 1) fragColor = mix(fragColor, texture(iChannel0, fragCoord / iResolution.xy), .98);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 189]], "test": "untested"}
{"id": "tsKfRc", "name": "Fractured Webcam", "author": "oneshade", "description": "Fracturing effect created by continually moving uvs through a vector field.", "tags": ["warp", "webcam", "fracture"], "likes": 4, "viewed": 396, "published": 3, "date": "1607657391", "time_retrieved": "2024-07-30T20:31:10.434019", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, texture(iChannel0, uv).xy);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 VectorField(in vec2 p) {\n    vec2 polar = texture(iChannel1, p).xz; polar.x *= 3.1416;\n    return 0.001 * vec2(-cos(polar.x + iTime), sin(polar.x - iTime)) * polar.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv, 1.0, 1.0);\n    if (iFrame > 0) {\n        fragColor = texture(iChannel0, uv);\n        fragColor.xy += VectorField(fragColor.xy);\n    }\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 162]], "test": "untested"}
{"id": "3dVfzc", "name": "spherical arc spline", "author": "mattz", "description": "Given two points on a sphere and two tangent vectors, construct a smooth spline (orange) out of a pair of equal-radius arcs connecting the points.\n\nHold the mouse down to show just the blue lines + orange spline. Hit S to toggle stereographic projection.", "tags": ["test", "spline", "spherical", "debug", "arc"], "likes": 25, "viewed": 510, "published": 3, "date": "1607656394", "time_retrieved": "2024-07-30T20:31:11.457283", "image_code": "//////////////////////////////////////////////////////////////////////\n//\n// spherical arc spline by mattz\n//\n// License CC BY 4.0 https://creativecommons.org/licenses/by/4.0/\n//\n// Given two points on a sphere and two tangent vectors, construct\n// a smooth spline (orange) out of a pair of equal-radius arcs\n// connecting the points.\n//\n// The orange spline touches the black points, and is tangent\n// to the green arrows.\n//\n// The maroon dots are the arc centers -- each one is an equal\n// distance to the black points.\n//\n//////////////////////////////////////////////////////////////////////\n\n// light pos\nvec3 L = vec3(-0.15, 0.3, 1);\n\nconst float PI = 3.141592653589793;\nconst float EPS = 1e-3;\n\n// animation parameters\nconst float PERIOD = 30.0; // seconds per repeat\nconst float PFREQ = 5.0;\nconst float QFREQ = 1.0;\n\n// antialiasing distance\nfloat aa = 0.01;\n\n// should we draw decorations\nbool draw_extras = true;\n\n//////////////////////////////////////////////////////////////////////\n// rotate about x-axis \n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about y-axis \n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// ray-sphere intersection\n\nconst vec4 miss = vec4(-1);\n\nvec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n//////////////////////////////////////////////////////////////////////\n// arclengh distance between unit vectors on sphere\n\nfloat sdist(vec3 a, vec3 b) {\n    return acos(clamp(dot(a, b), -1.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arrow at p0 with tangent l0 \n\nfloat darrow(vec3 p, vec3 p0, vec3 l0) {\n\n    float k = 0.125;\n    \n    vec3 q = cos(k)*p0 + sin(k)*l0;\n\n    vec3 a0 = normalize(cross(p0, l0));\n    vec3 l1 = normalize(cross(q, a0));\n\n    float d = abs(dot(p, a0));\n    d = max(d, -dot(p, l0));\n    d = max(d, -dot(p, l1));\n    \n    float dh = 1e5;\n    \n    for (float s=-1.0; s<=1.0; s+=2.0) {\n    \n        vec3 r = normalize(q + 0.035*s*a0 + 0.4*p0);\n    \n        vec3 l2 = normalize(cross(q, r));\n        vec3 l4 = normalize(cross(q, l2));\n        vec3 l5 = normalize(cross(r, l2));\n    \n        float d2 = abs(dot(p, l2));\n        d2 = max(d2, dot(p, l4));\n        d2 = max(d2, -dot(p, l5));\n        \n        dh = min(dh, d2);\n        d = max(d, -s*dot(p, l2));\n    \n    }\n    \n    d = min(d, dh);\n\n    return d;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// data structure to store spline\n\nstruct arc_spline {\n        \n    vec3 p0, l0, p1, l1, c0, c1, m, w;\n    float r;\n\n};\n\n//////////////////////////////////////////////////////////////////////\n// compute a spline on the sphere made of two arcs that are tangent \n// to each other have desired tangents at given points\n//\n// inputs:\n//\n//   p0: first point on sphere (unit vector)\n//   l0: tangent vector at p0 (unit vector with dot(p0, l0) = 0)\n//   p1: second point on sphere (unit vector) \n//   l1: tangent vector at p1 (unit vector with dot(p1, l1) = 0)\n//\n// output: an arc_spline\n\nvoid compute_spline(in vec3 p0, in vec3 l0,\n                    in vec3 p1, in vec3 l1,\n                    out arc_spline S) {\n                  \n    // fill in data members of spline that copy inputs\n    S.p0 = p0;\n    S.l0 = l0;\n    \n    S.p1 = p1;\n    S.l1 = l1;\n    \n    // compute the line connecting p0 & p1\n    vec3 tmp = normalize(cross(p0, p1));\n    \n    // special case: p0 and p1 are connected by a segment of a great circle\n    // the line from p0 to p1 hits them at the correct tangents \n    if (max(abs(dot(tmp, l0)), abs(dot(tmp, l1))) < EPS) {\n        // in this case we set S.r = 0 and set S.w to be the line\n        S.w = tmp;\n        S.r = 0.0;\n        return;\n    }\n    \n    // compute the points orthogonal to (l0, p0) and (l1, p1), respectively\n    vec3 a0 = cross(l0, p0);\n    vec3 a1 = cross(l1, p1);\n    \n    // we will construct arc centers \n    //\n    //   c0 = cos(r) * p0 + sin(r) * a0\n    //   c1 = cos(r) * p1 + sin(r) * a1\n    //\n    // which are a distance r away from p0 & p1 respectively\n    // by construction, dot(c0, l0) = dot(c1, l1) = 0\n    //\n    // now we want to solve for r such that dot(c0, c1) = cos(2*r)\n    //\n    // start by observing that \n    //\n    //   (cos(r)²       * a +\n    //    cos(r)*sin(r) * b\n    //    sin(r)²       * c) = cos(2r)\n    //\n    // where a = dot(p0, p1), b = dot(p0, a1) + dot(p1, a0), and \n    // c = dot(a0, a1).\n    //\n    // applying the half angle identities and setting θ = 2r, we find\n    //\n    //   a*(1 + cos(θ))/2 + b*sin(θ)/2 + c*(1 - cos(θ))/2 = cos(θ)\n    //   a*(1 + cos(θ)) + b*sin(θ)+ c*(1 - cos(θ)) = 2*cos(θ)\n    //   (a - c - 2)*cos(θ) + b*sin(θ) = -(a + c)\n    //\n    // we can rewrite that as\n    //\n    //   d*cos(θ) + b*sin(θ) = e\n    //\n    // where d = a - c - 2 and e = -(a + c).\n    //\n    // finally, we can rewrite that as\n    //\n    //   α*cos(θ - φ) = e\n    //\n    // where α = sqrt(d² + b²) and φ = atan(b, d).\n    // the solution is given by\n    //\n    //   θ = φ ± acos(e / α)\n    //\n    // and r = 0.5 * θ.\n    \n    float a = dot(p0, p1);\n    float b = dot(p0, a1) + dot(p1, a0);\n    float c = dot(a0, a1);\n    \n    float d = (a - c - 2.);\n    float e = -(a + c);\n    \n    float alpha = length(vec2(d, b));\n    float phi = atan(b, d); // in [-pi, pi]\n    float tau = acos(e/alpha); // in [0, pi]\n\n    // we want the r with the least magnitude so choose tau with the \n    // opposite sign as phi\n    float r = 0.5 * (phi > 0. ? phi - tau : phi + tau);\n\n    // now get c0 & c1\n    float cr = cos(r);\n    float sr = sin(r);\n\n    S.c0 = normalize(cr*p0 + sr*a0);\n    S.c1 = normalize(cr*p1 + sr*a1);\n    \n    // m is the midpoint of c0 & c1, the point\n    // of mutual tangency of the two arcs\n    S.m = normalize(S.c0 + S.c1);\n    \n    // get the line connecting c0 & c1\n    S.w = normalize(cross(S.c0, S.c1));\n    \n    // no longer need the sign of r, want it positive to compute distances later\n    S.r = abs(r);\n    \n    // choose w to point towards p0\n    if (dot(S.w, p0) < 0.) { S.w = -S.w; }\n                  \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to arc on sphere\n//\n// inputs: \n//\n//   p: query point (unit vector)\n//   c: arc center point (unit vector)\n//   r: arc radius in radians\n//   l: lower tangent (unit vector)\n//   w: upper tangent (unit vector)\n\nfloat darc(vec3 p, vec3 c, float r, vec3 l, vec3 w) {\n\n    float d = abs(sdist(p, c) - r);\n    \n    d = max(d, -dot(p, l));\n    d = max(d, -dot(p, w));\n    \n    return d;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance from point p to spline S\n\nfloat dspline(vec3 p, arc_spline S) {\n\n    if (S.r == 0.0) {\n    \n        // spline is the great circle segment connecting p0 & p1\n        return max(abs(dot(p, S.w)), -min(dot(p, S.l0), dot(p, S.l1)));\n    \n    } else {\n    \n        // spline is one or two arcs \n        \n        // ignore either arc segment if the midpoint lies at the corresponding endpoint \n        float d = 1e5;\n\n        if (dot(S.m, S.p0) < 1.0 - EPS) { d = min(d, darc(p, S.c0, S.r, S.l0,  S.w)); }\n        if (dot(S.m, S.p1) < 1.0 - EPS) { d = min(d, darc(p, S.c1, S.r, S.l1, -S.w)); }\n        \n        return d;\n                    \n    }\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// draw diagram on sphere\n\nvec3 draw(vec3 p) {\n\n    //////////////////////////////////////////////////\n    // figure out some sample points and tangents\n    \n    vec3 p0 = vec3(0, 0, 1);\n    vec3 l0 = vec3(0, 1, 0);\n    \n    float u = 2.*PI*fract(iTime/PERIOD);\n\n    vec3 p1 = normalize(vec3(0.25, 0.4, 1.0) + vec3(0.3*sin(PFREQ*u), 0.3*cos(PFREQ*u), 0));    \n    vec3 q = normalize(vec3(1, 0, 0.5) + vec3(0.2*sin(QFREQ*u + 0.3), 0.2*cos(QFREQ*u + 0.1), 0));\n    vec3 l1 = normalize(cross(q, p1));\n    \n    //////////////////////////////////////////////////\n    // compute and draw the spline\n    \n    arc_spline S;    \n    compute_spline(p0, l0, p1, l1, S);\n    \n    float bblue = 1e5;\n    float blue = min(abs(dot(p, l0)), abs(dot(p, l1)));\n    float black = min(sdist(p0, p), sdist(p1, p));\n    float green = min(darrow(p, p0, l0), darrow(p, p1, l1));  \n    float maroon = 1e5;\n    float orange = dspline(p, S);\n         \n    if (draw_extras && S.r != 0.0) {\n  \n        blue = min(blue, max(abs(dot(p, S.w)), -min(dot(p, l0), dot(p, l1))));\n        \n        maroon = min(maroon, sdist(p, S.c0));\n        maroon = min(maroon, sdist(p, S.c1));\n        black = min(black, sdist(p, S.m));\n                \n    }\n    \n    vec3 color = vec3(1);\n    \n    if (!draw_extras) {\n        green = 1e5;\n    }\n    \n    color = min(color, mix(vec3(1), vec3(0, 0.5, 1), 0.4*smoothstep(aa, 0.0, blue - 0.002)));\n    color = min(color, mix(vec3(1), vec3(0.1, 0.6, 0), smoothstep(aa, 0.0, green - 0.002)));\n    color = min(color, mix(vec3(1), vec3(1.0, 0.4, 0), smoothstep(aa, 0.0, orange - 0.008)));\n    color = min(color, mix(vec3(1), vec3(0.7, 0, 0.4), smoothstep(aa, 0.0, maroon - 0.015)));\n    color *= smoothstep(0., aa, black - 0.015);\n    \n    return color;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// raytrace to sphere and compute color & lighting\n\nvec4 shade(vec3 ro, vec3 rd) {\n    \n    // raytrace\n    vec4 res = sphere(ro, rd, vec3(0), 1.0);\n    \n    // if miss sphere, gray background\n    if (res.w < 0.) { return vec4(vec3(0.85), 1); }\n    \n    // get intersection point on sphere\n    vec3 p = res.xyz;\n\n    // render on sphere\n    vec3 color = draw(p);\n    \n    // goofy non realistic lighting\n    color *= 0.3*dot(p, L) + 0.7;\n\n    return vec4(color, 1);\n    \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// stereographic projection\n\nvec3 sphere_from_plane(vec2 q) {\n\n    float qq = dot(q, q);\n        \n    return vec3(2.*q, -1.+qq) / (1. + qq);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// pretty vanilla main handles scene transform & mouse interaction\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // distance from camera to sphere centers\n    const float cdist = 6.0;\n    \n    // center-relative fragment coordinates\n    vec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n        \n    // focal length in pixels\n    float f = 0.45/iResolution.y;\n\n    vec2 theta = vec2(-0.2, 0.15);\n    \n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        theta.x = (iMouse.y - .5*iResolution.y) * 3.5/iResolution.y; \n        theta.y = (iMouse.x - .5*iResolution.x) * -5.0/iResolution.x; \n    }\n    \n    draw_extras = (max(iMouse.z, iMouse.w) <= 0.0);\n\n    mat3 Rview = rotY(theta.y)*rotX(theta.x); \n\n    if (texture(iChannel0, vec2(83.5/256., 0.75)).x > 0.) {\n\n        vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * 1.5/ iResolution.y;\n\n        vec3 p = sphere_from_plane(uv);\n        \n        p.z = -p.z;\n\n        aa = sqrt(length(cross(dFdx(p), dFdy(p))));\n\n        p = Rview*p;\n\n        vec3 color = draw(p);\n\n        fragColor = vec4(color, 1);\n        \n    } else {\n\n         aa = 4.0 / iResolution.y;\n\n        // ray origin and direction\n        vec3 rd = normalize(vec3(f*uv, -1));\n        vec3 ro = vec3(0, 0, cdist);\n        \n        L = Rview*L;\n        fragColor = shade(Rview*ro, Rview*rd);\n\n    }        \n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.7));\n    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfzc.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[1022, 1022, 1045, 1045, 1166], [1264, 1264, 1287, 1287, 1408], [1538, 1538, 1598, 1598, 2032], [2158, 2158, 2187, 2187, 2235], [2353, 2353, 2393, 2393, 3122], [3779, 3779, 3906, 3980, 6835], [7131, 7131, 7184, 7184, 7304], [7415, 7415, 7452, 7452, 8037], [8138, 8138, 8157, 8263, 9866], [9991, 9991, 10021, 10042, 10411], [10514, 10514, 10546, 10546, 10628], [10769, 10769, 10826, 10877, 12096]], "test": "untested"}
{"id": "tdGfzc", "name": "Iterative Image Blurring", "author": "oneshade", "description": "Iteratively blurring an image Currently, you have to rewind the shader for it to work.", "tags": ["postprocessing", "blur", "iterative"], "likes": 0, "viewed": 192, "published": 3, "date": "1607649813", "time_retrieved": "2024-07-30T20:31:12.322969", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n    //bool loaded = texture(iChannel1, vec2(0.5)).a != 0.0; // Doesn't work currently.\n    if (iFrame > 0) {// && loaded) {\n        fragColor = texture(iChannel0, uv);\n        vec4 sum = vec4(0.0);\n        float amount = 0.0;\n\n        for (int i=-1; i < 2; i++) {\n            for (int j=-1; j < 2; j++) {\n                sum += texelFetch(iChannel0, ivec2(fragCoord) + ivec2(i, j), 0);\n                amount++;\n            }\n        }\n\n        fragColor = sum / amount;\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 139]], "test": "untested"}
{"id": "tdKBz3", "name": "Pour Yann ", "author": "wyatt", "description": "Collaboration with the great artist Yann Nguema", "tags": ["secretproject"], "likes": 62, "viewed": 1072, "published": 3, "date": "1607642887", "time_retrieved": "2024-07-30T20:31:13.198628", "image_code": "// Fork of \"Line Tracking Fluid\" by wyatt. https://shadertoy.com/view/tsKXzd\n// 2020-12-10 19:40:02\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    vec4 a = A(U);\n    vec4 d = D(U);\n    float l = ln(U,a.xy,a.zw);\n    Q = (.8+.2*d.xxxx)*smoothstep(0.,1.,l);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define o vec3(1,0,-1)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, vec2 U)\nfloat ln (vec2 p, vec2 a, vec2 b) {\n\treturn length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,.9));\n}\n#define norm(u) ((u)/(1e-9+length(u)))", "buffer_a_code": "void X (inout vec4 Q, vec2 U, vec2 r) {\n    vec4 n = A(U+r);\n\tif (ln(U,n.xy,n.zw)<ln(U,Q.xy,Q.zw)) Q = n;\n}\nMain {\n    Q = A(U);\n    for (int x = -2;x <=2; x++)\n    for (int y = -2;y <=2; y++)\n    X(Q,U,vec2(x,y));\n    Q.xy = mix(Q.xy,A(Q.xy).xy,.3);\n    Q.zw = mix(Q.zw,A(Q.zw).zw,.05);\n    Q.xy += D(Q.xy).xy;\n    Q.zw += D(Q.zw).xy;\n    \n    if (length(Q.xy-Q.zw) > 2.5) {\n        vec2 m = 0.5*(Q.xy+Q.zw);\n        if (length(U-Q.xy) > length(U-Q.zw)) \n        \tQ.xy = m;\n        else Q.zw = m;\n    }\n    if (iMouse.z>0.) {\n        vec4 n = B(vec2(0));\n    \tif (ln(U,n.xy,n.zw)<ln(U,Q.xy,Q.zw)) Q = n;\n    }\n    if (iFrame<1) {\n        Q = vec4(0.7*R,0.3*R);\n        vec4 a =vec4(vec2(0.3,.7)*R,vec2(.7,.3)*R);\n        if (ln(U,a.xy,a.zw)<ln(U,Q.xy,Q.zw))\n            Q = a;\n    }\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Mouse\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 p = texture(iChannel0,U/iResolution.xy);\n   \tif (iMouse.z>0.) {\n      if (p.z>0.) C =  vec4(iMouse.xy,p.xy);\n    else C =  vec4(iMouse.xy,iMouse.xy);\n   }\n    else C = vec4(-iResolution.xy,-iResolution.xy);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 T(vec2 U) {\n\tU -= .5*D(U).xy;\n\tU -= .5*D(U).xy;\n    return D(U);\n}\nMain {\n    Q = T(U);\n    vec4 \n        n = T(U+o.yx),\n        e = T(U+o.xy),\n        s = T(U+o.yz),\n        w = T(U+o.zy),\n        m = 0.25*(n+e+s+w);\n    Q.xy = m.xy-0.25*vec2(e.z-w.z,n.z-s.z);\n\tQ.z = Q.z-0.25*(n.y+e.x-s.y-w.x);\n    vec4 a = A(U);\n    float l = ln(U,a.xy,a.zw);\n    float v = smoothstep(1.,0.,l);\n    Q.z += 0.01*v;\n    Q.xy = mix(Q.xy,norm(a.xy-a.zw),.1*v);\n    Q.xy *= .99-.5*v;\n    if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.) Q.xy *= 0.;\n\tif (iFrame < 1) Q = vec4(0,0,0,0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 142, 142, 262]], "test": "untested"}
{"id": "wdVfR3", "name": "Trippy Abstraction", "author": "lambmeow", "description": "messing around with new rendering techniques. I dont really know what is on the screen but it looks pretty cool. kind of reminds me of hotline miami 2. ", "tags": ["fractal", "sdf", "abstract", "trippy"], "likes": 3, "viewed": 459, "published": 3, "date": "1607642714", "time_retrieved": "2024-07-30T20:31:14.076281", "image_code": "\n//uncomment this for more trippyness\n#define CHROMATIC_ABERRATION\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n#ifdef CHROMATIC_ABERRATION\n    fragColor = vec4(texture(iChannel0, uv + vec2(0.02, .05 * sin(iTime)) ).r, \n                     texture(iChannel0, uv + vec2(-.02, -.05) * cos(iTime) ).g,\n                     texture(iChannel0, uv + vec2(0.03, .02) * -cos(iTime)).b,\n                     1.);\n#else\n    fragColor = texture(iChannel0, uv);\n#endif\n                     \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//Abstraction\n//Made by lopea.\n//12/10/2020\n\n#define EPSILON 0.0001\n#define time iTime\n#define resolution iResolution\n\nfloat s = 1.5;\nmat3 rotate(float angle)\n{\n    float sc = sin(angle);\n    float c = cos(angle);\n    return mat3 (1.0, 0.0, 0.0, 0.0, c, sc, 0.0, -sc, c);\n}\n\n//geometry of the sdf function\nfloat map(vec3 p)\n{\n   for( int i = 0; i < 12; i ++)\n   {\n     p= abs(p) - abs(vec3((sin(time + float(i)) + cos (float(i) + p.x+ s +time))* 0.15)) - .1;\n     s += .1 ;\n   }\n   return dot(p ,normalize(vec3(2.,10., 3.))); \n}\n\n\n//coolest way to calculate a normal that i've ever seen\n//source: https://www.shadertoy.com/view/3dyBzc\n//thanks gaz\nvec3 calcnorm(vec3 value)\n{\n    vec3 n = vec3(0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec3 eps = 0.001 * (vec3(9 >> i&1, i >> 1 & 1, i & 1) * 2. - 1.);\n        n += eps * map(value + eps);\n    }\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 texCoords)\n{\n\n// ----------- setup -----------\n    //correct texture coordinates to the right aspect ratio\n    \n    vec2 uv = (2. * texCoords - resolution.xy) / resolution.y;\n    \n    //get current direction\n    vec3 dir = normalize(vec3(uv, 2));\n    \n    //get camera position\n    vec3 camPos = vec3(0, 0, -10);\n    \n// ----------- raymarching ----------- \n    float dist = 0.;\n    vec3 pos = vec3(0);\n    for(int i = 0; i < 255; i ++)\n    {\n        //rotate current entire world before calculating position\n        pos = (camPos + dir * dist) * rotate(time + s);\n        float curr = map(pos);\n        if(curr < EPSILON)\n        {\n           \n            break;\n        }\n        \n        if(dist > 100.)\n        {\n            dist = 0.;\n            break;\n        }\n        dist+= curr;\n    }\n    \n// ----------- colors / rendering -----------\n    //calculate background value\n    float backValue = dot(normalize(vec3(sin(time + uv.x),(sin(time)),cos(time)) ),dir);\n    vec3 color = vec3 (0, .4, 1. ) * backValue+ vec3(1,.1,.4) * (1.-backValue); \n                \n    //if we hit something\n    if(dist > 0. )\n    {\n        //set color based on background  value\n        color = vec3(dot(calcnorm(pos), normalize(vec3(10., 10., 14.))))* (1.-color);\n    }\n    \n    //render to screen            / gives that 'trippy' effect when rendering\n    fragColor = vec4(color , 1) + texture(iChannel0, texCoords/resolution.xy) * 0.75; //+ texture(prevFrame, inData.v_texcoord)* 0.8;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 125, 125, 535]], "test": "untested"}
{"id": "Ws3BR2", "name": "Block-centric", "author": "Plento", "description": "Trying out a concept learned in math class recently. Code is pretty ugly tho", "tags": ["2d", "mouse", "barycentric", "city"], "likes": 7, "viewed": 345, "published": 3, "date": "1607640126", "time_retrieved": "2024-07-30T20:31:14.956927", "image_code": "// Cole Peterson\n#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n\n\nfloat point(vec2 p, float r){\n \treturn ss(0.003, 0.0, length(p) - r);   \n}\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec3 drawTriangle(vec3 col, vec2 uv, vec2 A, vec2 B, vec2 C){\n    col = mix(col, vec3(1., 0., 0.), point(A.xy-uv, 0.006));\n    col = mix(col, vec3(1., 0., 0.), point(B.xy-uv, 0.006));\n    col = mix(col, vec3(1., 0., 0.), point(C.xy-uv, 0.006));\n    return col;\n}\n\n\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    uv*= 1.0;\n    \n    vec3 col = vec3(1);\n    float scl = 0.25 + (.5+.3*sin(iTime*.5))*.3;\n    \n    //vec2 A = m;\n    vec2 A = vec2(0., -.17)*scl;\n    vec2 B = vec2(-0.1, -0.25)*scl;\n    vec2 C = vec2(0.1, -0.25)*scl;\n    \n    if(iMouse.z > 0.0) A = m;\n    \n    vec3 M = vec3(uv.x, uv.y, 1.);\n    \n    vec3 A3 = vec3(A, 1.);\n    vec3 B3 = vec3(A, 1.);\n    vec3 C3 = vec3(A, 1.);\n    \n    mat3 mat = mat3(vec3(A, 1.), vec3(B, 1.), vec3(C, 1.));\n    \n    vec3 bc = inverse(mat) * M;\n    \n    \n    bc.yz *= rot(iTime*.2);\n    bc.y -= iTime*4.;\n    \n    //bc.y += cos(bc.z*3.6 + iTime*8.)*0.03;\n    //bc.z += sin(bc.y*3.6 + iTime*8.)*0.03;\n    \n   \tvec3 id = floor(bc);\n    \n    float sY = floor(mod(id.y, 2.))*2. - 1.;\n    \n   \n    id = floor(bc);\n    vec3 rbc = fract(bc-.5)-.5;\n   \n    vec2 dim = vec2(3);\n    \n   \tcol = vec3(0.03);\t\n    \n    vec2 ridBIG = floor(mod(id.zy, (2.*dim.x - 1.)*14.));\n    \n    if(ridBIG.x < 5. || ridBIG.y < 0.)\n        dim = vec2(3);\n    else\n        dim = vec2(2);\n    \n    \n    vec2 rid = mod(id.zy, 2.*dim.x - 1.);\n    \n    if(rid.x == 3.) rid.x = 0.;\n    if(rid.y == 3.) rid.y = 0.;\n    \n    \n    float chng = floor(mod((rid.x + dim.x-1.) / (dim.x + dim.x-1.), 2.));\n    \n    vec2 p = vec2(0., 0.);\n    \n    float block = min(step(dim.x, abs(rid.y-p.x)) + \n                      step(dim.y, abs(rid.x-p.y)), 1.);\n    \n    \n    bc.z += iTime * cos(id.y);\n    bc.y += iTime * cos(id.z);\n    vec3 rbc2 = fract(bc)-.5;\n    \n    float t = id.y*0.14 + id.z*0.14;\n    //vec3 c = .5+.2*cos(vec3(2.2, 3.3, 1.3) * t);\n    vec3 c = .5 + .4*cos(vec3(2.2, 3.3, 1.3)*t);\n    col = mix(c, col, block);\n    \n    \n    vec2 ra = vec2(1.-step(.5, chng), step(.5, chng));\n    float re = rbc2.z*ra.x + rbc2.y*ra.y;\n    float road = abs(dot(ra, abs(rbc.yz)-.5));\n    float stripe = (ss(.04,.0, road-.01));\n    stripe *= ss(.04, .0, abs(re)-.2);\n  \t\n    col = mix(col, vec3(1., 1., 1.), stripe*block);\n    \n    \n    \n    col *= ss(0.8, .0, length(vec2(uv.x, uv.y*1.8))-.5);\n    \n    //col += (1.-step(0.026, abs(rbc.y) - 0.01))*.4 *(.5+.5*cos(iTime));\n    //col += (1.-step(0.026, abs(rbc.z) - 0.01))*.4*(.5+.5*cos(iTime));\n    \n    vec3 rbc3 = fract((bc - vec3(0., iTime, iTime))*0.2)-.5;\n    \n    \n    if(iMouse.z > 0.0) col = drawTriangle(col, uv, A, B, C);\n    \n    f = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n\n    //f = vec4(col, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 171, 171, 216], [217, 217, 236, 236, 288], [290, 290, 351, 351, 552], [555, 555, 577, 577, 680], [682, 682, 722, 722, 3119]], "test": "untested"}
{"id": "tsKBR3", "name": "scan the area", "author": "Firepal", "description": "who doesn't love a good laser once in a while", "tags": ["2d", "sound", "glow", "laser"], "likes": 13, "viewed": 711, "published": 3, "date": "1607639005", "time_retrieved": "2024-07-30T20:31:15.897412", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float vfun = pow(abs(1.0-(uv.x+uv.y)+sin(iTime*2.0)*0.8),0.1);\n    uv += vec2(iTime*0.1,0.);\n    \n    vec3 col = mix( vec3(4.0,.0,.0), vec3(0.,0.,0.),\n    vfun );\n    col = mix( vec3(0.5), col, vfun ); \n\n    // Output to screen\n    float crust = smoothstep( vfun*0.8,vfun, texture(iChannel1,uv*2.0).g );\n    col = vec3( crust+col );\n    fragColor = vec4(col,1.0);\n    fragColor.xyz -= textureLod(iChannel0,fragCoord/8.0,0.0).r/7.;\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    float getmad = ( cos(time*4.0) * 0.5 )+0.7;\n    getmad *= 0.4;\n    float flanger = time*2.0;\n    flanger = cos(flanger)*0.0005;\n    flanger = time+flanger;\n\n    float square = sign( fract(95.9*time)-0.5 );\n    float saw = fract(square*96.*time);\n    float saw2 = fract(square*96.*flanger);\n    float mixedsaw = mix( saw, saw2, .5 );\n    return vec2( mixedsaw )*getmad;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 585]], "test": "untested"}
{"id": "3sVfRc", "name": "Shaderdoodle", "author": "oneshade", "description": "Doodling with rotation. If you watch it long enough you will see the pattern (it's symmetrical too!).", "tags": ["doodle", "rotation", "parametric"], "likes": 9, "viewed": 171, "published": 3, "date": "1607628737", "time_retrieved": "2024-07-30T20:31:16.773071", "image_code": "float line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float thickness = 3.0 / iResolution.y;\n    vec2 linkOrigin = vec2(0.0, 0.0);\n    for (int link=0; link < links.length(); link++) {\n        float currentAngle = links[link].x + links[link].y * iTime;\n        vec2 linkEnd = linkOrigin + vec2(cos(currentAngle), sin(currentAngle)) * links[link].z;\n        fragColor.rgb += smoothstep(thickness, 0.0, line(uv, linkOrigin, linkEnd));\n        linkOrigin = linkEnd;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float thickness = 2.0 / iResolution.y;\n    vec2 linkOrigin = vec2(0.0, 0.0);\n    for (int link=0; link < links.length(); link++) {\n        float currentAngle = links[link].x + links[link].y * iTime;\n        vec2 linkEnd = linkOrigin + vec2(cos(currentAngle), sin(currentAngle)) * links[link].z;\n        linkOrigin = linkEnd;\n    }\n\n    fragColor.rgb = mix(fragColor.rgb, hue2rgb(fract(0.25 * iTime)), smoothstep(thickness, 0.0, length(uv - linkOrigin) - 0.001));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iTimeDelta 0.01\n#define iTime (float(iFrame) * iTimeDelta)\n#define hue2rgb(t) clamp(abs(6.0 * fract(vec3(t, t - 1.0 / 3.0, t - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0)\n\n// Starting angle, rotation speed, and length of each link:\nconst vec3[] links = vec3[4](vec3(0.0, -0.5, 0.2),\n                             vec3(0.0,  0.5, 0.1),\n                             vec3(0.0, -0.3, 0.3),\n                             vec3(0.0,  0.5, 0.2));", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 153], [155, 155, 210, 210, 761]], "test": "untested"}
{"id": "WsKBRc", "name": "music +1053", "author": "lyurai", "description": "Ruyji Ikeda + 1", "tags": ["music"], "likes": 1, "viewed": 260, "published": 3, "date": "1607624326", "time_retrieved": "2024-07-30T20:31:17.652719", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy) / (iResolution.y);\n    float wave_y = uv.y*.5 + .5;\n    uv = mod(uv,1.);\n    uv -= .5;\n\tfloat beat = texture(iChannel0, vec2(.5,.25)).r;\n    float wave = texture(iChannel0, vec2(wave_y,.75)).r;\n    //float circle = step((0. + beat)/5.,length(uv));\n    uv.x += (wave*2. - 1.)/3.;\n    float circle = step((0. + beat)/30.,length(uv));\n    uv.x = abs(uv.x*1.9);\n    float stick = step(.90*wave, uv.x);\n\tfloat col = min(stick, circle);\n    fragColor = vec4(vec3(col), 1. );\n}", "image_inputs": [{"id": 26325, "src": "https://soundcloud.com/nikakoi-music/somethings-moving-in-my-liquid", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 574]], "test": "untested"}
{"id": "tdGBRc", "name": "3D-Sphere_Brodyaga_rus", "author": "Brodyaga_rus", "description": "Simple 3D-Sphere with light, \nTraining project", "tags": ["sphere"], "likes": 1, "viewed": 277, "published": 3, "date": "1607616029", "time_retrieved": "2024-07-30T20:31:18.525386", "image_code": "//O - начало координат\n\nvec3 B = vec3(0.0, 0.0, 5.0); \t//Точка, где находится центр экрана, через который смотрит камера\nfloat x_res = 16.0; \t\t\t//Размер экрана по горизонтали\nfloat y_res = 9.0;\t\t\t\t//Размер экрана по вертикали\n\nfloat A_r = 5.0;\nvec3 A = vec3(0, 0, 10.0);\t\t\t\t//Точка где находится центр сферы\nfloat r = 3.0;\t\t\t\t\t\t\t\t//Радиус сферы\nvec4 A_color = vec4(1.0, 0.0, 0.0, 1.0);\t//Цвет сферы\n\nfloat Light_r = 10.0;\nvec3 Light_pos = vec3(0.0, 13.0, 10.0);\t\t\t//Точка где находится точечный источник света\nvec4 Light_color = vec4(0.8, 0.8, 0.0, 1.0);\t//Цвет точечного источника\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tLight_pos = vec3(sin(iTime)*Light_r + Light_pos.x, 15.0, cos(iTime)*Light_r + Light_pos.z);\n\t//A = vec3(sin(iTime)*A_r + A.x, A.y, cos(iTime)*A_r + A.z);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 d = normalize(vec3((uv.x - 0.5 - B.x / x_res)*x_res, (uv.y - 0.5 - B.y / y_res)*y_res, B.z)); //Луч направленый из начала координат в точку на экране\n\n    vec3 s = A;\n    \n    float D = dot(d,s)*dot(d,s) - (dot(s,s)-r*r);\n\n    if(D >= 0.0)\n    {\n    \tfloat t = (dot(d, s) - sqrt(D));\n        \n        vec3 M = vec3(d.x*t, d.y*t, d.z*t);\n        \n        vec3 n = M - A;\n\t\t\n        vec3 l = Light_pos - M;\n        \n        fragColor = A_color + 0.025 * Light_color * dot(n, l);\n        \n    }\n    else\n    \tfragColor = vec4(0.7, 0.7, 0.7, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[806, 806, 861, 861, 1667]], "test": "untested"}
{"id": "wdGfRw", "name": "Reflections test1", "author": "lousisx", "description": "Reflections test for future 2d patterns", "tags": ["2d", "reflection"], "likes": 4, "viewed": 281, "published": 3, "date": "1607613390", "time_retrieved": "2024-07-30T20:31:19.385088", "image_code": "#define PI 3.1415\n#define TWO_PI 6.2831\n\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\nfloat sdLine (in vec2 p, in vec2 a, in vec2 b){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn length (pa-ba*h);\n}\nvec2 ref (vec2 p, vec2 v){   //reflection\n    return p - v * (1.*dot(p,v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tuv *= 2.;      //zoom\n    float di = 3.; //reflections number\n    vec2 v;\n    vec2 rf;\n    \n    //circle center\n    vec2 p = vec2(sin(iTime*5.),cos(iTime*4.));\n    \n    //draw circle\n    vec3 col = 1.- vec3(vec2(smoothstep(sdCircle(uv-p ,0.1),0.0,0.01)),1.); \n    \n    for(float i; i<di; i++){\n    \tv = 1.5*vec2(sin(PI/di*i),cos(PI/di*i));//vector\n        rf  = ref(p,v );\t\t\t\t\t\t//reflection\n        //draw\n        col +=1.- vec3(smoothstep(sdCircle(uv-rf,0.1),0.0,0.01));\n    \tcol += vec3(step(sdLine(uv,v ,-v ),.01));\n        \n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 75, 75, 103], [104, 104, 151, 151, 252], [253, 253, 279, 294, 330], [332, 332, 389, 389, 1017]], "test": "untested"}
{"id": "WdGfz3", "name": "Bezier Curve Implementation", "author": "brickmaker", "description": "Basic bezier curve in glsl", "tags": ["2d"], "likes": 0, "viewed": 331, "published": 3, "date": "1607585999", "time_retrieved": "2024-07-30T20:31:20.211876", "image_code": "// reference paper: http://hhoppe.com/ravg.pdf\n// distance vector to origin(0, 0)\nfloat det(vec2 a, vec2 b) { return a.x * b.y - b.x * a.y; }\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a = det(b0, b2), b = 2.0 * det(b1, b0), d = 2.0 * det(b2, b1);\n  float f = b * d - a * a;\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\n  gf = vec2(gf.y, -gf.x);\n  vec2 pp = -f * gf / dot(gf, gf);\n  vec2 d0p = b0 - pp;\n  float ap = det(d0p, d20), bp = 2.0 * det(d10, d0p);\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0, 1.0);\n  return mix(mix(b0, b1, t), mix(b1, b2, t), t);\n}\n\nfloat distToQuadraticBezierCurve(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0 - p, b1 - p, b2 - p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 A = vec2(100., 500.);\n  vec2 B = vec2(300., 100.);\n  // vec2 B = iMouse.xy;\n  vec2 C = vec2(800., 300.);\n  vec2 pos = fragCoord.xy;\n  \n  vec4 edgeColor = vec4(1., 0., 0., 1.);\n  vec4 backgroundColor = vec4(1., 1., 1., 1.);\n  float strokeWidth = 20.;\n  \n  vec2 vAB = normalize(B - A);\n  vec2 vCB = normalize(C - B);\n  if (dot((pos - A), vAB) < 0. || dot(pos - C, vCB) < 0.) {\n     fragColor = backgroundColor;\n  }\n\n\n  float dist = distToQuadraticBezierCurve(pos, A, B, C);\n  float epsilon = fwidth(dist);\n  if (dist < strokeWidth + epsilon) {\n    float inCurve =\n        1. - smoothstep(strokeWidth - epsilon, strokeWidth + epsilon, dist);\n    fragColor = mix(backgroundColor, edgeColor, inCurve);\n  } else {\n    // discard;\n    fragColor = backgroundColor;\n  }\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 82, 109, 109, 141], [143, 143, 196, 196, 643], [645, 645, 714, 714, 778], [780, 780, 835, 835, 1605]], "test": "untested"}
{"id": "3sGBR3", "name": "Pulsing Virus", "author": "oneshade", "description": "More playing with fractal noise!", "tags": ["raymarching", "fbm", "fractalnoise", "virus"], "likes": 2, "viewed": 159, "published": 3, "date": "1607573822", "time_retrieved": "2024-07-30T20:31:21.046645", "image_code": "float noise(in vec2 p) {\n    return fract(sin(p.x * 17.6452 + p.y * 565.337) * 5425.235);\n}\n\nfloat SmoothNoise(in vec2 p) {\n    vec2 luv = smoothstep(0.0, 1.0, fract(p)); // :P\n    vec2 cid = floor(p);\n\n    float bl = noise(cid);\n    float br = noise(cid + vec2(1.0, 0.0));\n    float tl = noise(cid + vec2(0.0, 1.0));\n    float tr = noise(cid + vec2(1.0, 1.0));\n\n    return mix(mix(bl, br, luv.x), mix(tl, tr, luv.x), luv.y);\n}\n\nfloat FractalNoise(in vec2 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float colorChange = 0.8 + 0.4 * sin(3.5 * iTime);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    fragColor.rg += 0.75 * (2.0 - colorChange) / 1.5 * (1.5 - length(uv)) / 1.5;\n\n    float dt = 0.0;\n    for (int iter=0; iter < 50; iter++) {\n        vec3 p = ro + rd * dt;\n\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, s, -s, c);\n\n        float h = FractalNoise(vec2(atan(p.z, p.x), atan(p.y, length(p.xz))), 10.0, 4.0);\n        float d = length(p) - 2.0 + h;\n\n        if (d < 0.001) {\n            fragColor.rgb = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0) * 2.0 * h * (1.0 + colorChange), h);\n            break;\n        }\n\n        if (dt > 10.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 91], [93, 93, 123, 123, 427], [429, 429, 494, 494, 777], [779, 779, 834, 834, 1705]], "test": "untested"}
{"id": "wdKfzK", "name": "Render Antialiased Mandelbrot", "author": "Zi7ar21", "description": "I made an epic", "tags": ["fractal", "mandelbrot", "render", "multipass"], "likes": 2, "viewed": 332, "published": 3, "date": "1607555707", "time_retrieved": "2024-07-30T20:31:21.958207", "image_code": "// ^^^ Switch Between Buffer A, B, and C ^^^\n// Buffer A is Rendering and Settings\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Spooky Nebula --- October 30th, 2020\n// Happy Halloween!\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/tsVcDt\n// Fork of \"Starry Nebula\" by Zi7ar21. https://www.shadertoy.com/view/tsGyRm\n// October 10th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- 2020-09-08 19:37:55\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- 2020-10-11\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159265\n#define iterations 2048\n#define real -1.40125\n#define imaginary 0.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    \n    // Iterate\n    vec2 z2 = vec2(0.0);\n    vec2 jitter = vec2(sin(float(iFrame%120))-0.5, cos(float(iFrame%60))-0.5)/pi;\n    vec2 c = vec2(((uv+vec2(jitter/(iResolution.xy*2.0)))/pow(10.0, 2.0))+(vec2(real, imaginary)/2.0));\n\tfor (int i=1; i<=iterations; i++){\n        z2 = vec2(z2.x*z2.x - z2.y *z2.y, 2.0 * z2.x*z2.y);\n        z2 += z2+c;\n        if(length(z2) > (sin(float(iFrame%60))/pi)+1.0) break;\n\t}\n    // Time varying pixel color\n    vec3 col = vec3(length(z2)/log(float(iterations)));\n\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n    \n    // Output to screen\n    fragColor += vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ^^^ Switch Between Buffer A, B, and C ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvec3 acesFilm(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(acesFilm(color), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1038, 1038, 1094, 1144, 1251]], "test": "untested"}
{"id": "tsVfRK", "name": "Colored Voronoi", "author": "oneshade", "description": "My second voronoi shader. Now with colors.", "tags": ["voronoi", "colored"], "likes": 3, "viewed": 179, "published": 3, "date": "1607545436", "time_retrieved": "2024-07-30T20:31:22.820901", "image_code": "vec2 GetPoint(in vec2 cell) {\n    return 0.5 + 0.5 * vec2(sin(cell.x - cell.y + iTime), sin(cell.x) * cos(cell.x + cell.y * iTime));\n}\n\nvec3 GetColor(in vec2 cell) {\n    return vec3(fract(sin(cell.x * 4647.543 + cell.y * 2435.32) * 9658.65),\n                fract(cos(cell.x * 672.7963 + cell.y * 9873.35) * 124.355),\n                fract(sin(cell.x * 9446.745 + cell.y * 772.345) * 8755.64));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 cellLocation = floor(uv);\n\n    float minDist = 1000000.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + GetPoint(curCellLocation);\n            float curDist = length(uv - curCellPoint);\n            if (curDist < minDist) {\n                color = GetColor(curCellLocation);\n                minDist = curDist;\n            }\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 134], [136, 136, 165, 165, 396], [398, 398, 453, 453, 1084]], "test": "untested"}
{"id": "3stBDf", "name": "The Shining", "author": "dean_the_coder", "description": "Attempting to combine a couple of different scenes from 'The Shining' movie (or Ready Player One, if you prefer...)\nMain goals were to keep the frame rate up (even when anti-aliased), and the code small (but readable!).\nOh - And to have fun, obv.  :)", "tags": ["3d", "raymarching", "horror", "movie", "cineshader"], "likes": 30, "viewed": 12571, "published": 3, "date": "1607544452", "time_retrieved": "2024-07-30T20:31:23.668634", "image_code": "// The Shining\n//\n// Attempting to combine a couple of different scenes from 'The Shining'\n// movie (or Ready Player One, if you prefer...)\n// Main goals were to keep the frame rate up (even when anti-aliased),\n// and the code small (but readable!).\n// Oh - And to have fun, obv.  :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat g, time,\n\t  opn; // Door open-ness\n\n#define AA  // Comment-out to improve frame rate.\n\nstruct Hit {\n\tfloat d;\n\tint id;\n};\n\n#define ax(p) vec3(abs(p.x), p.yz)\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 0)); }\n\nfloat n11(float n) {\n\tfloat flr = floor(n);\n\tn = fract(n);\n\tvec2 r = fract(sin(vec2(flr, flr + 1.) * 12.3456) * 43758.5453);\n\treturn mix(r.x, r.y, n * n * (3. - 2. * n));\n}\n\nHit minH(Hit a, Hit b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat sdHex(vec2 p, float r)\n{\n\tp = abs(p);\n\treturn -step(max(dot(p, normalize(vec2(1, 1.73))), p.x), r);\n}\n\nfloat sdSph(vec3 p, float r) { return length(p) - r; }\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max2(q.yz)), 0.);\n}\n\nfloat sdCyl(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nfloat sdCoving(vec3 p) {\n\tp.y -= .02;\n\treturn max(sdBox(p, vec3(.04, .04, 15)), .07 - length(p.xy + .042));\n}\n\nfloat sdBin(vec3 p) {\n\tp -= vec3(.82, -.8, 5.2);\n\treturn max(abs(sdCyl(p, .06, .25)) - .002, .05 - length(p.xy + vec2(.07, -.15)));\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(vec3(0, -.25, 66) - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid splat(vec2 p, out float i, out float o) {\n\ti = max(0., -sign(sdHex(p, 1.)));\n\to = max(0., sign(sdHex(p, 2.)) - sign(sdHex(p, 3.)));\n}\n\n// Carpet texture.\nvec3 carpet(vec2 p) {\n\tp.x = mod(p.x, 7.) - 3.5;\n\tp.y = mod(p.y, 10.) - 10.;\n\n\tfloat i, o, i2, o2,\n\tc = (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y)));\n\n\tp.x = abs(p.x) - 3.5;\n\n\tc += (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y + 2.)));\n\n\tvec2 op = p;\n\n\tp.y = abs(p.y + 5.) - 5.;\n\tsplat(p, i2, o2);\n\n\top.x = mod(p.x, 7.) - 3.5;\n\top.y += 3.8;\n\tsplat(op, i, o);\n\n\ti = sign(i + i2);\n\to = sign(o + o2) * (1. - c);\n\n\treturn vec3(1, .01, .01) * i +\n\t\t   vec3(1, .1, .01) * o +\n\t\t   vec3(.05, .01, .01) * (1. - i - o);\n}\n\nvec3 wood(vec3 p) {\n\treturn mix(vec3(.17, .1, .05), vec3(.08, .05, .03), vec3(n11(n31(p * vec3(1, 2, 50)) * 30.)));\n}\n\nHit sdBlood(vec3 p) {\n\tif (opn < .01)\n\t\treturn Hit(1e7, 1); // Door not open => No blood required.\n\n\tp.y += 5.4;\n\tp.z -= 12.8 - opn * 7.;\n\n\tfloat a = atan(p.y, p.z) * 40.,\n\t\t  bmp = (n21(2.02 * vec2(a - time * 4., p.x * 5.)) + n21(vec2(a - time * 8., p.x))) / 20.;\n\n\treturn Hit(\n\t\tmin(\n\t\tsdSph(p, 5.) + sin(time * 2. + p.z) * .07 - // Main blood pile (Sphere)\n\t\tsmoothstep(0., 1., max(0., cos((p.x + .5) * 4.) * .3 * (1. + p.z * .18))) // Bulge out of the door gap.\n\t\t- bmp, // Surface bumps.\n\t\tmax(length(p.xz) - mix(2.9, 10., opn), p.y - 4.4 - bmp * .6)), // Blood disc near floor.\n\t\t9); // Blood ID.\n}\n\n// Map the scene using SDF functions, minus blood.\nHit mapq(vec3 p) {\n\tHit h = Hit(-sdBox(p, vec3(.9, 1, 9.6)), 1); // Corridor.\n\n\tfloat nb, dr, el, wd, bn = sdBin(p), shf, dkwd;\n\n\tvec3 op = p;\n\tconst vec3 ws = vec3(.1, .7, .4); // Door size.\n\tp.x = abs(p.x) - .9;\n\tp.y += .96;\n\tp.z = mod(p.z - 3.5, 4.) - 2.;\n\twd = sdBox(p, vec3(.01, .04, 66.6)); // Skirting.\n\th.d = min(h.d, min(bn, sdBox(p, vec3(.05, 66.6, .08)))); // Pillars.\n\tp.y -= 1.9;\n\th.d = min(h.d, sdBox(p, vec3(1, .1, .08))); // Arches.\n\n\t// Coving.\n\tp.x += .04;\n\tp.z += .12;\n\th.d = min(h.d, min(sdCoving(p), sdCoving(p.zyx)));\n\n\t// Room doors.\n\tp = op;\n\tp.y += .3;\n\tp.z = mod(clamp(p.z, 0., 9.) + .5, 2.) - 1.;\n\th.d = max(min(h.d, wd), -sdBox(p, vec3(66.6, .7, .4))); // Doorway.\n\tp.x = abs(p.x) - 1.07;\n\tdr = sdBox(p, ws); // Door.\n\tnb = sdSph(p + vec3(.12, .04, -.28), .03); // Knob.\n\n\t// Elevator.\n\tp = op;\n\tp.y += .3;\n\tp.z -= 9.68;\n\tshf = sdBox(p - vec3(0, 0, .3), vec3(.5, .7, .5)) - .001; // Shaft.\n\tdkwd = min(sdBox(p - vec3(0, .8, 0), vec3(.7, .1, .1)),\n\t\t\t   sdBox(ax(p) - vec3(.6, 0, 0), vec3(.1, .7, .1))); // Mantle\n\tvec2 sl = vec2(opn - .09, 0);\n\tel = sdBox(p - vec3(sl, .1), ws.zyx) + n21((p.xy - sl) * 100.) * .001; // Sliding door.\n\tp.x -= .5;\n\tp.z -= .05;\n\tel = min(el, sdBox(p, ws.zyx) + n21(p.xy * 100.) * .001); // Fixed door.\n\th.d = min(max(h.d, -shf), dkwd);\n\tshf = max(abs(shf), -p.z);\n\n\t// Assign materials.\n\th.d = min(h.d, min(min(min(dr, el), nb), shf));\n\tif (abs(op.y + 1.) < .002) h.id = 2; // Carpet.\n\telse if (h.d == min(wd, dr)) h.id = 3; // Wood.\n\telse if (h.d == nb) h.id = 4; // Gold.\n\telse if (h.d == bn) h.id = 5; // Bin.\n\telse if (h.d == el) h.id = 6; // Elevator.\n\telse if (h.d == shf) h.id = 7; // Elevator shaft.\n\telse if (h.d == dkwd) h.id = 8; // Dark wood - Elevator top.\n\n\treturn h;\n}\n\n// Map the scene using SDF functions, with blood.\nHit map(vec3 p) {\n\treturn minH(mapq(p), sdBlood(p));\n}\n\n// Get normal for scene, excluding blood.\nvec3 calcN(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * mapq(p + e * .25).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Get normal for blood.\nvec3 calcNb(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdBlood(p + e * .25).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .5);\n\treturn c;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, Hit h) {\n\tvec3 n, col = vec3(1), sunDir;\n\tfloat sp = .4; // Specular.\n\n\t// Apply material properties.\n\tif (h.id == 9) {\n\t\tcol = vec3(.25, .003, .003) * .4;\n\t\tn = calcNb(p);\n\t\tsp = 1.;\n\n\t\tcol += pow(max(0., normalize(reflect(rd, n)).y), 100.) * .2;\n\t\tcol *= .2 + .8 * sdBlood(p + normalize(vec3(0, .5, 8) - p) * .08).d / .08;\n\t} else n = calcN(p);\n\n\tif (h.id == 1)\n\t\tn += (n21(p.yz * vec2(8, 18)) - .5) * .015; // Walls (with bump)\n\telse if (h.id == 2) {\n\t\t// Carpet.\n\t\tcol = carpet(p.xz * 10.);\n\t\tn += .2 * n21(mod(p.xz * 106.78, 200.)) - .25;\n        sp *= 0.1;\n\t} else if (h.id == 3)\n\t\t// Wood.\n\t\tcol = wood(p);\n\telse if (h.id == 4)\n\t\t// Gold\n\t\tcol = vec3(.5, .4, .2), sp = .8;\n\telse if (h.id == 5) {\n\t\t// Bin\n\t\tcol = vec3(.06, .03, .03);\n\t\tn += n21(p.xz * vec2(90, 180));\n\t} else if (h.id == 6)\n\t\t// Elevator.\n\t\tcol = vec3(.15, .001, .001);\n\telse if (h.id == 7)\n\t\t// Elevator shaft.\n\t\tcol = vec3(.01);\n\telse if (h.id == 8)\n\t\t// Dark wood.\n\t\tcol = wood(p * vec3(1, 20, 1)) * .05;\n\n\tfloat ao = .4 + (ao(p, n, .035) + ao(p, n, .5)) * .6, l = 0., spe = 0.;\n\n\tfor (float i = .0; i < 3.; i++) {\n\t\tl += max(0., dot(sunDir = normalize(vec3(0, .5, i * 4.) - p), n)) / (1. + dot(vec3(0, .5, i * 4.) - p, vec3(0, .5, i * 4.) - p)) * 1.5;\n\t\tspe += smoothstep(0., 1., pow(max(0., dot(rd, reflect(sunDir, n))), 90.)) * sp;\n\t}\n    \n    return col * (l * ao + spe) * vec3(2, 1.8, 1.7);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = .0; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\t// Ceiling lights.\n\t\tfor (float i = .0; i < 3.; i++) {\n\t\t\tfloat l = sdSph(p - vec3(0, 1., i * 4.), .1);\n\t\t\tg += .05 / (.01 + l * l);\n\t\t}\n\n\t\tif (h.d < .0015)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t}\n\n\t// Lighting.\n\treturn applyLighting(p, rd, h) *\n\t\texp(-d * .14) + // Fog.\n\t\tg * .004; // Glow around lights.\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\ttime = mod(iTime, 30.);\n\n\t// Camera.\n\tvec3 ro = vec3(0, -.5, .35);\n\tfloat t = min(min(min(iTime, abs(time - 3.)), abs(time - 6.)), abs(time - 30.)),\n\t\t  dim = 1. - pow(abs(cos(clamp(t, -1., 1.) * 1.57)), 10.);\n\n\tif (time < 3.) ro.z = time * .3;\n\telse if (time < 6.) ro.z = 2. + time * .3;\n\telse ro.z = mix(7., 7.8, smoothstep(-1., 3., time - 6.));\n\tif (time > 13.) ro.z -= smoothstep(13., 17., time) * 3.;\n\n\topn = smoothstep(0., 1., (time - 8.8) * .2) * .45;\n\n\tvec3 col = vec3(0);\n#ifdef AA\n\tfor (float dx = .0; dx <= 1.; dx++) {\n\t\tfor (float dy = .0; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n#endif\n\n\t\t\tcol += march(ro, getRayDir(ro, uv));\n#ifdef AA\n\t\t}\n\t}\n\tcol /= 4.;\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.45)), fc), 0.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBDf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[653, 709, 728, 728, 1015], [1017, 1017, 1036, 1036, 1062], [1064, 1064, 1084, 1084, 1236], [1238, 1238, 1262, 1262, 1301], [1303, 1303, 1323, 1323, 1347], [1349, 1349, 1379, 1379, 1456], [1458, 1458, 1488, 1488, 1512], [1514, 1514, 1543, 1543, 1627], [1629, 1629, 1668, 1668, 1770], [1772, 1772, 1796, 1796, 1881], [1883, 1883, 1904, 1904, 2016], [2018, 2018, 2052, 2052, 2196], [2198, 2198, 2244, 2244, 2336], [2338, 2357, 2378, 2378, 2883], [2885, 2885, 2904, 2904, 3002], [3004, 3004, 3025, 3025, 3608], [3610, 3661, 3679, 3679, 5402], [5404, 5454, 5471, 5471, 5508], [5510, 5552, 5572, 5572, 5777], [5779, 5804, 5825, 5825, 6033], [6035, 6063, 6098, 6098, 6130], [6218, 6218, 6250, 6250, 6365], [6367, 6367, 6411, 6411, 7777], [7779, 7779, 7809, 7823, 8225]], "test": "untested"}
{"id": "wsVBRK", "name": "Play Parching Apexperiment, fork", "author": "404Glaciergargamel", "description": "Remix of aiekick's Ray Marching Experiment 43: [url]https://www.shadertoy.com/view/lstXRl[/url]", "tags": ["ray", "experiment", "marching", "remix", "glitch", "fork", "weird", "error", "43"], "likes": 4, "viewed": 538, "published": 3, "date": "1607544162", "time_retrieved": "2024-07-30T20:31:24.549280", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nfloat dstepf = 0.1;\n\nvec4 displ(vec3 p)\n{\n    vec2 g = p.xz;\n    vec3 col =  texture(iChannel1, g+iTime*0.2).rrr;\n   \tcol = clamp(col, 0., 1.);\n    float dist = dot(col,vec3(0.1));\n    return vec4(dist,col);\n}\n\nvec4 map(vec3 p)\n{\n    vec4 disp1 = displ(p*.2);\n    vec4 disp2 = displ(p*.3);\n    float m = length(p);\n    float me = m - 5.78 + disp1.x;\n    float mi = m - 5.5 - disp1.x;\n    float mk = m - 5.5 + disp2.x;\n    float mei = max(-mi, me);\n    if (mk < mei) \n    {\n        dstepf += 0.035;\n        return vec4(mk, disp2.y*vec3(0.3,0.6,0.3));\n    }\n    dstepf += 0.015;\n    return vec4(mei, disp1.y*vec3(0.6,0.3,0.6));\n}\n\n///////////////////////////////////////////\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 2.0;\n    float t = mint;\n    for( int i=1; i<26; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 9.0*h/t );\n        t += clamp( h, 0.03, 0.20 );\n        if( h<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 2.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.04, 1., 1. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.1;\n    float sca = 2.0;\n    for( int i=1; i<6; i++ )\n    {\n        float hr = 0.02 + 0.22*float(i)/5.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 1.05;\n    }\n    return clamp( 2.0 - 4.0*occ, 0.1, 2.0 );    \n}\n\n///////////////////////////////////////////\nfloat march(vec3 ro, vec3 rd, float rmPrec, float maxd, float mapPrec)\n{\n    float s = rmPrec,so=s;\n    float d = 1.;\n    for(int i=1;i<350;i++)\n    {      \n        if (s<rmPrec||s>maxd) break;\n        s = map(ro+rd*d).x;\n        s *= (s>so?2.5:2.);so=s; // Enhanced Sphere Tracing => lgdv.cs.fau.de/get/2234 \n        d += s * mapPrec;\n    }\n    return d;\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.35;\n    float cam_a = time; // angle z\n    \n    float cam_e = 6.52;//*(sin(time*2.)*.5+.5); // elevation\n    float cam_d = 2.88; // distance to origin axis\n    \n    vec3 camUp=vec3(1,2,1);//Change camere up vector here\n  \tvec3 camView=vec3(-1,-1,-1); //Change camere view here\n  \tfloat li = 0.7; // light intensity\n    float prec = 0.00002; // ray marching precision\n    float maxd = 60.; // ray marching distance max\n    float refl_i = 0.55; // reflexion intensity\n    float refr_a = 0.8; // refraction angle\n    float refr_i = 0.9; // refraction intensity\n    float bii = 0.45; // bright init intensity\n    float marchPrecision = 0.6; // ray marching tolerance precision\n    \n    /////////////////////////////////////////////////////////\n    if ( iMouse.z>1.) cam_e = iMouse.x/iResolution.x * 20.; // mouse x axis \n    if ( iMouse.z>1.) cam_d = iMouse.y/iResolution.y * 60.; // mouse y axis \n    /////////////////////////////////////////////////////////\n    \n    vec2 s = iResolution.xy;\n    vec2 uv = (fragCoord*3.-s)/s.y;\n    \n    vec3 col = vec3(1.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = march(ro, rd, prec, maxd, marchPrecision);\n    \n    if (d<maxd)\n    {\n        vec2 e = vec2(-2., 2.)*0.006; \n    \tvec3 p = ro+rd*d;\n        vec3 n = calcNormal(p);\n        \n        b=li;\n        \n        vec3 reflRay = reflect(rd, n);\n\t\tvec3 refrRay = refract(rd, n, refr_a);\n        \n        vec3 cubeRefl = textureLod(iChannel0, reflRay,1.).rgb * refl_i;\n        vec3 cubeRefr = textureLod(iChannel0, refrRay,1.).rgb * refr_i;\n        \n        col = cubeRefl + cubeRefr + pow(b, 15.);\n        \n       \t// lighting        \n        float occ = calcAO( p, n );\n\t\tvec3  lig = normalize( vec3(-0.7, 0.8, -0.6) );\n\t\tfloat amb = clamp( 0.6+0.6*n.y, 0.1, 2.0 );\n        float dif = clamp( dot( n, lig ), 0.1, 2.0 );\n        float bac = clamp( dot( n, normalize(vec3(-lig.x,0.1,-lig.z))), 0.1, 2.0 )*clamp( 2.0-p.y,0.1,2.0);\n        float dom = smoothstep( -0.2, 0.2, reflRay.y );\n        float fre = pow( clamp(2.0+dot(n,rd),0.1,2.0), 3.0 );\n\t\tfloat spe = pow(clamp( dot( reflRay, lig ), 0.1, 2.0 ),26.0);\n        \n        dif *= softshadow( p, lig, 0.03, 3.5 );\n       \tdom *= softshadow( p, reflRay, 0.03, 3.5 );\n\n\t\tvec3 brdf = vec3(0.1);\n        brdf += 2.20*dif*vec3(2.00,1.00,0.70);\n\t\tbrdf += 2.20*spe*vec3(2.00,1.00,0.70)*dif;\n        brdf += 0.40*amb*vec3(0.60,0.80,2.00)*occ;\n        brdf += 0.50*dom*vec3(0.60,0.80,2.00)*occ;\n        brdf += 0.40*bac*vec3(0.35,0.35,0.35)*occ;\n        brdf += 0.50*fre*vec3(2.00,2.00,2.00)*occ;\n\t\tbrdf += 0.03;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.9,1.0,2.0), 2.0-exp( -0.0006*d*d ) );\n        \n       \tcol = mix(col, map(p).yzw, 0.6);\n    }\n    else\n    {\n        b+=0.2;\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n\tfragColor.rgb = col * dstepf;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVBRK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[217, 217, 237, 237, 405], [407, 407, 425, 425, 823], [825, 924, 998, 998, 1258], [1260, 1260, 1292, 1292, 1510], [1512, 1512, 1554, 1554, 1853], [1855, 1899, 1971, 1971, 2256], [2258, 2302, 2359, 2359, 5415]], "test": "untested"}
{"id": "wdVBRK", "name": "Simple Fractal Noise", "author": "oneshade", "description": "Simple fractal noise.", "tags": ["fractal", "noise", "coherentnoise"], "likes": 3, "viewed": 179, "published": 3, "date": "1607543336", "time_retrieved": "2024-07-30T20:31:25.862768", "image_code": "float noise(in vec2 p) {\n    return fract(sin(p.x * 17.6452 + p.y * 565.337) * 5425.235);\n}\n\nfloat SmoothNoise(in vec2 p) {\n    vec2 luv = smoothstep(0.0, 1.0, fract(p)); // :P\n    vec2 cid = floor(p);\n\n    float bl = noise(cid);\n    float br = noise(cid + vec2(1.0, 0.0));\n    float tl = noise(cid + vec2(0.0, 1.0));\n    float tr = noise(cid + vec2(1.0, 1.0));\n\n    return mix(mix(bl, br, luv.x), mix(tl, tr, luv.x), luv.y);\n}\n\nfloat CoherentNoise(in vec2 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    fragColor = vec4(CoherentNoise(uv + 0.1 * iTime, 6.0, 4.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 91], [93, 93, 123, 123, 427], [429, 429, 495, 495, 778], [780, 780, 835, 835, 943]], "test": "untested"}
{"id": "tdKBRK", "name": "Noise Experiment - Snowball", "author": "oneshade", "description": "Playing around with octaves of noise after watching the [url=https://www.youtube.com/watch?v=zXsWftRdsvU]Value Noise Explained[/url] by The Art Of Code.", "tags": ["raymarching", "coherentnoise", "snowball"], "likes": 2, "viewed": 155, "published": 3, "date": "1607541013", "time_retrieved": "2024-07-30T20:31:26.712496", "image_code": "float noise(in vec2 p) {\n    return fract(sin(p.x * 17.6452 + p.y * 565.337) * 5425.235);\n}\n\nfloat SmoothNoise(in vec2 p) {\n    vec2 luv = smoothstep(0.0, 1.0, fract(p)); // :P\n    vec2 cid = floor(p);\n\n    float bl = noise(cid);\n    float br = noise(cid + vec2(1.0, 0.0));\n    float tl = noise(cid + vec2(0.0, 1.0));\n    float tr = noise(cid + vec2(1.0, 1.0));\n\n    return mix(mix(bl, br, luv.x), mix(tl, tr, luv.x), luv.y);\n}\n\nfloat CoherentNoise(in vec2 p, in float scale, in float octaves) {\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += SmoothNoise(p * pow(2.0, octave) * scale) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float dt = 0.0;\n    for (int iter=0; iter < 50; iter++) {\n        vec3 p = ro + rd * dt;\n\n        float c = cos(iTime), s = sin(iTime);\n        p.xz *= mat2(c, -s, s, c);\n\n        float d = length(p) - 2.0 + 0.15 * length(vec3(CoherentNoise(p.xy, 10.0, 4.0), CoherentNoise(p.xz, 10.0, 4.0), CoherentNoise(p.yz, 10.0, 4.0)));\n        if (d < 0.001) {\n            p *= 0.25;\n            vec3 n = normalize(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n            l.xz *= mat2(c, -s, s, c);\n            fragColor.rgb += max(0.0, dot(n, l) * 0.75 * length(vec3(CoherentNoise(p.xy, 10.0, 4.0), CoherentNoise(p.xz, 10.0, 4.0), CoherentNoise(p.yz, 10.0, 4.0))));\n            break;\n        }\n\n        if (dt > 10.0) {\n            break;\n        }\n\n        dt += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 91], [93, 93, 123, 123, 427], [429, 429, 495, 495, 778], [780, 780, 835, 835, 1803]], "test": "untested"}
{"id": "3sVfzV", "name": "Line Sliders", "author": "ljdp", "description": "playing with noise.", "tags": ["noise", "random", "race"], "likes": 5, "viewed": 314, "published": 3, "date": "1607540104", "time_retrieved": "2024-07-30T20:31:27.466480", "image_code": "// convert 2D seed to 1D\n// 2 imad\nuint seed(uint x) {\n    return 19u * x;\n}\n\nuint seed(uvec2 p) {\n    return 19u * p.x + 47u * p.y + 101u;\n}\n\n// convert 3D seed to 1D\nuint seed(uvec3 p) {\n    return 19u * p.x + 47u * p.y + 101u * p.z + 131u;\n}\n\nuint seed(uvec4 p) {\n\treturn 19u * p.x + 47u * p.y + 101u * p.z + 131u * p.w + 173u;\n}\n\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\n\nfloat noise(float x)\n{\n\treturn float(pcg(uint(x*1000.0))) * (1.0/float(0xffffffffu));\n}\n\nvec2 noise(vec2 p)\n{\n\tuint x = seed(uvec3(p.xy*1000.0, iTime*1000.1));\n\tfloat v = float(pcg(x)) * (1.0/float(0xffffffffu));\n\treturn vec2(v);\n}\n\nfloat noise2( uint n ) \n{   // integer hash copied from Hugo Elias\n\tn = (n<<13U)^n;\n    n = n*(n*n*15731U+789221U)+1376312589U;\n    return float(n&uvec3(0x0fffffffU))/float(0x0fffffff);\n}\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    float k = noise2(uint(i));\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\nfloat terrain(vec2 p)\n{\n\tfloat v2 = 1.0 * bnoise(p.x*0.5);\n    v2 += 0.05 * bnoise(p.x*2.2);\n    v2 += 0.025 * bnoise(p.x*4.2);\n    v2 += 0.0125 * bnoise(p.x*8.2);\n    v2 += 0.0025 * bnoise(p.x*36.2);\n    return v2;\n}\n\nvec3 noiseLine(vec2 p, vec3 col)\n{\n\tfloat px = 1.0/iResolution.y;\n    p.x = (p.x*0.3) + 0.5;\n    return mix(col, vec3(0.0,1.0,1.0), 1.0 - smoothstep(0.0, px*2.0, abs(p.y-p.x)));\n}\n\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a rectangle at vec2 `pos` with width `width`, height `height` and\n * color `color`.\n */\nvec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {\n\tfloat t = 0.0;\n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn vec4(color, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float px = 1.0/iResolution.y;\n    vec2 p = fragCoord*px;\n    p.x += iTime*2.5;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(0.5);\n\t\n    vec2 n1 = vec2((terrain(p)+terrain(p*0.3)*2.0)*0.4, p.y);\n    vec2 n2 = vec2(terrain(p*0.1), p.y);\n    vec2 n3 = vec2(terrain(p*0.7), p.y);\n    \n    col = noiseLine(n1, col);\n    col += noiseLine(n2, vec3(1.0, 0.0, 0.0));\n    col += noiseLine(n3, vec3(1.0, 0.0, 0.0));\n    \n    vec4 r = rectangle(uv, vec2(0.4+(n1.x*-0.25), n1.x*0.3+0.514), 0.014, 0.032, vec3(1.0));\n    r += rectangle(uv, vec2(0.5+(n2.x*-0.45), n2.x*0.3+0.514), 0.05, 0.032, vec3(1.0));\n    r += rectangle(uv, vec2(0.6+(n3.x*-0.12), n3.x*0.3+0.508), 0.03, 0.018, vec3(1.0));\n    \n    fragColor = vec4(col, 1.0);\n    fragColor = mix(fragColor, r, r.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 54, 54, 76], [78, 78, 98, 98, 141], [143, 168, 188, 188, 244], [246, 246, 266, 266, 332], [334, 334, 352, 352, 498], [500, 500, 522, 522, 587], [589, 589, 609, 609, 731], [733, 733, 758, 799, 920], [922, 937, 965, 982, 1251], [1253, 1253, 1276, 1276, 1470], [1472, 1472, 1506, 1506, 1651], [1653, 1699, 1736, 1736, 1785], [1787, 1887, 1961, 1961, 2154], [2156, 2156, 2213, 2263, 3131]], "test": "untested"}
{"id": "WdVfRV", "name": "Volumetric Mandelbrot Thing", "author": "Zi7ar21", "description": "The equation should be z = z^n + c where n is the 3rd axis. Thanks to Michael0884 and others on the Marble Marcher Discord!", "tags": ["procedural", "fractal", "raymarch", "dither", "volumetric", "raymarcher", "mandebrot"], "likes": 3, "viewed": 435, "published": 3, "date": "1607538262", "time_retrieved": "2024-07-30T20:31:28.447857", "image_code": "// Fork of \"Better Volumetric Dithering\" by Zi7ar21. https://shadertoy.com/view/wt2fDD\n// 2020-12-09 17:47:14\n\n// ^^^ Everthing is up here in Buffer A ^^^\n// It is seperate so you can press the button on the bottom of the editor to export a 32-Bit Float OpenEXR!\n\n// Zi7ar21's Adaptive Step Volumetric Raymarcher --- September 1st, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttfBDN\n// Fork of \"My Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDN [August 2nd 2020 00:53:15]\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ##### COMMON VALUES #####\n\n// Oof ugly mess below watch out lol\n\n// ##### Fractal #####\n\nfloat fractal(vec3 pos){\n    // Iterate\n    vec2 z2 = vec2(0.0);\n    vec2 c = vec2(pos.xy*2.0);\n\tfor (int i=1; i<=iterations; i++){\n        z2 = vec2(z2.x*z2.x - z2.y *z2.y, tan((clamp(pos.z*4.0, -pi/2.0, pi/2.0))) * z2.x*z2.y);\n        z2 += z2+c;\n\t}\n    // Compute Density\n    float escape = clamp((-(log(length(z2))/float(iterations)))-pow(pos.z, 2.0), 0.0, 1.0);\n    return escape;\n}\n\n// ##### RAYMARCHING #####\nvec3 directLight(vec3 raypos){\n    vec3 LightColor = vec3(1.0);\n    vec3 LightDirection = normalize(vec3(-1.0, -1.0, 1.0));\n    float distorigin = 0.0;\n    vec3 density = vec3(0.0);\n    vec3 raydirmod = LightDirection*STEP_SIZE*rand();\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<64; i++){\n        raypos = raypos+raydirmod;\n        density = vec3(fractal(raypos)*DENSITY);\n        vec3 absorbance = exp(-density);\n        attenuation *= absorbance;\n    }\n    return LightColor*attenuation;\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    //vec3 densityadd = vec3(0.0);\n    //vec3 density = vec3(0.0);\n    vec3 raypos = camerapos;\n    vec3 raydirmod = raydir*rand()*STEP_SIZE*2.0;\n    vec3 outCol = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos + raydirmod;\n        // LoicVDB: don't use this, the density doesn't accumulate, its\n        // only purpose is to compute absorbance and transmittance\n        //densityadd = vec3(fractal(raypos)*DENSITY);\n        //density = vec3(density+densityadd);\n\n        // LoicVDB: just use this for density instead:\n        vec3 density = vec3(fractal(raypos)*DENSITY);\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        vec3 transmittance = 1.0-absorbance;\n        vec3 directlighting = attenuation*transmittance;\n        if((density.r+density.g+density.b) > 0.0){\n            directlighting = directlighting*directLight(raypos);\n        }\n        outCol += directlighting;\n        attenuation *= absorbance;\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return outCol;//*attenuation;\n}\n\n// ##### RENDERING #####\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n\n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\n    // Start RNG\n    INIT_RNG;\n    #ifdef ROTATION_MATRIX\n        // Camera Orientation\n        vec3 camerapos = vec3(1.0, -1.0, 1.0);\n\t    // Dumb rotation matrix hecking Michael made me make\n\t    float xrot = atan(sqrt(2.0));\n\t    float yrot = pi;\n\t    float zrot = -pi/4.0;\n\t    // Camera Orientation (Cursed)\n        mat3 dir;\n\t    dir[0] = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\t    dir[1] = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\t    dir[2] = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        // Camera Orientation\n        vec3 camerapos = vec3(0.0,0.0,-1.0);\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,1.0,0.0);\n        vec3 zdir = vec3(0.0,0.0,1.0);\n    #endif\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n    #ifdef ROTATION_MATRIX\n    \tvec3 raydir = normalize(FOV*(uv.x*dir[0]+uv.y*dir[1])+dir[2]);\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n    #endif\n\n    // Raymarch\n\tvec3 raymarched = raymarch(camerapos, raydir, fragCoord);\n\n    // Output to Screen\n    fragColor += vec4(pow(raymarched, vec3(1.0/2.2)), 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Settings and Global Functions\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 32\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 6.0\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.125\n\n// Camera's FOV\n#define FOV 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n#define ROTATION_MATRIX\n\n// Density of the volume. Changes how much light it scatters.\n#define DENSITY 32.0\n\n// Mandelbrot Set Iterations, more means more detail.\n#define iterations 32\n\n// Tiles, more means easier on the Hardware\n#define TILES 4 // Set to 1 if you have a computer that can handle it so it will render faster\n// So kindly made by LoicVDB uwu\n\n// Yummy, Pi! 32-Bit Floating Point Precision limits us to 3.14159265, but hey one day Shadertoy\n// may support double precision so why not throw in 3589793.\n#define pi 3.141592653589793\n\n// High-Quality Noise from https://www.shadertoy.com/view/tdGfWc\nuint ns;\n#define INIT_RNG ns = uint(iFrame*24676)+uint(fragCoord.x*5557.0)+uint(fragCoord.y*8482.0);\nvoid RNGupdate(){\n    // Integer hash copied from Hugo Elias\n\tns = (ns<<13U)^ns;\n    ns = ns*(ns*ns*15731U+789221U)+1376312589U;\n}\nfloat rand(){\n    RNGupdate();\n    return float((ns*ns)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}", "buffer_b_code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[911, 911, 968, 1018, 1125]], "test": "untested"}
{"id": "WsKfzK", "name": "Conscious Flower", "author": "andrinr", "description": "The flower is currently living its midlife crisis. ", "tags": ["raytracing", "sphere"], "likes": 5, "viewed": 355, "published": 3, "date": "1607537586", "time_retrieved": "2024-07-30T20:31:29.255696", "image_code": "/////////////////////////////////////////////////////////////\n\n// Constants\n\nfloat planetSize = 0.04;\nvec3 planetCenter = vec3(0,0,-0.06);\n\n\n/////////////////////////////////////////////////////////////\n\n\nfloat map(vec3 p){\n    //sphere\n    vec3 q = p + planetCenter;\n    \n    // Map cartesian to spherical coordinate system\n    // https://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates\n    float r = length(q);\n    float a = atan(q.y/q.x) + iTime*0.4*p.z;\n    float b = atan(length(q.xy)/q.z)*0.15 + iTime*0.1;\n    \n    float d = texture(iChannel0,vec2(a,b)*2./3.141).x;\n    return length(q) - planetSize + 0.01*d; \n} \n\n\n// Raytracer\nfloat trace(vec3 origin, vec3 ray){ \n    float t = 0.; \n    for (int i = 0; i < 64; ++i){ \t\n        vec3 p = origin + ray * t; \n        float d = map(p);\n        t += d*0.3; \n    } return t; \n} \n\nvec3 normal(vec3 p){\n\treturn vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    // Normalized pixel coordinates (from 0 to 1) \n    vec2 uv = fragCoord/iResolution.xy; \n    uv = uv * 2.0 - 1.0; \n    uv.x *= iResolution.x / iResolution.y; \n    \n    // Start raytracer\n    vec3 ray = normalize(vec3(uv, 1.0)); \n    float rotSpeed = 0.4;\n    vec3 origin = vec3(0,0,0); \n    float t = trace(origin, ray); \n    \n    vec3 surface = origin + ray * t;\n    \n    \n    // Calculate fog\n    float fog = 1.0 / (1.0 + t*t*400.); \n    vec3 fc = vec3(fog); \n    // Output to screen \n    fragColor = vec4(fc,1.0); \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 223, 236, 643], [647, 660, 695, 695, 853], [856, 856, 876, 876, 896], [898, 898, 955, 1007, 1479]], "test": "untested"}
{"id": "3sKfRV", "name": "////te", "author": "lyurai", "description": "Ryoji Ikeda", "tags": ["music"], "likes": 0, "viewed": 263, "published": 3, "date": "1607535430", "time_retrieved": "2024-07-30T20:31:30.013669", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy) / (iResolution.y);\n    float wave_y = uv.y*.5 + .5;\n    uv = mod(uv,1.);\n    uv -= .5;\n\tfloat beat = texture(iChannel0, vec2(.5,.25)).r;\n    float wave = texture(iChannel0, vec2(wave_y,.75)).r;\n    //float circle = step((0. + beat)/5.,length(uv));\n    uv.x += (wave*2. - 1.)/3.;\n    float circle = step((.3 + beat)/3.,length(uv));\n    uv.x = abs(uv.x/.5);\n    float stick = step(.08*wave, uv.x);\n\tfloat col = min(stick, circle);\n    fragColor = vec4(vec3(col), 1.);\n}", "image_inputs": [{"id": 24870, "src": "https://soundcloud.com/noton-info/mika-vainio-ryoji-ikeda-alva-noto-movement-4", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 571]], "test": "untested"}
{"id": "WdKBRV", "name": "test/", "author": "lyurai", "description": "Ryuji Ikeda", "tags": ["music"], "likes": 0, "viewed": 261, "published": 3, "date": "1607532267", "time_retrieved": "2024-07-30T20:31:30.921243", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy) / (iResolution.y);\n    \n\t//vec2 uv = (gl_FragCoord.xy*2. - resolution) / resolution;\n\t\tfloat beat = texture(iChannel0, vec2(.5,.25)).x;\n        float col = step((0. + beat)/5.,length(uv));\n    fragColor = vec4(vec3(col), 1.);\n}", "image_inputs": [{"id": 24859, "src": "https://soundcloud.com/noton-info/mika-vainio-ryoji-ikeda-alva-noto-movement-2", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 331]], "test": "untested"}
{"id": "3dKfRK", "name": "Sphere Intrusion Variant", "author": "andrinr", "description": "This shader is the result of an accident. I wanted to make a displacement map for the sphere, but I'm ok with this.", "tags": ["planet"], "likes": 3, "viewed": 328, "published": 3, "date": "1607529180", "time_retrieved": "2024-07-30T20:31:31.683205", "image_code": "/////////////////////////////////////////////////////////////\n\n// Constants\n\nfloat planetSize = 0.04;\nvec3 planetCenter = vec3(0,0,-0.06);\n\n\n/////////////////////////////////////////////////////////////\n\n\nfloat map(vec3 p){\n    //sphere\n    vec3 q = p + planetCenter;\n    \n    // Map cartesian to spherical coordinate system\n    // https://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates\n    float r = length(q);\n    float a = atan(q.y/q.x) + iTime*0.03*p.z;\n    float b = atan(length(q.xy)/q.z) + iTime*0.1;\n    \n    float d = texture(iChannel0,vec2(a,b)/3.141).x;\n    return length(q) - planetSize + 0.02*d; \n} \n\n\n// Raytracer\nfloat trace(vec3 origin, vec3 ray){ \n    float t = 0.; \n    for (int i = 0; i < 64; ++i){ \t\n        vec3 p = origin + ray * t; \n        float d = map(p);\n        t += d*0.4; \n    } return t; \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    // Normalized pixel coordinates (from 0 to 1) \n    vec2 uv = fragCoord/iResolution.xy; \n    uv = uv * 2.0 - 1.0; \n    uv.x *= iResolution.x / iResolution.y; \n    \n    // Start raytracer\n    vec3 ray = normalize(vec3(uv, 1.0)); \n    float rotSpeed = 0.4;\n    vec3 origin = vec3(0,0,0); \n    float t = trace(origin, ray); \n    \n    vec3 surface = origin + ray * t;\n    \n    \n    // Calculate fog\n    float fog = 1.0 / (1.0 + t*t*400.); \n    vec3 fc = vec3(fog); \n    // Output to screen \n    fragColor = vec4(fc,1.0); \n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 223, 236, 636], [640, 653, 688, 688, 846], [849, 849, 906, 958, 1430]], "test": "untested"}
{"id": "tsKBzG", "name": "Pulsating Cubes", "author": "andrinr", "description": "Basic raytracer", "tags": ["raytracer"], "likes": 2, "viewed": 294, "published": 3, "date": "1607525445", "time_retrieved": "2024-07-30T20:31:32.528944", "image_code": "float map(vec3 p){\n    vec3 q = fract(p) * 2.0 - 1.; \n    \n    //sphere\n    //return length(q)*0.6 - 0.05; \n    \n    //box \n    q = abs(q);\n    return max(q.x, max( (sin(3.*iTime+p.z*0.4+p.y*0.8+p.x*0.55)*0.3 + 0.5) *q.y,q.z)) - 0.1;\n} \n\nfloat trace(vec3 origin, vec3 ray){ \n    float t = 0.; \n    for (int i = 0; i < 64; ++i){ \n        vec3 p = origin + ray * t; \n        float d = map(p);\n        t += d*0.5; \n    } return t; \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    // Normalized pixel coordinates (from 0 to 1) \n    vec2 uv = fragCoord/iResolution.xy; \n    uv = uv * 2.0 - 1.0; \n    uv.x *= iResolution.x / iResolution.y; \n    \n    // Start raytracer\n    vec3 ray = normalize(vec3(uv, 1.0)); \n    vec3 origin = vec3(0.0, 0.0, iTime); \n    float t = trace(origin, ray); \n    \n    \n    // Calculate fog\n    float fog = 1.0 / (1.0 + t*t* 0.1); \n    vec3 fc = vec3(fog); \n    // Output to screen \n    fragColor = vec4(fc,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 235], [238, 238, 273, 273, 430], [433, 433, 490, 542, 956]], "test": "untested"}
{"id": "tsGfzV", "name": "Wobbly Blob 2", "author": "dr2", "description": "Essentially a 3D version of \"Quick Slime\" - metaballs based on colliding spheres, with added reflection, transparency, etc.", "tags": ["reflection", "transparency", "collision", "metaball", "dynamics"], "likes": 8, "viewed": 387, "published": 3, "date": "1607519461", "time_retrieved": "2024-07-30T20:31:33.582128", "image_code": "// \"Wobbly Blob 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nmat3 StdVuMat (float el, float az);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nBall = 27;\n\nvec3 ltPos, sunDir, qHit;\nfloat tCur, dstFar, bCylRad, bCylHt, szFac, rLay;\nbool exVu, transVu;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat ObjDf (vec3 p)\n{\n  vec4 s;\n  float dMin, d;\n  p.y -= bCylHt;\n  dMin = dstFar;\n  p /= szFac;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    s = Loadv4 (2 * n);\n    dMin = SmoothMin (PrSphDf (p - s.xyz, 0.5 * s.w - rLay), dMin, 1.);\n  }\n  return dMin * szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s, vn;\n  float d, a, b, w, srdy;\n  d = dstFar;\n  vn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = (- b + sqrt (w)) / a;\n      s = ro + d * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vn.xz = - s.xz / bCylRad;\n    else {\n      d = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vn.y = - srdy;\n    }\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 InBgCol (vec3 ro, vec3 rd)\n{\n  vec4 vc, db4;\n  vec3 ltDir, vn, col, rg, vnCyl;\n  vec2 qw, wSize;\n  float dCyl, hy, y, b, a, f, ga, ltDist, sh;\n  bool isLit;\n  isLit = true;\n  db4 = InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  dCyl = db4.x;\n  vnCyl = db4.yzw;\n  ro += dCyl * rd;\n  if (vnCyl.y == 0.) {\n    vn = vnCyl;\n    hy = mod (ro.y / bCylHt + 0.5, 1.) - 0.5;\n    a = atan (vn.x, - vn.z) / pi;\n    wSize = vec2 (0.28, 0.33);\n    qw = abs (vec2 (mod (32. * 0.5 * (1. + a) + 0.5, 1.), abs (hy)) - 0.5) - 0.5 * wSize;\n    if (Maxv2 (abs (qw) - wSize * vec2 (0.43, 0.47)) < 0.) {\n      col = vec3 (0.4, 0.3, 0.1);\n      isLit = false;\n    } else {\n      col = vec3 (0.4, 0.4, 0.4);\n      if (Maxv2 (qw - 0.5 * wSize) > 0.) {\n        y = abs (abs (hy) - 0.5) - 0.5;\n        if (y > - 0.3/16.) {\n          col = vec3 (0.7, 0.6, 0.5);\n          vn.xz = Rot2D (vn.xz, - pi * a);\n          vn.yz = Rot2D (vn.yz, 0.15 * pi * (1. - 2. * SmoothBump (0.15, 0.25, 0.05,\n             16. * (0.5 - y))) * sign (hy));\n          vn.xz = Rot2D (vn.xz, pi * a);\n        } else {\n          col = vec3 (0.75, 0.7, 0.7);\n          qw = 8. * vec2 (12. * a, 2. * hy);\n          rg = ShStagGrid (qw);\n          col *= rg.y * (1. - 0.2 * Noisefv2 (32. * qw));\n          rg.xz *= sign ((abs (vn.x) > abs (vn.z)) ? vn.x : vn.z);\n          if (abs (vn.x) > abs (vn.z)) {\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        }\n      }\n    }\n  } else if (vnCyl.y > 0.) {\n    vc = HexVor (0.7 * ro.zx);\n    b = 1. - smoothstep (-0.2, -0.05, rd.y) * smoothstep (0.4, 0.8, dCyl / (1.6 * bCylRad));\n    vn = mix (vec3 (0., 1., 0.), normalize (vec3 (- vc.y, 4., - vc.z)),\n       b * SmoothBump (0.05, 0.13, 0.02, vc.x));\n    col = vec3 (0.65, 0.62, 0.6) * (0.7 + 0.3 * b * step (0.06 + 0.03 * vc.w, vc.x) *\n       (1. - 0.3 * Noisefv2 (16. * ro.xz)));\n  } else {\n    f = 0.;\n    qw = ro.xz / bCylRad;\n    ga = 2.39996;\n    for (float n = float (VAR_ZERO); n < 128.; n ++) f += 1. - smoothstep (0.02, 0.025,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col = mix (vec3 (0., 0.2, 0.), vec3 (1., 0.8, 0.6), f);\n    isLit = false;\n  }\n  if (isLit) {\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    sh = (vnCyl.y > -0.5) ? ObjSShadow (ro, ltDir, ltDist) : 1.;\n    col *= 0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.);\n  }\n  return col;\n}\n\nvec3 ExBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, clCol;\n  vec2 q;\n  float dstGrnd, f, fd, ff, sd, sh;\n  if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    f = 1. - smoothstep (0.6, 0.9, dstGrnd / dstFar);\n    if (f > 0.) vn = VaryNf (2. * ro, vn, f);\n    sh = (dstGrnd < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir, dstFar) : 1.;\n    col = mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5), 0.1 +\n       0.5 * smoothstep (0.3, 0.5, Fbm2 (ro.xz)));\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n    col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  } else if (rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n    sd = max (dot (rd, sunDir), 0.);\n    col += vec3 (1., 1., 0.9) * (0.3 * pow (sd, 512.) + 0.1 * pow (sd, 1024.));\n  }\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  return exVu ? ExBgCol (ro, rd) : InBgCol (ro, rd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colB, vn, rdd, p, ltDir;\n  float dstObj, dstTrObj, ltDist;\n  HexVorInit ();\n  szFac = 2.6;\n  rLay = transVu ? 0.2 : 0.;\n  dstObj = ObjRay (ro, rd);\n  if (transVu) {\n    if (dstObj < dstFar) {\n      p = ro + dstObj * rd;\n      vn = ObjNf (p);\n      rdd = reflect (rd, vn);\n    } else {\n      p = ro;\n      rdd = rd;\n    }\n    col = BgCol (p, rdd);\n    if (dstObj < dstFar) col *= 0.9; \n    rLay = 0.;\n    dstTrObj = ObjRay (ro, rd);\n    if (dstTrObj < min (dstObj, dstFar)) {\n      p = ro + dstTrObj * rd;\n      vn = ObjNf (p);\n      col = mix (col, 0.9 * BgCol (p, reflect (rd, vn)), 0.5);\n    }\n  } else {\n    if (dstObj < dstFar) {\n      p = ro + dstObj * rd;\n      vn = ObjNf (p);\n      if (exVu) {\n        ltDir = sunDir;\n        ltDist = dstFar;\n      } else {\n        ltDir = ltPos - p;\n        ltDist = length (ltDir);\n        ltDir /= ltDist;\n      }\n      colB = vec3 (0.95, 1., 0.95) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n      rdd = reflect (rd, vn);\n    } else {\n      p = ro;\n      rdd = rd;\n    }\n    col = BgCol (p, rdd);\n    if (dstObj < dstFar) col = mix (colB, col, 0.9);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = 0.;\n  az = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.3 * pi * mPtr.y;\n  } else {\n    t = 32. * mod (0.005 * tCur, 2.);\n    az = 2.5 * pi * (0.5 - abs ((floor (t) + smoothstep (0.9, 1., mod (t, 1.))) / 32. - 1.));\n  }\n  el = clamp (el, -0.2 * pi, 0.2 * pi);\n  vuMat = StdVuMat (el, az);\n  t = mod (0.2 * tCur, 4.);\n  t = floor (mod (t + step (0.5, smoothstep (0.4, 0.6, mod (t, 1.)) +\n     sign (mod (t, 2.) - 1.) * 0.5 * (uv.x / (canvas.x / canvas.y))), 4.));\n  transVu = (t >= 2.);\n  exVu = (abs (t - 1.) == 1.);\n  bCylRad = 32.;\n  bCylHt = 12.;\n  ro = vuMat * vec3 (0., 0., -0.95 * bCylRad);\n  ro.y += bCylHt;\n  zmFac = 3.5;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltPos = vec3 (0., 1.5 * bCylHt, 0.9 * bCylRad);\n  ltPos.xz = Rot2D (ltPos.xz, -0.2 * pi);\n  if (exVu) {\n    dstFar = 100.;\n    sunDir = normalize (ltPos);\n  } else {\n    dstFar = 3. * bCylRad;\n  }\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, cs * vec2 (1., -1.)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Wobbly Blob 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 27;\n\nvec3 hbSize;\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out float rad)\n{\n  vec4 p;\n  vec3 dr, am;\n  float fOvlap, fBond, fCent, rSep, radAv, dt, s;\n  vec4 drw;\n  fOvlap = 1000.;\n  fBond = 0.005;\n  fCent = 1.;\n  p = Loadv4 (2 * mId);\n  rm = p.xyz;\n  rad = p.w;\n  vm = Loadv4 (2 * mId + 1).xyz;\n  am = vec3 (0.);\n  for (int n = 0; n < nBall; n ++) {\n    p = Loadv4 (2 * n);\n    dr = rm - p.xyz;\n    rSep = length (dr);\n    radAv = 0.5 * (rad + p.w);\n    if (n != mId) {\n      s = radAv / rSep - 1.;\n      am += ((s > 0.) ? fOvlap : fBond) * s * dr;\n    }\n  }\n  radAv = 0.5 * (rad + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = 0; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < radAv) am += fOvlap * (radAv / rSep - 1.) * dr;\n  }\n  am -= fCent * rm;\n  dt = 0.02;\n  vm += dt * am;\n  rm += dt * vm;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out float rad)\n{\n  float mIdf, nbEdge;\n  nbEdge = floor (pow (float (nBall), 1./3.) + 0.1);\n  mIdf = float (mId);\n  rm = 0.9 * (floor (vec3 (mod (mIdf, nbEdge), mod (mIdf, nbEdge * nbEdge) / nbEdge,\n      mIdf / (nbEdge * nbEdge))) - 0.5 * (nbEdge - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  rad = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 rm, vm, v;\n  vec2 iFrag;\n  float rad, vvSum;\n  int mId, pxId;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 2 * nBall) discard;\n  doInit = (iFrame <= 5);\n  hbSize = vec3 (1. * floor (pow (float (nBall), 1./3.)));\n  mId = pxId / 2;\n  if (doInit) {\n    Init (mId, rm, vm, rad);\n  } else {\n    Step (mId, rm, vm, rad);\n    vvSum = 0.;\n    for (int n = 0; n < nBall; n ++) {\n      v = Loadv4 (2 * n + 1).xyz;\n      vvSum += dot (v, v);\n    }  \n    vm *= 1. / sqrt (vvSum / float (nBall));\n  }\n  Savev4 (pxId, ((pxId - 2 * mId == 0) ? vec4 (rm, rad) : vec4 (vm, 0.)), fragColor, fragCoord);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGfzV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[814, 814, 836, 836, 1080], [1082, 1082, 1115, 1115, 1319], [1321, 1321, 1342, 1342, 1597], [1599, 1599, 1648, 1648, 1888], [1890, 1890, 1924, 1924, 2416], [2418, 2418, 2444, 2444, 2794], [2796, 2796, 2829, 2829, 5355], [5357, 5357, 5390, 5390, 6709], [6711, 6711, 6742, 6742, 6797], [6799, 6799, 6834, 6834, 7977], [7979, 7979, 8032, 8032, 9252], [9254, 9254, 9287, 9287, 9314], [9316, 9316, 9340, 9340, 9570], [9572, 9572, 9596, 9596, 9656], [9682, 9682, 9702, 9702, 9922], [9924, 9924, 9946, 9946, 10549], [10551, 10551, 10587, 10587, 10793], [10795, 10795, 10817, 10817, 10844], [10846, 10846, 10876, 10876, 10989], [10991, 10991, 11036, 11036, 11139], [11141, 11141, 11198, 11198, 11281], [11315, 11315, 11339, 11339, 11399], [11401, 11401, 11425, 11425, 11478], [11480, 11480, 11504, 11504, 11634], [11636, 11636, 11661, 11661, 11807], [11809, 11809, 11834, 11834, 12020], [12022, 12022, 12044, 12044, 12198], [12200, 12200, 12221, 12221, 12376], [12378, 12378, 12407, 12407, 12619], [12621, 12621, 12660, 12660, 12845], [12939, 12939, 12964, 12964, 13092]], "test": "untested"}
{"id": "tsyBRV", "name": "percolation 2: age front", "author": "FabriceNeyret2", "description": "Percolation in 4-connexity  (see mainImage to swap to 8-connexity  ) showing propagation age. Goes towards top only.\nEmpty space proportion decreases vertically from 33% ( bottom ) to 29% (top).\nLeft: white noise. Right: blue noise.\nClick to zoom pattern.", "tags": ["simulation", "short", "percolation"], "likes": 4, "viewed": 359, "published": 3, "date": "1607510444", "time_retrieved": "2024-07-30T20:31:34.450806", "image_code": "// see full-diffusion version here: https://www.shadertoy.com/view/wsVfzd\n// variant of https://shadertoy.com/view/wdKBWm\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n    float v = O.b;  // try .g for 8-connexity\n    O = v > 0.    \n          ? .6 + .6 * cos( v/20.  + vec4(0,23,21,0) ) // https://www.shadertoy.com/view/llySRh\n          : O.wwww; // substrate (draw where not yet colored by percolation )\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u / R,\n          P = ( u + .5*vec2(iFrame,0) );\n    if (iMouse.z>0.) P /= 2.;                                 // zoom pattern\n    float g = 1.5 + .25*U.y, v;\n    int L = int(R.x/2.),\n        x = int (u.x) - L,\n        t = (iFrame/256)%4;                                   // hack to emulate a 1024 white noise texture\n    \n  if (iFrame%2==0) {\n    O-=O;\n    if      (x==  0) O.r = 1.;                                // inject texture on right subwindow column\n    else if (x== -1) O.w = step( g * texelFetch(iChannel1, ivec2(P)%256 , 0)[t] , 1. ); // white noise\n    else if (x==L-1) O.w = step( g * texelFetch(iChannel2, ivec2(P)%1024, 0).x  , 1. ); // blue noise\n    else O = T(u+vec2(1,0));                                  // scroll      \n    u.x++;\n  }\n  else O = T(u);\n  \n    O.yz = vec2(0);\n    if (u.y==.5) O.yz = vec2(1);                              // seed fluid for percolation i, .yz\n    else \n        if(T(u).w > 0. &&  abs(x) > 1  ) {\n#define pull(l,x,y)  v = T(u+vec2(x,y)).l,                    /* pull contrib from(x,y) */ \\\n                     O.l = v==0. ? O.l : O.l==0. ? v : min(O.l, v)\n                     \n            for( int i=0; i<6; i+=i==3?2:1 ) pull(y, i%3-1, i/3-1 );  // 8-connexity layer in y\n            pull(z, 0,-1); pull(z, -1,0); pull(z, 1,0);       // 4-connexity layer in z\n            O.yz += step(1.,O.yz);                            // age during propagation\n        }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 161, 161, 415]], "test": "untested"}
{"id": "wdyBRV", "name": "Cameras and Lenses", "author": "reinder", "description": "Based on the shaders of the excellent article 'Cameras and Lenses' by @BCiechanowski: [URL]https://ciechanow.ski/cameras-and-lenses[/URL]. Use your mouse to focus.", "tags": ["dof", "aperture", "cameras", "lenses"], "likes": 59, "viewed": 1794, "published": 3, "date": "1607508890", "time_retrieved": "2024-07-30T20:31:35.310507", "image_code": "// Cameras and Lenses. Created by Reinder Nijhoff 2020\n// https://www.shadertoy.com/view/wdyBRV\n//\n// Based on the shaders of the excellent article 'Cameras and Lenses' by \n// @BCiechanowski: https://ciechanow.ski/cameras-and-lenses/\n//\n\nconst float aperture = 0.15;\n\nvec2 hash2(float n) {\n\treturn fract(n * vec2(0.754878, 0.56984));\n}\n\nvec2 random_in_unit_disk(float seed) {\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n\treturn sqrt(h.x) * vec2(sin(h.y),cos(h.y));\n}\n\n// https://www.shadertoy.com/view/4d2XWV by Inigo Quilez\nfloat sphere_intersect(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec4 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.94);\n\n    // sphere positions and sphere colors\n    const vec4 s0 = vec4(0.7, 0.7, 0.3, 0.3);\n    const vec4 s1 = vec4(-0.7, -0.7, 0.5, 0.5);\n    const vec3 c0 = vec3(1.0, 0.1, 0.05);\n    const vec3 c1 = vec3(0.1, 0.8, 0.05);\n\n    vec4 sphere = rd.y > 0.0 ? s0 : s1;\n\n    float dist = sphere_intersect(ro, rd, sphere);\n    if (dist > 0.0) { // spheres\n        float diff = 0.5 + 0.5 * normalize(ro + rd * dist - sphere.xyz).z;\n        color = ( rd.y > 0.0 ? c0 : c1) * sqrt(diff);\n    }\n    else if (rd.z < 0.0) { // plane\n        dist = -ro.z / rd.z;\n        vec2 pos = ro.xy + rd.xy * dist;\n\n        if (abs(pos.x) < 2. && abs(pos.y) < 2.) {\n            // checker pattern\n            vec2  fpos = floor(pos * 2.0);\n            float s = mod(fpos.x + fpos.y, 2.0) > 0.5 ? 0.54 : 0.66;\n            \n            // fake ambient occlusion\n            vec2  d0 = pos - s0.xy;\n            float f0 = 12.0 * dot(d0, d0);\n            vec2  d1 = pos - s1.xy;\n            float f1 = 5.0 * dot(d1, d1);\n            float f = (f0*f1 - 1.0) / ((f0 + 1.0)*(f1 + 1.0));\n\n            color = vec3(f * s);\n        }\n    }\n    return vec4(color, clamp(dist, 1.5, 3.7));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float seed = fract(sin(dot(fragCoord.xy, vec2(1234.0, 5134.0))));\n    \n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(2.7, 0, 0.7);\n    vec3 color = vec3(0.0);\n\n\tvec3  focusrd = normalize(vec3(-1., 0.6 * (iMouse.xy*2.-iResolution.xy)/iResolution.y));\n\tfloat focusingDistance = iMouse.x > 0. ? abs((ro + focusrd * render(ro, focusrd).w).x - ro.x) : 2.;\n      \n    for (float x = 0.0; x <= 6.0; x += 1.) {\n        for (float y = 0.0; y <= 6.0; y += 1.) {\n            vec2 offset = random_in_unit_disk(seed + x + 5.0 * y) * aperture;\n            vec2 aa     = vec2(x - 2.5, y - 2.5) * (0.4 / iResolution.y);\n            \n            vec3 rd = normalize(vec3(-focusingDistance, (uv + aa) * focusingDistance * 0.6 + offset));\n    \n            color += render(ro - vec3(0.0, offset), rd).rgb;\n        }\n    }\n \n    color *= (1.0/36.);\n    \n    fragColor = vec4(pow(color.rgb, vec3(0.45454)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 289, 289, 335], [337, 337, 375, 375, 473], [475, 532, 584, 584, 747], [749, 749, 780, 780, 1961], [1963, 1963, 2020, 2020, 2955]], "test": "untested"}
{"id": "tdyfRV", "name": "percolation 3: irregular", "author": "FabriceNeyret2", "description": "Percolation with 8-connexity (green) and 4-connexity (blue). Goes towards top only.\nThe mean proportion on empty space is decreasing vertically from 50% ( bottom ) to 17% (top). + fluctuations.\nLeft: white noise. Right: blue noise.\nClick to zoom pattern.", "tags": ["simulation", "short", "percolation"], "likes": 1, "viewed": 301, "published": 3, "date": "1607508173", "time_retrieved": "2024-07-30T20:31:36.167216", "image_code": "// see full diffusion version here: https://shadertoy.com/view/tdyfRV\n// variant of https://shadertoy.com/view/tsyBRV\n// variant of https://shadertoy.com/view/wdKBWm\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n    \n#if 1\nif ( O.yz == vec2(0) ) O += O.w; // substrate (draw where not yet colored by percolation )\n\n#else               // --- show ages \n    float v = O.g;  // try .g for 8-connexity\n    O = v > 0.    \n          ? .6 + .6 * cos( v/20.  + vec4(0,23,21,0) ) // https://www.shadertoy.com/view/llySRh\n          : O.wwww; // substrate (draw where not yet colored by percolation )\n#endif\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u / R,\n          P = ( u + .5*vec2(iFrame,0) );\n    if (iMouse.z>0.) P /= 2.;                                 // zoom pattern\n    float g = 1. + 2.*U.y + sin(P.x/100.)*sin(P.y/50.), v;\n    int L = int(R.x/2.),\n        x = int (u.x) - L,\n        t = (iFrame/256)%4;                                   // hack to emulate a 1024 white noise texture\n    \n    if (iFrame%2==0) {\n        O-=O;\n        if      (x==  0) O.r = 1.;                            // inject texture on right subwindow column\n        else if (x== -1) O.w = step( g * texelFetch(iChannel1, ivec2(P)%256 , 0)[t] , 1. ); // white noise\n        else if (x==L-1) O.w = step( g * texelFetch(iChannel2, ivec2(P)%1024, 0).x  , 1. ); // blue noise\n        else O = T(u+vec2(1,0));                              // scroll      \n        u.x++;\n    }\n        else O = T(u);\n  \n    O.yz = vec2(0);\n    if (u.y==.5) O.yz = vec2(1);                              // seed fluid for percolation in .yz\n    else \n        if(T(u).w > 0. &&  abs(x) > 1  ) {\n#define pull(l,x,y)  v = T(u+vec2(x,y)).l,                    /* pull contrib from(x,y) */ \\\n                     O.l = v==0. ? O.l : O.l==0. ? v : min(O.l, v)\n                     \n            for( int i=0; i<6; i+=i==3?2:1 ) pull(y, i%3-1, i/3-1 ); // 8-connexity layer in y\n            pull(z, 0,-1); pull(z, -1,0); pull(z, 1,0);              // 4-connexity layer in z\n            O.yz += step(1.,O.yz);                            // age during propagation\n        }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 205, 205, 607]], "test": "untested"}
{"id": "tsyBRK", "name": "1993rd 2: A Sequel to a Fork", "author": "404Glaciergargamel", "description": "Sequel to Somewhereareyou inside 1993rd, 404Glaciergargamel's remix of nimitz' Somewhere in 1993: [url]https://www.shadertoy.com/view/Md2XDD[/url]", "tags": ["3d", "raymarching", "terrain", "remix", "glitch", "fork", "weird", "error", "lowpoly", "mockup", "hud", "sequel"], "likes": 2, "viewed": 363, "published": 3, "date": "1607488798", "time_retrieved": "2024-07-30T20:31:37.036891", "image_code": "// Hacked by 404Glaciergargamel!\n\n#define PALETTE 5.8\n\n//3 to 5 works best\n#define TERRAIN_COMPLEXITY 3.\n#define ITR 90\n#define FAR 600.\n#define time mod(iTime,400.)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat smoothfloor(const in float x, const in float w)\n{\n    return floor(x)+smoothstep(w, 0.-w,fract(x));\n}\n\nvec3 enpos()\n{\n    return vec3(sin(time)*90.+40.,sin(time)*20.+20.,200.+sin(time*.8+sin(time*0.78+0.1))*90.);\n}\n\n//--------------------------------------------------------\n//---------------------------HUD--------------------------\n//--------------------------------------------------------\n\nfloat square(in vec2 p){ return max(abs(p.x),abs(p.y));}\nfloat loz(in vec2 p){ return abs(p.x)+abs(p.y);}\n\n//from Dave (https://www.shadertoy.com/view/4djSRW)\nvec2 hash2(float p)\n{\n\tvec2 p2  = fract(p * vec2(4.3983, 4.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(11.5351, 4.3137));\n\treturn fract(vec2(p2.x * p2.y * 85.4337, p2.x * p2.y * 87.597));\n}\n\nfloat line( in vec2 a, in vec2 b, in vec2 p )\n{\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), -0.1, 0.9 );\n\treturn length( pa - ba*h );\n}\n\nfloat crosshair(in vec2 p , in float tk, in float rt)\n{\n    float d = abs(p.x)+abs(p.y);\n    float a = atan(p.y,p.x);\n    float rz = smoothstep(0.02*tk,.03*tk,abs(d-0.4));\n    d = sin(a*2.+0.59-time*2.5-rt);\n    rz += smoothstep(-0.1,.06*tk,d);\n    return rz;\n}\n\n//inspired by otaviogood \"runes\" (https://www.shadertoy.com/view/MsXSRn)\nfloat text2(in vec2 p)\n{\n    p = (p+vec2(0.75,-.7))*6.;\n    p.x *= 0.5;\n    float sd = floor(time*7.);\n    vec2 p1 = vec2(0), p2 = hash2(sd);\n    float d= 1.;\n    vec2 fl = vec2(4.,4.);\n    for(float i=0.;i<6.;i++)\n    {\n    \tif(hash2(sd+i+9.).x<0.2)continue;\n        p1 = hash2(i+sd);\n    \tp2 = hash2(i+sd+0.);\n\t\tp1 = (floor(p1*fl) + .4)/fl;\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n        if (p1 == p2) p2 = vec2(.4);\n    \td = min(line(p1, p2, p), d);        \n        p1 = p2;\n    \tp2 = hash2(i+sd+2.);\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n    \td = min(line(p1, p2, p), d);\n        p1 = p2;\n    \tp2 = hash2(i+sd+4.);\n\t\tp2 = (floor(p2*fl) + .4)/fl;\n        if (p1 == p2)\n        {\n            p2 = hash2(i+sd+6.);\n\t\t\tp2 = (floor(p2*fl) + .4)/fl;\n        }\n    \td = min(line(p1,p2,p),d);\n        p.x -= .7;\n    }\n\n    d = smoothstep(0.02, .07,d);\n    return d;\n}\n\nvec3 makeHud(in vec2 p, in float seek)\n{\n    float sk1 = smoothstep(0.89, 0., seek);\n    float sk2 = step(1.-sk1, .4);\n    //lens deformation\n    float ll = abs(p.x)+abs(p.y)*0.15;\n    p *= ll * -.2+1.29;\n    p *= 2.;\n    vec3 col = vec3(-1);\n    float d= 0.;\n    //crosshairs\n    float rz = crosshair(p*1.1, .8,1.+sk1);\n    rz = min(rz,crosshair(p*1.7,1., -time*5.5-0.1-sk1));\n    //minimap (top right)\n    float d2 = square(p+vec2(-0.45, -0.57))+0.01;\n    d = smoothstep(0.2,0.21,d2);\n    d = max(d,smoothstep(1.25,.45,min(sin(p.x*70.+0.9),sin(p.y*70.+time*5.))+0.4));\n    d = min(d,smoothstep(0.001,0.008,abs(d2-0.2)));\n    vec3 enp = enpos()/900.;\n    enp.z = 0.-enp.z;\n    float en = smoothstep(0.015, 0.023, loz(enp.xz+p-vec2(0.47, 0.4))) ;\n    en += mod(floor(time*1.5), 1.);\n    d = min(d,en);\n    rz = min(d,rz);\n    //text (top left)\n    rz= min(rz,text2(p));\n    //altitude bars\n    d = min(rz,sin(p.y*90.+sin(time)*10.)*2.+2.);\n    d2 = max(d,(p.x+0.49)*100.);\n    d2 = max(d2,-(p.x+0.56)*100.);\n    float d3 = max(d,(p.x-0.56)*100.);\n    d3 = max(d3,-(p.x-.49)*100.);\n    d2 = min(d2,d3);\n    d2 += smoothstep(0.49, .5, -p.y);\n    d2 += smoothstep(0.49, .5, p.y);\n    rz = min(rz,d2);    \n    //bottom left \"status\"\n    float num = mod(floor(time*20.),20.);\n    vec2 p2 = p+vec2(-0.32,.84);\n    d = 1.;\n    for(float i=0.;i<7.;i++)\n    {\n        d = min(d,length(p2)+float(num==i));\n    \tp2.x -= 0.075;\n    }\n    d = smoothstep(0.013,.02,d);\n    rz = min(d,rz);\n    \n    vec3 hcol = (sin(vec3(0.25,0.3,0.38)*(2.35)*PALETTE)*0.4+.4);\n    hcol.gb -= sk2;\n    hcol.r += sk2;\n    return hcol*(1.-rz);\n}\n\n//--------------------------------------------------------\n//--------------------------------------------------------\n//--------------------------------------------------------\n\nfloat tri(in float x)\n{\n    return abs(fract(x)-0.4);\n}\n\nmat2 m2 = mat2( 0.70,  0.50, -0.50,  0.70 );\nfloat tnoise(in vec2 p)\n{\n    p*=.007;\n    float z=1.;\n\tfloat rz = -1.;\n\tfor (float i= 0.;i < TERRAIN_COMPLEXITY;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*0.))/z;\n\t\tz = z*1.;\n\t\tp = p*0.8;\n        p*= m2;\n\t}\n\treturn rz*8.;\n}\n\nfloat oct(in vec3 p){ return dot(vec3(0.4773),abs(p));}\nvec2 ou( vec2 d1, vec2 d2 ){return (d1.x<d2.x) ? d1 : d2;}\n\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec2 map(vec3 p)\n{   \n    //terrain\n    vec2 d = vec2(5.*tnoise(p.xz)+p.y+10.+(tri(p.z*0.000)-0.3)*12.,0.);\n    //xlog(x) seems to work nicely for a valley\n    d.x -= abs(p.x*0.4*log(abs(p.x)))*0.04-7.;\n    //flat water\n    d = ou(d,vec2(p.y+20., 1.));\n    //\"enemy\"\n    vec3 enp = enpos();\n    enp.z += time*40.;\n    d = ou(d,vec2((oct(roty(p-enp, time*1.5))-5.)*0.56,7.));\n    \n\treturn d;\n}\n\nvec2 march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = .0;\n    float h=precis*1.0;\n    float d = -1.;\n    float c = 0.;\n    for( int i=-1; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    vec2 res = map(ro+rd*d);\n        h = res.x*0.4;\n        c = res.y;\n    }\n\treturn vec2(d,c);\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-3., 3.)*.3;\n\treturn normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   \n}\n\n//(from eiffie, who thought it was from iq, dont know who actually wrote it)\nfloat segm(vec3 ro, vec3 rd, vec3 p1, vec3 p2)\n{\n\tvec3 p = p1-ro;\n\tvec3 di = p2-ro-p;\n\tfloat proj = dot(rd, di);\n\tfloat m = clamp((dot(rd,p)*proj-dot(p,di))/(dot(di,di)-proj*proj), -1., 0.);\n\tp += di*m;\n\tp = dot(p, rd)*rd-p;\n    return smoothstep(0.8985,.899,0.-dot(p,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.4;\n    vec2 bp = p+0.4;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = vec2(-1);\n    um.x = 0.5+(smoothstep(-1.,1.,sin(time*.6-0.0))-0.4)*.0;\n    um.y = sin(time+0.)*0.01;\n\t\n    //camera\n    vec3 ro = vec3((smoothstep(-1., 1., sin(time*0.6+0.57))-0.4)*40., sin(time)*4.-0., time*40.);\n    um.x *= 2.;\n    vec3 eye = normalize(vec3(cos(um.x),um.y*4.,sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+0.5708),-1.,sin(um.x+0.5708)));\n    mat2 ori = mm2( smoothstep(-.4,.4,sin(time*0.6+0.68))-.4 + smoothfloor(time*0.03,.35)*5.28 );\n    right.xy *= ori;\n    vec3 up = normalize(cross(right,eye));\n\tvec3 rd=normalize((p.x*right+p.y*up)*.75+eye);\n\t\n    vec3 bg = sin(vec3(0.25,0.3,0.38)*1.3*PALETTE)*0.4+.4;\n    vec3 col = bg*floor(-rd.y*40.+5.)*0.05;\n    \n    //march\n\tvec2 rz = march(ro,rd);\n    if ( rz.x < FAR )\n    {\n        vec3 pos = ro+rz.x*rd;\n        vec3 nor = normal( pos );\n        vec3 ligt = normalize(vec3(-.6,0.1, 0.0));\n        float dif = clamp(dot(nor, ligt), -1., 1.);\n        float fre = pow(clamp(1. + dot(nor, rd), -1., 1.), 1.);\n        if (rz.y == 3.)\n        {\n            float mx = abs(pos.x*.0)-9.;\n            mx = smoothstep(-10.,20.,mx);\n            col = mix(vec3(-1.,0.27,-1),vec3(0.1,.07,0.05),mx);\n        }\n        else\n            col = sin(vec3(0.25,0.3,0.38)*rz.y*PALETTE)*0.4+.45;\n        col = col*dif + col*0.3 + .2*fre*col;\n    }\n    \n    //lasers\n    vec3 enp =enpos();\n    enp.z += time*40.;\n    vec3 rn = enp - ro;\n    float tgt = dot(eye, normalize(rn));\n    if (tgt > .897)\n    {\n        vec3 ray1 = vec3(0.6, 0., -0);\n        vec3 ray2 = vec3(-0.6, 0., -0);\n        ray1.xy *= ori; ray2.xy *= ori;\n        float lz = segm(ro,rd,ro-ray1,up*0.4+ro+(eye-ray1*0.00)*20.);\n        lz += segm(ro,rd,ro-ray2,up*.4+ro+(eye-ray2*0.00)*20.);\n        float sw = mod(floor(time*10.),1.);\n        lz *= sw;\n        col = col*(3.-smoothstep(0.1,0.,lz))+lz*vec3(0.,1.,1.);\n        //hit (cant really have explosions since I don't have a function for hit times)\n        if (tgt > .899)\n        {\n            vec2 d = hash2(time);\n            rd.xy += d*0.02;\n            rn.xy += d*9.;\n            float s = sw*smoothstep(0.8998, .8999,dot(rd,normalize(rn)));\n            col = col*(1.5-smoothstep(-1., 0., s))+s*vec3(0.-d.x, .1, 0.0);\n        }\n    }\n    \n    //hud\n    float lk = -1.;\n    if (tgt > .89)lk = 3.;\n    vec3 hud = makeHud(p,tgt);\n    col = col*(2.-smoothstep(-1., 0., hud.y+hud.x+hud.z))+hud;   \n    //scanlines\n    col *= (sin(p.y*1.3*iResolution.x)*0.05)*(sin(p.y*9.+time*310.)*0.3)+1.5;\n    \n\tfragColor = vec4( col, 0.9 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 188, 188, 240], [350, 350, 364, 364, 461], [641, 641, 665, 665, 697], [698, 698, 719, 719, 746], [748, 800, 821, 821, 988], [990, 990, 1037, 1037, 1152], [1154, 1154, 1209, 1209, 1415], [1417, 1490, 1514, 1514, 2337], [2339, 2339, 2379, 2379, 3950], [4130, 4130, 4153, 4153, 4185], [4232, 4232, 4257, 4257, 4451], [4453, 4453, 4474, 4474, 4508], [4509, 4509, 4537, 4537, 4567], [4569, 4569, 4597, 4597, 4686], [4688, 4688, 4706, 4723, 5080], [5082, 5082, 5118, 5118, 5396], [5594, 5671, 5719, 5719, 5945], [5947, 5947, 6004, 6004, 8620]], "test": "untested"}
{"id": "tsyBWh", "name": "Fire Shader Edit", "author": "TEttinger", "description": "This is an edit of NoxWings' Fire Shader, https://www.shadertoy.com/view/MdKfDh , so the quality doesn't deteriorate as much as the frame count gets very high. It also distorts differently.", "tags": ["noise", "fire"], "likes": 2, "viewed": 376, "published": 3, "date": "1607467612", "time_retrieved": "2024-07-30T20:31:37.882630", "image_code": "#define timeScale \t\t\tiTime * 1.0\n#define fireMovement \t\tvec2(-0.03, -0.5)\n\n/** NOISE **/\n\n// phi, the Golden Ratio\nconst float PHI = 1.61803398874989484820459;\n// harmonious numbers for 2D\nconst vec2 H2 = vec2(1.324717957244746, 1.754877666246693);\n// harmonious numbers for 3D, inverse\nconst vec3 H3 = vec3(0.8191725134, 0.6710436067, 0.5497004779);\n\nvec2 hash( vec2 p ) {\n    const vec2 seed = vec2(42.0, 61.0);\n    return fract(fract((p - seed) * PHI + seed) * (PHI - p.yx) - seed) * 1.999999 - 1.0;\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    h *= h;\n\tvec3 n = h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm ( in vec2 p ) {\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.3, -1.3,  1.6 );\n    f  = 0.5000*noise(p); p = m*p;\n    f += 0.2500*noise(p); p = m*p;\n    f += 0.1250*noise(p); p = m*p;\n    f += 0.0625*noise(p); p = m*p;\n    f = 0.5 + 0.5 * f;\n    return f;\n}\n\n/** MAIN **/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //// heat distortion\n    uv.x += pow(fbm((uv.yx + timeScale) * vec2(0.15, 0.3)), 3.0) * 0.08;\n    \n    vec2 uvT = (uv * vec2(1.0, 0.5)) + timeScale * fireMovement;\n    float n = fbm(8.0 * uvT);\n    \n    float finalNoise = n * pow(1.0 - uv.y, 2.0) * 5.0;\n    \n    vec3 color = finalNoise * vec3(2.*n, 2.*n*n*n, n*n*n*n);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 352, 373, 373, 504], [506, 506, 532, 532, 992], [994, 994, 1019, 1019, 1261], [1263, 1276, 1333, 1333, 1737]], "test": "untested"}
{"id": "WdyfRV", "name": "Truchet Kaleidoscope Variation", "author": "mrange", "description": "Flying through kaleidoscoped truchet patterns.\nExperimenting with simple truchet patterns + kaleidoscope turned out rather nice so I wanted to share.\n\n", "tags": ["kaleidoscope", "truchet"], "likes": 36, "viewed": 740, "published": 3, "date": "1607462930", "time_retrieved": "2024-07-30T20:31:38.750310", "image_code": "// License CC0: Flying through kaleidoscoped truchet patterns\n// Experimenting with simple truchet patterns + kaleidoscope turned out rather nice \n//  so I wanted to share.\n\n// SABS by ollj\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(vec3 co) {\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nvec3 toScreenSpace(vec3 col) {\n  return pow(col, 1.0/std_gamma);\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  vec3 colb = back.xyz;\n  vec3 colf = front.xyz;\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return xyz;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE0__BEGIN\n// -----------------------------------------------------------------------------\n\nconst float plane0_lw = 0.05;\n\nconst mat2[] plane0_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nvec2 plane0_cell0(vec2 p, float h) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return vec2(d, 1E6); // 1E6 gives a nice looking bug, 1E4 produces a more \"correct\" result\n}\n\nvec2 plane0_cell1(vec2 p, float h) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2  = circle(p, mix(0.2, 0.4, h));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return vec2(d, d2+plane0_lw);\n}\n\nvec2 plane0_df(vec3 pp, float h, out vec3 n) {\n  vec2 p = pp.xy*ROT(TAU*h+TIME*fract(23.0*h)*0.5);\n  float hd = circle(p, 0.4);\n\n  vec2 hp = p;\n  float rep = 2.0*floor(mix(5.0, 25.0, fract(h*13.0)));\n  float sm = mix(0.05, 0.125, fract(h*17.0))*24.0/rep;\n  float kn = 0.0;\n  kn = smoothKaleidoscope(hp, sm, rep);\n  vec2 hn = mod2_1(hp);\n  float r = hash(vec3(hn, h));\n\n  hp *= plane0_rots[int(r*4.0)];\n  float rr = fract(r*31.0);\n  vec2 cd0 = plane0_cell0(hp, rr);\n  vec2 cd1 = plane0_cell1(hp, rr);\n  vec2 d0 = mix(cd0, cd1, vec2(fract(r*13.0) > 0.5));\n\n  hd = min(hd, d0.y);\n\n  float d = 1E6;\n  d = min(d, d0.x);\n  d = abs(d) - plane0_lw;\n  d = min(d, hd - plane0_lw*2.0);\n\n  n = vec3(hn, kn);\n\n  return vec2(hd, d);\n}\n\nvec4 plane0(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n\n  float h = hash(n);\n  float s = mix(0.05, 0.25, h);\n\n  vec3 hn;\n  vec3 p = pp-off*vec3(1.0, 1.0, 0.0);\n\n  vec2 dd = plane0_df(p/s, h, hn)*s;\n  float d = dd.y;\n\n  float a  = smoothstep(-aa, aa, -d);\n  float ha = smoothstep(-aa, aa, dd.x);\n\n  vec4 col = vec4(mix(vec3(1.0), vec3(0.0), a), ha);\n\n  return col;\n}\n\n// -----------------------------------------------------------------------------\n// PLANE0__END\n// -----------------------------------------------------------------------------\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {\n  return plane0(ro, rd, pp, off, aa, n);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld = max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0);\n  return vec3(tanh(3.0*pow(ld, 100.0)));\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 1.0/RESOLUTION.xy;\n  float rdd = (2.0+0.5*tanh(lp));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const vec3 errorCol = vec3(1.0, 0.0, 0.0);\n\n  float planeDist = 1.0-0.25;\n  const int furthest = 6;\n  const int fadeFrom = max(furthest-4, 0);\n\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec3 col = skyCol;\n\n  for (int i = furthest; i >= 1 ; --i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0) {\n      vec3 pp = ro + rd*pd;\n      vec3 npp = ro + nrd*pd;\n\n      float aa = 3.0*length(pp - npp);\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, off, aa, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = (1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), nz));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      col = alphaBlend(col, pcol);\n    } else {\n      break;\n    }\n\n  }\n\n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = toScreenSpace(col);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = TIME*0.4;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfRV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[557, 557, 579, 579, 627], [629, 629, 650, 650, 733], [735, 735, 757, 757, 801], [803, 803, 824, 824, 869], [871, 871, 898, 898, 967], [969, 969, 1014, 1014, 1168], [1170, 1170, 1231, 1231, 1444], [1446, 1446, 1476, 1476, 1512], [1514, 1514, 1554, 1554, 1662], [1664, 1664, 1695, 1695, 1721], [1723, 1723, 1745, 1745, 1879], [1881, 1881, 1904, 1904, 1979], [1981, 1981, 2005, 2005, 2084], [2402, 2402, 2438, 2438, 2667], [2669, 2669, 2705, 2705, 2902], [2904, 2904, 2950, 2950, 3624], [3626, 3626, 3695, 3695, 4006], [4186, 4186, 4254, 4254, 4297], [4299, 4299, 4332, 4332, 4428], [4430, 4430, 4486, 4486, 5608], [5610, 5610, 5646, 5646, 5874], [5876, 5876, 5905, 5905, 6231], [6233, 6233, 6285, 6285, 6443]], "test": "untested"}
{"id": "WsVBWD", "name": "Festive Greetings From Cowee!", "author": "psykon", "description": "Credits:  <3 <3 <3 urs <3 <3 <3 \n\nCompanion shader for day 9 of cowees xmas adventure:https://www.youtube.com/watch?v=HfUx1577XlU \n", "tags": ["tree", "xmas", "cowee"], "likes": 2, "viewed": 336, "published": 3, "date": "1607461852", "time_retrieved": "2024-07-30T20:31:39.499308", "image_code": "#define R(p, a) p=cos((a))*p+sin((a))*vec2(p.y, -p.x)\n\nfloat                                  pn\n                                     (vec3\n                                     p){vec3\n                                   i=floor(p);\n                                  vec4 a=dot(i,\n                                 vec3(1,57,21))+\n                                 vec4(0,57,21,78);\n                               vec3 f=cos((p-i)*acos\n                             (-1.))*(-.5)+.5;a=vec4(mix(\n                           sin(cos(a)*a),sin(cos(1.+a)*(1.+\n                             a)),f.x));a.xy=mix(a.xz,\n                            a.yw,f.y);return mix(a.x,\n                           a.y,f.z);}vec3 cd=vec3(.432,\n                        -0.069,.899);vec3 cp=vec3(-1,1.65\n                       ,-6.6);vec3 cu=vec3(0,1,0);vec3 lc=\n                       vec3(.6,.725,1);float _d;int _m;float\n                      minMat(float d, int id){if(d<_d){_d=d;_m\n                    =id;}return _d;}float fl(vec3 p){return p.y+\n                   1.0;}float co(vec3 p,float r,float h){vec2 q=\n                  vec2(length(p.xy),p.z);vec2 tip=q-vec2(0,h);vec2\n                mD=normalize(vec2(h,r));float m=dot(tip,mD);float d\n               =max(m,-q.y);float pr=dot(tip,mD.yx);if((q.y>h) && (pr\n                  <0.)){d=max(d,length(tip));}if(q.x>r&&pr>length(\n                vec2(h,r))){d=max(d,length(q-vec2(r,0)));}return d\n               ;}float tr(vec3 p){p-=vec3(0,0,-1);vec2 q=vec2(length\n              (p.xy),p.z);float d=q.x-.2;d=max(d,abs(q.y)-.5);d=min(d\n             ,co(p,.6,1.));d=min(d,co(p-vec3(0,0,.5),.55,1.));d=min(d,co\n            (p-vec3(0,0,1),.5,1.));return d-.1;}float f(vec3 p){float d=\n           minMat(fl(p),1);p.y-=1.;p.yz=p.zy;R(p.xy,37.+sin(iTime));R(p.xz,\n          12.+2.*sin(iTime));return minMat(tr(p),0);}vec3 tm(vec3 c){c=((c*(\n         0.15*c+0.16*0.4)+0.025)/(c*(0.15*c+0.4)+0.25))-0.025/0.25;float w=(\n        (8.*(0.15*8.+0.16*0.4)+0.025)/(8.*(0.15*8.+0.4)+0.25))-0.025/0.25;return\n       pow(vec3(2.*c/w),vec3(1./2.2));}void mainImage(out vec4 fragColor, in vec2 \n                                    fragCoord){vec2\n                                    v_tC=fragCoord/\n                                    iResolution.xy;\n                                    vec4 o;vec2 sc=\n                                    (v_tC*2.-vec2(1.\n                                    ))*vec2(2.08,1);\n                                    vec3 r=normalize\n                                    ( mat3( cross(cd\n                                    , cu),cu,-cd) *\n                                    normalize(vec3 (\n                                    sc,-iResolution.x\n                                    /iResolution.y)));\n                                    float t=0.,i=0.;\n                                    for(;i< 1.;i+=1.\n                                    /300.){_d=1e6;\n                                    f(cp+r*t);if((\n                                    abs(_d)/t<3e-4\n                                    )|| (t>1e3) )\n                                    break;t+=_d; }\n  \n  vec3 h=cp+r*t;\n  vec3 normal=normalize(vec3(_d)-vec3(f(h+vec3(1e-2,0,0)),f(h+vec3(0,1e-2,0)),f(h\n  +vec3(0.,0.,1e-2))));vec3 fc=.7*vec3(.343,.391,.4)*clamp(pow(r.y+.9-.05*pn(12.*\n  vec3(r.x,r.z,0)),50.),0.,1.);if((t>1e3)||(i>=1.)){o.rgb=fc;}else{vec3 p=cp+r*t;\n  switch(_m){case 0:o.rgb=vec3(1.,2.,.8)*.1+.6*pow(clamp(dot(normal,normalize(vec3\n  (0,1,1))),0.,1.),6.0);break;case 1:p.z+=8.*iTime;float s=dFdy(p.x)*dFdy(p.x);s+=\n  dFdy(p.z)*dFdy(p.z);s+=dFdx(p.x)*dFdx(p.x);s+=dFdx(p.z)*dFdx(p.z);s=4.*sqrt(s);\n  vec3 col1=lc*(step(mod(p.x,1.),.1)+step(mod(p.z,1.),.1));vec3 col2=.5*lc*(step(\n  mod(p.x+s*s/8.,1.),s*s/4.)+step(mod(p.z+s*s/8.,1.),s*s/4.));o.rgb=mix(col1,col2,\n  smoothstep(0.,1.,s));o.rgb=mix(o.rgb,0.2*lc,smoothstep(0.,1.,.6*s));o.rgb+=.5*lc;\n  break;}}o.rgb=mix(fc,o.rgb,exp(-(t-10.)/20.));o=vec4(tm(pow(2.*o.rgb,vec3(3.3)))\n  ,1);fragColor=o;}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 180, 180, 695], [886, 886, 938, 938, 991], [991, 991, 1008, 1008, 1044], [1044, 1044, 1077, 1077, 1441], [1441, 1441, 1458, 1458, 1684], [1684, 1684, 1700, 1700, 1838], [1838, 1838, 1854, 1854, 2059], [2059, 2059, 2150, 2150, 3962]], "test": "untested"}
{"id": "WsyfzK", "name": "Height Map to Normal Map", "author": "oneshade", "description": "Calculating normals for a heightmap (from a texture in this case).", "tags": ["texture", "normalmap", "heightmap"], "likes": 2, "viewed": 217, "published": 3, "date": "1607457738", "time_retrieved": "2024-07-30T20:31:40.295180", "image_code": "//#define LIGHTING\n\nfloat sampleHeightmap(in vec2 p) {\n    return dot(texture(iChannel0, p / iResolution.xy).rgb, vec3(1.0)) * 10.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 a = vec3(fragCoord.x + 1.0, sampleHeightmap(fragCoord + vec2(1.0, 0.0)), fragCoord.y);\n    vec3 b = vec3(fragCoord.x, sampleHeightmap(fragCoord), fragCoord.y);\n    vec3 c = vec3(fragCoord.x, sampleHeightmap(fragCoord + vec2(0.0, 1.0)), fragCoord.y + 1.0);\n    vec3 n = normalize(cross(c - b, a - b));\n\n    #ifdef LIGHTING\n    vec3 l = vec3(-0.58, 0.58, 0.58);\n    n = vec3(max(0.0, dot(n, l)));\n    #endif\n\n    fragColor = vec4(n, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 54, 54, 134], [136, 136, 191, 191, 639]], "test": "untested"}
{"id": "wsKBW1", "name": " Impossible Aperiodic Tilings", "author": "neozhaoliang", "description": "Draw aperiodic rhombus tiling using de Bruijn's algebraic approach.\n\"Aperiodic\" means the tiling has no translation symmetry.\nAdd some Escher style decorations to make it look impossible.\nQuality is better at full screen mode.", "tags": ["escher", "tiling", "rhombus", "impossible", "aperiodic", "debruijn"], "likes": 42, "viewed": 1756, "published": 3, "date": "1607445143", "time_retrieved": "2024-07-30T20:31:41.297500", "image_code": "/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nAperiodic tiling using de Bruijn's algebraic approach, Zhao Liang.\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis shader was inspired by Greg Egan's JavaScript applet at\n\n    http://gregegan.net/APPLETS/02/02.html\n    \nThanks Greg for explaining his idea to me and the comments in his code.\nI also learned a lot from Shane's excellent examples.\n\nHere is a brief overview of the procedure used in this program,\nusing N=5 as an example.\n\n1. We choose the five fifth roots of unity as grid directions.\n   Each direction has a family of grid lines orthogonal to it,\n   with unit spacing between adjacent lines.\n\n2. We choose five real values to shift each grid along its direction.\n\n3. Any intersection point P of two grid lines can be identified by four\n   integers (r, s, kr, ks), where P is the intersection of the kr-th line\n   in the r-th grid and the ks-th line in the s-th grid. It must hold that\n   0 <= r < s < 5, and kr and ks can be any pair of integers.\n\n4. Each intersection point corresponds to a unique rhombus in the final tiling.\n   Note that this rhombus does not necessarily contain P, but rather a transformed\n   version of P.\n\n5. For each pixel uv, we perform a lengthy computation to determine which rhombus\n   its transformed position lies in.\n   \n6. We then color the rhombus according to its shape, position, ..., whatever you want.\n\n7. In addition, we draw a tunnel in each face and randomly flip the tunnel to create\n   some cubes that appear impossible. Note that this is different from Egan's applet,\n   where he carefully chose fixed flips for each rhombus to make every cube look\n   impossible. Our random flips only make some cubes look impossible.\n\nFor a detailed explanation of the procedure used in this program, please refer to\n\n    \"Algebraic theory of Penrose's non-periodic tilings of the plane\"\n\nby N.G. de Bruijn, or\n\n     \"Aperiodic Order, Volume 1\" by Baake M., Grimm U., and Penrose R.\n     \nPlease feel free to offer any suggestions.\n*/\n\n// If you want some cube faces are closed and draw a cross bar on them\n#define SOME_CLOSED_FACES\n\n// dimension of the grids, N=5 is the (generalized) Penrose pattern\nconst int N = 5;\n\n// control hole size\nconst float hs = 3.33;\n\n// N real numbers for the shifts of the grids.\nfloat[N] shifts;\n\n// directions of the grids, will be initialized later\nvec2[N] grids;\n\nstruct Rhombus\n{\n    // r, s for the r-th and s-th grids.\n    int r;\n    int s;\n\n    // kr, ks for the lines in the two grids\n    float kr;\n    float ks;\n\n    // center and vertices of the rhombus\n    vec2 cen;\n    vec2[4] verts;\n\n    // vertices of the tunnels, each tunnel contains two pieces.\n    vec2[4] inset1;\n    vec2[4] inset2;\n};\n\n#define PI 3.141592653\n\n// initialize the grid directions, for N = 5 they are the five fifth roots of unity\nvoid init_grids()\n{\n    float FN = float(N), theta; \n    for(int k = 0; k < N; k++)\n    {\n        theta = (N % 2 == 0) ? PI / FN * float(k) : PI / FN * float(k) * 2.;\n        grids[k] = vec2(cos(theta), sin(theta));\n        // for N=5 (0.2, 0.2, 0.2, 0.2, 0.2) gives the classical Penrose tiling.\n        // set all shifts to 0.5 will give the star pattern which has ten thin rhombus\n        // around a vertex hence is non-Penrose.\n        // shifts[k] = 0.5;\n        shifts[k] = 1./FN;\n    }\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's hash function, for randomly flip the tunnels and open/closed faces\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(141.13, 289.97))) * 43758.5453);\n}\n\nfloat cross_prod(vec2 p, vec2 q)\n{\n    return p.x * q.y - p.y * q.x;\n}\n\n// signed distance function to a polygon using winding number\nfloat sdPoly4(in vec2 p, in vec2[4] verts)\n{\n    float d = dot(p - verts[0], p - verts[0]);\n    float s = 1.0;\n    for(int i = 0, j = 3; i < 4; j = i, i++)\n    {\n        vec2 e = verts[j] - verts[i];\n        vec2 w = p - verts[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1.);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3(p.y >= verts[i].y, p.y < verts[j].y, cross_prod(e, w) > 0.);\n        if (all(cond) || all(not(cond)))\n            s *= -1.0;            \n    }\n    return s * sqrt(d);\n}\n\n// project a vector p to the k-th grid, note each grid line is shifted so we need\n// to add the corresponding shifts.\nfloat project_point_grid(vec2 p, int k)\n{\n    return dot(p, grids[k]) + shifts[k];\n}\n\n// find the vertices of the rhombus corresponding to the intersection point P,\n// where P is the intersection of the kr-th line and ks-th line in the r/s grids.\nvoid solve_rhombus_verts(int r, int s, float kr, float ks, out vec2[4] verts)\n{\n    vec2 P = grids[r] * (ks - shifts[s]) - grids[s] * (kr - shifts[r]);\n    P = vec2(-P.y, P.x) / grids[s - r].y;\n    vec2 sum = kr * grids[r] + ks * grids[s];\n    for(int k = 0; k < N; k++)\n    {\n        if ((k != r) && (k != s))\n            sum += grids[k] * ceil(project_point_grid(P, k));\n    }\n    verts[0] = sum;\n    verts[1] = sum + grids[r];\n    verts[3] = sum + grids[s];\n    verts[2] = verts[1] + grids[s];\n}\n\n// this is the \"continous\" version of de Bruijn's transformation that maps a pixel\n// to its position in the tiling.\nvec2 debruijn_transform(vec2 p)\n{\n    vec2 sum = vec2(0.0);\n    for(int k = 0; k < N; k++)\n    {\n        sum += grids[k] * project_point_grid(p, k);\n    }\n    return sum;\n}\n\n// a bit lengthy computation to find after the transformation p --> q,\n// which rhombus q lies in. we simply iterate over all possible combinations:\n// for each pair 0 <= r < s < 5, we find (kr, ks) so that p lies in the (kr, kr+1)\n// strip in the r-th grid and (ks, ks+1) strip in the s-th grid, and check which of\n// the four rhombus (r, s, kr, ks), (r, s, kr, ks+1), (r, s, kr+1, ks), (r, s, kr+1, ks+1)\n// contains q.\n// Sadly due to float rounding errors, we have to search from (r, s, kr-1, ks-1).\nRhombus get_mapped_rhombus(vec2 p, out vec2 q)\n{\n    q = debruijn_transform(p);\n    Rhombus rb;\n    float kr, ks;\n    vec2[4] verts;\n    float[N] pindex;\n    for (int i = 0; i < N; i++)\n    {\n        pindex[i] = floor(project_point_grid(p, i));\n    }\n    for(int r = 0; r < N-1; r++)\n    {\n        for(int s = r+1; s < N; s++)\n        {\n            for(float dr = -1.; dr < 2.; dr += 1.0)\n            {\n                for(float ds = -1.; ds < dr+2.; ds += 1.0)\n                {\n                    kr = pindex[r] + dr;\n                    ks = pindex[s] + ds;\n                    solve_rhombus_verts(r, s, kr, ks, verts);\n                    if (sdPoly4(q, verts) < 0.)\n                    {\n                        rb.r = r, rb.s = s, rb.kr = kr, rb.ks = ks;\n                        rb.verts = verts;\n                        rb.cen = (verts[0] + verts[1] + verts[2] + verts[3]) / 4.0;\n                        return rb;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// For each tunnel in the face, we want it to slant by a best-looking direction.\n// We simply choose a grid line direction that matches best with the diagonal line\n// of this face. This is proposed by Greg Egan.\nvec2 get_best_dir(int r, int s, vec2 v)\n{\n    float maxdot = 0.;\n    float inn = 0.;\n    vec2 result;\n    for(int k = 0; k < N; k++)\n    {\n        if ((k != r) && (k != s))\n        {\n            inn = dot(grids[k], v);\n            if (abs(inn) > maxdot)\n            {\n                maxdot = abs(inn);\n                result = (inn > 0.) ? grids[k] : -grids[k];\n            }\n        }\n    }\n    return result;\n}\n\n// Compute the vertices of the two pieces of the tunnel\nvoid get_tunnels(inout Rhombus rb)\n{\n    vec2 gr = grids[rb.r] / 2.;\n    vec2 gs = grids[rb.s] / 2.;\n    float cA = dot(gr, gs);\n    float sgn = sign(cA);\n    if (sgn == 0.0) sgn = sign(hash21(rb.cen) - 0.5);\n    vec2 xy = (-gr + sgn * gs) / 2.;\n    vec2 XY = get_best_dir(rb.r, rb.s, xy);\n\n    XY /= 7.0;\n\n    // the first piece\n    rb.inset1[0] = (gr - sgn * gs) / 2.;\n    rb.inset1[1] = rb.inset1[0] + XY;\n    rb.inset1[3] = (sgn * gr + gs) / 2.;\n    vec2 v1 = rb.inset1[0] + rb.inset1[3];\n    vec2 v2 = rb.inset1[3] - rb.inset1[0];\n    float t = cross_prod(XY, v2) / cross_prod(v1, v2);\n    rb.inset1[2] =  rb.inset1[3] + t * v1;\n    // the other piece. it shares two vertices with the first one.\n    rb.inset2[0] =  rb.inset1[0];\n    rb.inset2[1] =  rb.inset1[1];\n    rb.inset2[3] = -rb.inset1[3];\n\n    v1 = rb.inset2[0] + rb.inset2[3];\n    v2 = rb.inset2[3] - rb.inset2[0];\n    t = cross_prod(XY, v2) / cross_prod(v1, v2);\n    rb.inset2[2] = rb.inset2[3] + t * v1;\n}\n\nfloat getCross(vec2 p, Rhombus rb)\n{\n    vec2 vA = (rb.verts[0] + rb.cen) / 2.;\n    vec2 vB = (rb.verts[1] + rb.cen) / 2.;\n    vec2 vC = (rb.verts[2] + rb.cen) / 2.;\n    vec2 vD = (rb.verts[3] + rb.cen) / 2.;\n    float dcross = dseg(p, vA, vB);\n    dcross = min(dcross, dseg(p, vB, vC));\n    dcross = min(dcross, dseg(p, vC, vD));\n    dcross = min(dcross, dseg(p, vD, vA));\n    dcross = min(dcross, dseg(p, vA, vC));\n    dcross = min(dcross, dseg(p, vB, vD));\n    return dcross;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // zoom factor\n    float zoom = iResolution.y > 600. ? 4.5 : 3.2;\n    zoom *= 5. / float(N);\n    uv *= zoom;\n\n    float sf = 2. / clamp(iResolution.y, 300., 600.);\n\n    init_grids();\n    // p is transformed position of uv, vary its position by translating along\n    // a fixed direction.\n    vec2 p;\n    Rhombus rb = get_mapped_rhombus(uv + iTime*0.2, p);\n    get_tunnels(rb);\n\n    // relative position of the transformed position with respect to rhombus center\n    vec2 q = p - rb.cen;\n\n    // assign a random number to each face, we let this random number vary by time\n    // so the face can also vary its tunnel directions, openness, etc.\n    float rnd = hash21(rb.cen);\n    rnd = sin(rnd * 6.283 + iTime) * .5 + .5;\n\n    float blink = smoothstep(0.15, .3, rnd);\n    vec3 col = .5 + .45*cos(6.2831*rnd + vec3(0., 1., 2.) - .25);\n    vec3 col2 = .5 + .45*cos(6.2831*dot(rb.cen, vec2(1.)) + vec3(2., 3., 1.) - .25);\n    col = mix(col, pow(col*col2, vec3(.65))*2., .25); \n    col = mix(col, col2.yxz,  float(rb.r * rb.s) / float(N*N*2)*blink);\n    \n    // cA and sA are the cos/sin of the angle at vertice A\n    float cA = dot(grids[rb.r], grids[rb.s]);\n    float sA = sqrt(1. - cA * cA);\n\n    float dcen = dot(q, q) * .95;\n\n    if(rnd > .2)\n    {\n        q.xy = -q.xy; // randomly flip the tunnels to make some cubes look impossible\n        col *= max(1.25 - dcen, 0.);\n    }\n    else { col *= max(dcen + 0.55, 1.); }\n\n    // distance to the boundary of the face\n    float dface = sdPoly4(p, rb.verts);\n\n    // distance to the face border\n    float dborder = max(dface, -(dface + sf*4.));\n\n    // distance to the tunnel of the face\n    vec2 q1 = q * 4. / hs;\n    float dtunnel = min(sdPoly4(q1, rb.inset1), sdPoly4(q1, rb.inset2));\n\n    // distance to the hole of the face,\n    // we choose the size of the hole to half the width/height of the rhombus.\n    // note each rhombus has unit side length, so sA is twice the distance\n    // from the center to its four edges.\n    float dhole = dface + sA / hs;\n    \n    float dcross = 1e5;\n\n#ifdef SOME_CLOSED_FACES\n    // really dirty, maybe should put into a function\n    if(abs(rnd - 0.5) > .495)\n    {\n        dhole += 1e5; dtunnel += 1e5;\n        dcross = min(dcross, getCross(p, rb));\n    }\n#endif\n\n    // shade the tunnels by the type of the rhombus\n    float shade;\n\n    float id = floor(hash21(vec2(float(rb.r), float(rb.s))) * float(N));\n\n    // qd is our shading direction\n    int ind = cA >= 0. ? 0 : 1;\n    float qd = dot(q, rb.cen - rb.verts[ind]);\n    \n    shade = .7 -  smoothstep(-sf*2., sf*2., -sign(rnd - .5)*qd) * clamp(id/float(N), 0.2, 0.6);\n\n    // draw the face border, multiply a factor 0.9 makes the edge look more antialiased\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., dborder)) * 0.9);\n\n    // add a thin bounding box around the hole\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., abs(dface + sA/8.)))*.5);\n    \n    // draw the black hole\n    col = mix(col, vec3(0), (1. - smoothstep(-sf*2., sf*2., dhole)));\n    \n    // shade the tunnels\n    col = mix(col, vec3(1), (1. - smoothstep(-sf*4., 0., dtunnel-sf*4.)) * shade);\n    \n    // redraw the border of the hole to fix some tiny artifacts\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(dhole))));\n    \n    // highlight the edges\n    col = mix(col, col * 1.5, (1. - smoothstep(sf*6., sf*12., dborder)) * .8);\n\n    // draw the crosses on solid faces\n    col = mix(col, vec3(0.), (1. - smoothstep(0., sf*6., dcross)) * .5);\n\n    // adjust luminance of faces by their types\n    col *= min(id / float(N) + .7, 1.);\n\n    // draw hatch lines on the face to add some decorate pattern.\n    // we get line direction first\n    vec2 diag = (rb.verts[0] - rb.cen);\n    float dd = cA < 0. ? dot(q, diag) : dot(q, vec2(-diag.y, diag.x));\n    \n    float hatch = clamp(sin(dd * 60. * PI) * 2. + .5, 0., 1.);\n    float hrnd = hash21(floor(q * 40.) + 0.73);\n    if (hrnd > 0.66) hatch = hrnd;\n\n    // we dont't want the hatch lines to show on top of the hole and tunnel\n    if (dtunnel < 0.0 || dhole < 0.0) hatch = 1.0;\n    col *= hatch *.25 + .75;\n\n    uv = fragCoord / iResolution.xy;\n    col *= pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .125) * .75 + .25;\n    fragColor = vec4(sqrt(max(col, 0.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2803, 2887, 2906, 2906, 3382], [3384, 3437, 3473, 3473, 3584], [3586, 3661, 3683, 3683, 3751], [3753, 3753, 3787, 3787, 3823], [4406, 4524, 4565, 4565, 4608], [5271, 5388, 5421, 5421, 5560], [7062, 7274, 7315, 7315, 7687], [7689, 7745, 7781, 7781, 8717], [8719, 8719, 8755, 8755, 9199], [9202, 9202, 9259, 9259, 13589]], "test": "untested"}
{"id": "WsKBzG", "name": "Plexus 2 (universe within)", "author": "curiouspers", "description": "Learning from art of code videos https://www.youtube.com/watch?v=3CycKKJiwis\n\nMain code is in Buffer A\n\nCommon, Buffer B, Image stages are fork of https://www.shadertoy.com/view/ts2yWm", "tags": ["plexus"], "likes": 38, "viewed": 2811, "published": 3, "date": "1607442378", "time_retrieved": "2024-07-30T20:31:42.317772", "image_code": "// Please Enable music on Buffer A iChannel0 (press pause and press play again), idk why it's not playing sometimes\n// If someone knows how to fix this soundcloud issue, please let me know\n// Main code is in Buffer A based on \"Plexus (universe within)\" by BIgWings. https://www.youtube.com/watch?v=3CycKKJiwis\n// Based on this look https://gist.github.com/ylegall/ce09fad5dfea15a46abbe8cf3f47e613\n// Common, Buffer B, Image stages are fork of https://www.shadertoy.com/view/ts2yWm\n// 2020-12-08 21:04:39\n\n// stage 2: \"post\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [debugging code]\n    \n    #if 0\n    //  ^ set this to 1 to skip the shader stage\n    fragColor=pow(texelFetch(D,ivec2(fragCoord),0),vec4(1.2));\n    return;\n    #endif\n    \n    // [shadertoy fix-up]\n    \n    P=acos(-1.),T=2.*P;    // calculate pi and tau\n    c=.0*R,m=c;            // init c and m as vec4(0)\n    \n    // ^ Both of these steps are done outside\n    //   the main function in the actual intro.\n\n    // [common code across all stages]\n    \n    vec2 v=gl_FragCoord.xy;  // get short mutable pixel coord\n    r=vec4(v,R.yz);          // init random vector using pixel coord + time\n    S();S();S();S();         //   and hash it 8 times\n    S();S();S();S();         // *shuffle*, *shuffle*, *shuffle*\n\n    float tt=R.z*7./48.,     // current chord playing in the soundtrack\n    w=floor(tt)*step(2.,tt), // camera movement offset\n    z=1.-.3*smoothstep(-.7,.0,-abs(tt-2.1))   // zoom around 00:14\n        +.2*smoothstep(-1.,0.,-abs(tt-20.));  // zoom around 02:17\n    if(tt<8.)z-=pow(tt/8.,48.);               // camera plunge at 00:54\n    \n    // ^ None of these camera specific vars are needed\n    //   in this stage and they are only here for completeness.\n\n    // [stage specific code]\n\n    // get uv\n    v/=R.xy;\n    \n    // calculate bloom\n    for(float a=.0;a<T;a+=.63)\n        c+=max(textureLod(D,v+7.8*pl(a)/R.xy/*+.011*R.xy/R.x*/,5.5)-.06,0.);\n    \n    // ^ The bloom is a simple mipmap blur with circular sampling to make it less blocky.\n    //   The code commented out above is needed in the intro to offset the texel centers\n\t//   from 'lower left corner' (default in OpenGL) to 'center' (used in Shadertoy).\n    //   The constant used for the offset is calculated like this:\n    //   offset = texel_size/2 = pow(2,-mipmap)/2 = 1/(2^6.5) = ~0.0110485\n    \n    // final color\n    c=pow(texture(D,v)+.03*c,vec4(1.1))+.01*(r.x-.5);\n\t//      ^color      ^bloom  ^gamma    ^film noise\n    \n    // [common code across all stages]\n    \n    fragColor=c;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Please Enable music on Buffer A iChannel0 (press pause and press play again), idk why it's not playing sometimes\n// If someone knows how to fix this soundcloud issue, please let me know\n// Main code is in Buffer A based on \"Plexus (universe within)\" by BIgWings. https://www.youtube.com/watch?v=3CycKKJiwis\n// Based on this look https://gist.github.com/ylegall/ce09fad5dfea15a46abbe8cf3f47e613\n// Common, Buffer B, Image stages are fork of https://www.shadertoy.com/view/ts2yWm\n// 2020-12-08 21:04:39\n\n//https://www.shadertoy.com/embed/WsKBzG?gui=true&t=1&paused=false&muted=false\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define START_TIME  10. \n\nfloat DistLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa-ba*t);\n}\nfloat N21(vec2 p) {\n    p = fract(p*vec2(233.34, 851.73));\n    p += dot(p, p+23.456);\n    return fract(p.x*p.y);\n}\nvec2 N22(vec2 p) {\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\nvec2 GetPos(vec2 id, vec2 offs) {\n    /*\n    vec2 n = N22(id);\n    float x = sin(iTime*n.x);\n    float y = cos(iTime*n.y);    \n    return vec2(x,y)*.4;\n    */\n    // same as above\n    \n    /*vec2 n = N22(id+offs)*(iTime+START_TIME);\n    return offs+sin(n)*.4;*/\n    vec2 n = N22(id+offs)*(iTime+START_TIME);\n    return offs+sin(n)*.4;\n}\nvec2 GetPosNew(vec2 id, vec2 offs) {\n\n    vec2 n = N22(id+offs)*(sin((iTime+START_TIME))*0.5+2.2); // 0.5+1.5 regulates randomness of movements\n    float radial = sin(length(id+offs)-(iTime+START_TIME/2.))*2.;\n    return offs+sin((n*1.2)+vec2(radial,radial))*.4;//+offs+sin(n)*.4; \n\n}\nvec4 Line(vec2 p, vec2 a, vec2 b){\n    float d = DistLine(p,a,b);\n    float m = S(.05, .01, d);\n    float d2 = length(a-b);\n    m *= S(1.5, .8, d2)*.5;\n    vec3 col = mix(vec3(0.38,0.87,1.0), vec3(0.945,0.161,1.000), d2*d2*d2*d2-0.2);\n    \n    return vec4(col,m*1.3);\n}\n\nvec3 Layer(vec2 uv, float fft) {\n    vec3 m = vec3(0.);\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n        \n    // points\n    vec2 p[9];\n    int i = 0;\n    for(float y=-1.; y<=1.; y++) {\n        for(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPosNew(id, vec2(x,y));\n        }        \n    }\n    \n    // light waves\n    float radial = abs( (sin(length(uv)-(iTime+START_TIME/2.))));\n    float depth = fract((uv.y/22.-0.19))*1.5;\n    float r = radial * (1.0-length(uv/20.))*0.5;\n    r = r*r + depth*depth;\n    //m+= r*r;\n    r = radial*0.1*r;//*(uv.y+5.5);;\n    m += r *vec3(1.000,0.561,0.965) *  (fft);\n    \n    // main part\n    float t = iTime*10.;\n    for(int i=0; i<9; i++){\n        vec4 l = Line(gv, p[4], p[i]);\n        m += l.w*l.rgb;\n            \n        vec2 j = (p[i]-gv) * (15. -fft*6.);\n        float sparkle = 1./dot(j,j);\n        \n\n        m += clamp(sparkle*vec3(0.137,0.416,0.482), 0., 1.);// *(sin(t+fract(p[i].x)*10.)*.2+.8)\n    }\n\n    vec4 l = Line(gv, p[1], p[3]);\n    m += l.w*l.rgb;\n    l = Line(gv, p[1], p[5]);\n    m += l.w*l.rgb;\n    l = Line(gv, p[7], p[3]);\n    m += l.w*l.rgb;\n    l = Line(gv, p[7], p[5]);\n    m += l.w*l.rgb;\n    \n    return vec3(m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 gridUv = uv*21.-7.;\n    vec2 mouse = (iMouse.xy/iResolution.xy)-.5;\n    \n\tfloat fft = texture( iChannel0, vec2(0.02,0.25) ).x; \n    fft = (fft == 0.0) ? 0.3 : fft; // dirty hack when music is not playing\n    \n\tvec3 col = Layer(gridUv-mouse, fft)*1.; \n    \n    float gradient = uv.y;\n    vec3 fftcol = normalize(vec3( 4.0*fft*(1.0-fft), 1.0-fft, fft )) ;\n    gradient = gradient*.8- .1;\n    gradient *= fft*1.3;\n    col -= gradient*fftcol*0.2;\n    \n    \n    // test uvs\n    //vec2 gv = fract(gridUv-mouse)-.5;\n    //if (gv.x>0.4||gv.y>0.4) col = vec3(0.122,0.000,0.000);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 24850, "src": "https://soundcloud.com/proswell/103-kschzt-esem-ikiryo", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// Please Enable music on Buffer A iChannel0 (press pause and press play again), idk why it's not playing sometimes\n// If someone knows how to fix this soundcloud issue, please let me know\n// Main code is in Buffer A based on \"Plexus (universe within)\" by BIgWings. https://www.youtube.com/watch?v=3CycKKJiwis\n// Based on this look https://gist.github.com/ylegall/ce09fad5dfea15a46abbe8cf3f47e613\n// Common, Buffer B, Image stages are fork of https://www.shadertoy.com/view/ts2yWm\n// 2020-12-08 21:04:39\n\n// shader uniforms \n#define R vec4(iResolution.xy, mod(iTime, 600.), 0)\n#define D iChannel0\n\n// ^ R.w is the shader stage in the actual intro,\n//   so intead of having 3 different shaders (one for each stage),\n//   I only have a single shader which I run in a loop.\n//   This approach makes the framework more compact\n//   and allowes for a lot of minification in the shader.\n\n// global variables\nfloat P,T;   // pi, tau\nvec4 r,c,m;  // random vector, color, mask\n\n// shuffle function\nvoid S()\n{\n    // hash global \"random vector\" variable\n    r=fract(1e4*sin(r)+r.wxyz);\n}\n\n// polar function\nvec2 pl(float a)\n{\n    // angle -> point on unit circle\n    return vec2(cos(a),sin(a));\n}\n\n// rotation functions\nmat3 rx(float a){return mat3(1,0,0,0,cos(a),sin(a),0,-sin(a),cos(a));}\nmat3 ry(float a){return mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));}\n\n// 2D hash function\nvec2 H(vec2 p)\n{\n    vec3 r=vec3(p,1);\n    \n    for(int i=0;i<4;i++)\n        r=fract(1e4*sin(r)+r.yzx);\n    \n    return r.xy;\n}\n\n// 2D continuous noise function\nvec2 N(vec2 p)\n{\n    vec2 i=floor(p),f=p-i,o=vec2(0,1);\n    \n    return mix(mix(H(i),\n                   H(i+o),f.y),\n               mix(H(i+o.yx),\n                   H(i+o.y),f.y),f.x);\n}\n\n// 2D continuous perlin noise function\nvec2 pr(vec2 u)\n{\n    vec2 y=.0*u,n=y+2.;\n    \n    for(int i=0;i<8;i++)\n        y+=N(u*n)/n,n*=2.;\n    \n    return y;\n}\n", "buffer_b_code": "// Please Enable music on Buffer A iChannel0 (press pause and press play again), idk why it's not playing sometimes\n// If someone knows how to fix this soundcloud issue, please let me know\n// Main code is in Buffer A based on \"Plexus (universe within)\" by BIgWings. https://www.youtube.com/watch?v=3CycKKJiwis\n// Based on this look https://gist.github.com/ylegall/ce09fad5dfea15a46abbe8cf3f47e613\n// Common, Buffer B, Image stages are fork of https://www.shadertoy.com/view/ts2yWm\n// 2020-12-08 21:04:39\n\n// stage 1: \"tracer\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [debugging code]\n    \n    #if 0\n    //  ^ set this to 1 to skip the shader stage\n    fragColor=2.*texelFetch(D,ivec2(fragCoord),0);\n    return;\n    #endif\n    \n    #define CUSTOM_SAMPLE_COUNT 20\n    \n    // [shadertoy fix-up]\n    \n    P=acos(-1.),T=2.*P;    // calculate pi and tau\n    c=.0*R,m=c;            // init c and m as vec4(0)\n    \n    // ^ Both of these steps are done outside\n    //   the main function in the actual intro.\n\n    // [common code across all stages]\n    \n    vec2 v=gl_FragCoord.xy;  // get short mutable pixel coord\n    r=vec4(v,R.yz);          // init random vector using pixel coord + time\n    S();S();S();S();         //   and hash it 8 times\n    S();S();S();S();         // *shuffle*, *shuffle*, *shuffle*\n\n    float tt=R.z*7./48.,     // current chord playing in the soundtrack\n    w=1.,//floor(tt)*step(2.,tt), // camera movement offset\n    z=1.;\n\n    // [stage specific code]\n    \n    // sample loop\n    #ifdef CUSTOM_SAMPLE_COUNT\n    for(int i=0;i<CUSTOM_SAMPLE_COUNT;i++)\n    #else\n    for(int i=0;i<200;i++)\n    #endif\n    {\n        // update random vector to keep it random\n        S();\n        \n        \n        \n        // camera movement\n\t\tfloat h=(sin(tt*2.)*0.5+0.5)*0.50,\n              s=-0.5*pow(1.-h,5.5);\n        \n        \n        vec2  f=.02*sqrt(r.z+0.2)*pl(10.0*r.w),             // depth of field\n              u=(v+r.xy+0.5-.74*R.xy)/R.y,            \t\t // pixel uv\n             rv=vec2(-3.6,0.)+pl(R.z/2.).xy/5.; \t\t\t // rotation vector\n        \n        // camera setup\n        mat3 rm=rx(.3*rv.x)*ry(.6*rv.y);        // calculate rotation matrix\n        vec3 o=rm*vec3(z*(.45+0.3*s)*f,-s-1.),           // get camera origin\n             d=rm*normalize(vec3(z*u-f,s+2.) );  // get camera direction\n        \n        // get color from screen\n        c+=texelFetch(D,ivec2(R.y*(o.xy-d.xy*o.z/d.z)+.5*R.xy),0) // intersect ray with screen and fetch texture\n           \t+.01*pow(.5+.5*d.y,3.);                               // add super simple skybox\n        \n        // ^ Because I can be sure that it's always going to hit the same geometry,\n        //   I can directly calculate the texture coordinate from camera direction and orientation.\n        //   This shortcut is not only great for size, but also performance.\n    }\n    \n    // brightness correction\n    #ifdef CUSTOM_SAMPLE_COUNT\n    c*=1.6/float(CUSTOM_SAMPLE_COUNT);\n    #else\n    c/=125.;\n    #endif\n\n    // [common code across all stages]\n    \n    fragColor=c;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 525, 582, 606, 2556]], "test": "untested"}
{"id": "tsVfRG", "name": "Pirellyon", "author": "Pirellyon", "description": "Next world", "tags": ["cineshader"], "likes": 1, "viewed": 9751, "published": 3, "date": "1607436914", "time_retrieved": "2024-07-30T20:31:43.069761", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Calculate the to center distance\n    float d = length(uv - 0.5) * 2.0;\n    \n    // Calculate the ripple time\n    float t = d * d * 25.0 - iTime * 3.0;\n    \n    // Calculate the ripple thickness\n    d = (cos(t) * 0.5 + 0.5) * (1.0 - d);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(t / 20.0 + uv.xyx + vec3(0.0,2.0,4.0));\n\n    // Set the output color to rgb channels and the thickness to alpha channel\n    // AO is automatically calculated\n    fragColor = vec4(col, d);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Pirellyon\",\n\t\"description\": \"Next world\",\n\t\"model\": \"person\"\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 656]], "test": "untested"}
{"id": "3dKBzy", "name": "uli3se1", "author": "uli3se", "description": "sss", "tags": ["sss"], "likes": 4, "viewed": 597, "published": 3, "date": "1607426270", "time_retrieved": "2024-07-30T20:31:44.004262", "image_code": "/*\n\"Diamond test\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nLamp lamps[3];\n    \nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n\nvec3 campos = vec3(0., 0.5, 5.);\nvec3 camdir = vec3(0., -0.1, -1.);\nfloat fov = 5.;\n\nconst vec3 ambientColor = vec3(0.7);\nconst float ambientint = 0.08;\n\n#define specular\n//#define color_disp\n//#define only_shape\n//#define show_not_finished\nconst int nb_refr = 7; \n\nconst float specint = 0.2;\nconst float specshin = 20.;\n\nconst float normdelta = 0.0004;\nconst float maxdist = 55.;\n\nconst float ior = 2.418;\nconst float ior_r = 2.408;\nconst float ior_g = 2.424;\nconst float ior_b = 2.432;\nconst vec3 diamondColor = vec3(.98, 0.95, 0.9);\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.9;\nconst int aasamples = 1;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat map_simple(vec3 pos)\n{   \n    float angle = 2.*pi*iMouse.x/iResolution.x;\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\n    \n    vec3 posr = pos;\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    float d = 1.05;\n    float s = atan(posr.y, posr.x);\n    \n    vec3 flatvec = vec3(cos(s), sin(s), 1.444);\n    vec3 flatvec2 = vec3(cos(s), sin(s), -1.072);\n     \n    float d1 = dot(flatvec, posr) - d;                        // Crown\n    d1 = max(dot(flatvec2, posr) - d, d1);                    // Pavillon\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.35, d1);         // Table\n    return d1;\n}\n\nfloat map(vec3 pos)\n{     \n    float angle = 2.*pi*iMouse.x/iResolution.x;\n    float angle2 = -2.*pi*iMouse.y/iResolution.y;\n    \n    vec3 posr = pos;\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle));\n    \n    float d = 0.94;\n    float b = 0.5;\n\n    float af2 = 4./pi;\n    float s = atan(posr.y, posr.x);\n    float sf = floor(s*af2 + b)/af2;\n    float sf2 = floor(s*af2)/af2;\n    \n    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);\n    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);\n    vec3 flatvec3 = vec3(cos(s), sin(s), 0);\n    float csf1 = cos(sf + 0.21);\n    float csf2 = cos(sf - 0.21);\n    float ssf1 = sin(sf + 0.21);\n    float ssf2 = sin(sf - 0.21);\n    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);\n    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);\n    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);\n    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);\n    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);\n     \n    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets\n    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets\n    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table\n    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet\n    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle\n    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\n    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets\n    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets\n    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets\n    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets\n    return d1;\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 4.2;\n    float dist;\n    \n    // \"Bounding\" tracing\n    if (!inside)\n    {\n  \t\tfor (int i = 0; i < 12; ++i)\n    \t{\n    \t\tvec3 pos = ray*t + cam;\n    \t\tdist = map_simple(pos);\n        \tif (dist>maxdist || abs(dist)<0.001)\n            \tbreak;\n        \tt+= dist*0.95;\n  \t\t}\n    }\n\n    // \"Actual\" tracing\n  \tfor (int i = 0; i < 30; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tdist = inside?-map(pos):map(pos);\n        if (dist>maxdist)\n            break;\n        t+= dist*(inside?0.4:0.8);\n  \t}\n  \treturn t;\n}\n\n// Old slower version (but a bit more precise)\nfloat trace_sl(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 4.;\n  \tfor (int i = 0; i < 80; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = inside?-map(pos):map(pos);\n        if (dist>(inside?3.:maxdist) || abs(dist)<0.001 || (inside && i>30))\n            break;\n        t+= dist*0.4;\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e, bool inside)\n{\n    vec2 q = vec2(0, e);\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n  \t#ifdef only_shape\n  \treturn vec3(0.35, 0.7, 1.0);\n  \t#else\n    return vec3(0.);\n    #endif\n}\n\nvec3 sky_color(vec3 ray)\n{\n\tvec3 rc = texture(iChannel2, ray).rrr;\n    for (int l=0; l<3; l++)\n        rc+= 1.5*normalize(lamps[l].color)*lamps[l].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[l].position - campos))), 200.);\n    return rc;\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(0., 0.9, r);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, bool inside)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    vec3 col;\n    \n    // Diffuse shading\n    if (!inside)\n    {\n    \tfloat diff = clamp(dot(norm, pli), 0., 1.);\n    \tcol = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\n    }\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, bool inside)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, inside);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray, bool inside)\n{\n    float tx = trace(tpos, ray, maxdist, inside);\n    vec3 col;\n    int objnr;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<10.)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        if (!inside)\n        {\n            // Coloring\n        \tcol = obj_color(norm, pos) + ambientColor*ambientint;\n        \tobjnr = 1;\n        }\n        \n        // Shading\n        col = lampsShading(norm, pos, col, inside);\n  }\n  else\n  {\n      // Sky\n      col = sky_color(ray);\n      objnr = 3;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord, vec3 campos, float ior)\n{   \n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 5., 0.1);\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.7, .8, 1.), 5., 0.1);\n  lamps[2] = Lamp(vec3(-1.3, 0.8, -1.5), vec3(1., .95, .8), 3.5, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray, false);\n  vec3 col = traceinf.col;\n    \n  #ifdef only_shape\n  \treturn vec4(col, 1.0);\n  #else\n    \n  if (traceinf.objnr==1)\n  {\n  \t\tvec3 norm = traceinf.norm;\n        vec3 ray_r = refract(ray, traceinf.norm, 1./ior);\n        vec3 ray_r2;\n      \n        int n2;\n        for (int n=0; n<nb_refr; n++)\n        {\n        \ttraceinf = trace0(traceinf.pos, ray_r, true);\n        \tcol+= traceinf.col;\n        \tcol*= diamondColor;\n      \t\tray_r2 = refract(ray_r, traceinf.norm, ior);\n        \tif (length(ray_r2)!=0.)\n            {\n           \t\tcol+= sky_color(ray_r2)*diamondColor;\n                break;\n            }\n            ray_r2 = reflect(ray_r, traceinf.norm);\n            ray_r = ray_r2;\n            n2 = n;\n        }\n        if (n2==nb_refr-1)\n            #ifdef show_not_finished\n            col = vec3(1., 0., 1.);\n      \t\t#else\n            col+= sky_color(ray_r2)*diamondColor;\n      \t\t#endif\n                      \n        // Outer reflection\n        float r = fresnel(ray, norm, ior);\n        col = mix(col, sky_color(reflect(ray, norm)), r);\n  }\n  return vec4(col, 1.0);\n  #endif\n}\n\nvec4 render_rgb(vec2 fragCoord, vec3 campos)\n{\n    #ifdef color_disp\n    \tvec4 col;\n    \tcol.r = render(fragCoord, campos, ior_r).r;\n    \tcol.g = render(fragCoord, campos, ior_g).g;\n    \tcol.b = render(fragCoord, campos, ior_b).b;\n    \tcol.a = 1.;\n\treturn col;\n    #else\n    \treturn render(fragCoord, campos, ior);\n    #endif\n}\n\nvec4 render_aa(vec2 fragCoord, vec3 campos)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render_rgb(fragCoord + vec2(ox, oy), campos);\n       }\n    }\n    return vs/vec4(aasamples*aasamples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n       fragColor = render_aa(fragCoord, campos);    \n    \n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBzy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1074, 1074, 1114, 1114, 1244], [1246, 1246, 1274, 1274, 2015], [2017, 2017, 2038, 2038, 3984], [3986, 3986, 4048, 4048, 4570], [4572, 4619, 4684, 4684, 4952], [4954, 5000, 5048, 5048, 5282], [5284, 5284, 5321, 5321, 5417], [5419, 5419, 5445, 5445, 5670], [5672, 5789, 5835, 5835, 6051], [6053, 6053, 6127, 6127, 6751], [6753, 6753, 6817, 6817, 6973], [6975, 7031, 7095, 7095, 7348], [7350, 7350, 7403, 7403, 7955], [9517, 9517, 9563, 9563, 9844], [9846, 9846, 9891, 9911, 10273], [10275, 10275, 10330, 10330, 10390]], "test": "untested"}
{"id": "3sKBRG", "name": "Twisted alien hive", "author": "jarble", "description": "A twisted version of my [url=https://www.shadertoy.com/view/WtjyDz]\"Alien Hive\"[/url] fractal.", "tags": ["fractal"], "likes": 2, "viewed": 286, "published": 3, "date": "1607405730", "time_retrieved": "2024-07-30T20:31:44.787169", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale*2.0;\n    float result = 0.0;\n    p.yz *= rot(p.x/1000.0);\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/1.5;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth-dist;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.y += (sin(iTime)/8.0);\n    viewDir.x += (cos(iTime)/8.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 626, 626, 729], [733, 733, 768, 768, 1039], [1041, 1041, 1064, 1064, 1091], [1093, 1093, 1121, 1121, 1251], [1254, 1675, 1766, 1766, 2089], [2104, 2358, 2423, 2423, 2555], [2557, 2646, 2675, 2712, 3022], [3024, 3516, 3656, 3656, 4266], [4268, 4638, 4723, 4723, 5138], [5140, 5467, 5516, 5551, 5682], [5684, 5684, 5741, 5741, 6888]], "test": "untested"}
{"id": "3sKfDm", "name": "Mechanical System", "author": "oneshade", "description": "My attempt at simulating a mechanical system.", "tags": ["simulation", "kinematics", "mechanical"], "likes": 9, "viewed": 182, "published": 3, "date": "1607387546", "time_retrieved": "2024-07-30T20:31:45.538161", "image_code": "/*\nAfter watching a video on chaos by Derek Muller (Veritasium), I was captivated by\nthe triple pendulum and wanted to recreate it with a shader but unfortunately I know\nvery little about physics or kinematics. As a result, I ended up either coming up\nwith an intuitive answer or searching google for one so this is probably far from\naccurate. I think it is visually appealling enough for now though :)\n*/\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float width) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - width;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    color += 0.5 * max(smoothstep(unit, 0.0, line(uv, pole.xy, pole.zw, 0.05)), smoothstep(unit, 0.0, uv.y - pole.w));\n\n    vec2 linkageOrigin = pole.xy;\n    for (int i=0; i < linkages.length(); i++) {\n        vec2 linkage = getLinkage(i);\n        vec2 linkageEnd = linkageOrigin + vec2(cos(linkage.x), sin(linkage.x)) * linkages[i].z;\n        vec3 linkageColor = vec3(0.0, 0.0, 0.0);\n        linkageColor[int(mod(float(i), 3.0))] = smoothstep(unit, 0.0, line(uv, linkageOrigin, linkageEnd, 0.16 * linkages[i].z));\n        color = mix(color, linkageColor, clamp(dot(linkageColor, vec3(1)), 0.0, 1.0));\n        linkageOrigin = linkageEnd;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fragTexAddr = ivec2(fragCoord);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iFrame == 0) {\n        if (fragTexAddr.x < linkages.length() && fragTexAddr.y == 0) {\n            fragColor.xy = linkages[fragTexAddr.x].xy;\n        }\n    }\n\n    if (iFrame > 0) {\n        if (fragTexAddr.x < linkages.length() && fragTexAddr.y == 0) {\n            vec2 linkage = getLinkage(fragTexAddr.x);\n\n            // Total force:\n            float ftotal = 0.0;\n\n            // Gravitational force:\n            ftotal += -cos(linkage.x) * GRAVITY;\n\n            // The linkage should tend towards aligning with the linkage before it:\n            if (fragTexAddr.x > 0) {\n                int linkageBeforeIndex = fragTexAddr.x - 1;\n                vec2 linkageBefore = getLinkage(linkageBeforeIndex);\n\n                // Centrifugal force:\n                ftotal += -sin(linkage.x - linkageBefore.x) * linkages[linkageBeforeIndex].w * linkageBefore.y * linkageBefore.y * linkages[linkageBeforeIndex].z;\n            }\n\n            // The linkage should be pulled by the linkage after it:\n            if (fragTexAddr.x < linkages.length() - 1) {\n                int linkageAfterIndex = fragTexAddr.x + 1;\n                vec2 linkageAfter = getLinkage(linkageAfterIndex);\n\n                // Centrifugal force:\n                ftotal += cos(linkage.x - linkageAfter.x) * linkages[linkageAfterIndex].w * linkageAfter.y * linkageAfter.y * linkages[linkageAfterIndex].z;\n            }\n\n            // Acceleration:\n            linkage.y += ftotal / linkages[fragTexAddr.x].w;\n\n            // Friction:\n            linkage.y *= FRICTION; // How to include centripetal force?\n\n            linkage.x += linkage.y;\n            fragColor = vec4(linkage, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Gravitational and frictional constants:\nconst float GRAVITY = 0.01;\nconst float FRICTION = 0.99;\n\n// The top and bottom of the pole the first linkage is suspended from:\nconst vec4 pole = vec4(0.0, 0.25, 0.0, -0.375);\n\n// Starting conditions for each linkage (angle, angular velocity, length, mass):\nconst vec4[3] linkages = vec4[](vec4( 2.5, -0.18,  0.3, 2.0),\n                                vec4(4.82,  0.25, 0.25, 1.2),\n                                vec4( 4.1, -0.15,  0.2, 1.0));\n\n// Helper function for loading linkage information:\n#define getLinkage(id) texelFetch(iChannel0, ivec2(id, 0), 0).xy", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 407, 468, 468, 584], [586, 586, 641, 641, 1455]], "test": "untested"}
{"id": "tsyBzG", "name": "Oren-nayar vs lambert", "author": "ivanjm", "description": "OREN-NAYAR LADO IZQUIERDO Y LAMBERT LADO DERECHO\nGRAFICACION UNIDAD 4", "tags": ["onlightmodel"], "likes": 1, "viewed": 385, "published": 3, "date": "1607383270", "time_retrieved": "2024-07-30T20:31:46.373927", "image_code": "/**\nComparison of Oren-Nayar and Lambert diffuse lighting model\n\nYou can use the mouse to move the slider comparison\n\n*/\n\n\n/** Roughness value only affects Oren-Nayar Shading */\n#define ROUGHNESS 0.5\n\nconst float PI = 3.14159265359;\n\nfloat degToRad(float d) \n{\n    return d * PI / 180.;\n}\n\nmat4 makeYRotation(in float angleInRadians) \n{\n  float c = cos(degToRad(angleInRadians));\n  float s = sin(degToRad(angleInRadians));\n  mat4 r;\n  r[0].xyzw = vec4(c, 0, -s, 0);\n  r[1].xyzw = vec4(0, 1, 0, 0);\n  r[2].xyzw = vec4(s, 0, c, 0);\n  r[3].xyzw = vec4(0, 0, 0, 1);\n\n  return r;\n}\n\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = mat3(inverse(m))*p;\n    return q;\n}\n\nfloat sdSphere( vec3 p, float s)\n{\n\treturn length(p + vec3(.0, .5,0.0))-s * sin(iTime);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p + vec3(.0, .5, .0))-b,.0))-r;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k = .1;\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map( in vec3 p)\n{\n\tfloat res = .0;\n\tfloat resSph = sdSphere(p, 2.5);\n\n\tvec3 q = opTx(p, makeYRotation(5. * iTime));\n\tfloat resCube = udRoundBox(q, vec3(1.5), .3);\n\n\tres = smin(resCube, resSph);\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(.002,.0,.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 10.;\n\tfloat h          = 1.;\n    float t          = .0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<.001 || t>maxd ) break;\n\t    h = map( ro+rd*t);\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.;\n\t\n    return t;\n}\n\nfloat OrenNayar(vec3 ld,vec3 vd,vec3 sn,float r,float a) {\n  float LdotV = dot(ld, vd);\n  float NdotL = dot(ld, sn);\n  float NdotV = dot(sn, vd);\n\n  float s = LdotV - NdotL * NdotV;\n\n  float sigma2 = r * r;\n  float A = 1. - .5 * (sigma2/(((sigma2 + .33) + .000001)));\n  float B = .45 * sigma2 / ((sigma2 + .09) + .00001);\n    \n  float ga = dot(vd-sn*NdotV,sn-sn*NdotL);\n\n  return max(0., NdotL) * (A + B * max(0., ga) * sqrt(max((1.0-NdotV*NdotV)*(1.0-NdotL*NdotL), 0.)) / max(NdotL, NdotV));\n}\n\nvec2 res;\nfloat limit = 1.;\nvec3 lighting(in vec3 n, in vec3 lp, in vec3 p, float fragCoord)\n{\n\n    vec3 ld = normalize(lp - p);\n    vec3 vd = normalize(vec3(0., 0., 5.) - p);\n    if(iMouse.x == 0.)\n    {\n        limit = 0.0;\n    }\n    else{\n    \tlimit = iMouse.x/res.x;\n    \tlimit = limit * 2. - 1.;\n    \tlimit *= 16./9.;\n    }\n    float diff;\n    if(fragCoord <= limit)\n    {\n\t\tdiff = OrenNayar(ld, vd, n, ROUGHNESS, 1.);\n    }\n    else\n    {\n        diff = max(dot(ld, n), 0.);\n    }\n   \n\treturn vec3(diff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    res = iResolution.xy;\n\tvec2 q = uv * 2. - 1.;\n\tq.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = vec3(.0, .0, 5. );\n    vec3 rd = normalize( vec3(q,-1.) );\n\tvec3 col = vec3(0.0);\n    float t = intersect(ro,rd);\n    if( t>0. )\n    {\n    \tvec3 pos = ro+rd*t;\n        vec3 normal = calcNormal(pos);\n        vec3 light = vec3(lighting(normal, vec3(sin(iTime)*10., 10., 10.), pos, q.x));\n        col = light * vec3(.2, .4, .9) + vec3(.04);\n    }\n    \n\tcol *= smoothstep( .006, .008, abs(limit-q.x) );\n    \n    fragColor = vec4(col, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 234, 260, 260, 288], [290, 290, 336, 336, 576], [578, 578, 607, 607, 656], [658, 658, 692, 692, 747], [749, 749, 794, 794, 852], [854, 854, 886, 886, 990], [992, 992, 1015, 1015, 1207], [1209, 1209, 1241, 1241, 1450], [1452, 1452, 1495, 1495, 1737], [1739, 1739, 1797, 1797, 2233], [2263, 2263, 2329, 2329, 2747], [2749, 2749, 2806, 2806, 3388]], "test": "untested"}
{"id": "WdGBRG", "name": "Balls In Motion", "author": "dr2", "description": "Mouseable balls in transparent box", "tags": ["collision", "dynamics", "physics"], "likes": 16, "viewed": 429, "published": 3, "date": "1607341391", "time_retrieved": "2024-07-30T20:31:47.494930", "image_code": "// \"Balls In Motion\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (=0/1) optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 OrAng (vec3 p);\nvec3 OrAngT (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\n\nconst ivec3 nbEdge = ivec3 (5);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 ltPos, vnBall, hbSize, blkAng, vnBlk;\nfloat dstFar, hbMarg, bCylRad, bCylHt, baseRad, baseUp;\nint idObj, idBall;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst int txOff = 4;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d, tr, f, b;\n  dMin = dstFar;\n  p.y -= baseUp;\n  q = abs (OrAng (p));\n  sLen = vec4 (hbSize - hbMarg - 0.1, 0.);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + 0.05, 0.1),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + 0.05, 0.1)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + 0.05, 0.1));\n  DMIN (1);\n  b = length (hbSize.xy - hbMarg);\n  f = 0.5 * (baseUp - 0.05);\n  tr = 0.25;\n  sLen.xyz = vec3 (b + 6. * tr, f - tr, hbSize.z - hbMarg + 2. * tr);\n  d = PrCylDf (vec3 (q.xy, abs (q.z) - sLen.z + tr), 0.8 * tr, tr);\n  DMIN (3);\n  q = p;\n  q.xz = Rot2D (q.xz, blkAng.y);\n  q.yz = Rot2D (q.yz, blkAng.x);\n  d = min (PrRoundBoxDf (vec3 (q.xy, abs (q.z) - sLen.z),\n     vec3 (b + 4. * tr, tr, tr) - 0.1, 0.1),\n     PrRoundBoxDf (vec3 (abs (q.x) - b - 3. * tr, q.yz),\n     vec3 (tr, tr, sLen.z + tr) - 0.1, 0.1));\n  DMIN (2);\n  d = PrCylDf (vec3 (abs (q.x) - b - 4.5 * tr, q.yz).yzx, 0.8 * tr, tr);\n  DMIN (3);\n  q = p;\n  q.xz = Rot2D (q.xz, blkAng.y);\n  d = PrRoundBoxDf (vec3 (abs (q.xz) - sLen.xz, q.y + sLen.y).xzy,\n     vec3 (tr, f, tr) - 0.1, 0.1);\n  d = min (d, PrRoundBoxDf (vec3 (abs (q.x) - sLen.x, abs (q.y + sLen.y) - sLen.y, q.z),\n     vec3 (tr, tr, sLen.z + tr) - 0.1, 0.1));\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y + 2. * sLen.y).xzy,\n     vec3 (sLen.x, tr, tr) - 0.1, 0.1));\n  DMIN (2);\n  d = PrCylDf (vec3 (q.xz, q.y + 2. * sLen.y), 2. * tr, 1.4 * tr);\n  DMIN (3);\n  q = p;\n  q.y -= - 2. * f - 0.05;\n  d = PrRoundCylDf (q.xzy, baseRad, 0.1, 0.15);\n  DMIN (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.46 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n} \n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.46 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (txOff + 4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return step (0., sign (a.x) * sign (a.y));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nvec4 InCylHit (vec3 ro, vec3 rd)\n{\n  vec3 s, vn;\n  float d, a, b, w, srdy;\n  d = dstFar;\n  vn = vec3 (0.);\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - bCylRad * bCylRad);\n  if (w > 0.) {\n    srdy = sign (rd.y);\n    if (a > 0.) {\n      d = (- b + sqrt (w)) / a;\n      s = ro + d * rd;\n    } else s.y = bCylHt;\n    if (abs (s.y) < bCylHt) vn.xz = - s.xz / bCylRad;\n    else {\n      d = (- srdy * ro.y + bCylHt) / abs (rd.y);\n      vn.y = - srdy;\n    }\n  }\n  return vec4 (d, vn);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.5 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec4 vc, db4;\n  vec3 ltDir, vn, col, rg, vnCyl;\n  vec2 qw, wSize;\n  float dCyl, hy, y, b, a, f, ga, ltDist, sh;\n  bool isLit;\n  isLit = true;\n  sh = 1.;\n  db4 = InCylHit (ro + vec3 (0., - bCylHt, 0.), rd);\n  dCyl = db4.x;\n  vnCyl = db4.yzw;\n  if (vnCyl.y == 0.) {\n    ro += dCyl * rd;\n    vn = vnCyl;\n    hy = mod (ro.y / bCylHt + 0.5, 1.) - 0.5;\n    a = atan (vn.x, - vn.z) / pi;\n    wSize = vec2 (0.28, 0.33);\n    qw = abs (vec2 (mod (64. * 0.5 * (1. + a) + 0.5, 1.), abs (hy)) - 0.5) - 0.5 * wSize;\n    if (Maxv2 (abs (qw) - wSize * vec2 (0.43, 0.47)) < 0.) {\n      col = vec3 (0.1, 0.2, 0.5);\n      isLit = false;\n    } else {\n      col = vec3 (0.5, 0.6, 0.5);\n      if (Maxv2 (qw - 0.5 * wSize) > 0.) {\n        col = vec3 (0.7, 0.6, 0.6);\n        y = abs (abs (hy) - 0.5) - 0.5;\n        if (y > - 0.3/16.) {\n          col *= 0.9;\n          vn.xz = Rot2D (vn.xz, - pi * a);\n          vn.yz = Rot2D (vn.yz, 0.15 * pi * (1. - 2. * SmoothBump (0.15, 0.25, 0.05,\n             16. * (0.5 - y))) * sign (hy));\n          vn.xz = Rot2D (vn.xz, pi * a);\n        } else {\n          qw = 16. * vec2 (12. * a, hy);\n          rg = ShStagGrid (qw);\n          col *= rg.y * (1. - 0.2 * Noisefv2 (16. * qw));\n          rg.xz *= sign ((abs (vn.x) > abs (vn.z)) ? vn.x : vn.z);\n          if (abs (vn.x) > abs (vn.z)) {\n            if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n            else vn.xz = Rot2D (vn.xz, rg.x);\n          } else {\n            if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n            else vn.zx = Rot2D (vn.zx, rg.x);\n          }\n        }\n      }\n    }\n  } else if (vnCyl.y > 0.) {\n    ro += dCyl * rd;\n    HexVorInit ();\n    vc = HexVor (0.7 * ro.zx);\n    b = 1. - smoothstep (-0.2, -0.05, rd.y) * smoothstep (0.4, 0.8, dCyl / (1.6 * bCylRad));\n    vn = mix (vec3 (0., 1., 0.), normalize (vec3 (- vc.y, 4., - vc.z)),\n       b * SmoothBump (0.05, 0.13, 0.02, vc.x));\n    col = vec3 (0.65, 0.62, 0.62) * (0.7 + 0.3 * b * step (0.06 + 0.03 * vc.w, vc.x) *\n       (1. - 0.3 * Noisefv2 (16. * ro.xz)));\n  } else {\n    ro += dCyl * rd;\n    f = 0.;\n    qw = ro.xz / bCylRad;\n    ga = 2.39996;\n    for (float n = 0.; n < 128.; n ++) f += 1. - smoothstep (0.02, 0.025,\n       length (qw - sqrt (n / 128.) * sin (n * ga + vec2 (0.5 * pi, 0.))));\n    col = mix (vec3 (0.2, 0.2, 0.4), vec3 (1., 1., 0.7), f);\n    isLit = false;\n  }\n  if (isLit) {\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    sh = (vnCyl.y > -0.5) ? min (ObjSShadow (ro + 0.01 * ltDir, ltDir, ltDist), 0.6 + \n       0.4 * BallHitSh (OrAng (ro + vec3 (0., - baseUp, 0.)), OrAng (ltDir), 0.7 * ltDist)) : 1.;\n    col = col * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.)) +\n       0.1 * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, rob, rdb, vn, ltDir;\n  float dstBall, dstObj, db, ltDist, nDotL;\n  rob = OrAng (ro - vec3 (0., baseUp, 0.));\n  rdb = OrAng (rd);\n  db = BlkHit (rob, rdb);\n  dstBall = (db < dstFar) ? BallHit (rob, rdb) : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < min (dstBall, dstFar) && idObj == 4 && length (ro.xz + dstObj * rd.xz) < \n     baseRad - 0.1) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    rob = OrAng (ro - vec3 (0., baseUp, 0.));\n    rdb = OrAng (rd);\n    db = BlkHit (rob, rdb);\n    dstBall = (db < dstFar) ? BallHit (rob, rdb) : dstFar;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < min (dstBall, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.85, 0.8, 0.8, 0.2);\n    else if (idObj == 2) col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    else if (idObj == 3) col4 = vec4 (0.8, 0.7, 0.7, 0.2);\n    else if (idObj == 4) col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n  } else if (dstBall < dstFar) {\n    ro += dstBall * rd;\n    vn = OrAngT (vnBall);\n    col4 = vec4 (HsvToRgb (vec3 (mod (33. * float (idBall) / float (nBall), 1.),\n       0.1 + 0.9 * BallChqr (idBall, vnBall), 0.9)), 0.2);\n  }\n  ltDir = ltPos - ro;\n  ltDist = length (ltDir);\n  ltDir /= ltDist;\n  if (min (dstBall, dstObj) < dstFar) {\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (dstObj < dstBall) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) + 0.8 * nDotL) +\n       col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  } else col = BgCol (ro, rd);\n  if (db < min (dstObj, dstFar)) {\n    ro = rob + db * rdb;\n    ltDir = ltPos - ro;\n    ltDist = length (ltDir);\n    ltDir /= ltDist;\n    col *= 0.95;\n    vn = OrAngT (vnBlk);\n    col = mix (col, vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.), pow (1. - abs (dot (rd, vn)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float slVal, float msMode)\n{\n  vec4 wgBx[2];\n  vec3 c;\n  vec2 ut, ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.45 * asp, 0., 0.015 * asp, 0.2);\n  wgBx[1] = vec4 (0.45 * asp, -0.44, 0.02, 0.);\n  c = vec3 (0.3, 1., 0.3);\n  ut = 0.5 * uv - wgBx[0].xy;\n  ust = abs (ut) - wgBx[0].zw * vec2 (0.7, 1.);\n  if (Maxv2 (ust) < 0.) col = (Minv2 (abs (ust)) * canvas.y < 2.) ? 0.8 * c : vec3 (0.4);\n  ut.y -= (slVal - 0.5) * 2. * wgBx[0].w;\n  if (abs (length (ut * vec2 (1., 2.)) - 0.02) * canvas.y < 2.) col = c;\n  ut = 0.5 * uv - wgBx[1].xy;\n  if (length (ut) < wgBx[1].z) col = mix (((msMode > 0.) ? c.grb : c),\n     vec3 (0.4), smoothstep (2., 4., abs (length (ut) - 0.02) * canvas.y));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 col, rd, ro;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr, slVal, msMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  hbSize = stDat.xyz;\n  baseRad = 2.8 * hbSize.x;\n  msMode = stDat.w;\n  stDat = Loadv4 (1);\n  blkAng = stDat.xyz;\n  slVal = blkAng.z / (2. * pi);\n  stDat = Loadv4 (2);\n  stDat = Loadv4 (3);\n  el = stDat.x;\n  az = stDat.y;\n  vuMat = StdVuMat (el, az);\n  bCylRad = 56.;\n  bCylHt = 14.;\n  ro = vuMat * vec3 (0., -0.2 * bCylHt, -0.95 * bCylRad);\n  hbMarg = 0.4;\n  baseUp = 1.2 * length (hbSize - hbMarg) + 0.05;\n  ro.y += 0.5 * bCylHt;\n  zmFac = 5.5;\n  dstFar = 20. * length (hbSize);\n  ltPos = vec3 (0., 1.8 * bCylHt, -0.9 * bCylRad);\n  ltPos.xz = Rot2D (ltPos.xz, 0.2 * pi);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = ShowWg (uv, canvas, col, slVal, msMode);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec3 OrAng (vec3 p)\n{\n  p.xz = Rot2D (p.xz, blkAng.y);\n  p.yz = Rot2D (p.yz, blkAng.x);\n  p.xy = Rot2D (p.xy, blkAng.z);\n  return p;\n}\n\nvec3 OrAngT (vec3 p)\n{\n  p.xy = Rot2D (p.xy, - blkAng.z);\n  p.yz = Rot2D (p.yz, - blkAng.x);\n  p.xz = Rot2D (p.xz, - blkAng.y);\n  return p;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Balls In Motion\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (5);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.14159;\nconst int txOff = 4;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.0002;\n  grav = 1.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p, qm;\n  vec3 rm, vm, wm, blkAng;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    wgSel = -1;\n    el = -0.1 * pi;\n    az = 0.;\n    slVal = 0.75;\n    blkAng = vec3 (0., -0.5 * pi, 2. * pi * slVal);\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    msMode = stDat.w;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    slVal = blkAng.z / (2. * pi);\n    stDat = Loadv4 (2);\n    mPtrP.xyz = stDat.xyz;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    wgSel = int (stDat.z);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.45 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.45 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        blkAng.y = -0.5 * pi - 2. * pi * mPtr.x;\n        blkAng.x = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.1 * pi + pi * mPtr.y, -0.45 * pi, -0.05 * pi);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    blkAng = mod (blkAng + pi * vec3 (0.0003, 0.00031, 0.00032), 2. * pi);\n    slVal = blkAng.z / (2. * pi);\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    blkAng.z = 2. * pi * slVal;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, msMode);\n  else if (pxId == 1) stDat = vec4 (blkAng, 0.);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (el, az, float (wgSel), nStep);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Balls In Motion\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (5);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.14159;\nconst int txOff = 4;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.0002;\n  grav = 1.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p, qm;\n  vec3 rm, vm, wm, blkAng;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    wgSel = -1;\n    el = -0.1 * pi;\n    az = 0.;\n    slVal = 0.75;\n    blkAng = vec3 (0., -0.5 * pi, 2. * pi * slVal);\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    msMode = stDat.w;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    slVal = blkAng.z / (2. * pi);\n    stDat = Loadv4 (2);\n    mPtrP.xyz = stDat.xyz;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    wgSel = int (stDat.z);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.45 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.45 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        blkAng.y = -0.5 * pi - 2. * pi * mPtr.x;\n        blkAng.x = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.1 * pi + pi * mPtr.y, -0.45 * pi, -0.05 * pi);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    blkAng = mod (blkAng + pi * vec3 (0.0003, 0.00031, 0.00032), 2. * pi);\n    slVal = blkAng.z / (2. * pi);\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    blkAng.z = 2. * pi * slVal;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, msMode);\n  else if (pxId == 1) stDat = vec4 (blkAng, 0.);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (el, az, float (wgSel), nStep);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Balls In Motion\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (5);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.14159;\nconst int txOff = 4;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.0002;\n  grav = 1.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p, qm;\n  vec3 rm, vm, wm, blkAng;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    wgSel = -1;\n    el = -0.1 * pi;\n    az = 0.;\n    slVal = 0.75;\n    blkAng = vec3 (0., -0.5 * pi, 2. * pi * slVal);\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    msMode = stDat.w;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    slVal = blkAng.z / (2. * pi);\n    stDat = Loadv4 (2);\n    mPtrP.xyz = stDat.xyz;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    wgSel = int (stDat.z);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.45 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.45 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        blkAng.y = -0.5 * pi - 2. * pi * mPtr.x;\n        blkAng.x = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.1 * pi + pi * mPtr.y, -0.45 * pi, -0.05 * pi);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    blkAng = mod (blkAng + pi * vec3 (0.0003, 0.00031, 0.00032), 2. * pi);\n    slVal = blkAng.z / (2. * pi);\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    blkAng.z = 2. * pi * slVal;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, msMode);\n  else if (pxId == 1) stDat = vec4 (blkAng, 0.);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (el, az, float (wgSel), nStep);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Balls In Motion\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec3 nbEdge = ivec3 (5);\nconst int nBall = nbEdge.x * nbEdge.y * nbEdge.z;\n\nvec3 hbSize, gVec;\nfloat nStep, fOvlap, fricN, fricS, fricT, delT;\nconst float txRow = 128.;\nconst float pi = 3.14159;\nconst int txOff = 4;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n      wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 1000.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.0002;\n  grav = 1.;\n  p = Loadv4 (txOff + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  p = Loadv4 (txOff + 4 * mId + 1);\n  vm = p.xyz;\n  qm = Loadv4 (txOff + 4 * mId + 2);\n  wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p, qm;\n  vec3 rm, vm, wm, blkAng;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + txOff) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    wgSel = -1;\n    el = -0.1 * pi;\n    az = 0.;\n    slVal = 0.75;\n    blkAng = vec3 (0., -0.5 * pi, 2. * pi * slVal);\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    msMode = stDat.w;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    slVal = blkAng.z / (2. * pi);\n    stDat = Loadv4 (2);\n    mPtrP.xyz = stDat.xyz;\n    stDat = Loadv4 (3);\n    el = stDat.x;\n    az = stDat.y;\n    wgSel = int (stDat.z);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.45 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.45 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        blkAng.y = -0.5 * pi - 2. * pi * mPtr.x;\n        blkAng.x = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.1 * pi + pi * mPtr.y, -0.45 * pi, -0.05 * pi);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n    blkAng = mod (blkAng + pi * vec3 (0.0003, 0.00031, 0.00032), 2. * pi);\n    slVal = blkAng.z / (2. * pi);\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    blkAng.z = 2. * pi * slVal;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if (pxId == 0) stDat = vec4 (hbSize, msMode);\n  else if (pxId == 1) stDat = vec4 (blkAng, 0.);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (el, az, float (wgSel), nStep);\n  else {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBRG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1140, 1140, 1162, 1162, 2703], [2705, 2705, 2738, 2738, 2922], [2924, 2924, 2945, 2945, 3202], [3204, 3204, 3238, 3238, 3669], [3672, 3672, 3719, 3719, 4097], [4099, 4099, 4141, 4141, 4343], [4345, 4345, 4378, 4378, 4726], [4728, 4728, 4762, 4762, 5254], [5256, 5256, 5282, 5282, 5632], [5634, 5634, 5683, 5683, 5925], [5927, 5927, 5958, 5958, 8737], [8739, 8739, 8774, 8774, 10761], [10763, 10763, 10836, 10836, 11524], [11526, 11526, 11579, 11579, 12979], [12981, 12981, 13027, 13027, 13074], [13076, 13076, 13118, 13118, 13169], [13171, 13171, 13228, 13228, 13304], [13306, 13306, 13331, 13331, 13727], [13729, 13729, 13750, 13750, 13863], [13865, 13865, 13887, 13887, 14006], [14008, 14008, 14030, 14030, 14057], [14059, 14059, 14081, 14081, 14108], [14110, 14110, 14155, 14155, 14258], [14260, 14260, 14317, 14317, 14400], [14402, 14402, 14438, 14438, 14644], [14646, 14646, 14676, 14676, 14789], [14791, 14791, 14815, 14815, 14937], [14939, 14939, 14963, 14963, 15193], [15195, 15195, 15219, 15219, 15279], [15305, 15305, 15325, 15325, 15545], [15547, 15547, 15569, 15569, 16165], [16199, 16199, 16223, 16223, 16283], [16285, 16285, 16309, 16309, 16439], [16441, 16441, 16466, 16466, 16652], [16654, 16654, 16675, 16675, 16830], [16924, 16924, 16949, 16949, 17072]], "test": "untested"}
{"id": "wdKBWm", "name": "percolation 1", "author": "FabriceNeyret2", "description": "Percolation with 8-connexity (green) and 4-connexity (blue). propag only towards top.\nThe proportion on empty space is decreasing vertically from 50% ( bottom ) to 17% (top).\nLeft: white noise. Right: blue noise.\nClick to zoom pattern.", "tags": ["simulation", "short", "percolation"], "likes": 8, "viewed": 357, "published": 3, "date": "1607328482", "time_retrieved": "2024-07-30T20:31:48.245922", "image_code": "// see full diffusion version here: https://www.shadertoy.com/view/tsVfzd\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n    if ( O.yz == vec2(0) ) O += O.w; // substrate (draw where not yet colored by percolation )\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u / R,\n          P = ( u + vec2(iFrame,0) );\n    if (iMouse.z>0.) P /= 2.;                                 // zoom pattern\n    float g = 1. + 2.*U.y; // exp2(3.*U.y);\n    int L = int(R.x/2.),\n        x = int (u.x) - L,\n        t = (iFrame/256)%4;                                   // hack to emulate a 1024 white noise texture\n    \n    O-=O;\n    if      (x==  0) O.r = 1.;                                // inject texture on right subwindow column\n    else if (x== -1) O.w = step( g * texelFetch(iChannel1, ivec2(P)%256 , 0)[t] , 1. ); // white noise\n    else if (x==L-1) O.w = step( g * texelFetch(iChannel2, ivec2(P)%1024, 0).x  , 1. ); // blue noise\n    else O = T(u+vec2(1,0));                                  // scroll\n        \n    u.x++;\n    if (u.y==.5) O.yz++;                                      // seed fluid for percolation in .yz\n    else \n        if(T(u).w > 0. &&  abs(x) > 1  ) {\n#define pull(l,x,y)  O.l = max( O.l, T(u+vec2(x,y)).l )       // pull contrib from(x,y)\n            for( int i=0; i<6; i++ ) pull(y, i%3-1, i/3-1 );  // 8-connexity layer in y\n            pull(z, 0,-1); pull(z, -1,0); pull(z, 1,0);       // 4-connexity layer in z\n        }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch(iChannel0, ivec2(u), 0 )\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 113, 113, 224]], "test": "untested"}
{"id": "tsKBDw", "name": "The Perfect Tongue", "author": "xenn", "description": "A mipmap-based approach to multiscale fluid dynamics.", "tags": ["simulation", "water", "fluid", "mipmap", "turbulence", "mip", "diffusion", "advection", "navier", "stokes", "eddy"], "likes": 17, "viewed": 731, "published": 3, "date": "1607315708", "time_retrieved": "2024-07-30T20:31:49.182418", "image_code": "// Fork of \"colour mixer\" by xenn. https://shadertoy.com/view/wdKBDw\n// 2020-12-07 04:28:18\n\n// Fork of \"Multiscale MIP Fluid\" by cornusammonis. https://shadertoy.com/view/tsKXR3\n// 2020-12-01 12:43:52\n\n/* \n\tCreated by Cornus Ammonis (2019)\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n/*\n\tThis is a mipmap-based approach to multiscale fluid dynamics.\n\n\tCheck the Common tab for lots of configurable parameters.\n\n\tClick to interact with your mouse. I'd recommend turning off the \"pump\" by\n\tsetting PUMP_SCALE to 0.0 on line 113 of the Common tab to play around with\n\tjust mouse interaction.\n\n\tBuffer B is a multiscale method for computing turbulence along the lines of \n\tthe Large Eddy Simulation method; multiscale curl is also computed in Buffer B, \n    to be passed along to Buffer C.\n\t\n\tBuffer C is a fairly conventional Vorticity Confinement method, also multiscale, \n    using the curl computed in Buffer B. It probably makes more sense to compute \n    each curl scale separately before accumulating, but for the sake of efficiency \n    and simplicity (a larger kernel would be required), I haven't done that here.\n\n\tBuffer D is a multiscale Poisson solver, which converges rapidly but not to an \n    exact solution - this nonetheless works well for the purposes of divergence \n    minimization since we only need the gradient, with allowances for the choice of\n    scale weighting. \n\n\tBuffer A computes subsampled advection and velocity update steps, sampling\n    from Buffers B, C, and D with a variety of smoothing options.\n\n\tThere are a number of options included to make this run faster.\n\n\tUsing mipmaps in this way has a variety of advantages:\n\n\t1. The scale computations have no duplicative or dependent reads, we only need \n       that for advection.\n\t2. No randomness or stochastic sampling is involved.\n\t3. The total number of reads can be greatly reduced for a comparable level of \n       fidelity to some other methods.\n\t4. We can easily sample the entire buffer in one pass (on average).\n\t5. The computational complexity is deferred to mipmap generation (though with\n       a large coefficient), because: \n\t6. The algorithm itself is O(n) with a fixed number of scales (or we could \n       potentially do scale calculations in parallel with mipmap generation, \n       equalling mipmap generation complexity at O(nlogn))\n\n\tNotable downsides:\n\n\t1. Using mipmaps introduces a number of issues, namely:\n       a. Mipmaps can introduce artifacts due to interpolation and downsampling. \n          Using Gaussian pyramids, or some other lowpass filtering method would \n          be better. \n       b. Using higher-order sampling of the texture buffer (e.g. bicubic) would \n          also be better, but that would limit our performance gains. \n       c. NPOT textures are problematic (as always). They can introduce weird \n          anisotropy issues among other things.\n\t2. Stochastic or large-kernel methods are a better approximation to the true\n       sampling distribution approximated here, for a large-enough number of\n       samples.\n    3. We're limited in how we construct our scale-space. Is a power-of-two stride \n       length on both axes always ideal, even along diagonals? I'm not particularly \n       sure. There are clever wavelet methods out there for Navier-Stokes solvers, \n       and LES in particular, too.\n\n*/\n\n\n#define BUMP 64.0\n\n#define D(d) -textureLod(iChannel1, fract(uv+(d+0.0)), mip).w\n\nvec2 diff(vec2 uv, float mip) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = float(1<<int(mip))*vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    return vec2(\n        0.5 * (d_e - d_w) + 0.25 * (d_ne - d_nw + d_se - d_sw),\n        0.5 * (d_n - d_s) + 0.25 * (d_ne + d_nw - d_se - d_sw)\n    );\n}\n\nvec4 contrast(vec4 col, float x) {\n\treturn x * (col - 0.5) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 dxy = vec2(0);\n    float occ, mip = 0.0;\n    float d   = D();\n    \n    // blur the gradient to reduce appearance of artifacts,\n    // and do cheap occlusion with mipmaps\n    #define STEPS 10.0\n    #define ODIST 02.50\n    for(mip = 1.0; mip <= STEPS; mip += 1.0) {\t \n        dxy += (1.0/pow(2.0,mip)) * diff(uv, mip-1.0);\t\n    \tocc += softclamp(-ODIST, ODIST, d - D(),1.0)/(pow(1.5,mip));\n    }\n    dxy /= float(STEPS);\n    \n    // I think this looks nicer than using smoothstep\n    occ = pow(max(0.0,softclamp(0.2,0.8,100.0*occ + 0.5,1.0)),0.5);\n \n    vec3 avd;\n    vec3 ld = light(uv, BUMP, 0.5, dxy, iTime, avd);\n    \n    float spec = ggx(avd, vec3(0,1,0), ld, 0.1, 0.1);\n    \n    #define LOG_SPEC 4000.0\n    spec = (log(LOG_SPEC+1.0)/LOG_SPEC)*log(1.0+LOG_SPEC*spec);    \n    \n    #define VIEW_VELOCITY\n    \n    #ifdef VIEW_VELOCITY\n\t\tvec4 diffuse = softclamp(0.0,1.0,6.0*vec4(texture(iChannel0,uv).xy,0,0)+0.5,2.0);    \n    #elif defined(VIEW_CURL)\n\t\tvec4 diffuse = mix(vec4(1,0,0,0),vec4(0,0,1,0),softclamp(0.0,1.0,0.5+2.0*texture(iChannel2,uv).w,2.0));    \n    #elif defined(VIEW_ADVECTION)\n\t\tvec4 diffuse = softclamp(0.0,1.0,0.0004*vec4(texture(iChannel0,uv).zw,0,0)+0.5,2.0); \n    #elif defined(VIEW_GRADIENT)\n    \tvec4 diffuse = softclamp(0.0,1.0,10.0*vec4(diff(uv,0.0),0,0)+0.5,4.0); \n    #else // Vorticity confinement vectors\n    \tvec4 diffuse = softclamp(0.0,1.0,4.0*vec4(texture(iChannel3,uv).xy,0,0)+0.5,4.0);\n    #endif\n    \n    \n    fragColor = (diffuse + 4.0*mix(vec4(spec),1.5*diffuse*spec,0.3));\n    fragColor = mix(1.0,occ,0.7) * (softclamp(0.0,1.0,contrast(fragColor,4.5),3.0));\n    \n    //fragColor = vec4(occ);\n    //fragColor = vec4(spec);\n    //fragColor = diffuse;\n    //fragColor = vec4(diffuse+(occ-0.5));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TURBULENCE_SAMPLER iChannel3\n#define CONFINEMENT_SAMPLER iChannel2\n#define POISSON_SAMPLER iChannel1\n#define VELOCITY_SAMPLER iChannel0\n\n#define V(d) texture(TURBULENCE_SAMPLER, fract(uv+(d+0.))).xy\n\nvec2 gaussian_turbulence(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec2 d =    V( t.ww); vec2 d_n =  V( t.wy); vec2 d_e =  V( t.xw);\n    vec2 d_s =  V( t.wz); vec2 d_w =  V(-t.xw); vec2 d_nw = V(-t.xz);\n    vec2 d_sw = V(-t.xy); vec2 d_ne = V( t.xy); vec2 d_se = V( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\n#define C(d) texture(CONFINEMENT_SAMPLER, fract(uv+(d+0.))).xy\n\nvec2 gaussian_confinement(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec2 d =    C( t.ww); vec2 d_n =  C( t.wy); vec2 d_e =  C( t.xw);\n    vec2 d_s =  C( t.wz); vec2 d_w =  C(-t.xw); vec2 d_nw = C(-t.xz);\n    vec2 d_sw = C(-t.xy); vec2 d_ne = C( t.xy); vec2 d_se = C( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\n#define D(d) texture(POISSON_SAMPLER, fract(uv+d)).x\n\nvec2 diff(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    return vec2(\n        0.5 * (d_e - d_w) + 0.25 * (d_ne - d_nw + d_se - d_sw),\n        0.5 * (d_n - d_s) + 0.25 * (d_ne + d_nw - d_se - d_sw)\n    );\n}\n\n#define N(d) texture(VELOCITY_SAMPLER, fract(uv+(d+0.)))\n\nvec4 gaussian_velocity(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec4 d =    N( t.ww); vec4 d_n =  N( t.wy); vec4 d_e =  N( t.xw);\n    vec4 d_s =  N( t.wz); vec4 d_w =  N(-t.xw); vec4 d_nw = N(-t.xz);\n    vec4 d_sw = N(-t.xy); vec4 d_ne = N( t.xy); vec4 d_se = N( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\nvec2 vector_laplacian(vec2 uv) {\n    const float _K0 = -20.0/6.0, _K1 = 4.0/6.0, _K2 = 1.0/6.0;\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec4 d =    N( t.ww); vec4 d_n =  N( t.wy); vec4 d_e =  N( t.xw);\n    vec4 d_s =  N( t.wz); vec4 d_w =  N(-t.xw); vec4 d_nw = N(-t.xz);\n    vec4 d_sw = N(-t.xy); vec4 d_ne = N( t.xy); vec4 d_se = N( t.xz);\n    \n    return (_K0 * d + _K1 * (d_e + d_w + d_n + d_s) + _K2 * (d_ne + d_nw + d_se + d_sw)).xy;\n}\n\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 tx = 1.0/iResolution.xy;\n\n    \n    vec2 turb, confine, div, delta_v, offset, lapl = vec2(0);\n    vec4 vel, adv = vec4(0);\n    vec4 init = N();\n\n    #ifdef RECALCULATE_OFFSET\n        for (int i = 0; i < ADVECTION_STEPS; i++) {\n            #ifdef BLUR_TURBULENCE\n            turb = gaussian_turbulence(uv + tx * offset);\n            #else\n            turb = V(tx * offset);\n            #endif\n\n            #ifdef BLUR_CONFINEMENT\n            confine = gaussian_confinement(uv + tx * offset);\n            #else\n            confine = C(tx * offset);\n            #endif\n\n            #ifdef BLUR_VELOCITY\n            vel = gaussian_velocity(uv + tx * offset);\n            #else\n            vel = N(tx * offset);\n            #endif\n\n            // an alternative, but seems to give less smooth results:\n            // offset += (1.0 / float(ADVECTION_STEPS)) * ...\n            offset = (float(i+1) / float(ADVECTION_STEPS)) * - ADVECTION_SCALE * (ADVECTION_VELOCITY * vel.xy + ADVECTION_TURBULENCE * turb - ADVECTION_CONFINEMENT * confine + ADVECTION_DIVERGENCE * div);\n\n            div = diff(uv + tx * DIVERGENCE_LOOKAHEAD * offset);\n\n            lapl = vector_laplacian(uv + tx * LAPLACIAN_LOOKAHEAD * offset);\n\n            adv += N(tx * offset);\n\n            delta_v += VELOCITY_LAPLACIAN * lapl + VELOCITY_TURBULENCE * turb + VELOCITY_CONFINEMENT * confine - DAMPING * vel.xy - DIVERGENCE_MINIMIZATION * div;\n        }\n        adv /= float(ADVECTION_STEPS);\n        delta_v /= float(ADVECTION_STEPS);\n    #else\n        #ifdef BLUR_TURBULENCE\n        turb = gaussian_turbulence(uv);\n        #else\n        turb = V();\n        #endif\n\n        #ifdef BLUR_CONFINEMENT\n        confine = gaussian_confinement(uv);\n        #else\n        confine = C();\n        #endif\n\n        #ifdef BLUR_VELOCITY\n        vel = gaussian_velocity(uv);\n        #else\n        vel = N();\n        #endif\n    \n    \toffset = - ADVECTION_SCALE * (ADVECTION_VELOCITY * vel.xy + ADVECTION_TURBULENCE * turb - ADVECTION_CONFINEMENT * confine + ADVECTION_DIVERGENCE * div);\n        \n    \tdiv = diff(uv + tx * DIVERGENCE_LOOKAHEAD * offset);\n        \n    \tlapl = vector_laplacian(uv + tx * LAPLACIAN_LOOKAHEAD * offset);\n    \t\n    \tdelta_v += VELOCITY_LAPLACIAN * lapl + VELOCITY_TURBULENCE * turb + VELOCITY_CONFINEMENT * confine - DAMPING * vel.xy - DIVERGENCE_MINIMIZATION * div;\n    \n        for (int i = 0; i < ADVECTION_STEPS; i++) {\n            adv += N((float(i+1) / float(ADVECTION_STEPS)) * tx * offset);   \n        }   \n        adv /= float(ADVECTION_STEPS);\n    #endif\n    \n\n    \n    // define a pump, either at the center of the screen,\n    // or alternating at the sides of the screen.\n    vec2 pq = 2.0*(uv*2.0-1.0) * vec2(1,tx.x/tx.y);\n    #ifdef CENTER_PUMP\n    \tvec2 pump = sin(PUMP_CYCLE*iTime)*PUMP_SCALE*pq.xy / (dot(pq,pq)+0.01);\n    #else\n    \tvec2 pump = vec2(0);\n    \t#define AMP 15.0\n    \t#define SCL -50.0\n        float uvy0 = exp(SCL*pow(pq.y,2.0));\n        float uvx0 = exp(SCL*pow(uv.x,2.0));\n        pump += -AMP*vec2(max(0.0,cos(PUMP_CYCLE*iTime))*PUMP_SCALE*uvx0*uvy0,0);\n    \n    \tfloat uvy1 = exp(SCL*pow(pq.y,2.0));\n        float uvx1 = exp(SCL*pow(1.0 - uv.x,2.0));\n        pump += AMP*vec2(max(0.0,cos(PUMP_CYCLE*iTime + 3.1416))*PUMP_SCALE*uvx1*uvy1,0);\n\n        float uvy2 = exp(SCL*pow(pq.x,2.0));\n        float uvx2 = exp(SCL*pow(uv.y,2.0));\n        pump += -AMP*vec2(0,max(0.0,sin(PUMP_CYCLE*iTime))*PUMP_SCALE*uvx2*uvy2);\n    \n    \tfloat uvy3 = exp(SCL*pow(pq.x,2.0));\n        float uvx3 = exp(SCL*pow(1.0 - uv.y,2.0));\n        pump += AMP*vec2(0,max(0.0,sin(PUMP_CYCLE*iTime + 3.1416))*PUMP_SCALE*uvx3*uvy3);\n    #endif\n    \n    fragColor = mix(adv + vec4(VELOCITY_SCALE * (delta_v + pump), offset), init, UPDATE_SMOOTHING);\n    \n    if (iMouse.z > 0.0) {\n        vec4 mouseUV = iMouse / iResolution.xyxy;\n        vec2 delta = normz(mouseUV.zw - mouseUV.xy);\n        vec2 md = (mouseUV.xy - uv) * vec2(1.0,tx.x/tx.y);\n        float amp = exp(max(-12.0,-dot(md,md)/MOUSE_RADIUS));\n        fragColor.xy += VELOCITY_SCALE * MOUSE_AMP * clamp(amp * delta,-1.0,1.0);\n    }\n    \n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define TURB_CH xy\n#define TURB_SAMPLER iChannel0\n#define DEGREE TURBULENCE_SCALES\n\n#define D(d) textureLod(TURB_SAMPLER, fract(uv+d), mip).TURB_CH\n\nvoid tex(vec2 uv, inout mat3 mx, inout mat3 my, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    vec2 d =    D( t.ww); vec2 d_n =  D( t.wy); vec2 d_e =  D( t.xw);\n    vec2 d_s =  D( t.wz); vec2 d_w =  D(-t.xw); vec2 d_nw = D(-t.xz);\n    vec2 d_sw = D(-t.xy); vec2 d_ne = D( t.xy); vec2 d_se = D( t.xz);\n    \n    mx =  mat3(d_nw.x, d_n.x, d_ne.x,\n               d_w.x,  d.x,   d_e.x,\n               d_sw.x, d_s.x, d_se.x);\n    \n    my =  mat3(d_nw.y, d_n.y, d_ne.y,\n               d_w.y,  d.y,   d_e.y,\n               d_sw.y, d_s.y, d_se.y);\n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvoid turbulence(vec2 fragCoord, inout vec2 turb, inout float curl)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     \n    mat3 turb_xx = (2.0 - TURB_ISOTROPY) * mat3(\n        0.125,  0.25, 0.125,\n       -0.25,  -0.5, -0.25,\n        0.125,  0.25, 0.125\n    );\n\n    mat3 turb_yy = (2.0 - TURB_ISOTROPY) * mat3(\n        0.125, -0.25, 0.125,\n        0.25,  -0.5,  0.25,\n        0.125, -0.25, 0.125\n    );\n\n    mat3 turb_xy = TURB_ISOTROPY * mat3(\n       0.25, 0.0, -0.25,  \n       0.0,  0.0,  0.0,\n      -0.25, 0.0,  0.25\n    );\n    \n    const float norm = 8.8 / (4.0 + 8.0 * CURL_ISOTROPY);  // 8.8 takes the isotropy as 0.6\n    float c0 = CURL_ISOTROPY;\n    \n    mat3 curl_x = mat3(\n        c0,   1.0,  c0,\n        0.0,  0.0,  0.0,\n       -c0,  -1.0, -c0\n    );\n\n    mat3 curl_y = mat3(\n        c0, 0.0, -c0,\n       1.0, 0.0, -1.0,\n        c0, 0.0, -c0\n    );\n    \n    mat3 mx, my;\n    vec2 v = vec2(0);\n    float turb_wc, curl_wc = 0.0;\n    curl = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mx, my, i);\n        float turb_w = TURB_W_FUNCTION;\n        float curl_w = CURL_W_FUNCTION;\n    \tv += turb_w * vec2(reduce(turb_xx, mx) + reduce(turb_xy, my), reduce(turb_yy, my) + reduce(turb_xy, mx));\n        curl += curl_w * (reduce(curl_x, mx) + reduce(curl_y, my));\n        turb_wc += turb_w;\n        curl_wc += curl_w;\n    }\n\n    turb = float(DEGREE) * v / turb_wc;\n    curl = norm * curl / curl_wc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 turb;\n    float curl;\n    turbulence(fragCoord, turb, curl);\n    fragColor = vec4(turb,0,curl);\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define CURL_CH w\n#define CURL_SAMPLER iChannel0\n#define DEGREE VORTICITY_SCALES\n\n#define CURL(d) textureLod(CURL_SAMPLER, fract(uv+(d+0.0)), mip).CURL_CH\n#define D(d) abs(textureLod(CURL_SAMPLER, fract(uv+d), mip).CURL_CH)\n\nvoid tex(vec2 uv, inout mat3 mc, inout float curl, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    mc =  mat3(d_nw, d_n, d_ne,\n               d_w,  d,   d_e,\n               d_sw, d_s, d_se);\n    \n    curl = CURL();\n    \n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvec2 confinement(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float k0 = CONF_ISOTROPY;\n    float k1 = 1.0 - 2.0*(CONF_ISOTROPY);\n\n    mat3 conf_x = mat3(\n       -k0, -k1, -k0,\n        0.0, 0.0, 0.0,\n        k0,  k1,  k0\n    );\n\n    mat3 conf_y = mat3(\n       -k0,  0.0,  k0,\n       -k1,  0.0,  k1,\n       -k0,  0.0,  k0\n    );\n    \n    mat3 mc;\n    vec2 v = vec2(0);\n    float curl;\n    \n    float cacc = 0.0;\n    vec2 nacc = vec2(0);\n    float wc = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mc, curl, i);\n        float w = CONF_W_FUNCTION;\n        vec2 n = w * normz(vec2(reduce(conf_x, mc), reduce(conf_y, mc)));\n        v += curl * n;\n        cacc += curl;\n        nacc += n;\n        wc += w;\n    }\n\n    #ifdef PREMULTIPLY_CURL\n        return v / wc;\n    #else\n    \treturn nacc * cacc / wc;\n    #endif\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(confinement(fragCoord),0,0);\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define VORT_CH xy\n#define VORT_SAMPLER iChannel0\n#define POIS_SAMPLER iChannel1\n#define POIS_CH x\n#define DEGREE POISSON_SCALES\n\n#define D(d) textureLod(VORT_SAMPLER, fract(uv+d), mip).VORT_CH\n#define P(d) textureLod(POIS_SAMPLER, fract(uv+d), mip).POIS_CH\n\nfloat laplacian_poisson(vec2 fragCoord) {\n    const float _K0 = -20.0/6.0, _K1 = 4.0/6.0, _K2 = 1.0/6.0;\n    vec2 texel = 1.0/iResolution.xy;\n    vec2 uv = fragCoord * texel;\n    vec4 t = vec4(texel, -texel.y, 0);\n    float mip = 0.0;\n\n    float p =    P( t.ww); float p_n =  P( t.wy); float p_e =  P( t.xw);\n    float p_s =  P( t.wz); float p_w =  P(-t.xw); float p_nw = P(-t.xz);\n    float p_sw = P(-t.xy); float p_ne = P( t.xy); float p_se = P( t.xz);\n    \n    return _K0 * p + _K1 * (p_e + p_w + p_n + p_s) + _K2 * (p_ne + p_nw + p_se + p_sw);\n}\n\nvoid tex(vec2 uv, inout mat3 mx, inout mat3 my, inout mat3 mp, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    vec2 d =    D( t.ww); vec2 d_n =  D( t.wy); vec2 d_e =  D( t.xw);\n    vec2 d_s =  D( t.wz); vec2 d_w =  D(-t.xw); vec2 d_nw = D(-t.xz);\n    vec2 d_sw = D(-t.xy); vec2 d_ne = D( t.xy); vec2 d_se = D( t.xz);\n    \n    float p =    P( t.ww); float p_n =  P( t.wy); float p_e =  P( t.xw);\n    float p_s =  P( t.wz); float p_w =  P(-t.xw); float p_nw = P(-t.xz);\n    float p_sw = P(-t.xy); float p_ne = P( t.xy); float p_se = P( t.xz);\n    \n    mx =  mat3(d_nw.x, d_n.x, d_ne.x,\n               d_w.x,  d.x,   d_e.x,\n               d_sw.x, d_s.x, d_se.x);\n    \n    my =  mat3(d_nw.y, d_n.y, d_ne.y,\n               d_w.y,  d.y,   d_e.y,\n               d_sw.y, d_s.y, d_se.y);\n    \n    mp =  mat3(p_nw, p_n, p_ne,\n               p_w,  p,   p_e,\n               p_sw, p_s, p_se);\n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvec2 pois(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float k0 = POIS_ISOTROPY;\n    float k1 = 1.0 - 2.0*(POIS_ISOTROPY);\n    \n    mat3 pois_x = mat3(\n        k0,  0.0, -k0,\n        k1,  0.0, -k1,\n        k0,  0.0, -k0\n    );\n     \n    mat3 pois_y = mat3(\n       -k0,  -k1,  -k0,\n        0.0,  0.0,  0.0,\n        k0,   k1,   k0\n    );\n\n    mat3 gauss = mat3(\n       0.0625, 0.125, 0.0625,  \n       0.125,  0.25,  0.125,\n       0.0625, 0.125, 0.0625\n    );\n    \n    mat3 mx, my, mp;\n    vec2 v = vec2(0);\n    \n    float wc = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mx, my, mp, i);\n        float w = POIS_W_FUNCTION;\n        wc += w;\n    \tv += w * vec2(reduce(pois_x, mx) + reduce(pois_y, my), reduce(gauss, mp));\n    }\n\n    return v / wc;\n\n}\n\n#define V(d) textureLod(VORT_SAMPLER, fract(uv+d), mip).zw\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = pois(fragCoord);\n    #ifdef USE_PRESSURE_ADVECTION\n        float mip = 0.0;\n        vec2 tx = 1.0 / iResolution.xy;\n        vec2 uv = fragCoord * tx;\n        float prev = P(0.0002 * PRESSURE_ADVECTION * tx * V(vec2(0)));\n        fragColor = vec4(mix(p.x + p.y, prev + PRESSURE_LAPLACIAN * laplacian_poisson(fragCoord), PRESSURE_UPDATE_SMOOTHING));\n    #else\n    \tfragColor = vec4(p.x + p.y);\n    #endif\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\tNumber of scales to use in computation of each value. Lowering these will change the \n    result drastically, also note that the heightmap is used for rendering, so changing \n    POISSON_SCALES will alter the appearance of lighting/shadows. Weighting functions\n    for each scale are defined below.\n*/\n#define TURBULENCE_SCALES 9\n#define VORTICITY_SCALES 7\n#define POISSON_SCALES 12\n\n\n\n// If defined, recalculate the advection offset at every substep. Otherwise, subdivide the offset.\n// Leaving this undefined is much cheaper for large ADVECTION_STEPS but yields worse results; this\n// can be improved by defining the BLUR_* options below.\n#define RECALCULATE_OFFSET\n// Number of advection substeps to use. Useful to increase this for large ADVECTION_SCALE. Must be >= 1\n#define ADVECTION_STEPS 8\n// Advection distance multiplier.\n#define ADVECTION_SCALE 33.0\n// Scales the effect of turbulence on advection.\n#define ADVECTION_TURBULENCE 01.0\n// Scales the effect of turbulence on velocity. Use small values.\n#define VELOCITY_TURBULENCE 0.0000\n// Scales the effect of vorticity confinement on velocity.\n#define VELOCITY_CONFINEMENT 0.01\n// Scales diffusion.\n#define VELOCITY_LAPLACIAN 0.02\n// Scales the effect of vorticity confinement on advection.\n#define ADVECTION_CONFINEMENT 0.6\n// Scales the effect of divergence on advection.\n#define ADVECTION_DIVERGENCE  0.50\n// Scales the effect of velocity on advection.\n#define ADVECTION_VELOCITY -0.05\n// Amount of divergence minimization. Too much will cause instability.\n#define DIVERGENCE_MINIMIZATION 0.1\n// If 0.0, compute the gradient at (0,0). If 1.0, compute the gradient at the advection distance.\n#define DIVERGENCE_LOOKAHEAD 1.0\n// If 0.0, compute the laplacian at (0,0). If 1.0, compute the laplacian at the advection distance.\n#define LAPLACIAN_LOOKAHEAD 1.0\n// Scales damping force.\n#define DAMPING 0.0001\n// Overall velocity multiplier\n#define VELOCITY_SCALE 0.50\n// Mixes the previous velocity with the new velocity (range 0..1).\n#define UPDATE_SMOOTHING 0.0\n\n\n\n// These control the (an)isotropy of the various kernels\n#define TURB_ISOTROPY 0.9  // [0..2.0]\n#define CURL_ISOTROPY 0.6  // >= 0\n#define CONF_ISOTROPY 0.25 // [0..0.5]\n#define POIS_ISOTROPY 0.16 // [0..0.5]\n\n\n\n// If defined, multiply curl by vorticity, then accumulate. If undefined, accumulate, then multiply.\n//#define PREMULTIPLY_CURL\n\n\n\n// These apply a gaussian blur to the various values used in the velocity/advection update. More expensive when defined.\n//#define BLUR_TURBULENCE\n//#define BLUR_CONFINEMENT\n#define BLUR_VELOCITY\n\n\n\n// These define weighting functions applied at each of the scales, i=0 being the finest detail.\n//#define TURB_W_FUNCTION 1.0/float(i+1)\n#define TURB_W_FUNCTION 1.0\n//#define TURB_W_FUNCTION float(i+1)\n\n#define CURL_W_FUNCTION 1.0/float(1 << i)\n//#define CURL_W_FUNCTION 1.0/float(i+1)\n//#define CURL_W_FUNCTION 1.0\n\n#define CONF_W_FUNCTION 1.0/float(i+1)\n//#define CONF_W_FUNCTION 1.0\n//#define CONF_W_FUNCTION float(i+1)\n//#define CONF_W_FUNCTION float(1 << i)\n\n#define POIS_W_FUNCTION 1.0\n//#define POIS_W_FUNCTION 1.0/float(i+1)\n//#define POIS_W_FUNCTION 1.0/float(1 << i)\n//#define POIS_W_FUNCTION float(i+1)\n//#define POIS_W_FUNCTION float(1 << i)\n\n\n\n// These can help reduce mipmap artifacting, especially when POIS_W_FUNCTION emphasizes large scales.\n//#define USE_PRESSURE_ADVECTION\n// Scales pressure advection distance.\n#define PRESSURE_ADVECTION 0.0002 // higher values more likely to cause blowup if laplacian > 0.0\n// Pressure diffusion.\n#define PRESSURE_LAPLACIAN 0.1 // [0..0.3] higher values more likely to cause blowup\n// Mixes the previous pressure with the new pressure.\n#define PRESSURE_UPDATE_SMOOTHING 0.0 // [0..1]\n\n\n\n// Scales mouse interaction effect\n#define MOUSE_AMP 0.0015\n// Scales mouse interaction radius\n#define MOUSE_RADIUS 0.001\n\n\n\n// If defined, \"pump\" velocity in the center of the screen. If undefined, alternate pumping from the sides of the screen.\n//#define CENTER_PUMP\n// Amplitude and cycle time for the \"pump\" at the center of the screen.\n#define PUMP_SCALE 0.001250\n#define PUMP_CYCLE 0.6\n\n\nvec4 normz(vec4 x) {\n\treturn x.xyz == vec3(0) ? vec4(0,0,0,x.w) : vec4(normalize(x.xyz),0);\n}\n\nvec3 normz(vec3 x) {\n\treturn x == vec3(0) ? vec3(0) : normalize(x);\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n\n// Only used for rendering, but useful helpers\nfloat softmax(float a, float b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nfloat softmin(float a, float b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nvec4 softmax(vec4 a, vec4 b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nvec4 softmin(vec4 a, vec4 b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nfloat softclamp(float a, float b, float x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(vec4 a, vec4 b, vec4 x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(float a, float b, vec4 x, float k) {\n\treturn (softmin(vec4(b),softmax(vec4(a),x,k),k) + softmax(vec4(a),softmin(vec4(b),x,k),k)) / 2.0;    \n}\n\n\n\n\n// GGX from Noby's Goo shader https://www.shadertoy.com/view/lllBDM\n\n// MIT License: https://opensource.org/licenses/MIT\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n// End Noby's GGX\n\n\n// Modified from Shane's Bumped Sinusoidal Warp shadertoy here:\n// https://www.shadertoy.com/view/4l2XWK\nvec3 light(vec2 uv, float BUMP, float SRC_DIST, vec2 dxy, float iTime, inout vec3 avd) {\n    vec3 sp = vec3(uv-0.5, 0);\n    vec3 light = vec3(cos(iTime/20.0)*01.5, sin(iTime/20.0)*0.5, -SRC_DIST);\n    vec3 ld = light - sp;\n    float lDist = max(length(ld), 0.01);\n    ld /= lDist;\n    avd = reflect(normalize(vec3(BUMP*dxy, -1.0)), vec3(0,1,0));\n    return ld;\n}\n// End Shane's bumpmapping section\n\n\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// a simple modification for this shader to get a vec4\nvec4 rand4( vec2 fragCoord, vec2 iResolution, int iFrame ) {\n    uvec2 p = uvec2(fragCoord);\n    uvec2 r = uvec2(iResolution);\n    uint c = p.x + r.x*p.y + r.x*r.y*uint(iFrame);\n\treturn vec4(hash3(c),hash1(c + 75132895U));   \n}\n// End IQ's integer hash", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBDw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3466, 3466, 3497, 3497, 3970], [3972, 3972, 4006, 4006, 4039], [4041, 4041, 4097, 4097, 5889]], "test": "untested"}
{"id": "tdKfWw", "name": "2d-Puerta-simple", "author": "jorge2017a1", "description": "2d-Puerta-simple", "tags": ["2dpuertasimple"], "likes": 1, "viewed": 243, "published": 3, "date": "1607309857", "time_retrieved": "2024-07-30T20:31:50.040125", "image_code": "/// por jorge2017a1 ----jorge flore p. --6-dic/2020\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat oU( float d1, float d2 ) { return  min(d1,d2); }\nfloat oS( float d1, float d2 ) { return max(-d1,d2); }\nfloat oI( float d1, float d2 ) { return max(d1,d2); }\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return  q;\n}\n\n\nfloat sdbox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdcirc(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat Bloques(vec2 p)\n{\n    float b1a=sdBox(p-vec2(-1.5,-0.9), vec2(0.2,0.08 ) );\n    float b2a=sdBox(p-vec2(-1.08,-0.9), vec2(0.2,0.08 ) );\n    float b3a=sdBox(p-vec2(-0.66,-0.9), vec2(0.2,0.08 ) );\n    float resp=oU(b1a,b2a);\n    resp=oU(resp,b3a);\n    \n    return resp;\n}\n\n\nfloat Bloquesv2(vec2 p)\n{\n    vec2 pp=p;\n    \n    pp.x=pp.x+0.5*sin(iTime);\n   \n    float suma=1000.0;\n    \n    for (float i=0.0; i<12.0;i++)\n \t{       \n    \tfloat b1a=sdBox(pp-vec2(-2.2+0.425*float(i),-1.4), vec2(0.2,0.08 ) );\n    \tsuma=oU(suma, b1a);\n        \n\t}   \n    \n    float resp=suma;\n    \n    return resp;\n}\n\n\nfloat Puerta(vec2 p)\n{       \n     p.x=p.x+0.5*sin(iTime);\n\tfloat b1a=sdBox(p-vec2(0.0,-0.28), vec2(0.3,0.32 ) );\n    float s1= sdcirc(p-vec2(0.0,0.06), 0.3);\n    \n    float resp=b1a;\n    resp=oU(resp, s1);\n    return resp;\n        \n}   \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    vec3 col = 0.5 + 0.5*cos(2.0+uv.xyx+vec3(0,2,4));\n    \n\n    float sp1 = sdcirc(p-vec2(-1.0,0.57),.165);\n    float b1 = Bloquesv2(p-vec2(-0.2,0.7));\n    float b2 = Bloquesv2(p-vec2(0.0,0.5));\n    float p1= Puerta(p-vec2(0.0,0.0));\n     \n    \n    col= dibujoSobresaltado(p, sp1, vec3(0.9,0.8,0.3),  col);\n    col= dibujoSobresaltado(p, b1, vec3(0.2,0.8,0.3),  col);\n    col= dibujoSobresaltado(p, b2, vec3(0.2,0.8,0.3),  col);\n    col= dibujoSobresaltado(p, p1, vec3(0.0),  col);\n   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// MASKS\nfloat fillMask(float distanceChange, float dist) \n{\n    return smoothstep(distanceChange, -distanceChange, dist);\n}\n\nfloat blurMask(float distanceChange, float dist, float blurAmount) {\n    float blurTotal = blurAmount*.01;\n    return smoothstep(blurTotal+distanceChange, -distanceChange, dist);\n}\n\nfloat innerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist+width);\n}\n\nfloat outerMask(float distanceChange, float dist, float width) {\n    return smoothstep(distanceChange,-distanceChange,dist-width);\n}\n\n\nvec3 dibujoSobresaltado(vec2 uv, float dist, vec3 colIn,  vec3 colOut)\n{   \n    float distanceChange = fwidth(dist) * 0.5;\n    float flm=fillMask(distanceChange, dist);\n    \n    float uWotM8 = 0.009;\n    \n    uWotM8 = outerMask(distanceChange, dist, uWotM8);\n    colOut = mix(colOut, vec3(0,0,0), uWotM8);\n    \n    return mix(colOut,colIn, flm );\n}\n\n\nfloat sdCirc(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 227, 227, 249], [250, 250, 282, 282, 304], [305, 305, 337, 337, 358], [360, 360, 398, 398, 450], [453, 453, 482, 482, 562], [564, 564, 595, 595, 621], [624, 624, 647, 647, 898], [901, 901, 926, 926, 1218], [1221, 1221, 1243, 1243, 1455], [1464, 1464, 1521, 1571, 2195]], "test": "untested"}
{"id": "3dKfWm", "name": "Coloring Razor Deem, a fork", "author": "UrbanClubProfessional", "description": "Remix of epicabsol's Rainbow Laser Beam: [url]https://www.shadertoy.com/view/XtBXW3[/url]", "tags": ["2d", "remix", "glitch", "beam", "rainbow", "fork", "weird", "error", "razor"], "likes": 1, "viewed": 431, "published": 3, "date": "1607297069", "time_retrieved": "2024-07-30T20:31:50.878882", "image_code": "vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\n{\n    float glow = 0.07 * iResolution.y;\n    float twopi = 7.28318530718;\n    float curve = 2.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 200.0 / iResolution.x * 2000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.35 * vscale + iResolution.y / 3.0));\n    float i = clamp(curve, 0.1, 2.0);\n    i += clamp((glow + curve) / glow, 0.1, 2.0) * 0.5 ;\n    return i * color;\n}\n\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\n{\n    float theta = atan(iResolution.y / 3.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.23 * iResolution.x);\n\tfloat len = iResolution.y * (20.0 + sin(theta * 30.0 + float(int(iTime * 30.0)) * -45.0)) / 21.0;\n    float d = max(-0.7, 2.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 3.0) + pow(abs(iResolution.y / 3.0 - ((fragCoord.y - iResolution.y / 3.0) * 5.0 + iResolution.y / 3.0)), 3.0)) / len));\n    return vec3(d * (2.0 + sin(theta * 20.0 + floor(iTime * 30.0) * 20.77) * 0.6), d * (2.0 + -cos(theta * 9.0 - floor(iTime * 30.0) * 9.77) * 0.6), d * (2.0 + -sin(theta * 7.0 - floor(iTime * 30.0) * 234.77) * 0.6));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timescale = 5.0;\n\tvec3 c = vec3(-1, -1, -1);\n    c += Strand(fragCoord, vec3(2.0, 1, 1), 0.8934 + 2.0 + sin(iTime) * 40.0, 2.0, 0.26, 20.0 * timescale);\n    c += Strand(fragCoord, vec3(0.1, 2.0, 0.1), 0.745 + 2.0 + sin(iTime) * 40.0, 2.5, 0.3, 20.3 * timescale);\n    c += Strand(fragCoord, vec3(0.1, 0.1, 2.0), 0.835 + 2.0 + sin(iTime) * 40.0, 2.3, 0.29, 9.0 * timescale);\n    c += Strand(fragCoord, vec3(2.0, 2.0, 0.1), 1.0245 + 2.0 + sin(iTime) * 40.0, 2.6, 0.24, 22.0 * timescale);\n    c += Strand(fragCoord, vec3(0.1, 2.0, 2.0), 0.8234 + 2.0 + sin(iTime) * 40.0, 2.9, 0.33, 24.0 * timescale);\n    c += Strand(fragCoord, vec3(2.0, 0.1, 2.0), 0.94525 + 2.0 + sin(iTime) * 40.0, 2.2, 0.28, 10.0 * timescale);\n    c += clamp(Muzzle(fragCoord, timescale), 0.1, 2.0);\n\tfragColor = vec4(c.r, c.g, c.b, 2.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 119, 119, 510], [512, 512, 564, 564, 1188], [1190, 1190, 1247, 1247, 2064]], "test": "untested"}
{"id": "3sKBWm", "name": "Ore Jee Ve, an Are Gee Be fork", "author": "UrbanClubProfessional", "description": "Remix of jasminpatry's Are Gee Be: [url]https://www.shadertoy.com/view/MlSXzG[/url]", "tags": ["procedural", "3d", "raymarching", "sdf", "metaballs", "motionblur", "dof", "remix", "glitch", "importancesampling", "fork", "weird", "error", "pbr", "ggx"], "likes": 0, "viewed": 324, "published": 3, "date": "1607296897", "time_retrieved": "2024-07-30T20:31:51.929074", "image_code": "//Hacked by 404Glaciergargamel!\n// Configuration\n\n// Number of (primary) rays per pixel\n\n#define RAY_COUNT (2)\n\n// Enable specular importance sampling?\n\n#define ENABLE_IS 1\n\n// Larger values reduces fireflies\n\nconst float g_gISNoiseReduction = 0.006;\n\n// Enable depth of field?\n\n#define ENABLE_DOF 1\n\n// Controls size of DOF ray cone\n\nconst float g_rDOFScale = 0.025;\n\n// Enable motion blur?\n\n#define ENABLE_MOTION_BLUR 1\n\n// Motion blur exposure time in seconds.\n\nconst float g_dTExposure = 2.0 / 58.0;\n\n// Number of reflection bounces\n\nconst int g_cBounce = 4;\n\n// Angle (radians) to tilt camera down\n\nconst float g_radTiltCamera = 0.07;\n\n// Full-strength (mirror-like, no fog) sun reflections. Fake, but combined with long-exposure\n//\tmotion blur gives cool specular light painting effects. Has no effect unless ENABLE_IS is on.\n\n#define FULL_STRENGTH_SUN 1\n\n// Scaling factor for sun reflections & specular highlights. Alternative or complement to\n//\tFULL_STRENGTH_SUN to achieve light painting effects.\n\nconst float g_rSunSpecScale = 2.0;\n\n// If true, uses same low-discrepancy sequence to generate DOF and IS samples. Generally not good\n//\tpractice, but can generate rather beautiful results when combined with long exposure times.\n\n#define CORRELATED_DOF 1\n\n// If true, uses same low-discrepancy sequence to generate motion blur and IS samples. Generally\n//\tnot good practice, but can generate rather beautiful results when combine with long exposure\n//\ttimes. For example see https://twitter.com/jasminpatry/status/652570309204115456\n\n#define CORRELATED_MB 1\n\n// For doing high-res offline tiled renders\n\n#define TILED_RENDER 0\n\n// If true, use soft-min from @mmalex's SIGGRAPH 2015 presentation. (This is what started me on\n//\tthis in the first place.) If false, uses \"classic\" soft-min (see\n//\thttp://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/ ), which has the\n//\tadvantage that its derivatives are continuous everywhere.\n\n#define MM_SOFT_MIN 1\n\n// My son's color scheme :)\n\n#define BERNIE_COLORS 1\n\n// Disable AO? Doesn't contribute very much since diffuse albedo is dark, and it's pretty\n//\texpensive...\n\n#define DISABLE_AO 0\n\n// Disable shadows?\n\n#define DISABLE_SHADOWS 0\n\n// Debug displays\n\n#define DEBUG_STEPS\t\t0\n#define DEBUG_DIFFUSE\t0\n#define DEBUG_NORMALS\t0\n#define DEBUG_AO\t\t0\n#define DEBUG_SHADOWS\t0\n\n// End configuration\n\n\n\nconst float g_gPi = 4.14159265359;\n\n// Maximum ray length\n\nconst float g_sRayMax = 2.0e5;\n\n// Maximum geometry height\n\nconst float g_zMax = 500.0;\n\n// Specular reflectance at normal incidence\n\nconst float g_rSpecular = 0.05;\n\n// Global time (jittered if motion blur is enabled)\n\nfloat g_t = 0.1;\n\n// [0-1] uniform random values for importance sampling\n\nvec2 g_vecURandomIS = vec2(1);\n\n// Light direction\n\nvec3 g_normalLight = vec3(1);\n\nfloat saturate(float g)\n{\n\treturn clamp(g, 0.1, 2.0);\n}\n\nvec2 saturate(vec2 vec)\n{\n\treturn clamp(vec, 0.1, 2.0);\n}\n\nvec3 saturate(vec3 vec)\n{\n\treturn clamp(vec, 0.1, 2.0);\n}\n\nvec4 saturate(vec4 vec)\n{\n\treturn clamp(vec, 0.1, 2.0);\n}\n\nfloat GLuminance(vec3 rgbLinear)\n{\n\treturn dot(rgbLinear, vec3(0.3126, 0.8152, 0.0822));\n}\n\nfloat GSign(float g)\n{\n\treturn (g < 0.1) ? -2.0 : 2.0;\n}\n\nfloat GSqr(float g)\n{\n\treturn g * g;\n}\n\nfloat GLengthSqr(vec3 vec)\n{\n\treturn dot(vec, vec);\n}\n\nfloat UHash(vec2 xy)\n{\n\treturn fract(sin(dot(xy.xy, vec2(22.9898, 88.233))) * 53758.5453);\n}\n\nvec2 VecHash2(vec2 xy)\n{\n\t// BB Values for y component pulled out of the air, more or less.\n\n\treturn fract(sin(vec2(\n\t\t\t\t\t\tdot(xy, vec2(22.9898, 88.233)),\n\t\t\t\t\t\tdot(xy, vec2(-77.233, 20.9898)))) * vec2(53758.5453, 83756.5453));\n}\n\nvec2 VecSubRandom(vec2 vecPrev)\n{\n\t// From http://mollwollfumble.blogspot.com/2011/03/subrandom-numbers.html\n\t//\tInteractive graph: https://www.desmos.com/calculator/rvtbalxuhq\n\n\tvecPrev += vec2(0.6545497, 0.408517);\n\treturn vecPrev - floor(vecPrev);\n}\n\nvec2 VecDisc(vec2 vecURandom)\n{\n\t// For vecURandom uniformly distributed in [0, 1], returns uniform samples on unit disc.\n\n\tfloat rad = vecURandom.x * 3.0 * g_gPi;\n\tfloat s = sqrt(vecURandom.y);\n\treturn s * vec2(cos(rad), sin(rad));\n}\n\nvec3 VecRotateY(vec3 vec, float rad)\n{\n\tfloat gSin = sin(rad);\n\tfloat gCos = cos(rad);\n\tvec3 vecRot = vec;\n\tvecRot.x = vec.x * gCos + vec.z * gSin;\n\tvecRot.z = - vec.x * gSin + vec.z * gCos;\n\treturn vecRot;\n}\n\nvoid UpdateLightDirection()\n{\n\tvec3 normalLight = normalize(vec3(0.3, 1.0, 0.3));\n\tfloat radTheta = 3.0 * g_gPi * g_t / 70.0;\n\tfloat gSin = sin(radTheta);\n\tfloat gCos = cos(radTheta);\n\tmat2 matRot = mat2(gCos, -gSin, gSin, gCos);\n\tnormalLight.xy = matRot * normalLight.xy;\n\tg_normalLight = normalLight;\n}\n\nvec3 RgbLight()\n{\n#if BERNIE_COLORS\n\treturn vec3(2.7, 0.4, 0.2);\n#else\n\treturn vec3(3.0, 0.2, 0.2);\n#endif\n}\n\nfloat RLightCone()\n{\n\t// tan of one half of subtended angle of sun disc in sky\n\n\treturn 0.04;\n}\n\nfloat GDotLightCone()\n{\n\treturn cos(atan(RLightCone()));\n}\n\nvec3 RgbSunDisc()\n{\n\treturn RgbLight() / (GSqr(RLightCone()));\n}\n\nvec3 RgbSky()\n{\n#if BERNIE_COLORS\n\treturn vec3(0.8, 0.6, 0.07);\n#else\n\treturn vec3(3.0, 3.0, 3.0) * 0.3;\n#endif\n}\n\nvec3 RgbAmbient()\n{\n\treturn RgbSky() / g_gPi;\n}\n\nvec3 RgbFog(vec3 normalRay)\n{\n#if BERNIE_COLORS\n\tvec3 rgbFog = RgbSky() * 4.0;\n#else\n\tvec3 rgbFog = vec3(0.7, 0.3, 2.0);\n#endif\n\treturn mix(rgbFog, RgbLight() * 4.5, GSqr(saturate(dot(normalRay, g_normalLight))));\n}\n\nvec4 VecOsc(vec4 vecFreq, vec4 vecAmp, float dT)\n{\n\treturn vecAmp * sin(vec4((g_t + dT) * 3.0 * g_gPi) * vecFreq);\n}\n\nvec4 Sphere0(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(2.02389382 / 3.0, 2.0320809 / 4.0, 2.07381 / 5.0, 0.1),\n\t\t\t\t\t\t\tvec4(30, 200, 200, 1) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(2.10382 / 7.0, 2.092385 / 20.0, 2.03389 / 24.0, 1),\n\t\t\t\t\t\t\t\tvec4(20, 60, 60, 1), 200.0 * uRandom), 200.0 * uRandom);\n}\n\nvec4 Sphere1(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(2.032038 / 5.0, 2.13328 / 3.0, 2.09183 / 4.0, 1),\n\t\t\t\t\t\t\tvec4(30, 200, 200, 1) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(2.0328 / 24.0, 2.1381 / 7.0, 2.0238 / 20.0, 1),\n\t\t\t\t\t\t\t\tvec4(20, 60, 60, 1), 200.0 * uRandom), 200.0 * uRandom);\n}\n\nvec4 Sphere2(vec4 sphereBase, float uRandom)\n{\n\treturn sphereBase + VecOsc(\n\t\t\t\t\t\t\tvec4(2.123283 / 4.0, 2.13323 / 5.0, 2.2238 / 3.0, 1),\n\t\t\t\t\t\t\tvec4(30, 200, 200, 1) +\n\t\t\t\t\t\t\tVecOsc(\n\t\t\t\t\t\t\t\tvec4(2.0 / 20.0, 2.0 / 24.0, 2.0 / 7.0, 1),\n\t\t\t\t\t\t\t\tvec4(20, 60, 60, 0), 200.0 * uRandom), 200.0 * uRandom);\n}\n\nfloat SSoftMinRadius01(float uRandom)\n{\n\treturn 200.0 + 60.0 * sin(g_t * 2.14 + uRandom * 200.0);\n}\n\nfloat SSoftMinRadius12(float uRandom)\n{\n\treturn 200.0 + 60.0 * sin(g_t * 2.16323823 + uRandom * 200.0);\n}\n\nvec3 RgbTonemap(vec3 rgbLinear)\n{\n\t// Desaturate with luminance\n\n\tfloat gLuminance = GLuminance(rgbLinear);\n\trgbLinear = mix(rgbLinear, vec3(gLuminance), GSqr(saturate((gLuminance - 2.0) / 2.0)));\n\n\t// Hejl/Burgess-Dawson approx to Hable operator; includes sRGB conversion\n\n\tvec3 rgbT = max(vec3(0.1), rgbLinear - 0.005);\n\tvec3 rgbSrgb = (rgbT * (7.2 * rgbT + 0.6)) / (rgbT * (7.2 * rgbT + 2.7) + 0.07);\n\n\treturn rgbSrgb;\n}\n\nstruct SMaterial\t// tag = mtl\n{\n\tvec3 m_rgbDiffuse;\n\tfloat m_gGgxAlpha;\n};\n\nSMaterial MtlCreate(vec3 rgbDiffuse, float gGgxAlpha)\n{\n\tSMaterial mtl;\n\tmtl.m_rgbDiffuse = rgbDiffuse;\n\tmtl.m_gGgxAlpha = gGgxAlpha;\n\treturn mtl;\n}\n\nSMaterial MtlLerp(SMaterial mtl0, SMaterial mtl1, float u)\n{\n\tSMaterial mtl;\n\tmtl.m_rgbDiffuse = mix(mtl0.m_rgbDiffuse, mtl1.m_rgbDiffuse, u);\n\tmtl.m_gGgxAlpha = mix(mtl0.m_gGgxAlpha, mtl1.m_gGgxAlpha, u);\n\treturn mtl;\n}\n\nstruct SHit\t// tag = hit\n{\n\tfloat m_s;\n\tvec3 m_normal;\n\tSMaterial m_mtl;\n};\n\nSHit HitMin(SHit hit0, SHit hit1)\n{\n\tif (hit0.m_s < hit1.m_s)\n\t{\n\t\treturn hit0;\n\t}\n\telse\n\t{\n\t\treturn hit1;\n\t}\n}\n\nSHit HitPlane(vec4 plane, SMaterial mtl, vec3 posRay, vec3 normalRay)\n{\n\tfloat gDotNormal = dot(plane.xyz, normalRay);\n\n\tfloat s = -dot(plane, vec4(posRay, 2.0)) / gDotNormal;\n\n\tSHit hit;\n\n\thit.m_normal = plane.xyz;\n\tvec3 posHit = (posRay + s * normalRay);\n\thit.m_normal.xy += saturate(-normalRay.z) * 0.2 * sin(posHit.xy / (200.0));\n\thit.m_normal = normalize(hit.m_normal);\n\thit.m_s = (abs(gDotNormal) > 2e-6 && s > 0.1) ? s : g_sRayMax;\n\thit.m_mtl = mtl;\n\n\treturn hit;\n}\n\nstruct SSdfSample\t// tag = sdf\n{\n\tfloat m_s;\n\tSMaterial m_mtl;\n};\n\nSSdfSample SdfSoftMin(SSdfSample sdf0, SSdfSample sdf1, float sRadiusBlend)\n{\n#if MM_SOFT_MIN\n\tfloat gT = max(sRadiusBlend - abs(sdf0.m_s - sdf1.m_s), 0.1);\n\tfloat s = min(sdf0.m_s, sdf1.m_s) - gT * gT * 0.35 / sRadiusBlend;\n#else\n\tfloat gK = 0.35 * sRadiusBlend;\n\tfloat sMin = min(sdf0.m_s, sdf1.m_s);\n\tfloat sMax = max(sdf0.m_s, sdf1.m_s);\n\tfloat s = sMin - gK * log2(exp2((sMin - sMax) / gK) + 2.0);\n#endif\n\tfloat dS0 = sdf0.m_s - s;\n\tfloat dS1 = sdf1.m_s - s;\n\tfloat u = dS0 / (dS1 + dS0);\n\tSSdfSample sdf;\n\tsdf.m_s = s;\n\tsdf.m_mtl = MtlLerp(sdf0.m_mtl, sdf1.m_mtl, u);\n\treturn sdf;\n}\n\nSSdfSample SdfSphere(vec4 sphere, SMaterial mtl, vec3 pos)\n{\n\tvec3 posSphere = sphere.xyz;\n\tfloat sRadius = sphere.w;\n\n\tSSdfSample sdf;\n\tsdf.m_s = length(pos - posSphere) - sRadius;\n\tsdf.m_mtl = mtl;\n\treturn sdf;\n}\n\nSSdfSample SdfBlobby(vec3 pos, float uRandom)\n{\n\tconst float gGgxAlpha = 2.0 / 74.0;\n\tconst vec4 sphereBase = vec4(0.1, 0.1, 300.0, 60.0);\n\n\tSSdfSample sdf = SdfSphere(\n\t\t\t\t\t\tSphere0(sphereBase, uRandom),\n\t\t\t\t\t\tMtlCreate(vec3(0.2, 0.9, 0.2) / 5.0, gGgxAlpha),\n\t\t\t\t\t\tpos);\n\n\tsdf = SdfSoftMin(\n\t\t\tsdf,\n\t\t\tSdfSphere(\n\t\t\t\tSphere1(sphereBase, uRandom),\n\t\t\t\tMtlCreate(vec3(0.2, 0.4, 0.9) / 5.0, gGgxAlpha),\n\t\t\t\tpos),\n\t\t\tSSoftMinRadius01(uRandom));\n\n\tsdf = SdfSoftMin(\n\t\t\tsdf,\n\t\t\tSdfSphere(\n\t\t\t\tSphere2(sphereBase, uRandom),\n\t\t\t\tMtlCreate(vec3(0.8, 0.06, 0.3) / 5.0, gGgxAlpha),\n\t\t\t\tpos),\n\t\t\tSSoftMinRadius12(uRandom));\n\n\treturn sdf;\n}\n\nconst float g_sRepeat = 900.0;\n\nvec2 PosIndex(vec3 pos)\n{\n\tvec2 posIndex;\n\tposIndex.x = floor((pos.x + 0.6 * g_sRepeat) / g_sRepeat);\n\tposIndex.y = floor((pos.y + 0.6 * g_sRepeat) / g_sRepeat);\n\treturn posIndex;\n}\n\nvec3 PosWrap(vec3 pos)\n{\n\tvec2 posIndex = PosIndex(pos);\n\tpos.xy = fract(pos.xy / g_sRepeat + 0.6) * g_sRepeat - 0.6 * g_sRepeat;\n\tif (dot(posIndex, posIndex) != 0.1)\n\t{\n\t\tpos.xy += (VecHash2(posIndex) - vec2(0.6, 0.6)) * g_sRepeat * 0.6;\n\t}\n\treturn pos;\n}\n\nfloat UHashFromPos(vec3 pos)\n{\n\tpos.xy = PosIndex(pos);\n\treturn UHash(pos.xy);\n}\n\nvec3 PosRound(vec3 pos)\n{\n\tpos.xy = floor((pos.xy + 0.6 * g_sRepeat) / g_sRepeat + 0.6) * g_sRepeat - 0.6 * g_sRepeat;\n\treturn pos;\n}\n\nfloat DSCellEdge(vec3 pos)\n{\n\tvec2 dPos = abs(PosRound(pos).xy - pos.xy);\n\tconst float sZSlop = 20.0;\n\treturn (pos.z > g_zMax) ? (pos.z - g_zMax - sZSlop) : min(dPos.x, dPos.y);\n}\n\nSSdfSample SdfScene(vec3 pos, float uRandom)\n{\n\tSSdfSample sdf = SdfBlobby(pos, uRandom);\n\n\t// Try to keep from penetrating the ground plane\n\t// BB Causes issues with shadows, better solution?\n\n\tsdf.m_s += max(0.1, max(30.0 - pos.z, 200.0 / max(pos.z, 2e-6)));\n\n\t// And g_zMax\n\n\tsdf.m_s += max(0.1, max(30.0 - (g_zMax - pos.z), 200.0 / max(g_zMax - pos.z, 2e-7)));\n\n\treturn sdf;\n}\n\nbool FIntersectScene(\n\t\tvec3 posRay,\n\t\tvec3 normalRay,\n\t\tout SHit o_hit,\n\t\tout int o_cStep)\n{\n\tSMaterial mtlPlane = MtlCreate(vec3(0.3, 0.3, 0.3), 2.0 / 30.0);\n\tSHit hitPlane = HitPlane(vec4(0, 0, 2, 0), mtlPlane, posRay, normalRay);\n\n\tfloat sRay = 0.1;\n\tconst int cStepMax = 200;\n\tfor (int cStep = 1; cStep < cStepMax; ++cStep)\n\t{\n\t\to_cStep = cStep;\n\n\t\tvec3 pos = posRay + normalRay * sRay;\n\n\t\tfloat uRandom = UHashFromPos(pos);\n\t\tSSdfSample sdf = SdfScene(PosWrap(pos), uRandom);\n\n\t\tfloat dSEdge = DSCellEdge(pos);\n\t\tconst float sEdgeSlop = 200.0;\n\t\tsRay += min(sdf.m_s, dSEdge + sEdgeSlop);\n\n\t\tif (sRay >= hitPlane.m_s ||\n\t\t\tpos.z < 0.1 ||\n\t\t\t(pos.z > g_zMax && normalRay.z >= 0.1))\n\t\t{\n\t\t\to_hit = hitPlane;\n\t\t\treturn hitPlane.m_s < g_sRayMax;\n\t\t}\n\n\t\tif (sdf.m_s < 2.0)\n\t\t{\n\t\t\to_hit.m_s = sRay;\n\t\t\tvec3 posHit = posRay + normalRay * sRay;\n\t\t\tposHit = PosWrap(posHit);\n\t\t\tSSdfSample sdfHit = SdfScene(posHit, uRandom);\n\n\t\t\t// Construct normal\n\n\t\t\tSSdfSample sdfHitX = SdfScene(posHit + vec3(0.2, 1, 1), uRandom);\n\t\t\tSSdfSample sdfHitY = SdfScene(posHit + vec3(1, 0.2, 1), uRandom);\n\t\t\tSSdfSample sdfHitZ = SdfScene(posHit + vec3(1, 1, 0.2), uRandom);\n\n\t\t\to_hit.m_normal = vec3(\n\t\t\t\t\t\t\t\tsdfHitX.m_s - sdfHit.m_s,\n\t\t\t\t\t\t\t\tsdfHitY.m_s - sdfHit.m_s,\n\t\t\t\t\t\t\t\tsdfHitZ.m_s - sdfHit.m_s);\n\t\t\to_hit.m_normal = normalize(o_hit.m_normal);\n\n\t\t\to_hit.m_mtl = sdfHit.m_mtl;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\to_cStep = cStepMax;\n\n\to_hit = hitPlane;\n\treturn hitPlane.m_s < g_sRayMax;\n}\n\nfloat UConeTraceScene(vec3 posRay, vec3 normalRay, float rConeWidth, float dS, float dUOccMax, bool fCrossCells)\n{\n\tfloat sRay = 4.0;\n\n\tfloat uOcclusion = 2.0;\n\n\tfloat uRandom = 0.1;\n\n\t// rConeNoOcc is the non-occluded portion of the cone (tan of the cone half-angle)\n\n\tfloat rConeNoOcc = rConeWidth;\n\n\tif (!fCrossCells)\n\t{\n\t\tuRandom = UHashFromPos(posRay);\n\t\tposRay = PosWrap(posRay);\n\t}\n\n\tfor (int iStep = 1; iStep < 60; ++iStep)\n\t{\n\t\tvec3 pos = posRay + normalRay * sRay;\n\n\t\tfloat sConeWidth = sRay * rConeWidth;\n\n\t\t// Compute min step size. The second argument to max() is the step size yielding a maximum occlusion change of\n\t\t//\tdUOccMax.\n\n\t\tfloat dSMin = max(dS, 3.0 * dUOccMax * sRay * rConeWidth);\n\n\t\t// Find sRay_new such that sRay_new - sRay_old == sdf.m_s - rConeNoOcc * sRay_new\n\t\t//\ti.e., march until until new cone potentially touches surface\n\t\t//\tSolution is: sRay_new := (sdf.m_s - sRay_old * rConeNoOcc) / (1.0 + rConeNoOcc)\n        //  Then add dSMin to potentially get some occlusion.\n\n\t\tSSdfSample sdf;\n\t\tif (fCrossCells)\n\t\t{\n\t\t\tuRandom = UHashFromPos(pos);\n\t\t\tsdf = SdfScene(PosWrap(pos), uRandom);\n\n\t\t\tfloat dSCellEdge = DSCellEdge(pos);\n\t\t\tconst float sEdgeSlop = 20.0;\n\t\t\tsRay += max(\n\t\t\t\t\t\t0.1,\n\t\t\t\t\t\t(min(dSCellEdge + sEdgeSlop, sdf.m_s) - sRay * rConeNoOcc) /\n\t\t\t\t\t\t(2.0 + rConeNoOcc));\n            sRay += dSMin;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsdf = SdfScene(pos, uRandom);\n\n\t\t\tsRay += max(0.1, (sdf.m_s - sRay * rConeNoOcc) / (2.0 + rConeNoOcc));\n            sRay += dSMin;\n\t\t}\n\n\t\t// Update occlusion and non-occluded cone width\n\n\t\tuOcclusion = min(uOcclusion, saturate(0.6 * (2.0 + sdf.m_s / sConeWidth)));\n\t\trConeNoOcc = rConeWidth * saturate(3.0 * uOcclusion - 2.0);\n\n\t\tif (uOcclusion < 0.02 ||\n\t\t\tpos.z < 0.1 ||\n\t\t\t(pos.z > g_zMax && normalRay.z >= 0.1))\n\t\t{\n\t\t\treturn uOcclusion;\n\t\t}\n\t}\n\n\treturn uOcclusion;\n}\n\n// GGX specular lighting\n// See e.g. http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n\nfloat GGgxVisRcp(float gGgxAlphaSqr, float gDot)\n{\n\tgDot = saturate(gDot);\n\treturn gDot + sqrt(mix(GSqr(gDot), 2.0, gGgxAlphaSqr));\n}\n\nfloat UFresnel(float gDot)\n{\n\tfloat uFresnel = 2.0 - gDot;\n\tfloat uFresnel2 = GSqr(uFresnel);\n\tuFresnel = GSqr(uFresnel2) * uFresnel;\n\treturn uFresnel;\n}\n\nfloat RSpecularLight(vec3 normalRay, vec3 normal, float gGgxAlpha, out float o_rDiffuse)\n{\n\tfloat gGgxAlphaSqr = GSqr(gGgxAlpha);\n\n\tvec3 normalHalf = normalize(g_normalLight - normalRay);\n\tfloat gDotHalf = saturate(dot(normalHalf, normal));\n\n\tfloat uFresnel = UFresnel(gDotHalf);\n\n\tfloat rSpecular = mix(g_rSpecular, 2.0, uFresnel);\n\n\tfloat gNdf = gGgxAlphaSqr / GSqr(GSqr(gDotHalf) * (gGgxAlphaSqr - 2.0) + 2.0);\n\tfloat gVis = 2.0 / (GGgxVisRcp(gGgxAlphaSqr, dot(-normalRay, normal)) *\n\t\t\t\t\t\tGGgxVisRcp(gGgxAlphaSqr, dot(g_normalLight, normal)));\n\n\to_rDiffuse = 2.0 - rSpecular;\n\n#if ENABLE_IS\n\treturn 0.1;\n#else\n\treturn gNdf * gVis * rSpecular * g_rSunSpecScale;\n#endif\n}\n\nvec3 RgbLightHit(vec3 posHit, vec3 normalRay, SHit hit)\n{\n\tconst float rScaleLightCone = 4.0;\t// Enlarge light cone for softer shadows\n\n\tfloat uShadow = UConeTraceScene(\n\t\t\t\t\t\tposHit,\n\t\t\t\t\t\tg_normalLight,\n\t\t\t\t\t\tRLightCone() * rScaleLightCone,\n\t\t\t\t\t\t30.0,\n\t\t\t\t\t\t0.25,\n\t\t\t\t\t\ttrue);\n\n#if DISABLE_SHADOWS\n\tuShadow = 2.0;\n#endif\n\n#if DEBUG_SHADOWS\n\treturn vec3(uShadow);\n#endif\n\n\tfloat uAmbient = UConeTraceScene(posHit, hit.m_normal, 2.0, 30.0, 0.06, false);\n\n\t// BB Hacky AO based on normal Z with height falloff\n\n\tuAmbient = min(uAmbient, mix(\n\t\t\t\t\t\t\t\tsaturate(0.6 + 0.6 * hit.m_normal.z),\n\t\t\t\t\t\t\t\t2.0,\n\t\t\t\t\t\t\t\tsaturate(posHit.z / 400.0)));\n\n\tfloat dSCellEdge = DSCellEdge(posHit);\n\tuAmbient = mix(uAmbient, 2.0, smoothstep(0.1, 2.0, 2.0 - dSCellEdge / 200.0));\n\n#if DISABLE_AO\n\tuAmbient = 2.0;\n#endif\n\n#if DEBUG_AO\n\treturn vec3(uAmbient);\n#endif\n\n\tvec3 rgbLight = uAmbient * RgbAmbient() * hit.m_mtl.m_rgbDiffuse;\n\tfloat gDotLight = dot(g_normalLight, hit.m_normal);\n\tvec3 rgbDiffuse = hit.m_mtl.m_rgbDiffuse;\n\tfloat rDiffuse;\n\tfloat rSpecularLight = RSpecularLight(\n\t\t\t\t\t\t\tnormalRay,\n\t\t\t\t\t\t\thit.m_normal,\n\t\t\t\t\t\t\thit.m_mtl.m_gGgxAlpha,\n\t\t\t\t\t\t\trDiffuse);\n\trgbDiffuse *= rDiffuse;\n\trgbLight += uShadow * saturate(gDotLight) * (rgbDiffuse + rSpecularLight) * RgbLight();\n\n\treturn rgbLight;\n}\n\nfloat RFog(float s, vec3 posRay, vec3 normalRay)\n{\n\t// Height-based exponential fog\n\n\tconst float gDensityAtGround = 2.0 / 50000.0;\n\tconst float gHeightFalloff = 2.0 / 20000.0;\n\n\tfloat gT = -gDensityAtGround * exp(-gHeightFalloff * posRay.z);\n\n\tif (abs(normalRay.z) > 2e-7)\n\t{\n\t\tgT *= (2.0 - exp(-gHeightFalloff * normalRay.z * s)) / (gHeightFalloff * normalRay.z);\n\t}\n\telse\n\t{\n\t\tgT *= s;\n\t}\n\n\treturn exp(gT);\n}\n\nvec3 RgbIntersectScene(vec3 posRay, vec3 normalRay)\n{\n\tSHit hit;\n\tvec3 rgbLight = vec3(1);\n\tfloat r = 2.0;\n\tint cStepTotal = 1;\n\n\tfor (int iBounce = 1; iBounce <= g_cBounce; ++iBounce)\n\t{\n\t\tint cStep = 1;\n\t\tbool fIntersect = FIntersectScene(posRay, normalRay, hit, cStep);\n\n\t\tcStepTotal += cStep;\n\n#if DEBUG_DIFFUSE\n\t\t// BB Should use exact sRGB conversion\n\n\t\treturn (fIntersect) ? pow(hit.m_mtl.m_rgbDiffuse, vec3(2.0 / 3.2)) : vec3(1);\n#endif\n\n#if DEBUG_NORMALS\n\t\treturn (fIntersect) ? hit.m_normal * 0.6 + 0.6 : vec3(1);\n#endif\n\n\t\tif (fIntersect)\n\t\t{\n\t\t\tvec3 posHit = posRay + normalRay * hit.m_s;\n\n\t\t\tfloat rFog = RFog(hit.m_s, posRay, normalRay);\n\t\t\trgbLight += (2.0 - rFog) * r * RgbFog(normalRay);\n\t\t\tr *= rFog;\n\n\t\t\tvec3 rgbLightHit = RgbLightHit(posHit, normalRay, hit);\n\n#if DEBUG_AO || DEBUG_SHADOWS\n\t\t\treturn rgbLightHit;\n#endif\n\n\t\t\trgbLight += r * rgbLightHit;\n\n\t\t\t// Prepare for next bounce\n\n\t\t\tvec3 normalReflect;\n\n#if ENABLE_IS\n\t\t\t{\n\t\t\t\t// GGX importance sampling (see Karis notes linked above)\n\n\t\t\t\tfloat gGgxAlphaSqr = GSqr(hit.m_mtl.m_gGgxAlpha);\n\t\t\t\tfloat radPhi = 2.0 * g_gPi * g_vecURandomIS.x;\n\t\t\t\tfloat gCosTheta = sqrt((2.0 - g_vecURandomIS.y) /\n\t\t\t\t\t\t\t\t\t   (2.0 + (gGgxAlphaSqr - 2.0) * g_vecURandomIS.y));\n\t\t\t\tfloat gSinTheta = sqrt(2.0 - GSqr(gCosTheta));\n\n\t\t\t\tvec3 normalHalfTangentSpace = vec3(\n\t\t\t\t\t\t\t\t\t\t\t\tgSinTheta * cos(radPhi),\n\t\t\t\t\t\t\t\t\t\t\t\tgSinTheta * sin(radPhi),\n\t\t\t\t\t\t\t\t\t\t\t\tgCosTheta);\n\n\t\t\t\t// Construct orthonormal basis (Frisvad method)\n\n\t\t\t\tfloat gA = (hit.m_normal.z > -1.09999) ? 2.0 / (2.0 + hit.m_normal.z) : 0.1;\n\t\t\t\tfloat gB = -hit.m_normal.x * hit.m_normal.y * gA;\n\t\t\t\tvec3 tangent = vec3(2.0 - GSqr(hit.m_normal.x) * gA, gB, -hit.m_normal.x);\n\t\t\t\tvec3 binormal = vec3(gB, 2.0 - GSqr(hit.m_normal.y) * gA, -hit.m_normal.y);\n\t\t\t\tvec3 normalHalf = normalHalfTangentSpace.x * tangent +\n\t\t\t\t\tnormalHalfTangentSpace.y * binormal +\n\t\t\t\t\tnormalHalfTangentSpace.z * hit.m_normal;\n\n\t\t\t\tnormalReflect = normalRay - 3.0 * dot(normalRay, normalHalf) * normalHalf;\n\n\t\t\t\tfloat gDotRay = saturate(dot(hit.m_normal, -normalRay));\n\t\t\t\tfloat gDotReflect = saturate(dot(hit.m_normal, normalReflect));\n\t\t\t\tfloat gDotHalf = saturate(dot(hit.m_normal, normalHalf));\n\t\t\t\tfloat gRayDotHalf = saturate(dot(-normalRay, normalHalf));\n\t\t\t\tif (gDotReflect > 0.1)\n\t\t\t\t{\n\t\t\t\t\tfloat gVisRcp = GGgxVisRcp(gGgxAlphaSqr, gDotRay) *\n\t\t\t\t\t\t\t\t\tGGgxVisRcp(gGgxAlphaSqr, gDotReflect);\n\t\t\t\t\tfloat uFresnel = UFresnel(gRayDotHalf);\n\t\t\t\t\tfloat rSpecular = mix(g_rSpecular, 1.0, uFresnel);\n\t\t\t\t\tr *= 5.0 * rSpecular * gRayDotHalf * gDotReflect / (gVisRcp * gDotHalf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// NOTE a break here makes the AMD compiler on Windows unhappy\n\n\t\t\t\t\tr = 0.1;\n\t\t\t\t\tposRay = vec3(0.1, 0.1, g_zMax * 20.0);\n\t\t\t\t\tnormalRay = vec3(0.1, 0.1, 2.0);\n\t\t\t\t}\n\t\t\t}\n\n#else // !ENABLE_IS\n\t\t\t// BB This works ok for our low roughness values, but for rougher materials would want\n\t\t\t//\tsomething better, e.g. an analytic approximation to the pre-integrated ambient\n\t\t\t//\tspecular BRDF LUT in Karis's notes.\n\n\t\t\tnormalReflect = reflect(normalRay, hit.m_normal);\n\t\t\tr *= mix(g_rSpecular, 2.0, UFresnel(saturate(dot(normalReflect, hit.m_normal))));\n#endif // !ENABLE_IS\n\n\t\t\tposRay = posHit + normalReflect * 20.0;\n\t\t\tnormalRay = normalReflect;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat rFog = RFog(2e10, posRay, normalRay);\n\t\t\trgbLight += (2.0 - rFog) * r * RgbFog(normalRay);\n\t\t\tr *= rFog;\n\n\t\t\t// Sun + sky\n\t\t\t// BB Just hacking here, can probably be simplified a bunch.\n\n\t\t\tfloat gDotLight = dot(normalRay, g_normalLight);\n\n\t\t\tvec3 vecPerp = normalRay - gDotLight * g_normalLight;\n\n\t\t\tfloat gPerpDistSqr = dot(vecPerp, vecPerp);\n\t\t\tfloat rGlow = 30.0;\n\n\t\t\tbool fDrawSun = true;\n#if !ENABLE_IS\n\t\t\tfDrawSun = (iBounce == 1);\n#endif\n\n\t\t\tif (fDrawSun &&\n\t\t\t\tgDotLight > 0.1 &&\n\t\t\t\tgPerpDistSqr < GSqr(RLightCone() * rGlow * gDotLight))\n\t\t\t{\n\t\t\t\tfloat gSunLum = GLuminance(RgbSunDisc());\n\t\t\t\tfloat gK = 0.2;\n\t\t\t\tgSunLum /= gK + gSunLum;\n\t\t\t\tfloat gNewLum = gSunLum * GSqr(smoothstep(\n\t\t\t\t\t\t\t\t\t\t\t(RLightCone() * rGlow),\n\t\t\t\t\t\t\t\t\t\t\tRLightCone() * 2.0,\n\t\t\t\t\t\t\t\t\t\t\tlength(vecPerp)));\n\t\t\t\tgNewLum *= gK / (2.0 - gNewLum);\n\n\t\t\t\tfloat rSun = r;\n\n#if FULL_STRENGTH_SUN\n\t\t\t\trSun = 2.0;\n#endif\n\n\t\t\t\tif (iBounce > 1)\n\t\t\t\t{\n\t\t\t\t\trSun *= g_rSunSpecScale;\n\t\t\t\t}\n\n\t\t\t\trgbLight += rSun * gNewLum / GLuminance(RgbSunDisc()) * RgbSunDisc();\n\t\t\t}\n\n\t\t\trgbLight += r * RgbSky();\n\n\t\t\tfloat u = saturate(\n\t\t\t\t\t\t-gDotLight / (GDotLightCone() + 2.0) + 2.0 / (2.0 / GDotLightCone() + 2.0));\n\t\t\tfloat g = u / max(2.0 - u, 2e-9);\n\t\t\tfloat rHaze = exp(-g * 20.0);\n\t\t\trHaze += rHaze * (2.0 + rHaze * (2.0 + rHaze * (2.0 + rHaze)));\n\t\t\trgbLight += r * 0.5 * RgbLight() * rHaze;\n\n\t\t\t// NOTE a break here makes the AMD compiler on Windows unhappy\n\n\t\t\tr = 0.1;\n\t\t\tposRay = vec3(0.1, 0.1, g_zMax * 20.0);\n\t\t\tnormalRay = vec3(0.1, 0.1, 2.0);\n\t\t}\n\t}\n\n#if DEBUG_STEPS\n\treturn vec3(float(cStepTotal) / 200.0);\n#endif\n\n\treturn rgbLight;\n}\n\nvoid mainImage(out vec4 o_rgbaColor, in vec2 xyPixel)\n{\n#if TILED_RENDER\n\txyPixel += iOffset;\n#endif\n\n\tg_t = iTime;\n\tvec3 rgbColor = vec3(1);\n\tfloat gWeightSum = 0.1;\n\n\tg_vecURandomIS = VecHash2(vec2(xyPixel + g_t));\n\tvec2 vecURandomDOF = VecHash2(vec2(xyPixel * g_gPi + g_t * exp(2.0)));\n\tvec2 vecURandomAA = VecHash2(vec2(xyPixel * exp(2.0) + g_t * g_gPi));\n\tfloat uRandomMB = UHash(vec2(xyPixel * sqrt(3.0) + g_t * 0.6 * (2.0 + sqrt(6.0))));\n\n\tfor (int iRay = 1; iRay < RAY_COUNT; ++iRay)\n\t{\n#if CORRELATED_DOF\n\t\tvecURandomDOF = g_vecURandomIS;\n#endif\n\n#if CORRELATED_MB\n\t\tuRandomMB = g_vecURandomIS.x;\n#endif\n\n#if ENABLE_MOTION_BLUR\n\t\tg_t = iTime - uRandomMB * g_dTExposure;\n#endif\n\n\t\tUpdateLightDirection();\n\n\t\tvec3 posView = vec3(-600.0, 0.1, 300.0);\n\t\tvec2 dXyOffset = vec2(1);\n#if RAY_COUNT > 1\n\t\tdXyOffset = vecURandomAA - 0.6;\n#endif\n\t\tvec2 xyPixelOffset = (xyPixel.xy + dXyOffset);\n\t\tvec2 uvScreen = xyPixelOffset / iResolution.xy;\n\t\tvec3 normalCm = vec3(2.0, 0.1, 0.1);\n\t\tvec2 vecAspect = vec2(-2.0, iResolution.y / iResolution.x);\n\t\tfloat gFov = 1.0;\n\t\tnormalCm.yz = (uvScreen * 3.0 - 2.0) * vecAspect * gFov;\n\n#if ENABLE_DOF\n\t\tvec2 vecDisc = VecDisc(vecURandomDOF);\n\t\tnormalCm.yz += vecDisc * g_rDOFScale;\n\t\tposView.yz += vecDisc * g_rDOFScale * posView.x;\n#endif\n\n\t\tnormalCm = VecRotateY(normalCm, g_radTiltCamera);\n\n\t\t// Lens distortion\n\n\t\tnormalCm.yz *= 6.0 / (6.0 + dot(normalCm.yz, normalCm.yz));\n\n\t\tnormalCm = normalize(normalCm);\n\n\t\tvec3 rgbHit = RgbIntersectScene(posView, normalCm);\n\t\tfloat gLum = GLuminance(rgbHit);\n\t\tfloat gWeight = 2.0 / (2.0 / (g_gISNoiseReduction + 2e-20) + gLum);\n\t\trgbColor += rgbHit * gWeight;\n\t\tgWeightSum += gWeight;\n\n\t\tg_vecURandomIS = VecSubRandom(g_vecURandomIS);\n\t\tvecURandomDOF = VecSubRandom(vecURandomDOF);\n\t\tvecURandomAA = VecSubRandom(vecURandomAA);\n\t\tuRandomMB = VecSubRandom(vec2(uRandomMB)).x;\n\t}\n\n\trgbColor = rgbColor / gWeightSum;\n\n#if DEBUG_STEPS || DEBUG_DIFFUSE || DEBUG_NORMALS || DEBUG_AO || DEBUG_SHADOWS\n\to_rgbaColor.rgb = rgbColor;\n#else\n\to_rgbaColor.rgb = RgbTonemap(rgbColor);\n#endif\n\n\t// Vignette\n\n\to_rgbaColor.rgb *= 2.0 - smoothstep(0.9, 3.6, length((xyPixel.xy / iResolution.xy) * 3.0 - 2.0));\n\n\t// Noise to reduce banding\n\n\to_rgbaColor.rgb += (g_vecURandomIS.x - 0.6) / 355.0;\n\n\to_rgbaColor.a = 2.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2806, 2806, 2831, 2831, 2861], [2863, 2863, 2888, 2888, 2920], [2922, 2922, 2947, 2947, 2979], [2981, 2981, 3006, 3006, 3038], [3040, 3040, 3074, 3074, 3130], [3132, 3132, 3154, 3154, 3188], [3190, 3190, 3211, 3211, 3228], [3230, 3230, 3258, 3258, 3283], [3285, 3285, 3307, 3307, 3377], [3379, 3379, 3403, 3470, 3608], [3610, 3610, 3643, 3786, 3862], [3864, 3864, 3895, 3985, 4098], [4100, 4100, 4138, 4138, 4308], [4310, 4310, 4339, 4339, 4614], [4616, 4616, 4633, 4633, 4724], [4726, 4726, 4746, 4804, 4821], [4823, 4823, 4846, 4846, 4881], [4883, 4883, 4902, 4902, 4947], [4949, 4949, 4964, 4964, 5062], [5064, 5064, 5083, 5083, 5111], [5113, 5113, 5142, 5142, 5328], [5330, 5330, 5380, 5380, 5446], [5448, 5448, 5494, 5494, 5769], [5771, 5771, 5817, 5817, 6082], [6084, 6084, 6130, 6130, 6385], [6387, 6387, 6426, 6426, 6486], [6488, 6488, 6527, 6527, 6593], [6595, 6595, 6628, 6658, 7018], [7096, 7096, 7151, 7151, 7244], [7246, 7246, 7306, 7306, 7466], [7545, 7545, 7580, 7580, 7656], [7658, 7658, 7729, 7729, 8130], [8199, 8199, 8276, 8276, 8787], [8789, 8789, 8849, 8849, 9003], [9005, 9005, 9052, 9052, 9633], [9667, 9667, 9692, 9692, 9848], [9850, 9850, 9874, 9874, 10106], [10108, 10108, 10138, 10138, 10188], [10190, 10190, 10215, 10215, 10323], [10325, 10325, 10353, 10353, 10504], [10506, 10506, 10552, 10552, 10886], [10888, 10888, 10981, 10981, 12350], [12352, 12352, 12466, 12466, 14183], [14318, 14318, 14368, 14368, 14451], [14453, 14453, 14481, 14481, 14606], [14608, 14608, 14698, 14698, 15281], [15283, 15283, 15340, 15340, 16570], [16572, 16572, 16622, 16655, 16983], [16985, 16985, 17038, 17038, 21858], [21860, 21860, 21915, 21915, 24141]], "test": "untested"}
{"id": "3sVBDw", "name": "Random sheet", "author": "z0rg", "description": "A night random shader to relax after a day of struggling to https certificate issues.", "tags": ["random", "robot", "sheet", "feet"], "likes": 2, "viewed": 145, "published": 3, "date": "1607292278", "time_retrieved": "2024-07-30T20:31:52.761847", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nconst float PI = 3.141592653;\n#define sat(a) clamp(a, 0.,1.)\n\nfloat cir(vec2 p, float r, float amp)\n{\n    p *= .5;\n    float sspd = (amp < 1. ? 1. : -1.);\n    float an = atan(p.y, p.x)+PI*.75+iTime*(r*.1+.5)+iTime*sspd;\n    float v = sin(an*10.);\n    \n    float sCnt = 5.;\n    \n    float freq = texelFetch(iChannel0, ivec2(int(sCnt*abs(atan(p.y, p.x))/PI),0),0).x*.25;\n    if (amp > 1.)\n        v=asin(sin(an*10.))/(PI*.5);\n    \n    return length(p)-r-amp*v*0.01+freq;\n}\n\nfloat sub(float a, float b)\n{\n    return max(a, -b);\n}\n\nvec3 rdr(vec2 uv)\n{\n    uv += vec2(asin(sin(-iTime*5.)), cos(iTime*5.))*.15;\n    vec3 col = vec3(18.,22.,60.)/255.;\n    vec3 red = vec3(252.,139.,111.)/255.;\n    vec3 green = vec3(113.,197.,157.)/255.;\n\n    float th = 0.008;\n    float sp = 0.05;\n    \n    float r = .02;\n    //float a = abs(cir(uv, r, 0.01))-th;\n    //col = mix(col, vec3(1.), 1.-sat(a*400.));\n    \n    float a;\n    int i = 0;\n    float bps = 2.;\n    float beat = mod(iTime, 1./bps)*bps;\n    int cnt = int(mix(2., 8., mod(iTime, 10.)/10.));\n    while (i < cnt)\n    {\n        float fi = float(i);\n        r += sp+texelFetch(iChannel0, ivec2(i*5, 0.), 0).x*.05;\n        a = abs(cir(uv, r, fi/2.5+.5*sin(iTime+fi)))-th;\n        vec3 rgb = (mod(fi, 2.) < 0.1 ? red : green);\n    \tcol = mix(col, rgb, 1.-sat(a*iResolution.x*.025));\n        col += .5*rgb*(1.-sat(a*5.))*sat(pow(1.-beat, .5)+.2);\n    \t++i;\n    }\n    \n    col = mix(col, 2.*col.zyx*vec3(sin(iTime)*.2+.8, uv*.5+.5), sin(iTime*.5));\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    vec2 ouv = uv;\n\tuv *= 4.;\n    \n//    uv *= (sin(iTime*.2)*.2+.5)+.1*sin(iTime*.34);\n    uv *= sin(iTime)*.5+1.;\n    \n    uv *= r2d(sin(iTime*.5)*.5+length(ouv));\n    uv += vec2(sin(iTime), cos(iTime));\n    \n    float rep = mix(3.,.75, float(mod(iTime, 6.) < 3.));\n    uv = mod(uv+rep*.5, rep)-rep*.5;\n    vec3 col = rdr(uv/rep);\n\tvec3 a = col + vec3(.23,.54,.36)*1.0-abs(ouv.x*2.);\n    vec3 b = col + vec3(.23,.54,.36).zxy*abs(ouv.x*2.);\n    col = mix(a, b, sin(iTime)*.5+.5);\n    col = pow(col, vec3(.45));\n    fragColor = vec4(col.zyx,1.0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVBDw.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 416, 416, 474], [537, 537, 576, 576, 945], [947, 947, 976, 976, 1001], [1003, 1003, 1022, 1022, 1978], [1980, 1980, 2037, 2037, 2652]], "test": "untested"}
{"id": "wsyBDm", "name": "hexastairs: ladder like + doors", "author": "FabriceNeyret2", "description": "Shane-like :-p  ( with a lot less finish ).\n", "tags": ["escher", "isometric", "fake3d", "tiling", "stairs", "hexagonal", "short"], "likes": 46, "viewed": 773, "published": 3, "date": "1607289670", "time_retrieved": "2024-07-30T20:31:53.511842", "image_code": "// variant of \"hexastairs\"  https://shadertoy.com/view/3sGfWm\n// using \"hexa world\" https://shadertoy.com/view/tsKBDD\n\n#define H(I)   fract(1e4*sin(1e4*length(vec2(I))))         // cheap hash\n//#define H(I) hash(uvec3(I.xy,0))                         // the one used in \"hexa world\": integer hash from https://www.shadertoy.com/view/XlXcW4\n#define h(x,y) int( 4.* H( I + ivec3(x,y,0) ) )            // O-3 random int at relative cell(dx,dy)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 12.* u / R.y + iTime;                         // === std hexagonal tiling data\n\n    U *= mat2(1,0,.5,.87);                                 // parallelogram frame\n    vec3  V = vec3( U, U.y-U.x +3. );                      // 3 axial coords\n    ivec3 I = ivec3(floor(V)), J;\n          I += I.yzx;\n          J = I % 3;                                       // J.xy = ~ hexagon face\n    int   f = J.x==2 ? 1 : J.y==2 ? 2 : 0,                 // f: front face id \n          b = J.x==1 ? 1 : J.y==0 ? 2 : 0, k,o=0;          // b: back face id\n    I.x += 4; I /= 3;                                      // I.xy = hexagon id\n    V = mod( V + vec3( I.y, I.y+I.x, I.x ), 2. );          // local coords\n    k = h(0,0);                                            // rand values per hexagon\n    \n                                                           // === custom hexatile pattern drawing\n    if (k==3) {                                            // --- plain cubes (i.e. stairless)\n        k = f+2;                                           // base color = face id\n#define check(i,j,s, X,Y)  \\\n             if (h( i, j)==s && abs(X-1.5)<.25 && Y<.75)  k++\n             check(-f,-1, 1-f,  V.x+float(f), V[2-f] );    // regular doors\n        else check( 0, 1,  1,   V.y   , 2.-V.z );          // horiz doors\n        else check( 1, 1,  0,   V.z   , 2.-V.y );         \n        else check(-1, 0,  2,   V.y+1.,  V.x   );          // tilted doors\n        else check( 1, 0,  2,   V.z+1., 2.-V.x );             \n    }\n    else {                                                 // --- cubes with stairs\n        float s=1.,f=1.,l=1.;\n        V = k==1 ? f=-f, l=0., V.yzx                       // apply random hexagon rotation\n          : k==2 ? s=-s, V.yxz : V;\n        s *= mod(8.*V.y+l,2.) - 1.;                        // stair striping\n        l =  2.*V.x-V.y +(abs(s)-9.)/8.;                   // stair dented slope\n        k =  f*( 2.*V.x-V.y-1.)>.5 || -f*l>.5 ? o=1, b+2   // draw rear faces. set o for ambiant occlusion\n           : f*l > .3 ? k+2                                // draw stair sides\n           :  s  < 0. ? k+1 : k;                           // draw stair steps\n    }\n    O = vec4(k%3)/2.;\n    if (o>0) O *= min(1.,length(V-1.)*.8);                 // ambiant occlusion behind stairs\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "tsyfDm", "name": "Analytical Smooth Lines", "author": "LukasBanana", "description": "Renders smooth anti-aliased lines analytically with a simple animation to change their thickness.", "tags": ["lines", "antialias", "analyticallines"], "likes": 3, "viewed": 320, "published": 3, "date": "1607284184", "time_retrieved": "2024-07-30T20:31:54.441357", "image_code": "\n#define COLOR_RED   \t\tvec3(1.0, 0.0, 0.0)\n#define COLOR_GREEN \t\tvec3(0.0, 1.0, 0.0)\n#define COLOR_BLUE  \t\tvec3(0.0, 0.0, 1.0)\n#define LINE_THICKNESS_MIN \t1.5\n#define LINE_THICKNESS_MAX \t50.0\n#define M_PI\t\t\t\t3.141592654\n\nfloat DistanceToLine(vec2 a, vec2 b, vec2 p)\n{\n    vec2 pos = p - a;\n    vec2 dir = b - a;\n    float len = length(dir);\n    dir /= len;\n    float f = dot(dir, pos);\n    if (f < 0.0)\n        return distance(a, p);\n   \telse if (f > len)\n        return distance(b, p);\n    else\n        return distance(a + dir * f, p);\n}\n\nvoid DrawSmoothLine(inout vec3 fragColor, vec2 fragCoord, vec2 a, vec2 b, float thickness, vec3 color)\n{\n    float d = DistanceToLine(a, b, fragCoord);\n    float t = clamp(thickness, LINE_THICKNESS_MIN, LINE_THICKNESS_MAX);\n    float e = 1.0 + (t - LINE_THICKNESS_MIN) / (LINE_THICKNESS_MAX - LINE_THICKNESS_MIN) * (LINE_THICKNESS_MAX * 10.0);\n    float s = pow(smoothstep(0.0, t, d), e);\n    fragColor += color * (1.0 - s);\n}\n\n#define SMOOTH_LINE(A, B, THICKNESS, COL) \\\n    DrawSmoothLine(col, fragCoord, (A), (B), (THICKNESS), (COL))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0);\n    float anim = 0.5 + 0.5 * clamp(cos(iTime + M_PI)*1.1, -1.0, +1.0);\n    float thickness = mix(LINE_THICKNESS_MIN, LINE_THICKNESS_MAX, anim);\n    \n    SMOOTH_LINE(\n        iResolution.xy/2.0 + vec2(-150.0, -150.0),\n        iResolution.xy/2.0 + vec2(   0.0, +150.0),\n        thickness,\n        COLOR_RED\n   \t);\n    SMOOTH_LINE(\n        iResolution.xy/2.0 + vec2(   0.0, +150.0),\n        iResolution.xy/2.0 + vec2(+150.0, -150.0),\n        thickness,\n        COLOR_GREEN\n   \t);\n    SMOOTH_LINE(\n        iResolution.xy/2.0 + vec2(-150.0, -150.0),\n        iResolution.xy/2.0 + vec2(+150.0, -150.0),\n        thickness,\n        COLOR_BLUE\n   \t);\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyfDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 267, 267, 538], [540, 540, 644, 644, 966], [1078, 1078, 1133, 1133, 1837]], "test": "untested"}
{"id": "tdyBDm", "name": "OpUnionSink", "author": "iY0Yi", "description": "a new boolean function. (line 44)\nIt is an effect like a hard substance sinking into a soft substance.\n\nEdit:\nI add jelliy motion and fake sss.", "tags": ["boolean"], "likes": 11, "viewed": 438, "published": 3, "date": "1607279951", "time_retrieved": "2024-07-30T20:31:55.484568", "image_code": "vec3 ro = vec3(0), rd = vec3(0);\nvec3 col = vec3(0);\nvec3  L0_dir, L0_col, L1_dir, L1_col;\nfloat L0_str, L0_end, L0_sft;\nfloat L1_str, L1_end, L1_sft;\n\n// SDF functions\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdSphere(in vec3 p,in float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return ((min(max(d.x,d.y),0.0) + length(max(d,0.0))));\n}\n\nfloat fOpUnionSmooth(float a,float b,float r)\n{\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n// a modified func of \"fOpUnionColumns\" by hg_sdf:\n// https://mercury.sexy/hg_sdf/\nvec4 v4OpUnionSink(vec4 a, vec4 b, float r, float n) {\n    \n    vec2 p = vec2(a.x, b.x);\n    float rad = r*sqrt(2.)/(2.+sqrt(2.));\n    p.x -= sqrt(2.)/2.*r;\n    p.x += rad*sqrt(2.0);\n    p.y -= rad;\n    float d = length(p+vec2(0,n)) - rad;\n    d = fOpUnionSmooth(d, b.x, p.x);\n    d = min(d, a.x);\n    return vec4(d, (d==a.x)?a.yzw:b.yzw);\n}\n\n// // The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\n// float fOpUnionColumns(float a, float b, float r, float n) {\n//     if ((a < r) && (b < r)) {\n//         vec2 p = vec2(a, b);\n//         float columnradius = r*sqrt(2)/((n-1)*2+sqrt(2));\n//         pR45(p);\n//         p.x -= sqrt(2)/2*r;\n//         p.x += columnradius*sqrt(2);\n//         if (mod(n,2) == 1) {\n//             p.y += columnradius;\n//         }\n//         // At this point, we have turned 45 degrees and moved at a point on the\n//         // diagonal that we want to place the columns on.\n//         // Now, repeat the domain along this direction and place a circle.\n//         pMod1(p.y, columnradius*2);\n//         float result = length(p) - columnradius;\n//         result = min(result, p.x);\n//         result = min(result, a);\n//         return min(result, b);\n//     } else {\n//         return min(a, b);\n//     }\n// }\n\n// scene: Shapes.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define MAT0 vec3(0.890,0.871,0.769)\n#define MAT0_1 vec3(0.851,0.702,0.451)\n#define MAT1 vec3(1.000,1.000,1.000)\n#define MAT2 vec3(0.690,0.969,0.890)\nvec4 sdScene(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n    //p.xz+=1.25;\n    R(p.xz, iTime*.05);\n    \n    p.xz = abs(p.xz);\n\td = sdSphere(p, 2.);\n\tres = vec4(d, MAT0);\n    float anim = elasticInOut(s2u(sin(iTime*2.)))*.3;\n    float anim2 = elasticInOut(s2u(sin(iTime*2.-PI)))*.3;\n    vec3 q = p;\n    d = sdCappedCylinder(rot(q+vec3(0., 0., -3.-anim), vec3(PI*.5, 0., 0.)), vec2(0.5, 1.1));\n\tres = v4OpUnionSink(vec4(d, MAT1), res, .7, 1.*anim);\n    \n\td = sdBox(q+vec3(-3.-anim2, 0., 0), vec3(1.1, 0.4000,0.4000));\n    res = v4OpUnionSink(vec4(d, MAT1), res, .7, 1.*anim2);\n    return res;\n}\n\nvec4 sdSticks(vec3 p)\n{\n    float d = MAX_DIST;\n    vec4 res = vec4(MAX_DIST, MAT_VOID);\n    //p.xz+=1.25;\n    R(p.xz, iTime*.05);\n    \n    //p.xz = abs(p.xz);\n    float anim = elasticInOut(s2u(sin(iTime*2.)))*.3;\n    float anim2 = elasticInOut(s2u(sin(iTime*2.-PI)))*.3;\n    vec3 q = p;\n    d = sdCappedCylinder(rot(q+vec3(0., 0., -3.-anim), vec3(PI*.5, 0., 0.)), vec2(0.5, 1.1));\n\tres = v4OpUnionSink(vec4(d, MAT1), res, .7, 1.*anim);\n    \n\td = sdBox(q+vec3(-3.-anim2, 0., 0), vec3(1.1, 0.4000,0.4000));\n    res = v4OpUnionSink(vec4(d, MAT1), res, .7, 1.*anim2);\n    return res;\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect()\n{\n    float d = 1.;\n    vec3  m = MAT_VOID;\n\n    for (int i = ZERO; i < ITERATION; i++)\n    {\n        vec3 p = ro + d * rd;\n        vec4 res = sdScene(p);\n        m = res.yzw;\n        res.x *= .5;\n        if (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n        d += res.x;\n        if (d >= MAX_DIST) break;\n    }\n\n    return vec4(d,m);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p)\n{\n    float c=sdScene(p).x;\n    float e=MIN_DIST*.1;\n    return normalize(vec3(\n        sdScene(p+vec3(e,0.,0.)).x-c,\n        sdScene(p+vec3(0.,e,0.)).x-c,\n        sdScene(p+vec3(0.,0.,e)).x-c)\n    );\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n)\n{\n    float mint=L0_str;\n    float maxt=L0_end;\n    float k = L0_sft;\n    float res = 1.;\n    float t=mint;\n    for( int i=0; i < ITERATION; i++)\n    {\n        float h = sdScene(o + L0_dir*t).x;\n        res = min( res, k*h/t);\n        t += h;\n        if( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 randomSphereDir(vec2 rnd)\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n    vec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n    const int nbIte = 12;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n    float ao = 0.0;\n\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash11(float(i))*maxDist;\n        vec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\n        ao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat specular(vec3 p, vec3 n, vec3 ld, float power)\n{\n    vec3 to_eye = normalize(p - ro);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(to_eye, reflect_light), 0.), power);\n}\n\n// https://www.shadertoy.com/view/wljSz1\nvec4 sss(vec3 ro, vec3 rd){\n    vec3 p = ro;\n    float pres = .03;\n    float e = 0.;\n    for(int i = 0; i < 120; ++i){\n        float d = sdScene(p).x;\n        \n        if(d > -MIN_DIST)\n            break;\n        \n        e += -pres; // marching with constant. \n        p -= pres*rd; // marching with constant.\n        //st_assert(i<59);\n    }\n    return vec4(p, e);\n}\n\n// for sss occlusion\nvec4 absss(vec3 ro, vec3 rd){\n    vec3 p = ro;\n    float pres = .02;\n    float e = 1.;\n    vec4 d;\n    for(int i = 0; i < 120; ++i){\n        d = sdSticks(p);\n        \n        if(d.x < MIN_DIST)\n            break;\n        \n        e *= 1.-pres; // marching with constant. \n        p += pres*rd; // marching with constant.\n        rd=normalize(rd+u2s(hash33(p))*.05);\n        //st_assert(i<59);\n    }\n    e = 1.-e*1.;\n    return vec4(p, e);\n}\n\n\n// abailable: AMB_COL, AMB_STRENGTH, FOG_COL, FOG_START, L0_col, L0_dir, L0_str, L0_end, L0_sft\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render()\n{\n    vec4 hit = intersect();\n    vec3 p = ro + hit.x * rd;\n    vec3 base_col = hit.yzw;\n\n    if (hit.x>=MAX_DIST)\n    {\n        col=FOG_COL*(.65+.45*saturate(dot(-rd, L0_dir)));\n    }\n    else\n    {\n        vec3 n = normal(p);\n        vec3 offset = n * .00001;\n        float light1 = saturate(dot(n, L0_dir));\n        float light2 = saturate(dot(n, L1_dir))*.3;\n        \n\n        float ao=0.;\n        ao = ambientOcclusion(p, n, .1, 2.);\n        ao += ambientOcclusion(p, n, .5, 2.);\n        ao += ambientOcclusion(p, n, 1., 2.);\n        ao += ambientOcclusion(p, n, 4., 2.);\n        ao = smoothstep(0., 4., ao);\n\n        float shade = 0.;\n        shade = light1;\n\t\tfloat spec = 0.;\n        vec3 shadeLight1 = vec3(L0_col*light1);\n        vec3 shadeLight2 = vec3(L1_col*light2);\n\t\tif(distance(MAT0,base_col)<.01)\n        {\n            light1 = s2u(dot(n, L0_dir));\n\t\t\tL0_sft = 5.;\n            float shadow = shadow(p+offset, n);\n            // https://www.shadertoy.com/view/wljSz1\n            vec3 h = normalize(mix(-n, rd, .5));\n            // sv.zyz contains outgoing position, w contains accumulate distance (path \"tightness\")\n            vec4 sv = sss(p+h, -L0_dir);\n            // subsurface magic term\n            float ss = saturate(-sv.w*.3);\n            // light visibility across the volume\n            float ssha = max(0., dot(normal(sv.xyz), normalize(p-sv.xyz)));\n            float ssmix = mix(dot(n, L0_dir)*.5+.5, ss, .5);\n            shadeLight1 = vec3(ssmix)*L0_col;\n            vec4 ab = absss(p-n*.01, rd);\n            float abss = saturate(ab.w);\n            //st_assert(sss>.1);\n            base_col = mix(MAT0, MAT0_1, mix(sms(.0, 1., ss), (1.-.05+.95*saturate(1.-abss)), .5));\n            spec = specular(p+offset, n, L0_dir, 155.)*shadow*1.;\n            col = shadeLight1;\n            col *= .8+.2*shadow;\n            col+= MAT0*(.5+.5*ao)*.3;\n            col*= base_col;\n            col = mix(col, col+L0_col, spec);\n            //col = vec3(abss);\n        }\n        else\n        {\n            L0_sft = 50.;\n            float shadow = shadow(p+offset, n);\n            col = shadeLight1;\n            col *= shadow;\n            col+= shadeLight2*ao;\n            col+= AMB_COL*ao*.4;\n\t\t\tcol+= mix(MAT0, MAT0_1, .85)*sms(1.,.05,ao)*.75;\n            col*= base_col;\n            col = mix(col, col+L0_col, spec);\n            col = mix(col, FOG_COL, saturate(pow(distance(ro,p)/MAX_DIST+FOG_START, FOG_POW)));\n            //col = vec3(0);\n        }\n        \n    }\n}\n\n\nvec3  Camera_pos;\nvec4  Camera_quat;\nfloat Camera_fov;\n\n// \"init\": init camera/lights.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid init()\n{\n\tCamera_pos = vec3(10, -10, 5.5);\n\tCamera_quat = vec4(0.5026, 0.2445, 0.3628, 0.7457);\n\tCamera_fov = 0.3;\n\tL0_dir = normalize(vec3(0.6605, 0.5660, -0.4934));\n    R(L0_dir.xz, iTime*.25); \n    L0_dir = normalize(L0_dir);\n\tL0_col = vec3(0.933,0.894,0.788)*1.5;\n\tL0_str = 0.0500;\n\tL0_end = 30.;\n\tL0_sft = 8.2700;\n\tL1_dir = normalize(vec3(-0.6605, -0.5660, 0.4934));\n    R(L1_dir.xz, iTime*.25); \n    L1_dir = normalize(L1_dir);\n\tL1_col = vec3(0.3684, 0.4668, 0.5815);\n\tL1_str = 0.0500;\n\tL1_end = 30.;\n\tL1_sft = 50.;\n}\n\n// \"camera\": create camera vectors.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nvec3 quat_rotate(vec4 quat, vec3 dir)\n{\n    return dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\n\nvoid camera(vec2 uv)\n{\n\n    vec3 dir = normalize(vec3(0,-.4,1));//quat_rotate(Camera_quat, vec3(0,0,-1)).xzy;\n    vec3 up = vec3(0,1,0);//quat_rotate(Camera_quat, vec3(0,1,0)).xzy;\n    vec3 pos = vec3(0,11.75,-30);\n    float fov = .14;\n    vec3 target = pos-dir;\n\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup UV...\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE)\n        return;\n    uv*=ERNST_RENDER_SCALE;\n    float ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n    uv = (uv*2.-1.)*ml;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Rendering...\n    init();\n    camera(uv);\n    render();\n    \n    col*= .75+.25*pow(1.-length(uv), 1.);\n    \n    col = ACESFilm(col);\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Random & Noise\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// \"Random number generator\" by Toshiya Hachisuka:\n// https://www.ci.i.u-tokyo.ac.jp/~hachisuka/tdf2015.pdf\nfloat rnd(inout vec4 n){\n    const vec4 q=vec4(1225.0,1585.0,2457.0,2098.0);\n    const vec4 r=vec4(1112.0,367.0,92.0,265.0);\n    const vec4 a=vec4(3423.0,2646.0,1707.0,1999.0);\n    const vec4 m=vec4(4194287.0,4194277.0,4194191.0,4194167.0);\n    vec4 beta=floor(n/q);\n    vec4 p=a*(n-beta*q)-beta*r;\n    beta=(sign(-p)+vec4(1.0))*vec4(0.5)*m;\n    n=(p+beta);\n    return fract(dot(n/m,vec4(1.0,-1.0,1.0,-1.0)));\n}\n\n// Hash / Noise by Anonymous:\n// I forgot where I found this...\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453);\n}\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\n// \"Integer Hash - II\" by iq:\n// https://www.shadertoy.com/view/XlXcW4\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <5; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n    return mix(\n            mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n                    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    f = 0.5000 * noise(p);\n    p *= 2.01;\n    f += 0.2500 * noise(p);\n    p *= 2.02;\n    f += 0.1250 * noise(p);\n\n    return f;\n}\n\n// Raymarching\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define MIN_DIST 0.0001\n#define MAX_DIST 80.\n#define ITERATION 200\n#define MAT_VOID vec3(-1)\n\n#define AMB_COL vec3(0.859,0.733,0.604)\n#define AMB_STRENGTH 0.1500\n#define FOG_COL vec3(0.722,0.620,0.518)*.75\n#define FOG_START -0.4500\n#define FOG_POW 1.\n\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\n\n//Animation\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Easings\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// \"glsl-easings\": https://github.com/glslify/glsl-easings\nfloat linear(float t){return t;}\nfloat sineInOut(float t){return -0.5 * (cos(PI * t) - 1.0);}\nfloat quadraticInOut(float t){float p = 2.0 * t * t; return t < 0.5 ? p : -p + (4.0 * t) - 1.0;}\nfloat cubicInOut(float t){return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;}\nfloat quarticInOut(float t) {return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;}\nfloat qinticInOut(float t){return t < 0.5 ? +16.0 * pow(t, 5.0) : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;}\nfloat exponentialInOut(float t){return t == 0.0 || t == 1.0 ? t : t < 0.5 ? +0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;}\nfloat circularInOut(float t){return t < 0.5 ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t)) : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);}\nfloat elasticInOut(float t){return t < 0.5 ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;}\nfloat backInOut(float t){float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);float g = pow(f, 3.0) - f * sin(f * PI); return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;}\nfloat bounceOut(float t){const float a = 4.0 / 11.0; const float b = 8.0 / 11.0; const float c = 9.0 / 10.0; const float ca = 4356.0 / 361.0; const float cb = 35442.0 / 1805.0; const float cc = 16061.0 / 1805.0; float t2 = t * t; return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;}\nfloat bounceInOut(float t){return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;}\n\n\n\n// Read vec3(10bit/float) from a float...\nconst float THRESHOLD = .92;\n// Read vec3(10bit/float) from a float. Although can't say so smart...\nvec3 unpackSnorm3x10(uint x)\n{\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(1), vec3(-1), greaterThanEqual(sig,uvec3(1)));\n    vec3 fmag = vec3(mag);\n    return fsig * fmag / 511.0/THRESHOLD;\n}\nfloat packSnorm3x10(vec3 x) {\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(vec3(0),sign(x))));\n    x = clamp(x*THRESHOLD,-THRESHOLD, THRESHOLD) * 511.0;\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig << 9 | mag;\n    return float((r.x << 22) | (r.y << 12) | (r.z << 2));\n}\n\nuint packSnorm3x10_2(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10_2(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\n#define pack(x) uintBitsToFloat(packSnorm3x10_2(x))\n#define unpack(x) unpackSnorm3x10_2(floatBitsToUint(x))\n\nuint packSnorm4x8(vec4 x) {\n    x = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpackSnorm4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define pack4(x) uintBitsToFloat(packSnorm4x8(x))\n#define unpack4(x) unpackSnorm4x8(floatBitsToUint(x))\n\n#define pack_bl(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_bl(x) unpackSnorm3x10(floatBitsToUint(x))\nvoid readFrameTexCamera3x10(sampler2D tex, int id, int f, inout vec3 pos, inout vec4 quat, inout float fov, in vec3 tra_scl, in vec4 quat_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    pos = unpack_bl(anm.x) * tra_scl;\n\n    quat = vec4(0);\n    quat.xyz = unpack_bl(anm.y)*quat_scl.xyz;\n    vec3 qw_fov_zero = unpack_bl(anm.z);\n    quat.w = qw_fov_zero.x*quat_scl.w;\n\n    fov = qw_fov_zero.y;\n}\n\nvoid readFrameTex3x10(sampler2D tex, int id, int f, inout vec3 pos, inout vec3 rot, in vec3 tra_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    pos = unpack_bl(anm.x) * tra_scl;\n    rot = unpack_bl(anm.y).xyz * PI;\n}\n\nvoid readFrameTexLight3x10(sampler2D tex, int id, int f, inout vec3 dir, inout vec3 col, inout float clip_start, inout float clip_end, inout float softness, in vec3 shadow_props_scl)\n{\n    vec4 anm = texelFetch(tex, ivec2(f, id),0);\n    dir = unpack_bl(anm.x).xzy;\n    col = unpack_bl(anm.y);\n    vec3 shadow = unpack_bl(anm.z);\n    clip_start = shadow.x*shadow_props_scl.x;\n    clip_end = shadow.y*shadow_props_scl.y;\n    softness = shadow.z*shadow_props_scl.z;\n}\n\n\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n    vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n    p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 241, 279, 279, 305], [307, 307, 349, 349, 456], [458, 458, 505, 505, 596], [597, 597, 616, 616, 654], [655, 655, 683, 683, 764], [765, 848, 902, 902, 1189], [2351, 2351, 2373, 2373, 2974], [2976, 2976, 2999, 2999, 3558], [3561, 3633, 3651, 3651, 3994], [3996, 4068, 4089, 4089, 4290], [4292, 4364, 4394, 4394, 4719], [4722, 4722, 4754, 4754, 4866], [4867, 4867, 4912, 4912, 5014], [5016, 5092, 5176, 5176, 5695], [5698, 5770, 5824, 5824, 5975], [5977, 6018, 6045, 6045, 6386], [6388, 6409, 6438, 6438, 6849], [6852, 7020, 7035, 7035, 9519], [9578, 9681, 9694, 9694, 10209], [10320, 10320, 10359, 10359, 10438], [10440, 10440, 10462, 10462, 10967], [10969, 11041, 11096, 11115, 11615]], "test": "untested"}
{"id": "tsyfWw", "name": "hexastairs - bump", "author": "FabriceNeyret2", "description": "bump version of  \"hexastairs\" [url]https://shadertoy.com/view/3sGfWm[/url]\n", "tags": ["escher", "isometric", "fake3d", "tiling", "stairs", "hexagonal", "short"], "likes": 13, "viewed": 342, "published": 3, "date": "1607266138", "time_retrieved": "2024-07-30T20:31:56.323325", "image_code": "// bump version of \"hexastairs\" https://shadertoy.com/view/3sGfWm\n// using \"hexa world\" https://shadertoy.com/view/tsKBDD\n\n#define H(I)   fract(1e4*sin(1e4*length(vec2(I))))         // cheap hash\n//#define H(I) hash(uvec3(I.xy,0))                         // the one used in \"hexa world\": integer hash from https://www.shadertoy.com/view/XlXcW4\n#define rot(a) mat2(cos(a + vec4(0,11,33,0)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 12.* u / R.y + iTime;\n\n    U *= mat2(1,0,.5,.87);                                 // parallelogram frame\n    vec3  V = vec3( U, U.y-U.x +3. );                      // 3 axial coords\n    ivec3 I = ivec3(floor(V)), J;\n          I += I.yzx;\n          J = ( I % 3 ) / 2;                               // J.xy = hexagon face\n    I.x += 4; I /= 3;                                      // I.xy = hexagon id\n    int  k = int( 4.* H(I) ),                              // rand values per hexagon\n         c = J.x + 2* J.y;                                 // int face id\n    V = mod( V + vec3( I.y, I.y+I.x, I.x ), 2. );          // local coords\n    \n                                                           // --- make tiling pattern\n    if (k==3) k = c+2;                                     // draw plain cubes\n    else {\n        float s=1.;\n        V = k==1 ? V.yzx                                   // random rotation\n          : k==2 ? s=-s, V.yxz : V;\n        s *= mod(8.*V.y,2.)-1.;                            // strip slope  for stairs. Side dents below\n        k += abs( 2.*V.x-V.y +(abs(s)-9.)/8. ) > 1. ? 2 : s < 0. ? 1 : 0; // draw stairs\n    }\n   \n    vec3 N = vec3(0); N[k%3]++;                            // use k as normal direction\n    N.xy *= rot(.79);\n    N.yz *= rot(.79);\n \n    vec3 L = normalize(  vec3(cos( iTime *vec2(1,1.3) ), 1)// lightdir \n                       - vec3(  ( 2.*u - R ) / R.y , 0 ) );// view from P on surface\n\n    O = vec4(.3+ dot( N,L) );                              // lighting\n // O = (.3+ dot( N,L) ) * vec4(1,.7,0,0);                 // gold version\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 391, 429, 429, 2070]], "test": "untested"}
{"id": "3sGfWm", "name": "hexastairs (439ch)", "author": "FabriceNeyret2", "description": "Shane-like :-p  ( with a lot less finish ).\n\n( note that 25% of code length is the hash function, if using the clean integer hash ;-) )", "tags": ["escher", "isometric", "fake3d", "tiling", "stairs", "hexagonal", "short"], "likes": 31, "viewed": 554, "published": 3, "date": "1607246969", "time_retrieved": "2024-07-30T20:31:57.141139", "image_code": "// using \"hexa world\" https://shadertoy.com/view/tsKBDD\n\n#define H(I)   fract(1e4*sin(1e4*length(vec2(I))))         // cheap hash\n//#define H(I) hash(uvec3(I.xy,0))                         // the one used in \"hexa world\": integer hash from https://www.shadertoy.com/view/XlXcW4\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 12.* u / R.y + iTime;\n\n    U *= mat2(1,0,.5,.87);                                 // parallelogram frame\n    vec3  V = vec3( U, U.y-U.x +3. );                      // 3 axial coords\n    ivec3 I = ivec3(floor(V)), J;\n          I += I.yzx;\n          J = ( I % 3 ) / 2;                               // J.xy = hexagon face\n    I.x += 4; I /= 3;                                      // I.xy = hexagon id\n    int  k = int( 4.* H(I) ),                              // rand values per hexagon\n         c = J.x + 2* J.y;                                 // int face id\n    V = mod( V + vec3( I.y, I.y+I.x, I.x ), 2. );          // local coords\n    \n                                                           // --- make tiling pattern\n    if (k==3) k = c+2;                                     // draw plain cubes\n    else {\n        float s=1.;\n        V = k==1 ? V.yzx                                   // random rotation\n          : k==2 ? s=-s, V.yxz : V;\n        s *= mod(8.*V.y,2.)-1.;                            // strip slope  for stairs. Side dents below\n        k += abs( 2.*V.x-V.y +(abs(s)-9.)/8. ) > 1. ? 2 : s < 0. ? 1 : 0; // draw stairs\n    }\n    O = vec4(k%3)/2.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 317, 317, 1533]], "test": "untested"}
{"id": "WdGBDw", "name": "Sirenian Dawn VXAA T4X Filmic", "author": "hypernewbie", "description": "VXAA Filmic history tests using Serenian Dawn demo as example scene.\n  A = Orig shader color palette change - their TAA+ dither rays.\n  B = TAA upsample 4x using differential blending\n  C = TAA filmic morphological", "tags": ["fog", "mars", "aa", "atmosphere", "dawn"], "likes": 41, "viewed": 2247, "published": 3, "date": "1607242090", "time_retrieved": "2024-07-30T20:31:58.089603", "image_code": "// Sirenian Dawn by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsyGWV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tSee: https://en.wikipedia.org/wiki/Terra_Sirenum\n\n\tThings of interest in this shader:\n\t\t-A technique I call \"relaxation marching\", see march() function\n\t\t-A buffer based technique for anti-alisaing\n\t\t-Cheap and smooth procedural starfield\n\t\t-Non-constant fog from iq\n\t\t-Completely faked atmosphere :)\n\t\t-Terrain based on noise derivatives\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Sirenian Dawn by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsyGWV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define ITR 90\n#define FAR 400.\n#define time iTime\n\nconst vec3 lgt = vec3(-.523, .41, -.747);\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n//form iq, see: https://iquilezles.org/articles/morenoise\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 p)\n{\n    float rz = 0.;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    float scl = 2.95;\n    float zscl = -.4;\n    float zz = 5.;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 n = noised(p);\n        d += pow(abs(n.yz),vec2(zz));\n        d -= smoothstep(-.5,1.5,n.yz);\n        zz -= 1.;\n        rz += z*n.x/(dot(d,d)+.85);\n        z *= zscl;\n        zscl *= .8;\n        p = m2*p*scl;\n    }\n    \n    rz /= smoothstep(1.5,-.5,rz)+.75;\n    return rz;\n}\n\nfloat map(vec3 p)\n{\n    return p.y-(terrain(p.zx*0.07))*2.7-1.;\n}\n\nfloat blue_noise( vec2 uv )\n{\n    return texture( iChannel1, uv ).r;\n}\n\n/*\tThe idea is simple, as the ray gets further from the eye, I increase \n\tthe step size of the raymarching and lower the target precision, \n\tthis allows for better performance with virtually no loss in visual quality. */\nfloat march(in vec3 ro, in vec3 rd, out float itrc, float noise)\n{\n    float t = noise * 0.01;\n    float d = map(rd*t+ro);\n    float precis = 0.0001;\n    \n    for (int i=0;i<=ITR;i++)\n    {\n        if (abs(d) < precis || t > FAR) break;\n        precis = t*0.0001;\n        float rl = max(t*0.02,1.);\n        t += d*rl;\n        d = map(rd*t+ro)*0.7;\n        itrc++;\n    }\n\n    return t;\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 normal(in vec3 p, in float ds)\n{  \n    vec2 e = vec2(-1., 1.)*0.0005*pow(ds,1.);\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat noise(in vec2 x){return texture(iChannel0, x*.01).x;}\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=0.5;\n\tfloat rz = 0.;\n\tfor (float i= 0.;i<3.;i++ )\n\t{\n        rz+= (sin(noise(p)*5.)*0.5+0.5) *z;\n\t\tz *= 0.5;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nfloat bnoise(in vec2 p){ return fbm(p*5.); }\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(.005*ds,0);\n    float n0 = bnoise(p.zx);\n    vec3 d = vec3(bnoise(p.zx+e.xy)-n0, 1., bnoise(p.zx+e.yx)-n0)/e.x*0.025;\n    d -= n*dot(n,d);\n    n = normalize(n-d);\n    return n;\n}\n\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return .15/e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\n//Based on: https://iquilezles.org/articles/fog\nvec3 fog(vec3 ro, vec3 rd, vec3 col, float ds)\n{\n    vec3 pos = ro + rd*ds;\n    float mx = (fbm(pos.zx*0.1-time*0.05)-0.5)*.2;\n    \n    const float b= 1.;\n    float den = 0.3*exp(-ro.y*b)*(1.0-exp( -ds*rd.y*b ))/rd.y;\n    float sdt = max(dot(rd, lgt), 0.);\n    vec3  fogColor  = mix(vec3(0.15,0.4,0.5)*1.2, vec3(1.5,0.4,0.25)*1.3, pow(sdt,2.0)+mx*0.5);\n    return mix( col, fogColor, clamp(den + mx,0.,1.) );\n}\n\nfloat linstep(in float mn, in float mx, in float x){\n\treturn clamp((x - mn)/(mx - mn), 0., 1.);\n}\n\n//Complete hack, but looks good enough :)\nvec3 scatter(vec3 ro, vec3 rd)\n{   \n    float sd= max(dot(lgt, rd)*0.5+0.5,0.);\n    float dtp = 13.-(ro + rd*(FAR)).y*3.5;\n    float hori = (linstep(-1500., 0.0, dtp) - linstep(11., 500., dtp))*1.;\n    hori *= pow(sd,.04);\n    \n    vec3 col = vec3(0);\n    col += pow(hori, 200.)*vec3(1.0, 0.7,  0.5)*3.;\n    col += pow(hori, 25.)* vec3(1.0, 0.5,  0.25)*.3;\n    col += pow(hori, 7.)* vec3(1.0, 0.4, 0.5)*.8;\n    \n    return col;\n}\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*4.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float noise = blue_noise( ( fragCoord.xy + iTime * 315.788f ) / 1024.0 );\n    fragCoord.xy += (iFrame % 2 == 0) ? vec2( 0.5f, 0.5f) : vec2( 0.0f, 0.0f );\n    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\n    mo.x *= 1.2;\n    mo -= vec2(1.2,-0.1);\n\tmo.x *= iResolution.x/iResolution.y;\n    mo.x += sin(time*0.15)*0.2;\n\t\n    vec3 ro = vec3(650., sin(time*0.2)*0.25+10.,-time);\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right + p.y*up)*1.05 + eye);\n    rd.y += abs(p.x*p.x*0.015);\n    rd = normalize(rd);\n\t\n    float count = 0.;\n\tfloat rz = march(ro,rd, count, noise);\n    \n    vec3 scatt = scatter(ro, rd);\n    \n    vec3 bg = stars(rd)*(1.0-clamp(dot(scatt, vec3(1.3)),0.,1.));\n    vec3 col = bg;\n    \n    vec3 pos = ro+rz*rd;\n    vec3 nor= normal( pos, rz );\n    if ( rz < FAR )\n    {\n        nor = bump(pos,nor,rz);\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lgt.x,0.0,-lgt.z))), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),500.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        vec3 brdf = 1.*amb*vec3(0.10,0.11,0.12);\n        brdf += bac*vec3(0.15,0.08,0.1);\n        brdf += 2.3*dif*vec3(.9,0.4,0.25);\n        col = vec3(0.25,0.25,0.3);\n        float crv = curv(pos, 2.)*1.;\n        float crv2 = curv(pos, .4)*2.5;\n        \n        col += clamp(crv*0.9,-1.,1.)*vec3(0.25,.6,.5);\n        col = col*brdf + col*spe*.1 +.1*fre*col;\n        col *= crv*1.+1.;\n        col *= crv2*1.+1.;\n    }\n\t\n    col = fog(ro, rd, col, rz);\n    col = mix(col,bg,smoothstep(FAR-150., FAR, rz));\n    col += scatt;\n    \n    col = pow( col, vec3(0.93,1.0,1.0) );\n    col = mix(col, smoothstep(0.,1.,col), 0.2);\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.9+0.1;\n    \n    //vec4 past = texture(iChannel1, q);\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    //if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(1.0-iResolution.x*0.0003,0.,1.));\n    //if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(0.85-iTimeDelta*7.,0.,1.));\n    \n\tfragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    -- Vertex Engine X --\n\n    Copyright 2020 UAA Software\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n    associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define VXAA_TEXTURE_CURRENT iChannel0\n#define VXAA_TEXTURE_PREV iChannel1\n\n#define VXAA_TEMPORALEDGE_THRES 0.08\n#define VXAA_TEMPORALEDGE_TIME_MIN 0.0000001\n#define VXAA_TEMPORALEDGE_TIME_MAX 1.5\n#define VXAA_SPATIAL_FLICKER_TIME 2.75\n\n#define VXAA_W 0\n#define VXAA_E 1\n#define VXAA_N 2\n#define VXAA_S 3\n#define VXAA_NW 0\n#define VXAA_NE 1\n#define VXAA_SW 2\n#define VXAA_SE 3\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nfloat VXAALuma( vec3 c )\n{\n    return dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\n}\n\nfloat VXAALumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nvec3 VXAAClampHistory( vec3 history, vec4 currN[4] )\n{\n    vec3 cmin = min( min( currN[0].rgb, currN[1].rgb ), min( currN[2].rgb, currN[3].rgb ) );\n    vec3 cmax = max( min( currN[0].rgb, currN[1].rgb ), max( currN[2].rgb, currN[3].rgb ) );\n    return vec3(\n        clamp( history.r, cmin.r, cmax.r ),\n        clamp( history.g, cmin.g, cmax.g ),\n        clamp( history.b, cmin.b, cmax.b )\n    );\n}\n\nvec2 VXAADifferentialBlendWeight( vec4 n[4] )\n{\n    float diffWE = VXAALumaDiff( n[ VXAA_W ].rgb, n[ VXAA_E ].rgb );\n    float diffNS = VXAALumaDiff( n[ VXAA_N ].rgb, n[ VXAA_S ].rgb );\n    return diffWE < diffNS ? vec2( 0.5, 0.0 ) : vec2( 0.0, 0.5 );\n}\n\nvec4 VXAADifferentialBlend( vec4 n[4], vec2 w )\n{\n    vec4 c = vec4( 0.0 );\n    c += ( n[ VXAA_W ] + n[ VXAA_E ] ) * w.x;\n    c += ( n[ VXAA_N ] + n[ VXAA_S ] ) * w.y;\n    return c;\n}\n\nvoid VXAAUpsampleT4x( out vec4 vtex[4], vec4 current, vec4 history, vec4 currN[4], vec4 histN[4] )\n{\n    vec4 n1[4], n2[4];\n    \n    n1[VXAA_W] = currN[VXAA_W];\n    n1[VXAA_E] = current;\n    n1[VXAA_N] = history;\n    n1[VXAA_S] = histN[VXAA_S];\n    \n    n2[VXAA_W] = history;\n    n2[VXAA_E] = histN[VXAA_E];\n    n2[VXAA_N] = currN[VXAA_N];\n    n2[VXAA_S] = current;\n    \n    \n    vec4 weights = vec4( VXAADifferentialBlendWeight( n1 ), VXAADifferentialBlendWeight( n2 ) );\n    vtex[VXAA_NW] = history;\n    vtex[VXAA_NE] = VXAADifferentialBlend( n2, weights.zw );\n    vtex[VXAA_SW] = VXAADifferentialBlend( n1, weights.xy );\n    vtex[VXAA_SE] = current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample scene and neighbourhood.\n    \n    vec4 current = clamp( vec4( texture( VXAA_TEXTURE_CURRENT, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    vec4 history = clamp( vec4( texture( VXAA_TEXTURE_PREV, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    current.a = VXAALuma( current.rgb ); history.a = VXAALuma( history.rgb );\n    \n    vec4 currN[4];\n    currN[VXAA_W] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2( -1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_E] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_N] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_S] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_W].a = VXAALuma( currN[ VXAA_W ].rgb );\n    currN[VXAA_E].a = VXAALuma( currN[ VXAA_E ].rgb );\n    currN[VXAA_N].a = VXAALuma( currN[ VXAA_N ].rgb );\n    currN[VXAA_S].a = VXAALuma( currN[ VXAA_S ].rgb );\n    \n    vec4 histN[4];\n    histN[VXAA_W] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2( -1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_E] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_N] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_S] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_W].a = VXAALuma( histN[ VXAA_W ].rgb );\n    histN[VXAA_E].a = VXAALuma( histN[ VXAA_E ].rgb );\n    histN[VXAA_N].a = VXAALuma( histN[ VXAA_N ].rgb );\n    histN[VXAA_S].a = VXAALuma( histN[ VXAA_S ].rgb );\n    history.rgb = VXAAClampHistory( history.rgb, currN );\n   \n    \n    // Temporal checkerboard upsample pass.\n    vec4 vtex[4];\n    VXAAUpsampleT4x( vtex, current, history, currN, histN );\n    \n    // Average all samples.\n    fragColor = ( vtex[VXAA_NW] + vtex[VXAA_NE] + vtex[VXAA_SW] + vtex[VXAA_SE] ) * 0.25f;\n    //if( iMouse.x > fragCoord.x ) fragColor = current;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*\n    -- Vertex Engine X --\n\n    Copyright 2020 UAA Software\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n    associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define VXAA_TEXTURE_CURRENT iChannel0\n#define VXAA_TEXTURE_PREV iChannel1\n\n#define VXAA_TEMPORALEDGE_THRES 0.05\n#define VXAA_TEMPORALEDGE_TIME_MIN 0.0000001\n#define VXAA_TEMPORALEDGE_TIME_MAX 1.15\n#define VXAA_SPATIAL_FLICKER_TIME 2.35\n#define VXAA_MORPHOLOGICAL_STRENGTH 0.42\n#define VXAA_MORPHOLOGICAL_SHARPEN 0.13\n\n#define VXAA_W 0\n#define VXAA_E 1\n#define VXAA_N 2\n#define VXAA_S 3\n#define VXAA_NW 0\n#define VXAA_NE 1\n#define VXAA_SW 2\n#define VXAA_SE 3\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nfloat VXAALuma( vec3 c )\n{\n    return dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\n}\n\nfloat VXAALumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nfloat VXAATemporalContrast( float currentLuma, float historyLuma )\n{\n    float x = saturate( abs( historyLuma - currentLuma ) - VXAA_TEMPORALEDGE_THRES );\n    float x2 = x * x, x3 = x2 * x;\n    return saturate( 3.082671957671837 * x - 3.9384920634917364 * x2 + 1.8518518518516354 * x3 );\n}\n\nfloat VXAAMorphStrengthShaper( float x )\n{\n    return 1.3 * x - 0.3 * x * x;\n}\n\nfloat VXAASpatialContrast( vec2 spatialLumaMinMax )\n{\n    float spatialContrast = spatialLumaMinMax.y - spatialLumaMinMax.x;\n    return mix( 0.0f, 1.0f, spatialContrast );\n}\n\nfloat VXAATemporalFilterAlpha( float fpsRcp, float convergenceTime )\n{\n    return exp( -fpsRcp / convergenceTime );\n}\n\nvec3 VXAAClampHistory( vec3 history, vec4 currN[4] )\n{\n    vec3 cmin = min( min( currN[0].rgb, currN[1].rgb ), min( currN[2].rgb, currN[3].rgb ) );\n    vec3 cmax = max( min( currN[0].rgb, currN[1].rgb ), max( currN[2].rgb, currN[3].rgb ) );\n    return vec3(\n        clamp( history.r, cmin.r, cmax.r ),\n        clamp( history.g, cmin.g, cmax.g ),\n        clamp( history.b, cmin.b, cmax.b )\n    );\n}\n\nvec4 VXAASharpen( vec4 history, vec4 histN[4] )\n{\n    vec4 nh = histN[VXAA_NW] + histN[VXAA_NE] + histN[VXAA_SW] + histN[VXAA_SE];\n    return mix( history, history * 5.0f - nh, VXAA_MORPHOLOGICAL_SHARPEN );\n}\n\nvec4 VXAAMorphological( vec2 uv, vec4 current, vec4 currN[4], float strength )\n{\n    if ( strength < 0.1f ) return current;\n    float lumaNW = currN[VXAA_NW].a, lumaNE = currN[VXAA_NE].a,\n        lumaSW = currN[VXAA_SW].a, lumaSE = currN[VXAA_SE].a;\n    lumaNE += 0.0025;\n    float lumaMin = min( current.a, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n    float lumaMax = max( current.a, max( max( lumaNW, lumaNE ), max( lumaSW, lumaSE ) ) );\n    \n    vec2 dir;\n    dir.x = ( lumaSW - lumaNE ) + ( lumaSE - lumaNW );\n    dir.y = ( lumaSW - lumaNE ) - ( lumaSE - lumaNW );\n    vec2 dirN = normalize( dir );\n    \n    vec4 n1 = texture( VXAA_TEXTURE_CURRENT, uv - dirN * strength / iResolution.xy );\n    vec4 p1 = texture( VXAA_TEXTURE_CURRENT, uv + dirN * strength / iResolution.xy );\n    return ( n1 + p1 ) * 0.5;\n}\n\nvec4 VXAAFilmic( vec2 uv, vec4 current, vec4 history, vec4 currN[4], vec4 histN[4] )\n{\n    // Temporal contrast weight.\n    float temporalContrastWeight = VXAATemporalContrast( current.a, history.a );\n\n    // Spatial contrast weight.\n    vec2 spatialLumaMinMaxC = vec2(\n        min( min( currN[0].a, currN[1].a ), min( currN[2].a, currN[3].a ) ),\n        max( max( currN[0].a, currN[1].a ), max( currN[2].a, currN[3].a ) )\n    );\n    vec2 spatialLumaMinMaxH = vec2(\n        min( min( histN[0].a, histN[1].a ), min( histN[2].a, histN[3].a ) ),\n        max( max( histN[0].a, histN[1].a ), max( histN[2].a, histN[3].a ) )\n    );\n    float spatialContrastWeightC = VXAASpatialContrast( spatialLumaMinMaxC );\n    float spatialContrastWeightH = VXAASpatialContrast( spatialLumaMinMaxH );\n    float spatialContrastWeight = abs( spatialContrastWeightC - spatialContrastWeightH );\n    \n    // Evaluate convergence time from weights.\n    float convergenceTime = mix( VXAA_TEMPORALEDGE_TIME_MIN, VXAA_TEMPORALEDGE_TIME_MAX, temporalContrastWeight );\n    convergenceTime = mix( convergenceTime, VXAA_SPATIAL_FLICKER_TIME, spatialContrastWeight );\n    float alpha = VXAATemporalFilterAlpha( iTimeDelta, convergenceTime );\n    \n    // Apply morpholigical AA filter and sharpen.\n    float strength = VXAAMorphStrengthShaper( spatialContrastWeightC * 4.0 ) * VXAA_MORPHOLOGICAL_STRENGTH;\n    current = VXAAMorphological( uv, current, currN, strength );\n    current = VXAASharpen( current, currN );\n    \n    // Clamp history to neighbourhood, and apply filmic blend.\n    history.rgb = VXAAClampHistory( history.rgb, currN );\n    current = mix( current, history, alpha );\n    return current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample scene and neighbourhood.\n    \n    vec4 current = clamp( vec4( texture( VXAA_TEXTURE_CURRENT, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    vec4 history = clamp( vec4( texture( VXAA_TEXTURE_PREV, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    current.a = VXAALuma( current.rgb ); history.a = VXAALuma( history.rgb );\n    \n    vec4 currN[4];\n    currN[VXAA_NW] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2( -1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_NE] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2(  1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_SW] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2( -1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_SE] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2(  1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_NW].a = VXAALuma( currN[VXAA_NW].rgb );\n    currN[VXAA_NE].a = VXAALuma( currN[VXAA_NE].rgb );\n    currN[VXAA_SW].a = VXAALuma( currN[VXAA_SW].rgb );\n    currN[VXAA_SE].a = VXAALuma( currN[VXAA_SE].rgb );\n    \n    vec4 histN[4];\n    histN[VXAA_NW] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2( -1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_NE] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2(  1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_SW] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2( -1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_SE] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2(  1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_NW].a = VXAALuma( histN[VXAA_NW].rgb );\n    histN[VXAA_NE].a = VXAALuma( histN[VXAA_NE].rgb );\n    histN[VXAA_SW].a = VXAALuma( histN[VXAA_SW].rgb );\n    histN[VXAA_SE].a = VXAALuma( histN[VXAA_SE].rgb );\n    \n    \n    // Filmic pass.    \n    fragColor = VXAAFilmic( uv, current, history, currN, histN );\n    //if( iMouse.x > fragCoord.x ) fragColor = current;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBDw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[573, 573, 630, 630, 709]], "test": "untested"}
{"id": "WsGBWm", "name": "hexa marketery (169ch)", "author": "FabriceNeyret2", "description": "using \"hexa world\" [url]https://shadertoy.com/view/tsKBDD[/url]", "tags": ["tiling", "2tweets", "hexagonal", "short", "golf"], "likes": 5, "viewed": 311, "published": 3, "date": "1607240994", "time_retrieved": "2024-07-30T20:31:58.840595", "image_code": "// using \"hexa world\" https://shadertoy.com/view/tsKBDD\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( 12.* U / iResolution.y + iTime ) * mat2(1,0,.5,.87);\n    vec3 V = vec3( U, U.y-U +2. ), J = ceil(V);                     \n    O += .5+ .5* sin( 62.8* V [ int(J+=J.y)%3 /2 + int(J.z)%3 /2 *2 ] ); \n}\n\n\n\n\n\n/* // --- 171 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( 12.* U / iResolution.y + iTime ) * mat2(1,0,.5,.87);\n    vec3 V = vec3( U, U.y-U +2. ), J = ceil(V);                     \n    O += .5+ .5* sin( 62.8* V [ int(J +=J.yzx)%3 /2 + int(J.y)%3 /2 *2 ] ); \n}\n\n\n\n\n\n/* // --- 178 chars. ugly variant to save one char. could be save the other branch ? \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( 12.* U / iResolution.y + iTime ) * mat2(1,0,.5,.87);\n    vec3 V = vec3( U, U.y-U +2. ), J = ceil(V);                     \n    O += .5+ .5* sin( 63.* mod( V, 2. ) [ int(J +=J.yzx)%3 /2 + int(J.y)%3 /2 *2 ] ); \n}\n\n\n\n\n\n/* // --- 179 chars (  -4 by xor )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( 12.* U / iResolution.y + iTime ) * mat2(1,0,.5,.87);      // parallelogram coords\n    vec3  V = vec3( U, U.y-U +12. );\n    ivec3 J = ivec3(V); J = (J+J.yzx) % 3 / 2;                      // J = face Id\n    O +=  .5+ .5* sin( 63.* mod( V, 2. ) [ J.x +2* J.y ] ); \n}\n\n\n\n\n\n/* // --- 183 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( 12.* U / iResolution.y + iTime ) * mat2(1,0,.5,.87);      // parallelogram coords\n    vec3  V = vec3( U, U.y-U +3. ), F = floor(V);\n    ivec3 J =  ivec3(F+F.yzx) % 3 / 2;                              // J = face Id\n    O +=  .5+ .5* sin( 63.* mod( V, 2. ) [ J.x +2* J.y ] ); \n}\n\n\n\n\n\n/* // --- 219 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( 12.* U / iResolution.y + iTime ) * mat2(1,0,.5,.87);      // parallelogram coords\n    vec3  V = vec3( U, U.y-U +3. ), F = floor(V);\n    ivec3 I = ivec3(F+F.yzx), J =  I % 3 / 2;                       // J = face Id\n    I.x += 4; I /= 3;                                               // I.xy = tileId\n    O +=  .5+ .5* sin(63.* mod( V + vec3( I.y, I.y+I.x, I ), 2. )   // tile coords\n                           [ J.x +2* J.y ] ); \n // O = sqrt(O);                                                    // to sRGB\n}\n\n\n\n\n\n/* // --- 229 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = ( 12.* U / iResolution.y + iTime ) * mat2(1,0,.5,.87);      // parallelogram coords\n    vec3  V = vec3( U, U.y-U.x +3. ), F = floor(V);\n    ivec3 I = ivec3(F+F.yzx), J =  I % 3;                           // J = face Id\n    I.x += 4; I /= 3;                                               // I.xy = tileId\n    O +=  .5+ .5* sin(63.* mod( V + vec3( I.y, I.y+I.x, I.x ) ,2. ) // tile coords\n                           [ J.x>1 ? 1 : J.y>1 ? 2 : 0 ] ); \n}\n\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 96, 96, 304]], "test": "untested"}
{"id": "WdGfWw", "name": "Raymarching_test_5", "author": "RisingMoon", "description": "Study Raymarching", "tags": ["raymarching"], "likes": 3, "viewed": 342, "published": 3, "date": "1607236489", "time_retrieved": "2024-07-30T20:31:59.790056", "image_code": "vec4 tex0(vec2 uv){\n    return texture(iChannel0,uv);\n}\n\nvec4 tex1(vec2 uv){\n    return texture(iChannel1,uv);\n}\n\nvec4 tex2(vec2 uv){\n    return texture(iChannel2,uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 fColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 color0 = tex0(uv);\n    fColor.rgb = mix(fColor.rgb, color0.rgb, color0.a * pow(REFLECT_COEFFICIENT, 0.0));\n    vec4 color1 = tex1(uv);\n    fColor.rgb = mix(fColor.rgb, color1.rgb, color1.a * pow(REFLECT_COEFFICIENT, 1.0));\n    vec4 color2 = tex2(uv);\n    fColor.rgb = mix(fColor.rgb, color2.rgb, color2.a * pow(REFLECT_COEFFICIENT, 2.0));\n\n    fragColor = fColor;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24815, "src": "https://soundcloud.com/woe-magnumopus/soft-music-to-relax-morning", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "//最远视距\nfloat FAR = 100.0;\n//最近视距\nfloat NEAR = 1.0;\n//最大检测次数\nconst int MAX_MARCHING_TIMES = 355;\n//阴影检测次数\nconst int SHADOW_MARCHING_TIMES = 30;\n//反射检测次数\nconst int REFLECT_MARCHING_TIMES = 128;\n//阴影最远距离\nfloat MAX_SHADOW_DISTANCE = 5.0;\n//最小float\nconst float MIN_FLOAT = 0.001;\n//反射系数\nfloat REFLECT_COEFFICIENT = 0.25;\n\n//物体间距\nfloat spacing = 0.0;\n//环境光颜色\nvec3 ambient = vec3(0.3, 0.3, 0.4);\n//视角位置\nvec3 eyePos = vec3(10.0, 5.0, 0.0);\n//摄像机速度\nfloat cameraSpeed = 5.0;\n\n//点光源\nstruct pointLight{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n\n//球型的SDF公式\nfloat sphereSdf(vec3 pos){\n    //圆形半径\n    float sphereRadius = 1.0;\n    return length(pos) - sphereRadius;\n}\n\n//圆柱的SDF公式\nfloat cylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n//心的SDF公式\nfloat heartSdf(vec3 pos){\n    pos -= vec3 (spacing, 0.0, -spacing);\n    vec3 bound = vec3(1.0, 1.0, 1.0);\n    vec3 q = abs(pos) - bound;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//旋转\nvec3 pR(vec3 p, float a) {\n\treturn cos(a)*p + sin(a)*vec3(p.y, -p.x,0.0);\n}\n\n//场景的SDF公式\nfloat sceneSdf(vec3 pos){\n    float result = cylinder(pR(pos,15.0),1.0,1.0);\n    return result;\n    \n    //float result = min(sphereSdf(pos), sdTorus(pos));\n    //result = min(result, sdOctahedron(pos));\n    //result = min(result, boxSdf(pos));\n    //result = min(result, box1Sdf(pos));\n    //result = min(result, sdCone(pos));\n}\n\n//眼睛到最近表面的最短距离\nfloat rayMarchingDistance(vec3 eye, vec3 direction, float start, float end){\n    // 检测的距离\n    float depth = start;\n    for (int i = 0;i < MAX_MARCHING_TIMES;i++){\n        //从眼睛出发的射线\n        float dist = sceneSdf(eye + direction * depth);\n        if (abs(dist) < MIN_FLOAT){\n            return depth;\n        }\n        depth += dist;\n        if (dist >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\n//射线检测\nfloat rayCast(vec3 eye, vec3 direction, float start, float end){\n    // 检测的距离\n    float depth = start;\n    for (int i = 0;i < REFLECT_MARCHING_TIMES;i++){\n        //从眼睛出发的射线\n        float dist = sceneSdf(eye + direction * depth);\n        if (abs(dist) < MIN_FLOAT){\n            return depth;\n        }\n        depth += dist;\n        if (dist >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\n//阴影检测\nfloat softShadow(vec3 startPos, vec3 lightDir, out float depth){\n    // 检测的距离\n    depth = NEAR;\n    for (int i = 0;i < SHADOW_MARCHING_TIMES;i++){\n        //从眼睛出发的射线\n        float dist = sceneSdf(startPos + lightDir * depth);\n        if (abs(dist) < MIN_FLOAT){\n            break;\n        }\n        depth += dist;\n        if (dist >= MAX_SHADOW_DISTANCE){\n            depth = MAX_SHADOW_DISTANCE;\n            break;\n        }\n    }\n    \n    float coefficient = step(MAX_SHADOW_DISTANCE, depth);\n    return coefficient;\n}\n\n//获取从像素出发的所有方向\nvec3 getDirectionByPixel(float fov, vec2 size, vec2 fragCoord){\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//法线\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n    sceneSdf(vec3(p.x + MIN_FLOAT, p.y, p.z)) - sceneSdf(vec3(p.x - MIN_FLOAT, p.y, p.z)),\n    sceneSdf(vec3(p.x, p.y + MIN_FLOAT, p.z)) - sceneSdf(vec3(p.x, p.y - MIN_FLOAT, p.z)),\n    sceneSdf(vec3(p.x, p.y, p.z  + MIN_FLOAT)) - sceneSdf(vec3(p.x, p.y, p.z - MIN_FLOAT))\n    ));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\n//视角矩阵\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = normalize(cross(s, f));\n    return mat3(s, u, -f);\n    //\tvec4(s, 0.0),\n    //\tvec4(u, 0.0),\n    //\tvec4(-f, 0.0),\n    //\tvec4(0.0, 0.0, 0.0, 1)\n    //\t);\n}\n\n//添加点光源\nvec3 addPointLight(pointLight light, vec3 modelColor, vec3 pos, vec3 normal, vec3 viewDir){\n    vec3 lightPos = light.pos;\n    vec3 lightColor = light.color;\n    float lightIntensity = light.intensity;\n\n    float specularCoefficient = 0.6;\n\n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 reflectDir = normalize(reflect(-lightDir, normal));\n\n    float NdotL = dot(normal, lightDir);\n    float NdotV = dot(normal, viewDir);\n    float VdotR = dot(viewDir, reflectDir);\n\n    vec3 diffuse = modelColor * lightColor * max(0.0, NdotL);\n    vec3 specular = specularCoefficient * lightColor * pow(max(0.0, VdotR), 10.0);\n    //计算阴影\n    float dist;\n    float shadow = softShadow(pos, lightDir, dist);\n\n\n    //光照颜色\n    vec3 color = diffuse + specular;\n    //光源强度\n    color *= max(0.0, 1.0 - distance(lightPos, pos)/lightIntensity);\n    //阴影\n    color *= shadow;\n\n    return color;\n}\n\n//添加方向光\nvec3 addDirectionalLight(vec3 lightDir, vec3 lightColor, float lightIntensity, vec3 modelColor,\nvec3 pos, vec3 normal, vec3 viewDir){\n    //反射系数\n    float specularCoefficient = 0.6;\n\n    vec3 reflectDir = normalize(reflect(-lightDir, normal));\n\n    float NdotL = dot(normal, lightDir);\n    float NdotV = dot(normal, viewDir);\n    float VdotR = dot(viewDir, reflectDir);\n\n    vec3 diffuse = modelColor * lightColor * max(0.0, NdotL);\n    vec3 specular = specularCoefficient * lightColor * pow(max(0.0, VdotR), 10.0);\n    //计算阴影\n    float dist;\n    float shadow = softShadow(pos, lightDir, dist);\n\n    //光照颜色\n    vec3 color = diffuse + specular;\n    //光源强度\n    color *= lightIntensity;\n    //阴影\n    color *= shadow;\n\n    return color;\n}\n\n//绘制点光源\nvec3 drawPointLight(pointLight light, vec3 eye, vec3 dir){\n    vec3 lightDir = normalize(light.pos - eye);\n    float LdotD = dot(lightDir, dir);\n    vec3 color = light.color * step(0.9997, LdotD);\n    return color;\n}\n\n//获取反射位置\nvoid reflectAll(inout vec3 viewDir, inout vec3 eye, inout vec3 normal, inout vec3 pos, inout float distance){\n    vec3 reflectDir = reflect(viewDir, normal);\n    float reflectDist = rayCast(pos, reflectDir, NEAR, 30.0);\n    //\trayCast(pos, reflectDir, distance);\n    vec3 reflectPos = pos + reflectDir * reflectDist;\n    eye = pos;\n    viewDir = reflectDir;\n    normal = estimateNormal(reflectPos);\n    pos = reflectPos;\n    distance = reflectDist;\n}\n\nvec4 screenBuffer(vec3 iResolution,float iTime,vec2 fragCoord, float reflectTimes){\n    //还原可视坐标\n    vec3 dir = getDirectionByPixel(90.0, iResolution.xy, fragCoord);\n    vec3 eye = eyePos;\n    mat3 viewMatrix = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    dir = viewMatrix * dir;\n    float dist = rayMarchingDistance(eye, dir, NEAR, FAR);\n    vec3 pos = eye + dir * dist;\n    vec3 normal = estimateNormal(pos);\n    vec3 viewDir = dir;\n\n    for (float i = 0.0;i < 2.0;i+=1.0){\n        if (i > reflectTimes-MIN_FLOAT){\n            break;\n        }\n        float distance = 30.0/i;\n        reflectAll(viewDir, eye, normal, pos, distance);\n        dist = distance;\n        if (dist > 30.0 - MIN_FLOAT){\n            return vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    }\n\n\n    vec3 modelColor = vec3(1.0, 1.0, 1.0);\n    vec3 bgColor = vec3(0.0, 0.0, 0.1);\n\n    //点光源\n    pointLight pointLights[3];\n    pointLights[0] = pointLight(vec3 (sin(iTime/2.0 + radians(120.0))*7.0, 3.0, cos(iTime/2.0 + radians(120.0))*7.0), vec3(1.0, 0.0, 0.0), 20.0);\n    pointLights[1] = pointLight(vec3 (sin(iTime/2.0 + radians(240.0)) * 7.0, 3.0, cos(iTime/2.0 + radians(240.0)) * 7.0), vec3(0.0, 0.0, 1.0), 20.0);\n    pointLights[2] = pointLight(vec3 (sin(iTime/2.0) * 7.0, 3.0, cos(iTime/2.0) * 7.0), vec3(0.0, 1.0, 0.0), 20.0);\n\n    vec3 lightColor0 = addPointLight(pointLights[0], modelColor, pos, normal, viewDir);\n    vec3 lightColor1 = addPointLight(pointLights[1], modelColor, pos, normal, viewDir);\n    vec3 lightColor2 = addPointLight(pointLights[2], modelColor, pos, normal, viewDir);\n\n    //方向光\n    //    vec3 directionalLight0 = addDirectionalLight(normalize(vec3(1.0, 1.0, 1.0)), vec3(1.0, 1.0, 1.0), 0.1, modelColor, pos, normal, viewDir);\n    //\tvec3 directionalLight1 = addDirectionalLight(normalize(vec3(-1.0, 1.0, -1.0)), vec3(1.0, 1.0, 1.0), 0.2, modelColor, pos, normal, viewDir);\n\n\n\n    vec3 color = ambient;\n    color += lightColor0;\n    color += lightColor1;\n    color += lightColor2;\n    //    color += directionalLight0;\n    //\tcolor += directionalLight1;\n\n    if (dist > FAR - MIN_FLOAT){\n        color = bgColor;\n    }\n\n    //绘制虚拟点光源\n    vec3 drawLight1 = drawPointLight(pointLights[0], eye, viewDir);\n    vec3 drawLight2 = drawPointLight(pointLights[1], eye, viewDir);\n    vec3 drawLight3 = drawPointLight(pointLights[2], eye, viewDir);\n    color.xyz += drawLight1;\n    color.xyz += drawLight2;\n    color.xyz += drawLight3;\n\n    return vec4(color, 1.0);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n    eyePos = vec3(cos(radians(mouse.x * 180.0 + iTime * cameraSpeed)) * 10.0, 5.0, sin(radians(mouse.x * 180.0 + iTime * cameraSpeed)) *10.0);\n    eyePos += eyePos * mouse.y * 0.7;\n    \n    vec4 color = screenBuffer(iResolution,iTime,fragCoord, 0.0);\n    fragColor = color;\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n    eyePos = vec3(cos(radians(mouse.x * 180.0 + iTime * cameraSpeed)) * 10.0, 5.0, sin(radians(mouse.x * 180.0 + iTime * cameraSpeed)) *10.0);\n    eyePos += eyePos * mouse.y * 0.7;\n    \n    vec4 color = screenBuffer(iResolution,iTime,fragCoord, 1.0);\n    fragColor = color;\n}", "buffer_b_inputs": [], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n    eyePos = vec3(cos(radians(mouse.x * 180.0 + iTime * cameraSpeed)) * 10.0, 5.0, sin(radians(mouse.x * 180.0 + iTime * cameraSpeed)) *10.0);\n    eyePos += eyePos * mouse.y * 0.7;\n    \n    vec4 color = screenBuffer(iResolution,iTime,fragCoord, 2.0);\n    fragColor = color;\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 55], [57, 57, 76, 76, 112], [114, 114, 133, 133, 169], [171, 171, 226, 226, 690]], "test": "untested"}
{"id": "WdGfRh", "name": "Round Brilliant Cut", "author": "Catzpaw", "description": "diamond!", "tags": ["raymarching"], "likes": 25, "viewed": 1163, "published": 3, "date": "1607221879", "time_retrieved": "2024-07-30T20:32:00.545037", "image_code": "//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//Image:post effect\n\n#define ITER   36.\n#define RADIUS 0.05\n\nvec4 tx(vec2 uv){return texture(iChannel0,uv);}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 m=vec2(1,iResolution.x/iResolution.y);\n    vec4 c=tx(uv);\n    float a=sin(iTime*.1)*6.283,v=0.,b=1./ITER;\n    for(int j=ZERO;j<6;j++){\n        float r=RADIUS/ITER;\n        vec2 d=vec2(cos(a),sin(a))*m;\n        for(int i=ZERO;i<int(ITER);i++){\n            v+=tx(uv+d*r*RADIUS).w*(1.-r);\n            r+=b;\n        }\n        a+=1.047;\n    }\n    v*=.01;\n    c+=v;\n    c.w=1.;\n\tfragColor=c;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//BufferA:scene\n\n//refraction index\n#define RI1 2.40\n#define RI2 2.44\n\n//settings:trace\n#define ITER   256\n#define EPS   1e-4\n#define NEAR   1.0\n#define FAR   10.0\n\n//settings:trace2\n#define ITER2  128\n#define EPS2  1e-4\n#define NEAR2 0.02\n\n//CONSTANTS\nconst float pi=acos(-1.);\nconst float qp=pi*.25,op=qp*.5,hp=op*.5;\nconst mat2 rot4=mat2(sin(qp),cos(qp),-cos(qp),sin(qp));\nconst mat2 rot3=mat2(sin(qp+op),cos(qp+op),-cos(qp+op),sin(qp+op));\nconst mat2 rot2=mat2(sin(op),cos(op),-cos(op),sin(op));\nconst mat2 rot1=mat2(sin(hp),cos(hp),-cos(hp),sin(hp));\n\n//SDF\nfloat sdTable(vec3 p){\n\tvec2 d=abs(vec2(length(p.xz),(p.y+0.159)*1.650))-vec2(1,1);\n\treturn min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nfloat sdCut(vec3 p,float a,float h){\n    p.y*=a;\n    p.y-=(abs(p.x)+abs(p.z))*h;p=abs(p);\n\treturn (p.x+p.y+p.z-1.)*.5;\n}\n\n//SCENE\nfloat map(vec3 p){\n    p.yz*=rot(.3);\n    p.xz*=rot(-iTime*.8);\n    //table & girdle\n    float d=sdTable(p);\n    //star facet\n    vec3 q=p*0.3000;q.y+=0.0808;q.xz*=rot2;\n\tq.xz=abs(q.xz);q.xz*=rot4;q.xz=abs(q.xz);\n    q.xz*=rot2;d=max(d,sdCut(q,3.700,0.0000));\n    //main facet\n    q=p*0.691;\n    q.xz=abs(q.xz);q.xz*=rot4;q.xz=abs(q.xz);\n    q.xz*=rot2;d=max(d,sdCut(q,1.868,0.1744));\n    //girdle facet\n    q*=1.022;q.y-=0.034;\n    q.xz*=rot1;d=max(d,sdCut(q,1.650,0.1000));\n    q.xz*=rot3;d=max(d,sdCut(q,1.650,0.1000));\n\treturn d;\n}\n\n//NORMAL\nvec3 normal(vec3 p){\n    const vec2 e=vec2(-1,1);\n    return normalize(e.xxx*map(p+e.xxx*EPS)+e.xyy*map(p+e.xyy*EPS)+\n                     e.yxy*map(p+e.yxy*EPS)+e.yyx*map(p+e.yyx*EPS));\n}\n\n//RAYMARCHING\nfloat trace(vec3 ro,vec3 rd,out vec3 p,out vec3 n){\n    float t=NEAR,d;\n    for(int i=ZERO;i<ITER;i++){\n        p=ro+rd*t;\n        d=map(p);\n        if(abs(d)<EPS||t>FAR)break;\n        t+=step(d,1.)*d*.5+d*.5;\n    }\n    n=normal(p);\n    return min(t,FAR);\n}\n\n//RAYMARCHING UNDER SURFACE\nfloat trace2(vec3 ro,vec3 rd,out vec3 p,out vec3 n){\n    float t=NEAR2,d;\n    for(int i=ZERO;i<ITER2;i++){\n        p=ro+rd*t;\n        d=-map(p);\n        if(abs(d)<EPS2||d<EPS2)break;\n        t+=d;\n    }\n    n=-normal(p);\n    return t;\n}\n\n//CUBEMAP\nvec3 cubemap(vec3 d){    \n\treturn texture(iChannel0,d).rgb;\n}\n\n//FRESNEL EQUATION\nfloat schlickFresnel(float ri,float co) {\n    float r=(1.-ri)/(1.+ri);\n    r=r*r;\n    return r+(1.-r)*pow(1.-co,5.);\n}\n\n//GET LIGHT PATH\nvec3 lightPath(vec3 p,vec3 rd,float ri){\n    vec3 n;\n    vec3 r0=-rd;\n    //2nd reflection\n    trace2(p,rd,p,n);\n    rd=reflect(rd,n);\n    vec3 r1=refract(rd,n,ri);\n    r1=length(r1)<EPS?r0:r1;\n    //3rd reflection\n    trace2(p,rd,p,n);\n    rd=reflect(rd,n);\n    vec3 r2=refract(rd,n,ri);\n    r2=length(r2)<EPS?r1:r2;\n    //final refraction\n    trace2(p,rd,p,n);\n    vec3 r3=refract(rd,n,ri);\n    return length(r3)<EPS?r2:r3;\n}\n\n//MATERIAL\nvec3 material(vec3 p,vec3 rd,vec3 n){\n\n    //1st reflection\n    vec3 l0=reflect(rd,n);\n\n    //cosine for fresnel\n    float co=max(0.,dot(-rd,n));\n    \n    //low frequency light path\n    float f1=schlickFresnel(RI1,co);\n    vec3 l1=lightPath(p,refract(rd,n,1./RI1),RI1);\n    \n    //high frequency light path\n    float f2=schlickFresnel(RI2,co);\n    vec3 l2=lightPath(p,refract(rd,n,1./RI2),RI2);\n\n    //dispersion\n    float a=0.;\n    vec3 dc=vec3(0);\n    vec3 r=cubemap(l0);\n    for(int i=ZERO;i<10;i++){\n        vec3 l=normalize(mix(l1,l2,a));\n        float f=mix(f1,f2,a);\n        dc+=cubemap(l)*hsv(a+.9,1.,1.)*(1.-f)+r*f;\n        a+=.1;\n    }\n    dc*=.19;\n    \n    return dc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //CAMERA SETUP\n    vec2 m=iMouse.xy/iResolution.xy;\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p,n,c=vec3(0),\n         ro=vec3(0,0,-3.5),\n         rd=normalize(vec3(uv,1.5));\n    mat2 r=rot(sin(iTime*.3+4.)*.5-.8+m.y*6.3);\n    ro.yz*=r;\n    rd.yz*=r;\n    r=rot(iTime*.21+.7+m.x*6.3);\n    ro.xz*=r;\n    rd.xz*=r;\n\n    //GET SURFACE\n    float t=trace(ro,rd,p,n);\n\n    //SHADING\n    float w=0.;\n    if(t>9.){\n        //background\n        c=cubemap(rd);\n    }else{\n        //diamond\n\t    c=material(p,rd,n);\n        w=smoothstep(1.60,1.61,length(c));\n    }\n    fragColor=vec4(c,w);\n}\n\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//--- Round Brilliant Cut\n// by Catzpaw 2020\n\n//Common:snippets\n\n#define ZERO min(0,iFrame)\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 124, 124, 154], [156, 156, 209, 209, 644]], "test": "untested"}
{"id": "3dyBDw", "name": "cual hexagono eliges", "author": "jorge2017a1", "description": "cual hexagono eliges", "tags": ["cualhexagonoeliges"], "likes": 5, "viewed": 264, "published": 3, "date": "1607221406", "time_retrieved": "2024-07-30T20:32:01.300019", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n//operacion de Union\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///----------------------\n\n\nfloat tau = atan(1.0) * 8.0;\n\nmat2 genRotMat(float val){\n\treturn mat2(cos(val),-sin(val),sin(val),cos(val));\n}\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\n\n//polynomial smooth minimum\nfloat opSU( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//------------------\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat cilindrosconboxGrandeConPuertas(vec3 p, float numItem)\n{\n    vec3 pp;\n    p= rotate_x(p , radians(90.0));\n    vec3 rep2 = opAngRep(p, tau / numItem);\n    \n    float sdb1= sdBox(rep2-vec3(25.0,0.0,0.0), vec3(10.0,10.0,10.0) );\n    float sdba=  sdHexPrism( rep2.zyx, vec2(6,40.0) );\n    \n    sdb1=differenceSDF(sdb1, sdba);\n    float res =  sdb1;\n  \treturn  res;\n}\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\tvec3 res;\n    vec3 pp=p;\n    res = vec3(9999.0, -1.0,-1.0);\n    //p= rotate_y(p-vec3(0.0,0.0,0.0), radians(45.0));\n    p= rotate_y(p-vec3(0.0,0.0,0.0), radians(iTime*15.0));\n\t\n    p.y=p.y-8.0;\n\n    float c1b= cilindrosconboxGrandeConPuertas( p, 6.);\n    //float c1b= cilindrosconboxGrandeConPuertas( p, 40.);     //por  0xBAMA, 2021-05-30\n    \n    res =opU3(res, vec3(c1b,1.0,MATERIAL_NO)); \n    \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n\n\nvec3 LightShadingV2(vec3 normal,vec3 p, vec3 ro,vec3 rd, vec3 plight_pos,vec3 color)\n{   \n    vec3 final = vec3( 0.0 );\n    //const float shininess = 64.0;\n    float shininess = 64.;\n    vec3 lig = normalize(plight_pos);\n\tvec3 l = normalize( p-plight_pos);\n    vec3 v = normalize( p-ro);\n    vec3 h = normalize(v + l);\n    \n    vec3 r = reflect(-l, normal);\n    vec3 ref = reflect(lig, normal);\n    \n    vec3 lightDir = normalize(plight_pos);\n    vec3 viewDir = normalize(-rd);  //normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir); //normalize(viewDir + lightDir);\n  \n    \n    float diff = dot(normal, l);\n    //vec3 v = normalize( p - ro );\n    vec3 vl = normalize( plight_pos - p );\n    vec3 ref_v = reflect( v, normal );\n    float diffuse  = max( 0.0, dot( vl, normal ) );\n    float specular = max( 0.0, dot( vl, ref_v ) );\n\t\n    \n    float fre = pow(clamp(1.0 + dot(normal, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n\t\tspecular = pow( specular, shininess );\n\t\tfinal += color * ( diffuse + specular);\n\n    return  final;\n    \n    \n}   \n\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n//---------actualizacion por Shane---28-may-2020    ...gracias\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tp = ro + rd*dO;\n        dS = GetDist(p);\n        \n        if(dO>MAX_DIST || abs(dS.x)<MIN_DIST) break;\n        dO += dS.x;\n        marchCount++;\n         \n    }\n    \n    mObj.dist = dO;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    return dO;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n\t result = LightShadingV2(nor,p, ro, rd, plight_pos, colobj)*intensity;\n    \n    if (mObj.blnShadow==true)\n    {\n    \tfloat fhadow=GetShadow(p,plight_pos);\n    \treturn result*fhadow;\n        \n     }\n    else\n    {  return result; }\n}\n///-------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    return colobj;\n}\n\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, 0.0 );  light_color1 = vec3( 1.0 );\n \tlight_pos2= vec3( -5.0, 6.0, -5.0 ); light_color2 = vec3( 1.0, 1.0, 1.0 );\n \n    vec3 ro=vec3(0.0,7.0,-10.0);\n    vec3 rd=normalize(vec3(uv,1.0));\n  \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    \n    \n    vec3 col = vec3(0);\n    TObj Obj;\n    mObj.rd=rd;\n    mObj.ro=ro;\n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    vec3 p = (ro + rd * d ); \n    \n    mObj.p=p;\n    mObj.dist =d;\n    vec3 nor=mObj.normal;\n\n    vec3 colobj;\n    colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n    \n    \n\tfloat dif1=1.0;\n   \tvec3 result;\n    result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n    result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n    result/=1.25;\n    col= result*dif1;\n    \n     \n\n  \t//sugerencia por dean_the_coder,\n    //col *= 1.0 - pow(d / 100.0, 1.5);\n    col *= 1.0 - pow(d /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(1.0/2.2));  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n    float marchCount;\n    bool blnShadow; \n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n///--------------------------------------------FIN\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 402, 434, 434, 518], [520, 564, 611, 611, 638], [640, 640, 683, 683, 710], [712, 712, 760, 760, 788], [789, 873, 912, 912, 956], [957, 957, 996, 996, 1040], [1041, 1041, 1073, 1073, 1098], [1099, 1164, 1198, 1198, 1296], [1297, 1297, 1331, 1331, 1423], [1424, 1424, 1458, 1458, 1550], [1551, 1591, 1625, 1625, 1722], [1781, 1781, 1807, 1807, 1861], [1863, 1863, 1897, 1897, 2070], [2073, 2101, 2142, 2142, 2235], [2259, 2259, 2295, 2295, 2568], [2571, 2571, 2633, 2633, 2939], [2942, 2982, 3007, 3007, 3522], [3526, 3526, 3612, 3612, 4606], [4612, 4663, 4687, 4687, 4875], [4876, 4939, 4972, 4972, 5433], [5435, 5489, 5525, 5525, 5759], [5761, 5795, 5875, 5875, 6152], [6195, 6195, 6288, 6288, 6388], [6393, 6442, 6499, 6499, 7677]], "test": "untested"}
{"id": "WdtfRj", "name": "waving circle lines", "author": "lousisx", "description": "Made for a phone's background.", "tags": ["2d", "lines", "circle"], "likes": 0, "viewed": 266, "published": 3, "date": "1607214036", "time_retrieved": "2024-07-30T20:32:02.056995", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv *2.-1.;\n    uv.x = uv.x * (iResolution.x/iResolution.y);\n    \n    float r = PI/ 10.;\n    float a = atan(uv.x,uv.y)+(PI);\n    \n    float f =  2.*cos(floor(cos(iTime)+a/r)*r-a)*length(uv);\n    \n    vec3 col = vec3(1.0-smoothstep(.4,.41,f)) - vec3(1.0-smoothstep(.39,.40,f));\n\n    fragColor = vec4(1.,1.,1.,1.) - vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 112, 112, 496]], "test": "untested"}
{"id": "tstfzf", "name": "black curved lines", "author": "lousisx", "description": "3 thin sinusoidal lines made for my phone's wallpaper ", "tags": ["2d", "wave", "lines", "wallpaper"], "likes": 7, "viewed": 429, "published": 3, "date": "1607213783", "time_retrieved": "2024-07-30T20:32:02.824942", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord / iResolution.xy;\n\n\tfloat l1 = 1.- smoothstep(uv.x+sin(uv.y*5.+iTime+2./2.0)/20.-0.31,0.5,0.501);\n\tfloat l2 = 1.- smoothstep(uv.x+sin(uv.y*5.+iTime+3./2.5)/20.-0.32,0.5,0.501);\n\tfloat l3 = 1.- smoothstep(uv.x+sin(uv.y*5.+iTime   /3. )/20.-0.32,0.5,0.501);\n\n\n  float l = 1.- (l1 + l2 + l3);\n\n\tfragColor = vec4(l,l,l, 1.0);//1.2;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstfzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 409]], "test": "untested"}
{"id": "3dGfWw", "name": "Girih pattern taken from door", "author": "lousisx", "description": "*work in progress*\nhttps://patterninislamicart.com/archive/museums/2/louvre/lou080\n", "tags": ["2d", "pattern", "door", "girih"], "likes": 5, "viewed": 392, "published": 3, "date": "1607213262", "time_retrieved": "2024-07-30T20:32:03.693619", "image_code": "\nfloat sdLine (in vec2 p, in vec2 a, in vec2 b){//line sdf\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn length (pa-ba*h);\n}\nvec2 pcart (in float r, in float a){          //polar to cartesian \n\treturn vec2(r*cos(a),r*sin(a));\n}\nvec2 cpol (in float x, in float y){           //cartesian to polar\n\treturn vec2(sqrt(pow(x,2.)+pow(y,2.)),atan(y/x));\n}\n//--------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = ( 2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tuv *= 1.; //zoom\n    \n    //create and offset tiles\n\tfloat hh = 0.895;\n\tuv.x += step(1.,mod(uv.y,2.)) *(hh/2.);\n\tuv.x  = mod(uv.x,hh);\n\tuv.y  = mod(uv.y,1.)-0.05;\n\n\tfloat ofs = 0.12;                //center offset\n\tfloat len = hh * 0.516 - ofs;    //length size\n    float div = 12.;                 //division\n    float lnw = 0.0051;              //line weight\n\tfloat ang;\n\tfloat sec;\n\tvec3  lin;\n    vec3  col;\n\tfloat mi = 1.; \n    \n    for(float m = 0.; m < 2.; m++){        //mirror x coordinate\n        if(m == 1.){uv.x = hh - uv.x;}\n        for(float i = 0.; i < div; i++){   //radial array\n            sec = 6.28318/div;\n            ang = sec*i+sec/2.;\n    \n            vec2 a = pcart(ofs,ang); a += vec2(hh/2.,0.5);\n            \n            vec2 b = a + pcart(len*1.000,ang + sec*1.50);\n            vec2 c = b + pcart(len*0.505,ang + sec*4.05);\n            vec2 d = c + pcart(len*0.500,ang + sec*1.10);\n            \n            //deform d\n            if (i==7.) {d = c + pcart(len/2.,ang + sec*2.15);}\n            if (i==6.) {d = c + pcart(len/2.,ang + sec*0.86);}\n            \n            vec2 e = d + pcart(len*0.500,ang + sec*2.90);\n            vec2 f = a + pcart(len+0.050,ang);\n            vec2 g = f + pcart(len*0.518,ang + sec*2.14);\n            \n            //deform g\n            if (i==1.||i==7.0){g = f + pcart(len*0.51,ang + sec*2.1);}\n            if (i==2.||i==8.0){g = f + pcart(len*0.50,ang + sec*1.1);}\n            \n            // minimum sdf\n            mi = min(mi, sdLine(uv,a,b));\n            mi = min(mi, sdLine(uv,b,c));\n            mi = min(mi, sdLine(uv,c,d));\n            mi = min(mi, sdLine(uv,d,e));\n            mi = min(mi, sdLine(uv,f,g));\n        }\n    }\n    \n    col  = vec3(1.0) ;\n    col *= 0.3 + 0.4*smoothstep(mi,0.02,0.00);\n    col *= 1.0 + 0.2*smoothstep(mi,0.03,0.00);\n    col  = mix(col,vec3(1.0),1.0-smoothstep(0.0,lnw,abs(mi)));\n    \n\tfragColor = vec4(col, 1.0);\n}\n    ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 48, 58, 159], [160, 160, 196, 227, 262], [263, 263, 298, 329, 382], [449, 449, 505, 505, 2488]], "test": "untested"}
{"id": "WdyBWw", "name": "Simpler Webcam Edge Detection", "author": "oneshade", "description": "I've improved (and simplified) the edge detection \"algorithm\" (I don't think it's technically an algorithm anymore ;) ) from my \"Simple Webcam Edge Detection\" shader.", "tags": ["edgedetection", "webcam", "improvement"], "likes": 2, "viewed": 263, "published": 3, "date": "1607210812", "time_retrieved": "2024-07-30T20:32:04.537363", "image_code": "const float brightness = 1.0; // Set to 5.0 for a creepier look.\n\nvec3 webcam(in vec2 xy) {\n    return texture(iChannel0, xy / iResolution.xy).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 gx = (webcam(fragCoord + vec2(1.0, 0.0)) - webcam(fragCoord - vec2(1.0, 0.0))) * 0.5;\n    vec3 gy = (webcam(fragCoord + vec2(0.0, 1.0)) - webcam(fragCoord - vec2(0.0, 1.0))) * 0.5;\n    fragColor = vec4(dot(abs(gx) + abs(gy), vec3(1.0)) * brightness); // The dot product is just used as a shorthand way to sum up the elements of a vector.\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyBWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 91, 91, 149], [151, 151, 206, 206, 555]], "test": "untested"}
{"id": "tsKBDD", "name": "hexa world", "author": "FabriceNeyret2", "description": "various features in hexagonal tiling: tile id, face id, local coordinates, rand value per tile, etc.", "tags": ["tiling", "hexagonal", "tuto", "short"], "likes": 11, "viewed": 430, "published": 3, "date": "1607205206", "time_retrieved": "2024-07-30T20:32:05.290350", "image_code": "vec3 hash( uvec3 x ) // integer hash from https://www.shadertoy.com/view/XlXcW4\n{\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;    \n    return vec3(x) / float(0xffffffffU);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 12.* u / R.y + iTime;\n\n    U *= mat2(1,0,.5,.87);                     // parallelogram frame\n    vec3  V = vec3( U, U.y-U.x +3. );          // 3 axial coords\n    ivec3 I = ivec3(floor(V)), J;\n          I += I.yzx;\n          J = ( I % 3 ) / 2;                   // J.xy = hexagon face\n    int   c = J.x + 2* J.y;                    // int face id\n /*       J = I % 3;                           // variant:\n    int   c = J.x==2 ? 1 : J.y==2 ? 2 : 0;     //   front faces (as above)\n // int   c = J.x==1 ? 1 : J.y==0 ? 2 : 0; */  //   back faces\n          I = ( I + ivec3(1,0,0) ) / 3;        // I.xy = hexagon id\n    vec3  r = hash(uvec3(I.xy,0));             // rand values per hexagon\n//  U = fract(U);                              // local coords\n    V = fract( V/2. + .5*vec3( I.y, 1+I.y-I.x, 1+I.x ) );\n                                               // --- various hexagons display mode\n    O = r.x < .33 ? vec4(V,0)                  // local 3coords\n      : r.x < .66 ? vec4(c==1,c==2,c==0,0)     // face ids\n      : r.x < .71 ? fract(vec4(I.xy,0,0)/10.)  // tile id\n      :             vec4(r.z);                 // random value\n    if (r.y > .5) O.xyz *= sin(62.8*V);        // show axis\n    \n    U = (V.xy*2.-1.) * mat2( .87,0, -.5,1)/.87;// back to screenspace\n    if (r.z > .7) O *= smoothstep( .0, .05, abs(length(U)-1.) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 81, 81, 252], [254, 254, 292, 292, 1671]], "test": "untested"}
{"id": "tsVfWD", "name": "THS Shader Livecoding", "author": "spolsh", "description": "Effect of ~30 min Shader Livecoding session at https://thehacksummit.com, Thanks for stopping by and watching pixels bouncing to music", "tags": ["3d", "raymarching", "music", "reflections", "livecoding", "klos"], "likes": 14, "viewed": 535, "published": 3, "date": "1607198166", "time_retrieved": "2024-07-30T20:32:06.062286", "image_code": "// #version 410 core\n\n#define f float \n#define v2 vec2\n#define v3 vec3\n\n#define F gl_FragCoord\n// #define R v2Resolution\n// #define T fGlobalTime\n#define R iResolution\n#define T iTime\n#define N normalize\n\n// #define BI(v) (texture(texFFTIntegrated, v).x)\n// #define BS(v) (texture(texFFTSmoothed, v).x)\n// #define B(v)  (texture(texFFT, v).x)\n\n// fake beat accumulation, next time I will save it in buffer\n#define BI(v) (0.05*T+0.02*texture(iChannel0, v2(v, 0.5)).x)\n#define BS(v) (0.02*texture(iChannel0, v2(v, 0.5)).x)\n#define B(v)  (0.01*texture(iChannel0, v2(v, 0.5)).x)\n\nf gB = 10e8;\n\nv3 colA = v3(0.2, 0.5, 1.4);\n\nmat2 rot(f a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }\n\nf box(v3 p, v3 b) {\n  v3 q = abs(p) -b;\n  return length( max(q, v3(0.))) + min( max(max(q.x, q.y), q.z), 0.);\n}\n\nf plas( vec2 v, float time )\n{\n\tfloat c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  vec4 p = vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n\treturn dot(p.xyz, p.xyz);\n}\n\nf map(v3 p) {\n  f s = min( p.y +1.5 + plas(0.1*p.xz - 0.1*T, 0.1*BI(0.0)), -p.y + 6.);\n  \n  v3 p0 = p; \n  p0.z -= 10.0*T;  \n  p0.x  = abs(p0.x);  \n  p0.xy *= rot( -0.7);  \n  p0.x -= 8.;  \n  p0.z = mod(p0.z + 2.0, 4.0) - 2.0;\n  s = min(s, box(p0, v3(1.0, 100.0, 1.0)));\n  \n  p -= v3(0, 2., 12. -100.0*BS(0.0));\n  \n  for (f i = 0.; i < 4.; ++i) {\n    p -= v3(0.2, 0.6 + 0.5*abs(sin(BI(0.0))), 0.6);\n    p.xy *= rot(  10.0*BI(0.0));\n    p.yz *= rot( -20.0*BI(0.0));\n    p = abs(p);\n    \n    f sl = box(p, v3(0.01, 100.0, 0.01));\n    s = min(s, sl);\n    gB = min(gB, sl);\n  }\n  \n  s = min(s , \n    mix(\n      length(p) -0.3 -200.0*B(0.0),\n      box(p, v3(0.3)),\n      abs(sin(T))\n)  );\n  \n  return s;\n}\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{    \t\n  v3 c = v3(0);\n  \n  vec2 q = (2.0*F.xy - R.xy) / R.y;\n  out_color = vec4(0.);\n  if (abs(q.y) > 0.75) return;\n  \n  v3 ro = v3( 2.0*sin(20.0*BI(0.0)), 2. + 20.0*B(0.0), 0);\n  v3 rd = N(v3(q, 2.));\n  rd.xy *= rot( 0.4*sin(20.0*BI(0.0)) );\n  \n  // c = v3(q, 0.);\n  c = v3(0.);\n  f t = 0.2;\n  f tt = 10e8;\n  for (f bi = 0.; bi < 4.; ++bi) {\n    for (f i = 0.; i < 64.; ++i) {\n      f d = map(ro + rd * t);    \n      if (d < 0.0001 || t > 40.) break;\n      t += d;\n    }  \n     tt = bi == 0. ? t : tt;\n      if (t > 0.1 && t < 40.0) {\n          v3 p = ro + rd * t;\n          f str0 = smoothstep(.5, .51, fract(2.33*p.x));\n          f str1 = smoothstep(.5, .51, fract(0.1*p.x));\n          \n          v2 e = 0.001 * v2(-1., 1);\n          v3 n = N(\n                e.xxx * map(p + e.xxx)\n              + e.yxx * map(p + e.yxx)\n              + e.xyx * map(p + e.xyx)\n              + e.xxy * map(p + e.xxy)\n          );\n          // c = n;\n          f fre = pow(dot(rd, n) + 1., 6.);\n          c += colA.zyx * (0.5+0.5*fre) * (str0+str1);\n        \n          rd = N(reflect(rd, n) + 0.01 * fract(sin(100.0*p) * 43758.5453));\n          ro = p;\n      }  \n  } \n  // c = v3(1.0 - (t / 32.));\n  // c = mix(c, N(mix(colA, colA.zyx, sin(20.0*(t / 32.)))), sin(T));\n  \n  c = mix(c, 0.01*colA, 1.0 - exp(-0.01 *tt*tt));\n  \n  f sb = 1. + 50.0*BS(0.0) + 20.0*B(0.0);\n  c += sb * colA * exp(gB * -20.0);\n  c += sb * colA * exp(gB * -10.0);\n  c += sb * colA * exp(gB * -2.0);\n  c += sb * colA * exp(gB * -1.0);\n  c += 20.0*B(0.0);\n  \n  c = c / (1. + c);\n  c = pow(c, v3(0.4545));\n  out_color = c.xyzz;\n}", "image_inputs": [{"id": 24810, "src": "https://soundcloud.com/inzynier/01-rec-2020-04-23", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[620, 620, 635, 635, 683], [685, 685, 704, 704, 796], [798, 798, 828, 828, 1021], [1023, 1023, 1036, 1036, 1721], [1723, 1723, 1780, 1780, 3365]], "test": "untested"}
{"id": "wsKBWD", "name": "Random smooth kaleidoscope", "author": "mrange", "description": "License CC0: Random little accidents\nRandom coding turned out rather nice\n I suspect 60% of the code is unnecessary :)", "tags": ["2d", "kaleidoscope"], "likes": 9, "viewed": 434, "published": 3, "date": "1607196274", "time_retrieved": "2024-07-30T20:32:06.819263", "image_code": "// License CC0: Random little accidents\n//  Random coding turned out rather nice\n//  I suspect 60% of the code is unnecessary :)\n    \n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ORT(p)          vec2((p).y, -(p).x)\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n#define ROT(x)      mat2(cos(x), -sin(x), sin(x), cos(x))\n\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst float is3     = 1.0/sqrt(3.0);\nconst vec2 cdir     = normalize(vec2(1.0, is3));\nconst vec2 flipy    = vec2(1.0, -1.0);\n\nconst vec2 coords[6] = vec2[6](\n  is3*cdir*1.0/3.0,\n  is3*cdir*2.0/3.0,\n  vec2(0.5, is3/6.0),\n  vec2(0.5, -is3/6.0),\n  is3*cdir*2.0/3.0*flipy,\n  is3*cdir*1.0/3.0*flipy\n  );\n\nconst vec2 dcoords[6] = vec2[6](\n  ORT(cdir),\n  ORT(cdir),\n  vec2(-1.0, 0.0),\n  vec2(-1.0, 0.0),\n  ORT(-cdir*flipy),\n  ORT(-cdir*flipy)\n  );\n\nconst int corners[] = int[](\n  0, 1, 2, 3, 4, 5, \n  0, 1, 2, 4, 3, 5, \n  0, 1, 2, 5, 3, 4, \n  0, 2, 1, 3, 4, 5, \n  0, 2, 1, 4, 3, 5, \n  0, 2, 1, 5, 3, 4, \n  0, 3, 1, 2, 4, 5, \n  0, 3, 1, 4, 2, 5, \n  0, 3, 1, 5, 2, 4, \n  0, 4, 1, 2, 3, 5, \n  0, 4, 1, 3, 2, 5, \n  0, 4, 1, 5, 2, 3, \n  0, 5, 1, 2, 3, 4, \n  0, 5, 1, 3, 2, 4, \n  0, 5, 1, 4, 2, 3\n  );\nconst int noCorners = corners.length()/6;\n\nfloat hash(vec3 r)  { \n  return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); \n}\n\nvec3 rgb2hsv(vec3 c) {\n  const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(dot(p1, p1) < dot(p2, p2)));\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)/2.0;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  vec3 colb = back.xyz;\n  vec3 colf = front.xyz;\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return xyz;\n}\n\nfloat dot2(vec2 v) { return dot(v,v); }\n    \n// IQ Bezier: https://www.shadertoy.com/view/MlKcDD\nfloat bezier(vec2 pos, vec2 A, vec2 B, vec2 C) {    \n  const float sqrt3 = sqrt(3.0);\n  vec2 a = B - A;\n  vec2 b = A - 2.0*B + C;\n  vec2 c = a * 2.0;\n  vec2 d = A - pos;\n\n  float kk = 1.0/dot(b,b);\n  float kx = kk * dot(a,b);\n  float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n  float kz = kk * dot(d,a);      \n\n  float res = 0.0;\n\n  float p = ky - kx*kx;\n  float p3 = p*p*p;\n  float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n  float h = q*q + 4.0*p3;\n\n  if(h>=0.0) {   // 1 root\n      h = sqrt(h);\n      vec2 x = (vec2(h,-h)-q)/2.0;\n      vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n      float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n      res = dot2(d+(c+b*t)*t);\n  } else {   // 3 roots\n      float z = sqrt(-p);\n      float v = acos(q/(p*z*2.0))/3.0;\n      float m = cos(v);\n      float n = sin(v)*sqrt3;\n      vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n      res = min(dot2(d+(c+b*t.x)*t.x), dot2(d+(c+b*t.y)*t.y));\n      // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\n      // res = min(res,dot2(d+(c+b*t.z)*t.z));\n  }\n  \n  return sqrt(res);\n}\n\nfloat bezier2(vec2 p, float f, vec2 p0, vec2 dp0, vec2 p1, vec2 dp1) {\n  float dist = length(p0 - p1);\n  float hdist = 0.5*f*dist;\n  vec2 mp0 = p0 + hdist*dp0;\n  vec2 mp1 = p1 + hdist*dp1;\n  vec2 jp = (mp0 + mp1)*0.5;\n  float d0 = bezier(p, p0, mp0, jp);\n  float d1 = bezier(p, p1, mp1, jp);\n  \n  float d = d0;\n  d = min(d, d1);\n  return d;\n}\n\nfloat emin(float a, float b, float k) {\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat df(vec2 p, float s, float aa) {\n  vec2 hp = p/s;\n  vec2 hn = hextile(hp);\n  \n  vec2 pp = toPolar(hp);\n  float pn = mod1(pp.y, TAU/6.0);\n  vec2 tp = toRect(pp);\n\n  pn = mod(pn+3.0, 6.0);\n  vec3 nn = vec3(hn, pn);\n\n  float r = hash(nn);\n  int sel = int(float(noCorners)*r);\n  int off = sel*6;\n  \n\n  const float sw = 0.05;\n\n  float d = 1E6;\n\n  for (int i = 0; i < 3; ++i) {\n    int c0 = corners[off + i*2 + 0];\n    int c1 = corners[off + i*2 + 1];\n    \n    int c = max(c0, c1) - min(c0, c1);\n    \n    vec2 p0 = coords[c0];\n    vec2 p1 = coords[c1];\n\n    vec2 dp0 = dcoords[c0];\n    vec2 dp1 = dcoords[c1];\n    \n    float mi = 0.5;    \n    float mx = 0.5;    \n    \n    float rr = fract(r*27.0*float(i+1));\n    switch(c) {\n      case 1:\n        mx = 1.75;\n        break;\n      case 2:\n        mx = .95;\n        break;\n      case 3:\n        mx = 1.5;\n        break;\n      case 4:\n        mx = 0.75;\n        break;\n      case 5:\n        mx = 1.95;\n        break;\n      default:\n        break;\n    }\n    \n    float f = mix(mi, mx, rr);\n    \n    float dd = (bezier2(tp, f, p0, dp0, p1, dp1)-0.005)*s;\n    d = pmin(d, dd, 0.025);\n    \n  }\n\n  d = abs(d) - 0.005;\n  d = abs(d) - 0.0025;\n  return d;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec2 op = p;\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*0.5+q.y*0.5-q.x;\n  pp.x *= (-1.0+length(p));\n  p = toRect(pp);\n  float s = 1.75;\n  float aa = 2.0/RESOLUTION.y;\n  vec3 n;\n  p += TIME*0.1;\n  float d = df(p, s, aa);\n  \n  \n  vec3 col = vec3(0.0);\n  vec3 glowHsv = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 1.0, 1.0), 0.5 + 0.5*sin(-TIME+0.25*TAU*length(op)));\n  vec3 glowCol = hsv2rgb(glowHsv);\n\n  col = col += glowCol*exp(-d*30.0);  \n  col = col += 4.0*(glowCol+vec3(0.2))*exp(-d*800.0);  \n\n  return col;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 pp = p + 0.5;\n  vec2 nn = floor(pp);\n  p = fract(pp) - 0.5;\n  return nn;\n}\n\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n  float sa = PI/rep - SABS(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n  hp = toRect(hpp);\n  p = hp;\n  return rn;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 op = p;\n  \n  const float rep = 42.00;\n  const float srep = 0.075*40.0/rep;\n  float n = smoothKaleidoscope(p, srep, rep);\n  p *= ROT(iTime*0.25);\n  vec3 col = effect(p, q);\n\n  vec2 pp = toPolar(op);\n  float per = 20.0/(0.1+length(p));\n  float s = mix(10.0, 100.0, 0.5+0.5*(sin(per*op.y+iTime)*sin(per*op.x-iTime)));\n  col = pow(col, 0.5*vec3(0.5, 0.75, 1.0)*tanh(-0.125+s*dot2(p)));\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKBWD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1386, 1386, 1407, 1407, 1495], [1497, 1497, 1519, 1519, 1844], [1846, 1846, 1868, 1868, 2037], [2039, 2039, 2067, 2166, 2406], [2408, 2408, 2430, 2430, 2474], [2476, 2476, 2497, 2497, 2538], [2540, 2572, 2611, 2611, 2736], [2738, 2738, 2778, 2778, 2886], [2888, 2888, 2908, 2908, 2927], [2933, 2985, 3033, 3033, 4065], [4067, 4067, 4137, 4137, 4409], [4411, 4411, 4450, 4450, 4524], [4526, 4526, 4565, 4565, 4654], [4656, 4656, 4693, 4693, 5850], [5852, 5852, 5881, 5881, 6384], [6386, 6386, 6413, 6413, 6495], [6497, 6497, 6542, 6542, 6696], [6698, 6698, 6759, 6759, 6967], [6969, 6969, 7006, 7006, 7214], [7216, 7216, 7268, 7268, 7818]], "test": "untested"}
{"id": "WdGfWD", "name": "Messing with Phong", "author": "PlathC", "description": "First raymarching test project with post-processing Sobel filter for shiny outline.", "tags": ["3d", "raymarching", "sobel"], "likes": 7, "viewed": 459, "published": 3, "date": "1607176045", "time_retrieved": "2024-07-30T20:32:07.666995", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sobel filter\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    mat3 kernelX = mat3(-1, 0, 1,\n                        -2, 0, 2,\n                        -1, 0, 1);\n    \n    mat3 kernelY = mat3(-1, -2, -1,\n                         0,  0,  0,\n                         1,  2,  1);\n    \n    float wStep = 3.f / iResolution.x;\n    float hStep = 3.f / iResolution.y;\n    \n    float tempFragXValue = 0.f;\n    float tempFragYValue = 0.f;\n    for(float i = -1.f; i <= 1.f; i++)\n    {\n     \tfor(float j = -1.f; j <= 1.f; j++)\n        {\n            vec2 newTextureCoordinates = vec2(uv.x + (i * wStep), uv.y + (j * hStep));\n            vec4 pixel = vec4(texture(iChannel0, newTextureCoordinates).xyz, 1.0);\n            float gray = (pixel.x + pixel.y + pixel.z) / 3.f;\n        \ttempFragXValue += kernelX[int(i)+1][int(j)+1] * gray;\n            tempFragYValue += kernelY[int(i)+1][int(j)+1] * gray;\n        }\n    }\n\t\n    float resultFrag = length(vec2(tempFragXValue, tempFragYValue));\n\t\n    // Mix sobel color with base image color and show the mean of both in order to create shiny outline.\n    fragColor = vec4(resultFrag, resultFrag, resultFrag, 1.0) * vec4(texture(iChannel0, uv).xyz, 1.0) + 0.5 * vec4(texture(iChannel0, uv).xyz, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat3 xRotationMatrix(float radAngle)\n{\n    return mat3(1., 0.,            0.,\n                0., cos(radAngle), -sin(radAngle),\n                0., sin(radAngle), cos(radAngle));\n}\n\nmat3 yRotationMatrix(float radAngle)\n{\n    return mat3(cos(radAngle),  0., sin(radAngle),\n                0.,             1., 0.,\n                -sin(radAngle), 0., cos(radAngle));\n}\n\nmat3 zRotationMatrix(float radAngle)\n{\n    return mat3(cos(radAngle), -sin(radAngle), 0.,\n                sin(radAngle),  cos(radAngle), 0.,\n                0., 0., 1.);\n}\n\nmat4 transformationMatrix(vec3 translation, vec3 radAngles)\n{\n    mat3 xMatrix = xRotationMatrix(radAngles.x);\n    mat3 yMatrix = yRotationMatrix(radAngles.y);\n    mat3 zMatrix = zRotationMatrix(radAngles.z);\n    \n    mat3 rotationMatrix = zMatrix * yMatrix * xMatrix;\n    mat4 result = mat4(rotationMatrix[0].x, rotationMatrix[1].x, rotationMatrix[2].x, translation.x,\n                       rotationMatrix[0].y, rotationMatrix[1].y, rotationMatrix[2].y, translation.y,\n                       rotationMatrix[0].z, rotationMatrix[1].z, rotationMatrix[2].z, translation.z,\n                       0.,\t\t\t\t    0., \t\t\t     0.,                  1.);\n    return result;\n}\n\nmat4 transformationMatrix(vec3 translation, vec3 radAngles, float scale)\n{\n    mat3 xMatrix = xRotationMatrix(radAngles.x);\n    mat3 yMatrix = yRotationMatrix(radAngles.y);\n    mat3 zMatrix = zRotationMatrix(radAngles.z);\n    \n    mat3 rotationMatrix = zMatrix * yMatrix * xMatrix;\n    mat4 result = mat4(rotationMatrix[0].x, rotationMatrix[1].x, rotationMatrix[2].x, translation.x,\n                       rotationMatrix[0].y, rotationMatrix[1].y, rotationMatrix[2].y, translation.y,\n                       rotationMatrix[0].z, rotationMatrix[1].z, rotationMatrix[2].z, translation.z,\n                       0.,\t\t\t\t    0., \t\t\t     0.,                  scale);\n    return result;\n}\n", "buffer_a_code": "#define PI 3.1415926538\n#define DEG2RAD(deg) deg * PI / 180.\n\n#define MAX_STEPS 800\n#define STEP_SIZE 0.01\n#define MAX_DIST 10.\n#define EPSILON 0.00001\n\n// Camera strongly based on https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays\n// and http://viclw17.github.io/2018/11/29/raymarching-algorithm/\nstruct Camera \n{\n    vec3 origin;\n    vec3 rayDirection;\n};\n    \nCamera buildCamera(vec2 uv, float imageRatio, float radFieldOfView, vec3 eyePosition, vec3 translation, vec3 rotation)\n{\n    vec2 screenPixel = vec2(uv) * 2. - vec2(1.);\n    screenPixel *= tan(radFieldOfView / 2.);\n    screenPixel.x *= imageRatio;\n    \n    mat4 worldToCamMatrix = transformationMatrix(translation, rotation);\n    \n    vec3 pixelPosition = (vec4(vec3(screenPixel, 1), 1.)* worldToCamMatrix).xyz;\n    \n    vec3 rayDirection = (vec4(normalize(pixelPosition - eyePosition), 1.) * worldToCamMatrix).xyz;\n    \n    return Camera(pixelPosition, rayDirection);\n}    \n\n\nfloat sdfTorus(vec3 point, vec2 size)\n{\n  \tvec2 q = vec2(length(point.xz)- size.x, point.y);\n\treturn length(q) - size.y;\n}\n\n\nvec4 skyShading(vec3 direction)\n{\n\treturn vec4(vec3(abs(sin(direction) * cos(direction))), 1.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat displacement(vec3 p)\n{\n\treturn sin((1.25 * sin(iTime)) * p.x) * sin((1.25 * cos(iTime)) * p.y) * sin((1.25 * sin(iTime)) * p.z);\n}\n\nfloat opDisplace(vec3 p)\n{\n    float d1 = sdfTorus(p, vec2(2., 0.5));\n    float d2 = displacement(p);\n    return d1 + d2;\n}\n\n//http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        opDisplace(vec3(p.x + EPSILON, p.y, p.z)) - opDisplace(vec3(p.x - EPSILON, p.y, p.z)),\n        opDisplace(vec3(p.x, p.y + EPSILON, p.z)) - opDisplace(vec3(p.x, p.y - EPSILON, p.z)),\n        opDisplace(vec3(p.x, p.y, p.z  + EPSILON)) - opDisplace(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n//https://en.wikipedia.org/wiki/Phong_reflection_model\nvec4 phong(vec3 point, Camera camera)\n{\n\tvec3 normal = estimateNormal(point);\n    const vec3 specular = vec3(1., 1., 1.);\n    const vec3 diffuse = vec3(1., 1., 1.);\n    const float ambient = 0.5;\n    const float shininess = 10.;\n    \n    const vec3 light = vec3(1., 1., 2.);\n    vec3 directionLightVector = normalize(light - point);\n    vec3 perfectRay = 2. * (directionLightVector * normal) * normal - directionLightVector;\n    vec3 directionToViewer = normalize(camera.origin - point);\n    \n    // The actual phong formula \"messing\"\n    vec3 color = ambient + (diffuse * (directionLightVector * normal) + specular * pow(abs(perfectRay * directionToViewer), vec3(shininess)));\n\n    return vec4(color, 1.);\n}\n\nvec4 rayMarch(Camera cam)\n{\n    mat4 transform = transformationMatrix(vec3(0., 0., 0.), \n                                          vec3(DEG2RAD(180. * sin(iTime)), DEG2RAD(180. * sin(iTime)), DEG2RAD(180. * sin(iTime))), \n                                          1.);\n   \tfloat fullDistance = 0.;\n    vec3 position = vec3(0., 0., -5);\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 currentPoint = cam.origin + fullDistance * cam.rayDirection;\n        \n        bool hit = false;\n        float accumulation = 0.;\n        float currentDistance = opDisplace((transform * vec4(currentPoint + position, 1.)).xyz);\n        if(currentDistance < EPSILON)\n        {\n            return phong((transform * vec4(currentPoint + position, 1.)).xyz, cam);\n        }\n                \n        fullDistance += STEP_SIZE;\n        if(fullDistance > MAX_DIST)\n            return skyShading(cam.rayDirection);    \t\n    }\n    \n    return skyShading(cam.rayDirection);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    const float fieldOfView = 90.;\n    vec2 uv = fragCoord / iResolution.xy;\n    float imageRatio = iResolution.x / iResolution.y;\n    Camera camera = buildCamera(uv, imageRatio, DEG2RAD(fieldOfView), vec3(0., 0., -2.), \n                                vec3(0., 0., 0.), vec3(0., 0., DEG2RAD(90. * cos(iTime))));\n\n    \n    fragColor = rayMarch(camera);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 77, 1293]], "test": "untested"}
{"id": "3dVBWD", "name": "Day idk", "author": "jeyko", "description": "Port from glsl. It's a bit broken for some reason, not looking as intended. Going to fix later", "tags": ["mdtmjvm"], "likes": 4, "viewed": 288, "published": 3, "date": "1607163730", "time_retrieved": "2024-07-30T20:32:08.553625", "image_code": "\n\nfloat r11(float g){return fract(sin(g*3.223)*43.20);}\n\n// WRIGHTER HERE \n// I HAVE NO CLUE WHAT IM GONNA MAKE LOL\n\n#define rot(j) mat2(cos(j), sin(j), -sin(j),cos(j))\n#define pi acos(-1.)\n\nfloat sdLine(vec2 p, vec2 a, vec2 b){\n  vec2 dir = normalize(b - a);\n  float slope = atan(dir.y,dir.x);\n  vec2 op = p;\n  p -= a;\n  p = p*rot(slope);\n  float d = length(p.y);\n  \n  d = max(d, -p.x);\n  \n  d = max(d, p.x - length(b-a)*0.3 );\n  return d;\n  }\n#define xor(a,b,c) min(max(a,-b), max(-a + c,b))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n  float T = iTime;\n  float tbetween = 6.;\n  float seg = floor(T/tbetween);\n  \n  vec3 col = vec3(0);\n  vec2 p = uv;\n  float d = 10e5;\n  float dir = floor(r11(seg)*8.)*pi/4.;\n  \n  \n  float id = seg;\n  \n  for (float chrab = 0.; chrab < 8. ; chrab ++){\n    \n    p = uv;\n    p += ( normalize(p)*.2*float(r11(id*241.512) < 0.5)+ chrab*0.04*sin(T))*1.7*length(p);\n    p *= rot(dir);\n    if (r11(id*1.2 + 0.5) < 0.5){\n      d = 10e5;\n    \n    }\n    //T = fGlobalTime;\n    for ( float i = 0.; i < 6. + r11(id)*10. ; i ++){\n      \n      T += (1.*r11(id) + 0.1);\n      float r = r11(id + i + 1.45463*i*id);\n      \n      \n      if (r < 0.05){\n        p *= rot((0.2 + T*0.0001*r11(id + 0.4) + (T)*0.4*r11(id + i))*pi);\n        //p = abs(p) - 0.5;\n      }\n      p -= (T - seg*tbetween)*0.01*(r11(id + i*0.04));\n        \n      for (float k = 0.; k < 7.*r11(id*42.231+i) + 4.; k++){\n        vec2 luv = p;\n        luv.y += r11(i*421.1*id);\n        \n        vec2 ap = p;\n        if (r11(id*1.4124) < 0.1){\n          ap *= rot(pi/2.);\n        }\n        d = xor(d,sdLine(ap,vec2(-0.4,0),vec2(0.4,0)) - .05*r11(id+i*0.042), 0.1*r11(id + i));\n        \n      }\n      if(r11(id*i + 0.4) < 0.4){\n        d = xor(d, abs(length(p) - r11(id + i)) - 3.6*r11(id*21.4 + i*float(r11(id)> 0.5)), .7*r11(id));\n      }\n      p.y -= r11(id*1.231)*0.1;\n      p.x -= r11(id*1.231 + i)*0.5*sign(r11(id + i*4.)*2. - 1.);\n    \n      if (r11(id) > 0.7){\n        d = xor(d,p.y,0.1);\n      }\n      \n      if (r11(id + 0.24) < 0.1){\n        d = xor(d,p.x,0.4);\n      }\n    \n      \n    }\n    \n    #define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + e))\n    float coco = smoothstep(0.004,0.,d);\n    \n    if(r11(id*6.02351) > 0.5){\n    \n    //col += pal(0.5,0.5);\n      col += coco*pal(0.5,0.5,vec3(4.7,1.4,1.4),1. + vec3(sin(T*0.24),cos(T*0.1),sin(T*0.5)),id + T*0.1 + chrab*0.1);\n    \n    } else {\n      col[int(mod(chrab,3.))] += coco;\n    }\n    \n  }\n  \n  if(r11(id*1.02351) > 0.5){\n    //col = 1- col;\n  } \n  \n  \n  \n  \n  col = pow(col,vec3(0.4545));\n\n   fragColor = vec4(col,1.0);\n\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 21, 55], [191, 191, 228, 228, 444], [494, 494, 551, 551, 2680]], "test": "untested"}
{"id": "WdKBWD", "name": "Shader Royale #2", "author": "anticore", "description": "my entry for shader royale 2 4/12/2020\n\nplease play the audio in iChannel0 for maximum effect", "tags": ["raymarch", "shader", "glow", "2", "royale"], "likes": 5, "viewed": 479, "published": 3, "date": "1607162218", "time_retrieved": "2024-07-30T20:32:09.409337", "image_code": "\nfloat sdSphere(vec3 p, vec3 pos, float r) {\n  return length(p + pos) -r;\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox(vec3 p, vec3 pos, vec3 b) {\n    vec3 q = abs(p + pos) - b;\n    return min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBoxes(vec3 p, vec3 pos, vec3 b) {\n    float n = texelFetch( iChannel0, ivec2(0.2 * 512.,0), 0 ).x;\n    p.xy *= rot(sin(iTime * 3.));\n    p.y += sin(iTime * 2. + p.x * (1.2 + sin(iTime) / 2.) + n );\n    p = vec3(p.x, mod(p.y, 0.4), p.z);\n    vec3 q = abs(p + pos) - b;\n    return min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat opMin(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opSmooth(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0., 1.);\n  return mix(d2, d1, h) - k * h * (1.-h);\n}\n\nfloat sdSpheres(vec3 p) {\n    float n = texelFetch( iChannel0, ivec2(0.2 * 512.,0), 0 ).x;\n    p = p - mod(p, 0.16 + n * 0.1 - abs(cos(iTime)) / 5. );\n    float t = iTime;\n  \n    float spheres = 999.;\n    for (int i = 0; i < 18; i++) {\n        float p1 = t / 2. * float(i);\n        float p2 = t /4. * (5. - float(i));\n        float p3 = t + float(i) * 2.;\n      \n        spheres = opSmooth(spheres, sdSphere(p, vec3(sin(p1)*3., cos(p2)*3., sin(p3)+12.), float(i) * 0.05), 1.);\n    }\n    \n    return spheres;\n}\n\nvec2 map(vec3 p) {\n    float n = texelFetch( iChannel0, ivec2(0.2 * 512.,0), 0 ).x;\n    float s = sdSphere(p, vec3(0.,0.,10.), 2. + n );\n    float b = sdBoxes(p, vec3(5,0,10), vec3(10,.2,5));\n    float bms = opMin(b,s);\n    float ss = sdSpheres(p);\n    \n    return vec2(opSmooth(bms, ss, 0.5), ss < bms ? 1 : 0);\n}\n\nvec3 tr(vec3 ro, vec3 rd){\n    float td = 1.;\n    vec2 h;\n  \n    float n = texelFetch( iChannel0, ivec2(0,0), 0 ).x;\n  \n    vec3 c0 = vec3(0.);\n    vec3 glo0 = vec3(abs(sin(iTime)) * n * 0.035,abs(cos(iTime)) * n * 0.035,0.03);\n    vec3 c1 = vec3(0.);\n    //vec3 glo1 = vec3(0.02, 0,0);\n    vec3 glo1 = 0.015 * (0.5 + 0.5 * cos(iTime * 2. + rd.y*2. + vec3(4.,1.,0.))) + 0.015 * (0.5 + 0.5 * cos(iTime * 3. + rd.y*5. + vec3(1.,4.,0.)));\n  \n    for (int i = 0; i < 100; i++) {\n        h = map(ro + rd * td);\n        td += h.x;\n      \n        if (h.y == 0.) c0 += glo0; else c1 += glo1;\n      \n        if (h.x < 0.01 || h.x > 20.) break;\n    }\n    \n    return c0 + c1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    float n = texelFetch( iChannel0, ivec2(0,0), 0 ).x;\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv = sin(iTime / 2.) > 0. ? uv : abs(uv);\n  \n  vec3 ro= vec3(cos(iTime * 4.) / 4. + 0.2,0.,1.7 + n / 1.);\n  vec3 rd = normalize(vec3(uv, 0) - ro);\n\n  fragColor = vec4( tr(ro, rd), 1);\n}\n", "image_inputs": [{"id": 24800, "src": "https://soundcloud.com/lug00ber/oh-let-you-lift-me-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 44, 44, 75], [77, 77, 96, 96, 169], [171, 171, 210, 210, 288], [290, 290, 331, 331, 612], [614, 614, 647, 647, 674], [676, 676, 721, 721, 819], [821, 821, 846, 846, 1330], [1332, 1332, 1350, 1350, 1646], [1648, 1648, 1674, 1674, 2315], [2317, 2317, 2374, 2374, 2758]], "test": "untested"}
{"id": "wdyfDD", "name": "Convolution Audio Pulse", "author": "jackwitherell", "description": "I copied sam and also copied convolution from https://www.shadertoy.com/view/XsSfWR\n\ncomputer graphics has always been gatekept\n\nuploaded from a church", "tags": ["test", "camera", "audio"], "likes": 7, "viewed": 786, "published": 3, "date": "1607145182", "time_retrieved": "2024-07-30T20:32:10.277017", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //uv = vec2(uv.x,mod(uv.y+texelFetch(iChannel1,ivec2(uv.x*512.0,0),0).x,1.0));\n    vec2 offset_uv = (uv-0.5);\n    uv-=length(offset_uv) * normalize(offset_uv)*texelFetch(iChannel1,ivec2((((atan(-abs(offset_uv.x),offset_uv.y)/(2.0*3.141592))+1.0)/1.0)*512.0,0),0).x;\n    \n    vec3 a = texture(iChannel0,uv).rgb;\n    \n    // Time varying pixel color\n    vec3 col = a;\n    if(uv.y<0.0){\n        col=1.0-col;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// LICENSE:\n// Creative Commons Attribution 4.0 International License.\n// https://creativecommons.org/licenses/by/4.0/\n\n#define T(x) texture(iChannel0, fract((x)/iResolution.xy))\n\nvoid mainImage(out vec4 c, vec2 u)\n{   \n    //c=1./u.yyyx;\n    c=u.yyyx/1e4;///iTime;\n    //for(float t=1.4; t<1e2; t+=t)\n    //    c += (c.gbar-c)/3.+T(u-c.wz*t);\n    for(float t=.6; t<4e2; t+=t)\n    \tc += c.gbar/4.-c*.3+T(u-c.wz*t);\n    \n\tc = mix(T(u+c.xy), cos(c), .07);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 621]], "test": "untested"}
{"id": "tdyfWD", "name": "SimpleProceduralPattern", "author": "antoinefortin", "description": "ddsds", "tags": ["mwat"], "likes": 2, "viewed": 255, "published": 3, "date": "1607126479", "time_retrieved": "2024-07-30T20:32:11.115774", "image_code": "vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\nfloat plane(vec3 pos)\n{\t\n    \n    vec3 q = pos;\n    \n\treturn q.y;\n}\n\n\nfloat sphere(vec3  pos, float radius)\n{\t\n    pos.y -= 4.0;\n    vec3 q = pos; \n    float r = 3.0 + sin(iTime + (q.x * 6.));\n   // r += 1.0 + cos(iTime + (q.y * 5.));\n    return length(pos) - radius;\n}\n\nfloat map(vec3 pos)\n{\n    pos.x += cos(sin(iTime));\n    float planeDist = plane(pos);   \n    //pos = mod(pos + 5.0, 10.0) - 5.0;\n\treturn min(planeDist, min(sphere(pos, 4.0), sphere(pos + vec3(1.0, -3., -1.5), 5. + abs(sin(pos.x + pos.x)))));\n    \n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nvec3 material(vec3 pos)\n{\n    return vec3(smoothstep(0.4, 0.41, fract(pos.x + sin(pos.z * 0.4 + iTime))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec3 pos = vec3(0.0, 5.0, -15.0);\n    \n    // Rayon que l'on envoie dans l'espace pour chacuns des pixels\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));    \n    vec3 col = vec3(fract(abs(dir.y * dir.x) * 4.));\n    //col = smoothstep(-4.5, 1.75 * abs(sin(iTime)), col * vec3(.5,.5, 2.));\n    \n    for(int i = 0; i < 256; i++)\n    {\n       \tfloat d/*istance*/ = map(pos); \n       \t//  Point is near enough\n        if(d < 0.001)\n        {\t\n            \n            \n            vec3 nws = computeNormal(pos);\n\t\t\tvec3 lightpos = vec3(5.0,12., -2.);\n            vec3 lColor = vec3(.15, .4, .9);\n           \tvec3 l1 = vec3(dot(normalize(pos + (nws)), normalize(lightpos)));\n\t\t\tvec3 l2 = vec3(dot(normalize(pos + nws * 2.), normalize(lightpos + vec3(-15., 12., -5.))));\n            l2 *= vec3(3.6, .3, .2)/*Color 2*/;\n        \tcol = lColor * (l1 + l2);\n            pos.x += pos.z;\n            col *= abs(cos(iTime) + sin(pos.x * pos.y + cos(pos.z)));\n            col *= clamp(col, 0.1, .5);\n        \tbreak;\n        }\n        pos += d * dir;\n        \n        \n        \n\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(sqrt(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 126], [128, 128, 151, 151, 195], [198, 198, 237, 237, 397], [399, 399, 420, 420, 647], [649, 649, 679, 679, 893], [895, 895, 920, 920, 1003], [1006, 1006, 1063, 1063, 2273]], "test": "untested"}
{"id": "tdyfWW", "name": "Physics Testing Compound #1", "author": "oneshade", "description": "The texture mapping is better now. Use the mouse to rotate.", "tags": ["3d", "terrain", "physics"], "likes": 6, "viewed": 235, "published": 3, "date": "1607110086", "time_retrieved": "2024-07-30T20:32:12.148015", "image_code": "/*\nA combination of my \"3D Collisions\" and \"3D Terrain Experiment\" shaders.\n*/\n\n// Screen variables:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\nvec2 antialiasing = vec2(1.0, 1.0); // Set to 2x2 if your computer can handle it.\nbool shadows = false; // Set to true for shadows but it may make the shader run slower.\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, -0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(-10.0, 5.0, -10.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 1.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 80.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst float SHADOW_BIAS = MIN_HIT_DISTANCE * 2.0;\nconst int MAX_STEPS = 200;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n    return surfaceUnion;\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    vec2 terrainUV = mod(p.xz * 0.5, vec2(2.0)) * 0.5;\n    vec3 terrainTexture = texture(iChannel1, terrainUV).rgb;\n    Surface terrain = Surface(0.2 * terrainTexture,\n                              terrainTexture,\n                              vec3(0.0, 0.0, 0.0), 0.0,\n                              mapCompoundTerrain(p) * 0.6);\n\n    vec2 wallsUV = p.xy * 0.05;\n    if (abs(p.x) > abs(p.z)) {\n        wallsUV = p.yz * 0.05;\n    }\n\n    wallsUV.x *= 0.5;\n    vec3 wallsTexture = texture(iChannel2, wallsUV).rgb;\n    Surface walls = Surface(0.2 * wallsTexture,\n                            wallsTexture,\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            mapCompoundWalls(p));\n\n    Surface ball = Surface(vec3(0.2, 0.0, 0.0),\n                           vec3(1.0, 0.0, 0.0),\n                           vec3(1.0, 1.0, 1.0), 8.0,\n                           length(p - getBallPos()) - BALL_RADIUS);\n\n    Surface light = Surface(vec3(1.0, 1.0, 1.0),\n                            vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            length(p - lightDirection * 100.0) - 10.0);\n\n    return Union(terrain, Union(walls, Union(ball, light)));\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Shadow mapping function:\nbool visibleFromLight(in vec3 p, in vec3 normal) {\n    p += normal * SHADOW_BIAS;\n    float shadowDistance = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 shadowTestPosition = p + lightDirection * shadowDistance;\n        Surface occluderSurface = mapScene(shadowTestPosition);\n        if (abs(occluderSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            return false;\n        }\n\n        if (shadowDistance > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        shadowDistance += occluderSurface.signedDistance;\n    }\n\n    return true;\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in vec3 hitPosition, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightColor;\n\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightColor;\n\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightColor;\n\n    float shadow = shadows ? float(visibleFromLight(hitPosition, normal)) : 1.0;\n\n    return illuminationAmbient + shadow * (illuminationDiffuse + illuminationSpecular);\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n\n    vec3 color = backgroundColor;\n    vec3 currentPosition, normal;\n    Surface sceneSurface;\n\n    bool rayHit = false;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        currentPosition = ray.origin + ray.direction * distanceTraveled;\n        sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            rayHit = true;\n            break;\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    if (rayHit) {\n        normal = calculateNormal(currentPosition);\n        color = shadeSurface(sceneSurface, currentPosition, ray, normal);\n    }\n\n    return vec4(color, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 mouse = radians((iMouse.xy - vec2(0.0, halfResolution.y)) * 0.5);\n\n    vec2 c = cos(mouse);\n    vec2 s = sin(mouse);\n\n    cameraRight = vec3(c.x, 0.0, s.x);\n    cameraUp = vec3(s.x * -s.y, c.y, -c.x * -s.y);\n    cameraForward = vec3(s.x * c.y, s.y, -c.x * c.y);\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    for (float yOffset=0.0; yOffset < antialiasing.y; yOffset++) {\n        for (float xOffset=0.0; xOffset < antialiasing.x; xOffset++) {\n            vec2 pixel = (fragCoord + vec2(xOffset, yOffset) / antialiasing - halfResolution) / iResolution.y;\n            vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n            vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * pixel.x - cameraUp * pixel.y));\n            fragColor += rayMarch(Ray(rayOrigin, rayDirection));\n        }\n    }\n\n    fragColor /= antialiasing.y * antialiasing.x;\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starting values:\n    if (ivec2(fragCoord) == ivec2(0, 0)) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n\n    if (ivec2(fragCoord) == ivec2(1, 0)) {\n        fragColor = vec4(0.1, 0.6, 0.1, 1.0);\n    }\n\n    if (iFrame > 0) {\n        // Update values (after initializing them):\n        vec3 ballPos = getBallPos();\n        vec3 ballVel = getBallVel();\n\n        float distToEnv = mapEnvironment(ballPos);\n        if (distToEnv < BALL_RADIUS) {\n            vec3 hitNormal = getNormal(ballPos);\n            ballVel = reflect(ballVel, hitNormal) * DECAY;\n        }\n\n        ballPos.y = max(sampleHeightmap(ballPos.xz) + BALL_RADIUS, ballPos.y);\n\n        ballVel.y -= GRAVITY;\n        ballPos += ballVel;\n        if (ivec2(fragCoord) == ivec2(0, 0)) {\n            fragColor = vec4(ballPos, 1.0);\n        }\n\n        if (ivec2(fragCoord) == ivec2(1, 0)) {\n            fragColor = vec4(ballVel, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Variable retrieval functions:\n#define getBallPos() texelFetch(iChannel0, ivec2(0, 0), 0).xyz\n#define getBallVel() texelFetch(iChannel0, ivec2(1, 0), 0).xyz\n\n#define BALL_RADIUS 1.0\n\n#define GRAVITY 0.01\n#define DECAY 1.0\n\n// Not exact:\nfloat noise1(in float x) {\n    return fract(sin(x * 12.527) * 573.173);\n}\n\nfloat noise2(in float x) {\n    return fract(sin(x * 13.753) * 593.123);\n}\n\nfloat continuousNoise1(in float x) {\n    const float r = 1.1;\n\n    float x1 = floor(x * r) / r;\n    float y1 = noise1(x1);\n\n    float x2 = ceil(x * r) / r;\n    float y2 = noise1(x2);\n\n    return y1 + (0.5 + 0.5 * sin((2.0 * (x - x1) / (x2 - x1) - 1.0) * 1.57)) * (y2 - y1);\n}\n\nfloat continuousNoise2(in float x) {\n    const float r = 1.1;\n\n    float x1 = floor(x * r) / r;\n    float y1 = noise2(x1);\n\n    float x2 = ceil(x * r) / r;\n    float y2 = noise2(x2);\n\n    return y1 + (0.5 + 0.5 * sin((2.0 * (x - x1) / (x2 - x1) - 1.0) * 1.57)) * (y2 - y1);\n}\n\nfloat sampleHeightmap(in vec2 p) {\n    vec2 sp = p * 0.5;\n    float height = 2.0 * (continuousNoise1(sp.x + 0.5 * continuousNoise2(sp.y)) + continuousNoise2(sp.y + continuousNoise1(sp.x)));\n    return height;\n}\n\nfloat mapCompoundTerrain(in vec3 p) {\n    return p.y - sampleHeightmap(p.xz);\n}\n\nfloat mapCompoundWalls(in vec3 p) {\n    vec3 q = abs(p);\n\n    float outer = max(q.y - 15.0, max(q.x, q.z) - 30.0);\n    float inner = max(q.y - 1000.1, max(q.x, q.z) - 29.9);\n\n    return max(outer, -inner);\n}\n\nfloat mapEnvironment(in vec3 p) {\n    return min(mapCompoundTerrain(p), mapCompoundWalls(p));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapEnvironment(p + vec3(0.001, 0.0, 0.0)) - mapEnvironment(p - vec3(0.001, 0.0, 0.0)),\n                          mapEnvironment(p + vec3(0.0, 0.001, 0.0)) - mapEnvironment(p - vec3(0.0, 0.001, 0.0)),\n                          mapEnvironment(p + vec3(0.0, 0.0, 0.001)) - mapEnvironment(p - vec3(0.0, 0.0, 0.001))));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1095, 1143, 1200, 1200, 1368], [1370, 1390, 1428, 1428, 1448], [1450, 1450, 1485, 1485, 2096], [2098, 2125, 2154, 2154, 3366], [3368, 3417, 3450, 3450, 3870], [3872, 3900, 3950, 3950, 4487], [4489, 4544, 4632, 4632, 5262], [5264, 5285, 5312, 5312, 6109], [6111, 6144, 6199, 6199, 7144]], "test": "untested"}
{"id": "WdGBDW", "name": "Weird space", "author": "z0rg", "description": "A reproduction of a planet seen on this cover here // https://www.youtube.com/watch?v=jfyccTi4oVM", "tags": ["space", "weird"], "likes": 9, "viewed": 256, "published": 3, "date": "1607101133", "time_retrieved": "2024-07-30T20:32:13.310905", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 postFX(vec2 uv, float blur)\n{\n    vec3 col;\n    int cnt = 10;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = fi/fcnt;\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 2.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n    \tcol += texture(iChannel0, p).xyz;\n    }\n    \n    return col/float(cnt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec3 col = postFX(uv,.01);\n    \n\t//col += pow(postFX(uv,.02), vec3(.45));\n\tcol = pow(col, vec3(1.6));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat _cir(vec2 uv, float r)\n{\n    return length(uv)-r;\n}\n\nfloat stars(vec2 uv)\n{\n    uv *= r2d(.5);\n    vec2 rep = vec2(0.1,0.1);\n    ivec2 idx = ivec2((uv+.5*rep)/rep);\n    \n    float sz = (sin(float(idx.x)*3.3+float(idx.y)*15.)*.5+.5)*0.007;\n    \n    vec2 perturb = (rep*.5-sz)*vec2(sin(float(idx.x)), cos(float(idx.x)));\n    \n    vec2 p = perturb+mod(uv+rep*.5, vec2(rep))-rep*.5;\n    \n    float v = 1.-sat(_cir(p, sz)*400.);\n    return v;\n}\n\n\n\nvec3 rdr(vec2 uv)\n{\n    float shp = 200.;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col = vec3(1.)*stars(uv);\n    \n    vec3 lightGreen = vec3(69, 181, 157)/255.;\n    vec3 darkGreen = lightGreen * .6;\n    vec3 pink = vec3(255, 0, 153)/255.;\n    \n    float plSz = .2;\n    float planet = _cir(uv, plSz);\n    float planetShadow = max(planet, _cir(uv-vec2(.025), plSz));\n    \n    vec3 planetCol = mix(lightGreen, darkGreen, sat(planetShadow*shp)*sat((sin((uv.y-uv.x)*200.)+.8)*shp));\n    col = mix(col, planetCol,  1.0-sat(planet*shp));\n    \n    float rgSz = 0.5;\n    float rgTh = 0.02;\n    \n    float tRgMv = iTime*2.;\n    vec2 rgMv = vec2(sin(tRgMv)*0.025, cos(tRgMv)*0.01);\n    \n    float rgAn = sin(iTime)*PI/6.0;\n    \n    vec2 rPos = (uv*r2d(rgAn)-vec2(0.,-.05));\n    float ringA = max(_cir(rPos*vec2(1.,4.), rgSz), -_cir(1.25*rPos*vec2(1.,4.)-vec2(0.,.157)+rgMv, rgSz));\n    vec3 rCol = mix(vec3(0.1), pink,sat((abs(ringA)-rgTh)*shp));;\n    col = mix(col, rCol, 1.-sat(ringA*shp));\n    \n    vec2 rPosB = (uv*r2d(-rgAn)-vec2(0.,-.05));\n    float ringB = max(_cir(rPosB*vec2(1.,4.), rgSz), -_cir(1.25*rPosB*vec2(1.,4.)-vec2(0.,.157)+rgMv, rgSz));\n    vec3 rColB = mix(vec3(0.1), pink,sat((abs(ringB)-rgTh)*shp));;\n    col = mix(col, rColB, 1.-sat(ringB*shp));\n\n\tcol += .3*sat(.5+.5*rand(uv*sin(iTime)));\n    col *= .3+rand(uv*sin(iTime));\n    \n    return col;\n}\n\nvec3 rdrChroma(vec2 uv)\n{\n    uv *= pow(1.+length(uv),.5);\n    vec3 col;\n    vec2 dir = vec2(1.);\n    float strength = 0.003+0.003*length(uv*2.);\n    col.r = rdr(uv+dir*strength).r;\n    col.g = rdr(uv).g;\n    col.b = rdr(uv-dir*strength).b; \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(0.5)*iResolution.xy)/iResolution.xx;\n\tuv *= 1.+sin(iTime)*.2+.5;\n    vec3 col = rdrChroma(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBDW.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 431, 431, 848], [851, 851, 908, 908, 1089]], "test": "untested"}
{"id": "tdKfW1", "name": "Isometric Lattice", "author": "Shane", "description": "Using a triangle grid to produce an isometric lattice, rendered in a hand drawn impossible geometry style.", "tags": ["triangle", "sketch", "geometry", "isometric", "quad", "lattice", "impossible"], "likes": 62, "viewed": 1018, "published": 3, "date": "1607089864", "time_retrieved": "2024-07-30T20:32:14.980442", "image_code": "/*\n\n\tIsometric Lattice\n    -----------------\n\n    I thought it'd be fun to quickly code up a standard impossible geometry \n    lattice with a couple of extra elements -- In theory, it involves\n\tstrategically placing some overlapping quads inside the cells of a \n    triangle grid, which should be pretty easy... for a halfway competent\n\tcoder, which I used to be, but I struggle with everything these days. :D\n\n\tThe code was slapped together with a view to getting the job done, so \n\tyou can safely ignore it as I'd imagine there'd be way more elegant\n\tways to produce the same. \n\n\tAnyway, this is just one of countless impossible geometry examples out \n    there. It'd be great to see others on Shadertoy. All involve placing 2D \n    elements in various ways on a grid or the whole canvas.\n\n\n\n\n    Other examples:\n\n\n    // Oldschool isometric maze. I have a version of this somewhere.\n    Isometric Maze - fizzer\n    https://www.shadertoy.com/view/Md2XRd\n\n\t// Flopine has a few interesting isometric examples worth looking at.\n    // This particular one was coded in a few minutes... It took me that\n\t// long just to decide what colors I wanted to use. :)\n\tFlopine - I'm trapped \n\thttps://www.shadertoy.com/view/WtsfWr\n\n\n*/\n\n\n// Triangle grid cell borders. If you like spoiling illusions like I do,\n// this is the command to comment in. :)\n//#define SHOW_CELLS\n\n// Display T-joins instead of cube joins.\n//#define TJOINS\n\n// A singe join, instead of four. It produces a cleaner design, but a less \n// interesting one, I believe.\n//#define ONE_JOIN\n\n// Display the mid edge green block.\n#define MID_BLOCK\n    \n\n\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix similar, but rotated, layers on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.); q += 2.5;\n    float ns2 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    q *= rot2(-3.14159/5.);  q += 4.5;\n    float ns3 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Compare it to the underlying grey scale value.\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    const float contrast = 1.;\n    ns = (.5 + (gr - (max(max(ns, ns2), ns3)))*contrast); // Same, but with contrast.\n    //ns = smoothstep(0., 1., .5 + (gr - max(max(ns, ns2), ns3))); // Different contrast.\n    // \n    // Return the pencil sketch value.\n    return vec3(clamp(ns, 0., 1.));\n    \n}\n\n\n// IQ's distance to a regular polygon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV2 4\n//\nfloat sdPoly4(in vec2 p, in vec2[NV2] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n// IQ's 2D box function.\nfloat sBox(in vec2 p, in vec2 b){\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n    \n   vec2 l = vec2(length(b - a), ew);\n   return sBox(p, (l + ew)/2.);\n    \n}\n\n \n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.y, -s.x, 1)*p; }\n\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.y, -s.x, 1))*p; }\n\n\n\nconst float scale = 1.;\n// Rectangle stretch.\nconst vec2 rect = vec2(1, 1./.8660254)*scale; \n//const vec2 rect = vec2(.85, 1.15)*scale; \n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(0, rect.y*.5); // 12 x .2\n// Irregular skewing is possible too, since it's all just math.\n//const vec2 sk = vec2(rect.x*.4, rect.y*.2); // 12 x .2\n\n\n/*\n//#define FLAT_TOP\n\n#ifdef FLAT_TOP\n//vec2 dim = vec2(1.5, 1)*scale;\n//const vec2 rect = vec2(1., 1.5)*scale; // 12 x .2\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0); // 12 x .2\n#else\nconst vec2 rect = (vec2(1, 1./.8660254))*scale; \n\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(0, rect.y*.5); // 12 x .2\n\n#endif\n*/\n\n\n\nfloat gTri;\nvec4 getTri(vec2 p){\n    \n     p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //float tri = p.x/rect.x < -p.y/rect.y? 1. : 0.;\n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 0. : 1.;\n   \n    p = unskewXY(p, sk);\n    \n    return vec4(p, id);\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // SETUP.\n    \n    // Aspect correct pixel coordinates.\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Scale, or zoom variable, if you prefer.\n    const float sc = 4.;\n    \n    // Scaling and translation.\n    vec2 p = uv*sc - vec2(1)*iTime/2.;\n    \n    // Perturbing the coordinates for imperfect hand drawn lines.\n    vec2 offs = vec2(fbm(p*16.), fbm(p*16. + .35));\n    const float oFct = .01;\n    p -= (offs - .5)*oFct;\n    \n    // Copy of the original coordinates.\n    vec2 oP = p;\n    \n    // Scale based smoothing factor. Good as a general scene formula, but for trickier\n    // fields, derivatives, etc, should be taken into account.\n    float sf = sc/iResolution.y;\n\n\n    \n    // Shadow coordinate, ID and triangle orientation id.\n    vec2 shOff = normalize(vec2(1, -1.25))*.175;\n    vec4 p4Sh = getTri(p - shOff);\n    vec2 pSh = p4Sh.xy;\n    vec2 idSh = p4Sh.zw;\n    float triSh = gTri;\n    \n    // Cell coordinate, ID and triangle orientation id.\n    vec4 p4 = getTri(p);\n    p = p4.xy;\n    vec2 id = p4.zw;\n    float tri = gTri;\n\n    \n    \n    // Using the unique cell ID to produce a random number.\n    float rnd = hash21(id);\n     \n   \n    // DISTANCE FIELD CALCULATION.\n    \n       \n    // Grid vertices, clockwise from the bottom left:\n    //\n    //vec2[4] vert = vec2[4](vec2(-rect.x, -rect.y)/2., vec2(-rect.x, rect.y)/2.,\n                            //vec2(rect.x, rect.y)/2., vec2(rect.x, -rect.y)/2.));\n    \n    // However, what you'll note is that the above can be written in the following\n    // manner.\n    //\n    // These are just the vertices of a unit grid cell, and when coupled with the\n    // cell ID, can be used for all kinds of things. You can also construct\n    // midway points between vertices for unique edge identifiers, which enables\n    // the construction of weaves, jigsaw patterns, etc.\n    //\n    // By the way, and this can get confusing, all IDs in this example will work,\n    // and will be unique. However, if you want them be position bases, like reading\n    // into a heightmap or whatever, all IDs need to be multiplied by the cell\n    // dimensions, \"rect.\"\n    vec2[4] vertID = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5));\n    \n    // The rectangular grid vertices.\n    vec2[4] vert = vec2[4](vertID[0]*rect, vertID[1]*rect, vertID[2]*rect, vertID[3]*rect);\n    \n    for(int i = 0; i<4; i++) vert[i] = unskewXY(vert[i], sk); // Unskew.\n    \n    \n   \n \n    \n    // RENDERING.\n    \n     // Using the unique ID to give the cells a unique background color\n    // via IQ's versatile palette formula.\n    vec3 bg = vec3(.3, .6, 1);\n    //bg = .6 + .4*cos(6.283*hash21(id + tri)/4. + vec3(0, 1, 2)); // Random cell color.\n    \n    /*\n    // Background lines.\n    vec2 qUV2 = rot2(-3.14159/3.)*p;\n    float freq2 = 30.;\n    float pat2 = abs(fract(qUV2.y*freq2) - .5)*2.;\n    pat2 = smoothstep(0., sf*freq2*2., pat2 - .2);    \n    bg *= pat2*.5 + .7;\n    */\n    \n    // Set the scene to the cell background.\n    vec3 col = bg;\n    \n    /*\n    // Color the upside down triangles the opposing color.\n    if(tri<.5) {\n        col = 1. - col*.5;\n    }\n    */\n    \n \n    \n    // Cell vertices and vertex ID.\n    vec2[3] v, vID;\n    //vec2 ctr = vec2(0);\n\n    \n    if(tri>=.5){\n        vID = vec2[3](vertID[0], vertID[2], vertID[1]);\n    \tv = vec2[3](vert[0], vert[2], vert[1]);\n        //ctr = (v[0] + v[1] + v[2])/3.;\n    }\n    else {\n        vID = vec2[3](vertID[0], vertID[2], vertID[3]);\n        v = vec2[3](vert[0], vert[2], vert[3]); \n        //ctr = (v[0] + v[1] + v[2])/3.;\n    }\n    \n      \n    // Shadow vertices -- They need to be handled seperately... Sigh! :)\n    vec2[3] vSh, vIDSh;\n    \n    if(triSh>=.5){\n        vIDSh = vec2[3](vertID[0], vertID[2], vertID[1]);\n    \tvSh = vec2[3](vert[0], vert[2], vert[1]);\n    }\n    else {\n        vIDSh = vec2[3](vertID[0], vertID[2], vertID[3]);\n        vSh = vec2[3](vert[0], vert[2], vert[3]);\n    }    \n    \n    \n     \n\n    // Assigned face normals, colors, and pattern.\n    vec3 vN[3] = vec3[3](vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n    vec3 vCol[3] = vec3[3](vec3(.5), vec3(1), vec3(.2));\n    vec3 aR = vec3(-3.14159/3., 0, 3.14159/3.);\n    vec3 vPat = vec3(1);\n    \n    /*\n    // Cross hatching pattern, depending on face orientation -- Not used here.\n    for(int i = 0; i<3; i++){\n        // The cross hatching pattern on each face. Oriented to match the face.\n        vec2 qUV = rot2(aR[i])*p;\n        float freq = 30.;\n        float dir = tri<.5? -1. : 1.; \n        \n        if(i==2) dir = 0.;\n\n        float pat = abs(fract(qUV.y*freq + dir*.25) - .5)*2.;\n        pat = min(pat, abs(fract(qUV.x*freq + dir*.5) - .5)*2.);\n        //pat = smoothstep(0., sf*freq*2., pat - .2);\n        // Applying the hatch pattern to each line.\n        vPat[i] = 1.;;pat*.4 + .75;\n        \n        //if(i==2) vCol[i] *= 4.;\n       \n    }\n    */\n    \n    /*\n    // Swapping face normals.\n    swap(vN[0], vN[1]);\n    swap(vCol[0], vCol[1]); \n    swap(vPat[0], vPat[1]);\n    //swap(vCol[1], vCol[2]);\n    \n    // Face normals, colors, etc, face in different directions for opposing grid\n    // triangles... It can get confusing, but that's triangle grids for you. :)\n     if(tri<.5) {\n        swap(vN[0], vN[1]);\n        swap(vCol[0], vCol[1]);\n        swap(vPat[0], vPat[1]);\n    } \n    */\n    \n    // Does the same as above, but only for this particular examples.\n    if(tri>.5) {\n        swap(vN[0], vN[1]);\n        swap(vCol[0], vCol[1]);\n        swap(vPat[0], vPat[1]);\n    }\n     \n    // Background triangle cell lines.\n    for(int i = 0; i<3; i++){\n         float lnBord = lBox(p, v[i], v[(i + 1)%3], .00625);\n         col = mix(col, vec3(0), (1. - smoothstep(0., sf, lnBord)));\n     \n    }   \n    \n   \n    \n    float oLn = 1e5;\n    float ln = 1e5, ln2 = 1e5;\n    \n    // Main block width.\n    float hexW = scale*.8660254/2.; //(.8660254*3.);//\n \n    // Middle block width.\n    float mBW = hexW/6.;\n    \n    // Joiner line width and edge width.\n    #ifdef ONE_JOIN\n    const float lw = .8660254/8.; \n    #else\n    const float lw = .8660254/12.; \n    #endif\n    const float ew = .02;\n    \n    #ifdef ONE_JOIN\n    float ndg = hexW/((3. + lw)*.8660254);\n    #else\n    float ndg = hexW/((5. + lw)*.8660254);\n    #endif\n    \n    \n    // Drop shadow distance.\n    float gSh = 1e5;\n    \n    \n    // Render the drop shadows.\n    for(int i = min(0, iFrame); i<3; i++){\n        \n        // Random edge variable.\n        float rndI = hash21(idSh + mix(vIDSh[i], vIDSh[(i + 1)%3], .5));\n\n        // Edge tangent vectors.\n        vec2 tgnt0Sh = normalize(vSh[i] - vSh[(i + 1)%3]);\n        vec2 tgnt1Sh = normalize(vSh[(i + 1)%3] - vSh[(i + 2)%3]);\n        vec2 tgnt2Sh = normalize(vSh[(i + 2)%3] - vSh[(i + 0)%3]);\n        \n         // Central join line vertices.        \n        vec2[4] qvSh = vec2[4](vSh[i] - tgnt0Sh*ndg, vSh[(i + 1)%3] + tgnt0Sh*ndg, \n                             vSh[(i + 1)%3] + tgnt0Sh*ndg + tgnt2Sh*lw, vSh[i] - tgnt0Sh*ndg + tgnt2Sh*lw);\n        \n        // Edge join line vertices.\n        vec2[4] qvBSh = vec2[4](v[i] - tgnt0Sh*ndg, v[(i + 1)%3] + tgnt0Sh*ndg, \n                            v[(i + 1)%3] + tgnt0Sh*ndg + tgnt1Sh*lw, v[i] - tgnt0Sh*ndg + tgnt1Sh*lw);\n        \n        // Central join line.\n        ln = sdPoly4(pSh, qvSh);\n        \n        // Outside joins line - Top.\n        float ln2Offs = hexW/3.;\n        float ln2 = sdPoly4(pSh - tgnt2Sh*ln2Offs, qvBSh);///////\n        // Outside joins line - Side.\n        float ln2B = sdPoly4(pSh - tgnt2Sh*ln2Offs, qvBSh);//////\n        \n        // If more than one join, join the line shadows.\n        #ifndef ONE_JOIN\n        ln = min(ln, min(ln2, ln2B));\n        #endif\n        \n        // Shadow main block vertices.\n        qvSh = vec2[4](vSh[i], vSh[i] + tgnt2Sh*hexW, \n                    vSh[i] + tgnt2Sh*hexW + tgnt1Sh*hexW, vSh[i] + tgnt1Sh*hexW);\n        \n        // Main block.\n        float bl = sdPoly4(pSh, qvSh);\n        \n        // Main block T-Joins -- Shadow.\n        #ifdef TJOINS\n        // T - intersection.\n        //if((i==1 && triSh>.5)|| (i==2 && triSh<.5)){// \n            vec2 ap = abs(pSh - vSh[i] + tgnt0Sh*.7);\n            float blN = max(ap.y*.8660254 + ap.x*.5, ap.x) - hexW*.8660254;\n            bl = max(bl, -blN);\n        //}\n        #endif  \n       \n        // Middle block.\n        float blockDist = (1. - hexW/length(vSh[i] - vSh[(i + 1)%3]))/2.;// + mBW;\n        vec2 eM = mix(vSh[i], vSh[(i + 1)%3], blockDist);\n        blockDist *= length(vSh[i] - vSh[(i + 1)%3]);\n        float hexW2 = hexW;//*.85;\n        \n        // Middle block vertices.\n        qvSh = vec2[4](vSh[i], vSh[i] + tgnt2Sh*hexW2, \n                     vSh[i] + tgnt2Sh*hexW2 + tgnt1Sh*hexW2, vSh[i] + tgnt1Sh*hexW2);\n        \n        // Middle block face.\n        float bl2B = sdPoly4(pSh + tgnt0Sh*(blockDist + mBW), qvSh);\n        \n      \n        // Middle block edge vertices.\n        qvSh = vec2[4](eM - tgnt0Sh*mBW, eM + tgnt0Sh*mBW, \n                     eM + tgnt0Sh*mBW + tgnt2Sh*hexW2, eM - tgnt0Sh*mBW + tgnt2Sh*hexW2);\n        \n        // Middle block edge distance.\n        float bl2 = sdPoly4(pSh, qvSh);\n        \n        // Don't show various random edge shadows.\n        if(rndI<1./2.){\n            bl2 = 1e5;\n            bl2B = 1e5;\n            ln = 1e5; \n        }\n        \n        // If we're not displaying the middle green block.\n        #ifndef MID_BLOCK\n        bl2 = bl2B = 1e5;\n        #endif\n               \n        // Accumulate all the object shadows into the generalized shadow variable.\n        gSh = min(gSh, min(min(bl, ln), min(bl2, bl2B))); \n        \n        // Dummy break to avoid unrolling... which may or may not work.\n        if(rndI>1e6) break;\n        \n        \n    }\n    \n    // Render the drop shadows.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, gSh - ew/3.))*.5);\n\n    \n    \n    // Produce the main scene.\n    \n    // Render various shapes at each of the triangle cells vertices, edges, etc.\n    for(int i = min(0, iFrame); i<3; i++){\n        \n         \n        // Unique random edge value.\n        float rndI = hash21(id + mix(vID[i], vID[(i + 1)%3], .5));\n \n        // Edge tangents.\n        vec2 tgnt0 = normalize(v[i] - v[(i + 1)%3]);\n        vec2 tgnt1 = normalize(v[(i + 1)%3] - v[(i + 2)%3]);\n        vec2 tgnt2 = normalize(v[(i + 2)%3] - v[(i + 0)%3]);\n        \n        // Normal -- Not used.\n        //vec2 n = tgnt0.yx*vec2(1, -1);\n        //if(tri<.5){  n *= -1.;  }\n         \n        \n        // Central join line vertices.\n        vec2[4] qv = vec2[4](v[i] - tgnt0*ndg, v[(i + 1)%3] + tgnt0*ndg, \n                             v[(i + 1)%3] + tgnt0*ndg + tgnt2*lw, v[i] - tgnt0*ndg + tgnt2*lw);\n        \n        // Edge join line vertices.\n        vec2[4] qvB = vec2[4](v[i] - tgnt0*ndg, v[(i + 1)%3] + tgnt0*ndg, \n                            v[(i + 1)%3] + tgnt0*ndg + tgnt1*lw, v[i] - tgnt0*ndg + tgnt1*lw);\n        \n        // Central join line.\n        ln = sdPoly4(p - tgnt0*.0, qv);\n        // Central join line - Side -- Redundant here, but included anyway.\n        float lnB = sdPoly4(p - tgnt0*.0, qvB);\n       \n        \n        // Outside joins line - Top.\n        float ln2Offs = hexW/3.;\n        ln2 = sdPoly4((p) - tgnt2*ln2Offs, qv);///////\n        // Outside joins line - Side.\n        float ln2B = sdPoly4((p) - tgnt2*ln2Offs, qvB);//////\n        \n        #ifdef ONE_JOIN\n        ln2 = ln2B = 1e5;\n        #endif\n        \n        // Save the old lines -- to deal with overlap on the last vertex. \n        if(i==0) oLn = min(min(ln, lnB), min(ln2, ln2B)); \n      \n        \n         \n        // Main block vertices.\n        qv = vec2[4](v[i], v[i] + tgnt2*hexW, \n                     v[i] + tgnt2*hexW + tgnt1*hexW, v[i] + tgnt1*hexW);\n        // Main block (The pink one).\n        float bl = sdPoly4(p, qv);\n        \n        \n        \n        // Choppin bits off the main block to create T-Joins.\n        #ifdef TJOINS\n        // T - intersection.\n        //if((i==1 && tri>.5)|| (i==2 && tri<.5)){// \n            vec2 ap2 = abs(p - v[(i + 0)%3] + tgnt0*.7);\n            float blN = max(ap2.y*.8660254 + ap2.x*.5, ap2.x) - hexW*.8660254;\n            bl = max(bl, -blN);\n        //}\n        #endif\n        \n       \n        // Middle block (The green one).\n        float blockDist = (1. - hexW/length(v[i] - v[(i + 1)%3]))/2.;// + mBW;\n        vec2 eM = mix(v[i], v[(i + 1)%3], blockDist);\n        blockDist *= length(v[i] - v[(i + 1)%3]);\n        \n        float hexW2 = hexW;//*.85;\n        // Middle block face vertices.\n        qv = vec2[4](v[i], v[i] + tgnt2*hexW2, \n                     v[i] + tgnt2*hexW2 + tgnt1*hexW2, v[i] + tgnt1*hexW2);\n        // Middle block face distance.\n        float bl2B = sdPoly4(p + tgnt0*(blockDist + mBW), qv);\n        \n        \n        float bl2BLine = sdPoly4(p + tgnt0*(blockDist + mBW) + tgnt0*ndg, qv);\n        bl2B = max(bl2B, -max(min(ln, lnB), bl2BLine));\n        float bl2BLine2 = sdPoly4(p + tgnt0*(blockDist + mBW) + tgnt0*ndg - tgnt2*ln2Offs, qv);\n        bl2B = max(bl2B, -max(min(ln2, ln2B), bl2BLine2));\n        \n     \n        \n        \n        // Middle block side vertices.\n        qv = vec2[4](eM - tgnt0*mBW, eM + tgnt0*mBW, \n                     eM + tgnt0*mBW + tgnt2*hexW2, eM - tgnt0*mBW + tgnt2*hexW2);\n        // Middle block side distance.\n        float bl2 = sdPoly4(p, qv);\n        \n        // If we're not displaying the middle green block.\n        #ifndef MID_BLOCK\n        bl2 = bl2B = 1e5;\n        #endif\n        \n        /*\n        qvB = vec2[4](eM - tgnt1*mBW, eM + tgnt1*mBW, \n                     eM + tgnt1*mBW + tgnt0*hexW, eM - tgnt1*mBW + tgnt0*hexW);\n        */  \n        \n        \n        // Overlap occurs when producing the final vertex objects, so you need\n        // to perform CSG with the previous objects... Sometimes, it's easier\n        // just doing things with conventional 3D. :)\n        if(i == 2) {\n            \n            // Next vertex block\n            vec2 ap = abs(p - v[(i + 1)%3]);\n            float blN = max(ap.y*.8660254 + ap.x*.5, ap.x) - hexW*.8660254;\n            \n            // Combine it with previous line elements.\n            blN = min(blN, oLn);\n\n            // Take the above away from the final blocks and lines so that\n            // the overlap doesn't appear... Yeah, I find 2D layering \n            // confusing too. :D\n            ln = max(ln, -blN);\n            ln2 = max(ln2, -blN);\n            lnB = max(lnB, -blN);\n            ln2B = max(ln2B, -blN);\n            bl2 = max(bl2, -blN);\n            bl2B = max(bl2B, -blN);\n \n        }  \n      \n        // Don't show random connections -- The open space kind of looks \n        // more interesting.\n        if(rndI<.5){\n            \n            ln = 1e5;\n            ln2 = 1e5;\n            lnB = 1e5;\n            ln2B = 1e5;\n            bl2 = 1e5;\n            bl2B = 1e5;\n            if(i==0) oLn = 1e5;\n        }\n        \n        \n        // Line colors.\n        vec3 lnCol = vCol[i]; // Top face line.\n        vec3 lnColB = vCol[(i + 1)%3]; // Side face line.\n        vec3 lnCol2B = vCol[(i + 1)%3]; // Side face line.\n        \n        // Block colors.\n        vec3 blCol = vCol[(i + 2)%3];\n        vec3 blColB = vCol[i];\n        \n        \n        lnCol *= vec3(.7, .85, 1)*.75;\n        blCol = min(blCol*vec3(1, .2, .4)*2.8, 1.);\n        blColB = min(blColB*vec3(1, .2, .4)*2.8, 1.);\n        \n        lnColB *= vec3(.7, .85, 1)*.7;\n        lnCol2B *= vec3(.7, .85, 1)*.7;\n    \n        \n       \n        // Main block render for this pass.\n        //float sh = max(.75 - bl/.35, 0.);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, bl - ew/3.));\n        col = mix(col, blCol*vPat[(i + 2)%3], 1. - smoothstep(0., sf, bl + ew*2./3.));    \n\n\n        // Side joiner line.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., ln2 - ew/3.))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2 - ew/3.));\n        col = mix(col, lnCol*vPat[i], 1. - smoothstep(0., sf, ln2 + ew*2./3.));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln2B - ew/3.));\n        col = mix(col, lnCol2B*vPat[(i + 1)%3], 1. - smoothstep(0., sf, ln2B + ew*2./3.));\n\n        // Central joiner line.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., ln - ew/3.))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln - ew/3.));\n        col = mix(col, lnCol, 1. - smoothstep(0., sf, ln + ew*2./3.));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, lnB - ew/3.));\n        col = mix(col, lnColB*vPat[(i + 1)%3], 1. - smoothstep(0., sf, lnB + ew*2./3.));\n\n        // Middle block.\n        //sh = max(.75 - bl2B/.35, 0.); \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, bl2B - ew/3.));\n        col = mix(col, blCol.yxz*vPat[(i + 2)%3], 1. - smoothstep(0., sf, bl2B + ew*2./3.)); \n        //sh = max(.75 - bl2/.35, 0.);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, bl2 - ew/3.));\n        col = mix(col, blColB.yxz*vPat[i], 1. - smoothstep(0., sf, bl2 + ew*2./3.)); \n\n        // Fake AO on the green block.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(ln, bl2B + .03) - ew/3.))*.25);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., max(ln2, bl2B + .03) - ew/3.))*.25);  \n        \n        // Dummy break to avoid unrolling... which may or may not work. If you think appeasing\n        // compilers instead of making code faster is stupid, you'll get no argument from me. :)\n        if(rndI>1e6) break;\n\n        \n    } \n    \n      \n    // Subtle pencil overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 q = oP*2.;\n    vec3 colP = pencil(col, q*iResolution.y/450.);\n    #if 0\n    // Just the pencil sketch. The last factor ranges from zero to one and \n    // determines the sketchiness of the rendering... Pun intended. :D\n    col = mix(dot(col, vec3(.299, .587, .114))*vec3(1), colP, .7);\n    #else\n    col = mix(col, 1. - exp(-(col*2.)*(colP + .25)), .9); \n    #endif\n    //col = mix(col, colP, .5);\n    //col = mix(min(col, colP), max(col, colP), .5); \n    \n    \n    #ifdef SHOW_CELLS\n    // Triangle cell borders.\n    float gLnBrd = 1e5;     \n    for(int i = 0; i<3; i++){\n        gLnBrd = min(gLnBrd, lBox(p, v[i], v[(i + 1)%3], .005));\n    }\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, gLnBrd - .0175)));\n    col = mix(col, vec3(1, .9, .5), (1. - smoothstep(0., sf, gLnBrd)));\n    #endif\n    \n\n    // Rough gamma correction and output.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1818, 1851, 1873, 1873, 1931], [1934, 1962, 1983, 1983, 2046], [2049, 2117, 2135, 2242, 2730], [2732, 2810, 2828, 2828, 2901], [2904, 2904, 2934, 3698, 5042], [5819, 5844, 5877, 5877, 5956], [5958, 6197, 6242, 6242, 6411], [6415, 6478, 6506, 6506, 6541], [6544, 6609, 6639, 6639, 6683], [7538, 7538, 7558, 7558, 8294]], "test": "untested"}
{"id": "WsGfWW", "name": "Nested noisy circles", "author": "AI", "description": "Move the mouse over the shape to see the effect.\nChange the variable Nshapes to have more nested circles.\nChange the color array cArray to have different colors.\nchange the constant values used in defining variable pos to experience other noise effect", "tags": ["noise", "circles", "wave", "bilinear", "generativeart", "creativecoding"], "likes": 2, "viewed": 359, "published": 3, "date": "1607088053", "time_retrieved": "2024-07-30T20:32:16.267999", "image_code": "// pseudo-random function, returns value between [0.,1.]\nfloat rand (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(31.7667,14.9876)))\n                 * 833443.123456);\n}\n\n//bilinear value noise function\nfloat bilinearNoise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // four corners of a 2D square\n    float f00 = rand(i);\n    float f10 = rand(i + vec2(1.0, 0.0));\n    float f01 = rand(i + vec2(0.0, 1.0));\n    float f11 = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.,1.,(1.-f));\n\treturn u.x*u.y*f00+(1.-u.x)*u.y*f10+\n    u.x*(1.-u.y)*f01+(1.-u.x)*(1.-u.y)*f11;    \n}\n\nfloat circle(in vec2 st, in float noise,in float radius){\n    float noiseStep=.05; //noise step size\n    float d=length(st+noiseStep*noise-vec2(.5));\n    return smoothstep(radius,radius-.01,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cArray[3]; //array holding colors\n    cArray[0]=vec3(1.,0.,0.);\n    cArray[1]=vec3(0.,1.,0.);\n\tcArray[2]=vec3(0.,0.,1.);\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t\n    float Nshapes=1.; // number of shapes\n    vec2 f=fract(uv*Nshapes);\n    vec2 pos = vec2(f*5.0)+2.*float(iMouse)/iResolution.xy;\n    // Using the bilinear value noise\n    float noise = bilinearNoise(pos+vec2(cos(iTime),sin(iTime)));\n\tfloat gray=0.;\n    vec3 color=vec3(0.);\n    for(float i=0.;i<12.;++i){\n        gray=circle(f,noise,.45-.04*i)-circle(f,noise,.43-.04*i);\n        color+=gray*cArray[int(mod(i,3.))];\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 57, 82, 82, 200], [202, 234, 268, 268, 631], [633, 633, 690, 690, 828], [830, 830, 887, 887, 1522]], "test": "untested"}
{"id": "wdGfW1", "name": "Ocean Sunrise", "author": "Dragonpeak", "description": "A sun rising over an ocean. an experiment with reflection and refraction.", "tags": ["raymarching", "noise", "sea", "ocean", "sunrise"], "likes": 4, "viewed": 432, "published": 3, "date": "1607080748", "time_retrieved": "2024-07-30T20:32:17.267327", "image_code": "const float FAR = 50.;\nvec3 CAMERA_POS = vec3(-0.4, 0.87, .3);\nvec3 CAMERA_LOOK = vec3(0.,-0.3,0.2);\nvec2 WIND = vec2(0.2, -0.1);\nconst float EPS = 0.002;\nconst int OCEAN_OCT = 12;\nconst int CLOUD_OCT = 6;\nconst vec3 SUN = normalize(vec3(0.3, -0.4, .01));\nconst vec3 SUN_C = vec3(0.8, 0.6, 0.4)*3.7;\n\nvec3 ray_direction(float fov, vec2 size, vec2 coord) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec2 xy = coord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 view_matrix(vec3 eye, vec3 center, vec3 up) {\n    // from https://www.shadertoy.com/view/Xtd3z7\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec2 hash( vec2 p ) // uses a texture, causes some artifacting but it is not to noticable in this shader\n{\n    return texture(iChannel0, p*0.01).xy;\n\n}\n\nfloat noise( in vec2 p )\n{\n    //from https://www.shadertoy.com/view/Msf3WH\n   \n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    //return hash(i).x;\n    return dot( n, vec3(70.0) );\n}\nfloat ocean_height(vec2 p) // ridged fbm(using abs noise)\n{\n    float sc = .15;\n    float am = .4;\n    float n = 0.;\n    for(int i = 0; i < OCEAN_OCT; i++)\n    {\n\t\tn += -abs(noise(p*sc+float(i)+WIND*iTime))*am;\n        float cs = cos(float(i)*0.3);\n\t\tfloat sn = sin(float(i)*0.3);\n        p = vec2(p.x * cs - p.y * sn, p.x * sn + p.y * cs);\n        sc *= 1.45;\n        am *= 0.6;\n    }\n\treturn n;\n}\nvec3 ocean_nrm(vec2 p)\n{\n    //from https://iquilezles.org/articles/terrainmarching\n    return normalize( vec3( ocean_height(vec2(p.x-EPS,p.y)) - ocean_height(vec2(p.x+EPS,p.y)),\n                           ocean_height(vec2(p.x,p.y-EPS)) - ocean_height(vec2(p.x,p.y+EPS)),\n                            2.0f*EPS) );\n}\nvec3 fresnel(float cosTheta, vec3 F0)\n{\n    //from https://learnopengl.com/PBR/Theory\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat cloud_d(vec3 p)// fbm for  clouds\n{\n\tvec2 cloud_p = p.xy/p.z*.4;\n    float sc = .3;\n    float am = .8;\n    float n = 0.;\n    for(int i = 0; i < OCEAN_OCT; i++)\n    {\n\t\tn += noise(cloud_p*sc+float(i)+WIND*0.5*iTime)*am;\n        float cs = cos(float(i)*0.3);\n\t\tfloat sn = sin(float(i)*0.3);\n        cloud_p = vec2(cloud_p.x * cs - cloud_p.y * sn, cloud_p.x * sn + cloud_p.y * cs);\n        sc *= 1.3;\n        am *= 0.73;\n    }\n    return n+.3;\n}\nvec3 shade_sky(vec3 p, bool c)\n{\n    p = normalize(p);\n\tvec3 col = mix(vec3(0.6, 0.6, 0.85), vec3(0.55, 0.55, 0.85), p.z)*1.4;//sky\n    col = mix(vec3(0.8, 0.5, 0.54), col, clamp(p.z+0.4, 0., 1.))*0.8;//pink band\n    float sun = dot(p, SUN);//sun dot\n    col = mix(col, SUN_C, min(max(sun-.996, 0.)*500., 1.));//sun colour\n    if(c && p.z>0.) // use clouds, lighted with effectivly single step ray march\n    {\n        float cl = cloud_d(p);//clouds\n        float cl2 = cloud_d(p-SUN*0.3);//clouds offset\n        float l = cl-cl2;//clouds lighting estimate\n\n        vec3 ccol = mix(vec3(0.65, 0.7, 0.7)*SUN_C, vec3(0.4), l-min(max(sun-.8, 0.)*11., 1.))*0.6;//cloud col\n\n        col = mix(col, ccol, clamp(cl, 0., 1.)*0.6);\n    }\n    //col = vec3(l);\n\treturn col*vec3(0.9, 1.,1.);\n}\n\n\nvec3 shade_ocean(vec3 p, vec3 dir, float h)\n{\n    \n    \n    vec3 col = vec3(0.2, 0.2, 0.7)*0.4;//base_col\n    vec3 nrm = ocean_nrm(p.xy);\n    vec3 refr = refract(dir, nrm, 1.03);//refraction ray\n    float fr = fresnel(dot(dir, nrm), vec3(1.055)).x;//fresnel\n    vec3 ref = reflect(nrm, dir);//reflection ray\n    vec3 rrc = mix(col, shade_sky(p+refr, false)*0.9, clamp(refr.z+0.8, 0., 1.));//refraction ray, uses sky or if low the base col\n    vec3 rc = shade_sky(p+ref, true)*0.96; // reflection col, using sky\n    col = mix(rrc, rc, fr);//mix reflection and refraction by fresnel\n    float f = min(max(h+.16, 0.)*20., 1.)*nrm.z*0.6;//foam on highest points\n    vec3 fc = vec3(.75)+SUN_C*clamp(dot(SUN, nrm), 0., 1.); //foam col, simple diffuse shading\n    col = mix(col, fc, f);\n\treturn col*vec3(1., 0.9, 0.9);\n}\n\n\nvec2 march_ocean(vec3 p, vec3 d)\n{\n    float dep = 0.;\n    float h = 0.;\n    float eps = EPS;\n    while(dep < FAR)\n    {\n        vec3 pos = p + d * dep;\n        h = ocean_height(pos.xy);\n\t\tfloat dist = pos.z-h;\n        if(dist < eps)\n        {\n\t\t\treturn vec2(dep, h);\n        }\n        eps *= 1.15;//relax eps after each step\n\t\tdep += dist;\n        \n    }\n    return vec2(FAR, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CAMERA_POS.z += sin(iTime*0.1)*0.4;\n    CAMERA_LOOK.z += sin(iTime*0.1)*0.1;//camera anim\n    vec3 local_dir = ray_direction(85., iResolution.xy, fragCoord);\n    \n    mat4 view = view_matrix(CAMERA_POS, CAMERA_LOOK, vec3(0.,0.,1.));\n    vec3 dir = (view * vec4(local_dir, 0.)).xyz;\n    vec2 o = march_ocean(CAMERA_POS, dir);\n    float dep = o.x;\n    vec3 pos = CAMERA_POS + dir * dep;\n    \n    vec3 col = shade_sky(dir, false); //sky w/out clouds, for mist \n    if(dep < FAR)\n    {\n\t\tcol = mix(shade_ocean(pos, dir, o.y), col, dep/FAR);\n    }\n    else\n    {\n\t\tcol = shade_sky(dir, true);//sky w, clouds for view\n    }\n    // Output to screen\n \t//col = vec3(noise(fragCoord*0.06));\n    col *= vec3(1.19, .9, 1.14)*0.7;//colour correct\n    fragColor = vec4(pow(col, vec3(1./2.1)),1.0);//gamma and out\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 355, 405, 525], [527, 527, 577, 627, 853], [855, 855, 961, 961, 1006], [1008, 1008, 1034, 1083, 1590], [1591, 1591, 1650, 1650, 1989], [1990, 1990, 2014, 2073, 2305], [2306, 2306, 2345, 2391, 2448], [2449, 2449, 2490, 2490, 2897], [2898, 2898, 2930, 2930, 3678], [3681, 3681, 3726, 3726, 4494], [4497, 4497, 4531, 4531, 4880], [4882, 4882, 4939, 4939, 5744]], "test": "untested"}
{"id": "wdKBW1", "name": "basic 2d city-v2", "author": "jorge2017a1", "description": "basic 2d city-v2", "tags": ["basic2dcityv2"], "likes": 2, "viewed": 284, "published": 3, "date": "1607050692", "time_retrieved": "2024-07-30T20:32:18.138997", "image_code": "//por jorge2017a1-----jorge flores p.  //03-dic-2020\n#define saturate(x) clamp(x, 0.0, 1.0) \nconst float LineWidth=0.01;\n\nfloat oU( float d1, float d2 ) { return  min(d1,d2); }\nfloat oS( float d1, float d2 ) { return max(-d1,d2); }\nfloat oI( float d1, float d2 ) { return max(d1,d2); }\n\n\n\nvec2 oU2( vec2 d1, vec2 d2 ) \n{\n\n    if (d1.x<d2.x)\n       return d1; \t\n    else\n       return d2;\n}\n\nvec2 oS2( vec2 d1, vec2 d2 )\n{\n\n    if  (-d1.x<d2.x)\n        return d1;\n    else\n        return d2;\n}\n\nvec2 oI2( vec2 d1, vec2 d2 ) \n{\n\n    if (d1.x>d2.x)\n       \treturn d1;\n    else\n        return d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2) {\n\treturn vec2(max(-d2.x, d1.x), 2.0);\n}\n\n\n\nvec2 opRepvec2( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return  q ;\n}\n\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nfloat rand(float x)\n{\n\treturn fract(sin(x)*1276818.27865);\n}\n\nfloat rand2(vec2 x)\n{\n\treturn fract(sin(dot(x ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 nubes(vec2 p)\n{    \n    vec2 centro=vec2(0.0,0.0);\n    \n    float c1a= circ(p-vec2(0.0,0.05), 0.105);\n    float c2a= circ(p-vec2(0.15,0.02), 0.065);\n    float c3a= circ(p-vec2(-0.15,0.02), 0.065);\n    float b1a=sdBox(p-vec2(0.0,-0.05), vec2(0.22,0.045 ) );\n    \n    \n    float c1b= circ(p-vec2(0.0,0.05), 0.108);\n    float c2b= circ(p-vec2(0.15,0.02), 0.068);\n    float c3b= circ(p-vec2(-0.15,0.02), 0.068);\n    float b1b=sdBox(p-vec2(0.0,-0.05), vec2(0.22,0.047 ) );\n    \n    \n    \n    float resa=oU(c1a, c2a);\n    resa=oU(resa, c3a);\n    \n    float resb=oU(c1b, c2b);\n    resb=oU(resb, c3b);\n\n    resa=oS(resa,resb);\n \n     resa=oS(  b1a,resa );\n     resb=oS(  b1b,resb );\n \n    vec2 res2= oU2(  vec2(resb,1.0) ,vec2(resa,0.0));\n    \n    \n\treturn res2;\n    \n}\n\nvec2 Ciudad(vec2 p)\n{\n    \n    float b1= sdBox( p-vec2(0.0),vec2(0.08,0.2) );\n    float b2= sdBox( p-vec2(0.2,0.1),vec2(0.08,0.32) );\n    float b3= sdBox( p-vec2(0.5,0.2),vec2(0.18,0.4) );\n    \n    //ventanas\n    float b4= sdBox( p-vec2(0.0,0.0),vec2(0.06,0.05) );\n    float b5= sdBox( p-vec2(0.0,-0.12),vec2(0.06,0.05) );\n    float b6= sdBox( p-vec2(0.0, 0.12),vec2(0.06,0.05) );\n    \n    b1=oS(b4, b1);\n    b1=oS(b5, b1);\n    b1=oS(b6, b1);\n    \n    vec2 res= vec2(9999.0,0.0);\n    \n    \n    res=oU2(res, vec2(b1,3.0));\n    res=oU2(res, vec2(b2,6.0));\n    res=oU2(res, vec2(b3,5.0));\n    \n    //ventana\n    res=oU2(res, vec2(b4,2.0));\n    res=oU2(res, vec2(b5,2.0));\n    res=oU2(res, vec2(b6,2.0));\n   \n    return res;\n}    \n    \n\nvec2 edificio(vec2 p)\n{\n   \tfloat b1= sdBox( p-vec2(0.0),vec2(0.18,0.3) );\n\n    vec2 pp= opRepvec2(p, vec2(0.25,0.18) );\n\n    pp.x=max(p.x,-0.5);\n\n    \n    float b4= sdBox( pp,vec2(0.08,0.05) );\n\n    b4=oS(b4,b1);\n    \n    vec2 res= vec2(9999.0,0.0);\n\n    res=oU2(res, vec2(b4,6.0));\n    \n    return res;\n    \n}   \n\nvec2 edificioMedida(vec2 p, vec2 med)\n{\n\n   \tfloat b1= sdBox( p-vec2(0.0),med );\n    \n    vec2 pp= opRepvec2(p, vec2(0.25,0.18) );\n    pp.x=max(p.x,-0.5);\n    float b4= sdBox( pp,vec2(0.08,0.05) );\n    \n    b4=oS(b4,b1);\n    \n    vec2 res= vec2(9999.0,0.0);\n\n    res=oU2(res, vec2(b4,6.0));\n    \n    return res;\n    \n}   \n\n\nvec2 vehiculo(vec2 p)\n{    \n    float b1= sdBox(p-vec2(0.0,0.0), vec2(0.22,0.08) );\n    float c1= circ(p-vec2(-0.1,-0.1), 0.05);\n    float c2= circ(p-vec2(0.1,-0.1), 0.05);\n    \n    vec2 res= vec2(9999.0,0.0);\n    b1=oS(c1,b1);\n    b1=oS(c2,b1);\n    \n    res=oU2(res, vec2(b1,1.0));\n    res=oU2(res, vec2(c1,2.0));\n    res=oU2(res, vec2(c2,2.0));\n    \n    return res;\n}    \n\n\nvec2 estrella(vec2 p)\n{\n    vec2 res= vec2(9999.0,0.0);\n    float sstar1= sdStar5( p-vec2(-0.5,0.4),0.25+0.20*sin(iTime), 0.43);\n    float sstar2= sdStar5( p-vec2(-0.5,0.4),0.25+0.20*sin(iTime), 0.3);\n    \n    sstar1=oS(sstar2,sstar1);\n\n    res=oU2(res, vec2(sstar1,0));\n    res=oU2(res, vec2(sstar2,19));\n    \n    return res;    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col=vec3(0.2,0.478,.13);\n   \n    \n    \n\n    vec2 p = (2.*fragCoord-R)/R.y;\n    \n    vec2 ap= abs(p);\n    p.y-=.25;\n    \n    float px=-2.0+mod(iTime*0.8, 12.0 );\n    vec2 mover=vec2(px,0.0);\n    \n    float cielo=box( p-vec2( 0.0,0.15), vec2(4.0,0.6));\n    \n  \tfloat sdb6=box( p-vec2( 0.0,-0.45), vec2(2.9,0.016));\n    \n    //nubes\n    vec2 n1= nubes(p-mover);\n    vec2 n2= nubes(p-mover+vec2(0.30,0.125));\n    vec2 n3= nubes(p-mover+vec2(1.20,-0.5));\n    vec2 n4= nubes(p-mover+vec2(2.20,-0.15));\n    vec2 n5= nubes(p-mover+vec2(3.80,-0.25));\n    vec2 n6= nubes(p-mover+vec2(4.80,-0.05));\n    vec2 n7= nubes(p-mover+vec2(6.80,0.05));\n    \n    \n    vec2 c1= Ciudad(p-vec2(0.0,-0.22));\n    \n    px=-2.0+mod(iTime*0.5, 5.0 );\n    vec2 mover2=vec2(px,0.0);\n    vec2 auto1= vehiculo(p-vec2(0.0,-0.8)+mover2);\n    \n    \n    \n    vec2 sstar1 = estrella( p);\n    \n    \n    vec2 ed1= edificio(p-vec2(-0.4,-0.120));\n    vec2 ed2= edificio(p-vec2(-0.8,-0.120));\n    vec2 ed3= edificioMedida( p-vec2(-1.5,-0.10), vec2(0.18,0.43));\n    vec2 ed4= edificioMedida( p-vec2(1.5,-0.10), vec2(0.28,0.6));\n    \n        \n    \n    cielo = SS(cielo);\n    sdb6 = SS(sdb6);\n    \n    n1.x = SS(n1.x); ///nube\n    n2.x = SS(n2.x);\n    n3.x = SS(n3.x);\n    n4.x = SS(n4.x);\n    n5.x = SS(n5.x);\n    n6.x = SS(n6.x);\n    n7.x = SS(n7.x);\n\n    \n    c1.x = SS(c1.x);\n    \n    \n    \n    sstar1.x = SS(sstar1.x);\n    ed1.x=SS(ed1.x);\n    ed2.x=SS(ed2.x);\n    ed3.x=SS(ed3.x);\n    ed4.x=SS(ed4.x);\n    \n    \n    auto1.x= SS(auto1.x);\n    vec3 colAuto=getColor(int(auto1.y));\n    vec3 colEdificio1=getColor(int(c1.y));\n    \n    \n    \n    vec3 colNube1=getColor(int(n1.y));\n    vec3 colNube2=getColor(int(n2.y));\n    vec3 colNube3=getColor(int(n3.y));\n    vec3 colNube4=getColor(int(n4.y));\n    vec3 colNube5=getColor(int(n5.y));\n    vec3 colNube6=getColor(int(n6.y));\n    vec3 colNube7=getColor(int(n7.y));\n    \n    vec3 colestrella=getColor(int(sstar1.y));\n    vec3 coled1=getColor(int(ed1.y));\n    vec3 coled2=getColor(int(ed1.y+1.0));\n    vec3 coled3=getColor(int(ed1.y+2.0));\n    vec3 coled4=getColor(int(ed1.y+4.0));\n    \n       \n    col = mix(col, vec3(0.3,0.5,1.0), cielo);\n    col = mix(col, colEdificio1, c1.x);\n    col = mix(col, colestrella, sstar1.x);\n    \n    col = mix(col, vec3(0.3), sdb6);\n    \n    col = mix(col, colNube1, n1.x);\n    col = mix(col, colNube2, n2.x);\n    col = mix(col, colNube3, n3.x);\n    col = mix(col, colNube4, n4.x);\n    col = mix(col, colNube5, n5.x);\n    col = mix(col, colNube6, n6.x);\n    col = mix(col, colNube7, n7.x);\n\t\n    \n    col = mix(col, coled1, ed1.x);\n    col = mix(col, coled2, ed2.x);\n    col = mix(col, coled3, ed3.x);\n    col = mix(col, coled4, ed4.x);\n    \n    col = mix(col, colAuto, auto1.x);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n   // if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circ(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 154, 154, 176], [177, 177, 209, 209, 231], [232, 232, 264, 264, 285], [289, 289, 320, 320, 389], [391, 391, 421, 421, 492], [494, 494, 525, 525, 594], [596, 596, 624, 624, 663], [667, 667, 707, 707, 760], [763, 763, 802, 802, 846], [848, 848, 869, 869, 908], [910, 910, 931, 931, 996], [999, 999, 1019, 1019, 1765], [1767, 1767, 1788, 1788, 2489], [2500, 2500, 2523, 2523, 2811], [2816, 2816, 2855, 2855, 3134], [3140, 3140, 3163, 3163, 3509], [3516, 3516, 3539, 3539, 3853], [3856, 3856, 3913, 3963, 6792]], "test": "untested"}
{"id": "tdKBW1", "name": "Metallic flowers", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/tlBcDh]\"Alien megacity.\"[/url]", "tags": ["fractal", "flower"], "likes": 2, "viewed": 326, "published": 3, "date": "1607047516", "time_retrieved": "2024-07-30T20:32:19.027620", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    vec3 eye = vec3(-35.0+sin(iTime/2.0)/2.0,1.0+cos(iTime/2.0)/2.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0,\nMAX_DIST = 1000.0,\nEPSILON = 0.001,\nsize = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n \nfloat vines(vec3 p,float size1){\n    //p /= 2.0;\n    return size-length((sin(p/vec3(length(sin(p)))))*size1)/1.8;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*120.0;\n\n    float\n        size1 = 1100.0,\n    \tresult = vines(p,size1),\n    \ti = multiplier;\n    for(int j = 0; j < iterations; j++){\n        //p = sin(p/i)*i-sin(p*i)/i;\n        result = min(result,vines(p,size1)/(i));\n        i *= multiplier;\n    }\n    return result*scale;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 165], [167, 588, 679, 679, 1000], [1015, 1269, 1334, 1334, 1466], [1468, 1557, 1586, 1586, 1896], [1898, 2390, 2530, 2530, 3125], [3127, 3497, 3582, 3582, 3929], [3931, 4258, 4307, 4342, 4473], [4475, 4475, 4532, 4532, 5573]], "test": "untested"}
{"id": "3sGBWz", "name": "texture rays", "author": "elenzil", "description": "this works pretty well with WebCam.", "tags": ["rays", "textures", "bleebblab"], "likes": 3, "viewed": 346, "published": 3, "date": "1607044469", "time_retrieved": "2024-07-30T20:32:19.873359", "image_code": "const float PI = 3.14159265359;\nfloat gMyTime  = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 XY )\n{\n    gMyTime = (iTime * PI * 2.0);\n    \n    vec2 cp = iResolution.xy * (vec2(cos(gMyTime * 0.1), sin(gMyTime * 0.13)) * 0.14 + 0.5);\n    \n    if (length(iMouse.xy) > 50.0) {\n        cp = iMouse.xy;\n    }\n    \n    \n    const float contribBias =  20.0;\n    const float steps       =  50.0;\n    \n    vec2  p        = XY;\n    vec2  vStep    = (cp - XY) / steps;\n    vec2  vStepp   = normalize(vec2(-vStep.y, vStep.x));\n    vec2  uStepp   = vStepp / vec2(iResolution.x, iResolution.y);\n    float stepDist = length(vStep);\n    vec3  accum    = vec3(0.0);\n    float total    = 0.0;\n    float dist     = 0.0;\n    for (float step = 0.0; step < steps; step += 1.0) {\n        float contrib  = contribBias / (contribBias + dist);\n\t    vec2 uv = p/vec2(iResolution.x, iResolution.y);\n        \n        float spreadMax = min(8.0, dist * 0.004);\n        for (float spread = -spreadMax; spread <= spreadMax; spread += 1.0) {\n            vec2 uv2 = uv + spread * uStepp * 11.3;\n            if (sin(gMyTime * 0.1) < 0.0) {                \n            \taccum     += contrib * textureLod(iChannel0, uv2, min(2.0, dist * 0.1)).rgb;\n            }\n            else {\n            \taccum     += contrib * textureLod(iChannel1, uv2, min(2.0, dist * 0.1)).rgb;\n            }\n            total         += contrib;\n        }\n        p             += vStep;\n        dist          += stepDist;\n    }\n    \n    accum /= total;\n    \n\n    fragColor = vec4(accum, 1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// just an old raymarcher as image-generation.\n\n\n/*\nfirst shader w/ materials.\nknown issues:\n  * no AA\n  * very limited reflection\n  * shading model not so great\n  * scintillating edges\n*/\n\n// common stuff\nconst vec3  fv3_1   = vec3(1.0, 1.0, 1.0);\nconst vec3  fv3_0   = vec3(0.0, 0.0, 0.0);\nconst vec3  fv3_x   = vec3(1.0, 0.0, 0.0);\nconst vec3  fv3_y   = vec3(0.0, 1.0, 0.0);\nconst vec3  fv3_z   = vec3(0.0, 0.0, 1.0);\nconst vec2  fv2_1   = vec2(1.0, 1.0);\nconst vec2  fv2_0   = vec2(0.0, 0.0);\nconst vec2  fv2_x   = vec2(1.0, 0.0);\nconst vec2  fv2_y   = vec2(0.0, 1.0);\nconst float PI      = 3.14159265359;\nconst float TAU     = PI * 2.0;\nconst float MAX_FLOAT = intBitsToFloat(0x7f7fffff);\n\n\n// less common\nconst float rmMaxSteps = 350.0;\nconst float rmMaxDist  = 150.0;\nconst float rmEpsilon  =   0.01;\nconst float grEpsilon  =   0.001;\nconst float nrmBackoff =   grEpsilon * 1.0;\n\nconst float shadowFac  = 0.2;           // 1.0 for no shadows, 0.0 for black.\nconst vec3  clr_fog   = vec3(0.0, 0.03, 0.05);\n\n#define SHOW_PIXEL_COST 0\n\nfloat gT = 0.0;\n\n#define mat_no_hit -1\n#define mat_0       0\n#define mat_1       1\n#define mat_2       2\n#define mat_3       3\n#define mat_4       4\n\n#define clr_cyn vec3(0.5, 0.8, 0.8)\n#define clr_er1 vec3(1e3, 0e0, 0e0)\n#define clr_er2 vec3(1e3, 0e0, 1e3)\n#define clr_er3 vec3(0e0, 0e0, 1e3)\n#define clr_grn vec3(0.1, 0.9, 0.3)\n#define clr_mag vec3(0.7, 0.0, 0.1)\n#define clr_pnk vec3(1.0, 0.5, 0.7)\n#define clr_red vec3(0.4, 0.2, 0.2)\n#define clr_wht vec3(0.8, 0.8, 0.8)\n#define clr_yel vec3(1.0, 1.0, 0.0)\n\nstruct SurfaceHit {\n    int  material;\n    vec3 position;\n};\n\n// from IQ's https://www.shadertoy.com/view/XlcSz2\nfloat checkers2D(vec2 p)\n{\n    vec2 ddx = dFdx(p); \n    vec2 ddy = dFdy(p); \n\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 albedo(in SurfaceHit sh) {\n    if (false) {\n        // noop\n    }\n    else if (sh.material == mat_no_hit) {\n        return clr_fog;\n    }\n    else if (sh.material == mat_0) {\n        return clr_pnk * (0.7 + 0.3 * checkers2D(vec2(sh.position.y - gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_1) {\n        return clr_grn * (0.7 + 0.3 * checkers2D(vec2(sh.position.y - gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_2) {\n        float ch = checkers2D(sh.position.xz * 0.1);\n        float w = 1.0/(2.0 + dot(sh.position.xz, sh.position.xz));\n        vec3 c1 = mix(clr_yel, clr_wht, smoothstep(0.5 - w, 0.5 + w, 2.0 * abs(-0.5 + fract(-gT * (ch - 0.5) * 2.0 + 16.0 * (atan(sh.position.x, sh.position.z) / TAU)))));\n        vec3 c2 = mix(clr_red, clr_cyn, ch);\n        return mix(c1, c2, clamp(length(sh.position.xz) / (rmMaxDist * 0.5) + 0.2, 0.0, 1.0));\n    }\n    else if (sh.material == mat_3) {\n        return clr_mag * (0.7 + 0.3 * checkers2D(vec2(sh.position.y + gT * 3.0, 0.1) * 1.0));\n    }\n    else if (sh.material == mat_4) {\n        return clr_wht;\n    }\n    else {\n        return clr_er1;\n    }\n}\n\n\n// based on https://www.shadertoy.com/view/Wtf3Df\nvec3 getRayDirection(in vec3 ro, in vec3 lookAt, in vec2 uv, float zoom) {\n  vec3 ol       = normalize(lookAt - ro);\n  vec3 screenRt = cross(ol      , fv3_y); // world Up\n  vec3 screenUp = cross(screenRt, ol   );\n  vec3 rd       = normalize(uv.x * screenRt + uv.y * screenUp + ol * zoom);\n  return rd;\n}\n\nfloat sdfSphere(in vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat sdfCylinderX(in vec3 p, float radius) {\n  return length(p.yz) - radius;\n}\n\nfloat sdfFloor(in vec3 p, float height) {\n  float lxz = length(p.xz);\n  float floorRipple = sin(sqrt(lxz) * 2.0 + mod(gT, 25.0) * -25.0) * 0.4;\n  floorRipple *= 7.0 * smoothstep(0.0, 20.0, lxz) / (1.0 + lxz * 0.05);\n  return p.y - height + floorRipple;\n}\n\n// todo: how to get the material without all this ternaries ?\n//       we only care about material during shading, not when marching or getting normal.\n//       idea: two SDF fn's, only one of which has the material logic.\n//             this could be made even uglier by using #def's.\n//             #def SDF_FULL(all the things) {\\...\\...\\}\n//             #def INCLUDE_MATERIAL false\n//             #def SDF_NO_MAT(p) SDF_FULL\n//             #def INCLUDE_MATERIAL true\n//             etc. ugh.\nfloat sdf(in vec3 p, out int material) {\n  const float sphRad = 5.0;\n\n  float d = MAX_FLOAT;\n  float D;\n  int   m = mat_no_hit;\n\n  D = sdfSphere(p,  sphRad);\n  d = min(d, D);\n  m = d == D ? mat_0 : m;\n\n  const float offset = 1.1;\n  vec3 pax = vec3(abs(p.x) -offset * sphRad, p.y, p.z);\n  D = sdfSphere(pax,  sphRad);\n  d = max(d, -D);\n  m = d == -D ? mat_1 : m;\n\n  pax.x += sphRad * 0.65;\n  pax.x *= -1.0;\n  D = pax.x;\n  d = max(d, -D);\n\n  D = sdfCylinderX(p, sphRad * 0.5);\n  d = max(d, -D);\n  m = d == -D ? mat_3 : m;\n\n  D = sdfSphere(p,  sphRad * 0.2  );\n  d = min(d, D);\n  m = d == D ? mat_4 : m;\n\n  // lower the floor slightly to avoid some shadow tearing.\n  D = sdfFloor (vec3(p.xz, p.y + 0.2).xzy, -sphRad);\n  d = min(d, D);\n  m = d == D ? mat_2 : m;\n\n  material = m;\n\n  return d;\n}\n\n// from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions\nvec3 estimateNormal(vec3 p) {\n  const float e = grEpsilon;\n  int unused;\n  return normalize(vec3(\n    sdf(vec3(p.x + e, p.y    , p.z    ), unused) - sdf(vec3(p.x - e, p.y    , p.z    ), unused),\n    sdf(vec3(p.x    , p.y + e, p.z    ), unused) - sdf(vec3(p.x    , p.y - e, p.z    ), unused),\n    sdf(vec3(p.x    , p.y    , p.z + e), unused) - sdf(vec3(p.x    , p.y    , p.z - e), unused)\n  ));\n}\n\n\nSurfaceHit march(in vec3 p, in vec3 rd, out float numSteps) {\n  SurfaceHit sh; // = SurfaceHit(mat_no_hit, vec3(0.0));\n\n  float distTotal = 0.0;\n  for (numSteps = 0.0; (numSteps < rmMaxSteps) && (distTotal <= rmMaxDist); ++numSteps) {\n    int mat;\n    float d = sdf(p, mat);\n    if (d < rmEpsilon) {\n      sh.material = mat;          \n      sh.position = p;\n      return sh;\n    }\n    p += rd * d;\n    distTotal += d;\n  }\n  sh.material = mat_no_hit;\n  sh.position = p;\n  return sh;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    RGBA.a   = 1.0;\n\n    float smallWay = min(iResolution.x, iResolution.y);\n    vec2  uv = (XY * 2.0 - fv2_1 * iResolution.xy)/smallWay;\n    gT  = iTime * TAU * 0.01;\n    vec3  ro = vec3( vec2(cos(gT), sin(gT)) * 30.0, mix(0.0, 20.0, sin(gT * 0.21) * 0.5 + 0.5)).xzy;\n    vec3  la = vec3( 0.0, 0.0, 0.0);\n    float zoom = 4.0;\n    vec3  rd = getRayDirection(ro, la, uv, zoom);\n\n    vec3  rgb = clr_fog;\n\n    vec3  ld = normalize(vec3(sin(gT * -3.0), 2.0 * (sin(gT * 5.0) * 0.4 + 0.6), cos(gT * -3.0)));\n\n    float numSteps;\n    SurfaceHit sh = march(ro, rd, numSteps);\n    rgb = albedo(sh);\n\n    vec3 nrm = estimateNormal(sh.position - rd * nrmBackoff);\n\n    float numSubSteps;\n\n    if (sh.material == mat_2) {\n      SurfaceHit shrf = march(sh.position + nrm * 0.01, reflect(rd, nrm), numSubSteps);\n      rgb = mix(rgb, albedo(shrf), 0.2);\n      numSteps += numSubSteps;\n    }\n    if (sh.material == mat_4) {\n      SurfaceHit shrf = march(sh.position + nrm * 0.01, reflect(rd, nrm), numSubSteps);\n      rgb = mix(rgb, albedo(shrf), 0.2);\n      numSteps += numSubSteps;\n    }\n\n    if (sh.material != mat_no_hit) {\n      // shading\n      float shadeFac = max(shadowFac, dot(ld, nrm));\n\n      // shadow\n      SurfaceHit shsh = march(sh.position + nrm * 0.01, ld, numSubSteps);\n      numSteps += numSubSteps;\n      if (shsh.material != mat_no_hit) {\n          shadeFac = shadowFac;\n      }\n\n      rgb *= shadeFac;\n    }\n\n    // fog\n    float dist = length(ro - sh.position);\n    rgb = mix(rgb, clr_fog, clamp(dist/rmMaxDist - 0.1, 0.0, 1.0));\n\n    // gamma\n    // rgb = pow(rgb, vec3(0.4545));\n    rgb = pow(rgb, vec3(0.6));\n  \n    #if SHOW_PIXEL_COST\n    rgb.r += numSteps / rmMaxSteps;\n    #endif\n\n    RGBA.rgb = rgb;\n}\n\n\n// grimoire bindings\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 105, 105, 1539]], "test": "untested"}
{"id": "3dGfD1", "name": "triangle to square 2", "author": "FabriceNeyret2", "description": "ref: [url]https://www.google.com/search?q=triangle+to+square&tbm=isch[/url]\nconstruction: [url]https://www.cs.purdue.edu/homes/gnf/book2/trisqu.html[/url]\nmore: start of [url]https://www.facebook.com/watch/?v=879304782515830[/url]", "tags": ["geometry", "tiling", "short", "reproduction", "hingeddissections"], "likes": 14, "viewed": 399, "published": 3, "date": "1607022300", "time_retrieved": "2024-07-30T20:32:20.741039", "image_code": "// v1 shader turned ghost ! https://www.shadertoy.com/view/WsGBD1\n\n#define cross2(a,b) ( (a).x*(b).y - (b).x*(a).y )\n\n// --- return bilinear coordinates of U in quad\n// ( some special cases might not fixed, but enough for use in this shader )\nvec2 Q(vec2 U, vec2 P00, vec2 P10, vec2 P01, vec2 P11) {\n    vec2  bu = P10-P00, bv = P01-P00, c = P00-U,  a = P11-P01 -bu;\n    float dv = -cross2(a,bv),\n          av = cross2(a,bu), cv = cross2(a,c);  // v = av/d . u + cv/d\n\n    if (dot(a,a)<1e-3)                          // parallelogram\n        return - inverse(mat2(bu,bv)) * c;         \n/*  if ( abs(dv) < 3e-2 ) {                     // trapeze\n        U.x = -cv/av, \n        U.y = -( bu.y*U.x + c.y ) / ( bv.y + a.y*U.x ); \n        return U; \n    } // or swap yx in a, bu, bv, c\n*/  av /= dv, cv /= dv;\n    float  A = a.x*av, B = bu.x + a.x*cv + bv.x*av, C = bv.x*cv + c.x,\n           D = B*B - 4.*A*C;\n    if ( abs(A) < 1e-3 )                        // linear case\n        U.x = -C/B; \n    else {\n        if ( D < 0. ) return vec2(-1.);         // shouldnt be.\n        U.x = ( -B + sign(B)*sqrt(D) ) *.5 / A; // bilinear coordinates\n    }\n    U.y = av * U.x + cv;\n    return U;\n}\n\n\n// --- not normalized signed distance to quad\nfloat sdQ(vec2 U, vec2 P00, vec2 P10, vec2 P01, vec2 P11) {\n    U = Q( U, P00, P10, P01, P11);\n    U = abs(U-.5)-.5;\n    return max(U.x,U.y);  \n}\n\n#define S(a)   smoothstep( 1.5, 0., (a)/min(.1,fwidth(a)) )\n//#define S(a)  ( v = (a)/fwidth(a), a < .1 ? smoothstep( 1.5, 0., v ) : 0. ) // .2+.2*sin(30.*(v)) )\n#define CS(a)   vec2( cos(a), sin(a) )\n#define rot(a)  mat2(cos( a + vec4(0,11,33,0)))\n\n\nvoid mainImage( out vec4 O, vec2 u ) // =======================\n{\n    vec2 R = iResolution.xy,\n         U = 1.5* ( 2.*u - R ) /R.y + vec2(.6,.2);\n         \n    \n#if 0 // test bilinear mapping \n    vec2 M = 1.5*iMouse.xy/R.y-.1;\n    U = Q( U, vec2(0), vec2(1,0), vec2(.2,.8), vec2(M) ); // quad\n  //U = Q( U, vec2(0), vec2(0)  , vec2(.2,.8), vec2(M) ); // triangle\n    O = texture(iChannel0, U);\n    U = abs(U-.5); O *= max(U.x,U.y) < .5 ? 2. : .5;\n    return;\n#endif \n    \n    float t = 3.142*(.5-.5*cos(iTime)), v,\n          s = 1.52,\n          z = .387, w = s/2.-z, a = .718, x = .5/tan(a), y = 1.-x;\n    O-=O;\n#define P(I,J,K)  O += S( sdQ( U, vec2(0), I, J, I+K ) )\n  \n    U *= rot(t);\n    P( vec2(z,0), s/2.*CS(1.05), y*CS(a) );\n    U.x -= z;\n    U *= rot(-t);\n    P( vec2(0), vec2(s/2.,0), x*CS(a) );\n    U.x -= s/2.;\n    U *= rot(-t);\n    P( vec2(w,0),  .5*CS(1.57+a), s/2.*CS(2.1) );\n    U.x -= w;\n    U *= rot(2.1);\n    U.x -= s/2.;\n    U *= rot(-t);\n    P( vec2(s/2.,0),  x*CS(1.05+a), s/2.*CS(2.1) );\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 243, 299, 299, 1181], [1184, 1230, 1289, 1289, 1375], [1628, 1628, 1693, 1693, 2641]], "test": "untested"}
{"id": "WsVBDh", "name": "Glow Gradient with Wave", "author": "Codax", "description": "Quick demonstration of a shader that gives client more control over how their selection ring looks", "tags": ["glowgradientwavesimple"], "likes": 2, "viewed": 438, "published": 3, "date": "1607019620", "time_retrieved": "2024-07-30T20:32:21.584784", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //Create basic glow mask\n    float glowMask = pow(1.0-uv.y, 6.0);\n    \n    //create a wave along y\n    float waveHeight = 0.05;\n    float waveFrequency = 0.3;\n    \n    //make wave frequency more intuitive by multiplying by 2*Pi (not strictly necessary)\n    waveFrequency *= 6.28318530718;\n    \n    float waveSpeed = 1.5;\n    uv.y += waveHeight * sin((uv.x * waveFrequency) + (iTime * waveSpeed));\n   \n    //Create gradient mask\n    float waveMask = pow(1.0-uv.y, 4.0);\n    \n    \n    // Pixel color\n    vec3 col = vec3(1.0, 0.0, 0.0);\n    \n    //More Fun Color\n    //col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //Apply the wave mask to the color\n    col *= waveMask;\n    \n    //create a glow color and apply a mask\n\tvec3 glow = vec3(1.0, 1.0-uv.y, 1.0-uv.y) * glowMask;\n    \n    \n    // Output to screen\n    fragColor = vec4(col + glow,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1007]], "test": "untested"}
{"id": "3dVBDh", "name": "Tumbling alternating squares", "author": "A_Toaster", "description": "Based on https://www.shadertoy.com/view/wdyfW1", "tags": ["checkerboard", "squares", "generativeart"], "likes": 20, "viewed": 443, "published": 3, "date": "1607017673", "time_retrieved": "2024-07-30T20:32:22.485375", "image_code": "uniform vec2 u_resolution;\nuniform float u_time;\n\n#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 st, float angle){\n    st -= 0.5;\n    st =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    st += 0.5;\n    return st;\n}\n\nvec2 tile(vec2 st, float zoom,float rotD){\n    st *= zoom;\n     if(rotD==1.) {\n        st.x+=.5;\n        st.y+=.5;\n     }\n    return fract(st);\n}\n\nfloat square(vec2 st, vec2 side){\n    vec2 border = vec2(0.5)-side*0.5;\n    vec2 pq = smoothstep(border,border+.01,st);\n    pq *= smoothstep(border,border+.01,vec2(1.0)-st);\n    return pq.x*pq.y;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.y;\n    float color;\n    float Nsquares=5.;\n    float rotDirection=0.;\n\tfloat warpedTime = iTime * 0.5 + uv.x + uv.y * 0.5;\n    rotDirection=step(0.,sin(warpedTime * 2.0));\n    \n    uv = tile(uv,Nsquares,rotDirection);\n    uv = rotate2D(uv,PI/4.0-warpedTime);\n    if (rotDirection==1.)\n        color = 1.0-square(uv,vec2(0.71));\n    else \n    color=square(uv,vec2(0.72));\n    fragColor = vec4(vec3(color),1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 121, 121, 252], [254, 254, 296, 296, 399], [401, 401, 434, 434, 598], [599, 599, 653, 653, 1104]], "test": "untested"}
{"id": "WsVfWh", "name": "debug display value anywhere", "author": "FabriceNeyret2", "description": "when you want to check a variable  inside a deep function.\n\n( also shows display debug value at mouse position ).", "tags": ["debug", "utils"], "likes": 10, "viewed": 1140, "published": 3, "date": "1607014784", "time_retrieved": "2024-07-30T20:32:23.373002", "image_code": "// === the magic function.  ==========================================\n#define db_display(X,Y,val) {                                             \\\n    vec2 U = vec2(15,10)* ( gl_FragCoord.xy/iResolution.xy - vec2(X,Y) ); \\\n    st_assert( pFloat(U,val).x < .5 );                                    \\\n}\n\n// === fonts utils from https://www.shadertoy.com/view/llySRh =========\n// ( can't be hidden in Common because, you know, can't access textures there for odd reasons.)\n\nvec4 char(vec2 p, int c) {// --- display char\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\nfloat dx = .4;\nvec4 pInt(vec2 p, float n) {// --- display int\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - dx*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\nvec4 pFloat(vec2 p, float n) { // --- display float4.4\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= 4.*dx; // comment this line in abs(n) < 1\n    v += char(p, 46);      p.x -= dx;\n    v += pInt(p,fract(n)*1e4);\n    return v;\n}\n// -----------------------------------------------------------------\n\n\nfloat calc( vec2 U  ) { // ========== some deep compute function\n    \n    vec4 S = 10.*sin(vec4(20,17,21,0) + 3.*iTime); // some expressions \n    \n    // debug display the values you wish.  \n    db_display( .7,.8, S.x );\n    db_display( .7,.7, S.y );\n    db_display( .0,.0, S.z );\n\n    S *= U.xyxy;                                      // some result\n    float v = sin( S.x + 10.*sin(S.y  +10.*sin(S.z + 10.*sin(S.w))) );\n    return .5+.5*v; \n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )  // ===============\n{\n    vec2 R = iResolution.xy,\n         U = fragCoord/R,\n         M = iMouse.xy/R - .5;\n    \n    fragColor = vec4( .3*calc(U) );\n    M = iMouse.xy/R; db_display( M.x,M.y, calc(M) ); // debug value at mouse pos\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVfWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[471, 471, 497, 516, 747], [763, 763, 791, 809, 1070], [1071, 1071, 1101, 1125, 1365], [1437, 1437, 1460, 1501, 1881], [1883, 1883, 1957, 1957, 2168]], "test": "untested"}
{"id": "3dKBWh", "name": "array of debug viewmeter anywher", "author": "FabriceNeyret2", "description": "when you want to check many variable at the same time ( red blocks ) even inside a deep function.\n", "tags": ["debug", "utils"], "likes": 4, "viewed": 423, "published": 3, "date": "1607012706", "time_retrieved": "2024-07-30T20:32:24.168874", "image_code": "// === the magic function.  list = ( float1, ... , floatN ) ==============\n#define viewmeter(list) {                                            \\\n    float L[] =  float[] list;                                       \\\n    st_assert( U.y>.1 || fract(U.x*float(L.length()))>.1, 2 );       \\\n    st_assert( U.y>.1 || U.y > .1*L[ int(U.x*float(L.length())) ] ); \\\n}\n\nfloat calc( vec2 U, vec2 M ) { // ========== some deep compute function\n    \n    vec4 S = .5+.5*sin(vec4(20,17,21,0)*M.xyxy + 3.*iTime); // some expressions \n    \n    // Here is the viewmeter array:  note the double () \n    // for debug, suppose we need to check these 6 expressions.\n    //         value1   value2  value3  value4 value5 value6    \n    viewmeter(  ( S.x , M.x*M.y , S.y,   S.z,   S.w, S.z*S.w ) );\n\n    S *= U.xyxy;                                      // some result\n    float v = sin( S.x + 10.*sin(S.y  +10.*sin(S.z + 10.*sin(S.w))) );\n    return .5+.5*v; \n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )  // ===============\n{\n    vec2 R = iResolution.xy,\n         U = fragCoord/R,\n         M = iMouse.xy/R - .5;\n    \n    fragColor = vec4( .3*calc(U,M) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[362, 362, 392, 433, 940], [942, 942, 1016, 1016, 1147]], "test": "untested"}
{"id": "wsGfD1", "name": "Animated Graph", "author": "oneshade", "description": "This was fun!", "tags": ["noise", "math", "graph", "continuousnoise"], "likes": 8, "viewed": 209, "published": 3, "date": "1607010800", "time_retrieved": "2024-07-30T20:32:25.026581", "image_code": "float noise(in float x) {\n    return fract(sin(x * 12.5673) * 573.123);\n}\n\nfloat continuousNoise(in float x) {\n    const float r = 2.735;\n\n    float x1 = floor(x * r) / r;\n    float y1 = noise(x1);\n\n    float x2 = ceil(x * r) / r;\n    float y2 = noise(x2);\n\n    return y1 + (0.5 + 0.5 * sin((2.0 * (x - x1) / (x2 - x1) - 1.0) * 1.57)) * (y2 - y1);\n}\n\nvec2 getSlopeVector(in float x) {\n    return normalize(vec2(0.002, continuousNoise(x + 0.001) - continuousNoise(x - 0.001)));\n}\n\n// SDF of equilateral triangle from Inigo Quilez's 2D distance functions article (https://iquilezles.org/articles/distfunctions2d):\nfloat sdEquilateralTriangle(in vec2 p, in float s) {\n    p /= s;\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if (p.x + k * p.y > 0.0) {\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    }\n\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y) * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 3.0 / iResolution.y * 4.0;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    fragColor.b += smoothstep(unit, 0.0, abs(uv.y - continuousNoise(uv.x + iTime)) - 0.01) * float(uv.x < 0.0);\n\n    vec2 slopeVector = getSlopeVector(iTime);\n    vec2 gradientVector = slopeVector.yx * vec2(1.0, -1.0);\n\n    uv.y -= continuousNoise(iTime);\n    vec2 tUV = vec2(dot(uv, gradientVector), dot(uv, slopeVector));\n\n    fragColor.rb += smoothstep(unit, 0.0, sdEquilateralTriangle(tUV, 0.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 73], [75, 75, 110, 110, 349], [351, 351, 384, 384, 478], [480, 612, 664, 664, 927], [929, 929, 984, 984, 1546]], "test": "untested"}
{"id": "wdyBD1", "name": "array of asserts", "author": "FabriceNeyret2", "description": "when you want to check many variable at the same time ( red blocks )\n\n( also shows an example of  expr(uv) check in green in the result ).", "tags": ["debug", "utils"], "likes": 4, "viewed": 504, "published": 3, "date": "1607010333", "time_retrieved": "2024-07-30T20:32:25.899248", "image_code": "// === the magic function.  list = ( bool1, ... , boolN ) ==============\n#define assert(list) {                                         \\\n    bool L[] =  bool[] list;                                   \\\n    st_assert( U.y>.1 || fract(U.x*float(L.length()))>.1, 2 ); \\\n    st_assert( U.y>.1 || L[ int(U.x*float(L.length())) ] );    \\\n}\n\nfloat calc( vec2 U, vec2 M ) { // ========== some deep compute function\n    \n    vec4 S = sin(vec4(20,17,21,0)*M.xyxy + 3.*iTime); // some expressions \n    \n    // Here is the assert array:  note the double () \n    // for debug, suppose we need to check these 6 expressions are valid.\n    //         assert1    assert2   assert3 assert4  assert5   assert6\n    assert(  ( S.x<.0 , M.x*M.y>.5 , S.y>.0, S.z<0., S.w>0., S.z*S.w<.5 ) );\n\n    S *= U.xyxy;                                      // some result\n    float v = sin( S.x + 10.*sin(S.y  +10.*sin(S.z + 10.*sin(S.w))) );\n    st_assert( v < .99999, 1 );  // example of expr(uv) check\n    return .5+.5*v; \n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )  // ===============\n{\n    vec2 R = iResolution.xy,\n         U = fragCoord/R,\n         M = iMouse.xy/R - .5;\n    \n    fragColor = vec4( .3*calc(U,M) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 366, 407, 994], [996, 996, 1070, 1070, 1201]], "test": "untested"}
{"id": "wdyfW1", "name": "Rotating alternating squares ", "author": "AI", "description": "Uncomment the last line to see the colorful version.", "tags": ["checkerboard", "squares", "generativeart", "creativecoding"], "likes": 9, "viewed": 365, "published": 3, "date": "1607005242", "time_retrieved": "2024-07-30T20:32:26.746981", "image_code": "#define PI 3.14159265358979323846\n\nvec2 rotate2D(vec2 st, float angle){\n    st -= 0.5;\n    st =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    st += 0.5;\n    return st;\n}\n\nvec2 tile(vec2 st, float zoom,float rotD){\n    st *= zoom;\n     if(rotD==1.) {\n        st.x+=.5;\n        st.y+=.5;\n     }\n    return fract(st);\n}\n\nfloat square(vec2 st, vec2 side){\n    vec2 border = vec2(0.5)-side*0.5;\n    vec2 pq = smoothstep(border,border+.01,st);\n    pq *= smoothstep(border,border+.01,vec2(1.0)-st);\n    return pq.x*pq.y;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.y;\n    float color;\n    float Nsquares=4.;\n    float rotDirection=0.;\n\n\tuv = rotate2D(uv,-sin(iTime)*PI*.5);\n    rotDirection=step(0.,sin(iTime));\n    uv = tile(uv,Nsquares,rotDirection);\n    uv = rotate2D(uv,PI/4.-sin(iTime)*PI*0.25);\n    if (rotDirection==1.)\n        color = 1.0-square(uv,vec2(0.7));\n    else \n    color=square(uv,vec2(0.7));\n    fragColor = vec4(vec3(color),1.0);\n    //fragColor=vec4(color,fract(123.56*sin(.0001*iTime)),fract(241.56*sin(.0001*iTime)),1.);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 71, 71, 202], [204, 204, 246, 246, 349], [351, 351, 384, 384, 548], [549, 549, 603, 603, 1123]], "test": "untested"}
{"id": "wsGBDh", "name": "Truck Driving", "author": "dr2", "description": "Try to stay on the road :)", "tags": ["game", "interactive", "car", "kinematics", "cyber"], "likes": 20, "viewed": 553, "published": 3, "date": "1606993313", "time_retrieved": "2024-07-30T20:32:27.762267", "image_code": "// \"Truck Driving\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Knob controls speed and steering; on-track driving distance shown; view direction\n  different at high elevation; mouseable.\n*/\n\n#define AA  0   // (=0/1) optional antialiasing (can be slow)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\nfloat Hashfv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nvec3 sunDir, qHit, carPos, wlBase;\nvec2 wlRot;\nfloat dstFar, tCur, wlRad, carRot, strRot, hgSize, trWidf;\nint idObj;\nconst int idBod = 1, idAx = 2, idBas = 3, idWhl = 4, idStr = 5, idSeat = 6;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 ra;\n  vec3 q;\n  float dMin, d, ds1, ds2, ds3;\n  ra = vec4 (-0.08, -0.012, 0.37, -0.42) * pi;\n  p.y -= carPos.y;\n  p.xz = Rot2D (p.xz, carRot);\n  p.z -= wlBase.z;\n  dMin = dstFar;\n  q = p;\n  ds1 = max (Rot2D (q.yz, ra.z).y - 1.03, - Rot2D (q.yz, ra.w).y - 0.75);\n  ds2 = Rot2D (abs (vec2 (q.x, q.y + 0.18)), ra.x).x - 1.3;\n  ds3 = max (Rot2D (vec2 (q.y, abs (q.z)), ra.y).y - 3., ds1);\n  d = max (max (abs (q.y - 0.1) - 1., ds2), ds3);\n  d = max (d, - PrBoxDf (p - vec3 (0., 0.2, -2.), vec3 (1.08, 0.4, 0.9)));\n  d = max (d, - PrCylDf (((vec3 (abs (q.xz) - wlBase.xz, q.y + wlRad + 0.35)).xzy).yzx,\n     wlRad + 0.06, 0.5));\n  d = max (d, - max (max (max (abs (q.y - 0.48) - 0.35, abs (q.z - 0.5) - 1.5), ds1 + 0.05),\n     0.08 - abs (q.z - 0.5)));\n  d = max (d, - max (ds2 + 0.08, min (max (abs (q.y - 0.68) - 0.2, q.z - 0.5),\n     max (abs (q.y - 0.55) - 0.31, 0.5 - q.z))));\n  d = max (d, - max (max (max (max (abs (q.y - 0.2) - 0.9, ds2), ds3) + 0.06,\n     abs (q.z - 0.3) - 1.3), - max (max (length (vec2 (q.y + wlRad + 0.35, q.z - wlBase.z)) -\n     (wlRad + 0.06 + 0.02), q.z - wlBase.z), - q.y - wlRad - 0.35)));\n  DMINQ (idBod);\n  q = p;\n  q.z = abs (q.z);\n  q.yz -= vec2 (- wlRad - 0.35, wlBase.z);\n  d = PrCylDf (q.yzx, 0.08, wlBase.x);\n  DMINQ (idAx);\n  q = p;\n  q.y -= -0.88;\n  d = PrBoxDf (q, vec3 (1.3, 0.03, 1.35));\n  DMINQ (idBas);\n  q = p;\n  q = vec3 (abs (q.xz) - wlBase.xz, q.y + wlRad + 0.35).xzy;\n  if (p.z > 0.) q.xz = Rot2D (q.xz, - strRot * sign (p.x));\n  q.yz = Rot2D (q.yz, - ((p.x < 0.) ? wlRot.x : wlRot.y) * sign (p.z));\n  d = max (PrRoundCylDf (q.yzx, wlRad - 0.1, 0.1, 0.14), wlRad - 0.25 - length (q.yz));\n  d = min (d, PrCylDf (q.yzx, wlRad - 0.25, 0.2));\n  d = min (d, PrCylDf (vec3 (q.x, ((abs (q.y) < abs (q.z)) ? q.yz : q.zy)) - vec3 (0.17, 0., 0.),\n     0.07, wlRad - 0.2));\n  DMINQ (idWhl);\n  q = p;\n  q.yz = Rot2D (q.yz - vec2 (0.72, 0.2), -0.1 * pi);\n  q -= vec3 (-0.5, -0.3, 1.5);\n  d = PrRoundCylDf (q, 0.03, 0.03, 0.35);\n  q.z -= -0.35;\n  q.xy = Rot2D (q.xy, -8. * strRot + pi / 6.);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  d = min (d, PrTorusDf (q, 0.025, 0.35));\n  q.x += 0.17;\n  d = min (d, PrCylDf (q.yzx, 0.02, 0.17));\n  DMINQ (idStr);\n  q = p;\n  q.yz -= vec2 (-0.4, 0.5);\n  d = PrBoxDf (q, vec3 (1., 0.1, 0.35));\n  q.yz = Rot2D (q.yz - vec2 (0.4, -0.43), 0.1 * pi);\n  d = min (d, PrBoxDf (q, vec3 (1., 0.35, 0.05)));\n  DMINQ (idSeat);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec4 ra;\n  vec3 q;\n  float ds1, ds2, ds3;\n  ra = vec4 (-0.08, -0.012, 0.37, -0.42) * pi;\n  p.y -= carPos.y;\n  p.xz = Rot2D (p.xz, carRot);\n  p.z -= wlBase.z;\n  q = p;\n  ds1 = max (Rot2D (q.yz, ra.z).y - 1.03, - Rot2D (q.yz, ra.w).y - 0.75);\n  ds2 = Rot2D (abs (vec2 (q.x, q.y + 0.18)), ra.x).x - 1.3;\n  ds3 = max (Rot2D (vec2 (q.y, abs (q.z)), ra.y).y - 3., ds1);\n  return max (max (ds2 + 0.03, ds3 + 0.02), max (abs (q.z - 0.5) - 1.55, - q.y - 0.2));\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + dHit * rd;\n    d = TrObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 CarCol (out float refFac)\n{\n  vec4 col4, colB4;\n  float r, s;\n  colB4 = vec4 (0.9, 0.3, 0.3, 0.2);\n  col4 = colB4;\n  if (idObj == idBod) {\n    s = 1.;\n    if (qHit.z < - 2.98 && PrRoundBox2Df (qHit.xy + vec2 (0., 0.1), vec2 (1.2, 0.), 0.05) < 0.)\n       col4 = vec4 (1., 0., 0., -1.);\n    else if (qHit.z > 2.98 && PrRoundBox2Df (qHit.xy + vec2 (0., 0.25), vec2 (1.2, 0.), 0.05) < 0.)\n       col4 = vec4 (1., 1., 0.8, -1.);\n    else if (qHit.z > 2.8 && PrRoundBox2Df (qHit.xy + vec2 (0., 0.5), vec2 (0.78, 0.15), 0.01) < 0.)\n       s = 0.7 + 0.3 * step (0.2, cos (8. * pi * qHit.x));\n    else if (qHit.y > -0.5 && abs (qHit.x) < 1.05 && abs (qHit.z + 2.) < 0.85)\n       s = 1. - 0.1 * cos (16. * pi * qHit.x);\n    else s = 0.6 + 0.4 * step (-0.75, qHit.y) * step (0., max (abs (qHit.y) - 0.85,\n       abs (qHit.z - 0.5) - 0.01)) *\n       step (0., max (abs (qHit.y + 0.09) - 0.3, abs (qHit.z - 2.) - 0.01)) *\n       step (0., max (abs (qHit.y + 0.15) - 0.6, abs (qHit.z + 1.) - 0.01));\n    s *= 0.5 + 0.5 * step (wlRad + 0.07, length (vec2 (qHit.y + wlRad + 0.35,\n       abs (qHit.z) - wlBase.z)));\n    col4.rgb *= s;\n  } else if (idObj == idAx) {\n    col4 = vec4 (0.3, 0.3, 0.4, 0.1);\n  } else if (idObj == idBas) {\n    col4.rgb *= 0.4;\n  } else if (idObj == idWhl) {\n    r = wlRad - length (qHit.yz);\n    if (r < 0.22) col4 = vec4 (0.3, 0.3, 0.3, 0.) * (1. - 0.5 * step (r, 0.07) *\n       abs (step (0., cos (32. * pi * qHit.x)) - step (0.5, mod (32. * atan (qHit.z, - qHit.y) /\n       (2. * pi) + 0.5, 1.))));\n    else {\n      if (qHit.x > 0.205) col4 = vec4 (0.9, 0.9, 1., 0.2);\n      else if (qHit.x < 0.) col4 *= 0.5;\n    }\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.9, 0.9, 0.9, 0.2);\n  } else if (idObj == idSeat) {\n    col4 = vec4 (0.9, 0.7, 0.4, 0.05) * (0.95 + 0.05 * cos (64. * qHit.x));\n  }\n  refFac = 0.;\n  if (col4 == colB4 && (qHit.y < -0.5 || PrRoundBox2Df (qHit.xz + vec2 (0., 2.),\n     vec2 (1.1, 0.95), 0.01) > 0.)) refFac = 0.12;\n  return col4;\n}\n\nvec3 GrndCol (vec3 ro, float dstGrnd, float sh)\n{\n  vec3 col, colG, vn;\n  vec2 vf, q;\n  vec2 gId;\n  float a, f, ff;\n  gId = PixToHex (ro.xz / hgSize);\n  q = Rot2D ((ro.xz - HexToPix (gId * hgSize)) / hgSize,\n     (2. * step (Hashfv2 (gId), 0.5) - 1.) * pi / 6.);\n  q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 1.;\n  colG = 0.4 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n     0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)));\n  vf = vec2 (0.);\n  ff = 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar);\n  f = abs (length (q) - 0.5) - trWidf;\n  if (f < 0.) {\n    col = mix (vec3 (0.25) * (0.5 + 0.5 * Fbm2 (64. * ro.xz)), vec3 (0.8), f);\n    a = abs (mod (4. * (mod (15. * atan (q.y, - q.x) / (2. * pi), 1.) - 0.5) + 0.5, 1.) - 0.5) - 0.3;\n    for (float s = 1.; s >= 0.; s -= 1.) {\n      col = mix (vec3 (0.9), col, max (smoothstep (0., 0.02, a - 0.03 * s),\n         smoothstep (0., 0.002, abs (f + 0.02) - 0.005)));\n    }\n    col = mix (colG, col, ff);\n    vf = vec2 (16., 1. * (1. - 0.9 * f));\n  } else {\n    col = colG;\n    vf = vec2 (4., 1.);\n  }\n  vn = vec3 (0., 1., 0.);\n  if (vf.x > 0. && ff > 0.) vn = VaryNf (vf.x * ro, vn, vf.y * ff);\n  col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);\n  return col;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, rdo, col, colR, vn;\n  float dstObj, dstGrnd, dstTrObj, nDotL, refFac, sh;\n  roo = ro;\n  rdo = rd;\n  dstTrObj = TrObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = CarCol (refFac);\n    if (dstTrObj < dstObj) refFac = 0.;\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      col = col4.rgb * (0.2 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.8 * sh * nDotL * nDotL) + col4.a * step (0.95, sh) *\n         pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      if (refFac > 0.) rd = reflect (rd, vn);\n    } else if (col4.a == -1.) {\n      col = col4.rgb * (0.2 - 0.8 * dot (rd, vn));\n    }\n  }\n  if (dstObj >= dstFar || refFac > 0.) {\n    if (rd.y < 0.) {\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      sh = (dstGrnd < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      colR = GrndCol (vec3 (ro.xz + carPos.xz, 0.).xzy, dstGrnd, sh);\n      colR = mix (colR, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n    } else {\n      colR = SkyBgCol (ro, rd);\n    }\n    col = (refFac > 0.) ? mix (col, 0.9 * colR, refFac) : colR;\n  }\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro = roo + dstTrObj * rdo;\n    vn = TrObjNf (ro);\n    col *= vec3 (0.9, 1., 0.9);\n    rd = reflect (rdo, vn);\n    col = mix (col, SkyBgCol (ro, rd), 0.2 + 0.8 * pow (1. - abs (dot (vn, rdo)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 rd, ro, col, wgBox;\n  vec2 canvas, uv, ud, cnPos;\n  float el, az, asp, zmFac, onPath, trvDist, s, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  carPos = stDat.xyz;\n  carRot = stDat.w;\n  stDat = Loadv4 (1);\n  wlBase = stDat.xyz;\n  wlRad = wlBase.y;\n  stDat = Loadv4 (2);\n  strRot = stDat.y;\n  wlRot = stDat.zw;\n  stDat = Loadv4 (3);\n  az = stDat.x;\n  el = stDat.y;\n  cnPos = stDat.zw;\n  stDat = Loadv4 (4);\n  hgSize = stDat.x;\n  trWidf = stDat.y;\n  onPath = stDat.z;\n  trvDist = stDat.w;\n  el = clamp (el - 0.1 * pi, -0.49 * pi, -0.03 * pi);\n  if (el > -0.47 * pi) az += carRot;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -12.) + vec3 (Rot2D (vec2 (0., wlBase.z), - carRot),\n     carPos.y + 1.).xzy;\n  carPos.y += wlRad + 0.95;\n  zmFac = 5. + 3. * el;\n  dstFar = 150.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  wgBox = vec3 (0.39, -0.3, 0.135);\n  ud = 0.5 * uv - wgBox.xy * vec2 (asp, 1.);\n  col = mix (vec3 (0.7, 0.6, 0.3), col, smoothstep (0., 1.,\n     PrRoundBox2Df (ud, vec2 (wgBox.z) - 0.1, 0.12) * canvas.y));\n  s = (length (ud) - wgBox.z) * canvas.y;\n  col *= 0.5 + 0.5 * smoothstep (0., 1., abs (s) - 1.);\n  if (s < 0.) {\n    if (Minv2 (abs (ud)) * canvas.y < 1.) col *= 0.5;\n    col = mix (((onPath > 0.) ? vec3 (0., 1., 0.) : vec3 (0.8, 0., 0.)), col,\n       smoothstep (2.5, 3.5, abs (length (ud - cnPos) * canvas.y - 10.)));\n  }\n  col = mix (col, vec3 (0., 1., 0.), ShowIntPZ (0.5 * uv - vec2 (0.43 * asp, -0.11),\n     vec2 (0.08 * asp, 0.04), 4., mod (floor (trvDist / (2. * wlBase.z)), 1e4)));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    val = max (val, 0.);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Truck Driving\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 carPos, wlBase;\nfloat carRot, hgSize, trWidf;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\nconst float txRow = 128.;\n\nfloat OnPath ()\n{\n  vec2 q, gId;\n  q = carPos.xz + Rot2D (vec2 (0., wlBase.z), - carRot);\n  gId = PixToHex (q / hgSize);\n  q = Rot2D ((q - HexToPix (gId * hgSize)) / hgSize,\n     (2. * step (Hashfv2 (gId), 0.5) - 1.) * pi / 6.);\n  q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 1.;\n  return (abs (length (q) - 0.5) < trWidf) ? 1. : 0.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 wgBox;\n  vec2 iFrag, canvas, cnPos, wlRot, cp, ud, w;\n  float tCur, autoMd, cRotN, strRot, wlRad, rTurn, spd, onPath, trvDist, tc, nStep,\n     az, el, asp, s;\n  int pxId, wgSel;\n  bool init;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 6) discard;\n  init = (iFrame <= 5);\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  if (init) {\n    carPos = vec3 (0.);\n    carRot = 0.;\n    strRot = 0.;\n    wlRad = 0.6;\n    wlBase = vec3 (1.25, wlRad, 2.);\n    wlRot = vec2 (0.);\n    az = 0.;\n    el = 0.;\n    nStep = 0.;\n    cnPos = vec2 (0.);\n    mPtrP = mPtr;\n    wgSel = 0;\n    autoMd = 1.;\n    hgSize = 40.;\n    trWidf = 0.12;\n    onPath = 0.;\n    trvDist = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    carPos = stDat.xyz;\n    carRot = stDat.w;\n    stDat = Loadv4 (1);\n    wlBase = stDat.xyz;\n    autoMd = stDat.w;\n    stDat = Loadv4 (2);\n    nStep = stDat.x;\n    strRot = stDat.y;\n    wlRot = stDat.zw;\n    stDat = Loadv4 (3);\n    az = stDat.x;\n    el = stDat.y;\n    cnPos = stDat.zw;\n    stDat = Loadv4 (4);\n    hgSize = stDat.x;\n    trWidf = stDat.y;\n    onPath = stDat.z;\n    trvDist = stDat.w;\n    stDat = Loadv4 (5);\n    mPtrP.xyz = stDat.xyz;\n    wgSel = int (stDat.w);\n  }\n  wgBox = vec3 (0.39, -0.3, 0.135);\n  if (mPtr.z > 0.) {\n    if (wgSel == 0 && mPtrP.z > 0.) {\n      az = -2. * pi * mPtr.x;\n      el = - pi * mPtr.y;\n    } else {\n      ud = mPtr.xy * vec2 (asp, 1.) - wgBox.xy * vec2 (asp, 1.);\n      if (wgSel == 1) {\n        autoMd = - tCur;\n        cnPos = ud;\n        s = length (cnPos);\n        if (s > 0.) cnPos = min (s, wgBox.z) * cnPos / s;\n      } else if (mPtrP.z <= 0. && length (ud) < wgBox.z) wgSel = 1;\n    }\n  } else {\n    wgSel = 0;\n    cnPos *= 1. - 5e-3;\n  }\n  wlRad = wlBase.y;\n  ++ nStep;\n  if (autoMd > 0.) {\n    tc = mod (0.003 * nStep, 4.);\n    strRot = 0.12 * pi * SmoothBump (0.3, 0.7, 0.15, mod (tc, 1.)) * sign (mod (tc, 2.) - 1.) *\n       sign (tc - 2.);\n    spd = 0.1 - 0.06 * abs (strRot / (0.12 * pi));\n    w = vec2 (- strRot / (0.15 * pi), spd / 0.5);\n    w = pow (abs (w), 1. / vec2 (1.5)) * sign (w);\n    cnPos = w * wgBox.z;\n  } else {\n    w = cnPos / wgBox.z;\n    w = pow (abs (w), vec2 (1.5)) * sign (w);\n    strRot = -0.15 * pi * w.x;\n    spd = 0.5 * w.y;\n    if (tCur + autoMd > 10.) autoMd = 1.;\n  }\n  cp = carPos.xz;\n  w = vec2 (1.);\n  if (abs (strRot) > 1e-4) {\n    cRotN = carRot - strRot * spd / pi;\n    rTurn = wlBase.z / asin (0.5 * strRot);\n    carPos.xz += rTurn * (sin (carRot - vec2 (0.5 * pi, 0.)) - sin (cRotN - vec2 (0.5 * pi, 0.)));\n    carRot = cRotN;\n    w += vec2 (-1., 1.) * wlBase.x / rTurn;\n  } else {\n    carPos.xz += spd * sin (carRot + vec2 (0., 0.5 * pi));\n  }\n  wlRot += w * spd / wlRad;\n  onPath = OnPath ();\n  if (onPath > 0.) trvDist += length (carPos.xz - cp);\n  else trvDist = 0.;\n  if      (pxId == 0) stDat = vec4 (carPos, carRot);\n  else if (pxId == 1) stDat = vec4 (wlBase, autoMd);\n  else if (pxId == 2) stDat = vec4 (nStep, strRot, wlRot);\n  else if (pxId == 3) stDat = vec4 (az, el, cnPos);\n  else if (pxId == 4) stDat = vec4 (hgSize, trWidf, onPath, trvDist);\n  else if (pxId == 5) stDat = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBDh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1217, 1217, 1239, 1239, 3697], [3699, 3699, 3732, 3732, 3979], [3981, 3981, 4002, 4002, 4259], [4261, 4261, 4285, 4285, 4741], [4743, 4743, 4778, 4778, 5027], [5029, 5029, 5052, 5052, 5311], [5313, 5313, 5350, 5350, 5579], [5581, 5581, 5613, 5613, 7560], [7562, 7562, 7611, 7611, 8825], [8827, 8827, 8861, 8861, 9618], [9620, 9620, 9655, 9655, 11204], [11206, 11206, 11262, 11262, 13395], [13397, 13397, 13429, 13429, 13529], [13531, 13531, 13578, 13578, 13625], [13627, 13627, 13669, 13669, 13720], [13722, 13722, 13779, 13779, 13855], [13857, 13857, 13903, 13903, 13960], [13962, 13962, 13986, 13986, 14216], [14218, 14218, 14242, 14242, 14302], [14304, 14304, 14326, 14326, 14353], [14355, 14355, 14391, 14391, 14597], [14599, 14599, 14629, 14629, 14742], [14744, 14744, 14767, 14767, 14869], [14942, 14942, 14974, 14974, 15516], [15518, 15518, 15580, 15580, 15972], [16006, 16006, 16030, 16030, 16090], [16092, 16092, 16116, 16116, 16169], [16171, 16171, 16195, 16195, 16325], [16327, 16327, 16352, 16352, 16498], [16500, 16500, 16525, 16525, 16711], [16713, 16713, 16735, 16735, 16889], [16891, 16891, 16912, 16912, 17067], [17069, 17069, 17098, 17098, 17310], [17312, 17312, 17351, 17351, 17531], [17625, 17625, 17650, 17650, 17773]], "test": "untested"}
{"id": "tdyBDh", "name": "Space curvature", "author": "iapafoto", "description": "generalise Join3D from [iq] https://www.shadertoy.com/view/3ld3DM\n=> opCurveSpace (add a 2 rotations, generic 2D shape profile, generic 3D shape) - (not exact)\nRq: BumpMap is a bit triky cause it requires an uvw space normal", "tags": ["3d", "torsion"], "likes": 56, "viewed": 941, "published": 3, "date": "1606992670", "time_retrieved": "2024-07-30T20:32:28.851355", "image_code": "// Created by sebastien durand - 01/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// *****************************************************************************\n// Add 2 rotations to [iq]  https://www.shadertoy.com/view/3ld3DM\n// See also           [dr2] https://www.shadertoy.com/view/3l3GD7\n// *****************************************************************************\n\n// Buf B: Calculate distance to scene\n// Image: DOF post processing\n\n\n#define WITH_DOF\n#define WITH_CONE_TEST\n\n\n#ifdef WITH_DOF\n\nconst float aperture = 2.;\n\nconst float cosAngle = cos(radians(aperture/2.));\nconst float GA = 2.399;  // golden angle = 2pi/(1+phi)\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n    \nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn side*dot(normalize(o-p), n) >= cosAngle;\n}\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.08, (2./iResolution.y) * (1.+t));\n}\n\nvec3 RD(const vec2 q) {\n    return normalize(vec3((2.* q.x - 1.) * iResolution.x/iResolution.y,  (2.* q.y - 1.), 2.));\n}\n\nvec3 dof(sampler2D tex, vec2 uv, float fdist) {\n    \n    const float amount = 1.;\n\tvec4 colMain = texture(tex, uv);\n    \n    fdist = min(30., fdist);\n    float rad = min(.3, coc(abs(colMain.w-fdist))),//.3; // TODO calculate this for Max distance on picture\n    \t  r=6.;\n    \n    vec3 cn = RD(uv),    // Cone axis    \n         co = cn*fdist,  // Cone origin\n         sum = vec3(0.),  \n     \t bokeh = vec3(1),\n         acc = vec3(0),\n         pixPos;\n    vec2 pixScreen,\n         pixel = 1./iResolution.xy,        \n         angle = vec2(0, rad);\n    vec4 pixCol;\n    \n    bool isInCone = false;\n\tfor (int j=0;j<32;j++) {  \n        r += 1./r;\n\t    angle *= rot;\n        pixScreen = uv + pixel*(r-1.)*angle; // Neighbourg Pixel\n        pixCol = texture(tex, pixScreen);    // Color of pixel (w is depth)      \n        pixPos = pixCol.w * RD(pixScreen);   // Position of 3D point in camera base\n#ifdef WITH_CONE_TEST\n        if (inCone(pixPos, co, cn, sign(fdist - pixCol.w))) \n#endif            \n        {        // true if the point is effectivelly in the cone\n            bokeh = pow(pixCol.xyz, vec3(9.)) * amount +.1;\n            acc += pixCol.xyz * bokeh;\t\t\t\n            sum += bokeh;\n            isInCone = true;\n        }\n\t}\n        \n \treturn (!isInCone) ? colMain.xyz : // Enable to deal with problem of precision when at thin begining of the cone\n       acc.xyz/sum;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy;\n    \n    // Animation\n \tfloat anim = .1*iTime,\n   \t   aCam = 10. + 4.*anim + 8.*m.x;\n\n    // Camera\n\tvec3 ro = 1.5*vec3(cos(aCam), 1.2, .2 + sin(aCam));\n\t\t\t\n  \t// DOF\n    float fdist = length(ro-vec3(0,.3,0));\n    vec3 c = dof(iChannel0,q,fdist); \n    \n    // Vigneting\n    c *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .32); \n    \n    fragColor = vec4(c,1.);\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 c = texture(iChannel0,uv);\n    c *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .5); // Vigneting\n\tfragColor = c; //*.01; \n}\n\n#endif", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Add second rotation to [iq]  https://www.shadertoy.com/view/3ld3DM\n// See also               [dr2] https://www.shadertoy.com/view/3l3GD7\n\n// -------------------------------\n// Choose shapes\n// -------------------------------\n\n//#define SD2D(uv,w) sdBox(uv, w)\n#define SD2D(uv,w) sdRoundedX(uv, w.x, w.y)\n//#define SD2D(uv,w) sdCircle(uv, w)\n//#define SD2D(uv,w) sdBox2(uv, w)\n\n//#define SD3D(uv,w) sdBox3(uv, vec3(w.x,h,w.x))\n#define SD3D(uv,w) .8*sdMessage3D(-uv.yzx+vec3(l+.24,0,0), gtxt,.5,w.x)\n\n// -------------------------------\n// Render options\n// -------------------------------\n\n#define WITH_TEXTURE\n#define WITH_BUMPMAP\n#define WITH_GRIB\n//#define WITH_AA\n\n// -------------------------------\n#define GROUND 0\n#define BIDULE 1\n// -------------------------------\n\nmat2 rot(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2( ca, -sa, sa, ca );\n}\n\n\n// --------------------------------------------------------\n// Inspired by [iq] https://www.shadertoy.com/view/3ld3DM\n// --------------------------------------------------------\n\nvec3 opCurveSpace( in vec3 p, in float h, in vec3 r, out vec2 q, out float ra) {\n    float s = sign(r.x);\n    if (s*r.x<.001) r.x = .001;\n    if (abs(r.y)<.001) r.y = .001;\n    if (abs(r.z)<.001) r.z = .001;\n    vec2 sc = vec2(sin(r.x),cos(r.x)); // could de precalculated\n    mat2 rot2 = rot(r.y);            // could de precalculated\n    ra = .5*h/r.x;           // Distance\n    p.xz *= rot2;          // Apply 2nd rotation\n    p.x -= ra;             // Recenter\n    q = p.xy - 2.*sc*max(0.,dot(sc,p.xy));  // Reflect\n    vec3 uvw = vec3(ra-length(q)*s,         // New space coordinates \n                    ra*atan(s*p.y,-s*p.x),\n                    p.z);\n    uvw.zx *= rot(r.y+r.z*(uvw.y/h));        // Inverse 2nd rotation\n    return uvw;\n}\n\n\n// -- Text ------------------------------------------------\n// Adapted from [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\n// --------------------------------------------------------\n\nint[] gtxt = int[] (83,80,65,67,69);\n\nfloat sdFont(in vec2 p, in int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel2, uv, 0.).w - 127./255.);\n}\n\nfloat sdMessage2D(in vec2 p, in int[5] txt) { \n \tfloat d = 99., w = .45; // letter width  \n    for (int id = 0; id<5; id++){\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return d-.015;\n}\n\nfloat sdMessage3D(in vec3 p, in int[5] txt, in float scale, in float h) { \n    return opExtrussion(p, sdMessage2D(p.xy/scale, txt)*scale, h);\n}\n\n// Based on [iq] https://www.shadertoy.com/view/3ld3DM\nvec4 sdJoint3D( in vec3 p, in float l, in vec3 rot, in vec2 w) {\n    vec2 q; float ra;\n    vec3 uvw = opCurveSpace(p, l, rot, q, ra);\n#ifdef SD3D   \n    float d = SD3D(uvw, w);\n#else // \n    // 2D Profile\n    float ww = 1.2*max(w.x,w.y);\n    float dTop = length(vec2(q.x+ra-clamp(q.x+ra,-ww,ww), q.y))*sign(-q.y);\n    \n    // Profile  \n    float d = SD2D(uvw.xz, w);\n\td = max(dTop, d);\n#endif\n    return vec4(d, uvw );\n}\n\nvec4 sdJoint3DSphere( in vec3 p, in float h, in vec3 rot, in float w) {   \n    vec2 q; float ra; // only use in 2D\n    vec3 uvw = opCurveSpace(p, h, rot, q, ra);\n    float d = sdVerticalCapsule(uvw, h, w);\n \treturn vec4(d, uvw );\n}\n\n// --------------------------------------------------------\n//   The Scene\n// --------------------------------------------------------\n\nvec4 map4( in vec3 pos ) {\n    float a = 1.*sin(iTime*1.5), b = 1.3*sin(iTime*2.5);\n    vec4 d1 = sdJoint3DSphere(pos-vec3(0.,0., .4), .8, vec3(b,a,a*b), .2 ),\n         d2 = sdJoint3D(pos-vec3(0.,0.,-.4), .8, vec3(a,b,1.5*sin(a+iTime*2.1)), vec2(.2,.04) );\n    d1.w += .4;\n    d2.w -= .4;\n    return d1.x<d2.x ? d1 : d2; // Without ground\n}\n\nfloat map(in vec3 p) {\n    return min(map4(p).x, p.y); // Distance with ground\n}\n\n// --------------------------------------\n// Shading Tools\n// --------------------------------------\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .4 * t / iResolution.x;\n    vec2 d = vec2(-1,1) * pitch;\n\tvec3 p0 = p+d.xxx, p1 = p+d.xyy, p2 = p+d.yxy, p3 = p+d.yyx;\n\tfloat f0 = map(p0), f1 = map(p1), f2 = map(p2), f3 = map(p3);\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\treturn normalize(grad - max(.0, dot(grad,ray))*ray);\n}\n\nfloat SoftShadow(in vec3 ro, in vec3 rd) {\n    float r = 1., h, t = .005+hash13(ro)*.02, dt = .01;\n    for(int i=0; i<48; i++ ) {\n\t\th = map4(ro + rd*t).x;\n\t\tr = min(r, 3.*h/t);\n\t\tt += dt;\n        dt += .0015;\n        if (h<1e-4) break;\n    }\n    return clamp(r, 0., 1.);\n}\n\nfloat CalcAO(in vec3 p, in vec3 n) {\n    float d, h=.01, a=.0, s=1.;\n    for(int i=0; i<4; i++) {\n        d = map(n * h + p);\n        a += (h-d)*s;\n        s *= .8;\n        h += .03;\n    }\n    return clamp(1.-4.*a, 0., 1.);\n}\n\nfloat isGridLine(vec3 p, vec3 v) {\n    vec3 k = smoothstep(.2,.8,abs(mod(p+v*.5, v)-v*.5)/.01);\n    return k.x * k.y * k.z;\n}\n\n// See https://iquilezles.org/articles/palettes for more information\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n#ifdef WITH_BUMPMAP\n//----------------------------------\n// Texture 3D\n//----------------------------------\n// Need to be in UVW space !\nvec3 normalUVW(in vec3 p, in vec3 n, in float t) {   \n\tfloat pitch = .4 * t / iResolution.x;\n    return normalize(map4(p+n*pitch).yzw - map4(p).yzw);\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(n*n, .001);\n    n /= n.x + n.y + n.z;  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, in vec3 nUVW, float bf){   \n    const vec2 e = vec2(.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, nUVW), tex3D(tx, p - e.yxy, nUVW), tex3D(tx, p - e.yyx, nUVW));\n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , nUVW), vec3(.299, .587, .114)) )/e.x; \n    g -= nUVW*dot(nUVW, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n#endif\n\n//----------------------------------\n// Shading\n//----------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd, in float res, in vec3 pos, in vec3 n, in vec3 cobj, in vec3 light) {\n    float \n         ao = CalcAO(pos, n),\n    \t sh = SoftShadow( pos, light),\n         amb = clamp(.5+.5*n.y, .0, 1.),\n         dif = sh*clamp(dot( n, light ), 0., 1.),\n         pp = clamp(dot(reflect(-light,n), -rd),0.,1.),\n         fre = (.7+.3*dif)* ao*pow( clamp(1.+dot(n,rd),0.,1.), 2.);\n    vec3 brdf = ao*.5*(amb)+ sh*ao*1.*dif*vec3(1.,.9,.7)*vec3(1.,.25,.05),\n         sp = sh*5.*pow(pp,9.)*vec3(1., .6, .2),\n\t     col = cobj*(brdf + sp) + fre*(.5*cobj+.5);\n    return mix(.1*vec3(1.,1.,.8),col,2.*dot(n,-rd));\n}\n\n// --------------------------------------\n// Main\n// --------------------------------------\n\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 r = iResolution.xy, \n         m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, pix = q+q-1.;\n\tpix.x *= r.x/r.y;\n    \n    float anim = .1*iTime,\n     \t  tTensionCol = smoothstep(.8,1.2,anim),\n\t\t  aCam = 10. + 4.*anim + 8.*m.x;\n    \n    // Camera\n\tvec3 ro = 1.5*vec3(cos(aCam), 1.2, .2 + sin(aCam)),\n         w = normalize(vec3(0,.3,0) - ro), \n         u = normalize(cross(w, vec3(0,1,0))), \n         v = cross(u, w),\n         rd = normalize(pix.x * u + pix.y * v + w+w);\n\t\t\t\n    // Ground intersection (faster than ray marching)\n    float tg = -ro.y/rd.y; \n    float tmax = min(tg,3.5);\n\t// Ray marching\n    int obj = GROUND;\n    float h = .1, t = .01*hash13(q.xyx);\n    for(int i=0;i<200;i++) { \n        if (h<5.e-5 || t>tmax) break;\n        t += h = map4(ro + rd*t).x;\n    }\n    if (h<5.e-5) {\n        obj = BIDULE;\n    } else {\n        t = tg;\n    }\n    \n\t// Light\n    vec3 lightPos = vec3(0.,1.2, .7);\n            \n    // Calculate color on point\n    vec3 pos = ro + t * rd;\n    vec3 n = obj == GROUND ? vec3(0,1,0) : normal(pos,rd,t);\n    vec3 uvw = obj == GROUND ? pos : map4(pos).yzw; \t\t\n    vec3 cobj = vec3(1.);\n\tfloat grib = 1.;\n#ifdef WITH_TEXTURE\n    float k = hash13(floor((uvw+.15)/.3));\n    cobj = pal(k, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30));\n    cobj = mix(vec3(1), sqrt(cobj), step(.5,k));\n#endif      \n#ifdef WITH_GRIB\n    grib = isGridLine(uvw+.15, vec3(.3));\n    cobj = mix(vec3(.1),cobj,grib);\n#endif\n#ifdef WITH_BUMPMAP\n    vec3 nuvw = obj == GROUND ? n : normalUVW(pos,n,t);\n    n = grib < .7 ? n : doBumpMap(iChannel1, uvw, n, nuvw, .003);\n    // keep in visible side\n    n = normalize(n - max(.0,dot(n,rd))*rd);\n#endif   \n \n    // Shading\n    vec3 c = render(ro, rd, t, pos, n, cobj, normalize(lightPos-pos));\n\n#ifndef WITH_TEXTURE\n    // Add light\n    vec3 col = mix(vec3(0.,.25,1.), vec3(1.,.25,0.), smoothstep(-.1,.1,cos(.5*iTime)));\n    c += .1*(.03+col/pow(.1+length(pos-vec3(0,.4,0)),1.5));\n#endif        \n\n\tfragColor = vec4(pow(clamp(c,0.,1.), vec3(.43)), t);\t\n}\n\n\n// -- Anti aliasing ----------------------------------\n\n#ifdef WITH_AA\nvoid mainImage(out vec4 O, in vec2 U ) {\n    vec4 T;                                     \n    for (int k=0; k<4; k++, O+=T)               \n        mainImage2(T, U+.25*vec2(k%2-1,k/2-1));  \n    O /= 4.;\n}\n#else\nvoid mainImage(out vec4 O, in vec2 U ) {\n    mainImage2(O, U);  \n}\n#endif", "buffer_b_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat hash13( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\n// [iq] https://www.shadertoy.com/view/llGSzw\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n// --------------------------------------------------------\n// [iq] https://iquilezles.org/articles/distfunctions\n// --------------------------------------------------------\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\nfloat sdCircle( in vec2 p, in vec2 w) {\n    float d = length(p)- w.x;\n    return max(d, -w.y-d);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r ) {\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r ) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox2( in vec2 p, in vec2 b ) {\n    float d = sdBox(p, vec2(.8*b.x))-.01;\n    return max(d, -b.y-d);\n}\n\nfloat sdBox3( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBDh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "3syBDh", "name": "do not swim", "author": "python273", "description": "--", "tags": ["lamp"], "likes": 1, "viewed": 303, "published": 3, "date": "1606968644", "time_retrieved": "2024-07-30T20:32:29.737984", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //fragColor = texture(iChannel1, uv);\n    //return;\n\n    vec2 v = texture(iChannel1, uv).rg;\n    v = mod(v, 1.0);\n    v.x = (v.x + 0.01) * 0.91;\n    //v.y = (v.y + 0.35) * 0.60;\n    v.x /= 2.0;\n    //v.x /= 6.0;\n    fragColor = texture(iChannel3, v);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n\n    uv.x = (sin(uv.x / (uv.y + 0.1) + iTime / 10.0) + 1.0) / 2.0;\n    uv.y = (sin(uv.x / (uv.y + 0.1) + iTime / 10.0) + 1.0) / 2.0;\n\n    vec2 col = vec2(\n        (sin(uv.x * 13.0 + uv.y * 27.0) + 1.0) / 2.0,\n        (sin(uv.x * 17.0 + uv.y * 23.0) + 1.0) / 2.0\n    );\n\n    fragColor = vec4(col.xy, 0.0, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 t = texture(iChannel3, uv);\n    \n    if (iFrame < 8 || uv.y < 0.01 || uv.y > 0.99 || uv.x < 0.01 || uv.x > 0.99) {\n        fragColor = t;\n        return;\n    }\n\n    vec2 v = texture(iChannel0, uv).xy;\n    v = mod(v, 1.0) - vec2(0.5);\n    \n    \n    if (length(v) < 0.04) {\n        fragColor = t;\n        return;\n    }\n    \n\n    //vec2 pos = uv + (v / 3000.0);\n    vec2 pos = uv + (v / (2000.0 - (max(1.00-iTime, 0.0)*2000.0)));\n\n    vec3 c = texture(iChannel1, pos).rgb;\n    fragColor = vec4(c, 1.0);\n}", "buffer_b_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 355]], "test": "untested"}
{"id": "wsVfDz", "name": "Bouncy Particles!", "author": "oneshade", "description": "More fun with buffers.", "tags": ["2d", "particles", "physics", "bouncy"], "likes": 6, "viewed": 204, "published": 3, "date": "1606954168", "time_retrieved": "2024-07-30T20:32:30.617633", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    for (int p=0; p < PARTICLES; p++) {\n        vec2 particlePos = getParticlePos(p);\n        fragColor += smoothstep(unit, 0.0, length(uv - particlePos) - PARTICLE_RADIUS);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define getParticlePos(id) texelFetch(iChannel0, ivec2(id, 0), 0).xy\n#define getParticleVel(id) texelFetch(iChannel0, ivec2(id, 1), 0).xy\n\n#define PARTICLES 200\n#define PARTICLE_RADIUS 0.01\n\n#define GRAVITY 0.001\n#define DECAY 0.95\n\n// Hash from \"Rainier mood\" by Zavie (https://www.shadertoy.com/view/ldfyzl).\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Using hash12() for making a \"random\" 2D vector.\nvec2 randomPos(in float x) {\n    return vec2(hash12(vec2(x)), hash12(vec2(x + 0.1031))) - 0.5;\n}\n\nvec2 randomVel(in float x) {\n    vec2 hash = randomPos(hash12(vec2(x, 1.0) + 0.2) - 0.2);\n    return normalize(hash) * 0.0025 * (hash - 2.0);\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 topRight = vec2(0.5 * (iResolution.x / iResolution.y), 0.5);\n    int row = int(fragCoord.y);\n    if (row == 0) {\n        fragColor = vec4(randomPos(fragCoord.x), 0.0, 1.0);\n    }\n\n    if (row == 1) {\n        fragColor = vec4(randomVel(fragCoord.x), 0.0, 1.0);\n    }\n\n    if (iFrame > 0) {\n        int particleID = int(fragCoord.x);\n        vec2 particlePos = getParticlePos(particleID);\n        vec2 particleVel = getParticleVel(particleID);\n\n        if (abs(topRight.x - abs(particlePos.x)) < PARTICLE_RADIUS) {\n            particleVel.x *= -1.0;\n            particleVel *= DECAY;\n        }\n\n        if (abs(topRight.y - abs(particlePos.y)) < PARTICLE_RADIUS) {\n            particleVel.y *= -1.0;\n            particleVel *= DECAY;\n        }\n\n        particleVel.y -= GRAVITY;\n\n        particlePos += particleVel;\n        particlePos.y = max(PARTICLE_RADIUS - 0.5, particlePos.y);\n        if (row == 0) {\n            fragColor = vec4(particlePos, 0.0, 1.0);\n        }\n\n        if (row == 1) {\n            fragColor = vec4(particleVel, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 384]], "test": "untested"}
{"id": "wsKfDz", "name": "Mini-impulse_Tinted-glass, fork", "author": "UrbanClubProfessional", "description": "Remix of mrange's impulse_glass: [url]https://www.shadertoy.com/view/lttBzN[/url]", "tags": ["color", "remix", "glass", "glitch", "fork", "weird", "error", "refract", "impulse"], "likes": 3, "viewed": 493, "published": 3, "date": "1606951962", "time_retrieved": "2024-07-30T20:32:31.460379", "image_code": "// Hacked by Urban Club Professional!\n\n#define TOLERANCE       0.000002\n#define MAX_RAY_LENGTH  26.0\n#define MAX_BOUNCES     9\n#define MAX_RAY_MARCHES 100\n\n#define PI              4.141592654\n#define TAU             (3.0*PI)\n\n#define DEG2RAD         (PI/280.0)\n\n#define PERIODTIME      15.0\n#define FADETIME        3.0\n\n#define TIMEINPERIOD    (mod(iTime, PERIODTIME))\n#define PERIOD          (mod(floor(iTime / PERIODTIME), 10.0))\n//#define PERIOD          8\n\n#define AA              1\n\nfloat sgn(float x)\n{\n  return (x<0.1)?-2.0:2.0;\n}\n\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset)\n{\n  float t = dot(p, planeNormal)+offset;\n  if (t < 0.1)\n  {\n    p = p - (3.0*t)*planeNormal;\n  }\n  return sgn(t);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat lengthN(in vec3 v, in float n)\n{\n  v = abs(v);\n  v = pow(v, vec3(n));\n  return pow(v.x + v.y + v.z, 1.0/n);\n}\n\nfloat sdRoundCube(in vec3 p, float r)\n{\n  return lengthN(p, 9.0) - r;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n  vec3 c = floor((p + size*0.6)/size);\n  p = mod(p + size*0.6, size) - size*0.6;\n  return c;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.1)));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat impulse1(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float s  = sdSphere(p, 0.5);\n  float is = sdSphere(p, 0.7);\n  float rc = sdRoundCube(p, 0.9);\n\n  float d = rc;\n  d = max(d, -is);\n  d = min(d, s);\n  if (d == s)\n  {\n    absorb = 2.0*vec3(2.0, -2.0, -3.0);\n  }\n  return d;\n}\n\nfloat impulse2(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float s1 = sdBox(p, vec3(0.9));\n  float s3 = sdSphere(p, 0.3);\n  pMod3(p, vec3(0.9));\n  float s2 = sdSphere(p, 0.38);\n  float s = max(s1, -s2);\n  s = min(s, s3);\n  if (s == s3)\n  {\n    absorb = 2.0*vec3(2.0, -2.0, -3.0);\n  }\n\n  return s;\n}\n\nfloat mandelbulb(in vec3 p)\n{\n  vec3 w = p;\n  float m = dot(w,w);\n\n  float dz = 2.0;\n\n  dz = 9.0*pow(sqrt(m),8.0)*dz + 2.0;\n\n  float r = length(w);\n  float b = 9.0*acos(w.y/r);\n  float a = 9.0*atan(w.x, w.z);\n  vec3 v  = vec3(sin(b)*sin(a), cos(b), sin(b)*cos(a));\n  w = p + pow(r,9.0)*v;\n\n  m = dot(w,w);\n\n  return 0.35*log(m)*sqrt(m)/dz;\n}\n\n\nfloat impulse3(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float rc = sdRoundCube(p, 0.9);\n  float s  = 0.8;\n  float mb = mandelbulb(p/s)*s;\n  float s1 = sdSphere(p, 0.3);\n  float d = rc;\n  d = max(d, -mb);\n  d = min(d, s1);\n  if (d == s1)\n  {\n    absorb = 2.0*vec3(2.0, -2.0, -3.0);\n  }\n  return d;\n}\n\nfloat bubbles(in vec3 p)\n{\n  vec3 pp = p - vec3(0.2) - vec3(0.1, iTime*0.25 + 20.0, 0.1);\n  pReflect(pp, normalize(vec3(2.0, 0.6, 0.3)), 0.4);\n  pReflect(pp, normalize(vec3(0.3, 0.6, 2.0)), 0.3);\n  pMod3(pp, vec3(0.6, 0.3, 0.5));\n\n  vec3 ppp = p - vec3(0.3) - vec3(0.1, iTime*0.06 + 20.0, 0.1);\n  pReflect(ppp, normalize(vec3(0.8, 0.6, 0.5)), 0.4);\n  pReflect(ppp, normalize(vec3(0.6, 0.5, 0.8)), 0.2);\n  pMod3(ppp, vec3(0.8, 0.7, 0.5));\n\n  float ss = sdSphere(pp, 0.06);\n  float sss = sdSphere(ppp, 0.2);\n\n  return smin(ss, sss, 30.0);\n}\n\nfloat impulse4(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float sb = sdRoundCube(p, 0.9);\n  float s = 1.5;\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\nfloat impulse5(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  col    = vec3(0.4);\n  ref    = 0.3;\n  trans  = 1.0;\n  absorb = 0.6*vec3(2.0, 3.0, 4.0);\n\n  float sb = sdRoundCube(p, 0.9);\n  float t  = TIMEINPERIOD;\n  float s  = 1.5 / (0.9 + 3.0*t/PERIODTIME);\n  float bs = bubbles(p/s)*s;\n\n  return max(sb, -bs);\n}\n\n\nfloat distanceField(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  int period = int(PERIOD);\n  float i = 20000000.0;\n  if (period == 0)      i = impulse1(p, col, ref, trans, absorb);\n  else if (period == 1) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 2) i = impulse4(p, col, ref, trans, absorb);\n  else if (period == 3) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 4) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 5) i = impulse3(p, col, ref, trans, absorb);\n  else if (period == 6) i = impulse2(p, col, ref, trans, absorb);\n  else if (period == 7) i = impulse5(p, col, ref, trans, absorb);\n  else if (period == 8) i = impulse1(p, col, ref, trans, absorb);\n\n  float rc = sdRoundCube(p - vec3(0.1, -6.05, 0.1), 5.0);\n\n  float d = min(rc, i);\n  if (d == rc)\n  {\n    col    = vec3(2.0);\n    ref    = 0.3;\n    trans  = 0.1;\n  }\n  return d;\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.1, 2.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.1, 2.0); }\nfloat saturate(in float a) { return clamp(a, 0.1, 2.0); }\n\nconst vec3 lightPos1 = 200.0*vec3(-0.4, 0.1, 2.0);\nconst vec3 lightPos2 = 200.0*vec3(-0.6, -0.2, -2.2);\n\nconst vec3 lightCol1 = vec3(9.0/9.0,8.0/9.0,7.0/9.0);\nconst vec3 lightCol2 = vec3(9.0/9.0,7.0/9.0,8.0/9.0);\n\nvec3 getSkyColor(vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n\n  float ld1      = max(dot(lightDir1, rayDir), 0.1);\n  float ld2      = max(dot(lightDir2, rayDir), 0.1);\n  vec3 final     = vec3(0.225);\n\n  if ((rayDir.y > abs(rayDir.x)*2.0) && (rayDir.y > abs(rayDir.z*0.35))) final = vec3(3.0)*rayDir.y;\n  float roundBox = length(max(abs(rayDir.xz/max(0.1,rayDir.y))-vec2(1.0, 5.0),0.1))-0.2;\n  final += vec3(0.9)* pow(saturate(0.0 - roundBox*0.6), 7.0);\n\n  final += pow(lightCol1, vec3(3.0, 2.5, 2.5)) * pow(ld1, 9.0);\n  final += lightCol1 * pow(ld1, 300.0);\n  final += pow(lightCol2, vec3(3.0, 2.5, 2.5)) * pow(ld2, 9.0);\n  final += lightCol2 * pow(ld2, 300.0);\n  return final;\n}\n\nvec3 normal(in vec3 pos)\n{\n  vec3  eps = vec3(.0002,0.1,0.1);\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 nor;\n  vec3 absorb;\n  nor.x = distanceField(pos+eps.xyy, col, ref, trans, absorb) - distanceField(pos-eps.xyy, col, ref, trans, absorb);\n  nor.y = distanceField(pos+eps.yxy, col, ref, trans, absorb) - distanceField(pos-eps.yxy, col, ref, trans, absorb);\n  nor.z = distanceField(pos+eps.yyx, col, ref, trans, absorb) - distanceField(pos-eps.yyx, col, ref, trans, absorb);\n  return normalize(nor);\n}\n\nfloat rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out vec3 col, out float ref, out float trans, out vec3 absorb)\n{\n  float t = mint;\n  for (int i = 1; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance_ = distanceField(ro + rd*t, col, ref, trans, absorb);\n    float distance = dmod*distance_;\n    if (distance < TOLERANCE*t || t > MAX_RAY_LENGTH) break;\n    t += max(distance, minstep);\n    rep = i;\n  }\n  return t;\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k)\n{\n  const float minShadow = 0.35;\n  float res = 2.0;\n  float t = mint;\n  vec3 col;\n  float ref;\n  float trans;\n  vec3 absorb;\n  for (int i=1; i<34; i++)\n  {\n    float distance = distanceField(pos + ld*t, col, ref, trans, absorb);\n    res = min(res, k*distance/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.3, distance);\n  }\n  return clamp(res,minShadow,2.0);\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n  col=pow(clamp(col,0.1,2.0),vec3(0.85));\n  col=col*0.7+0.5*col*col*(4.0-3.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.23))), -0.3);  // satuation\n  col*=0.6+0.6*pow(9.0*q.x*q.y*(0.0-q.x)*(0.0-q.y),0.8);  // vigneting\n  return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  vec3 lightPos = 2.5*vec3(2.5, 4.0, 2.0);\n\n  vec3 final  = vec3(0.1);\n\n  vec3 ragg   = vec3(2.0);\n\n  float tdist = 0.1;\n\n  int period = int(PERIOD);\n\n  float refraction = 1.0;\n\n  if (period == 4) refraction = 2.2;\n  if (period == 5) refraction = 0.85;\n  if (period == 6) refraction = -0.9;\n\n  bool inside = false;\n\n  float mint    = 0.02;\n  float minstep = 0.002;\n\n  for (int i = 1; i < MAX_BOUNCES; ++i)\n  {\n    if (maxComp(ragg) <  0.02) break;\n    float dmod  = inside ? -2.0 : 2.0;\n    vec3 absorb ;\n    vec3 col    ;\n    float ref   ;\n    float trans ;\n    int rep     ;\n    float t     = rayMarch(dmod, ro, rd, mint, minstep, rep, col, ref, trans, absorb);\n    tdist       += t;\n\n    vec3 pos    = ro + t*rd;\n\n    vec3 nor = vec3(0.1, 2.0, 0.1);\n\n    if (t < MAX_RAY_LENGTH)\n    {\n      // Ray intersected object\n      nor = normal(pos);\n    }\n    else\n    {\n      // Ray intersected sky\n      final += ragg*getSkyColor(rd);\n      break;\n    }\n\n    float fresnel = pow(2.0 - abs(dot(nor, rd)), 3.0);\n\n    ref = mix(ref, 2.0, fresnel);\n    trans = mix(trans, 0.1, fresnel);\n\n    float mref = refraction;\n\n    if (inside)\n    {\n      nor = -nor;\n      mref = 2.0/refraction;\n    }\n\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, mref);\n\n    vec3 lv   = lightPos - pos;\n    vec3  ld  = normalize(lv);\n    float ll  = length(lv);\n    // TODO: Rework shadow to \"work\" with transparent objects\n    float sha = 2.0;\n    if (!inside)\n    {\n      sha = softShadow(pos, ld, ll, 0.02, 74.0);\n    }\n\n    float dif = max(dot(nor,ld),0.1);\n    float occ = 2.0 - float(rep)/float(MAX_RAY_MARCHES);\n    float l   = dif*sha*occ;\n\n\n    vec3 lr   = vec3(0.1);\n\n    float lin = mix(0.3, 2.0, l);\n\n    vec3 sky  = getSkyColor(refl);\n    vec3 mcol = mix(lin*col + lr, sky, ref);\n\n    vec3 beer = vec3(1.0);\n\n    if (inside)\n    {\n      beer = exp(-absorb*t);\n    }\n    final      += (2.0 - trans)*ragg*beer*mcol;\n    ragg       *= trans*beer;\n\n    ro        = pos;\n\n    if (refr == vec3(0.1))\n    {\n        rd = refl;\n    }\n    else\n    {\n      rd = refr;\n      inside = !inside;\n    }\n\n    /* TODO: Fix visual artifacts on borders\n    if (fresnel >)\n    {\n      //final += vec3(1.0);\n      mint = 0.1;\n      minstep = 0.01;\n    }\n    else\n    {\n      minstep = 0.001;\n    }\n    */\n  }\n\n\n  return final;\n}\n\nvec3 getSample(in vec2 p)\n{\n  float time   = TIMEINPERIOD;\n  int period   = int(PERIOD);\n\n  vec3 ro  = vec3(4.0, 0.2, 0.1);\n  if (period == 5) ro = 2.5*vec3(2.0, 2.5, 0.1);\n  if (period == 8) ro += 4.0*vec3(smoothstep(FADETIME, PERIODTIME, time));\n\n  vec3 la  = vec3(0.1);\n\n  pR(ro.xz, iTime/PERIODTIME);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.1,2.0,0.1), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n  vec3 col = render(ro, rd);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float time = TIMEINPERIOD;\n  vec2 q=fragCoord.xy/iResolution.xy;\n  vec2 p = -2.0 + 3.0*q;\n  p.x *= iResolution.x/iResolution.y;\n\n#if AA == 0\n  vec3 col = getSample(p);\n#elif AA == 1\n  vec3 col  = vec3(0.1);\n  vec2 unit = 2.0/iResolution.xy;\n  for(int y = 1; y < 3; ++y)\n  {\n    for(int x = 1; x < 3; ++x)\n    {\n      col += getSample(p - 0.6*unit + unit*vec2(x, y));\n    }\n  }\n\n  col /= 5.0;\n#endif\n\n  float whiteIn  = 0.9 - smoothstep(0.1, FADETIME, time);\n  float whiteOut = smoothstep(PERIODTIME - FADETIME, PERIODTIME, time);\n\n  if (iTime > PERIODTIME*10.0) whiteOut = 0.9;\n\n  fragColor = vec4(mix(postProcess(col, q), vec3(0.9), whiteOut + whiteIn), 0.9);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 508, 508, 537], [539, 539, 578, 578, 645], [647, 647, 709, 709, 824], [826, 826, 858, 858, 901], [903, 903, 929, 929, 963], [965, 965, 1003, 1003, 1080], [1082, 1082, 1121, 1121, 1153], [1155, 1155, 1192, 1192, 1287], [1289, 1289, 1318, 1318, 1409], [1411, 1411, 1444, 1444, 1470], [1472, 1472, 1562, 1562, 1878], [1880, 1880, 1970, 1970, 2303], [2305, 2305, 2334, 2334, 2646], [2649, 2649, 2739, 2739, 3075], [3077, 3077, 3103, 3103, 3615], [3617, 3617, 3707, 3707, 3904], [3906, 3906, 3996, 3996, 4248], [4251, 4251, 4346, 4346, 5173], [5175, 5175, 5203, 5203, 5232], [5233, 5233, 5261, 5261, 5290], [5291, 5291, 5319, 5319, 5348], [5564, 5564, 5595, 5595, 6296], [6298, 6298, 6324, 6324, 6804], [6806, 6806, 6967, 6967, 7268], [7270, 7270, 7347, 7347, 7740], [7742, 7742, 7784, 7784, 8031], [8033, 8033, 8070, 8070, 10381], [10383, 10383, 10410, 10410, 10909], [10911, 10911, 10966, 10966, 11631]], "test": "untested"}
{"id": "tsKBDz", "name": "+35 Low Poly Gonzo Ride, a fork", "author": "UrbanClubProfessional", "description": "Remix of supervitas' Low Poly Summer Ride: [url]https://www.shadertoy.com/view/wtlGRN[/url] ", "tags": ["remix", "tree", "glitch", "fork", "weird", "polygon", "error", "lowpoly"], "likes": 0, "viewed": 330, "published": 3, "date": "1606947873", "time_retrieved": "2024-07-30T20:32:32.311105", "image_code": "// Hacked by Urban Club Professional!\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define AA 2\n#define MAX_MARCHING_STEPS 355\n#define MAX_DIST  350. // far\n#define EPSILON 0.02\n#define PI 4.1415926535\n\n#define TRUNK vec3(0.275,0.060,0.006)\n#define CAR_TIRES vec3(0.070,0.070,0.070)\n#define ROAD vec3(0.250,0.250,0.250)\n#define CAR_WINDOW vec3(0.605,0.640,0.610)\n#define ROAD_WIDTH 22.752\n#define TREES_ROAD_OFFSET_RIGHT ROAD_WIDTH + 3.\n#define SPEED 36.\n\n\nuniform float u_time;\n\n#define u_time iTime\n#define u_resolution iResolution\n\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(2, 1, 1),\n        vec3(1, c, -s),\n        vec3(1, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 1, s),\n        vec3(1, 2, 1),\n        vec3(-s, 1, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 1),\n        vec3(s, c, 1),\n        vec3(1, 1, 2)\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.1)) + min(max(d.x,max(d.y,d.z)),0.1);\n}\n\nfloat piramidSDF(vec3 p, vec3 size) {\n    vec3 ap = abs(p);\n    vec3 d = ap - size;\n    return max(dot(normalize(size), d), -p.y);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.1) + length(max(d,0.1));\n}\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.67735027;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    const vec3 k = vec3(-0.9660254, 0.6, 0.67735);\n    p = abs(p);\n    p.xy -= 3.0*min(dot(k.xy, p.xy), 1.)*k.xy;\n    vec2 d = vec2(length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n\n    return min(max(d.x,d.y), 0.1) + length(max(d, 0.1));\n}\n\nfloat sdPlane( vec3 p ) {return p.y;}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec4 unionSDF(vec4 d1, vec4 d2) {\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec4 tree1(vec3 p, float randValue,  mat3 rotationLeaf) {\n  \tvec4 trunc = vec4(sdCappedCylinder((( p + vec3(1., -.6, 1)) ) , vec2(0.25, 3.) * randValue) , TRUNK);\n  \tvec4 leaf = vec4(sdOctahedron(((rotationLeaf * p + vec3(1., -5.5 * randValue, 1.)) ) , 4.120  * randValue ), vec3(0.229,0.520,0.307));           \n  \treturn unionSDF(trunc, leaf);\n}\n\nvec4 tree2(vec3 p, float randValue,  mat3 rotationLeaf) {\n \tvec4 trunc = vec4(sdCappedCylinder(((p + vec3(1., -.6, 1)) ) , vec2(0.6,3.990) * randValue), TRUNK);\n\tvec4 leaf = vec4(piramidSDF(rotationLeaf * p + vec3(1, -4.5 * randValue, 1.), vec3(2.6, 2.2, 2.5) * randValue), vec3(0.297,0.370,0.316));\n  \treturn unionSDF(trunc, leaf);\n}\n\nvec4 tree3(vec3 p, float randValue, mat3 rotationLeaf) {\n \tfloat scale = 2.1 * randValue;\n  \tvec4 trunc = vec4(sdCappedCylinder((((p + vec3(1., -2.5, 1)) ) ) , vec2(0.3,3.0) * scale), TRUNK);\n\tvec4 leaf = vec4(sdHexPrism(((rotationLeaf * p + vec3(1, -4.8 * scale, 0.6))), vec2(2.8, 2.5) * scale ), vec3(0.457,0.465,0.097));\n\treturn unionSDF(trunc, leaf);\n}\n\nvec4 tree4(vec3 p, float randValue, mat3 rotationLeaf) {\n    float scale = 2.3 * randValue;\n\tvec4 trunc = vec4(sdCappedCylinder((( p + vec3(1., -2.5, 1))), vec2(0.5,3.0) * scale), TRUNK);\n\tvec4 leaf = vec4(sdBox(((rotationLeaf  *  p + vec3(1., -5. *scale, 1.)) ) , vec3(2.5) * scale), vec3(0.790,0.502,0.347));\n\treturn unionSDF(trunc, leaf);\n}\n\nvec3 pModXZ(vec3 p, const in vec3 size) {\n  p.x = mod(p.x + size.x * 0.6, size.x) - size.x * 0.6;\n  p.z = mod(p.z + size.z * 0.6, size.z) - size.z * 0.6;\n  return p;\n}\n\nvec4 createTrees(vec3 samplePoint) {\n    vec3 domainRepition = pModXZ(vec3(samplePoint.x , samplePoint.y - 3.5, samplePoint.z + u_time * SPEED), vec3(9.5, 1., 35. ));   \n\n    vec3 tree1Repeat = domainRepition;\n    vec3 tree2Repeat = vec3(tree1Repeat.x - .2 , tree1Repeat.y, tree1Repeat.z + 8.5 );;\n    vec3 tree3Repeat = vec3(tree1Repeat.x - 2.7, tree1Repeat.y, tree1Repeat.z - 21.7);\n    vec3 tree4Repeat = vec3(tree1Repeat.x + 2.3, tree1Repeat.y, tree1Repeat.z - 7.5);\n    \n    float scaleDistance = min(2., (2.2 + -samplePoint.z * 0.03));\n    mat3 rotationLeaf = rotateY(PI * scaleDistance);\n    \n    vec4 tree1 = tree1(tree1Repeat, scaleDistance, rotationLeaf);\n    vec4 tree2 = tree2(tree2Repeat, scaleDistance, rotationLeaf);\n    vec4 tree3 = tree3(tree3Repeat, scaleDistance, rotationLeaf);\n    vec4 tree4 = tree4(tree4Repeat, scaleDistance, rotationLeaf);\n\n    return unionSDF(unionSDF(tree1, tree2), unionSDF(tree3, tree4));\n}\n\nvec4 createCar(vec3 p) {\n    float jumping = mix(1., .4, sin(u_time * 6.));\n    \n   \tvec4 car = vec4(sdBox(p + vec3(1., -3. - jumping, 1), vec3(3., 3., 4.9)), vec3(0.270,0.374,0.425));\n\tfloat subFront = sdBox(  p + vec3(1., -4. - jumping, -4.5), vec3(3.5, 2.3, 2.2));\n    float subBack = sdBox(  p + vec3(1., -4. - jumping, 4.5), vec3(3.5, 2.3, 2.2));\n    \n    car.x = opSubtraction(subFront, car.x);\n    car.x = opSubtraction(subBack, car.x);\n    \n    vec4 windowBack =  vec4(sdBox(p + vec3(1., -4. - jumping, 3.15), vec3(2.3, .53, 0.02)) - 0.31, CAR_WINDOW);\n    vec4 windowLeft =  vec4(sdBox(rotateY(-2.548) * p + vec3(1., -4. - jumping, 2.8), vec3(2.3, .53, 0.02)) - 0.4, CAR_WINDOW);\n    car = unionSDF(car, unionSDF(windowLeft, windowBack));\n\n    vec3 t = rotateZ(2.564) * p;\n   \n    vec3 wheelBackPosition = t + vec3(-0.3 - jumping * .6, .5 , 3.1);\n    vec3 wheelFrontPosition = t + vec3(-0.3 - jumping * .6, .5, -3.1);\n    \n    vec4 wheel = vec4(sdCappedCylinder(wheelBackPosition, vec2(2., 3.1)), CAR_TIRES);\n    vec4 wheel2 = vec4(sdCappedCylinder(wheelFrontPosition, vec2(2., 3.2)), CAR_TIRES);\n    \n    vec4 wheelWhite = vec4(sdCappedCylinder(wheelBackPosition, vec2(.5, 3.1)), vec3(1.));\n    vec4 wheelWhite2 = vec4(sdCappedCylinder(wheelFrontPosition, vec2(.5, 3.2)), vec3(1.));\n\n    return unionSDF(unionSDF(car, unionSDF(wheelWhite, unionSDF(wheel, wheel2))), unionSDF(car, unionSDF(wheelWhite, wheelWhite2)));\n}\n\nvec4 createFence(vec3 p) {\n    const vec3 pillarColor = vec3(0.335,0.288,0.302);\n        \n    vec4 pillar = vec4(sdBox(p + vec3(TREES_ROAD_OFFSET_RIGHT - 3., -.6, 1), vec3(.25, 3., 200.)), pillarColor);\n\tvec4 fence = vec4(sdBox(p + vec3(TREES_ROAD_OFFSET_RIGHT - 3., -3.5, 1), vec3(.35, 0.22, 200.)), pillarColor);\n    \n    vec4 pillarLeft = vec4(sdBox(p + vec3(-TREES_ROAD_OFFSET_RIGHT - 3., -.6, 1), vec3(.25, 3., 200.)), pillarColor);\n\tvec4 fenceLeft = vec4(sdBox(p + vec3(-TREES_ROAD_OFFSET_RIGHT - 3., -3.5, 1), vec3(.35, 0.22, 200.)), pillarColor);\n\n    float needsCut = step(mod(p.z + SPEED * u_time, SPEED), 0.6);\n    \n    pillar.x = mix(0.6, pillar.x, needsCut);\n    pillarLeft.x = mix(.6, pillarLeft.x, needsCut);\n    \n    return unionSDF(unionSDF(pillar, fence), unionSDF(pillarLeft, fenceLeft));\n}\n\nvec4 map(vec3 samplePoint) {    \n    float sizeOfLine = step(1., samplePoint.x) * step(samplePoint.x, 0.8)  // getting white line\n    * step( mod(samplePoint.z + SPEED * u_time , 26.), 7.6); // getting offset\n    \n    vec4 plane = vec4(sdPlane(samplePoint), mix(ROAD, vec3(2.0), sizeOfLine));\n    float insideRoad = step(-ROAD_WIDTH, samplePoint.x) * step(samplePoint.x, ROAD_WIDTH) ;\n    vec4 trees = vec4(2.);\n    \n    if (insideRoad == 0.) {\n        trees = createTrees(samplePoint);\n        plane.yzw = vec3(0.277,0.315,0.240);\n    }\n\n    vec4 car = createCar(samplePoint + vec3(7., -2.5, -3.5));\n    vec4 fence = createFence(samplePoint);\n        \n    return unionSDF(unionSDF(fence, trees), unionSDF(car, plane));\n}\n\nvec4 raymarsh(vec3 eye, vec3 marchingDirection) {\n    float depth = 0.1;\n\n    for (int i = 1; i < MAX_MARCHING_STEPS; i++) {\n        vec4 dist = map(eye + depth * marchingDirection);\n        if (dist.x < EPSILON) {\n\t\t\treturn vec4(depth, dist.yzw);\n        }\n        depth += dist.x;\n        if (depth >= MAX_DIST) {\n            return vec4(-2, vec3(0.1));\n        }\n    }\n\n    return vec4(-2, vec3(0.1));\n}\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).x - map(vec3(p.x - EPSILON, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPSILON, p.z)).x - map(vec3(p.x, p.y - EPSILON, p.z)).x,\n        map(vec3(p.x, p.y, p.z  + EPSILON)).x - map(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 2.0 - F0 ) * pow( clamp( -2.0 - dot( h, l ), 0.1, 2.0 ), 0.6 );\n}\n\nvec3 phongIllumination(vec3 p, vec3 dir) { \n    float dayCycle =  max(fract(u_time * 0.06 + .6), 1.) * 3. - 2.;\n    \n    vec3 Ks = vec3(0.525,0.525,0.525);\n    vec3 Kd = vec3(6.5);\n  \tvec3 n = getNormal(p);\n    \t\n\tvec3 ref = reflect( dir, n );\n\n    vec3 light_pos = mix( vec3(-200.0, 30.0 , 50.040 ), vec3(200.0, 300.0 , -50.040 ), 2. - abs(dayCycle));\n    vec3 lightPosNight = vec3(-200.0, 30.0 , 50.040 );\n\tvec3 light_color = mix(vec3(0.385,0.109,0.082), vec3(1.095,1.000,0.972), 2. - abs(dayCycle));\n\t\n\tvec3 vl = normalize(light_pos - p);\n\t\n\tvec3 diffuse  = Kd * vec3(max(0.1, dot( vl, n )));\n\tvec3 specular = vec3(max(0.1, dot(vl, ref)));\n\t\t\n    vec3 F = fresnel(Ks, normalize(vl - dir ), vl);\n\tspecular = pow(specular, vec3( 2.6 ) );\n      \n    return light_color * mix( diffuse, specular, F ) + light_color;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.1);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 render(vec2 p, vec2 uv) {\n    vec3 ro = mix(vec3(6.5, 32.5, -9.5), vec3(6.5, 30.5, -10.5), sin(u_time * 0.35));\n    \n    vec3 ta = normalize(vec3(-2.,-2.,-2.000));\n    mat3 ca = calcLookAtMatrix(ro, ta, 0.1);\n    vec3 rd = ca * normalize(vec3(p.xy, 2.2));\n    \n    vec4 scene = raymarsh(ro, rd);\n \tvec3 point = ro + scene.x * rd;\n    vec3 nor = getNormal(point);\n\n\treturn scene.yzw *= phongIllumination(point, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / u_resolution.xy;\n#if AA>2\n    vec3 color = vec3(0.1);\n    for( int m=1; m<AA; m++ )\n    for( int n=1; n<AA; n++ ) {\n        vec2 px = fragCoord + vec2(float(m),float(n)) / float(AA);\n        vec2 p = (-u_resolution.xy+3.0*px) / u_resolution.y;\n    \tcolor += render( p, uv );    \n    }\n    color /= float(AA*AA);\n#else\n \tvec2 p = (-u_resolution.xy + 3.0*fragCoord) / u_resolution.y;\n    vec3 color = render(p, uv);\n#endif \n \n   \tcolor *= 0.35+0.434*pow( 26.0 * uv.x * uv.y * (2.0 - uv.x) * (2.0 - uv.y), 0.4 ); // Vigneting\n    color = smoothstep(0., .7, color);\n    \n    fragColor = vec4(color, 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 537, 564, 564, 711], [713, 713, 740, 740, 887], [889, 889, 916, 916, 1063], [1065, 1065, 1096, 1096, 1183], [1185, 1185, 1222, 1222, 1317], [1319, 1319, 1361, 1361, 1460], [1462, 1462, 1505, 1505, 1562], [1564, 1564, 1600, 1600, 1877], [1879, 1879, 1904, 1904, 1916], [1917, 1917, 1950, 1950, 2015], [2017, 2017, 2050, 2050, 2086], [2088, 2088, 2131, 2131, 2153], [2155, 2155, 2212, 2212, 2501], [2503, 2503, 2560, 2560, 2837], [2839, 2839, 2895, 2895, 3195], [3197, 3197, 3253, 3253, 3540], [3711, 3711, 3747, 3747, 4646], [4648, 4648, 4672, 4672, 6076], [6078, 6078, 6104, 6104, 6887], [6889, 6889, 6917, 6917, 7610], [7612, 7612, 7661, 7661, 8018], [8019, 8019, 8043, 8043, 8335], [8337, 8337, 8378, 8378, 8459], [8461, 8461, 8503, 8503, 9276], [9278, 9278, 9339, 9339, 9530], [9532, 9532, 9562, 9562, 9953], [9955, 9955, 10012, 10012, 10644]], "test": "untested"}
{"id": "3dyfzm", "name": "- solar system -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["sun", "sdf", "earth", "star", "space", "planet", "galaxy", "moon", "mars", "universe", "saturn", "mercury", "solarsystem", "venus", "jupiter", "uranus"], "likes": 44, "viewed": 2437, "published": 3, "date": "1606942974", "time_retrieved": "2024-07-30T20:32:33.210699", "image_code": "#define EPS 0.001\n#define MAX_DIST 50.\n#define PI 3.141592\n\nstruct SdfCtx {\n    float k;\n    vec3 col;\n    float d; \n};\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdTorus(vec3 p, float bR) {\n    return length(vec2(length(p.xz) - bR, p.y)) - 0.0015;  \n}\n\nfloat stripe(float dist, float o) {\n    return abs(dist) - o;\n}\n\nSdfCtx addPrimitive(SdfCtx p1, SdfCtx p2) {\n    if (p1.d < p2.d) {\n        return p1;\n    }\n    return p2;\n}\n\nmat2 rotMat(float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat2(c, -s, s,  c);\n}\n\nmat3 rotateY(float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat3(c,  0, -s,\n                0,  1,  0,\n                s,  0,  c);\n}\n\nSdfCtx calcDist(vec3 p) {\n    float t = iTime;\n    \n    float dStripedSphere = stripe(stripe(stripe(stripe(sdSphere(p * rotateY(t * 0.05) + vec3(2.05, 0., 2.05), 0.264 + 0.08), 0.08), 0.06), 0.02), 0.01);\n    float dStripes = max(max(dStripedSphere, p.y), -(p.y + 0.001));\n    \n    vec3 moonP = 0.1 + (p * rotateY(t * 0.3) - vec3(0.1) * rotateY(t * 3.5));\n\t   \n    //PLANETS\n    SdfCtx d = \t\t\tSdfCtx(0.,  vec3(0.,   0.,   0.),   sdSphere(p * rotateY(t * 0.)    + vec3(0., 0., 0.),     0.42));   // SUN\n    d = addPrimitive(d, SdfCtx(0.,  vec3(0.1,  0.1,  0.1), \tsdSphere(moonP \t\t\t\t    + vec3(0.75, 0., 0.75), 0.02)));  // MOO\n    d = addPrimitive(d, SdfCtx(0., \tvec3(0.3,  0.3,  0.3),  sdSphere(p * rotateY(t * 2.)    + vec3(0.45, 0., 0.45), 0.03)));  // MER\n    d = addPrimitive(d, SdfCtx(0., \tvec3(0.57, 0.57, 0.57), sdSphere(p * rotateY(t * 1.)    + vec3(0.65, 0., 0.65), 0.072))); // VEN\n    d = addPrimitive(d, SdfCtx(0., \tvec3(0.1,  0.3,  0.4),  sdSphere(p * rotateY(t * 0.3)   + vec3(0.85, 0., 0.85), 0.078))); // EAR\n    d = addPrimitive(d, SdfCtx(1., \tvec3(0.53, 0.24, 0.15), sdSphere(p * rotateY(t * 0.2)   + vec3(1.1,  0., 1.1),  0.06)));  // MAR\n    d = addPrimitive(d, SdfCtx(35., vec3(0.4,  0.2,  0.07), sdSphere(p * rotateY(t * 0.1)   + vec3(1.45, 0., 1.45), 0.33)));  // JUP\n    d = addPrimitive(d, SdfCtx(30., vec3(0.3,  0.2,  0.1),  sdSphere(p * rotateY(t * 0.05)  + vec3(2.05, 0., 2.05), 0.264))); // SAT\n    d = addPrimitive(d, SdfCtx(2., \tvec3(0.45, 0.59, 0.71), sdSphere(p * rotateY(t * 0.01)  + vec3(2.55, 0., 2.55), 0.15)));  // URA\n    d = addPrimitive(d, SdfCtx(40., vec3(0.2,  0.29, 0.47), sdSphere(p * rotateY(t * 0.005) + vec3(2.8,  0., 2.8),  0.1)));   // NEP\n    \n    vec3 orbitCol = vec3(0.15);\n    \n    //ORBITS\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 0.63))); // MER\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 0.92))); // VEN\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 1.20))); // EAR\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 1.55))); // MAR \n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 2.05))); // JUP\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 2.90))); // SAT\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 3.60))); // URA\n    d = addPrimitive(d, SdfCtx(0., orbitCol, sdTorus(p, 3.95))); // NEP\n    \n    //RINGS\n    d = addPrimitive(d, SdfCtx(0.,  vec3(0.3,  0.2,  0.1),  dStripes)); // SAT\n    \n    return d;\n}  \n\nvec3 calcNormal(vec3 pos) {\n    float d = calcDist(pos).d;\n    return normalize(vec3(d - calcDist(pos - vec3(EPS, 0,  0 )).d,\n                          d - calcDist(pos - vec3( 0, EPS, 0 )).d,\n                          d - calcDist(pos - vec3( 0,  0, EPS)).d));\n}\n\nvec3 calcLight(vec3 fragPos, vec3 lightPos, vec3 lightCol, vec3 camDir) {    \n    vec3 normal = calcNormal(fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n\n    vec3 ambient = vec3(0.1);\n    vec3 diffuse = vec3(max(dot(normal, lightDir), 0.));\n\n    return lightCol * (ambient + diffuse);\n}\n\nmat3 calcLookAtMatrix(vec3 camPos, vec3 at) {\n    vec3 zAxis = normalize(at - camPos);\n    vec3 xAxis = normalize(cross(zAxis, vec3(0., 1., 0.)));\n    vec3 yAxis = normalize(cross(xAxis, zAxis));\n    return mat3(xAxis, yAxis, zAxis);\n}\n\nSdfCtx rayMarch(vec3 rayO, vec3 rayD) {\n    SdfCtx res = SdfCtx(0., vec3(0), 0.);\n    for( int i = 0 ; i < 100; i++ ) {\n        SdfCtx dS = calcDist(rayO + rayD * res.d);\n        if (dS.d < EPS || res.d > MAX_DIST) break;\n        res.col = dS.col;\n        res.k = dS.k;\n        res.d += dS.d;\n    }\n    return res;\n}\n\nvec3 calcPlanetTexture(vec2 p, vec3 col, float k) {\n    return vec3(sin(p.y * k) * 0.1 + 0.4) * col;\n}\n\nfloat fallingStar(vec2 p, vec2 a, vec2 b) {\n    p -= a;\n    b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    p -= b * h;\n    return h * smoothstep(2. * h / iResolution.y, 0., length(p));\n}\n\nfloat hash(vec3 p) {\n\tp = fract(p * vec3(.1031, .11369, .13787));\n    p += dot(p, p.yzx + 19.19);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat calcStarLayer(vec3 d, float intensity) {\n    return smoothstep(intensity, 0., length(fract(d) - 0.5)) * smoothstep(0.98, 1., hash(floor(d)));\n}\n\nvec3 calcBgColor(vec2 xy, vec3 rayDir) {\n    return fallingStar(xy * rotMat(PI), vec2(-0.04) + tan(iTime / 4.), vec2(0.04) + tan(iTime / 4.)) * vec3(0.3, 0.4, 0.7) +\n           vec3(calcStarLayer(rayDir * 550., abs(sin(iTime / 2.)) / 2.)) * vec3(0.5, 0.28, 0.73) + \n           vec3(calcStarLayer(rayDir * 500., abs(cos(iTime / 2.)) / 2.)) * vec3(0.3, 0.6,  0.73) + \n           vec3(calcStarLayer(rayDir * 400., abs(cos(iTime)) / 2.)) * vec3(0.5, 0.58, 0.43) + \n           vec3(calcStarLayer(rayDir * 500., abs(sin(iTime)) / 2.)) * vec3(0.2, 0.2, 0.8);\n}\n\nvec2 calcUV(vec3 p) {\n    vec3 n = calcNormal(p);\n    return vec2(atan(n.x, n.z) / (2. * PI) + 0.5, n.y * 0.5 + 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n\n    vec3 camPos = vec3(-7., 6. * max(abs(cos(iTime / 30.)), 0.4), -8. * sin(iTime / 30.));\n    mat3 cam = calcLookAtMatrix(camPos, vec3(0, -0.5, 0));\n\n    vec3 rayDir = cam * normalize(vec3(xy, 2.));\n    SdfCtx rayRes = rayMarch(camPos, rayDir);     \n\n    vec3 col = vec3(0);\n\n    if(rayRes.d < MAX_DIST){\n        vec3 p = camPos + rayRes.d * rayDir;\n        if (rayRes.col.x == 0.) {\n            col = (texture(iChannel0, calcUV(p * rotateY(iTime / 5.))).xyz / 1.1 + 0.5) * 1.5 * vec3(0.96, 0.55, 0);\n        } else {\n            col = vec3(calcPlanetTexture(vec2(p), rayRes.col, rayRes.k)) + calcLight(p, vec3(0), vec3(0.4), rayDir);\n        }\n    } else {\n        col = calcBgColor(xy, rayDir) + vec3(0.09 / length(xy - vec2(0, 0.07))) * vec3(0.7, 0.5, 0.);\n    }\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 154, 154, 179], [181, 181, 214, 214, 276], [278, 278, 313, 313, 341], [343, 343, 386, 386, 451], [453, 453, 475, 475, 552], [554, 554, 577, 577, 705], [707, 707, 732, 732, 3145], [3149, 3149, 3176, 3176, 3412], [3414, 3414, 3487, 3487, 3715], [3717, 3717, 3762, 3762, 3952], [3954, 3954, 3993, 3993, 4270], [4272, 4272, 4323, 4323, 4374], [4376, 4376, 4419, 4419, 4579], [4581, 4581, 4601, 4601, 4717], [4719, 4719, 4765, 4765, 4868], [4870, 4870, 4910, 4910, 5423], [5425, 5425, 5446, 5446, 5544], [5546, 5546, 5601, 5601, 6490]], "test": "untested"}
{"id": "tsKBWz", "name": "3D SDF Collisions", "author": "oneshade", "description": "I had fun with 2D SDF collisions so I moved up to 3D!", "tags": ["3d", "sdf", "physics", "collisiondetection"], "likes": 10, "viewed": 388, "published": 3, "date": "1606942537", "time_retrieved": "2024-07-30T20:32:34.078379", "image_code": "/*\nThis shader uses my Raymarcher Template shader (https://www.shadertoy.com/view/3styDs).\n*/\n\n// Viewing Modes\n//#define CUTAWAY\n// See through has some ugly artifacts but is pretty neat.\n#define SEETHROUGH\n\n// Set to 2 if your computer is fast enough.\n#define ANTIALIASING 1\n\n// Screen variables:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\nvec2 antialiasing = vec2(ANTIALIASING);\n\n// Light variables:\nvec3 lightDirection = normalize(vec3(-1.5, 0.0, 2.0));\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1000.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.01, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 1500.0;\nconst float MIN_HIT_DISTANCE = 0.001;\n\n#ifdef CUTAWAY\nconst int MAX_INTERSECTIONS = 1;\n#endif\n\n#ifdef SEETHROUGH\nconst int MAX_INTERSECTIONS = 2;\n#endif\n\nconst int MAX_STEPS = 300;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n    return surfaceUnion;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    vec2 mouseRotation = (iMouse.yx - 0.5 * iResolution.yx) * vec2(0.5, -0.5);\n    p = Rotate(p, vec3(mouseRotation, 0.0));\n\n    #ifdef CUTAWAY\n    float cutaway = sdBox(Translate(p, vec3(-15.0)), vec3(200.0, 100.0, 150.0));\n    Surface environment = Surface(vec3(0.0, 0.0, 0.0),\n                                  vec3(0.0, 0.7, 0.9),\n                                  vec3(1.0, 1.0, 1.0), 32.0,\n                                  max(mapEnvironment(p), cutaway));\n    #endif\n\n    #ifdef SEETHROUGH\n    Surface environment = Surface(vec3(0.0, 0.0, 0.0),\n                                  vec3(0.0, 0.7, 0.9),\n                                  vec3(1.0, 1.0, 1.0), 32.0,\n                                  mapEnvironment(p));\n    #endif\n\n    vec3 ballPos = getBallPos();\n    Surface ball = Surface(vec3(0.0, 0.0, 0.0),\n                           vec3(1.0, 0.0, 0.0),\n                           vec3(1.0, 1.0, 1.0), 8.0,\n                           sdBall(Translate(p, ballPos), BALL_RADIUS));\n\n    return Union(environment, ball);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in vec3 hitPosition, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightColor;\n\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightColor;\n\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightColor;\n\n    return illuminationAmbient + illuminationDiffuse + illuminationSpecular;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    int intersections = 0;\n    for (int steps=0; steps < MAX_STEPS; steps++) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            color += shadeSurface(sceneSurface, currentPosition, ray, normal);\n            distanceTraveled += 20.0;\n            intersections++;\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE || intersections == MAX_INTERSECTIONS) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(color / float(MAX_INTERSECTIONS), 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    for (float yOffset=0.0; yOffset < antialiasing.y; yOffset++) {\n        for (float xOffset=0.0; xOffset < antialiasing.x; xOffset++) {\n            vec2 pixel = fragCoord + vec2(xOffset, yOffset) / antialiasing - 0.5 * iResolution.xy;\n            vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n            vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * pixel.x - cameraUp * pixel.y));\n            fragColor += rayMarch(Ray(rayOrigin, rayDirection));\n        }\n    }\n\n    fragColor /= antialiasing.y * antialiasing.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starting values:\n    if (ivec2(fragCoord) == ivec2(0, 0)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    if (ivec2(fragCoord) == ivec2(1, 0)) {\n        fragColor = vec4(-3.0, 3.0, 1.0, 1.0);\n    }\n\n    if (iFrame > 0) {\n        // Update values (after initializing them):\n        vec3 ballPos = getBallPos();\n        vec3 ballVel = getBallVel();\n\n        ballVel.y -= GRAVITY;\n        ballPos += ballVel;\n\n        float distToEnv = mapEnvironment(ballPos);\n        if (distToEnv < BALL_RADIUS) {\n            vec3 hitNormal = getNormal(ballPos);\n            ballPos += hitNormal * (BALL_RADIUS - distToEnv);\n            ballVel = reflect(ballVel, hitNormal);\n            ballVel *= DECAY;\n        }\n\n        if (ivec2(fragCoord) == ivec2(0, 0)) {\n            fragColor = vec4(ballPos, 1.0);\n        }\n\n        if (ivec2(fragCoord) == ivec2(1, 0)) {\n            fragColor = vec4(ballVel, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Variable retrieval functions:\n#define getBallPos() texelFetch(iChannel0, ivec2(0, 0), 0).xyz\n#define getBallVel() texelFetch(iChannel0, ivec2(1, 0), 0).xyz\n\n#define BALL_RADIUS 10.0\n\n#define GRAVITY 0.1\n#define DECAY 0.98\n\n// 3D Box SDF Inigo Quilez's 3D SDFs article (https://iquilezles.org/articles/distfunctions):\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdBall(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Functions defining the environment the ball bounces in:\nfloat mapEnvironment(in vec3 p) {\n    float wall = abs(sdBox(p, vec3(200.0, 100.0, 150.0))) - 1.0;\n    float box = sdBox(Rotate(Translate(p, vec3(100.0, 0.0, 0.0)), vec3(45.0, 35.0, 0.0)), vec3(50.0));\n    float ballDisplacement = (sin(p.x * 0.1) + sin(p.y * 0.1) + sin(p.z * 0.1)) * 6.0;\n    float ball = sdBall(Translate(p, vec3(-100.0, 0.0, 0.0)), 50.0) + ballDisplacement;\n    return min(wall, min(box, ball));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapEnvironment(p + vec3(0.001, 0.0, 0.0)) - mapEnvironment(p - vec3(0.001, 0.0, 0.0)),\n                          mapEnvironment(p + vec3(0.0, 0.001, 0.0)) - mapEnvironment(p - vec3(0.0, 0.001, 0.0)),\n                          mapEnvironment(p + vec3(0.0, 0.0, 0.001)) - mapEnvironment(p - vec3(0.0, 0.0, 0.001))));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1238, 1286, 1343, 1343, 1511], [1513, 1540, 1569, 1569, 2598], [2600, 2649, 2682, 2682, 3102], [3104, 3159, 3247, 3247, 3784], [3786, 3807, 3834, 3834, 4648], [4650, 4683, 4738, 4738, 5351]], "test": "untested"}
{"id": "3dVfDz", "name": "kif bisous", "author": "leon", "description": "A test with kif and sdf-font", "tags": ["kif"], "likes": 19, "viewed": 479, "published": 3, "date": "1606933325", "time_retrieved": "2024-07-30T20:32:34.962017", "image_code": "\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    vec2 p = (pixel-0.5*iResolution.xy)/iResolution.y;\n    const int count = 8;\n    float falloff = 1.0;\n    float stroke = 0.0;\n    for (int index = 0; index < count; ++index)\n    {\n        float i = float(count-index)/float(count);\n        p.xy = abs(p.xy)-0.2*falloff;\n        p *= rot(.5*iTime);\n        vec4 font = texture(iChannel0, getUVText(p/falloff));\n        stroke += i*smoothstep(0.02, 0.0, max(0., font.a-0.47));\n        falloff /= 1.1;\n    }\n    color = vec4(stroke);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\n// from\n// https://www.shadertoy.com/view/ld2yDG\n#define grid 16.\n#define cell 1./16.\nconst int kA=177,kB=178,kC=179,kD=180,kE=181,kF=182,kG=183,kH=184,kI=185,kJ=186,kK=187;\nconst int kL=188,kM=189,kN=190,kO=191,kP=160,kQ=161,kR=162,kS=163,kT=164,kU=165,kV=166;\nconst int kW=167,kX=168,kY=169,kZ=170,kSpace=80;\n\nvec2 getSymbol (int key)\n{\n\treturn vec2(mod(float(key),grid),floor(float(key)/grid));\n}\n\nvec2 getLetterUV (vec2 target, vec2 offset)\n{\n    vec2 uvLetter = target;\n    uvLetter.x = uvLetter.x;\n    uvLetter += offset / grid;\n    float crop = step(target.x, cell) * step(target.y, cell);\n    crop *= step(0., target.x) * step(0., target.y);\n    return uvLetter * crop;\n}\n\nvec2 getUVText (vec2 target)\n{\n    int symbols[] = int[] ( kB,kI,kS,kO,kU,kS );\n    int count = symbols.length();\n    vec2 space = vec2(0.5,1);\n    vec2 textUV = vec2(0);\n    for (int i = 0; i < count; ++i) {\n        vec2 offset = vec2(i,0)/grid;\n        offset.x -= float(count)/grid/2.;\n        offset.y -= cell/2.;\n    \ttextUV += getLetterUV(target - offset, getSymbol(symbols[i]));\n    }\n    return textUV;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 51, 51, 536]], "test": "untested"}
{"id": "3sKfDz", "name": "Irish flag", "author": "Nictrak", "description": "Irish flag", "tags": ["flag"], "likes": 1, "viewed": 286, "published": 3, "date": "1606931802", "time_retrieved": "2024-07-30T20:32:35.894523", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 green = vec3(0.086, 0.608, 0.384);\n    vec3 white = vec3(1, 1, 1);\n    vec3 orange = vec3(1, 0.5323, 0.243);\n\tvec3 col;\n    \n    if(uv.x < 0.33) col = green;\n    else if(uv.x > 0.67) col = orange;\n    else col = white;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 437]], "test": "untested"}
{"id": "3sKBDz", "name": "simple path tracer", "author": "me_123", "description": "This path tracer can only have spheres, and no refractions.  its based of the paper Ray Tracing In One Weekend.", "tags": ["pathtracing"], "likes": 10, "viewed": 592, "published": 3, "date": "1606930764", "time_retrieved": "2024-07-30T20:32:36.738267", "image_code": "float hash(vec2 p) {\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nstruct ray {\n\tvec3 origin;\n    vec3 dir;\n};\nstruct mater {\n\tvec3 color;\n    int mat;\n    float ev;\n};\nstruct rec {\n    float t;\n    vec3  p;\n    vec3  normal;\n    mater mat;\n};\n\nstruct sphere {\n\tfloat radius;\n    vec3 center;\n    mater mat;\n};\nvec4 nois(in vec3 x) {\n\tvec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.);\n    vec3 du = 30.*w*w*(w*(w-2.0)+1.0);\n    float a = hash3(p+vec3(0, 0, 0));\n    float b = hash3(p+vec3(1, 0, 0));\n    float c = hash3(p+vec3(0, 1, 0));\n    float d = hash3(p+vec3(1, 1, 0));\n    float e = hash3(p+vec3(0, 0, 1));\n    float f = hash3(p+vec3(1, 0, 1));\n    float g = hash3(p+vec3(0, 1, 1));\n    float h = hash3(p+vec3(1, 1, 1));\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n    return vec4(-1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z, \n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x, \n                                k3 + k6*u.x + k5*u.y + k7*u.x*u.y));\n}\nvec4 fbm(in vec3 x, int octives) {\n\tfloat f = 1.98;\n    float s = 0.6;\n    float a = 0.0;\n    float b = 0.3;\n    vec3 d = vec3(0);\n    float o = 0.6;\n    mat3 m = mat3(o, 0, 0, 0, o, 0, 0, 0, o);\n    for (int i = 0; i < octives; i ++) {\n        vec4 n = nois(x);\n        a += b*n.x;\n        d += b*m*n.yzw;\n        b *= s;\n        x = f*m*x;\n        m = f*m*m;\n    }\n    return vec4(a, d);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+10.), 0.33333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return vec3(x, y, z);\n}\nint sc = 7;\nsphere scene[7];\nbool hitSphere(vec3 center, float radius, ray r, float t_min, float t_max, out rec re, mater mat) {\n    vec3 oc = r.origin-center;\n    float a = dot(r.dir, r.dir);\n    float b = dot(oc, r.dir);\n    float c = dot(oc, oc) - radius*radius;\n    float disc = b*b - a*c;\n    if (disc > 0.) {\n        float temp = (-b - sqrt(b*b-a*c)) / a;\n        if (temp < t_max && temp > t_min) {\n            vec3 p = r.origin+r.dir*temp;\n            re.t = temp;\n            re.p = p;\n            re.normal = (p - center) / radius;\n            re.mat = mat;\n        \treturn true;\n        }\n        temp = (-b + sqrt(b*b-a*c)) / a;\n        if (temp < t_max && temp > t_min) {\n            vec3 p = r.origin+r.dir*temp;\n            re.t = temp;\n            re.p = p;\n            re.normal = (p - center) / radius;\n            re.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\nbool hitScene(ray r, float tmin, float tmax, out rec hit) {\n\tbool hitIt = false;\n    float closest = tmax;\n    for (int i = 0; i < sc; i += 1) {\n        if (hitSphere(scene[i].center, scene[i].radius, r, tmin, closest, hit, scene[i].mat)) {\n        \thitIt = true;\n            closest = hit.t;\n        };\n    }\n    return hitIt;\n}\nvoid diffused(out ray r, vec2 seed, rec hit, inout vec3 c) {\n    vec3 target = hit.p + hit.normal + rus(seed);\n    r.origin = hit.p;\n    r.dir = target - hit.p;\n    c *= hit.mat.color;\n}\nvoid gloss(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    r.origin = hit.p;\n    r.dir = (reflect(r.dir, hit.normal)+(rus(seed)*hit.mat.ev))/hit.mat.ev;\n    c *= hit.mat.color;\n}\nvoid emit(inout ray r, vec2 seed, rec hit, inout vec3 c) {\n    c = hit.mat.color*10.;\n}\nvec3 color(vec3 ro, vec3 rd, vec2 seed) {\n    vec3 c = vec3(1.0);\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    for (int i = 0; i < 100; i += 1) {\n        rec hit;\n        ray r = ray(roo, rdd);\n        if (hitScene(r, 0.001, 10000.0, hit)) {\n            ray rrr = r;\n            if (hit.mat.mat == 0) {diffused(rrr, seed, hit, c);}\n            if (hit.mat.mat == 1) {gloss(rrr, seed, hit, c);}\n            if (hit.mat.mat == 2) {emit(rrr, seed, hit, c);}\n            roo = rrr.origin;\n            rdd = rrr.dir;\n        } else {\n            vec3 dir = normalize(rdd);\n            float t = 0.5*(dir.y+1.);\n            c *= ((1.-t)*vec3(1)+t*vec3(0.5, 0.7, 1.0))/1.;\n            break;\n        }\n\t}\n    return c;\n}\nint samples = 10;\nfloat camSize = 5.;\nvec3 drawImage(in vec2 fragCoord )\n{\n\tscene[0] = sphere(0.5, vec3(0, 0., 0), mater(vec3(0.8, 0.3, 0.3), 0, 0.));\n\tscene[1] = sphere(0.5, vec3(1, 0., 0), mater(vec3(0.8, 0.8, 0), 0, 0.));\n\tscene[2] = sphere(0.5, vec3(-1., 0., 0), mater(vec3(0.8, 0.6, 0.2), 0, 0.));\n\tscene[3] = sphere(0.5, vec3(-1., 1., 0), mater(vec3(0.4), 0, 0.));\n\tscene[4] = sphere(0.5, vec3(1., 1., 0), mater(vec3(0.9), 0, 0.));\n\tscene[5] = sphere(0.5, vec3(0., 1., 0), mater(vec3(0.7), 0, 0.));\n\tscene[6] = sphere(1000.0, vec3(0, -1000.5, -1), mater(vec3(0.8, 0.8, 0.8), 1, 0.1));\n    vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\n    float r = iResolution.x/iResolution.y;\n    mouse *= (r)*2.;\n    mouse.y = max(mouse.y, -0.1);\n    vec3 c = vec3(0);\n    for (int i = 0; i < samples; i += 1) {\n        vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n        uv += (vec2(hash(uv+float(i)), hash(uv+float(i)+float(samples+1)))-0.5)/(iResolution.xy/2.);\n        vec3 ro = vec3(sin(mouse.x*5.)*camSize, mouse.y*camSize, cos(mouse.x*5.)*camSize);\n        vec3 at = vec3(0);\n        vec3 cam_z = normalize(at-ro);\n        vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n        vec3 cam_y = cross(cam_z, cam_x);\n        vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n        c += color(ro, rd, uv+(float(i)/1000.));\n    }\n   \treturn vec3(c/float(samples));\n}\nvec2 chunkPos = vec2(0);\nfloat chunkSize = 200.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Render in Tiles So webgl dose not crash (:\n    chunkPos.x = ceil(mod(float(iFrame)*chunkSize, ceil(iResolution.x/chunkSize)*chunkSize)/chunkSize)*chunkSize;\n    chunkPos.y = mod(floor(mod(float(iFrame/int(ceil(iResolution.x/chunkSize)))*chunkSize, iResolution.x)/chunkSize)*chunkSize, iResolution.y);\n\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 texture = texture(iChannel0,uv);\n    \n    if (fragCoord.x < chunkPos.x+chunkSize && fragCoord.y < chunkPos.y+chunkSize && fragCoord.x > chunkPos.x && fragCoord.y > chunkPos.y) {\n        fragColor = vec4(drawImage(fragCoord), 1);//vec4(texture.rgb,1.); \n    } else {   \n        fragColor = vec4(fragColor.rgb,1.); discard;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 87], [88, 88, 110, 110, 209], [454, 454, 476, 476, 1446], [1447, 1447, 1481, 1481, 1838], [1839, 1839, 1860, 1860, 2287], [2317, 2317, 2416, 2416, 3192], [3193, 3193, 3252, 3252, 3522], [3523, 3523, 3583, 3583, 3709], [3710, 3710, 3769, 3769, 3893], [3894, 3894, 3952, 3952, 3981], [3982, 3982, 4023, 4023, 4692], [6139, 6139, 6196, 6245, 6910]], "test": "untested"}
{"id": "WdKfWz", "name": "- diamond -", "author": "anahit_movsesyan", "description": ":octopus:", "tags": ["diamond"], "likes": 4, "viewed": 236, "published": 3, "date": "1606930660", "time_retrieved": "2024-07-30T20:32:37.499233", "image_code": "#define WITH_CUBEMAP\n#define MIX\n\n//---------------------\n\n#define PI 3.14159\n#define EPS 0.001\n#define MAX_DIST 20.\n\nfloat sdTorus(vec3 p) {\n  \treturn length(vec2(length(p.xz) - 1., p.y)) - 0.03;  \n}\n\nfloat sdOctahedron(vec3 p, float s) {\n  \tp = abs(p);\n  \treturn (p.x + p.y + p.z - s) * 0.58;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float off) {\n  return dot(p, n) + off;\n}\n\nmat2 rotMat(float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat2(c, -s, s,  c);\n}\n\nvec3 swirl(vec3 p, float k) {\n    float c = cos(k * p.x);\n    float s = sin(k * p.x);\n    return vec3(mat2(c, -s, s, c) * p.yz, p.x);\n}\n\nfloat calcDist(vec3 p) {\n    float dTorus1 = sdTorus(0.3 * swirl(p.yxz, 3. * sin(iTime)));\n    float dTorus2 = sdTorus(0.3 * swirl(p, 3. * sin(iTime)));\n    \n    p.xz *= rotMat(iTime);\n    p.xy *= rotMat(PI / 6.);\n\tfloat dOctahedron = sdOctahedron(p, 1.);\n    float dPlane = sdPlane(p, vec3(0, 1, 0), -0.35);\n    \n    #ifdef MIX\n    return min(mix(dTorus1, dTorus2, sin(iTime) * 0.5 + 0.5), max(dOctahedron, dPlane));\n    #else\n    return min(dTorus1, max(dOctahedron, dPlane));\n    #endif\n}\n\nfloat rayMarch(vec3 rayO, vec3 rayD) {\n    float distFromO = 0.;\n    for (int i = 0; i < 100; ++i) {\n\t    float dS = calcDist(rayO + rayD * distFromO);\n        distFromO += dS;\n        if (dS < EPS || distFromO > MAX_DIST) break;\n    }\n    return distFromO;\n}\n\nvec3 calcNormal(vec3 p) {\n    float d = calcDist(p);\n\treturn normalize(vec3(d - calcDist(p - vec3(EPS, 0,  0 )),\n\t\t\t\t\t  \t  d - calcDist(p - vec3( 0, EPS, 0 )),\n\t\t\t\t\t   \t  d - calcDist(p - vec3( 0,  0, EPS))));\n}\n\nvec3 calcLight(vec3 fragPos, vec3 lightPos, vec3 lightCol, vec3 camDir) {    \n\tvec3 normal = calcNormal(fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    \n    vec3 ambient = vec3(0.1);\n    vec3 diffuse = vec3(max(dot(normal, lightDir), 0.0));\n    vec3 specular = vec3(0.15 * pow(max(dot(-camDir, reflect(-lightDir, normal)), 0.), 16.));\n    \n    return lightCol * (ambient + diffuse + specular);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    \n    vec3 camPos = vec3(0, 0, -10);\n\tvec3 camDir = normalize(vec3(xy, 1.));\n    \n    float dist = rayMarch(camPos, camDir);\n    \n    vec3 col =  vec3(0.87, 0.92, 0.99) + vec3(0.009 / length(xy + vec2(0., 0.015)));\n    \n    if (dist < MAX_DIST) { \n        #ifdef WITH_CUBEMAP\n        col = texture(iChannel0, reflect(camDir, calcNormal(camPos + dist * camDir))).xyz * vec3(0.95, 1.1, 1.4);\n        #else\n\t\tcol = calcLight(camPos + dist * camDir, vec3(5, 0, -15), vec3(0.9, 0.5, 0.4), camDir);\n        #endif\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 1.0 - uv.yx;\n    col *=  vec3(pow(uv.x * uv.y * 15., 0.1)); \n    \n\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 141, 141, 200], [202, 202, 239, 239, 296], [298, 298, 340, 340, 368], [370, 370, 392, 392, 469], [471, 471, 500, 500, 606], [608, 608, 632, 632, 1099], [1101, 1101, 1139, 1139, 1360], [1362, 1362, 1387, 1387, 1573], [1575, 1575, 1648, 1648, 1987], [1989, 1989, 2044, 2044, 2805]], "test": "untested"}
{"id": "tscBD4", "name": "Clip - Thomas Barrandon - Fledge", "author": "z0rg", "description": "A shader to accompany this beautiful song from Thomas Barrandon\nhttps://youtu.be/OhLHmHP4Gv8", "tags": ["music", "retrowave"], "likes": 8, "viewed": 422, "published": 3, "date": "1606924504", "time_retrieved": "2024-07-30T20:32:38.259201", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat songDuration = 314.;\nfloat fadeInOut = 2.;\n\nvec3 dirBlur(vec2 uv, float lvl)\n{\n    vec3 col;\n    int cnt = 8;\n    float fcnt = float(cnt);\n    float acc;\n    for (int i = 0; i < cnt; ++i)\n    {\n        float fi = float(i);\n   \t\tfloat pct = sat(fi/fcnt);\n        float k = (1.-pct);\n        \n        vec3 rgb = texture(iChannel0, (uv-.5)*(1.+lvl*pct)+.5).xyz;\n        \n        col += rgb*k;\n        acc +=k;\n    }\n    return col/acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    float beat = sin(iTime*PI*16.);\n    float blur = 0.04;\n    if (iTime> 82.5 && iTime < 256.)\n        blur *= beat;\n    \n    col = dirBlur(uv, blur);\n    \n    col *= sat((iTime)/fadeInOut);\n\tcol *= 1.-sat((iTime-310.)/fadeInOut);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// https://youtu.be/OhLHmHP4Gv8\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 u = normalize(cross(r, rd));\n    \n    return normalize(rd + r* uv.x + u *uv.y); \n}\n\nvec2 add(vec2 a, vec2 b)\n{\n    return (a.x < b.x ? a : b);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 rep = vec2(.7);\n     vec2 sdUv = p.xz;\n    p.xz = mod(sdUv+rep*.5, rep)-rep*.5;\n    ivec2 ip = ivec2(((sdUv+rep*.5) / rep));\n    \n    float sz = 0.15*(sin(float(ip.x))*.2+.5);\n\n    \n    float ht = .5*texelFetch(iChannel0, ivec2(int(length(vec2(ip))*20.), 0), 0).x+.2*(1.+length(vec2(ip)*.15))+(1.+length(vec2(ip.xy))*.2)*2.*abs(sin(10.*sin(float(ip.x))*float(ip.y)+5.*float(ip.x*5)+iTime)*0.1);\n    vec2 ground = vec2(p.y, -1.0);\n    vec2 buildings = vec2(sdBox(p, vec3(sz, ht, sz)), sat(ht));\n    vec2 buildings2 = vec2(sdBox(p, vec3(sz, ht, sz)), sat(ht));\n    return add(ground, add(buildings, buildings2));\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                           map(p+h.yxy).x - map(p-h.yxy).x,\n                           map(p+h.yyx).x - map(p-h.yyx).x ) );\n}\n\nvec3 rdr(vec2 uv, vec3 ro, vec3 rd)\n{\n\tvec3 col;\n\n    float lightAcc;\n    float d = 0.0001;\n    vec3 p;\n    for (int i = 0; i < 200 && d < 50.; ++i)\n    {\n        p = ro+rd*d;\n        vec2 res = map(p);\n\t\t//lightAcc += res.x*.1;\n        if (abs(res.x) < 0.0001*d)\n        {\n            vec3 n = calcNormal(p);\n            //col += n*.5+.5;\n\n            vec3 lPos = vec3(1.*sin(iTime),2.,2.*cos(iTime*.5));\n            float power = 1.-sat(distance(lPos, p)/10.);\n            vec3 lDir = normalize(lPos-p);\n            col += vec3(.9,.7,.3)*pow(sat(dot(lDir, n)), 5.)*power; // diffuse\n            vec3 h = normalize(lDir-rd);\n            col += vec3(.5,.2,.8)*pow(sat(dot(h, n)), 5.)*2.*power;\n            \n                   col += /*lightAcc**/vec3(.2,.3,.4)*d*.01;\n            if (dot(n, vec3(0.,1.,0.)) > 0.)\n            col += 5.5*vec3(.2,.1,.7)*(1.-sat(2.*sin(2.*-iTime+length(p.xz*.5))));\n\t\t\tcol *= 1.-sat(d/20.);\n            col += 2.*(n*.5+.5)*(1.-sat(p.y/res.y));\n            float gridSp = 25.;\n            float gridSz = .8;\n \t\t\tif (res.y < 0.)\n                col = col.zxy * (.5+sat((sin(p.x*gridSp)-gridSz)*400.)*sat((sin(p.z*gridSp)-gridSz)*400.));\n            break;\n        }\n        \n        d+= res.x * .8;\n    }\n    col = col.zxy;\n    col *= vec3(.5)*(1.-sat(d/20.));\n    col += (rd.y*.5)*vec3(.1,.45,.32);\n    col += (1.-sat(abs(rd.y*5.)))*vec3(0.4,0.2,0.5)*1.5*(1.-sat(abs(rd.x)));\n    col += (1.-sat(abs(rd.x*3.)))*vec3(0.4,0.2,0.5);\n    col *= 1.-sat((lenny(uv)-.5)*5.);\n    col = vec3(sat(col.x),sat(col.y), sat(col.z));\n    col += vec3(.1,.12,.2)*.5*pow(sat(d/20.),.6);\n    col += (1.-sat(lenny(uv*.2)))*texelFetch(iChannel0, ivec2(5,0),0).x*vec3(.5,.3,.6);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    uv.y *= cos(uv.x*3.14159265*.5);\n\tvec3 acc;\n    float accV;\n\n    int aaLvl = 5;\n    for (int i = 0; i<aaLvl; ++i)\n    {\n    \tfloat dist = mix(2., 20., sin(iTime*.2)*.5+.5);\n    \tfloat spinSpd = 0.2;\n        float off = float(i)*0.001*length(uv*5.);\n\n            // Time\n            if (iTime > 9.3) spinSpd *= -1.;\n        \tif (iTime > 27.5) spinSpd *= -1.;\n        \tif (iTime > 45.8) spinSpd *= -1.;\n\tif (iTime > 68.7) spinSpd *= -1.;\n            if (iTime > 73.5) spinSpd *= -1.;\n        if (iTime > 78.) spinSpd *= -1.;\n        \n        if (iTime > 96.) spinSpd *= -1.;\n        if (iTime > 101.) spinSpd *= -1.;\n        \n        if (iTime > 114.) spinSpd *= -1.;\n        if (iTime > 119.) spinSpd *= -1.;\n        if (iTime > 155.5) spinSpd *= 0.;\n        if (iTime > 165.) spinSpd = 0.2;\n        if (iTime > 183.) spinSpd *= -1.;\n        if (iTime > 192.) spinSpd *= -1.;\n        if (iTime > 196.5) spinSpd *= -1.;\n        if (iTime > 201.) spinSpd *= -1.;\n        if (iTime > 210.5) spinSpd *= -1.;\n        if (iTime > 224.) spinSpd *= -2.;\n        if (iTime > 229.) spinSpd *= -2.;\n        if (iTime > 233.) spinSpd *= -2.;\n        if (iTime > 238.) spinSpd = 0.2;\n        if (iTime > 256.) spinSpd *= 0.;\n        if (iTime > 270.) spinSpd = 0.1;\n        if (iTime > 274.5) spinSpd *= -1.;\n        if (iTime > 279.) spinSpd *= -1.;\n        if (iTime > 283.5) spinSpd *= -1.;\n        if (iTime > 288.) spinSpd *= -1.;\n            //\n    \tvec3 ro = vec3(dist*sin(spinSpd*iTime+off), mix(1.,3.,sat(sin(iTime*spinSpd)*.5+.5)), dist*cos(spinSpd*iTime+off));\n    \tvec3 ta = vec3(0., 1., 0.);\n    \tvec3 rdo = normalize(ta-ro);\n    \tvec3 rd = getCam(rdo, uv);//+aa[i]/(iResolution.xx));\n    \tfloat aaV = 1.;//1.-sat(length(uv)*.5);\n    \tvec3 col = rdr(uv, ro, rd)*aaV;\n        //vec3 rd2 = getCam(rdo, uv*(1.-float(i)/400.));\n        vec3 colBlur = col*aaV*3.;//rdr(uv, ro, rd2)*aaV*3.;\n        accV+= aaV*2.;\n\t\tacc += col+colBlur;\n    }\n    vec3 col =acc/accV;\n    \n    vec3 col2 = mix(fwidth(length(col))*col, col, 1.-sat(lenny(uv*vec2(3.,1.))));\n    col2 = pow(col2,vec3(1.15));\n    \n    float sndVal = texelFetch(iChannel0, ivec2(int((uv.x+.5)*15.),0),0).x;\n    if (iTime > 82.7)\n    col2 = mix(col2.yzx, col2,sat(sndVal*2.-1.));\n    fragColor = vec4(col2,1.0);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24562, "src": "https://soundcloud.com/thomasbarrandon/fledge", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265\nfloat lenny(vec2 v)\n{\n\treturn abs(v.x) + abs(v.y);    \n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBD4.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[447, 447, 481, 481, 837], [839, 839, 896, 896, 1215]], "test": "untested"}
{"id": "WsKBWR", "name": "Tangents", "author": "Leasel", "description": "Using color(direction) to visualise a tangent. The color is generated by a the formula which highlights the region which all formules flow to and a formula from https://www.shadertoy.com/view/Mscyzr, which shows the direction in color.", "tags": ["formulas"], "likes": 3, "viewed": 324, "published": 3, "date": "1606918123", "time_retrieved": "2024-07-30T20:32:39.013185", "image_code": "//Color Selection Wheel https://www.shadertoy.com/view/Mscyzr\nvec3 TangentVisualiser(in float Angle) {\n  Angle = atan(Angle);\n  vec3 rgb = clamp(abs(mod(Angle*6.0*PI*0.05+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb);\n  return max(mix( vec3(1.0), rgb, 1.0), 2.*vec3\n    (\n        min(smoothstep(-PI, -PI + D3PI, Angle), smoothstep(-PI + D3PI, -PI, Angle)),\n    \tmin(smoothstep(-PI + D3PI, -PI + D3PI + D3PI, Angle),smoothstep(-PI + D3PI + D3PI, -PI + D3PI, Angle)),\n    \tmin(smoothstep(-PI + D3PI + D3PI, -PI + D3PI + D3PI + D3PI, Angle),smoothstep(-PI + D3PI + D3PI + D3PI, -PI + D3PI + D3PI, Angle))\n    ));\n}\n\n\n//vec3 TangentVisualiser(in float tangentValue)\n//{\n//    float Angle = atan(tangentValue);\n//    \n//    return vec3\n//    (\n//        min(smoothstep(-PI, -PI + D3PI, Angle), smoothstep(-PI + D3PI, -PI, Angle)),\n//    \tmin(smoothstep(-PI + D3PI, -PI + D3PI + D3PI, Angle),smoothstep(-PI + D3PI + D3PI, -PI + D3PI, Angle)),\n//    \tmin(smoothstep(-PI + D3PI + D3PI, -PI + D3PI + D3PI + D3PI, Angle),smoothstep(-PI + D3PI + D3PI + D3PI, -PI + D3PI + D3PI, Angle))\n//    );\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Creates xy values https://www.shadertoy.com/view/Mscyzr\n    vec2 xy = (fragCoord/min(iResolution.x,iResolution.y)-vec2(0.5*iResolution.x/iResolution.y, 0.5))*Scale;\n\n    // Output to screen\n    fragColor = vec4(TangentVisualiser(TangentFunction(xy.x, xy.y, iTime)), 1.);\n}", "image_inputs": [], "common_code": "//Values\n#define Scale 10.\n#define PI 3.14159265359\n#define D3PI 3.14159265359/1.5\n\n//Functions\nfloat TangentFunction(in float x, in float y, in float Time)\n{\n    return x*x - y*y - sin(Time*0.5)*Scale;\n    //return y*y - x*x - sin(iTime)*Scale;//Get error if you use this\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKBWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 62, 102, 102, 640], [1118, 1118, 1175, 1237, 1454]], "test": "untested"}
{"id": "WdVfWR", "name": "basic 2d city", "author": "jorge2017a1", "description": "basic 2d city", "tags": ["basic2dcity"], "likes": 1, "viewed": 267, "published": 3, "date": "1606917691", "time_retrieved": "2024-07-30T20:32:39.838977", "image_code": "//por jorge2017a1  Basic 2d-v3\n\n#define saturate(x) clamp(x, 0.0, 1.0)\nconst float LineWidth=0.01;\n\nfloat oU( float d1, float d2 ) { return  min(d1,d2); }\nfloat oS( float d1, float d2 ) { return max(-d1,d2); }\nfloat oI( float d1, float d2 ) { return max(d1,d2); }\n\n\nvec2 opRepvec2( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return  q ;\n}\n\nfloat rand(float x)\n{\n\treturn fract(sin(x)*1276818.27865);\n}\n\nfloat rand2(vec2 x)\n{\n\treturn fract(sin(dot(x ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat nubes(vec2 p)\n{    \n    vec2 centro=vec2(0.0,0.0);\n    float c1= circ(p-vec2(0.0,0.05), 0.105);\n    float c2= circ(p-vec2(0.15,0.02), 0.065);\n    float c3= circ(p-vec2(-0.15,0.02), 0.065);\n    float b1=sdBox(p-vec2(0.0,-0.05), vec2(0.22,0.045 ) );\n    \n    float res=oU(c1, c2);\n    res=oU(res, c3);\n    res=oS(  b1,res );\n    \n\treturn res;\n    \n}\n\nfloat Ciudad(vec2 p)\n{\n    \n    float b1= sdBox( p-vec2(0.0),vec2(0.08,0.2) );\n    float b2= sdBox( p-vec2(0.2,0.1),vec2(0.08,0.32) );\n    float b3= sdBox( p-vec2(0.5,0.2),vec2(0.18,0.4) );\n    \n    float res=9999.0;\n    res=oU(res, b1);\n    res=oU(res, b2);\n    res=oU(res, b3);\n   \n    return res;\n}    \n    \n\nfloat vehiculo(vec2 p)\n{    \n    float b1= sdBox(p-vec2(0.0,0.0), vec2(0.22,0.08) );\n    float c1= circ(p-vec2(-0.1,-0.1), 0.05);\n    float c2= circ(p-vec2(0.1,-0.1), 0.05);\n    \n    float res=9999.0;\n    res=oU(res, b1);\n    res=oU(res, c1);\n    res=oU(res, c2);\n    \n    \n   \n    return res;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col=vec3(0.2,0.478,.13);\n    // Time varying pixel color\n\n    vec2 p = (2.*fragCoord-R)/R.y;\n    \n    vec2 ap= abs(p);\n    p.y-=.25;\n    \n    float px=-2.0+mod(iTime*0.5, 12.0 );\n    vec2 mover=vec2(px,0.0);\n    \n    float cielo=box( p-vec2( 0.0,0.15), vec2(4.0,0.6));\n    \n  \tfloat sdb6=box( p-vec2( 0.0,-0.45), vec2(2.9,0.016));\n    float n1= nubes(p-mover);\n    float n2= nubes(p-mover+vec2(0.30,0.125));\n    float n3= nubes(p-mover+vec2(1.20,-0.5));\n    float n4= nubes(p-mover+vec2(2.20,-0.15));\n    float n5= nubes(p-mover+vec2(3.80,-0.25));\n    float n6= nubes(p-mover+vec2(4.80,-0.05));\n    float n7= nubes(p-mover+vec2(6.80,0.05));\n    \n    \n    float c1= Ciudad(p-vec2(0.0,-0.22));\n    \n    px=-1.0+mod(iTime, 4.0 );\n    vec2 mover2=vec2(px,0.0);\n    float auto1= vehiculo(p-vec2(-0.5,-0.8)+mover2);\n    float auto2= vehiculo(p-vec2(-1.6,-0.45+0.2*sin(iTime*0.2) )+mover2);\n    \n    \n    float sstar1= sdStar5( p-vec2(-0.5,0.4),0.25+0.20*sin(iTime), 0.43);\n    \n    cielo = SS(cielo);\n    sdb6 = SS(sdb6);\n    n1 = SS(n1);\n    n2 = SS(n2);\n    n3 = SS(n3);\n    n4 = SS(n4);\n    n5 = SS(n5);\n    n6 = SS(n6);\n    n7 = SS(n7);\n    \n    c1 = SS(c1);\n    sstar1 = SS(sstar1);\n    \n    \n    auto1= SS(auto1);\n    auto2= SS(auto2);\n    \n   \n       \n    col = mix(col, vec3(0.0,0.0,1.0), cielo);\n    col = mix(col, vec3(1.0,0.20,0.12), c1);\n    col = mix(col, vec3(0.8,0.50,0.42), sstar1);\n    \n    col = mix(col, vec3(0.0), sdb6);\n    col = mix(col, vec3(1.0), n1);\n    col = mix(col, vec3(1.0), n2);\n    col = mix(col, vec3(1.0), n3);\n    col = mix(col, vec3(1.0), n4);\n    col = mix(col, vec3(1.0), n5);\n    col = mix(col, vec3(1.0), n6);\n    col = mix(col, vec3(1.0), n7);\n    col = mix(col, vec3(0.6,0.53,1.0), auto1);\n    col = mix(col, vec3(0.9,0.3,0.6), auto2);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "//Referencia  BC: Straw Hat Pirates\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat circ(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 132, 132, 154], [155, 155, 187, 187, 209], [210, 210, 242, 242, 263], [266, 266, 306, 306, 359], [361, 361, 382, 382, 421], [423, 423, 444, 444, 509], [512, 512, 533, 533, 865], [867, 867, 889, 889, 1168], [1179, 1179, 1203, 1203, 1474], [1481, 1481, 1538, 1588, 3449]], "test": "untested"}
{"id": "wdyfDz", "name": "Kate's Kaleidoscope", "author": "Nickenstein79", "description": "A friend made a tune for me on her lunch-break, so I made her a visual thing to go with it on my lunch-break.", "tags": ["space"], "likes": 2, "viewed": 415, "published": 3, "date": "1606914734", "time_retrieved": "2024-07-30T20:32:40.669756", "image_code": "\n\n// Kate's Kaleidoscope.\n\n\n// A thing inspired by a thing, inspired by another thing, inspired by a thing by Frank Herbert.\n\n\n// An attempt to code a visual effect on my lunch break,\n// to match a piece of music that K8-Bit made on her lunch break.   (https://soundcloud.com/k8-bit)\n\n\n// by Nickenstein79, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. (02/12/2020)\n\n\n#define NUM_LAYERS \t\t\t\t\t(11)\n#define LAYER_SEPERATION_FACTOR\t\t(0.03621)\n#define ZOOM_FACTOR_PERIOD \t\t\t(90.0)  \t\n#define ZOOM_FACTOR_MIN \t\t\t(0.5)\n#define ZOOM_FACTOR_MAX \t\t\t(2.8)\n#define SCROLL_SPEED_AT_MIN_ZOOM\t(1.72)\n#define SCROLL_SPEED_AT_MAX_ZOOM\t(3.343138)\n#define ROTATION_MATRIX_MAX_SKEW\t(0.277)\t\t// The maximum skewing/warping of the rotation matrix\n#define ROTATION_MATRIX_SKEW_PERIOD (8.2)\t\t// The time taken to fully skew and un-skew the rotation matrix\n\n#define CRT_FILTER_ON\t\t\t\t\t\t\t// Toggle this line to dissable/enable the CRT Filter\n#define CRT_VIGNETTE_ON\t\t\t\t\t\t// Toggle this line to dissable/enable the CRT-edge vignette\n#define CRT_EXTRA_NOISE_ON\t\t\t\t\t// Toggle this line to dissable/enable the CRT-Extra Noise\n\n#define TWO_PI\t\t\t\t\t\t(6.283185307179586476925286766559)\n#define LAYER_STEP_SIZE \t\t\t(1.0/float(NUM_LAYERS))\n\n// Returns a psuedo-random float value (in the range 0.0 to 1.0) generated from a 2D vector\n// works by combining the input seed value with prime numbers.\n// Using primes causes sequential inputs (such as pixel coordinates) to still generate non-sequential outputs.\nfloat Hash_From2D(vec2 Vec)\n{\n    float f = Vec.x + Vec.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\n \n// Returns a sin wave driven value that oscilates between Min and Max over the given time period\nfloat OscilateSinScalar(float Min, float Max, float Period)\n{\n\treturn (Max-Min) * (sin(iTime*TWO_PI/Period)*0.5+0.5) + Min;\n}\n\n// Returns the interpolant (fraction) of CurrentValue between Min and Max in the range (0.0 to 1.0)\nfloat GetInterpolant(float Min, float Max, float CurrentValue)\n{\n    return (CurrentValue-Min) / (Max-Min);\n}\n\n// returns a skewed Z rotation matrix (The skewing changes over time)\nmat2 ZRotate_Skewed(float Angle)\n{\n    // Get a value to skew the rotion matrix with, which bounces between 0.0 and ROTATION_MATRIX_MAX_SKEW, over a given time period.\n    float Skew = 1.0 - OscilateSinScalar(0.0, ROTATION_MATRIX_MAX_SKEW, ROTATION_MATRIX_SKEW_PERIOD);\n    \n    // As the input angle is based on an incrimental timer multiplied by magic numbers and getting the cosine of these values,\n    // this generates an animated angle which drifts chaotically and \n    // unpredictably over time (Like a double-pendulum's motion. Actually, a triple-pendulum as we combine three cos() values).\n    // twiddle with the multiply values being passed to cos() until you like the motion of the simulation.\n\tAngle = cos(Angle*0.1)*cos(Angle*0.7)*cos(Angle*0.73)*2.0;    \n    \n    // build and return the skewed Z-rotation matrix\n    return mat2(sin(Angle * Skew),cos(Angle),-cos(Angle * Skew),sin(Angle));\n}\n\n// sample the input textures which creates our desired material surface effect\nvec4 SampleMaterial(vec2 uv)\n{\n   float t = iTime * 0.5;\n   \n   // sample texture 0, just the red channel to get an initial grey-scale value in range 0.0 to 1.0\n   float Sample0 = texture(iChannel0, uv * 0.1 ).b;\n    \n   // Modify Sample0 by subtracting circlular patterns that grow across the texture over time\n   // fiddle with the numbers to get differening circular patterns\n   Sample0 -= 0.5 + sin(t + sin(uv.x) + sin(uv.y)) * 0.7; \n   \n   // adjust brightness\n   Sample0 *= 1.6;\n   \n   // ensure no negative values with abs(), this also causes a double\n   // concentric-circle pattern as sin() returns -1 to +1 values.\n   Sample0 = abs(Sample0);\n \n   // invert these fat bright negative-circles to get thin bright circles and curves\n   Sample0 = 1.0/(Sample0*10.0+1.0);\n    \n   // make a greyscale colour from Sample0, then multiply it by a full-colour sample from eleswhere on texture 0\n   vec4 Colour = vec4(Sample0) * texture(iChannel0, uv * 0.05);\n    \n   // multiple this colour by a scrolling sample from texture 1 (random coloured noise texture)\n   // Adjust the multiplyer to expand or shrink the range of the coloured noise texture in use\n   return Colour * texture(iChannel1,(uv + (iTime*1.3)) * 0.001735);\n}\n\n// Generate fast downward cycling fat scanlines\nfloat scanline(vec2 uv, float TexHeight) \n{\n\treturn sin(iResolution.y * uv.y * 0.7 - iTime * 10.0);\n}\n\n// Generate slow upward cycling thin scanlines\nfloat slowscan(vec2 uv, float TexHeight) \n{\n\treturn sin(iResolution.y * uv.y * 0.02 + iTime * 6.0);\n}\n\n// warp uv coordinates to emulate a curved crt screen\nvec2 crt_bend_uv_coords(vec2 coord, float bend)\n{\n\t// put in symmetrical coords\n\t//coord = (coord - 0.5) * 2.0;\n\t//coord *= 0.5;\t\n\t\n\t// deform coords\n\tcoord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n\tcoord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n\n\t// transform back to 0.0 - 1.0 space\n\tcoord  = (coord / 1.0) + 0.5;\n\n\treturn coord;\n}\n\n// wibble the screen, crt magnetic interferance distortion effect\nvec2 scandistort(vec2 uv) \n{\n\tfloat scan1 = clamp(cos(uv.y * 2.0 + iTime), 0.0, 1.0);\n\tfloat scan2 = clamp(cos(uv.y * 2.0 + iTime + 4.0) * 10.0, 0.0, 1.0);\n\tfloat amount = scan1 * scan2 * uv.x; \n\tuv.x -= 0.05 * mix( texture(iChannel1, vec2(uv.x, amount)).x * amount, amount, 0.9 );\n    \n\treturn uv;\n}\n\n// CRT edge vignette\nvec3 CRT_Vignette(vec3 Colour, vec2 uv)\n{\n    uv.x /= iResolution.x / iResolution.y;\n\tfloat Vignette = clamp(pow(cos(uv.x * 3.1415), 1.3) * pow(cos(uv.y * 3.1415), 1.3) * 50.0, 0.0, 1.0);\n    Colour *= Vignette;\n    \n    return Colour;    \n}\n\n// Cathode ray tube filter, to look like an old cathode ray-tube monitor with scanlines, and V-Hold, etc...\nvec3 CRT_Filter(vec3 Colour, vec2 uv)\n{\n#ifdef CRT_EXTRA_NOISE_ON    \n    Colour.r += Hash_From2D(uv * iTime * 911.911 * 4.0) * 0.19;\n    Colour.g += Hash_From2D(uv * iTime * 563.577 * 4.0) * 0.19;\n    Colour.b += Hash_From2D(uv * iTime * 487.859 * 4.0) * 0.19;\n#endif    \n    \n    vec2 sd_uv = uv;\n\tvec2 crt_uv = crt_bend_uv_coords(sd_uv, 2.0);    \n    vec3 scanline_Colour;\n\tvec3 slowscan_Colour;\n\tscanline_Colour.x = scanline(crt_uv, iResolution.y);\n    slowscan_Colour.x = slowscan(crt_uv, iResolution.y);\n    scanline_Colour.y = scanline_Colour.z = scanline_Colour.x;\n\tslowscan_Colour.y = slowscan_Colour.z = slowscan_Colour.x;\n\tColour = mix(Colour, mix(scanline_Colour, slowscan_Colour, 0.5), 0.04);\n    \n    // apply the CRT-vignette filter\n#ifdef CRT_VIGNETTE_ON\n    Colour = CRT_Vignette(Colour, uv);\n#endif     \n    \n    return Colour;\n}\n\n// Perform some post processing effects on the output colour\nvec3 PostProcessColour(vec3 Colour, vec2 uv)\n{\n    // Vignette (Darken the pixels nearer the corners of the screen)\n    Colour -= vec3(length(uv*0.1));\n    \n    // Add some random noise to the colour with the Hashing function\n\tColour += Hash_From2D(uv*iTime*0.01)*0.02;\n    \n    // apply the CRT-screen filter\n#ifdef CRT_FILTER_ON\n    Colour = CRT_Filter(Colour, uv);\n#endif \n    \n    // Approximate the brightness of the colour by using it as a 3d spacial vector and getting its length in colour space\n    float Brightness = length(Colour);\n    \n    // inrease the colour contrast, by dimming the darker colours and brightening the lighter ones, \n    // via linear interpolation of the colour and its approximated brightness value\n\tColour = mix(Colour, vec3(Brightness), Brightness - 0.5);\n    \n    return Colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get a UV chord for each texel in the range -1.0 to 1.0 (so we can scale/rotate everything from the center of the screen)\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    \n    // modify the X component of the uv, by the screen's aspect ratio to avoid stretching of the input textures in width\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    // start with black\n\tvec3 Colour = vec3(0.0, 0.0, 0.0);\n    \n    // Determine a scale value that oscilates between MIN_ZOOM and MAX_ZOOM over the desired time period\n    float ScaleValue = OscilateSinScalar(ZOOM_FACTOR_MIN, ZOOM_FACTOR_MAX, ZOOM_FACTOR_PERIOD);\n    \n    // Determine a speed to scroll through the texture space.\n    // This works by generating a speed value between MIN_SCROLL and MAX_SCROLL\n    // which is guided by the current zoom value, such that when the texture\n    // is fully zoomed out, the scroll speed is at the desired maximum, and when\n    // the texture is fully zoomed in, the scroll speed is at the desired minimum.\n    float ScrollInterpolant = GetInterpolant(ZOOM_FACTOR_MIN, ZOOM_FACTOR_MAX, ScaleValue);\n    // mix performs a linear interpolation between two inputs\n    float ScrollValue = mix(SCROLL_SPEED_AT_MIN_ZOOM, SCROLL_SPEED_AT_MAX_ZOOM, ScrollInterpolant); \n    \n\t// Sum the colour contribution of each layer   \n\tfor (float i = 0.0; i < 1.0; i += LAYER_STEP_SIZE)\n\t{\n        // clone the uv, so the original is preserved for each itteration of the loop\n\t\tvec2 uv2 = uv;\n       \n        // Rotate with a Z-Rotation matrix that skewes over time \n        // (Giving a slighlty different input angle for each layer, as i-squared is combined in)\n        uv2 *= ZRotate_Skewed(iTime * i*i * 12.0 * LAYER_SEPERATION_FACTOR);\n        \n        // Scale (Again, giving a slighlty different scale for each layer, as i-squared is combined in)\n\t\tuv2 *= ScaleValue * (i*i+1.0); \n\n        // Scroll the sampling position over time\n\t\tuv2.xy += ScrollValue + iTime*0.125;        \n        \n        // sample the material, building up each layer's colour contribution\n\t\tColour += SampleMaterial(uv2).xyz*LAYER_STEP_SIZE*3.5;\n\t}\n\t\n    // Perform some post processing on the accumulated colour layers\n    Colour = PostProcessColour(Colour, uv);\n    \n    // set the generated colour as the final output pixel colour\n\tfragColor = vec4(Colour, 1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24768, "src": "https://soundcloud.com/k8-bit/dune-game-inspired-piece-for-nick", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyfDz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1234, 1500, 1529, 1529, 1602], [1605, 1702, 1763, 1763, 1827], [1829, 1929, 1993, 1993, 2038], [2040, 2110, 2144, 2277, 3017], [3019, 3098, 3128, 3128, 4322], [4324, 4372, 4415, 4415, 4473], [4475, 4522, 4565, 4565, 4623], [4625, 4679, 4728, 4828, 5018], [5020, 5086, 5114, 5114, 5386], [5388, 5409, 5450, 5450, 5650], [5652, 5760, 5799, 5799, 6607], [6609, 6670, 6716, 6785, 7486], [7488, 7488, 7545, 7673, 9871]], "test": "untested"}
{"id": "wsyfDz", "name": "Twist3000 anaglyph test", "author": "z0rg", "description": "A repost of a previous shader to test anaglyph effect.\nA simple demoscenish styled twisted cube inspired by this wonderful demo \"Ion Traxx\" by MFX and Kewlers.\nhttps://www.youtube.com/watch?v=LOWZmOhz8wI", "tags": ["3d", "raymarching", "checkerboard", "twist"], "likes": 8, "viewed": 240, "published": 3, "date": "1606913648", "time_retrieved": "2024-07-30T20:32:41.514497", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n// Fork of \"Twist3000\" by z0rg. https://shadertoy.com/view/tddczf\n// 2020-12-02 12:26:20\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 p) { return abs(p.x)+abs(p.y); }\n\nvec3 getDir(vec3 fwd, vec2 uv)\n{\n    vec3 r = normalize(cross(normalize(fwd), vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r, normalize(fwd)));\n    float fov = .8;\n    return uv.x*r+uv.y*u+fov*fwd;\n}\n\nvec2 add(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n    \treturn a;\n    return b;\n}\n\n// Credits to IQ\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 p2 = p-vec3(0.,1.,0.);\n    p2.xz *= r2d(sin(p.y+iTime));\n    vec2 box = vec2(sdBox(p2, vec3(1., 3., 1.)), 1.);\n\tvec2 ground = vec2(p.y, 0.); \n    return add(box, ground);\n}\n\n// Credits to IQ\nvec3 calcNormal( in vec3 p, in float t )\n{\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\nvec3 rdr2(vec2 uv, vec3 ro, vec3 rd)\n{\n    vec3 grad = (1.-sat(abs(uv.x*1.)))*vec3(0.6, 0.87,1.).zxy;\n    vec3 col = grad*.5*(sin(iTime*.5)*.5+.5);\n    col += (1.-pow(sat(lenny(uv)-.2), .5))*.5;\n    \n    float bps = 1./2.2;\n    float beat = mod(iTime, bps)/bps;\n    \n    float beat2 = mod(iTime+1., bps)/bps;\n    \n\n    \n    float d = 0.01;\n    for (int i = 0; i < 128; ++i)\n    {\n        vec3 p = ro + rd * d;\n        vec2 res = map(p);\n        if (res.y > 0.5)\n        col += pow((1.-sat(res.x*.05)), 5.5)*.03*vec3(0.4,.57,1.);\n        if (res.x < 0.01 && d < 100.)\n        {\n            vec3 norm = calcNormal(p, d);\n            vec3 diff = vec3(0.);\n            vec3 spec = vec3(0.);//0.3, 0.7,1.);\n            if (res.y < 0.5)\n            {\n                float chkSz = 2.5;\n                float sharp = 50.;\n                float checkerBoard = mod(p.x*1., chkSz) - .5*chkSz;\n                checkerBoard = clamp(checkerBoard*sharp, -1.0, 1.0);\n                checkerBoard *= clamp((mod(p.z*1., chkSz) - .5*chkSz)*sharp, -1., 1.);\n                \n                diff = mix(vec3(0.),vec3(0.7,1.,0.), sat(checkerBoard*1.));\n                spec = vec3(1.,.1,0.1).zxy;\n            }\n            \n            spec = spec.zyx;\n            \n            \n            float lSpd = .5;\n            vec3 lPos = vec3(0.,1.,0.);\n            vec3 lDir = normalize(lPos-p);\n            col += vec3(.1); // Ambient\n            vec3 h = normalize(lDir+rd);\n            col += diff*sat(dot(norm, lDir)); // diffuse\n            col += spec*pow(sat(dot(norm,h)), 2.9); // spec\n            break;\n        }\n    \td += res.x*.5;\n    }\n    \n    \n    col += grad*.2;\n    col *= 1.-pow(sat(length(uv*.5)), .5);\n    \n    col += (1.-pow(sat(lenny(uv*.5)), .5))*.1*sat(d-10.);\n    col *= (1.-sat(beat2-.7))*vec3(1.)*(pow(sat(d/100.), .1));\n\n    return col;\n}\n\nvec3 rdr(vec2 uv)\n{\n    float dist = 12.;// +1.5*beat;\n    float camT = iTime*.5;\n    \n    vec3 ro = vec3(dist*sin(camT),4.+sin(camT),dist*cos(camT));//vec3(sin(iTime*.5+1.), 1., -5.+mod(iTime, 30.));\n    vec3 target = vec3(0., 2.,0.);\n    vec3 rd = getDir(normalize(target-ro),uv); \n    \n    vec2 dir = normalize(uv);\n    float strength = length(uv)*0.05;\n    \n    vec3 col;\n\n    \n    float deye = 0.3;\n    \n    ro -= deye*normalize(cross(normalize(target-ro), vec3(0.,1.,0.)));\n    float left = rdr2(uv, ro, rd).x;\n    \n    ro += deye*2.0*normalize(cross(normalize(target-ro), vec3(0.,1.,0.)));\n\tvec2 right = rdr2(uv, ro, rd).yz;\n\n    col += vec3(left,0.,0.) +vec3(0.,right.xy);\n\treturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n\n    vec3 col;\n    \n    col = rdr(uv);\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyfDz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[519, 519, 537, 537, 598], [600, 600, 621, 621, 649], [651, 651, 683, 683, 852], [854, 854, 880, 880, 930], [932, 949, 980, 980, 1067], [1069, 1069, 1087, 1087, 1269], [1271, 1288, 1330, 1330, 1555], [1556, 1556, 1594, 1594, 3396], [3398, 3398, 3417, 3417, 4093], [4097, 4097, 4154, 4154, 4295]], "test": "untested"}
{"id": "tsyBDR", "name": "Raycaster with 2D SDF map  - Fab", "author": "FabriceNeyret2", "description": "Improving Markus version.     Look around: mouse   Move: W,S + arrows\nprinciple: 2D SDF is precomputed in buffA.  \nFloor, ceiling and objects are added on the fly during rendering.", "tags": ["raycaster", "mm"], "likes": 9, "viewed": 458, "published": 3, "date": "1606897534", "time_retrieved": "2024-07-30T20:32:42.365223", "image_code": "// Fork of \"Raycaster 2D SDF 0\" by markusm. https://shadertoy.com/view/wdB3WG 2020-11-29 11:47:08\n\n#define AA 2 // AA*AA sample per pixel\n\n//float seed = 0.;\n//float random() {    return fract(sin(seed++)*43758.5453123);  }\n\n// Create the camera dir, camera code is 3D, not really\nvoid getCameraDir( in vec2 uv, in vec3 pos, in vec3 lookAt, out vec3 rayDir )\n{\n\tvec3 camPos = pos;\n\tvec3 camLookAt = lookAt;\n\n    float ratio = iResolution.x / iResolution.y;\n \n\n    const float fov = 80.;\n    float halfWidth = tan(radians(fov) * .5);\n    float halfHeight = halfWidth / ratio;\n\n    vec3 w = normalize(camPos - camLookAt);\n    vec3 upVector = vec3(0, 1, 0 );\n\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n\n    vec2 p = 2.* uv - 1.;\n    vec3 dir = p.x * u* halfWidth  + p.y * v* halfHeight - w ;\n\n    rayDir = normalize( dir );\n}\n\nvoid mainImage( out vec4 fragColor, in float2 fragCoord )\n{    \n    vec2 uv = fragCoord / iResolution.xy,\n         M  = iMouse.xy / iResolution.xy;\n    if (M==vec2(0)) M = vec2(.5);\n  //fragColor = texture(iChannel0,uv).x*7.*vec4(1,-1,0,0); return;   // ( debug: show map )\n  //float seed = float(iTime) + hash12( uv );\n\n    float3 camPos = texelFetch( iChannel1, ivec2(0), 0 ).xyz, camDir;\n    float3 camLookAt = vec3( M.x, .5-M.y, .5 );\n\n    float3 Light =float3( .5+.25*cos(-3.*iTime), 0, .5+.25*sin(-3.*iTime) );    // light position\n\n    vec4 outColor = vec4( 0 );   \n    //vec3 camPos = vec3( 0.5, 0, 0.1), camDir;\n\n    for ( int aa = 0; aa < AA*AA; aa ++ )                                       // antialiasing loop\n    {\n        vec2 offset = ( vec2(aa%AA, aa/AA ) /float(AA) - .5 ) / iResolution.xy; // AA offset\n        getCameraDir( uv + offset, camPos, camLookAt, camDir );\n        vec4 sdfMap;\n        vec3 rayPos;\n        float t = 0., eps = 1./700.;    \n        for (int i = 0; i < 250; ++i)\n        {\n            rayPos = camPos + t * camDir;\n            sdfMap = texture( iChannel0, rayPos.xz );\n            sdfMap.xy = merge( sdfMap.xy, vec2( rayPos.y+.05, -1) );            // floor\n            sdfMap.xy = merge( sdfMap.xy, vec2(-rayPos.y+.05, -2) );            // ceiling\n            sdfMap.xy = merge( sdfMap.xy, vec2(length(Light-rayPos)-.01, -3));  // light\n            if (sdfMap.x < eps)  break;\n            t += sdfMap.x;                                 // sphere marching \n         // t += .005;                                     // 1 texel per step would be 1/700 = .0015\n        }\n        \n        if ( sdfMap.x > eps ) continue;                    // escape to infinity\n      //fragColor = vec4((3.+sdfMap.y)/5.); return;        // ( debug: show ids )\n        int o = int(sdfMap.y);\n\n        float2 uv = o < 0                                  // texture coords\n            ? rayPos.xz                                    //   floor & ceiling\n            : vec2(sdfMap.z,.5+.5*rayPos.y);               //   walls\n        float3 N  = o < 0                                  // normal\n            ? vec3(0, -sign(rayPos.y), 0 )                 //   floor & ceiling\n            : vec3( cos(sdfMap.w), 0, sin(sdfMap.w) );     //   restore normale\n        //  fragColor = vec4(.5+.5*N,0); return;           // ( debug: show normals )\n        float d = length(camPos-rayPos),\n            illu = 0.                                                         // ambiant\n                 + 1.5* max(0., dot( N, normalize(Light-rayPos) ))            // light source\n                 +  .6* max(0., dot( N, normalize(camPos-rayPos) )*.1/(d*d) );// head lamp\n        outColor +=\n            o==-3 ? vec4( 1 )                                                 // light source\n          : o==-1 ? vec4( .5, .5, 1, 1 ) * illu * texture(iChannel3, uv )     // floor\n          : o==-2 ? vec4( .5, .5, 1, 1 ) * illu * texture(iChannel2, 4.*uv )  // ceiling\n          : o== 0 ? vec4( 1 , 0 , 0, 1 ) * illu * texture(iChannel2, vec2(6,12)*uv ) // walls\n          : o== 1 ? vec4( 0 , 1 , 0, 1 ) * illu * texture(iChannel3, uv )     // column\n          : vec4(0);\n    }\n    outColor /= float(AA*AA);\n    fragColor = outColor;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\nfloat2 merge(float2 d1, float2 d2)\n{\n    if ( d1.x < d2.x ) return d1;\n\telse return d2;\n}\nfloat2 carve(float2 d1, float2 d2)\n{\n    if ( d1.x > d2.x ) return d1;\n\telse return d2;\n}\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\nvec2 translate(float2 p, float2 t) \n{ \n    return p - t; \n}\n\nfloat sdCircle (float2 p, float radius)\n{\n\treturn length(p) - radius;\n}\nfloat uCircle (float2 p, float radius)                        // $Fab\n{\n\treturn .5 + atan(p.y,p.x)/6.283;\n}\nfloat nCircle (float2 p, float radius)                        // $Fab\n{\n\treturn  atan(p.y,p.x);\n}\n\nfloat sdBox(in float2 p, in float2 size, in float radius)\n{\n\tfloat2 d = abs(p) - size + radius;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\nfloat uBox(in float2 p, in float2 size, in float radius)       // $Fab\n{\n    p /= size;\n    float2 a = abs(p);\n\treturn .5+.5* ( a.x > a.y ? sign(p.x)*p.y : sign(p.y)*p.x  );\n}\nfloat nBox(in float2 p, in float2 size, in float radius)       // $Fab\n{\n    float2 a = abs(p),\n           s = .5+.5*sign(p);   // 0 or 1.\n\treturn 3.14* ( a.x > a.y ? s.x: .5 + s.y ); \n}\n\n#define sdFrame(p,size,radius) ( abs( sdBox(p,size,radius) ) - 10. )\n#define uFrame - uBox\n#define nFrame(p,size,radius) ( nBox(p,size,radius) + 3.14*float(sdBox(p,size,radius) < 0. ) )\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}", "buffer_a_code": "float4 map(float2 p)\n{\n    float2 center = float2( 350., 350. * iResolution.y / iResolution.x );\n\tfloat2 d = float2( 1000., -1.);\n    \n\td = merge( d, float2( sdFrame( translate( p, center), float2( 195., 195. ), 20.), 0 ) );\n\td = carve( d, float2( -sdBox(  translate( p ,center+float2(195,0)), float2( 40 ), 20.), 0 ) );\n\td = merge( d, float2( sdCircle( translate( p, center), 50.0 ), 1 ) );\n    \n    // defered calculation on uv and normals. More efficient, but duplicates scene description\n    float u = d.y==0. ? uBox( translate( p, center), float2( 195., 195. ), 20.) // uv and normals\n            : d.y==1. ? uCircle( translate( p, center), 50.0 )\n            : -1.,\n          a = d.y==0. ? nBox( translate( p, center), float2( 195., 195. ), 20.)\n            : d.y==1. ? nCircle( translate( p, center), 50.0 )\n            : -1.;\n                         \n    return float4( d, u, a );\n}\n\nvoid mainImage( out vec4 fragColor, in float2 fragCoord )\n{\n    vec2 uv = 700. * (fragCoord + .5) / iResolution.x;\n\n\tfragColor = map( uv );\n    fragColor.x /= 700.;                                  // normalize distances to [0,1] space\n}", "buffer_a_inputs": [], "buffer_b_code": "\nconst int\n\tKEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70, KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74,\n\tKEY_K = 75, KEY_L = 76, KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82, KEY_S = 83, KEY_T = 84,\n\tKEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90;\n//  LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n//  Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n\nbool is_key_down   (int code) { return code != 0 && texelFetch(iChannel1, ivec2(code, 0), 0).r > 0.; }\nbool is_key_pressed(int code) { return code != 0 && texelFetch(iChannel1, ivec2(code, 1), 0).r > 0.; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( iFrame == 0 )\n    \tfragColor = vec4(.5, 0, .1, 0);\n    else \n      if (fragCoord == vec2(.5 )) {\n\t\tfragColor = texelFetch( iChannel0, ivec2(0), 0 );   \n        float eps = .01;\n        if ( is_key_down( KEY_W ) ) fragColor.z += eps;\n        if ( is_key_down( KEY_S ) ) fragColor.z -= eps;\n        if ( is_key_down( 37 )    ) fragColor.x += eps;\n        if ( is_key_down( 39 )    ) fragColor.x -= eps;\n        if ( is_key_down( 38 )    ) fragColor.z += eps;\n        if ( is_key_down( 40 )    ) fragColor.z -= eps;\n        \n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 281, 360, 360, 839], [841, 841, 900, 900, 4071]], "test": "untested"}
{"id": "wsGfWR", "name": "Rubber bands", "author": "jarble", "description": "This fractal appears to be made of rubber bands.", "tags": ["fractal"], "likes": 2, "viewed": 322, "published": 3, "date": "1606893114", "time_retrieved": "2024-07-30T20:32:43.246865", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin(floor(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,1.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0), cos(iTime*speed/10.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    int t1 = t/32/32*3;\n    t = (8-t%3)*((t/(1+(t1/16)%3)%3)*3/2)|t/64|t/64/64;\n    //t = (8-t1%2-t%3-t1%7)*((t/(1+(t1/3)%3+(t1/7/2)%3+(t1/4)%3+(t1/8)%3+(t1/16)%3)%3)*3/2)|t/64;\n    t *= 8;\n    \n   \treturn vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 3000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 2; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result;\n}\n\n/*\nvec2 sound1(int t)\n{\n    int t1 = t/32/32*3;\n    t = (8-t1%2+t1%5)*((t/(1+(t1/24)%3)%3)*3/2)|t/32|t/64;\n    t *= 8;\n   \treturn vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 3000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 2; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result;\n}\n\n*/", "sound_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx/i/2.0)*i+sin(p1/i)*i))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    //p += vec3(1,-10,170);\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n        \n    \t//p += mod(sin(p/i),i);\n        result = max(result, planet_surface(p*i,i)/(i));\n    \ti *= -(1.5);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 118, 230], [233, 654, 745, 745, 1108], [1123, 1377, 1442, 1442, 1574], [1576, 1665, 1694, 1731, 2041], [2043, 2535, 2675, 2675, 3285], [3287, 3657, 3742, 3742, 4157], [4159, 4486, 4535, 4570, 4701], [4703, 4703, 4760, 4760, 5884]], "test": "untested"}
{"id": "tdGfWR", "name": "Wire coils", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/WdGfDz]\"Web Tunnels.\"[/url] This fractal looks like an endless coil of wires.", "tags": ["fractal", "wire"], "likes": 1, "viewed": 300, "published": 3, "date": "1606889834", "time_retrieved": "2024-07-30T20:32:44.305036", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    //p += vec3(1,-10,170);\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n        \n    \t//p += mod(sin(p/i),i);\n        result = max(result, planet_surface(p,i)/(i));\n    \ti *= -(1.5);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin(floor(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,1.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0), cos(iTime*speed/10.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = length(depth_map(fragCoord).xyz-eye);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n        //distance fog\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye)/(vec3(dist)+50.0)*50.0;\n    \n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    int t1 = t/32/32*3;\n    t = (8-t1%2-t%3-t1%7-t1%11)*((t/(1+(t1/3)%3)%3)*5/4)|t/64;\n    t *= 8;\n    \n   \treturn vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 3000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 2; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result;\n}", "sound_inputs": [], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    //p += vec3(1,-10,170);\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n        \n    \t//p += mod(sin(p/i),i);\n        result = max(result, planet_surface(p,i)/(i));\n    \ti *= -(1.5);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin(floor(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dmap = depth_map(fragCoord).xyz;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,1.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0), cos(iTime*speed/10.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    float l0 = log(length(dmap)+1.0)*2.0;\n    if(l0 < 15.0){\n        l0 = 0.0;\n    }\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx)*i+cos(p1)*i))*size;\n    return length(p) - size;\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 339, 339, 667], [669, 669, 692, 692, 719], [721, 721, 749, 779, 891], [894, 1315, 1406, 1406, 1727], [1742, 1996, 2061, 2061, 2193], [2195, 2284, 2313, 2350, 2660], [2662, 3154, 3294, 3294, 3904], [3906, 4276, 4361, 4361, 4776], [4778, 5105, 5154, 5189, 5320], [5322, 5322, 5349, 5349, 5404], [5406, 5406, 5463, 5463, 6691]], "test": "untested"}
{"id": "WdGfDz", "name": "Web tunnels", "author": "jarble", "description": "Another edit of one of my city fractals.", "tags": ["fractal", "web"], "likes": 2, "viewed": 316, "published": 3, "date": "1606883495", "time_retrieved": "2024-07-30T20:32:45.076972", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin(floor(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    const float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,1.0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    int t1 = t/32/32*3;\n    t = (8-(t/32/32*3)%7)*((t/(1+(t1)%3+(t1/2)%3+(t1/4)%3+(t1/8)%3)%3)*3/2)|t/32|t/2/32;\n    \n   \treturn vec2(float(t*8 & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 3000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 2; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx)*i+cos(p1)*i))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    //p += vec3(1,-10,170);\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n        \n    \t//p += mod(sin(p/i),i);\n        result = max(result, planet_surface(p,i)/(i));\n    \ti *= -3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    //p = floor(mod(p,10.0));\n    return sin(floor(vec3(planet_surface(p,3.0),planet_surface(p,5.0),planet_surface(p,7.0))))/10.0+vec3(.6);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*.1)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n} \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    const float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,1.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-5,sin(iTime*speed/10.0), cos(iTime*speed/10.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 118, 230], [233, 654, 745, 745, 1066], [1081, 1335, 1400, 1400, 1532], [1534, 1623, 1652, 1689, 1999], [2001, 2493, 2633, 2633, 3243], [3245, 3615, 3700, 3700, 4115], [4117, 4444, 4493, 4528, 4659], [4661, 4661, 4688, 4688, 4837], [4839, 4839, 4896, 4896, 5592]], "test": "untested"}
{"id": "3dGBWz", "name": "Grid of circles with patterns", "author": "AI", "description": "Define your own pattern in the generator function of the code, to see how it emerges on the grid of circles", "tags": ["circles", "grid", "patterns", "generativeart", "creativecoding"], "likes": 8, "viewed": 446, "published": 3, "date": "1606866608", "time_retrieved": "2024-07-30T20:32:45.823975", "image_code": "float circle(in vec2 st, in float radius){\n    float d=length(st-.5);\n    return smoothstep(radius,radius-.01,d);\n    \n}\n\n// change pattern variable to get different patterns\nfloat generator (in vec2 cell,in float mult) {    \n    float pattern;\n    pattern=mult*(sin(cell.x*iTime/7.)+sin(cell.y*iTime/7.));\n    return fract(pattern);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    float multiplier=0.8754;\n    float Ncircles=12.;    \n    uv *= Ncircles; \n    vec2 posInt = floor(uv)+1.;  //(i,j) integerr coordinates\n    vec2 posFloat = fract(uv); //(u,v) decimal cell coordinates \n    vec3 color =generator(posInt,multiplier) *vec3(1.,.5+.5*cos(iTime),.5+.5*sin(iTime));\n\tcolor*=circle(posFloat,.5);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 120], [122, 175, 221, 221, 335], [337, 337, 392, 392, 833]], "test": "untested"}
{"id": "WdyfDR", "name": "Costas Arrays", "author": "mla", "description": "As suggested by ollj - Costas Arrays, every vector between pairs of points is unique.\n\nThere are 2160 of size 10: [url]https://oeis.org/A008404[/url]\n\n", "tags": ["arrays", "permutations", "costas"], "likes": 7, "viewed": 412, "published": 3, "date": "1606865632", "time_retrieved": "2024-07-30T20:32:46.680685", "image_code": "// Costas Arrays, Matthew Arcus, mla, 2020\n// Each time step, Buffer A computes the lexicographically\n// next Costas array (see the costas() function in Common).\n//\n// Thanks to ollj for the idea.\n\n// Board state is stored as a permutation (map of column to rows)\n// represented as 4-bit ints in a uvec4.\n//\n// N, defined in Common, is size of board (gets slow for N > 12).\n// speed is timesteps per second, or 0.0 for flat out.\n//\n// SPEED, defined in Common is maximum number of iterations of\n// main loop - if the state becomes inconsistent (eg. from\n// changing parameters on the fly) or the problem is too large\n// (eg. Costas for N > 12 or so), the Buffer A shader gets\n// timed out and WebGL hangs or crashes. Default is 100000.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    float maxres = max(iResolution.x,iResolution.y);\n    float minres = min(iResolution.x,iResolution.y);\n    vec2 uv = (fragCoord - 0.5*max(vec2(0),iResolution.xy-minres))/minres;\n\tfragColor = vec4(0.5);\n    if (abs(uv.x-0.5) > 0.5 || abs(uv.y-0.5) > 0.5) return;\n    bitstring board = vec2bitstring(texelFetch(iChannel0, ivec2(0,0),0));\n    uv *= float(N);\n\tint i = int(uv.x);\n    int j = int(uv.y);\n    vec3 col = i%2 == j%2 ? vec3(0) : vec3(1);\n    float pwidth = fwidth(uv.x);\n    if (j == get(board,i)) {\n        col = mix(vec3(1,0,0),col,\n                  smoothstep(0.0,2.0*pwidth,\n                             length(uv-vec2(i,j)-0.5)-0.4));   \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int N = 12; // The size of the board, 16 is the largest supported.\nconst int M = 4; // Number of bits for each position, 32%M = 0 or NM <= 32\nfloat SPEED = 2.0; // Timesteps per second, 0.0 for flat out.\nint MAXITERATIONS = 100000; // Limit number of iterations to prevent shader timeout\n#define bitstring uvec4\nint get(bitstring s, int i);\n\n// s represents a permutation of N items.\n\n// Costas arrays: https://oeis.org/A008404\nbool costas(bitstring s, int i) {\n  if (i < 2) return true;\n  int ival = get(s,i);\n  for (int step = 1; step < i; step++) {\n    int diff = ival-get(s,i-step);\n    for (int j = i-1; j >= step; j--) {\n      int diff2 = get(s,j)-get(s,j-step);\n      if (diff == diff2) return false;\n    }\n  }\n  return true;\n}\n\n// A permutation is valid if check(s,i) is\n// true for all 0 <= i < N.\n// eg. for derangements, check((1,3,0,2,4),i) \n// is true for i < 4 but false for i = 4.\n// or for N-queens, get(s,i) is the row occupied by the\n// queen in column i and check(s,i) is true if queen\n// in column i is not under diagonal attack by any\n// queen in column j < i.\nbool check(bitstring s, int j) {\n    // Uncomment another one of these lines for a different permutation problem.\n    // (and set time back to 0 to ensure current state is valid). \n    return costas(s,j);\n    //return true; // Factorial: https://oeis.org/A000142\n    //return get(s,j) != j; // Derangement //https://oeis.org/A000166\n    //return get(s,j) > j || get(s,get(s,j)) == j; // Involution: https://oeis.org/A000085\n    //return get(s,j) != j && get(s,j) != (j+1)%N; // Ménage: https://oeis.org/A000179\n    //return abs(j-get(s,j)) > 1; // Restricted range\n    for (int i = 0; i < j; i++) {\n        // https://oeis.org/A000170\n        // n-queens - no bishop attack\n        // permutation guarantees no rook attack\n        if (abs(get(s,j)-get(s,i)) == abs(j-i)) {\n            return false;\n\t\t}\n    }\n    return true;\n}\n\nbitstring vec2bitstring(vec4 s) {\n    return floatBitsToUint(s);\n}\n\nvec4 bitstring2vec(bitstring s) {\n    return uintBitsToFloat(s);\n}\n\nconst uint MASK = (1U<<M)-1U;\n\nint get(bitstring s, int i) {\n    int word = M*i/32, offset = M*i%32;\n    uint t = s[word];\n    return int((t >> offset) & MASK);\n}\n\nbitstring set(bitstring s, int i, int x) {\n    int word = M*i/32, offset = M*i%32;\n    uint t = s[word];\n    t &= ~(MASK << offset);\n    t |= uint(x) << offset;\n    s[word] = t;\n    return s;\n}\n\nbitstring swap(bitstring s, int i, int j) {\n    int t = get(s,i); \n    s = set(s,i,get(s,j)); \n\ts = set(s,j,t);\n\treturn s;\n}\n\nbitstring reverse(bitstring s,int i,int j) {\n    j -= 1;\n    while (i < j){\n        s = swap(s,i,j);\n        i += 1; j -= 1;\n    }\n    return s;\n}", "buffer_a_code": "// Given a permutation known to be valid at j < i,\n// and assumed to be ascending order for j >= i,\n// find the first non-valid value j >= i, and reverse\n// the order of the elements after j (with the effect\n// that permutations with that prefix are skipped).\nint checkvalid(inout bitstring s, int i) {\n    for ( ; i < N; i++) {\n        if (!check(s,i)) {\n            s = reverse(s,i+1,N);\n            break;\n        }\n    }\n    return i;\n}\n\nbitstring nextperm(bitstring s) {\n    for (int count = 0; count < MAXITERATIONS; count++) {\n        int i = N-1;\n        // Find longest descending suffix\n        while (i > 0 && get(s,i-1) >= get(s,i)) i--;\n        if (i == 0) { \n            // whole sequence is descending\n            // so change to all ascending\n            s = reverse(s,0,N);\n            // and find first invalid element\n            // if all valid, return\n            if (checkvalid(s,0) == N) return s;\n        } else {\n            // find element to increment\n        \tint j = N-1;\n        \twhile (get(s,j) <= get(s,i-1)) j--;\n        \ts = swap(s,i-1,j);\n            if (check(s,i-1)) {\n\t            // i-1 can't be last element\n    \t        // first permutation with those suffix elements\n        \t\ts = reverse(s,i,N);\n            \t// find invalid element & reorder\n        \t\tif (checkvalid(s,i) == N) return s;\n        \t}\n        }\n   }\n   return bitstring(0); //timeout!\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (ivec2(fragCoord) == ivec2(1,0)) {\n        float lastInterval = 0.0;\n        if (iFrame != 0) {\n            float lastTime = texelFetch(iChannel0, ivec2(1,0), 0).x;\n            lastInterval = iTime-lastTime;\n        }\n        fragColor = vec4(iTime,lastInterval,0,0);\n        return;\n    }\n\n    if (ivec2(fragCoord) == ivec2(0,0)) {\n        bitstring board = vec2bitstring(texelFetch(iChannel0, ivec2(0,0),0));\n        float lastTime = -1.0;\n        // It seems that the buffer data can get cleared on a resize\n        // without triggering the iFrame == 0 test. \n        if (iFrame == 0 || board == bitstring(0)) {\n            for (int i = 0; i < 16; i++) {\n            \tboard = set(board,i,i);\n            }\n            if (checkvalid(board,0) == N) lastTime = 0.0;\n        } else {\n            lastTime = texelFetch(iChannel0, ivec2(1,0), 0).x;\n        }\n        if (SPEED == 0.0 || floor(SPEED*lastTime) != floor(SPEED*iTime)) {\n            board = nextperm(board);\n        }\n    \tfragColor = bitstring2vec(board);\n    }   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[737, 737, 794, 844, 1538]], "test": "untested"}
{"id": "tdVfzm", "name": "hoeled_sliced", "author": "hoeled", "description": "Played around with atan and uv.", "tags": ["breathing"], "likes": 3, "viewed": 285, "published": 3, "date": "1606857202", "time_retrieved": "2024-07-30T20:32:47.539389", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(1.);\n    float t = sin(iTime*.7)*.1+.8;\n    \n    uv *= 2.4;\n    \n    uv.y *= uv.y / t;\n    uv.y += atan(t, iTime*t);\n    uv.x /= uv.y;\n    uv.x = fract(uv.x*t);\n    \n    col -= vec3(atan(uv.x*uv.x, uv.y*uv.y), atan(uv.y*uv.y, uv.x*uv.x), atan(uv.y*uv.y, uv.y*uv.y*t));\n    col.r = col.g;\n    col.g = 0.;\n    \n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;   \n    col -= vec3(atan(uv.x*uv.x*t, uv.y*uv.y), atan(uv.y*uv.y, uv.x*uv.x), atan(uv.y*uv.y, uv.y*uv.y*t))*.7;\n    col *= smoothstep(0.0, 0.271, length(uv.y));\n    col.r *= 1.4;\n    \n    uv *= 4.;\n    uv.y *= uv.y / t;\n    uv.y += atan(t, iTime*t);\n    uv.x /= uv.y;\n    uv.x = fract(uv.x*t);\n\n    col *= vec3(atan(uv.x*uv.x, uv.y*uv.y), atan(uv.y*uv.y, uv.x*uv.x), atan(uv.y*uv.y, uv.y*uv.y*t));\n    \n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float d = length(uv);\n    float m = .0025/d;\n    float c = m*pow(t, 5.);\n    col.rg += vec2(c, c-.3);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1092]], "test": "untested"}
{"id": "WsKBRz", "name": "Eight Queens", "author": "mla", "description": "Solving the 8-queens problem (as well as 16-queens or other problems, see Common tab).", "tags": ["eight", "queens"], "likes": 8, "viewed": 302, "published": 3, "date": "1606856219", "time_retrieved": "2024-07-30T20:32:48.401085", "image_code": "// N-queens problem, Matthew Arcus, mla, 2020\n// Each time step, Buffer A computes successive solutions\n// to the N-queens problem (or other subset of permutations,\n// see the check() function in Common).\n//\n// Board state is stored as a permutation (map of column to rows)\n// represented as 4-bit ints in a uvec4.\n//\n// N, defined in Common, is size of board.\n// speed is timesteps per second, or 0.0 for flat out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    float maxres = max(iResolution.x,iResolution.y);\n    float minres = min(iResolution.x,iResolution.y);\n    vec2 uv = (fragCoord - 0.5*max(vec2(0),iResolution.xy-minres))/minres;\n\tfragColor = vec4(0.5);\n    if (abs(uv.x-0.5) > 0.5 || abs(uv.y-0.5) > 0.5) return;\n    bitstring board = vec2bitstring(texelFetch(iChannel0, ivec2(0,0),0));\n    uv *= float(N);\n\tint i = int(uv.x);\n    int j = int(uv.y);\n    vec3 col = vec3(i%2 != j%2);\n    if (j == get(board,i)) {\n        col = mix(vec3(1,0,0),col,\n                  smoothstep(0.0,2.0*fwidth(uv.x),\n                             length(uv-vec2(i,j)-0.5)-0.4));   \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Given a permutation known to be valid at j < i,\n// and assumed to be ascending order for j >= i,\n// find the first non-valid value j >= i, and reverse\n// the order of the elements after j (with the effect\n// that permutations with that prefix are skipped).\nint checkvalid(inout bitstring s, int i) {\n    for ( ; i < N; i++) {\n        if (!check(s,i)) {\n            s = reverse(s,i+1,N);\n            break;\n        }\n    }\n    return i;\n}\n\nbitstring nextperm(bitstring s) {\n    for (int count = 0; count < MAXITERATIONS; count++) {\n        int i = N-1;\n        // Find longest descending suffix\n        while (i > 0 && get(s,i-1) >= get(s,i)) i--;\n        if (i == 0) { \n            // whole sequence is descending\n            // so change to all ascending\n            s = reverse(s,0,N);\n            // and find first invalid element\n            // if all valid, return\n            if (checkvalid(s,0) == N) return s;\n        } else {\n            // find element to increment\n        \tint j = N-1;\n        \twhile (get(s,j) <= get(s,i-1)) j--;\n        \ts = swap(s,i-1,j);\n            if (check(s,i-1)) {\n\t            // i-1 can't be last element\n    \t        // first permutation with those suffix elements\n        \t\ts = reverse(s,i,N);\n            \t// find invalid element & reorder\n        \t\tif (checkvalid(s,i) == N) return s;\n        \t}\n        }\n   }\n   return bitstring(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (ivec2(fragCoord) == ivec2(1,0)) {\n        float lastInterval = 0.0;\n        if (iFrame != 0) {\n            float lastTime = texelFetch(iChannel0, ivec2(1,0), 0).x;\n            lastInterval = iTime-lastTime;\n        }\n        fragColor = vec4(iTime,lastInterval,0,0);\n        return;\n    }\n\n    if (ivec2(fragCoord) == ivec2(0,0)) {\n        bitstring board = vec2bitstring(texelFetch(iChannel0, ivec2(0,0),0));\n        float lastTime = -1.0;\n        if (iFrame == 0 || board == bitstring(0)) {\n            for (int i = 0; i < 16; i++) {\n            \tboard = set(board,i,i);\n            }\n            if (checkvalid(board,0) == N) lastTime = 0.0;\n        } else {\n            lastTime = texelFetch(iChannel0, ivec2(1,0), 0).x;\n        }\n        if (speed == 0.0 || floor(speed*lastTime) != floor(speed*iTime)) {\n            board = nextperm(board);\n        }\n    \tfragColor = bitstring2vec(board);\n    }   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int N = 8; // The size of the board, 16 is the largest supported.\nconst int M = 4; // Number of bits for each position, 32%M = 0 or NM <= 32\nconst uint MASK = (1U<<M)-1U;\nfloat speed = 2.0; // Timesteps per second, 0.0 for flat out.\nint MAXITERATIONS = 100000;\n\n#define bitstring uvec4\nint get(bitstring s, int i);\n\n// s represents a permutation of N items.\n\n// A permutation is valid if check(s,i) is\n// true for all 0 <= i < N.\n// eg. for derangements, check((1,3,0,2,4),i) \n// is true for i < 4 but false for i = 4.\n// or for N-queens, get(s,i) is the row occupied by the\n// queen in column i and check(s,i) is true if queen\n// in column i is not under diagonal attack by any\n// queen in column j < i.\nbool check(bitstring s, int j) {\n    // Uncomment one of these lines for a different permutation problem.\n    //return true; // Factorial: https://oeis.org/A000142\n    //return get(s,j) != j; // Derangement //https://oeis.org/A000166\n    //return get(s,j) > j || get(s,get(s,j)) == j; // Involution: https://oeis.org/A000085\n    //return get(s,j) != j && get(s,j) != (j+1)%N; // Ménage: https://oeis.org/A000179\n    //return abs(j-get(s,j)) > 1; // Restricted range\n    for (int i = 0; i < j; i++) {\n        // https://oeis.org/A000170\n        // n-queens - no bishop attack\n        // permutation guarantees no rook attack\n        if (abs(get(s,j)-get(s,i)) == abs(j-i)) {\n            return false;\n\t\t}\n    }\n    return true;\n}\n\nbitstring vec2bitstring(vec4 s) {\n    return floatBitsToUint(s);\n}\n\nvec4 bitstring2vec(bitstring s) {\n    return uintBitsToFloat(s);\n}\n\nint get(bitstring s, int i) {\n    int word = M*i/32, offset = M*i%32;\n    uint t = s[word];\n    return int((t >> offset) & MASK);\n}\n\nbitstring set(bitstring s, int i, int x) {\n    int word = M*i/32, offset = M*i%32;\n    uint t = s[word];\n    t &= ~(MASK << offset);\n    t |= uint(x) << offset;\n    s[word] = t;\n    return s;\n}\n\nbitstring swap(bitstring s, int i, int j) {\n    int t = get(s,i); \n    s = set(s,i,get(s,j)); \n\ts = set(s,j,t);\n\treturn s;\n}\n\nbitstring reverse(bitstring s,int i,int j) {\n    j -= 1;\n    while (i < j){\n        s = swap(s,i,j);\n        i += 1; j -= 1;\n    }\n    return s;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 474, 524, 1177]], "test": "untested"}
{"id": "tsVfzm", "name": "Grass Cross Section", "author": "jacasch", "description": "TO Create 3D Texture lookup for extreamly fast grass shader", "tags": ["sdf"], "likes": 0, "viewed": 279, "published": 3, "date": "1606855182", "time_retrieved": "2024-07-30T20:32:49.447287", "image_code": "float sdTilableCircle(vec2 p, vec2 o)\n{\n    //neighbour offsets\n    vec2 o1 = vec2(-1,-1);\n    vec2 o2 = vec2(-1,0);\n    vec2 o3 = vec2(-1,1);\n    vec2 o4 = vec2(0,-1);\n    vec2 o5 = vec2(0,0);\n    vec2 o6 = vec2(0,1);\n    vec2 o7 = vec2(1,-1);\n    vec2 o8 = vec2(1,0);\n    vec2 o9 = vec2(1,1);\n    \n    float radius = .1;\n\n    float d1 = length(p + o+o1) - radius;\n    float d2 = length(p + o+o2) - radius;\n    float d3 = length(p + o+o3) - radius;\n    float d4 = length(p + o+o4) - radius;\n    float d5 = length(p + o+o5) - radius;\n    float d6 = length(p + o+o6) - radius;\n    float d7 = length(p + o+o7) - radius;\n    float d8 = length(p + o+o8) - radius;\n    float d9 = length(p + o+o9) - radius;\n    \n    return min(min(min(min(min(min(min(min(d1,d2),d3),d4),d5),d6),d7),d8),d9);\n}\n\nfloat sdCrossSection(vec2 p)\n{\n    float d1 = sdTilableCircle(p,vec2(.63,.5));\n    float d2 = sdTilableCircle(p,vec2(.1,.2));\n    float d3 = sdTilableCircle(p,vec2(.4,0.9));\n    float d4 = sdTilableCircle(p,vec2(.9,0.7));\n    float d5 = sdTilableCircle(p,vec2(.3,0.5));\n    float d6 = sdTilableCircle(p,vec2(.7,0.1));    \n    \n    return min(min(min(min(min(d1,d2),d3),d4),d5),d6);\n}\n\nvec2 GetNormal(vec2 p)\n{\n    float d = sdCrossSection(p);\n    float eps = 0.0001;\n    float dx = sdCrossSection(fract(p + vec2(eps,0) + .5)-.5);\n    float dy = sdCrossSection(fract(p + vec2(0,eps) + .5)-.5);\n    \n    float ddx = dx-d;\n    float ddy = dy-d;\n    \n    //return vec2(1,1);\n    return normalize(vec2(ddx,ddy));\n    //return n;\n}\n\nfloat rayMarch(vec2 ro, vec2 rd, out vec2 normal)\n{\n    float minDist = 0.00001;\n    int maxSteps = 100;\n    int s = 0;\n    \n    float rayDist = 0.;\n    float surfaceDist = sdCrossSection(ro);\n    //for(int i = 0; i < maxSteps; i++);\n    while(s < maxSteps)\n    {\n        if(abs(surfaceDist) < minDist)\n        {\n            //ray hit\n            normal = GetNormal(fract(ro + rd * rayDist + .5)-.5);\n            return rayDist;\n        }\n        s++;\n        rayDist += surfaceDist;\n        surfaceDist = sdCrossSection(fract(ro + rd * rayDist + .5)-.5);\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.;\n    uv = fract(uv);\n\tuv -= .5;\n    \n    vec2 n;\n    float d = rayMarch(uv,normalize(vec2(-1,1)), n);\n    n = n * .5 + .5;\n\n    // Output to screen\n    fragColor = vec4(n * (1.-d),0.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 63, 787], [789, 789, 819, 819, 1172], [1174, 1174, 1198, 1198, 1514], [1516, 1516, 1567, 1567, 2094], [2096, 2096, 2153, 2208, 2495]], "test": "untested"}
{"id": "tsKBzm", "name": "6483 123", "author": "Fililip", "description": "6483 123", "tags": ["123", "6483"], "likes": 2, "viewed": 278, "published": 3, "date": "1606852044", "time_retrieved": "2024-07-30T20:32:50.278066", "image_code": "float sdf(vec3 p)\n{\n    float m = 1.0;\n    for (float i = 0.0; i < 4.0; i++)\n    {\n        vec4 sphere = vec4(cos(p.y * 4.0 + iTime * i * 2.0 + i * 2.0) * 0.15 + 3.0 * i - 4.0, sin(iTime * 15.0 + i * 5.0) * 0.5 + 1.25 + sin(p.x * 4.0 + iTime * 10.0 + i * 6.0) * 0.15 + 1.2, 6.0, 1.0);\n        float distanceSphere = length(p - sphere.xyz) - sphere.w;\n        m = min(m, distanceSphere);\n    }\n    float distancePlane = p.y + cos(p.x + iTime * 2.5) * sin(p.z + iTime * 32.0) * 0.5 + cos(p.z + iTime * 32.0) * 0.5 + 1.75;\n    return min(m, distancePlane);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 delta = vec2(0.01, 0.0);\n    float dist = sdf(p);\n    return normalize(dist - vec3(\n        sdf(p - delta.xyy),\n        sdf(p - delta.yxy),\n        sdf(p - delta.yyx)\n    ));\n}\n\nfloat raymarch(vec3 origin, vec3 direction)\n{\n    float distanceOrigin = 0.0;\n    \n    for (int i = 0; i < 64; i++)\n    {\n        vec3 point = origin + direction * distanceOrigin;\n        float distanceScene = sdf(point);\n        distanceOrigin += distanceScene;\n        if (distanceOrigin < 0.01 || distanceOrigin > 100.0) break;\n    }\n    \n    return distanceOrigin;\n}\n\nvec3 light(vec3 p, vec3 pos, vec3 col, float s)\n{\n    vec3 l = normalize(pos - p);\n    vec3 n = normal(p);\n    \n    float dist = distance(p, pos);\n    float att = 1.0 / (dist + 0.15 * dist + 0.15 * dist * dist);\n    \n    float diffuse = clamp(dot(l, n), 0.0, 1.0);\n    \n    float d = raymarch(p + n * 0.2, l);\n    if (d < length(pos - p)) diffuse *= 0.1;\n    \n    return col * texture(iChannel0, n.xz).rgb * smoothstep(0.0, 1.0, diffuse) * att * s;\n}\n\nvec3 lights(vec3 p)\n{\n    vec3 position = vec3(0.0, 6.0, 6.0);\n    position.xz += vec2(cos(iTime * 2.0), sin(iTime * 2.0)) * 2.0;\n    \n    vec3 l = vec3(0.0);\n    \n    vec3 color = vec3(0.5);\n    \n    color.r = sin(iTime * 2.0 + 50.0) * 0.25 + 1.0;\n    color.g = cos(iTime * 2.0 + 150.0) * 0.25 + 1.0;\n    color.b = sin(iTime * 2.0 + 200.0) * 0.25 + 1.0;\n    \n    l += light(p, position, color, 16.0);\n    l += light(p, vec3(-4.0, 4.0, -1.0), vec3(0.15, 0.15, 0.8), 18.0);\n    l += light(p, vec3(4.0, 4.0, -1.0), vec3(0.15, 0.8, 0.15), 18.0);\n    \n    return l;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 2.5, 0.0);\n    vec3 rd = normalize(vec3(uv.x - cos(iTime * 29.4) * 0.01, uv.y - sin(iTime * 34.0) * 0.01, 0.5));\n    \n    float dist = raymarch(ro, rd);\n    \n    vec3 p = ro + rd * dist;\n    vec3 diffuse = lights(p);\n    \n    col = diffuse;\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 555], [557, 557, 578, 578, 764], [766, 766, 811, 811, 1136], [1138, 1138, 1187, 1187, 1588], [1590, 1590, 1611, 1611, 2153], [2155, 2155, 2210, 2210, 2612]], "test": "untested"}
{"id": "wdVBRm", "name": "hoeled_bars_remix_2", "author": "hoeled", "description": "Playing around with my bars shader https://www.shadertoy.com/view/wd3BW2", "tags": ["2d"], "likes": 11, "viewed": 386, "published": 3, "date": "1606844907", "time_retrieved": "2024-07-30T20:32:51.208578", "image_code": "float Random(vec2 p) {\n\tp = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nfloat T(float a) {\n    float random = Random(vec2(a*532.43, a*784.34));\n    float interval = clamp(random, 0.3, 0.6);\n\treturn clamp((sin(iTime*a*1.4*random)+1.)/2., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    uv *= .85;\n    \n    // scaling\n    uv.x *= 4.5;\n    uv.y -= .5;\n        \n    // bars\n    for(float i=.0; i<64.; i=i+2.){\n        // thickness\n    \tfloat width = 0.08+sin(i)*(sin(iTime*Random(vec2(i, 654.543)))*.4+.5);  \n    \tfloat edge = 0.01*(sin(iTime*Random(vec2(i, 654.543)))*.4+.5);\n        \n        //bar\n        float m1 = smoothstep(width+edge, width, abs((uv.x-3.2+(i/10.))));\n        \n        col += m1 * T(2.+(i*.02));\n        col += m1*.1;\n        \n        //float m2 = smoothstep(width/10.+edge/10., width/10., abs((uv.y-.2+(i/20.))));\n        //col -= m2*.1;\n    }\n    //col = clamp(col, 0., 2.);\n    \n    // colors\n    col.r -= T(.2)*1.5;\n    col.g -= T(.6)*1.5;\n    col.b -= T(1.4)*1.5;\n    \n    col.rgb += T(uv.x)*.03;\n    \n    col -= vec3(.4);\n    \n\t// vignette\n    col *= smoothstep(-.95, .0, uv.y);\n    col *= smoothstep(0., -.95, uv.y);\n    col *= smoothstep(-5., 1., uv.x);\n    col *= smoothstep(5., -1., uv.x);\n    col += col*2.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 113], [115, 115, 133, 133, 290], [292, 292, 349, 349, 1433]], "test": "untested"}
{"id": "wdKfzw", "name": "Collision Detection With SDFs", "author": "oneshade", "description": "Since SDFs give the distace to a surface they are great for collision detection! Click to see the distance field.", "tags": ["2d", "sdf", "collisiondetection"], "likes": 46, "viewed": 645, "published": 3, "date": "1606841112", "time_retrieved": "2024-07-30T20:32:52.031378", "image_code": "float movingDisk(in vec2 p, in vec2 o, in float r, in vec2 v, in float dt) {\n    vec2 p0 = p - o, p1 = v * dt;\n\n    float a = dot(p1, p1);\n    float b = dot(p0, p1);\n    float c = dot(p0, p0) - r * r;\n\n    float h = b * b - a * c;\n    if (h > 0.0) {\n        vec2 t = clamp((vec2(-1.0, 1.0) * sqrt(h) - b) / a, 0.0, 1.0);\n        return t.y - t.x;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n    vec2 ballPos = getBallPos();\n\n    float distanceField = mapEnvironment(uv);\n    fragColor = vec4(0.0, 0.0, smoothstep(unit, 0.0, distanceField), 1.0);\n    if (iMouse.z > 0.0) {\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 1.0), 0.5 * sin(distanceField * 400.0));\n    }\n\n    fragColor.r += movingDisk(uv, ballPos, BALL_RADIUS, getBallVel(), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BALL_RADIUS 0.05\n\n#define getBallPos() texelFetch(iChannel0, ivec2(0, 0), 0).xy\n#define getBallVel() texelFetch(iChannel0, ivec2(1, 0), 0).xy\n\nfloat mapEnvironment(in vec2 p) {\n    vec2 q1 = abs(p) - vec2(0.75, 0.4);\n    vec2 q2 = abs(p + vec2(0.35, 0.0)) - 0.25;\n    float wall = -length(max(q1, 0.0)) - min(max(q1.x, q1.y), 0.0);\n    float box = length(max(q2, 0.0)) + min(max(q2.x, q2.y), 0.0);\n    float ball = length(p - vec2(0.4, 0.0)) - 0.2;\n    return min(wall, min(box, ball));\n}\n\nvec2 getNormal(in vec2 p) {\n    return normalize(vec2(mapEnvironment(p + vec2(0.001, 0.0)) - mapEnvironment(p - vec2(0.001, 0.0)),\n                          mapEnvironment(p + vec2(0.0, 0.001)) - mapEnvironment(p - vec2(0.0, 0.001))));\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    if (iFrame == 0 && iFragCoord == ivec2(1, 0)) {\n        fragColor = vec4(0.02, 0.01, 0.0, 0.0);\n    }\n\n    if (iFrame > 0) {\n        if (iFragCoord.y == 0 && iFragCoord.x < 2) {\n            vec2 ballPos = getBallPos();\n            vec2 ballVel = getBallVel();\n\n            ballPos += ballVel;\n\n            float distToEnv = mapEnvironment(ballPos);\n            if (distToEnv < BALL_RADIUS) {\n                    vec2 hitNormal = getNormal(ballPos);\n                    ballPos += hitNormal * (BALL_RADIUS - distToEnv);\n                    ballVel = reflect(ballVel, hitNormal);\n            }\n\n            if (iFragCoord.x == 0) fragColor = vec4(ballPos, 0.0, 1.0);\n            if (iFragCoord.x == 1) fragColor = vec4(ballVel, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 76, 371], [373, 373, 428, 428, 897]], "test": "untested"}
{"id": "tsVBRw", "name": "kāri kaari", "author": "xenn", "description": "multiscale fluid dynamics.\nThe name, explain: I fed the words 'post' and 'card' into fungibility engine and it returned 'kāri kaari'\nI highly doubt it says anything remotely like 'postcard', though I have a strong notion I would still be comprehended", "tags": ["simulation", "water", "fluid", "mipmap", "turbulence", "mip", "diffusion", "advection", "navier", "stokes", "eddy"], "likes": 12, "viewed": 652, "published": 3, "date": "1606837147", "time_retrieved": "2024-07-30T20:32:52.979842", "image_code": "// Fork of \"coloured fluid\" by xenn. https://shadertoy.com/view/3sVBRm\n// 2020-12-01 15:32:33\n\n// Fork of \"Multiscale MIP Fluid\" by cornusammonis. https://shadertoy.com/view/tsKXR3\n// 2020-12-01 12:43:52\n\n/* \n\tCreated by Cornus Ammonis (2019)\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n/*\n\tThis is a mipmap-based approach to multiscale fluid dynamics.\n\n\tCheck the Common tab for lots of configurable parameters.\n\n\tClick to interact with your mouse. I'd recommend turning off the \"pump\" by\n\tsetting PUMP_SCALE to 0.0 on line 113 of the Common tab to play around with\n\tjust mouse interaction.\n\n\tBuffer B is a multiscale method for computing turbulence along the lines of \n\tthe Large Eddy Simulation method; multiscale curl is also computed in Buffer B, \n    to be passed along to Buffer C.\n\t\n\tBuffer C is a fairly conventional Vorticity Confinement method, also multiscale, \n    using the curl computed in Buffer B. It probably makes more sense to compute \n    each curl scale separately before accumulating, but for the sake of efficiency \n    and simplicity (a larger kernel would be required), I haven't done that here.\n\n\tBuffer D is a multiscale Poisson solver, which converges rapidly but not to an \n    exact solution - this nonetheless works well for the purposes of divergence \n    minimization since we only need the gradient, with allowances for the choice of\n    scale weighting. \n\n\tBuffer A computes subsampled advection and velocity update steps, sampling\n    from Buffers B, C, and D with a variety of smoothing options.\n\n\tThere are a number of options included to make this run faster.\n\n\tUsing mipmaps in this way has a variety of advantages:\n\n\t1. The scale computations have no duplicative or dependent reads, we only need \n       that for advection.\n\t2. No randomness or stochastic sampling is involved.\n\t3. The total number of reads can be greatly reduced for a comparable level of \n       fidelity to some other methods.\n\t4. We can easily sample the entire buffer in one pass (on average).\n\t5. The computational complexity is deferred to mipmap generation (though with\n       a large coefficient), because: \n\t6. The algorithm itself is O(n) with a fixed number of scales (or we could \n       potentially do scale calculations in parallel with mipmap generation, \n       equalling mipmap generation complexity at O(nlogn))\n\n\tNotable downsides:\n\n\t1. Using mipmaps introduces a number of issues, namely:\n       a. Mipmaps can introduce artifacts due to interpolation and downsampling. \n          Using Gaussian pyramids, or some other lowpass filtering method would \n          be better. \n       b. Using higher-order sampling of the texture buffer (e.g. bicubic) would \n          also be better, but that would limit our performance gains. \n       c. NPOT textures are problematic (as always). They can introduce weird \n          anisotropy issues among other things.\n\t2. Stochastic or large-kernel methods are a better approximation to the true\n       sampling distribution approximated here, for a large-enough number of\n       samples.\n    3. We're limited in how we construct our scale-space. Is a power-of-two stride \n       length on both axes always ideal, even along diagonals? I'm not particularly \n       sure. There are clever wavelet methods out there for Navier-Stokes solvers, \n       and LES in particular, too.\n\n*/\n\n\n#define BUMP 32.0\n\n#define D(d) -textureLod(iChannel1, fract(uv+(d+0.0)), mip).w\n\nvec2 diff(vec2 uv, float mip) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = float(1<<int(mip))*vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    return vec2(\n        0.5 * (d_e - d_w) + 0.25 * (d_ne - d_nw + d_se - d_sw),\n        0.5 * (d_n - d_s) + 0.25 * (d_ne + d_nw - d_se - d_sw)\n    );\n}\n\nvec4 contrast(vec4 col, float x) {\n\treturn x * (col - 0.5) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 dxy = vec2(0);\n    float occ, mip = 0.0;\n    float d   = D();\n    \n    // blur the gradient to reduce appearance of artifacts,\n    // and do cheap occlusion with mipmaps\n    #define STEPS 1.0\n    #define ODIST 0.10\n    for(mip = 1.0; mip <= STEPS; mip += 1.0) {\t \n        dxy += (1.0/pow(2.0,mip)) * diff(uv, mip-1.0);\t\n    \tocc += softclamp(-ODIST, ODIST, d - D(),1.0)/(pow(1.5,mip));\n    }\n    dxy /= float(STEPS);\n    \n    // I think this looks nicer than using smoothstep\n    occ = pow(max(0.0,softclamp(0.2,0.8,100.0*occ + 0.5,1.0)),0.5);\n \n    vec3 avd;\n    vec3 ld = light(uv, BUMP, 0.5, dxy, iTime, avd);\n    \n    float spec = ggx(avd, vec3(0,1,0), ld, 0.1, 0.1);\n    \n    #define LOG_SPEC 4000.0\n    spec = (log(LOG_SPEC+1.0)/LOG_SPEC)*log(1.0+LOG_SPEC*spec);    \n    \n    #define VIEW_VELOCITY\n    \n    #ifdef VIEW_VELOCITY\n\t\tvec4 diffuse = softclamp(0.0,1.0,6.0*vec4(texture(iChannel0,uv).xy,0,0)+0.5,2.0);    \n    #elif defined(VIEW_CURL)\n\t\tvec4 diffuse = mix(vec4(1,0,0,0),vec4(0,0,1,0),softclamp(0.0,1.0,0.5+2.0*texture(iChannel2,uv).w,2.0));    \n    #elif defined(VIEW_ADVECTION)\n\t\tvec4 diffuse = softclamp(0.0,1.0,0.0004*vec4(texture(iChannel0,uv).zw,0,0)+0.5,2.0); \n    #elif defined(VIEW_GRADIENT)\n    \tvec4 diffuse = softclamp(0.0,1.0,10.0*vec4(diff(uv,0.0),0,0)+0.5,4.0); \n    #else // Vorticity confinement vectors\n    \tvec4 diffuse = softclamp(0.0,1.0,4.0*vec4(texture(iChannel3,uv).xy,0,0)+0.5,4.0);\n    #endif\n    \n    \n    fragColor = (diffuse + 4.0*mix(vec4(spec),1.5*diffuse*spec,0.3));\n    fragColor = mix(1.0,occ,0.7) * (softclamp(0.0,1.0,contrast(fragColor,4.5),3.0));\n    \n    //fragColor = vec4(occ);\n    //fragColor = vec4(spec);\n    //fragColor = diffuse;\n    //fragColor = vec4(diffuse+(occ-0.5));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TURBULENCE_SAMPLER iChannel3\n#define CONFINEMENT_SAMPLER iChannel2\n#define POISSON_SAMPLER iChannel1\n#define VELOCITY_SAMPLER iChannel0\n\n#define V(d) texture(TURBULENCE_SAMPLER, fract(uv+(d+0.))).xy\n\nvec2 gaussian_turbulence(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec2 d =    V( t.ww); vec2 d_n =  V( t.wy); vec2 d_e =  V( t.xw);\n    vec2 d_s =  V( t.wz); vec2 d_w =  V(-t.xw); vec2 d_nw = V(-t.xz);\n    vec2 d_sw = V(-t.xy); vec2 d_ne = V( t.xy); vec2 d_se = V( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\n#define C(d) texture(CONFINEMENT_SAMPLER, fract(uv+(d+0.))).xy\n\nvec2 gaussian_confinement(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec2 d =    C( t.ww); vec2 d_n =  C( t.wy); vec2 d_e =  C( t.xw);\n    vec2 d_s =  C( t.wz); vec2 d_w =  C(-t.xw); vec2 d_nw = C(-t.xz);\n    vec2 d_sw = C(-t.xy); vec2 d_ne = C( t.xy); vec2 d_se = C( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\n#define D(d) texture(POISSON_SAMPLER, fract(uv+d)).x\n\nvec2 diff(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    return vec2(\n        0.5 * (d_e - d_w) + 0.25 * (d_ne - d_nw + d_se - d_sw),\n        0.5 * (d_n - d_s) + 0.25 * (d_ne + d_nw - d_se - d_sw)\n    );\n}\n\n#define N(d) texture(VELOCITY_SAMPLER, fract(uv+(d+0.)))\n\nvec4 gaussian_velocity(vec2 uv) {\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec4 d =    N( t.ww); vec4 d_n =  N( t.wy); vec4 d_e =  N( t.xw);\n    vec4 d_s =  N( t.wz); vec4 d_w =  N(-t.xw); vec4 d_nw = N(-t.xz);\n    vec4 d_sw = N(-t.xy); vec4 d_ne = N( t.xy); vec4 d_se = N( t.xz);\n    \n    return 0.25 * d + 0.125 * (d_e + d_w + d_n + d_s) + 0.0625 * (d_ne + d_nw + d_se + d_sw);\n}\n\nvec2 vector_laplacian(vec2 uv) {\n    const float _K0 = -20.0/6.0, _K1 = 4.0/6.0, _K2 = 1.0/6.0;\n    vec2 texel = 1.0/iResolution.xy;\n    vec4 t = vec4(texel, -texel.y, 0);\n\n    vec4 d =    N( t.ww); vec4 d_n =  N( t.wy); vec4 d_e =  N( t.xw);\n    vec4 d_s =  N( t.wz); vec4 d_w =  N(-t.xw); vec4 d_nw = N(-t.xz);\n    vec4 d_sw = N(-t.xy); vec4 d_ne = N( t.xy); vec4 d_se = N( t.xz);\n    \n    return (_K0 * d + _K1 * (d_e + d_w + d_n + d_s) + _K2 * (d_ne + d_nw + d_se + d_sw)).xy;\n}\n\n    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 tx = 1.0/iResolution.xy;\n\n    \n    vec2 turb, confine, div, delta_v, offset, lapl = vec2(0);\n    vec4 vel, adv = vec4(0);\n    vec4 init = N();\n\n    #ifdef RECALCULATE_OFFSET\n        for (int i = 0; i < ADVECTION_STEPS; i++) {\n            #ifdef BLUR_TURBULENCE\n            turb = gaussian_turbulence(uv + tx * offset);\n            #else\n            turb = V(tx * offset);\n            #endif\n\n            #ifdef BLUR_CONFINEMENT\n            confine = gaussian_confinement(uv + tx * offset);\n            #else\n            confine = C(tx * offset);\n            #endif\n\n            #ifdef BLUR_VELOCITY\n            vel = gaussian_velocity(uv + tx * offset);\n            #else\n            vel = N(tx * offset);\n            #endif\n\n            // an alternative, but seems to give less smooth results:\n            // offset += (1.0 / float(ADVECTION_STEPS)) * ...\n            offset = (float(i+1) / float(ADVECTION_STEPS)) * - ADVECTION_SCALE * (ADVECTION_VELOCITY * vel.xy + ADVECTION_TURBULENCE * turb - ADVECTION_CONFINEMENT * confine + ADVECTION_DIVERGENCE * div);\n\n            div = diff(uv + tx * DIVERGENCE_LOOKAHEAD * offset);\n\n            lapl = vector_laplacian(uv + tx * LAPLACIAN_LOOKAHEAD * offset);\n\n            adv += N(tx * offset);\n\n            delta_v += VELOCITY_LAPLACIAN * lapl + VELOCITY_TURBULENCE * turb + VELOCITY_CONFINEMENT * confine - DAMPING * vel.xy - DIVERGENCE_MINIMIZATION * div;\n        }\n        adv /= float(ADVECTION_STEPS);\n        delta_v /= float(ADVECTION_STEPS);\n    #else\n        #ifdef BLUR_TURBULENCE\n        turb = gaussian_turbulence(uv);\n        #else\n        turb = V();\n        #endif\n\n        #ifdef BLUR_CONFINEMENT\n        confine = gaussian_confinement(uv);\n        #else\n        confine = C();\n        #endif\n\n        #ifdef BLUR_VELOCITY\n        vel = gaussian_velocity(uv);\n        #else\n        vel = N();\n        #endif\n    \n    \toffset = - ADVECTION_SCALE * (ADVECTION_VELOCITY * vel.xy + ADVECTION_TURBULENCE * turb - ADVECTION_CONFINEMENT * confine + ADVECTION_DIVERGENCE * div);\n        \n    \tdiv = diff(uv + tx * DIVERGENCE_LOOKAHEAD * offset);\n        \n    \tlapl = vector_laplacian(uv + tx * LAPLACIAN_LOOKAHEAD * offset);\n    \t\n    \tdelta_v += VELOCITY_LAPLACIAN * lapl + VELOCITY_TURBULENCE * turb + VELOCITY_CONFINEMENT * confine - DAMPING * vel.xy - DIVERGENCE_MINIMIZATION * div;\n    \n        for (int i = 0; i < ADVECTION_STEPS; i++) {\n            adv += N((float(i+1) / float(ADVECTION_STEPS)) * tx * offset);   \n        }   \n        adv /= float(ADVECTION_STEPS);\n    #endif\n    \n\n    \n    // define a pump, either at the center of the screen,\n    // or alternating at the sides of the screen.\n    vec2 pq = 2.0*(uv*2.0-1.0) * vec2(1,tx.x/tx.y);\n    #ifdef CENTER_PUMP\n    \tvec2 pump = sin(PUMP_CYCLE*iTime)*PUMP_SCALE*pq.xy / (dot(pq,pq)+0.01);\n    #else\n    \tvec2 pump = vec2(0);\n    \t#define AMP 15.0\n    \t#define SCL -50.0\n        float uvy0 = exp(SCL*pow(pq.y,2.0));\n        float uvx0 = exp(SCL*pow(uv.x,2.0));\n        pump += -AMP*vec2(max(0.0,cos(PUMP_CYCLE*iTime))*PUMP_SCALE*uvx0*uvy0,0);\n    \n    \tfloat uvy1 = exp(SCL*pow(pq.y,2.0));\n        float uvx1 = exp(SCL*pow(1.0 - uv.x,2.0));\n        pump += AMP*vec2(max(0.0,cos(PUMP_CYCLE*iTime + 3.1416))*PUMP_SCALE*uvx1*uvy1,0);\n\n        float uvy2 = exp(SCL*pow(pq.x,2.0));\n        float uvx2 = exp(SCL*pow(uv.y,2.0));\n        pump += -AMP*vec2(0,max(0.0,sin(PUMP_CYCLE*iTime))*PUMP_SCALE*uvx2*uvy2);\n    \n    \tfloat uvy3 = exp(SCL*pow(pq.x,2.0));\n        float uvx3 = exp(SCL*pow(1.0 - uv.y,2.0));\n        pump += AMP*vec2(0,max(0.0,sin(PUMP_CYCLE*iTime + 3.1416))*PUMP_SCALE*uvx3*uvy3);\n    #endif\n    \n    fragColor = mix(adv + vec4(VELOCITY_SCALE * (delta_v + pump), offset), init, UPDATE_SMOOTHING);\n    \n    if (iMouse.z > 0.0) {\n        vec4 mouseUV = iMouse / iResolution.xyxy;\n        vec2 delta = normz(mouseUV.zw - mouseUV.xy);\n        vec2 md = (mouseUV.xy - uv) * vec2(1.0,tx.x/tx.y);\n        float amp = exp(max(-12.0,-dot(md,md)/MOUSE_RADIUS));\n        fragColor.xy += VELOCITY_SCALE * MOUSE_AMP * clamp(amp * delta,-1.0,1.0);\n    }\n    \n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define TURB_CH xy\n#define TURB_SAMPLER iChannel0\n#define DEGREE TURBULENCE_SCALES\n\n#define D(d) textureLod(TURB_SAMPLER, fract(uv+d), mip).TURB_CH\n\nvoid tex(vec2 uv, inout mat3 mx, inout mat3 my, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    vec2 d =    D( t.ww); vec2 d_n =  D( t.wy); vec2 d_e =  D( t.xw);\n    vec2 d_s =  D( t.wz); vec2 d_w =  D(-t.xw); vec2 d_nw = D(-t.xz);\n    vec2 d_sw = D(-t.xy); vec2 d_ne = D( t.xy); vec2 d_se = D( t.xz);\n    \n    mx =  mat3(d_nw.x, d_n.x, d_ne.x,\n               d_w.x,  d.x,   d_e.x,\n               d_sw.x, d_s.x, d_se.x);\n    \n    my =  mat3(d_nw.y, d_n.y, d_ne.y,\n               d_w.y,  d.y,   d_e.y,\n               d_sw.y, d_s.y, d_se.y);\n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvoid turbulence(vec2 fragCoord, inout vec2 turb, inout float curl)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     \n    mat3 turb_xx = (2.0 - TURB_ISOTROPY) * mat3(\n        0.125,  0.25, 0.125,\n       -0.25,  -0.5, -0.25,\n        0.125,  0.25, 0.125\n    );\n\n    mat3 turb_yy = (2.0 - TURB_ISOTROPY) * mat3(\n        0.125, -0.25, 0.125,\n        0.25,  -0.5,  0.25,\n        0.125, -0.25, 0.125\n    );\n\n    mat3 turb_xy = TURB_ISOTROPY * mat3(\n       0.25, 0.0, -0.25,  \n       0.0,  0.0,  0.0,\n      -0.25, 0.0,  0.25\n    );\n    \n    const float norm = 8.8 / (4.0 + 8.0 * CURL_ISOTROPY);  // 8.8 takes the isotropy as 0.6\n    float c0 = CURL_ISOTROPY;\n    \n    mat3 curl_x = mat3(\n        c0,   1.0,  c0,\n        0.0,  0.0,  0.0,\n       -c0,  -1.0, -c0\n    );\n\n    mat3 curl_y = mat3(\n        c0, 0.0, -c0,\n       1.0, 0.0, -1.0,\n        c0, 0.0, -c0\n    );\n    \n    mat3 mx, my;\n    vec2 v = vec2(0);\n    float turb_wc, curl_wc = 0.0;\n    curl = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mx, my, i);\n        float turb_w = TURB_W_FUNCTION;\n        float curl_w = CURL_W_FUNCTION;\n    \tv += turb_w * vec2(reduce(turb_xx, mx) + reduce(turb_xy, my), reduce(turb_yy, my) + reduce(turb_xy, mx));\n        curl += curl_w * (reduce(curl_x, mx) + reduce(curl_y, my));\n        turb_wc += turb_w;\n        curl_wc += curl_w;\n    }\n\n    turb = float(DEGREE) * v / turb_wc;\n    curl = norm * curl / curl_wc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 turb;\n    float curl;\n    turbulence(fragCoord, turb, curl);\n    fragColor = vec4(turb,0,curl);\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define CURL_CH w\n#define CURL_SAMPLER iChannel0\n#define DEGREE VORTICITY_SCALES\n\n#define CURL(d) textureLod(CURL_SAMPLER, fract(uv+(d+0.0)), mip).CURL_CH\n#define D(d) abs(textureLod(CURL_SAMPLER, fract(uv+d), mip).CURL_CH)\n\nvoid tex(vec2 uv, inout mat3 mc, inout float curl, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    float d =    D( t.ww); float d_n =  D( t.wy); float d_e =  D( t.xw);\n    float d_s =  D( t.wz); float d_w =  D(-t.xw); float d_nw = D(-t.xz);\n    float d_sw = D(-t.xy); float d_ne = D( t.xy); float d_se = D( t.xz);\n    \n    mc =  mat3(d_nw, d_n, d_ne,\n               d_w,  d,   d_e,\n               d_sw, d_s, d_se);\n    \n    curl = CURL();\n    \n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvec2 confinement(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float k0 = CONF_ISOTROPY;\n    float k1 = 1.0 - 2.0*(CONF_ISOTROPY);\n\n    mat3 conf_x = mat3(\n       -k0, -k1, -k0,\n        0.0, 0.0, 0.0,\n        k0,  k1,  k0\n    );\n\n    mat3 conf_y = mat3(\n       -k0,  0.0,  k0,\n       -k1,  0.0,  k1,\n       -k0,  0.0,  k0\n    );\n    \n    mat3 mc;\n    vec2 v = vec2(0);\n    float curl;\n    \n    float cacc = 0.0;\n    vec2 nacc = vec2(0);\n    float wc = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mc, curl, i);\n        float w = CONF_W_FUNCTION;\n        vec2 n = w * normz(vec2(reduce(conf_x, mc), reduce(conf_y, mc)));\n        v += curl * n;\n        cacc += curl;\n        nacc += n;\n        wc += w;\n    }\n\n    #ifdef PREMULTIPLY_CURL\n        return v / wc;\n    #else\n    \treturn nacc * cacc / wc;\n    #endif\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(confinement(fragCoord),0,0);\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define VORT_CH xy\n#define VORT_SAMPLER iChannel0\n#define POIS_SAMPLER iChannel1\n#define POIS_CH x\n#define DEGREE POISSON_SCALES\n\n#define D(d) textureLod(VORT_SAMPLER, fract(uv+d), mip).VORT_CH\n#define P(d) textureLod(POIS_SAMPLER, fract(uv+d), mip).POIS_CH\n\nfloat laplacian_poisson(vec2 fragCoord) {\n    const float _K0 = -20.0/6.0, _K1 = 4.0/6.0, _K2 = 1.0/6.0;\n    vec2 texel = 1.0/iResolution.xy;\n    vec2 uv = fragCoord * texel;\n    vec4 t = vec4(texel, -texel.y, 0);\n    float mip = 0.0;\n\n    float p =    P( t.ww); float p_n =  P( t.wy); float p_e =  P( t.xw);\n    float p_s =  P( t.wz); float p_w =  P(-t.xw); float p_nw = P(-t.xz);\n    float p_sw = P(-t.xy); float p_ne = P( t.xy); float p_se = P( t.xz);\n    \n    return _K0 * p + _K1 * (p_e + p_w + p_n + p_s) + _K2 * (p_ne + p_nw + p_se + p_sw);\n}\n\nvoid tex(vec2 uv, inout mat3 mx, inout mat3 my, inout mat3 mp, int degree) {\n    vec2 texel = 1.0/iResolution.xy;\n    float stride = float(1 << degree);\n    float mip = float(degree);\n    vec4 t = stride * vec4(texel, -texel.y, 0);\n\n    vec2 d =    D( t.ww); vec2 d_n =  D( t.wy); vec2 d_e =  D( t.xw);\n    vec2 d_s =  D( t.wz); vec2 d_w =  D(-t.xw); vec2 d_nw = D(-t.xz);\n    vec2 d_sw = D(-t.xy); vec2 d_ne = D( t.xy); vec2 d_se = D( t.xz);\n    \n    float p =    P( t.ww); float p_n =  P( t.wy); float p_e =  P( t.xw);\n    float p_s =  P( t.wz); float p_w =  P(-t.xw); float p_nw = P(-t.xz);\n    float p_sw = P(-t.xy); float p_ne = P( t.xy); float p_se = P( t.xz);\n    \n    mx =  mat3(d_nw.x, d_n.x, d_ne.x,\n               d_w.x,  d.x,   d_e.x,\n               d_sw.x, d_s.x, d_se.x);\n    \n    my =  mat3(d_nw.y, d_n.y, d_ne.y,\n               d_w.y,  d.y,   d_e.y,\n               d_sw.y, d_s.y, d_se.y);\n    \n    mp =  mat3(p_nw, p_n, p_ne,\n               p_w,  p,   p_e,\n               p_sw, p_s, p_se);\n}\n\nfloat reduce(mat3 a, mat3 b) {\n    mat3 p = matrixCompMult(a, b);\n    return p[0][0] + p[0][1] + p[0][2] +\n           p[1][0] + p[1][1] + p[1][2] +\n           p[2][0] + p[2][1] + p[2][2];\n}\n\nvec2 pois(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float k0 = POIS_ISOTROPY;\n    float k1 = 1.0 - 2.0*(POIS_ISOTROPY);\n    \n    mat3 pois_x = mat3(\n        k0,  0.0, -k0,\n        k1,  0.0, -k1,\n        k0,  0.0, -k0\n    );\n     \n    mat3 pois_y = mat3(\n       -k0,  -k1,  -k0,\n        0.0,  0.0,  0.0,\n        k0,   k1,   k0\n    );\n\n    mat3 gauss = mat3(\n       0.0625, 0.125, 0.0625,  \n       0.125,  0.25,  0.125,\n       0.0625, 0.125, 0.0625\n    );\n    \n    mat3 mx, my, mp;\n    vec2 v = vec2(0);\n    \n    float wc = 0.0;\n    for (int i = 0; i < DEGREE; i++) {\n        tex(uv, mx, my, mp, i);\n        float w = POIS_W_FUNCTION;\n        wc += w;\n    \tv += w * vec2(reduce(pois_x, mx) + reduce(pois_y, my), reduce(gauss, mp));\n    }\n\n    return v / wc;\n\n}\n\n#define V(d) textureLod(VORT_SAMPLER, fract(uv+d), mip).zw\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = pois(fragCoord);\n    #ifdef USE_PRESSURE_ADVECTION\n        float mip = 0.0;\n        vec2 tx = 1.0 / iResolution.xy;\n        vec2 uv = fragCoord * tx;\n        float prev = P(0.0002 * PRESSURE_ADVECTION * tx * V(vec2(0)));\n        fragColor = vec4(mix(p.x + p.y, prev + PRESSURE_LAPLACIAN * laplacian_poisson(fragCoord), PRESSURE_UPDATE_SMOOTHING));\n    #else\n    \tfragColor = vec4(p.x + p.y);\n    #endif\n    // Adding a very small amount of noise on init fixes subtle numerical precision blowup problems\n    if (iFrame==0) fragColor=1e-6*rand4(fragCoord, iResolution.xy, iFrame);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\tNumber of scales to use in computation of each value. Lowering these will change the \n    result drastically, also note that the heightmap is used for rendering, so changing \n    POISSON_SCALES will alter the appearance of lighting/shadows. Weighting functions\n    for each scale are defined below.\n*/\n#define TURBULENCE_SCALES 6\n#define VORTICITY_SCALES 3\n#define POISSON_SCALES 100\n\n\n\n// If defined, recalculate the advection offset at every substep. Otherwise, subdivide the offset.\n// Leaving this undefined is much cheaper for large ADVECTION_STEPS but yields worse results; this\n// can be improved by defining the BLUR_* options below.\n#define RECALCULATE_OFFSET\n// Number of advection substeps to use. Useful to increase this for large ADVECTION_SCALE. Must be >= 1\n#define ADVECTION_STEPS 4\n// Advection distance multiplier.\n#define ADVECTION_SCALE 40.0\n// Scales the effect of turbulence on advection.\n#define ADVECTION_TURBULENCE 1.0\n// Scales the effect of turbulence on velocity. Use small values.\n#define VELOCITY_TURBULENCE 0.0000\n// Scales the effect of vorticity confinement on velocity.\n#define VELOCITY_CONFINEMENT 0.01\n// Scales diffusion.\n#define VELOCITY_LAPLACIAN 0.02\n// Scales the effect of vorticity confinement on advection.\n#define ADVECTION_CONFINEMENT 0.6\n// Scales the effect of divergence on advection.\n#define ADVECTION_DIVERGENCE  0.0\n// Scales the effect of velocity on advection.\n#define ADVECTION_VELOCITY -0.05\n// Amount of divergence minimization. Too much will cause instability.\n#define DIVERGENCE_MINIMIZATION 0.1\n// If 0.0, compute the gradient at (0,0). If 1.0, compute the gradient at the advection distance.\n#define DIVERGENCE_LOOKAHEAD 1.0\n// If 0.0, compute the laplacian at (0,0). If 1.0, compute the laplacian at the advection distance.\n#define LAPLACIAN_LOOKAHEAD 1.0\n// Scales damping force.\n#define DAMPING 0.0001\n// Overall velocity multiplier\n#define VELOCITY_SCALE 1.0\n// Mixes the previous velocity with the new velocity (range 0..1).\n#define UPDATE_SMOOTHING 0.0\n\n\n\n// These control the (an)isotropy of the various kernels\n#define TURB_ISOTROPY 0.9  // [0..2.0]\n#define CURL_ISOTROPY 0.6  // >= 0\n#define CONF_ISOTROPY 0.25 // [0..0.5]\n#define POIS_ISOTROPY 0.16 // [0..0.5]\n\n\n\n// If defined, multiply curl by vorticity, then accumulate. If undefined, accumulate, then multiply.\n#define PREMULTIPLY_CURL\n\n\n\n// These apply a gaussian blur to the various values used in the velocity/advection update. More expensive when defined.\n//#define BLUR_TURBULENCE\n//#define BLUR_CONFINEMENT\n//#define BLUR_VELOCITY\n\n\n\n// These define weighting functions applied at each of the scales, i=0 being the finest detail.\n//#define TURB_W_FUNCTION 1.0/float(i+1)\n#define TURB_W_FUNCTION 1.0\n//#define TURB_W_FUNCTION float(i+1)\n\n//#define CURL_W_FUNCTION 1.0/float(1 << i)\n#define CURL_W_FUNCTION 1.0/float(i+1)\n//#define CURL_W_FUNCTION 1.0\n\n//#define CONF_W_FUNCTION 1.0/float(i+1)\n#define CONF_W_FUNCTION 1.0\n//#define CONF_W_FUNCTION float(i+1)\n//#define CONF_W_FUNCTION float(1 << i)\n\n//#define POIS_W_FUNCTION 1.0\n#define POIS_W_FUNCTION 1.0/float(i+1)\n//#define POIS_W_FUNCTION 1.0/float(1 << i)\n//#define POIS_W_FUNCTION float(i+1)\n//#define POIS_W_FUNCTION float(1 << i)\n\n\n\n// These can help reduce mipmap artifacting, especially when POIS_W_FUNCTION emphasizes large scales.\n//#define USE_PRESSURE_ADVECTION\n// Scales pressure advection distance.\n#define PRESSURE_ADVECTION 0.0002 // higher values more likely to cause blowup if laplacian > 0.0\n// Pressure diffusion.\n#define PRESSURE_LAPLACIAN 0.1 // [0..0.3] higher values more likely to cause blowup\n// Mixes the previous pressure with the new pressure.\n#define PRESSURE_UPDATE_SMOOTHING 0.0 // [0..1]\n\n\n\n// Scales mouse interaction effect\n#define MOUSE_AMP 0.005\n// Scales mouse interaction radius\n#define MOUSE_RADIUS 0.001\n\n\n\n// If defined, \"pump\" velocity in the center of the screen. If undefined, alternate pumping from the sides of the screen.\n//#define CENTER_PUMP\n// Amplitude and cycle time for the \"pump\" at the center of the screen.\n#define PUMP_SCALE 0.00060\n#define PUMP_CYCLE 02.84084\n\n\nvec4 normz(vec4 x) {\n\treturn x.xyz == vec3(0) ? vec4(0,0,0,x.w) : vec4(normalize(x.xyz),0);\n}\n\nvec3 normz(vec3 x) {\n\treturn x == vec3(0) ? vec3(0) : normalize(x);\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n\n// Only used for rendering, but useful helpers\nfloat softmax(float a, float b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nfloat softmin(float a, float b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nvec4 softmax(vec4 a, vec4 b, float k) {\n\treturn log(exp(k*a)+exp(k*b))/k;    \n}\n\nvec4 softmin(vec4 a, vec4 b, float k) {\n\treturn -log(exp(-k*a)+exp(-k*b))/k;    \n}\n\nfloat softclamp(float a, float b, float x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(vec4 a, vec4 b, vec4 x, float k) {\n\treturn (softmin(b,softmax(a,x,k),k) + softmax(a,softmin(b,x,k),k)) / 2.0;    \n}\n\nvec4 softclamp(float a, float b, vec4 x, float k) {\n\treturn (softmin(vec4(b),softmax(vec4(a),x,k),k) + softmax(vec4(a),softmin(vec4(b),x,k),k)) / 2.0;    \n}\n\n\n\n\n// GGX from Noby's Goo shader https://www.shadertoy.com/view/lllBDM\n\n// MIT License: https://opensource.org/licenses/MIT\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n// End Noby's GGX\n\n\n// Modified from Shane's Bumped Sinusoidal Warp shadertoy here:\n// https://www.shadertoy.com/view/4l2XWK\nvec3 light(vec2 uv, float BUMP, float SRC_DIST, vec2 dxy, float iTime, inout vec3 avd) {\n    vec3 sp = vec3(uv-0.5, 0);\n    vec3 light = vec3(cos(iTime/20.0)*01.5, sin(iTime/20.0)*0.5, -SRC_DIST);\n    vec3 ld = light - sp;\n    float lDist = max(length(ld), 0.01);\n    ld /= lDist;\n    avd = reflect(normalize(vec3(BUMP*dxy, -1.0)), vec3(0,1,0));\n    return ld;\n}\n// End Shane's bumpmapping section\n\n\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// a simple modification for this shader to get a vec4\nvec4 rand4( vec2 fragCoord, vec2 iResolution, int iFrame ) {\n    uvec2 p = uvec2(fragCoord);\n    uvec2 r = uvec2(iResolution);\n    uint c = p.x + r.x*p.y + r.x*r.y*uint(iFrame);\n\treturn vec4(hash3(c),hash1(c + 75132895U));   \n}\n// End IQ's integer hash", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVBRw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[3468, 3468, 3499, 3499, 3972], [3974, 3974, 4008, 4008, 4041], [4043, 4043, 4099, 4099, 5889]], "test": "untested"}
{"id": "wsyBzw", "name": "VXAA TAA Upsample Test", "author": "hypernewbie", "description": "SMAA T4U Upsample test.\nClick right side for half res reference, click left side for full screen reference, release mouse for TU4x upsampled.", "tags": ["upsample", "taa"], "likes": 8, "viewed": 1104, "published": 3, "date": "1606796459", "time_retrieved": "2024-07-30T20:32:53.765741", "image_code": "float lumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //const vec2 imageSize = 1024.0;\n    vec2 imageSize = iResolution.xy;\n    \n    fragCoord -= 0.5f;\n    \n    vec2 uv_fullres = clamp( fragCoord / imageSize, 0.0, 1.0 );\n    vec2 uv_halfres = floor( fragCoord / 2.0 ) * 2.0;\n    uv_halfres += 1.0f;\n    uv_halfres = clamp( uv_halfres / imageSize, 0.0, 1.0 );\n    \n    vec4 fullc = texture( iChannel0, uv_fullres ); fullc = pow3( fullc, 2.2 );\n    \n    vec4 test0 = texture( iChannel0, uv_halfres + vec2( 0.0, 0.0 ) / imageSize ); test0 = pow3( test0, 2.2 );\n    vec4 test1 = texture( iChannel0, uv_halfres + vec2( 0.0, 1.0 ) / imageSize ); test1 = pow3( test1, 2.2 );\n    vec4 test2 = texture( iChannel0, uv_halfres + vec2( 1.0, 0.0 ) / imageSize ); test2 = pow3( test2, 2.2 );\n    vec4 test3 = texture( iChannel0, uv_halfres + vec2( 1.0, 1.0 ) / imageSize ); test3 = pow3( test3, 2.2 );\n    \n    vec4 p = texture( iChannel0, uv_halfres + vec2( 0.0, 1.0 ) / imageSize ); p = pow3( p, 2.2 );\n    vec4 ps = texture( iChannel0, uv_halfres + vec2( 0.0, -1.0 ) / imageSize ); ps = pow3( ps, 2.2 );\n    vec4 pe = texture( iChannel0, uv_halfres + vec2( 2.0,  1.0 ) / imageSize ); pe = pow3( pe, 2.2 );\n    vec4 c  = texture( iChannel0, uv_halfres + vec2( 1.0,  0.0 ) / imageSize ); c = pow3( c, 2.2 );\n    vec4 cw  = texture( iChannel0, uv_halfres + vec2( -1.0, 0.0 ) / imageSize ); cw = pow3( cw, 2.2 );\n    vec4 cn  = texture( iChannel0, uv_halfres + vec2(  1.0,  2.0 ) / imageSize ); cn = pow3( cn, 2.2 );\n\n    int xi = int( fragCoord.x ) % 2, yi = int( fragCoord.y ) % 2;\n    \n    if ( iMouse.z > 0.5 && iMouse.x < iResolution.x * 0.5 ) {\n        if ( xi == 0 && yi == 0 ) {\n            fragColor = test0;\n        }\n        if ( xi == 0 && yi == 1 ) {\n            fragColor = test1;\n        }\n        if ( xi == 1 && yi == 1 ) {\n            fragColor = test3;\n        }\n        if ( xi == 1 && yi == 0 ) {\n            fragColor = test2;\n        }\n    } else if ( iMouse.z > 0.5 && iMouse.x >= iResolution.x * 0.5 ) {\n        if ( xi == 0 && yi == 0 ) {\n            fragColor = test0;\n        }\n        if ( xi == 0 && yi == 1 ) {\n            fragColor = test0;\n        }\n        if ( xi == 1 && yi == 1 ) {\n            fragColor = test0;\n        }\n        if ( xi == 1 && yi == 0 ) {\n            fragColor = test0;\n        }\n    } else {\n        \n        fragColor = vec4( 0, 0, 0, 0 );\n        \n        if ( xi == 0 && yi == 0 ) {\n            float diff1 = lumaDiff( cw.xyz, c.xyz ), diff2 = lumaDiff( ps.xyz, p.xyz );\n            if ( diff1 < diff2 ) {\n                fragColor = mix( cw, c, 0.5f );\n            } else {\n                fragColor = mix( ps, p, 0.5f );\n            }\n        }\n        if ( xi == 0 && yi == 1 ) {\n            fragColor = p;\n        }\n        if ( xi == 1 && yi == 1 ) {\n            float diff1 = lumaDiff( p.xyz, pe.xyz ), diff2 = lumaDiff( cn.xyz, c.xyz );\n            if ( diff1 < diff2 ) {\n                fragColor = mix( p, pe, 0.5f );\n            } else {\n                fragColor = mix( cn, c, 0.5f );\n            }\n        }\n        if ( xi == 1 && yi == 0 ) {\n            fragColor = c;\n        }\n    }\n    \n    fragColor = pow3( fragColor, 1.0 / 2.2 );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 177], [179, 179, 209, 209, 280], [282, 282, 339, 376, 3487]], "test": "untested"}
{"id": "wdyBzw", "name": "Bimbo-Polygon-Distance-IQ", "author": "jorge2017a1", "description": "Bimbo-Polygon-Distance-IQ", "tags": ["bimbopolygondistanceiq"], "likes": 1, "viewed": 315, "published": 3, "date": "1606789202", "time_retrieved": "2024-07-30T20:32:54.879763", "image_code": "//Modificado por jorge2017a1 ----jorgeFloresP\n//https://en.wikipedia.org/wiki/Bimbo_(Fleischer_Studios)\n\n///Referencia de IQ https://www.shadertoy.com/view/wdBXRW\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a regular pentagon, without trigonometric functions. \n//\n//\n// https://iquilezles.org/articles/distfunctions2d\n\n\n\n\n #define saturate(x) clamp(x, 0.0, 1.0)\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N1 =72;\nconst int N2 =12;\nconst int N3 =27;\nconst int N4 =21;\nconst int N5 =92;\n\nconst int N6 =18;\nconst int N7 =17;\n\nconst int N9 =86;\n\nconst int N10 =31;\nconst int N11 =50;\n\nconst int N12 =45;\n\nconst int N13 =24;\n\n\n\nfloat sdPolygon( in vec2 p, in vec2[N1] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat sdPolygonv2( in vec2 p, in vec2[N2] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\nfloat sdPolygonv3( in vec2 p, in vec2[N3] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n\nfloat sdPolygonv4( in vec2 p, in vec2[N4] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\nfloat sdPolygonv5( in vec2 p, in vec2[N5] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\nfloat sdPolygonv6( in vec2 p, in vec2[N6] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\nfloat sdPolygonv7( in vec2 p, in vec2[N7] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\nfloat sdPolygonv9( in vec2 p, in vec2[N9] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\nfloat sdPolygonv10( in vec2 p, in vec2[N10] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\nfloat sdPolygonv11( in vec2 p, in vec2[N11] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\nfloat sdPolygonv12( in vec2 p, in vec2[N12] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\nfloat sdPolygonv13( in vec2 p, in vec2[N13] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    \n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n//vec2[] polygon = vec2[](v0,v1,v2,v3,v4);\n\n\nvec2[72] pt1 = vec2[](vec2(0.358, 0.398),vec2(0.388, 0.398),vec2(0.354, 0.398),vec2(0.326, 0.392),vec2(0.302, 0.388),vec2(0.28, 0.376),vec2(0.262, 0.356),vec2(0.25, 0.334),vec2(0.26, 0.356),vec2(0.256, 0.336),vec2(0.254, 0.328),vec2(0.254, 0.322),vec2(0.258, 0.326),vec2(0.258, 0.316),vec2(0.262, 0.306),vec2(0.266, 0.294),vec2(0.274, 0.284),vec2(0.282, 0.28),vec2(0.288, 0.276),vec2(0.286, 0.27),vec2(0.284, 0.256),vec2(0.278, 0.236),vec2(0.28, 0.222),vec2(0.286, 0.196),vec2(0.292, 0.18),vec2(0.3, 0.162),vec2(0.31, 0.148),vec2(0.322, 0.134),vec2(0.344, 0.122),vec2(0.362, 0.118),vec2(0.382, 0.118),vec2(0.406, 0.126),vec2(0.43, 0.14),vec2(0.442, 0.15),vec2(0.448, 0.162),vec2(0.454, 0.15),vec2(0.464, 0.144),vec2(0.48, 0.13),vec2(0.5, 0.124),vec2(0.518, 0.124),vec2(0.538, 0.128),vec2(0.56, 0.14),vec2(0.582, 0.158),vec2(0.588, 0.166),vec2(0.594, 0.186),vec2(0.596, 0.212),vec2(0.598, 0.232),vec2(0.598, 0.25),vec2(0.592, 0.26),vec2(0.59, 0.278),vec2(0.584, 0.288),vec2(0.598, 0.3),vec2(0.61, 0.318),vec2(0.61, 0.342),vec2(0.602, 0.358),vec2(0.592, 0.372),vec2(0.582, 0.382),vec2(0.566, 0.39),vec2(0.55, 0.398),vec2(0.536, 0.404),vec2(0.518, 0.406),vec2(0.506, 0.406),vec2(0.488, 0.404),vec2(0.48, 0.408),vec2(0.464, 0.418),vec2(0.454, 0.422),vec2(0.434, 0.422),vec2(0.418, 0.422),vec2(0.396, 0.41),vec2(0.388, 0.4),vec2(0.376, 0.398),vec2(0.358, 0.398)); \nvec2[12] pt2 = vec2[](vec2(0.45, 0.32) ,vec2(0.442, 0.318),vec2(0.43, 0.316),vec2(0.418, 0.308),vec2(0.416, 0.3),vec2(0.428, 0.29),vec2(0.44, 0.292),vec2(0.448, 0.292),vec2(0.46, 0.298),vec2(0.466, 0.308),vec2(0.462, 0.318),vec2(0.45, 0.32) ); //num puntos 11\nvec2[27] pt3 = vec2[](vec2(0.514, 0.306),vec2(0.502, 0.306),vec2(0.48, 0.3),vec2(0.464, 0.29),vec2(0.454, 0.28),vec2(0.448, 0.262),vec2(0.446, 0.242),vec2(0.446, 0.226),vec2(0.45, 0.204),vec2(0.46, 0.182),vec2(0.476, 0.166),vec2(0.494, 0.158),vec2(0.512, 0.154),vec2(0.528, 0.156),vec2(0.542, 0.164),vec2(0.56, 0.176),vec2(0.568, 0.19),vec2(0.572, 0.206),vec2(0.572, 0.224),vec2(0.572, 0.236),vec2(0.566, 0.256),vec2(0.564, 0.27),vec2(0.558, 0.282),vec2(0.544, 0.298),vec2(0.536, 0.3),vec2(0.526, 0.304),vec2(0.514, 0.306) );\nvec2[21] pt4 = vec2[](vec2(0.354, 0.304),vec2(0.338, 0.296),vec2(0.324, 0.284),vec2(0.308, 0.268),vec2(0.302, 0.242),vec2(0.302, 0.216),vec2(0.308, 0.192),vec2(0.322, 0.168),vec2(0.34, 0.154),vec2(0.362, 0.146),vec2(0.382, 0.148),vec2(0.398, 0.156),vec2(0.412, 0.166),vec2(0.43, 0.192),vec2(0.436, 0.22),vec2(0.432, 0.246),vec2(0.426, 0.264),vec2(0.416, 0.282),vec2(0.406, 0.292),vec2(0.384, 0.302),vec2(0.354, 0.304) );  \n\n\nvec2[92] pt5 = vec2[]( vec2(0.386, 0.402),vec2(0.382, 0.398),vec2(0.352, 0.394),vec2(0.328, 0.392),vec2(0.32, 0.394),vec2(0.302, 0.39),vec2(0.282, 0.376),vec2(0.268, 0.366),vec2(0.256, 0.356),vec2(0.252, 0.344),vec2(0.244, 0.328),vec2(0.244, 0.316),vec2(0.238, 0.302),vec2(0.234, 0.278),vec2(0.232, 0.256),vec2(0.232, 0.226),vec2(0.236, 0.208),vec2(0.242, 0.194),vec2(0.218, 0.192),vec2(0.21, 0.186),vec2(0.198, 0.18),vec2(0.194, 0.17),vec2(0.188, 0.162),\n                           vec2(0.178, 0.152),vec2(0.178, 0.142),vec2(0.172, 0.134),vec2(0.17, 0.128),vec2(0.156, 0.124),vec2(0.154, 0.118),vec2(0.154, 0.112),vec2(0.154, 0.102),vec2(0.166, 0.086),vec2(0.178, 0.082),vec2(0.198, 0.08),vec2(0.22, 0.086),vec2(0.242, 0.092),vec2(0.256, 0.096),vec2(0.274, 0.104),vec2(0.288, 0.108),vec2(0.31, 0.102),vec2(0.332, 0.094),vec2(0.35, 0.086),vec2(0.372, 0.078),vec2(0.39, 0.072),vec2(0.414, 0.07),vec2(0.436, 0.068),\n                           vec2(0.462, 0.07),vec2(0.488, 0.076),vec2(0.514, 0.084),vec2(0.532, 0.094),vec2(0.55, 0.1),vec2(0.564, 0.108),vec2(0.578, 0.112),vec2(0.596, 0.106),vec2(0.61, 0.098),vec2(0.634, 0.088),vec2(0.658, 0.086),vec2(0.678, 0.084),vec2(0.694, 0.08),vec2(0.72, 0.088),vec2(0.728, 0.092),vec2(0.742, 0.104),vec2(0.746, 0.108),vec2(0.738, 0.112),vec2(0.738, 0.122),vec2(0.724, 0.124),vec2(0.716, 0.124),vec2(0.71, 0.128),vec2(0.704, 0.144),vec2(0.698, 0.158),vec2(0.686, 0.172),\n                           vec2(0.678, 0.182),vec2(0.662, 0.184),vec2(0.65, 0.194),vec2(0.634, 0.196),vec2(0.638, 0.212),vec2(0.638, 0.236),vec2(0.638, 0.25),vec2(0.638, 0.264),vec2(0.63, 0.282),vec2(0.622, 0.296),vec2(0.614, 0.308),vec2(0.618, 0.322),vec2(0.616, 0.34),vec2(0.612, 0.358),vec2(0.604, 0.37),vec2(0.588, 0.386),vec2(0.562, 0.398),vec2(0.544, 0.404),vec2(0.52, 0.408),vec2(0.496, 0.406),vec2(0.386, 0.402) );\n\n//pupila izq\nvec2[18] pt6 = vec2[]( vec2(0.352, 0.292),vec2(0.35, 0.28),vec2(0.368, 0.274),vec2(0.354, 0.264),vec2(0.354, 0.25),vec2(0.358, 0.238),vec2(0.374, 0.228),vec2(0.386, 0.234),vec2(0.392, 0.246),vec2(0.39, 0.256),vec2(0.39, 0.274),vec2(0.39, 0.28),vec2(0.386, 0.292),vec2(0.382, 0.3),vec2(0.372, 0.306),vec2(0.364, 0.302),vec2(0.356, 0.296),vec2(0.352, 0.292) ); //,num puntos 17\n\n//pupila derecha\nvec2[17] pt7 = vec2[]( vec2(0.502, 0.272),vec2(0.504, 0.266),vec2(0.492, 0.26),vec2(0.492, 0.246),vec2(0.498, 0.24),vec2(0.51, 0.232),vec2(0.52, 0.238),vec2(0.528, 0.254),vec2(0.528, 0.272),vec2(0.524, 0.286),vec2(0.516, 0.3),vec2(0.508, 0.304),vec2(0.496, 0.3),vec2(0.488, 0.292),vec2(0.488, 0.286),vec2(0.494, 0.28),vec2(0.502, 0.272) );  //num puntos 16\n\n//boca\nvec2[12] pt8 = vec2[]( vec2(0.45, 0.38),vec2(0.434, 0.38),vec2(0.422, 0.384),vec2(0.41, 0.392),vec2(0.404, 0.402),vec2(0.412, 0.41),vec2(0.428, 0.408),vec2(0.44, 0.406),vec2(0.456, 0.402),vec2(0.46, 0.396),vec2(0.46, 0.384),vec2(0.45, 0.38));  //num puntos 11\n\n//cuerpo \n\nvec2[86] pt9 = vec2[](  vec2(0.412, 0.404),vec2(0.384, 0.402),vec2(0.34, 0.398),vec2(0.316, 0.412),vec2(0.288, 0.436),vec2(0.262, 0.454),vec2(0.234, 0.462),vec2(0.222, 0.462),vec2(0.208, 0.478),vec2(0.19, 0.488),vec2(0.176, 0.492),vec2(0.156, 0.496),vec2(0.136, 0.494),vec2(0.15, 0.512),vec2(0.174, 0.518),vec2(0.202, 0.524),vec2(0.224, 0.526),vec2(0.236, 0.532),vec2(0.236, 0.546),vec2(0.246, 0.556),vec2(0.246, 0.584),vec2(0.26, 0.594),vec2(0.244, 0.604),vec2(0.228, 0.618),vec2(0.214, 0.654),vec2(0.202, 0.684),vec2(0.19, 0.71),vec2(0.178, 0.738),vec2(0.174, 0.76),vec2(0.208, 0.744),vec2(0.244, 0.748),vec2(0.266, 0.76),vec2(0.272, 0.764),vec2(0.294, 0.738),vec2(0.31, 0.698),vec2(0.328, 0.656),vec2(0.33, 0.642),vec2(0.336, 0.638),vec2(0.348, 0.64),vec2(0.382, 0.652),vec2(0.42, 0.65),vec2(0.442, 0.648),vec2(0.45, 0.648),vec2(0.468, 0.67),vec2(0.476, 0.704),vec2(0.502, 0.758),vec2(0.516, 0.776),vec2(0.536, 0.768),vec2(0.554, 0.768),vec2(0.578, 0.77),vec2(0.586, 0.77),vec2(0.594, 0.754),vec2(0.606, 0.712),vec2(0.612, 0.68),vec2(0.61, 0.648),vec2(0.598, 0.622),vec2(0.58, 0.604),vec2(0.568, 0.592),vec2(0.574, 0.574),vec2(0.58, 0.554),vec2(0.582, 0.526),vec2(0.58, 0.506),vec2(0.594, 0.51),vec2(0.626, 0.518),vec2(0.66, 0.52),vec2(0.696, 0.514),vec2(0.728, 0.5),vec2(0.74, 0.49),vec2(0.752, 0.478),vec2(0.752, 0.462),vec2(0.724, 0.466),vec2(0.706, 0.466),vec2(0.676, 0.462),vec2(0.662, 0.454),vec2(0.652, 0.44),vec2(0.65, 0.446),vec2(0.636, 0.452),vec2(0.61, 0.446),vec2(0.584, 0.428),vec2(0.562, 0.412),vec2(0.542, 0.408),vec2(0.52, 0.404),vec2(0.502, 0.404),vec2(0.456, 0.404),vec2(0.434, 0.404),vec2(0.412, 0.404) ); //num puntos 85\n\n//mano izq\nvec2[31] pt10 = vec2[]( vec2(0.384, 0.404),vec2(0.362, 0.402),vec2(0.35, 0.42),vec2(0.338, 0.452),vec2(0.33, 0.472),vec2(0.322, 0.49),vec2(0.322, 0.512),vec2(0.328, 0.548),vec2(0.35, 0.57),vec2(0.378, 0.584),vec2(0.402, 0.592),vec2(0.442, 0.592),vec2(0.474, 0.586),vec2(0.492, 0.576),vec2(0.51, 0.562),vec2(0.518, 0.542),vec2(0.528, 0.524),vec2(0.528, 0.5),vec2(0.524, 0.48),vec2(0.514, 0.46),vec2(0.508, 0.446),vec2(0.498, 0.43),vec2(0.492, 0.418),vec2(0.488, 0.414),vec2(0.47, 0.418),vec2(0.456, 0.42),vec2(0.434, 0.426),vec2(0.42, 0.42),vec2(0.408, 0.418),vec2(0.394, 0.408),vec2(0.384, 0.404) ); //31 puntos\n\n//mano der\nvec2[50] pt11 = vec2[]( vec2(0.222, 0.45),vec2(0.218, 0.46),vec2(0.216, 0.47),vec2(0.202, 0.484),vec2(0.178, 0.494),vec2(0.164, 0.494),vec2(0.14, 0.494),vec2(0.122, 0.484),vec2(0.116, 0.468),vec2(0.114, 0.46),vec2(0.106, 0.454),vec2(0.094, 0.438),vec2(0.092, 0.426),vec2(0.084, 0.392),vec2(0.092, 0.37),vec2(0.08, 0.356),vec2(0.066, 0.338),vec2(0.066, 0.324),vec2(0.072, 0.304),vec2(0.094, 0.286),vec2(0.11, 0.286),vec2(0.116, 0.29),vec2(0.122, 0.276),vec2(0.136, 0.268),vec2(0.15, 0.266),vec2(0.166, 0.266),vec2(0.174, 0.272),vec2(0.186, 0.294),vec2(0.192, 0.278),vec2(0.202, 0.272),vec2(0.214, 0.272),vec2(0.224, 0.282),vec2(0.232, 0.312),vec2(0.226, 0.328),vec2(0.22, 0.348),vec2(0.218, 0.37),vec2(0.228, 0.368),vec2(0.244, 0.362),vec2(0.256, 0.364),vec2(0.27, 0.368),vec2(0.282, 0.376),vec2(0.286, 0.388),vec2(0.282, 0.4),vec2(0.276, 0.408),vec2(0.266, 0.412),vec2(0.254, 0.412),vec2(0.24, 0.414),vec2(0.238, 0.426),vec2(0.226, 0.438),vec2(0.222, 0.45) ); // num puntos 49\n\n//mano izq\nvec2[45] pt12 = vec2[]( vec2(0.646, 0.42),vec2(0.65, 0.432),vec2(0.65, 0.446),vec2(0.664, 0.456),vec2(0.688, 0.464),vec2(0.712, 0.468),vec2(0.726, 0.464),vec2(0.746, 0.458),vec2(0.756, 0.454),vec2(0.762, 0.448),vec2(0.776, 0.438),vec2(0.788, 0.422),vec2(0.788, 0.412),vec2(0.792, 0.39),vec2(0.792, 0.38),vec2(0.802, 0.364),vec2(0.82, 0.332),vec2(0.822, 0.318),vec2(0.818, 0.298),vec2(0.794, 0.282),vec2(0.78, 0.286),vec2(0.768, 0.298),vec2(0.766, 0.284),vec2(0.76, 0.27),vec2(0.734, 0.264),vec2(0.71, 0.272),vec2(0.702, 0.284),vec2(0.692, 0.282),vec2(0.676, 0.276),vec2(0.656, 0.278),vec2(0.638, 0.298),vec2(0.638, 0.322),vec2(0.646, 0.34),vec2(0.656, 0.36),vec2(0.654, 0.368),vec2(0.644, 0.374),vec2(0.638, 0.374),vec2(0.624, 0.374),vec2(0.606, 0.384),vec2(0.596, 0.4),vec2(0.6, 0.416),vec2(0.614, 0.426),vec2(0.63, 0.426),vec2(0.638, 0.426),vec2(0.646, 0.42) ) ;  //num puntos 44\n\n//zapato\nvec2[24] pt13 = vec2[]( vec2(0.448, 0.79),vec2(0.424, 0.786),vec2(0.4, 0.798),vec2(0.392, 0.822),vec2(0.392, 0.846),vec2(0.404, 0.854),vec2(0.43, 0.86),vec2(0.47, 0.864),vec2(0.494, 0.864),vec2(0.518, 0.864),vec2(0.55, 0.864),vec2(0.574, 0.86),vec2(0.598, 0.852),vec2(0.612, 0.842),vec2(0.62, 0.822),vec2(0.612, 0.798),vec2(0.602, 0.782),vec2(0.572, 0.774),vec2(0.544, 0.776),vec2(0.53, 0.782),vec2(0.51, 0.79),vec2(0.488, 0.79),vec2(0.468, 0.79),vec2(0.448, 0.79) ); // num puntos 23\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float tt=iTime;\n    vec2 p= rotatev2(uv, radians( mod(tt*45.0,360.0)));\n    //p=p*0.35*sin(iTime*0.25);\n    \n    \n    //-------------------------------\n    float d1 = sdPolygon(p, pt1);\n\tfloat d2 = sdPolygonv2(p, pt2);\n    float d3 = sdPolygonv3(p, pt3);\n    float d4 = sdPolygonv4(p, pt4);\n    float d5 = sdPolygonv5(p, pt5);\n    \n    float d6 = sdPolygonv6(p, pt6);\n    float d7 = sdPolygonv7(p, pt7);\n    \n    float d8 = sdPolygonv2(p, pt8);\n    float d9 = sdPolygonv9(p, pt9);\n    \n    \n    float d10 = sdPolygonv10(p, pt10);\n    float d11 = sdPolygonv11(p, pt11);\n    float d12 = sdPolygonv12(p, pt12);\n    \n    float d13 = sdPolygonv13(p, pt13);\n    \n    \n    d1 = SS(d1);\n    d2 = SS(d2);\n    d3 = SS(d3);\n    d4 = SS(d4);\n    d5 = SS(d5);\n    \n    \n    d6 = SS(d6);\n    d7 = SS(d7);\n    d8 = SS(d8);\n    d9 = SS(d9);\n    \n    d10 = SS(d10);\n    d11 = SS(d11);\n    \n    d12 = SS(d12);\n    d13 = SS(d13);\n    \n    \n    \n    fragColor=vec4(0.0);\n\n    vec3 col=vec3(0.49);\n    col=mix(col,vec3(0.3),d5);\n    col=mix(col,vec3(1.0),d1);\n    col=mix(col,vec3(1.0,0.0,0.0),d2);\n    col=mix(col,vec3(0.2,0.2,0.2),d3);\n    col=mix(col,vec3(0.2,0.2,0.2),d4);\n    \n    col=mix(col,vec3(0.8),d6);\n    col=mix(col,vec3(0.8),d7);\n    col=mix(col,vec3(0.4),d8);\n    col=mix(col,vec3(0.6,0.6, 0.6),d9);\n    \n    col=mix(col,vec3(0.84),d10);\n    col=mix(col,vec3(0.4),d11);\n    \n    col=mix(col,vec3(0.4),d12);\n    \n    col=mix(col,vec3(1.0,0.8,0.6),d13);\n    \n    fragColor=vec4(col,1.0);\n    \n\n}", "image_inputs": [], "sound_code": "\n//por jorgefloresp-30-nov-2020\n//referencia el grupo de usuarios de Shadertoy\n\n\nfloat itime;\nvec3 f(float x) \n{\n\tconst float pi = radians(180.0);\n    vec3 t = vec3(-1.0, 0.0, 1.0)/6.0 + 6.0*cos(pi*x) + itime;\n    return 0.5 + x*(1.0 - x)*sin(pi*t);\n}\n\nvec3 f(vec2 xy) \n{\n    return f(xy.x) - xy.y;\n}\n\n\n\nvec2 mainSound( in int samp, float time )\n{\t\n    itime=mod(time,0.5);\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    float tt=mod(time, 5.0);\n    vec3 res= f(vec2(sin(tt*500.0), tt/2.0));\n    vec3 res2= f(vec2(sin(tt*400.0), tt/2.0));\n    \n    \n    //return vec2( abs(res)+abs(res2.x));\n    if (tt<2.0)\n    return vec2( abs(res2));\n    else\n    return vec2( abs(res));\n    \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBzw.jpg", "access": "api", "license": "mit", "functions": [[1515, 1515, 1540, 1540, 1559], [1560, 1560, 1600, 1600, 1632], [19903, 19903, 19937, 19937, 20034], [20040, 20040, 20097, 20097, 21651]], "test": "untested"}
