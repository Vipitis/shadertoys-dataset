{"id": "Nd33zs", "name": "2nd rocket", "author": "jorge2017a1", "description": "2nd rocket", "tags": ["2ndrocket"], "likes": 2, "viewed": 241, "published": 3, "date": "1630440751", "time_retrieved": "2024-07-30T19:03:56.196743", "image_code": "//por jorge2017a1-\n//2nd Rocket\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions\n//https://www.shadertoy.com/view/Xls3D2....float height(in vec2 p)..by Dave_Hoskins\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n///-----------------------------------------------------\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 cohete(vec3 p)\n{ \n   vec3 res= vec3(9999.0, -1.0,-1.0); \n   vec3 p0=p;\n   p=rotate_y(p-vec3(0.0,5.0,10.0), radians(270.0));\n   vec3 p1=p;\n   \n   p=rotate_y(p-vec3(0.0,5.0,10.0), radians(90.0));\n   \n   float sd1A=sdCylinderYZ(p, vec2(5.0,10.0));\n   float sd1B=sdCylinderYZ(p, vec2(4.0,10.5));\n   float sd1C=sdCylinderYZ(p, vec2(4.0,9.0));\n   \n   vec3 p2=p0-vec3(26.0,10.0,8.0);\n   vec3 p3=p0-vec3(2.0,10.0,8.0);\n   \n   p2=rotate_x(p2, radians(90.0));\n   p2=rotate_z(p2, radians(90.0));\n   \n   p3=rotate_x(p3, radians(90.0));\n   p3=rotate_z(p3, radians(90.0));\n   \n   float sdPunta1= sdCone(p2-vec3(2.0,0.0,0.0), vec2(3.5,5.5), 6.0);\n   float sdPunta2= sdCone(p3-vec3(2.0,0.0,0.0), vec2(3.5,5.5), 6.0);\n   float sdif= differenceSDF(sd1A, sd1B);\n   \n   p.y-=10.0;\n   \n   float numItem=6.0;\n   float tau = atan(1.0) * 8.0;\n   \n   //rotar aspas\n   p1=rotate_z(p1-vec3(0.0,5.0,-1.0), iTime);\n   vec3 rep2a = opAngRep(p1, tau / numItem);\n   float sdAspas=sdCylinderYZ(rep2a ,vec2(1.0,10.0)  );\n   \n   res =opU3(res, vec3(sdif,3.0,-1.0)); \n   res =opU3(res, vec3(sd1C,1.0,-1.0)); \n   res =opU3(res, vec3(sdAspas,2.0,-1.0)); \n   res =opU3(res, vec3(sdPunta1,4.0,-1.0)); \n   res =opU3(res, vec3(sdPunta2,5.0,-1.0)); \n   \n   return res;\n}\n\n//https://www.shadertoy.com/view/Xls3D2\nfloat height(in vec2 p)\n{\n    float h = sin(p.x*.1+p.y*.2)+sin(p.y*.1-p.x*.2)*.5;\n    h += sin(p.x*.04+p.y*.01+3.0)*4.;\n    h -= sin(h*10.0)*.1;\n    return h;\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n   \n   planeDist1 +=height(p.xz);  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,6.0));\n\n    p.y+=-12.0+5.0*sin(iTime*2.0);\n    p.x-=iTime*5.0;\n    vec3 c1=cohete(p);\n    vec3 c2=cohete(p-vec3(-20.0,-5.0,25.0));\n    res =opU3(res, c1 ); \n    res =opU3(res, c2 ); \n   return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n      lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{ \nfloat t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n      sky = mix(sky, vec3(.12, .12, .3),  rd.y);\nreturn sky;\n\n\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n    if (id_material==6.0)\n    {  float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n//------------------\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n     float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n   \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, 10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 20.0, -20.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(10.0,15.0,-25.0);\n   ro.x+=iTime*5.0;\n   float t1=mod(iTime,2.);\n   float t2=mod(iTime,3.);\n   \n   if (t1<t2)\n       ro.y-=5.0*sin(iTime*2.0);\n  \n  vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n      col = linear2srgb(col);\n    \n  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd33zs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[640, 640, 676, 676, 697], [698, 698, 737, 737, 832], [833, 833, 872, 872, 967], [968, 968, 1007, 1007, 1102], [1104, 1148, 1195, 1195, 1222], [1223, 1223, 1266, 1266, 1293], [1294, 1294, 1342, 1342, 1370], [1371, 1409, 1445, 1445, 1490], [1491, 1491, 1530, 1530, 1574], [1575, 1640, 1674, 1674, 1770], [1771, 1771, 1805, 1805, 1896], [1897, 1897, 1931, 1931, 2022], [2023, 2063, 2097, 2097, 2192], [2195, 2195, 2242, 2376, 2711], [2713, 2770, 2804, 2804, 2977], [2979, 2979, 3000, 3000, 4211], [4213, 4253, 4278, 4278, 4413], [4414, 4454, 4479, 4479, 4857], [4859, 4910, 4934, 4934, 5096], [5098, 5098, 5147, 5147, 5783], [5785, 5839, 5875, 5875, 6120], [6121, 6176, 6203, 6203, 6220], [6222, 6222, 6258, 6258, 6350], [6351, 6351, 6397, 6397, 6522], [6524, 6524, 6598, 6598, 8199], [8256, 8290, 8370, 8370, 8493], [8536, 8536, 8568, 8568, 8814], [8817, 8868, 8915, 8915, 9273], [9275, 9327, 9420, 9420, 9766], [9768, 9789, 9820, 9820, 10424], [10426, 10475, 10501, 10501, 10611], [10615, 10664, 10721, 10721, 11400]]}
{"id": "7dtGRB", "name": " HexTruchet", "author": "hjd3481", "description": "Triangular grid to create some triangular Truchet tiles. leaving out the corners of the original grid leaves a hexagonal gap in the wires.\nSome kind of techy dynamic neural net thing.", "tags": ["truchet", "hex", "tiles", "electronic", "beinner"], "likes": 11, "viewed": 366, "published": 3, "date": "1630422297", "time_retrieved": "2024-07-30T19:03:57.180113", "image_code": "#define SIN_60 0.8660254\n\n/////////////////////////////////////////////////////////////\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n/////////////////////////////////////////////////////////////\nvec3 blob( vec2 uv, vec2 p )\n{\n    //un-skew the uv to get round dots\n    uv.x += uv.y * 0.5; //skew x to shift diagonal into triangles\n    uv.x /= SIN_60;\n    //also scale the position to get the origin to the correct place.\n    p.x /= SIN_60;\n        \n    float d = distance( uv, p );\n    \n    float r = 0.123;\n    float outer = smoothstep(r + 0.001, r - 0.001, d); //invert\n    \n    float rb = 0.066;\n    float inner = smoothstep(rb - 0.001, rb + 0.001, d); \n    \n    \n    float glow = smoothstep(rb+0.3, rb, d);  //invert\n    \n    return vec3(outer,inner, glow);\n}\n/////////////////////////////////////////////////////////////\nvec3 pulse( float falloff, vec3 rnd )\n{\n    //vec3 colA = vec3(0.4,0.01,0.0);\n    //vec3 colB = vec3(1.0,0.7,0.0);\n    \n    vec3 colA = vec3(0.1,0.01,0.5);\n    vec3 colB = vec3(0.4,0.45,1.0);\n    \n    float v = abs(sin(((iTime*(1.0+rnd.z))+rnd.x) * (rnd.y+0.1) * 5.0));\n    vec3 col = mix( colA, colB, vec3(v*v*v));\n    \n    return col * pow( falloff, mix(7.0,3.0,v));\n    \n}\n/////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.y; //y-fov\n    vec2 uv = fragCoord/iResolution.x; //x-fov\n\n     // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    //offset zoom centre\n    uv -= 0.5;    \n     \n    //sacle (zoom)\n    float tilesY = mix(10.0, 14.0, sin(iTime*0.1)*0.5+0.5); //zoom in and out\n    uv *= tilesY;\n    \n    //pan the image \n    uv += vec2(0.45233 * iTime, sin(iTime*-0.1250235) * 1.41 );    \n   \n        \n    //squares -> euqlaterial triangles\n    uv.x *= SIN_60; //scale to get equalateral. mul by sin60 to get h == 1/2a (equalaterial triangle corner = 60deg)\n    uv.x -= uv.y * 0.5; //skew x to shift diagonal into triangles\n    \n    vec2 id = floor(uv.xy);\n    \n    vec2 idRightB = id + vec2(1.0, 0.0);\n\n    vec2 idBottomA = id + vec2(0.0, -1.0);   \n    \n    \n    \n    uv = fract(uv);\n    \n    //get diagonal of the skewed grid to get a triangular chequer pattern.\n    float sn = sign( (uv.x+uv.y)-1.0f );\n    \n    uv = mix(uv, vec2(1)-uv, sn*0.5+0.5); //flip UV in top right triangle\n        \n    //convert the grid-id to a triangle-id\n    \n    float daigonalHashOffset = 1.7133453;\n    \n    vec2 idSign = id + ((-sn)*daigonalHashOffset);\n    id += sn*daigonalHashOffset; //add some offset based on the chequer/sign \n    \n    idRightB += (-sn)*daigonalHashOffset; //flipping the sign gets us the upper-right triangle in the un-skewed cell.\n    idBottomA += (-sn)*daigonalHashOffset; \n    \n    vec3 rnd = hash32(id); //get a noise per triangle\n       \n    \n    float dots = 0.0;\n    \n    //Draw edges between triangles randomly\n    int numEdges = 0;\n    \n    vec3 rndEdges = fract(rnd + (floor(iTime)*vec3(0.2,0.1,0.3)) ); //step-tick the random values by adding a \n    \n    if(rndEdges.x < 0.5)\n    {\n        dots += smoothstep( 0.05, 0.04, abs(uv.x - 0.5));\n        ++numEdges;\n    }\n  \n    if(rndEdges.y < 0.5)\n    {\n        dots += smoothstep( 0.05, 0.04, abs(uv.y - 0.5));\n        ++numEdges;\n    }\n    \n    if( rndEdges.z < 0.5 && numEdges < 2 /*|| numEdges==0*/ )\n    {\n        dots += smoothstep( 0.05, 0.04, abs((uv.x+uv.y) - 0.5));\n    }\n    \n    //Draw rings around the edge-centres between trianges, between the solid edges above\n    vec3 dotA = blob(uv, vec2(0.5,0.0));\n    vec3 dotB = blob(uv, vec2(0.25,0.5));\n    vec3 dotC = blob(uv, vec2(0.75,0.5));\n    \n    float dotsMask = 1.0;\n    \n    dots += dotA.x;\n    dotsMask *= dotA.y;\n    \n    dots += dotB.x;\n    dotsMask *= dotB.y;\n    \n    dots += dotC.x;\n    dotsMask *= dotC.y;\n      \n    //cut out the ring centres\n        \n     \n    //draw backgound       \n    //random dark gray triangle bg\n    col = vec3((sin((iTime*rnd.z+rnd.x)*5.)+1.0)*0.05); \n    \n    //draw wires\n    //colour a bit like copper traces\n    vec3 wiresCol = vec3( 0.8,0.6,0.4 );\n    col = mix( col, wiresCol ,clamp(dots,0.0,1.0) );\n    \n    col *= dotsMask; //mask out holes to black again (ingore bg)\n    \n    //draw glow \n    \n    //get the same random values from neighbouring triangles so the blobs on the edges match up\n    vec3 rndA = hash32(idBottomA); \n    if(sn >= 0.0)\n    {\n        rndA = hash32(id);\n    }\n    \n    vec3 rndB = hash32(id); \n    if(sn >= 0.0)\n    {\n        rndB = hash32(idRightB);\n    }\n    \n    vec3 rndC = hash32(idSign);\n    if(sn >= 0.0)\n    {\n        rndC = hash32(id);\n    }\n\n    col += pulse(dotA.z,rndA); \n    col += pulse(dotB.z,rndB); \n    col += pulse(dotC.z,rndC); \n    \n        \n    //visualise random triangle\n    //col += rnd*0.25;\n    \n    //visualize uvs\n    //col.rg += uv * 0.5;\n    \n       \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 214, 236, 236, 353], [355, 355, 376, 376, 512], [514, 576, 606, 645, 1144], [1145, 1207, 1246, 1321, 1582], [1583, 1645, 1702, 1801, 5317]]}
{"id": "fllGR7", "name": "Acid tubes", "author": "z0rg", "description": "Grafix acid generation", "tags": ["tubes"], "likes": 7, "viewed": 1292, "published": 3, "date": "1630397225", "time_retrieved": "2024-07-30T19:03:58.125092", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 50;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 10.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*(fi/fcnt)*blur*.1;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    \t\n        \n    }\n    \n    return col/float(cnt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity = 504./640.;  \n    vec3 bloomSample = doBloom(uv, 200./360., 337./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.9));\n    col = pow(col, vec3(1.)*mix(0.45,1.45,(sat(length(cuv*3.)))));\n    col = col + (bloomSample*bloomIntensity);\n    \n    col = pow(col, vec3(1.9));\n    \n    col *= 1.-sat((length(cuv)-.25)*3.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28022, "src": "https://soundcloud.com/grafixmusicuk/acid-generation-1", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFT(a) texture(iChannel1, vec2(a, 0.)).x\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+abs(v.y);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(1000.); \n    for (int i = 0; i < 16; ++i)\n    {\n        float fi = float(i)*.5;\n        vec3 pos = p+vec3(0., sin(fi), cos(fi))*3.;\n        pos.y += sin(iTime+p.x*1.)*.1;\n        pos.xz *= r2d(fi+p.x*.1-fi*5.);\n        pos.z += sin(iTime+p.x*1.+fi);\n        float sz = 0.25*(pow(FFT(float(i)/16.),.1));\n        vec2 shape = vec2(length(pos.zy)-sz, fi);\n        acc = _min(acc, shape);\n    }\n    return acc;\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    float fov = mix(0.5,2., sin(iTime*.25)*.5+.5);\n    return normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+= rd*res.x*.25;\n    }\n    return vec3(-1.);\n}\n\n\nvec3 rdr(vec2 uv, vec2 ouv)\n{\n    vec3 col = .25*mix(vec3(0.), mix(vec3(0.145,0.831,0.443), vec3(0.898,0.165,0.275), sat(abs(uv.x))), pow(sat(lenny(uv*1.)),1.))*.75;\n    \n    vec3 ro = vec3(sin(iTime*.5)*5., -1.5+sin(iTime*.25), cos(iTime)*5.);\n    vec3 ta = vec3(0., 0., 0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 256);\n    \n    if (res.y > 0.)\n    {\n        vec3 p = ro + rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = 2.*sat(-.3*sin(res.z*10.+iTime*5.)+sin(10.*p.x+res.z+iTime*(res.z+2.)*20.+15.*pow(FFT(res.z/16.),.5)))*(n*.5+.5);\n        vec3 refl = reflect(rd, n);\n        col += texture(iChannel0, refl).xyz*(1.-sat(-dot(rd, n)))*(n*.5+.5);\n    }\n    else\n        col += .3*mix(vec3(0.), vec3(0.914,0.537,0.184), 1.-pow(sat(lenny(uv)),1.));\n    col += .25*mix(vec3(0.), vec3(0.914,0.537,0.184), 1.-pow(sat(lenny(uv)),1.));\n    \n    col = mix(col, texture(iChannel2, ouv).xyz, 0.5);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv*2.*r2d(sin(iTime*.5+uv.x*2.)*.5), fragCoord/iResolution.xy);\n\n    col *= pow(FFT(uv.x),.25)*.25+.75;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.14159265", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllGR7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 449, 449, 965], [968, 968, 1025, 1025, 1560]]}
{"id": "ssdGRX", "name": "Australian Summer", "author": "xenn", "description": "Dedicated to my best idiot savant friend Nathan. Why, Nathan, why?\n The displacement vectors are supplied by an underlying dynamical system. Click to panic", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "likes": 4, "viewed": 420, "published": 3, "date": "1630387585", "time_retrieved": "2024-07-30T19:03:59.165311", "image_code": "// Fork of \"A Handsome Mess with Dispersion\" by xenn. https://shadertoy.com/view/fdc3zj\n// 2021-08-31 05:24:34\n\n// Mashup Fork of \"Displacement with Dispersion\" by cornusammonis. https://shadertoy.com/view/4ldGDB\n// 2021-08-28 10:34:29\n// & this https://www.shadertoy.com/view/MsGSRd by flockeroo\n\n// displacement amount\n#define DISP_SCALE 2.0\n\n// chromatic dispersion samples\n#define SAMPLES 64\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),150.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 532, 532, 596], [598, 598, 618, 618, 667], [669, 1318, 1347, 1347, 1421], [1423, 1423, 1476, 1476, 1915], [1917, 1917, 1973, 1973, 2693]]}
{"id": "NstGzf", "name": "Acid toothpaste", "author": "xenn", "description": "Displacement mapping with chromatic dispersion. The displacement vectors are supplied by an underlying dynamical system. Mashed with another", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "likes": 27, "viewed": 838, "published": 3, "date": "1630378864", "time_retrieved": "2024-07-30T19:04:00.344159", "image_code": "\n// Mashup Fork of \"Displacement with Dispersion\" by cornusammonis. https://shadertoy.com/view/4ldGDB\n// 2021-08-28 10:34:29\n// & this https://www.shadertoy.com/view/MsGSRd by flockeroo\n\n// displacement amount\n#define DISP_SCALE 2.0\n\n// chromatic dispersion samples\n#define SAMPLES 64\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),150.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstGzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[398, 398, 421, 421, 485], [487, 487, 507, 507, 556], [558, 1207, 1236, 1236, 1310], [1312, 1312, 1365, 1365, 1804], [1806, 1806, 1862, 1862, 2582]]}
{"id": "fdd3Rf", "name": "3/4-three quarters", "author": "jorge2017a1", "description": "3/4-three quarters", "tags": ["34threequarters"], "likes": 2, "viewed": 200, "published": 3, "date": "1630373968", "time_retrieved": "2024-07-30T19:04:01.404326", "image_code": "//por jorge2017a1-\n//referencia\n//https://iquilezles.org/articles/distfunctions\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 Casa1(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float r1, r2, he;\n    r1=8.0;r2=0.25;he=8.0;\n    \n    float sdt1= sdTrapezoid(p.xy, r1, r2, he );\n    float sdb1= sdBox(p, vec3(10.0,10.0,10.0) );\n    float sint= intersectSDF(sdt1,sdb1);\n    float sdbC1= sdBox(p-vec3(0.0,-15.0,0.0), vec3(6.0,7.0,8.0) );\n    float sdbP1= sdBox(p-vec3(0.0,-17.0,-8.0), vec3(2.0,5.0,1.0) );\n    \n    p= rotate_y(p, radians(iTime*90.0));\n    float sds1= sdSphere( p-vec3(16.0,0.0,0.0), 2.0 );\n    \n    res =opU3(res, vec3(sint,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdbC1,3.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdbP1,0.0,MATERIAL_NO));\n    res =opU3(res, vec3(sds1,7.0,MATERIAL_NO)); \n    \n    return res;\n}\n\nvec3 Casa2(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float r1, r2, he;\n    r1=13.0;r2=7.0;he=8.0;\n    \n    p.y+=26.0;\n    float sdt1= sdTrapezoid(p.xy, r1, r2, he );\n    float sdb1= sdBox(p, vec3(14.0,10.0,12.0) );\n    float sint= intersectSDF(sdt1,sdb1);\n    float sdbC1= sdBox(p-vec3(0.0,-15.0,0.0), vec3(11.0,7.0,8.0) );\n    float sdbP1= sdBox(p-vec3(0.0,-17.0,-8.0), vec3(3.0,5.0,1.0) );\n    res =opU3(res, vec3(sint,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdbC1,5.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdbP1,0.0,MATERIAL_NO)); \n    \n    return res;\n}\n    \n\nvec3 Casa3(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float r1, r2, he;\n    r1=17.0;\n    r2=13.0;\n    he=8.0;\n    \n    p.y+=56.0;\n    float sdt1= sdTrapezoid(p.xy, r1, r2, he );\n    float sdb1= sdBox(p, vec3(18.0,10.0,12.0) );\n    float sint= intersectSDF(sdt1,sdb1);\n    float sdbC1= sdBox(p-vec3(0.0,-15.0,0.0), vec3(15.0,7.0,8.0) );\n    float sdbP1= sdBox(p-vec3(0.0,-17.0,-8.0), vec3(3.0,5.0,1.0) );\n          \n    res =opU3(res, vec3(sint,2.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdbC1,6.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdbP1,0.0,MATERIAL_NO)); \n    \n    return res;\n}\n    \n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\t\n    p.y= opRep1D(p.y, 100.0 );\n    p.x= opRep1D(p.x, 60.0 );\n    p.y=p.y-40.0;\n    \n    vec3 c1= Casa1(p);\n    res =opU3(res, c1); \n    \n    vec3 c2= Casa2(p);\n    res =opU3(res, c2);\n    \n    vec3 c3= Casa3(p);\n    res =opU3(res, c3);\n    \n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n//https://www.shadertoy.com/view/sdX3zN\nvec3 getBackgroundColor(vec2 uv) \n{\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(0., 0., 0.);\n  vec3 gradientEndColor = vec3(0., 0.5, 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .2)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    vec3 sky2= getBackgroundColor(rd.xy) ;\n\treturn (sky*1.5+sky2)/2.0;\n}\n\n//------------------------------------------------\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*6.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0+t,-40.0-45.0*abs(sin(iTime*0.5)));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[541, 541, 577, 577, 598], [599, 599, 631, 631, 715], [717, 761, 808, 808, 835], [836, 836, 879, 879, 906], [907, 907, 955, 955, 983], [984, 1022, 1058, 1058, 1103], [1104, 1169, 1203, 1203, 1299], [1300, 1300, 1334, 1334, 1425], [1426, 1426, 1460, 1460, 1551], [1593, 1593, 1618, 1618, 1637], [1638, 1638, 1663, 1663, 1682], [1683, 1683, 1719, 1719, 1747], [1749, 1749, 1814, 1814, 2124], [2126, 2126, 2146, 2146, 2838], [2840, 2840, 2860, 2860, 3414], [3421, 3421, 3441, 3441, 4017], [4024, 4064, 4089, 4089, 4397], [4399, 4450, 4474, 4474, 4636], [4638, 4638, 4687, 4687, 5354], [5356, 5410, 5446, 5446, 5691], [5692, 5747, 5774, 5774, 5791], [5793, 5793, 5829, 5829, 5921], [5922, 5922, 5968, 5968, 6093], [6095, 6095, 6169, 6169, 7768], [7769, 7858, 7938, 7938, 8061], [8062, 8143, 8178, 8178, 8431], [8434, 8434, 8466, 8466, 8721], [8775, 8827, 8920, 8920, 9091], [9094, 9094, 9125, 9125, 9720], [9722, 9771, 9797, 9797, 9907], [9909, 9909, 9967, 9967, 10019], [10021, 10070, 10127, 10127, 10743]]}
{"id": "NdtGRX", "name": "stars falling -basic", "author": "jorge2017a1", "description": "stars falling -basic", "tags": ["starsfallingbasic"], "likes": 4, "viewed": 273, "published": 3, "date": "1630352305", "time_retrieved": "2024-07-30T19:04:02.534303", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//refrencia\n//https://iquilezles.org/articles/distfunctions\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n          p.y=p.y-10.0;\n   \n   \n   vec2 sc = vec2(0.05);\n   vec2 hsc = 5.0/sc; \n   vec2 id = floor(p.xz*sc) + .5;\n   \n   p+=vec3(0.0,iTime*5.0,0.0);\n   p= opRep3D(p+vec3(.0,.0,.0), vec3(30.0,40.0,30.0) );\n   \n   \n   float r=10.0;\n   int n=5;\n   float m=3.0;\n   float sds1= sdStar(p.xy, r, n, m);\n   float sdb1= sdBox(p, vec3(12.0,12.0,2.0) );\n   \n   float sint= intersectSDF(sds1, sdb1);\n   float t1=mod(iTime,1.0);\n   float t2=mod(iTime,2.0);\n   float idc;\n   \n   if (t1<t2)\n       idc=length(id)+1.0+mod(id.x,5.0);\n   else\n       //idc=length(p.xy)+length(p.zy)+length(p.xz);\n       idc=floor(length(p.xy));\n   \n   \n   res =opU3(res, vec3(sint,idc,MATERIAL_NO));\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin *= atten*0.5*col*fshadow;\n   // lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n}\n//----------------------------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n//------------------------------------------------\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*2.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(10.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 10.0, 10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(15.0,7.0,0.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    \n    ///col = pow(col, vec3(0.6545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n///--------------------------------------------FIN\n///--------------------------------------------\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[540, 540, 572, 572, 656], [658, 702, 749, 749, 776], [777, 777, 820, 820, 847], [848, 848, 896, 896, 924], [925, 963, 999, 999, 1044], [1045, 1045, 1084, 1084, 1128], [1129, 1169, 1228, 1285, 1684], [1686, 1726, 1751, 1751, 2579], [2581, 2632, 2656, 2656, 2818], [2820, 2820, 2869, 2869, 3500], [3502, 3589, 3625, 3625, 3870], [3871, 3926, 3953, 3953, 3970], [3972, 3972, 4008, 4008, 4100], [4101, 4101, 4147, 4147, 4272], [4274, 4274, 4348, 4348, 5794], [5795, 5850, 5930, 5930, 6053], [6054, 6095, 6127, 6127, 6324], [6326, 6374, 6402, 6402, 6590], [6593, 6696, 6789, 6789, 6960], [6963, 6963, 6994, 6994, 7588], [7590, 7639, 7665, 7665, 7775], [7777, 7777, 7835, 7835, 7887], [7889, 7938, 7995, 7995, 8540]]}
{"id": "7dtGR2", "name": "Stanford bunny in 2k", "author": "goingdigital", "description": "Encoding the Stanford Bunny using radial basis functions. Ray marcher by FabriceNeyret2", "tags": ["sdf"], "likes": 19, "viewed": 1434, "published": 3, "date": "1630346610", "time_retrieved": "2024-07-30T19:04:03.288287", "image_code": "// Bunny SDF using radial basis functions.\n// The RBF is a sphere SDF. Number of RBFs have been adjusted to deliver a shader in\n// 2048 chars.\n//\n// Yes, missing some detail. But not half bad for a 2k model with renderer!\n//\n// Gist for the generating the model:\n//   https://colab.research.google.com/gist/going-digital/67e7db8e86319e19246ebe00248ac971/rbf-bunny.ipynb\n\n#define S(a,b,c,d) a*length(p-.01*vec3(b,c,d))\nfloat scene(vec3 p){\n  return -.428\n    + S(.332,64,-44,35)\n    - S(.359,0,-2,29)\n    + S(.285,53,-45,-63)\n    + S(.231,44,1,-54)\n    + S(.187,44,0,-54)\n    - S(.832,10,-5,-79)\n    + S(.255,37,-30,-52)\n    + S(.066,4,-8,-7)\n    - S(.417,41,-15,12)\n    + S(.159,-59,7,0)\n    + S(.658,-25,-40,46)\n    - S(.158,44,-16,-31)\n    + S(.245,7,-4,-14)\n    + S(.158,8,36,24)\n    + S(.579,-67,-27,45)\n    - S(.246,38,-69,-37)\n    - S(.403,-25,-31,-36)\n    - S(.27,-27,-55,18)\n    + S(.42,40,-44,20)\n    + S(.152,6,-5,-13)\n    + S(.255,46,43,48)\n    - S(.183,-21,-14,33)\n    - S(.174,37,-14,18)\n    + S(.403,-21,-11,-54)\n    + S(.152,-35,-1,-8)\n    + S(.283,-17,-48,-10)\n    + S(.503,-1,-41,-58)\n    - S(.29,-49,-1,28)\n    - S(.362,20,1,44)\n    + S(.32,-1,-12,49)\n    - S(.342,-70,12,31)\n    + S(.257,28,-32,42)\n    + S(.229,13,69,-41)\n    + S(.232,44,4,-11)\n    - S(.425,7,23,52)\n    - S(.285,-28,-32,17)\n    + S(.09,5,-7,-9)\n    + S(.063,3,27,18)\n    + S(.259,13,69,-41)\n    - S(.272,47,-19,-32)\n    - S(.287,-64,-26,6)\n    - S(.31,-3,51,62)\n    + S(.193,6,-5,-12)\n    + S(.304,37,-30,-52)\n    - S(.394,-23,-75,34)\n    + S(.189,7,-4,-14)\n    - S(.516,3,-40,73)\n    - S(.503,-35,-13,71)\n    - S(.386,-25,-22,71)\n    - S(.258,78,-40,-24)\n    - S(.457,-33,-6,33)\n    - S(.394,19,-7,34)\n    - S(.358,-22,-13,34)\n    - S(.358,13,-52,-38)\n    + S(.212,-0,32,19)\n    + S(.661,-5,-5,56)\n    + S(.843,-17,6,61)\n    + S(.022,3,-5,-5)\n    - S(.401,-27,-21,-33)\n    + S(.245,20,18,22)\n    + S(.742,-26,18,76)\n    - S(.139,44,-15,-31)\n    - S(.336,45,22,67)\n    + S(.147,34,21,34)\n    - S(.285,66,-7,35)\n    - S(.232,-83,-56,-20)\n    + S(.535,-40,-37,53)\n    + S(.094,5,-9,-7)\n    - S(.381,-30,-15,59)\n    + S(.313,-38,-24,-67)\n    - S(.291,-18,29,37)\n    + S(.621,-47,-37,65)\n    + S(.325,13,-40,-10)\n    - S(.179,-98,70,22)\n    - S(.271,45,-17,-31)\n    - S(.16,85,99,-29)\n    + S(.155,-56,-4,-5)\n    + S(.455,16,-45,36);\n}\n\n\n// Ray marcher by FabriceNeyret2\n\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = ( u -.5 * R ) / R.y, M = ( iMouse.xy - .5*R ) / R.y;\n    vec3 D = normalize(vec3(1.5,U)), p = vec3(-3,0,0);\n    float y = .5, z = iTime*.1, l = 0., d = l;\n    if (iMouse.z > 0.) y += -4.*M.y, z = -4.*M.x;\n    D.xz *= rot(y); D.xy *= rot(z);\n    p.xz *= rot(y); p.xy *= rot(z);\n    bool hit = false;\n    for (int i = 0; i < 150 && d < 5. && !hit; i++)\n        d = scene(p),\n        hit = d < 1e-3,\n        p += d*D,\n        l += d;\n\n    vec3 e = vec3(.01,0,0), n = normalize(scene(p) - vec3(scene(p-e),scene(p-e.yxy),scene(p-e.yyx)));\n    O = hit ? .2*max(0.,n.z)+.8*texture(iChannel0, reflect(D,n).xzy) : texture(iChannel0, D.xzy);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 438, 438, 2319], [2400, 2400, 2438, 2438, 3105]]}
{"id": "Nsc3RX", "name": "basic trapezoid", "author": "jorge2017a1", "description": "basic trapezoid", "tags": ["basictrapezoid"], "likes": 6, "viewed": 238, "published": 3, "date": "1630290407", "time_retrieved": "2024-07-30T19:04:04.141008", "image_code": "\n//por jorge2017a1-\n\n//Referencia\n//https://iquilezles.org/articles/distfunctions\n//https://iquilezles.org/articles/distfunctions2d\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    \n    \n    res =opU3(res, vec3(planeDist1,100.0,-1.0)); //inf\n    \n    p.y=p.y-6.5;\n    \n    p.z=opRep1D(p.z, 15.0 );\n    \n    float r1=7.0;\n    float r2=3.0;\n    float he=7.0;\n    \n    float sdt1= sdTrapezoid(p.xy, r1,r2,he )   ;\n     r1=6.0;\n     r2=2.5;\n     he=6.5;\n    \n    float sdt2= sdTrapezoid(p.xy, r1,r2,he );\n    \n    float sdb1= sdBox(p, vec3(10.0,10.0,3.0) );\n    float sdb2= sdBox(p, vec3(10.0,10.0,3.5) );\n    \n    float sinter1= intersectSDF(sdt1,sdb1);\n    float sinter2= intersectSDF(sdt2,sdb2);\n    float sdif= differenceSDF(sinter1,sinter2);\n    res =opU3(res, vec3(sdif,104.0,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*1.5; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    if (i==104 ) \n    {\n    return tex3D(iChannel0, p/32., nor); \n    }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{  \n    float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    mObj.dist=d;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n        \n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n    \n   return col;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\tmObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(1.0, 20.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3(-1.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    //col *= 1.0 - pow(mObj.dist /(MAX_DIST) , 3.5);    \n    col = pow(col, vec3(0.6545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsc3RX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[593, 593, 625, 625, 709], [711, 755, 802, 802, 829], [830, 830, 873, 873, 900], [901, 901, 949, 949, 977], [978, 1016, 1052, 1052, 1097], [1098, 1138, 1163, 1163, 1182], [1183, 1183, 1208, 1208, 1227], [1228, 1228, 1264, 1264, 1292], [1295, 1295, 1360, 1360, 1670], [1672, 1712, 1737, 1737, 2558], [2560, 2611, 2635, 2635, 2797], [2799, 2799, 2848, 2848, 3479], [3481, 3568, 3604, 3604, 3849], [3850, 3905, 3932, 3932, 3949], [3951, 3951, 3987, 3987, 4079], [4080, 4080, 4126, 4126, 4251], [4253, 4253, 4327, 4327, 5887], [5888, 5943, 5992, 5992, 6307], [6308, 6342, 6422, 6422, 6545], [6546, 6587, 6619, 6619, 6820], [6822, 6870, 6898, 6898, 7086], [7088, 7139, 7186, 7186, 7417], [7419, 7471, 7564, 7564, 8052], [8055, 8055, 8086, 8086, 8711], [8713, 8762, 8819, 8819, 9426]]}
{"id": "Ndt3Dn", "name": "Bloom Experiment", "author": "oneshade", "description": "Very dramatic bloom effect.\nRotate with mouse.", "tags": ["blur", "bloom", "glow"], "likes": 23, "viewed": 904, "published": 3, "date": "1630284496", "time_retrieved": "2024-07-30T19:04:05.163274", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    fragColor += texture(iChannel0, fragCoord / iResolution.xy) * BLOOM_STRENGTH;\n    fragColor.rgb *= vec3(0.9, 0.8, 0.5);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Horizontal blur pass\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float x=-WIDTH; x < WIDTH; x++) {\n        float weight = gaussian(x, BLUR);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(x, 0.0)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w; // Approaches 1 with more samples but unfortunately we can't take too many\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Vertical blur pass\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float y=-HEIGHT; y < HEIGHT; y++) {\n        float weight = gaussian(y, BLUR);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(0.0, y)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w; // Approaches 1 with more samples but unfortunately we can't take too many\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define BLOOM_STRENGTH 1.5\n#define BLOOM_THRESHOLD 1.46\n\n#define WIDTH 30.0\n#define HEIGHT 30.0\n#define BLUR 10.0\n\nfloat gaussian(in float x, in float sigma) {\n    x /= sigma;\n    return 0.398942280401 / (sigma * exp(0.5 * x * x)); // 0.398942280401 ~ 1/sqrt(2)\n}", "buffer_c_code": "// Modified raytracer template (https://www.shadertoy.com/view/fsBGRd)\n\n// Constants\n#define EPSILON 0.001\n#define INFINITY 1000000000.0\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Settings\n#define LIGHT_BOUNCES 3\n#define ZOOM 1.0\n#define AA 2\n\n// Convenience structs\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n\nstruct Mat {\n    vec3 color;\n    bool reflective;\n};\n\nstruct TraceInfo {\n    bool hit;\n    float dist;\n    vec3 pos;\n    vec3 nor;\n    Mat mat;\n};\n\n// Transformations\nmat2 Rotate2D(in float theta) {\n    float c = cos(theta), s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n// Primitive intersectors\nvoid addSphere(in vec3 pos, in float radius, in Mat mat, in Ray ray, inout TraceInfo scene) {\n    ray.pos -= pos;\n\n    float a = dot(ray.dir, ray.dir);\n    float b = dot(ray.pos, ray.dir);\n    float c = dot(ray.pos, ray.pos) - radius * radius;\n\n    float discr = b * b - a * c;\n    if (discr > 0.0) {\n        float t = (-sign(c) * sqrt(discr) - b) / a;\n        if (t > 0.0 && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = ray.pos + ray.dir * t;\n            scene.nor = scene.pos / radius;\n            scene.mat = mat;\n            scene.pos += pos;\n        }\n    }\n}\n\n// Main scene\nTraceInfo traceScene(in Ray ray) {\n    TraceInfo scene = TraceInfo(false, -1.0, vec3(0.0), vec3(0.0), Mat(vec3(0.0), false));\n\n    addSphere(vec3(1.0, 1.0, 1.0), 1.0, Mat(vec3(1.0, 0.0, 0.0), true), ray, scene);\n    addSphere(vec3(-1.0, 1.0, 1.0), 1.0, Mat(vec3(1.0, 1.0, 0.0), true), ray, scene);\n    addSphere(vec3(1.0, -1.0, 1.0), 1.0, Mat(vec3(1.0, 0.0, 1.0), true), ray, scene);\n    addSphere(vec3(-1.0, -1.0, 1.0), 1.0, Mat(vec3(1.0, 0.5, 0.6), true), ray, scene);\n    addSphere(vec3(1.0, 1.0, -1.0), 1.0, Mat(vec3(0.0, 1.0, 1.0), true), ray, scene);\n    addSphere(vec3(-1.0, 1.0, -1.0), 1.0, Mat(vec3(1.0, 0.8, 0.0), true), ray, scene);\n    addSphere(vec3(1.0, -1.0, -1.0), 1.0, Mat(vec3(0.0, 1.0, 0.0), true), ray, scene);\n    addSphere(vec3(-1.0, -1.0, -1.0), 1.0, Mat(vec3(0.0, 0.0, 1.0), true), ray, scene);\n\n    return scene;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * PI;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    Light[] lights = Light[](Light(vec3(-10.0, 10.0, 10.0), vec3(0.8, 0.2, 0.2)),\n                             Light(vec3(10.0, 10.0, 10.0), vec3(0.2, 0.8, 0.2)),\n                             Light(vec3(0.0, 10.0, -10.0), vec3(0.2, 0.2, 0.8)));\n\n    // Mouse rotation\n    mat2 yaw = Rotate2D(-mouse.x);\n    mat2 pitch = Rotate2D(-mouse.y);\n\n    // Take multiple subsamples for antialiasing\n    float aaStep = 1.0 / float(AA);\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            vec2 uv = (fragCoord + vec2(xOffs, yOffs) - center) / iResolution.y;\n            vec3 color = vec3(0.0);\n\n            Ray camRay = Ray(vec3(0.0, 0.0, 8.0), normalize(vec3(uv, -ZOOM)));\n\n            // Rotate with mouse\n            camRay.pos.yz *= pitch;\n            camRay.pos.xz *= yaw;\n            camRay.dir.yz *= pitch;\n            camRay.dir.xz *= yaw;\n\n            // Bounce the ray around the scene\n            float weight = 1.0 / float(LIGHT_BOUNCES);\n            for (int b=0; b < LIGHT_BOUNCES; b++) {\n                TraceInfo scene = traceScene(camRay);\n                vec3 lightDir; Ray shadow;\n                bool stopBouncing = false;\n                if (scene.hit) {\n                    for (int n=0; n < lights.length(); n++) {\n                        lightDir = normalize(lights[n].pos - scene.pos);\n                        float shade = max(0.0, dot(scene.nor, lightDir));\n\n                        // Trace a shadow ray\n                        shadow = Ray(scene.pos + scene.nor * EPSILON, lightDir);\n                        TraceInfo shadowTrace = traceScene(shadow);\n                        if (shadowTrace.hit) {\n                            shade = 0.0;\n                        }\n\n                        // Shade and break out of the loop if the shape is not reflective\n                        vec3 diff = lights[n].color * scene.mat.color * shade;\n                        if (scene.mat.reflective) diff *= weight;\n                        color.rgb += diff;\n                        if (!scene.mat.reflective) stopBouncing = true;\n                    }\n                }\n\n                // Sample the cubemap instead on a miss\n                else {\n                    color.rgb += texture(iChannel0, camRay.dir).rgb;\n                    stopBouncing = true;\n                }\n\n                // Bounce\n                camRay = Ray(shadow.pos, reflect(camRay.dir, scene.nor));\n                if (stopBouncing) break;\n            }\n\n            // Tonemap\n            color.rgb = pow(color.rgb, vec3(0.75));\n\n            // Combine\n            fragColor.rgb += color;\n        }\n    }\n\n    // Average\n    fragColor.rgb /= float(AA * AA);\n}", "buffer_c_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Thresholding for bloom overlay\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    if (length(fragColor.rgb) < BLOOM_THRESHOLD) fragColor = vec4(0.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 245]]}
{"id": "7sdGz2", "name": "complex roots of polynomial", "author": "kekwizard", "description": "For each pixel we apply newtons method to find a complex root of the given function \"func()\". The closest real root (as in \"actual\", still a complex number) determines the color that is produced.\n\"funcd()\" is the derivative of \"func()\", used for newton.", "tags": ["fractal", "complex", "polynomial", "roots"], "likes": 1, "viewed": 234, "published": 3, "date": "1630277438", "time_retrieved": "2024-07-30T19:04:05.915264", "image_code": "// raphael@gonku.de\n\n#define pi acos(-1.)\n#define angle(z) (atan(z.y/z.x) + pi * step(0.0, z.x))\n\n\n// -- some helper functions for complex numbers\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float v = (w.x * w.x + w.y * w.y);\n    vec2 r = vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y);\n    return r / v;\n}\n\n// Taken from \n// https://www.shadertoy.com/view/sdt3R2\n\nvec2 cmul(vec2 z, vec2 w) {\n    vec2 r = vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n    return r;\n}\n\nvec2 pol(vec2 z) {\n    float size = sign(z.x) * length(z);\n    float angle = angle(z);\n    return vec2(length(z), angle);\n}\n\nvec2 cart(vec2 pol) {\n    return pol.x * vec2(cos(pol.y), sin(pol.y));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n    vec2 p1 = pol(z);\n    vec2 p = vec2(pow(p1.x, w.x) * exp(-w.y * p1.y), p1.y * w.x + log(p1.x) * w.y);\n    vec2 r = cart(p);\n    return r;\n}\n\nvec2 cpow(vec2 z, float w) {\n    return cpow(z, vec2(w, 0.0));\n}\n\nvec2 cpow(vec2 z, int w) {\n    return cpow(z, float(w));\n}\n\n\n// --- main code\n\n\n#define NEWTON_ITER 15\n#define MOVE_ROOTS\n\n\n// P(z)\nvec2 func(vec2 z) {\n    return cpow(z, 5) + cpow(z, 2) - z + vec2(1.0, 0.0);\n}\n\n// P'(z)\nvec2 funcd(vec2 z) {\n    return cmul(vec2(5.0, 0.0), cpow(z, 4)) + cmul(vec2(2.0, 0.0), z) - vec2(1.0, 0.0);\n}\n\nvec2 newton(vec2 z) {\n    vec2 t = func(z);\n    vec2 td = funcd(z);\n    return z - cdiv(t, td);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n    float t = iTime;\n\n\n#ifdef MOVE_ROOTS\n\n    // actual complex roots of the function.\n    // i added some terms to move the points over time.\n    // mathematically speaking, this is nonsense,\n    // it does look cool tho\n    vec2 roots[5] = vec2[5] (\n        vec2(-1.324, 0.0) + 1.45 * vec2(sin(iTime) * 0.65, cos(iTime * 0.8)), \n        vec2(0.0, -1.0) + 0.35 * vec2(cos(iTime * 0.55 + 11.5), sin(iTime * 0.618)),\n        vec2(0.0, 1.0) + 1.45 * vec2(cos(iTime + 15.5), sin(iTime * 0.18)), \n        vec2(0.6623, 0.5622), \n        vec2(0.6623, -0.5622)\n    );\n    \n#else\n     \n    \n    // actual roots of function\n    const vec2 roots[5] =  vec2[5](\n        vec2(-1.324, 0.0),\n        vec2(0.0, -1.0),\n        vec2(0.0, 1.0),\n        vec2(0.6623, 0.5622),\n        vec2(0.6623, -0.5622)\n    ); \n    \n\n#endif\n\n    \n    \n\n    const vec3 colors[5] = vec3[5] (\n        vec3(0.937, 0.278, 0.435), \n        vec3(1.00, 0.82, 0.40), \n        vec3(0.024, 0.83, 0.62), \n        vec3(0.06, 0.54, 0.69), \n        vec3(0.02, 0.23, 0.29)\n    );\n    \n    \n\n    // zoom + slight pan\n    vec2 r = (p / (t*t)) - vec2(0.53315, 0.0);\n    \n\n    // newton\n    for(int i = 0; i < NEWTON_ITER; i++) {\n        r = newton(r);\n    }\n\n    // find closest root\n    float d = distance(r, roots[0]);\n    int ix = 0;\n    for(int i = 1; i < 5; i++) {\n        float nd = distance(r, roots[i]);\n        if(nd < d) {\n            d = nd;\n            ix = i;\n        }\n    }\n\n    fragColor = vec4(colors[ix], 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 175, 175, 299], [358, 358, 385, 385, 466], [468, 468, 486, 486, 591], [593, 593, 614, 614, 665], [667, 667, 694, 694, 838], [840, 840, 868, 868, 904], [906, 906, 932, 932, 964], [1030, 1038, 1057, 1057, 1116], [1118, 1127, 1147, 1147, 1237], [1239, 1239, 1260, 1260, 1336], [1338, 1338, 1393, 1393, 2941]]}
{"id": "ssdGR2", "name": "a cloud of music", "author": "pali6", "description": "I took the previous thing and tied parameters to music. I think it's neat. Enjoy.\nHold left mouse button to attract some of the cloud to your cursor!", "tags": ["simulation", "music"], "likes": 2, "viewed": 227, "published": 3, "date": "1630260888", "time_retrieved": "2024-07-30T19:04:06.728091", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    fragColor.yz = 0.2 * 0.5 * (fragColor.yz + vec2(1, 1)) * fragColor.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define N 4\n#define WF 0.6\n#define DISPERSION 1.6\n\nvec2 norm(vec2 v)\n{\n    if(length(v) <= 0.000001)\n        return v;\n    return normalize(v);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame <= 10)\n    {\n        fragColor = texture(iChannel1, uv) - vec4(-1., 0.5, 0.5, 0.);\n        return;\n    }\n    /*\n    if(mouse.z > 0. && distance(fragCoord, iMouse.xy) < 10.)\n    {\n        fragColor = vec4(1., rand(vec2(iTime, 42.) + mouse.xy) * 2. - 1., rand(vec2(iTime, 43.) + mouse.xy) * 2. - 1., 1.);\n        return;\n    }\n    */\n    ivec2 pos = ivec2(fragCoord);\n    \n    vec2 finalVel;\n    float finalAmount = 0.;\n    for(int dx = -1; dx <= 1; dx++)\n    {\n        for(int dy = -1; dy <= 1; dy++)\n        {\n            if(abs(dx) + abs(dy) != 1)\n                continue;\n            vec4 cur = texelFetch(iChannel0, pos + ivec2(-dx, -dy), 0);\n            vec2 cVel = cur.yz;\n            float cAmount = cur.x;\n            float mulSum = abs(cVel.x) + abs(cVel.y) + 0.000000001 + max(0., cAmount - 1.);\n            float mul = max(0., dot(vec2(dx, dy), cVel)) + max(0., cAmount - 1.) / 4.; // 4 = number of cardinal directions\n            mul /= mulSum;\n            cVel += max(0., cAmount - 1.) * vec2(dx, dy) * DISPERSION;\n            finalVel += cVel * cAmount * mul;\n            finalAmount += cAmount * mul;\n        }\n    }\n    finalVel = norm(finalVel);\n\n    vec2 alignVel;\n    vec2 cohesVel;\n    vec2 avoidVel;\n    for(int dx = -N; dx <= N; dx++)\n    {\n        for(int dy = -N; dy <= N; dy++)\n        {\n            vec4 cur = texelFetch(iChannel0, pos + ivec2(dx, dy), 0);\n            vec2 cVel = cur.yz;\n            float cAmount = cur.x;\n            alignVel += cVel * cAmount;\n            cohesVel += norm(vec2(dx, dy)) * cAmount;\n            if(abs(dx) + abs(dy) <= 3)\n                avoidVel += norm(vec2(dx, dy)) * (1. / (cAmount * cAmount * cAmount + 1.));\n        }\n    }\n    vec2 wallVel = \n        vec2(1. / (WF + uv.x), 0.) +\n        vec2(0., 1. / (WF + uv.y)) +\n        vec2(0., -1. / (1. - uv.y + WF)) +\n        vec2(-1. / (1. - uv.x + WF), 0.);\n    vec2 randVel = norm(vec2(rand(vec2(pos) + vec2(iTime, 1.)), rand(vec2(pos) + vec2(iTime, 0.))) * 2. - vec2(1, 1));\n    alignVel = norm(alignVel);\n    cohesVel = norm(cohesVel);\n    vec2 rotationVel = vec2(finalVel.y, - finalVel.x);\n    finalVel = norm(\n        4.0 * texture(iChannel2, vec2(0.1, 0.)).x * finalVel + \n        0.8 * texture(iChannel2, vec2(0.3, 0.)).x * alignVel + \n        0.6 * texture(iChannel2, vec2(0.5, 0.)).x * cohesVel + \n        0.0 * avoidVel + \n        0.1 * wallVel + \n        0.6 * texture(iChannel2, vec2(0.7, 0.)).x * randVel + \n        0.01 * texture(iChannel2, vec2(0.9, 0.)).x * rotationVel +\n        20.0 * (mouse.z > 0. ? 1. : 0.) * norm(iMouse.xy - fragCoord) / distance(fragCoord, iMouse.xy)\n    );\n    \n    fragColor = vec4(finalAmount, finalVel, 1.);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 213]]}
{"id": "sdd3zj", "name": "not a fluid simulation", "author": "pali6", "description": "A bit closer to what I wanted of the previous simulation. Mildly inspired by good ol' boids except it's a field of values instead of having particles.\nClick to create more stuff.\nYou might want to tinker with values around line 81 to change the behaviour.", "tags": ["simulation"], "likes": 7, "viewed": 328, "published": 3, "date": "1630260153", "time_retrieved": "2024-07-30T19:04:07.567845", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    fragColor.yz = 0.5 * (fragColor.yz + vec2(1, 1)) * fragColor.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define N 4\n#define WF 0.6\n#define DISPERSION 1.6\n\nvec2 norm(vec2 v)\n{\n    if(length(v) <= 0.000001)\n        return v;\n    return normalize(v);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame <= 10)\n    {\n        fragColor = texture(iChannel1, uv) - vec4(0., 0.5, 0.5, 0.);\n        return;\n    }\n    if(mouse.w > 0. && distance(fragCoord, iMouse.xy) < 10.)\n    {\n        fragColor = vec4(1., rand(vec2(iTime, 42.) + mouse.xy) * 2. - 1., rand(vec2(iTime, 43.) + mouse.xy) * 2. - 1., 1.);\n        return;\n    }\n    ivec2 pos = ivec2(fragCoord);\n    \n    vec2 finalVel;\n    float finalAmount = 0.;\n    for(int dx = -1; dx <= 1; dx++)\n    {\n        for(int dy = -1; dy <= 1; dy++)\n        {\n            if(abs(dx) + abs(dy) != 1)\n                continue;\n            vec4 cur = texelFetch(iChannel0, pos + ivec2(-dx, -dy), 0);\n            vec2 cVel = cur.yz;\n            float cAmount = cur.x;\n            float mulSum = abs(cVel.x) + abs(cVel.y) + 0.000000001 + max(0., cAmount - 1.);\n            float mul = max(0., dot(vec2(dx, dy), cVel)) + max(0., cAmount - 1.) / 4.; // 4 = number of cardinal directions\n            mul /= mulSum;\n            cVel += max(0., cAmount - 1.) * vec2(dx, dy) * DISPERSION;\n            finalVel += cVel * cAmount * mul;\n            finalAmount += cAmount * mul;\n        }\n    }\n    finalVel = norm(finalVel);\n\n    vec2 alignVel;\n    vec2 cohesVel;\n    vec2 avoidVel;\n    for(int dx = -N; dx <= N; dx++)\n    {\n        for(int dy = -N; dy <= N; dy++)\n        {\n            vec4 cur = texelFetch(iChannel0, pos + ivec2(dx, dy), 0);\n            vec2 cVel = cur.yz;\n            float cAmount = cur.x;\n            alignVel += cVel * cAmount;\n            cohesVel += norm(vec2(dx, dy)) * cAmount;\n            if(abs(dx) + abs(dy) <= 3)\n                avoidVel += norm(vec2(dx, dy)) * (1. / (cAmount * cAmount * cAmount + 1.));\n        }\n    }\n    vec2 wallVel = \n        vec2(1. / (WF + uv.x), 0.) +\n        vec2(0., 1. / (WF + uv.y)) +\n        vec2(0., -1. / (1. - uv.y + WF)) +\n        vec2(-1. / (1. - uv.x + WF), 0.);\n    vec2 randVel = norm(vec2(rand(vec2(pos) + vec2(iTime, 1.)), rand(vec2(pos) + vec2(iTime, 0.))) * 2. - vec2(1, 1));\n    alignVel = norm(alignVel);\n    cohesVel = norm(cohesVel);\n    vec2 rotationVel = vec2(finalVel.y, - finalVel.x);\n    finalVel = norm(\n        2.0 * finalVel + \n        0.3 * alignVel + \n        0.1 * cohesVel + \n        0.0 * avoidVel + \n        0.1 * wallVel + \n        0.2 * randVel + \n        0.0 * rotationVel\n    );\n    \n    fragColor = vec4(finalAmount, finalVel, 1.);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdd3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 207]]}
{"id": "sd33Rj", "name": "Op Heart", "author": "pbauermeister", "description": "My first shader.", "tags": ["opart"], "likes": 1, "viewed": 256, "published": 3, "date": "1630252440", "time_retrieved": "2024-07-30T19:04:08.361723", "image_code": "#define PI 3.1415926538\n#define SIZE 39.\n\nbool in_heart(in vec2 point) {\n    vec2 p = point;\n    \n    // rescale\n    p.y *= 1.5;\n    p.y += SIZE/8.;\n    p.y *= SIZE/25.;\n    p /= -SIZE/4.;\n    p.x += 1.;\n    \n    // heart for x in [-2, 2]\n    if (abs(p.x)>2.)\n        return false;\n    // top part\n    if (p.y > 0. && p.y < sqrt(1. - pow(abs(p.x)-1., 2.)))\n        return true;\n    // bottom part\n    if (p.y < 0. && p.y > acos(1.-abs(p.x)) - PI)\n        return true;\n\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -25 to +25)\n    float f = min(iResolution.x, iResolution.y);\n    vec2 point = fragCoord/f * SIZE - SIZE/2.;\n    // center\n    float dx = iResolution.x > f ? (iResolution.x-f) / SIZE : 0.;\n    float dy = iResolution.y > f ? (iResolution.y-f) / SIZE : 0.;\n    //point -= vec2(dx, dy);\n    // invert and skew\n    point.y *= -1.;\n    point.x += point.y/2.;  // skew\n\n    // waves and heart\n    float t = iTime / 4.;\n    float wave1 = simplex3d(vec3(point / 60. -t/2., t/2.));\n    float wave2 = simplex3d(vec3(point / 12. -t   , t   ));\n    float wave = (wave1*1.5 + wave2)/4. - (-cos(t)+.75)/12.;\n    float heart = in_heart(point) ? -.1 : -5.;\n\n    float disp = max(wave, heart); \n    point.y += disp * 8.;\n    \n    // horizontal stripes\n    float pattern = abs(point.y)<SIZE*.38 ? pow((cos(point.y*7.)+1.)/2., 2.) : 0.;\n\n    // color\n    vec3 col = vec3(pattern);\n    if (heart>wave) col = vec3(pattern, 0., 0.);  // red\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright  2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd33Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 72, 72, 488], [490, 490, 547, 601, 1540]]}
{"id": "sdtGzj", "name": "wisps", "author": "pali6", "description": "This is not quite what this was supposed to be originally but I don't feel like tinkering with it more right now, maybe later. \nClick to make a new wisp.", "tags": ["simulation"], "likes": 9, "viewed": 237, "published": 3, "date": "1630251117", "time_retrieved": "2024-07-30T19:04:09.179536", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    fragColor.yz = 0.5 * (fragColor.yz + vec2(1, 1)) * fragColor.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define N 4\n#define WF 0.\n\nvec2 norm(vec2 v)\n{\n    if(length(v) <= 0.000001)\n        return v;\n    return normalize(v);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame <= 10)\n    {\n        fragColor = texture(iChannel1, uv) - vec4(0., 0.5, 0.5, 0.);\n        return;\n    }\n    if(mouse.w > 0. && distance(fragCoord, iMouse.xy) < 10.)\n    {\n        fragColor = vec4(1., rand(vec2(iTime, 42.) + mouse.xy) * 2. - 1., rand(vec2(iTime, 43.) + mouse.xy) * 2. - 1., 1.);\n        return;\n    }\n    ivec2 pos = ivec2(fragCoord);\n    \n    vec2 finalVel = vec2(0);\n    float finalAmount = 0.;\n    for(int dx = -1; dx <= 1; dx++)\n    {\n        for(int dy = -1; dy <= 1; dy++)\n        {\n            if(abs(dx) + abs(dy) != 1)\n                continue;\n            vec4 cur = texelFetch(iChannel0, pos + ivec2(-dx, -dy), 0);\n            vec2 cVel = cur.yz;\n            float cAmount = cur.x;\n            float mul = max(0., dot(vec2(dx, dy), cVel)) / (abs(cVel.x) + abs(cVel.y) + 0.000000001);\n            finalVel += cVel * cAmount * mul;\n            finalAmount += cAmount * mul;\n        }\n    }\n    finalVel = norm(finalVel);\n\n    vec2 alignVel;\n    vec2 cohesVel;\n    vec2 avoidVel;\n    for(int dx = -N; dx <= N; dx++)\n    {\n        for(int dy = -N; dy <= N; dy++)\n        {\n            vec4 cur = texelFetch(iChannel0, pos + ivec2(dx, dy), 0);\n            vec2 cVel = cur.yz;\n            float cAmount = cur.x;\n            alignVel += cVel * cAmount;\n            cohesVel += vec2(dx, dy) * cAmount;\n            avoidVel += norm(vec2(dx, dy)) * (1. / (cAmount * cAmount * cAmount + 0.1));\n        }\n    }\n    vec2 wallVel = vec2(1. / (WF + uv.x), 0.) +\n        vec2(0., 1. / (WF + uv.y)) +\n        vec2(0., -1. / (1. - uv.y - WF)) +\n        vec2(-1. / (1. - uv.x - WF), 0.);\n    vec2 randVel = norm(vec2(rand(vec2(pos) + vec2(iTime, 1.)), rand(vec2(pos) + vec2(iTime, 0.))) * 2. - vec2(1, 1));\n    alignVel = norm(alignVel);\n    cohesVel = norm(cohesVel);\n    finalVel = norm(\n        1. * finalVel + \n        0.3 * alignVel + \n        0.4 * cohesVel + \n        0.004 * avoidVel + \n        0.01 * wallVel + \n        0.1 * randVel\n    );\n    \n    fragColor = vec4(finalAmount, finalVel, 1.);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtGzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 207]]}
{"id": "sst3Rj", "name": "Smaller 2D Rotation", "author": "KilledByAPixel", "description": "This is a demo of the smallest known way to apply a rotation in shader.", "tags": ["2d", "texture", "rotate"], "likes": 6, "viewed": 553, "published": 3, "date": "1630248341", "time_retrieved": "2024-07-30T19:04:10.393291", "image_code": "void mainImage(out vec4 o, vec2 p)\n{\n    // normalize uv around 0\n    p = ( p - .5 * iResolution.xy ) / iResolution.y;\n    \n    // angle to rotate by\n    float a = iTime*.1;\n    \n    // rotate uv by the angle\n    p = p*cos(a) + vec2(-p.y,p)*sin(a);\n\n    // set out color\n    o = texture(iChannel0, p - .5);\n    \n    // rotate the normal way\n    //float s = sin(a), c = cos(a);\n    //p *= mat2(c, -s, s, c);\n    \n    // this also works if you trust the optimizer\n    //p *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    \n    // another small way with some precision loss\n    //p *= mat2(cos(a - vec4(0, 11, 33, 0)));\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sst3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 65, 614]]}
{"id": "7stGRj", "name": "Dune (Sand Worm)", "author": "dean_the_coder", "description": "Anyone else looking forward to the new Dune movie?\nThe cycle lasts 30 seconds, if you can wait that long.", "tags": ["3d", "raymarching", "dune", "movie", "cineshader"], "likes": 52, "viewed": 7947, "published": 3, "date": "1630245519", "time_retrieved": "2024-07-30T19:04:11.575131", "image_code": "// 'Dune (Sand Worm)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/7stGRj (YouTube: https://youtu.be/GqkO68U4Hws)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I'm kinda excited about the new Dune movie, but hope they\n// don't mess it up. The 1984 version was the one for me!\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, and a bunch\n// of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define NM\tnormalize\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S01(a)\tsmoothstep(0., 1., a)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define minH(a, b, c) { float h_ = a; if (h_ < h.d) h = Hit(h_, b, c); }\n\nfloat t;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat box(vec3 p, vec3 b) { return length(max(abs(p) - b, 0.)); }\n\nfloat cap(vec3 p, vec2 h) {\n\tp.y -= clamp(p.y, 0., h.x);\n\treturn length(p) - h.y;\n}\n\nHit map(vec3 p) {\n\tfloat d, e, g, lp, r, rz,\n\t      f = S(0., 5., t),\n\t      n = n31(p * 4.);\n\td = n21(p.xz * .1) * 3. + p.y + 2.5;\n\tg = smin(d, length(p - vec3(.2, -8.6, 12.6)) - 6. + .01 * (.5 + .5 * sin(p.y * 22.)), 1.);\n\tp += vec3(.5 + sin(t * .6) * .2 + .6 * sin(p.z * .4 - .66), 1. - cos(p.z * .3 - .3 - f * mix(.8, 1., S01(sin(t * 1.4) * .5 + .5))) * 1.8, S(28., 30., t) * 2.5 - mix(6., 2.8, f));\n\tr = .8 + smin(p.z * .18, 2., .5) + abs(sin(p.z * 2.) * S01(p.z) * .05);\n\tr *= S(-5.3 + 2.75 * cos(t * .8) * f, 1.4, p.z);\n\tlp = length(p.xy);\n\tf = abs(lp - r - .05) - .03;\n\tr *= S(2.5, .35 + sin(t) * .1, p.z);\n\td = max(abs(lp - r) - .02, .4 - p.z);\n\tp.xy = vec2(fract(atan(p.y, p.x) * .477) - .5, lp);\n\tp.y -= r;\n\tHit h = Hit(min(d, box(p, vec3(.2 + p.z * .77, .02, .4))), 2, p);\n\tp.y += .13;\n\tvec2 v2 = vec2(.1, sat(.07 * p.y));\n\tp.z -= .4;\n\trz = mod(p.z, .3) - .15;\n\te = max(min(cap(vec3(mod(p.x, .08333) - .04167, p.y, rz), v2), cap(vec3(mod(p.x + .04167, .08333) - .04167, p.y, rz - .15), v2)), -0.05 - p.z * 0.2);\n\td = abs(p.x) - p.z * .5 - .5;\n\tminH(max(e, d), 4, p);\n\tf = max(f, d - .05);\n\tminH(f, 3, p);\n\tg = smin(g, h.d, .4 + .4 * n * S(1., 0., abs(g - f)));\n\tminH(g, 1, p);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn NM(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - lp);\n\tvec3 ld = NM(lp - p);\n\tfor (float i = Z0; i < 40.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -.001); }\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tvec3 c,\n\t     ld = NM(vec3(6, 3, -10) - p),\n\t     n = N(p, d);\n\tfloat spe = 1.;\n\tif (h.id == 3) {\n\t\tc = vec3(.4, .35, .3);\n\t\tn.y += n31(h.uv * 10.);\n\t\tn = NM(n);\n\t}\n\telse if (h.id == 2) c = mix(vec3(.16, .08, .07), vec3(.6), pow(n31(h.uv * 10.), 3.));\n\telse if (h.id == 4) c = vec3(.6, 1, 4);\n\telse {\n\t\tspe = .1;\n\t\tc = vec3(.6);\n\t\tn.x += sin((p.x + p.z * n.z) * 8.) * .1;\n\t\tn = NM(n);\n\t}\n\n\tfloat ao = mix(ao(p, n, .2), ao(p, n, 2.), .7);\n\treturn mix((sat(.1 + .9 * dot(ld, n)) * (.1 + .9 * shadow(p, vec3(6, 3, -10))) * (.3 + .7 * ao) + (sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.) * spe) * ao) * c * vec3(1.85, .5, .08), vec3(1.85, .5, .08), S(.7, 1., 1. + dot(rd, n)) * .1);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s, float mx) {\n\tfloat i,\n\t      d = .01;\n\tHit h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t\tif (d > mx) return vec4(0);\n\t\tp += h.d * rd;\n\t}\n\n\treturn vec4(lights(p, rd, d, h), h.id);\n}\n\nvec3 scene(vec3 rd) {\n\tt = mod(iTime, 30.);\n\tvec3 c,\n\t     p = vec3(0);\n\tvec4 col = march(p, rd, 180., 64.);\n\tfloat f = 1.,\n\t      x = n31(rd + vec3(-t * 2., -t * .4, t));\n\tif (col.w == 0.) c = mix(vec3(.5145, .147, .0315), vec3(.22, .06, .01), sat(rd.y * 3.));\n\telse {\n\t\tc = col.rgb;\n\t\tf = fog(p * (.7 + .3 * x));\n\t}\n\n\tf *= 1. - x * x * x * .4;\n\treturn mix(vec3(.49, .14, .03), c, sat(f));\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(t), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     q = fc.xy / R.xy;\n\tvec3 r = NM(cross(vec3(0, 1, 0), vec3(0, 0, 1))),\n\t     col = scene(NM(vec3(0, 0, 1) + r * uv.x + cross(vec3(0, 0, 1), r) * uv.y));\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col) * sat(30. - t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stGRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[935, 935, 954, 954, 1237], [1239, 1239, 1258, 1258, 1284], [1286, 1286, 1325, 1325, 1407], [1409, 1409, 1436, 1436, 1474], [1476, 1476, 1503, 1503, 1559], [1561, 1561, 1578, 1578, 2762], [2764, 2764, 2789, 2789, 3001], [3003, 3003, 3034, 3034, 3294], [3296, 3296, 3331, 3331, 3362], [3364, 3364, 3383, 3383, 3416], [3418, 3418, 3464, 3464, 4190], [4192, 4192, 4246, 4246, 4459], [4461, 4461, 4482, 4482, 4853], [4926, 4926, 4986, 4986, 5047], [5049, 5049, 5094, 5094, 5397]]}
{"id": "fstGz2", "name": "ZCAM color palette generation", "author": "kdrag0n", "description": "Generating Material You color palettes in the ZCAM (default) and Oklab (mouse down) color spaces.\n\nThis shader has many other features; see https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "palette", "cam", "colorscience", "oklab", "zcam"], "likes": 4, "viewed": 468, "published": 3, "date": "1630233390", "time_retrieved": "2024-07-30T19:04:13.035227", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Bjrn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = true;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    } else {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    /*if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    fragColor = vec4(fragColor.rgb + digit2, 1.0);\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1447, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [2147, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3615, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4071, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [6255, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6403, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7247, 7247, 7272, 7272, 7791], [7793, 7793, 7818, 7818, 8344], [8346, 8346, 8378, 8378, 8423], [8425, 8425, 8457, 8457, 8502], [9711, 9875, 9923, 10081, 12107], [12109, 12200, 12234, 12297, 12674], [12676, 12814, 12893, 12936, 15967], [15969, 15969, 16015, 16015, 16585], [16587, 16587, 16629, 16629, 17184], [17186, 17186, 17231, 17231, 17992], [17994, 17994, 18050, 18050, 18725], [18727, 18727, 18786, 18786, 19737], [20350, 20350, 20369, 20369, 20507], [20509, 20509, 20531, 20531, 20663], [20665, 20665, 20691, 20691, 21137], [21139, 21139, 21163, 21163, 21220], [21222, 21222, 21274, 21274, 21422], [21424, 21424, 21545, 21545, 21821], [22110, 22110, 22162, 22206, 23442], [23444, 23444, 23496, 23496, 25007], [25009, 25009, 25073, 25073, 25199], [25272, 25272, 25340, 25340, 26379], [28003, 28003, 28128, 28128, 28516], [28518, 28518, 28619, 28619, 28954], [28956, 28956, 28993, 28993, 29657], [29659, 29659, 29759, 29759, 30885], [30887, 30887, 30927, 30927, 31394], [31431, 31431, 31499, 31499, 31621], [31623, 31623, 31692, 31692, 31843], [31845, 31845, 31912, 31912, 32169], [32172, 32172, 32244, 32244, 32357], [32359, 32359, 32432, 32432, 32566], [32568, 32568, 32639, 32639, 32867], [32890, 32890, 32941, 32941, 33384], [33386, 33386, 33443, 33443, 33572], [33574, 33574, 33625, 33625, 33665], [33684, 33684, 33739, 33739, 36643]]}
{"id": "NdtGz2", "name": "Color blending in ZCAM and Oklab", "author": "kdrag0n", "description": "Blending red with white in the ZCAM (default) and Oklab (mouse down) color spaces.\n\nThis shader has many other features that can be enabled by uncommenting the respective sections in mainImage. See https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "blending", "cam", "colorscience", "oklab", "zcam"], "likes": 3, "viewed": 524, "published": 3, "date": "1630233242", "time_retrieved": "2024-07-30T19:04:14.072454", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Bjrn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = false;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    } else {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    /*if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    //camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    fragColor = vec4(fragColor.rgb + digit2, 1.0);\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1447, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [2147, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3615, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4071, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [6255, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6403, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7247, 7247, 7272, 7272, 7791], [7793, 7793, 7818, 7818, 8344], [8346, 8346, 8378, 8378, 8423], [8425, 8425, 8457, 8457, 8502], [9711, 9875, 9923, 10081, 12107], [12109, 12200, 12234, 12297, 12674], [12676, 12814, 12893, 12936, 15967], [15969, 15969, 16015, 16015, 16585], [16587, 16587, 16629, 16629, 17184], [17186, 17186, 17231, 17231, 17992], [17994, 17994, 18050, 18050, 18725], [18727, 18727, 18786, 18786, 19737], [20350, 20350, 20369, 20369, 20507], [20509, 20509, 20531, 20531, 20663], [20665, 20665, 20691, 20691, 21137], [21139, 21139, 21163, 21163, 21220], [21222, 21222, 21274, 21274, 21422], [21424, 21424, 21545, 21545, 21821], [22110, 22110, 22162, 22206, 23442], [23444, 23444, 23496, 23496, 25007], [25009, 25009, 25073, 25073, 25199], [25273, 25273, 25341, 25341, 26380], [28004, 28004, 28129, 28129, 28517], [28519, 28519, 28620, 28620, 28955], [28957, 28957, 28994, 28994, 29658], [29660, 29660, 29760, 29760, 30886], [30888, 30888, 30928, 30928, 31395], [31432, 31432, 31500, 31500, 31622], [31624, 31624, 31693, 31693, 31844], [31846, 31846, 31913, 31913, 32170], [32173, 32173, 32245, 32245, 32358], [32360, 32360, 32433, 32433, 32567], [32569, 32569, 32640, 32640, 32868], [32891, 32891, 32942, 32942, 33385], [33387, 33387, 33444, 33444, 33573], [33575, 33575, 33626, 33626, 33666], [33685, 33685, 33740, 33740, 36642]]}
{"id": "fdtGz2", "name": "[CC 2021-08-28]  Shure Iken", "author": "totetmatt", "description": "Done for Chaos Constructions 2021 Shader Jam.\n\n** With comments ! **", "tags": ["terrain", "green", "outline"], "likes": 5, "viewed": 328, "published": 3, "date": "1630233109", "time_retrieved": "2024-07-30T19:04:14.985014", "image_code": "/*\n\nFOR THE SOUNDCLOUD, REFRESH THE PAGE IF YOU HAVE THE ERROR MESSAGE\n\nChaos Constructions 2021-08-28\n\n*** Thanks to all the shader showdown scene folks ***\n\n*** Thanks my co-participants Tater, eimink & provod. Go check their stuff ! ***\n\n*** Thanks havoc and random for organising the jam ! ***\n\n>>>>\n***** PRIVIET CHAOS CONSTRUCTION ! KAK DELA ?  *****\n<<<<\n*/\n\n//Bonzo Trick\n#define fGlobalTime iTime \n\n// Need this for switch Iso to non iso\n// You will see after, it's a munch of mix on camera \n// But keep in mind to respect everywhere the order of the mix\n// Here 0, mix left = Non iso and  1,mix right = Iso\n#define timer (clamp(cos(fGlobalTime*.5),-.25,.05)*2.+.5) \nmat2 rot(float a){float c=cos(a),s=sin(a);return  mat2(c,-s,s,c);}\n\nfloat txt(vec2 uv,float s){\n    uv = vec2(log(length(uv)),atan(uv.y,uv.x))*3.5/atan(1.); // LogPolar coordinates\n    uv -=fGlobalTime*.5; // Rotate and zoom in one  (thx logpolar)\n    int x = int(abs(uv.x)*s); \n    int y = int(abs(uv.y)*s);\n    float z = float(x ^ y) ;  // Some messing up, need int to play with Bit operation :) \n     return texture(iChannel0,fract(vec2( (z /s)*.1))).r; // I love fft based effect ;\n}\n// Based on iq\nfloat diam(vec3 p,float s){\n      p  =abs(p);\n      return (p.x+p.y+p.z-s)*inversesqrt(3.);\n       //                      ^----- does it make sense instead of sqrt(1./3.) ? I don't know\n  }\n// Based on iq  \n float box(vec3 p,vec3 b){ // Taht's a box, nothing fancy\n      vec3 q = abs(p)-b;\n      return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n    \n   }\n   \n   \n// a mix of Iq article on fbmdetail (and all fbm related stuff)\n// & Evvvvil stuff about displacement\n// It's a nice way to generate sort of terrain \nfloat dd(vec3 p){\n    p*=.1; // Scaling makes this low poly effect\n    float q = 0.; // Start at 0 but could tune that\n    vec4 pp= vec4(p,1.);\n    for(float i=0.;i<=12.;i++){ // yes 12 loop, but still \"cheap\" sort of ? \n           \n           // Doing whatever you want, clamp it and don't forget scale compentation\n           q += clamp(cos(length(pp.xz))+sin(pp.x)+sin(pp.z*2.) ,0.,.75)/pp.a; \n           pp.xz*=rot(-.785*i+i);\n           pp*=1.2;\n           pp.xyz = abs(pp.xyz)-.5;\n      }\n      return q;\n  \n }\n \n float qq = 0.; // Keep the displacement\n vec3 oop ;  // Keep the position for later\nvec2 sdf(vec3 p){\n   vec3 op =p ;\n    p.yz=mix(p.yz,p.yz*rot(atan(inversesqrt(1./2.))),timer); // Camera Switch between iso and non iso\n    p.xz=mix(p.xz,p.xz*rot(3.1415/4.),timer); // Camera Switch between iso and non iso\n    \n    vec2 h;\n   vec3 hp = p+vec3(0.,asin(sin(fGlobalTime)),0.); // Object doing up and down -> '/\\/\\/\\'\n    hp .x = abs(abs(hp.x)-3.1-texture(iChannel0,vec2(.3)).r)-1.5; // Duplication of 4 objects \n    hp.yz *=rot(-fGlobalTime); // You see them rollin\n    h.x = mix(box(hp,vec3(1.)),diam(hp,1.),1.3)*.9; // Secret receipe of the start / 3D shuriken\n    qq= sqrt(\n         texture(iChannel0,\n                 fract(vec2(floor(length(p.xz*10.)*.1)*.1-fGlobalTime*.5))\n                 ).r\n        )*.5; // did I told you I love fft  ? \n     h.y = mod(floor(fGlobalTime-p.x-p.z),2.) ==0. ? 3.:4.; // Texture switch for later\n     oop = hp; // need this for txture application later\n     \n     // Done with the shuriken, now the terrain\n     // Going forward right, or forwad on iso cam\n     p.zx +=fGlobalTime+100.;\n     vec2 t;\n    // Non conventional, not using the dot(n,vec3(0.,1.,0.)) but just p.y and then adding stuff\n    t.x = p.y+3.2+dd(p+qq*.5)*2.5+qq*.1+texture(iChannel0,vec2(p.z*.01)).r*.5;\n    \n    \n    //t.x = max(-(abs(p.x)+.5),t.x); I wanted to 'cut' the terrain in a band, couldn't remember how\n  \n    // Texture switch, the \"texture wave\" in the terrain\n    t.y = sin((op.x+op.z)*.1+fGlobalTime) < 0.01+qq? 1.:2.;\n    \n \n  // Mixing everything\n    h= t.x < h.x ? t:h;\n    \n    // OH YEAH\n    return h;  \n}\n\n// Routine for normal compute, sooo tini\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p, float e){vec2 nv= vec2(-e,e);return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\n\n// Some ao, completly useless here and mostly incorrect\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,.3)+ao(rp,n,.5))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // El famoso background\n   vec3 col = vec3(.1)*txt(uv,100.);\n  \n  // Camera\n  vec3 ro = vec3(0.,0.,-5.);\n  float zz = 20.;\n  \n  ro = mix(ro,vec3(uv*zz,-zz),timer); // Camera Switch between iso and non iso\n  vec3 rd = normalize(vec3(uv,1.));\n  rd = mix(rd,vec3(0,0,1),timer);// Camera Switch between iso and non iso\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 rp = ro;\n  vec3 acc = vec3(0.);\n  for(float i=0.;i<=128.;i++){\n      vec2 d= sdf(rp);\n      if(d.y == 1.){ // Add some \"glow\" on terrain\n        acc +=vec3(.1,0.,1.)*exp(-abs(d.x))/(69.-qq*10.);\n        \n        }\n      if(length(rp) > 75.) break; // If too far break;\n      if(d.x<.001){\n          vec3 n = norm(rp,.003); // Get normal\n          if(d.y == 1.){ // Texture 1 : \"Normal terrain\"\n          // For people that really know their stuff\n          // I'm still learning lightning, so what is under this comment\n          // will mostly be incorrect. I'm aware, and I'm working on it\n          float diff=  max(0.,dot(normalize(light-rp),n)); // diffraction \n          float spc = pow(max(0.,dot(normalize(ro-rp),reflect(-normalize(light),n))),16.); // Specular\n          float fr = pow(1.+dot(n,rd),8.); // Frenel\n          col = vec3(.01)*diff+ vec3(1.)*spc+fr*vec3(.0,1.,.0)*.5; //Color composition\n      \n          break; \n          } else if(d.y == 2.){ // Texture 2 : The terrain outline\n          // Outline stuff is basically computing the normal on the same point but at different\n          // \"scale / resolution / epsilon value\" and taking the different / lenght of it\n          // -> If you are on a surface that doesn't change that much (plane of sphere) length will be 0\n          // -> If you are close to and edge (corner , breaking in the shape), the length > 0\n              float edge = length(n-norm(rp,.001*length(ro-rp))); \n            col  = vec3(.0,1.,.0)*edge;\n            \n              break;\n          } else if(d.y== 3.){  // texture 3: Boring texture for shuriken\n  float diff=  max(0.,dot(normalize(light-rp),n));            \n            col = diff * vec3(1.);\n            \n                break;\n            } else if(d.y == 4.){ // Texture 4, the generative texture applied to shuriken\n               float diff=  max(0.,dot(normalize(light-rp),n));\n                col = diff*vec3(2.)*txt(oop.xz*.1,1.);\n                break;\n            }\n       }\n       \n       rp+=rd*d.x*.9; // Poor trick to avoid glitch (as you can see not fixing everything)\n    \n   }\n  col +=acc; // Don't forget the glow\n\n    // YAY\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 28014, "src": "https://soundcloud.com/rezdubstep/signals-ep-out-now", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[676, 676, 694, 694, 742], [744, 744, 771, 771, 1163], [1164, 1179, 1206, 1206, 1369], [1370, 1388, 1413, 1444, 1547], [1556, 1706, 1723, 1723, 2222], [2241, 2310, 2327, 2327, 3860], [3929, 3929, 3956, 3956, 4035], [4186, 4186, 4243, 4293, 6905]]}
{"id": "Nsd3R2", "name": "ZCAM and Oklab lightness ramps", "author": "kdrag0n", "description": "Linear lightness ramps in the ZCAM (default) and Oklab (mouse down) color spaces.\n\nThis shader has many other features that can be enabled by uncommenting the respective sections in mainImage. See https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "cam", "colorscience", "oklab", "lightness", "zcam"], "likes": 1, "viewed": 323, "published": 3, "date": "1630233027", "time_retrieved": "2024-07-30T19:04:16.069115", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Bjrn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = false;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    } else {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return zcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    /*if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Lightness ramp\n    if (iMouse.z > 0.0) {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    }\n\n    // Theme generation\n    //camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    fragColor = vec4(fragColor.rgb + digit2, 1.0);\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsd3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1447, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [2147, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3615, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4071, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [6255, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6403, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7247, 7247, 7272, 7272, 7791], [7793, 7793, 7818, 7818, 8344], [8346, 8346, 8378, 8378, 8423], [8425, 8425, 8457, 8457, 8502], [9711, 9875, 9923, 10081, 12107], [12109, 12200, 12234, 12297, 12674], [12676, 12814, 12893, 12936, 15967], [15969, 15969, 16015, 16015, 16585], [16587, 16587, 16629, 16629, 17184], [17186, 17186, 17231, 17231, 17992], [17994, 17994, 18050, 18050, 18725], [18727, 18727, 18786, 18786, 19737], [20350, 20350, 20369, 20369, 20507], [20509, 20509, 20531, 20531, 20663], [20665, 20665, 20691, 20691, 21137], [21139, 21139, 21163, 21163, 21220], [21222, 21222, 21274, 21274, 21422], [21424, 21424, 21545, 21545, 21821], [22110, 22110, 22162, 22206, 23442], [23444, 23444, 23496, 23496, 25007], [25009, 25009, 25073, 25073, 25199], [25273, 25273, 25341, 25341, 26380], [28004, 28004, 28129, 28129, 28517], [28519, 28519, 28620, 28620, 28955], [28957, 28957, 28994, 28994, 29658], [29660, 29660, 29760, 29760, 30886], [30888, 30888, 30928, 30928, 31395], [31432, 31432, 31500, 31500, 31622], [31624, 31624, 31693, 31693, 31844], [31846, 31846, 31913, 31913, 32170], [32173, 32173, 32245, 32245, 32358], [32360, 32360, 32433, 32433, 32567], [32569, 32569, 32640, 32640, 32868], [32891, 32891, 32942, 32942, 33381], [33383, 33383, 33440, 33440, 33569], [33571, 33571, 33622, 33622, 33662], [33681, 33681, 33736, 33736, 36638]]}
{"id": "fsd3R2", "name": "ZCAM and Oklab gamut", "author": "kdrag0n", "description": "Visualizing the sRGB gamut in ZCAM (default) and Oklab (mouse down) color spaces.\n\nThis shader has many other features that can be enabled by uncommenting the respective sections in mainImage. See https://github.com/kdrag0n/glcolortest for more info.", "tags": ["color", "cam", "gamut", "colorscience", "oklab", "zcam"], "likes": 4, "viewed": 691, "published": 3, "date": "1630231596", "time_retrieved": "2024-07-30T19:04:17.455409", "image_code": "precision highp float;\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2021 Danny Lin <danny@kdrag0n.dev>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/*\n * Config\n */\n\nconst float HUE_RATE = 20.0;\n\nconst float SRGB_WHITE_LUMINANCE = 203.0; // cd/m^2\nconst float SRGB_WHITE_LUMINANCE_DYN_MAX = 10000.0; // cd/m^2\n\n\n/*\n * Helpers\n */\n\nconst float PI = 3.141592653589793;\nconst float FLT_MAX = 3.402823466e+38;\n\nfloat degreesToRadians(float x) {\n    return x * PI / 180.0;\n}\n\nfloat radiansToDegrees(float x) {\n    return x * 180.0 / PI;\n}\n\nfloat atan2(float y, float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nfloat square(float x) {\n    return x * x;\n}\n\nfloat cube(float x) {\n    return x * x * x;\n}\n\nfloat sqrtStd(float x) {\n    if (x < 0.0) {\n        return 0.0 / 0.0;\n    } else {\n        return sqrt(x);\n    }\n}\n\n\n/*\n * Number rendering\n */\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0)\n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\n    bool bNeg = ( fValue < 0.0 );\n    fValue = abs(fValue);\n\n    float fLog10Value = log2(abs(fValue)) / log2(10.0);\n    float fBiggestIndex = max(floor(fLog10Value), 0.0);\n    float fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n    float fCharBin = 0.0;\n    if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n        if(fDigitIndex > fBiggestIndex) {\n            if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n        } else {\n            if(fDigitIndex == -1.0) {\n                if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n            } else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n                float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n            }\n        }\n    }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n/*\n * LCh\n */\n\nvec3 labToLch(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float hDeg = radiansToDegrees(atan2(b, a));\n    return vec3(\n        L,\n        sqrt(a*a + b*b),\n        (hDeg < 0.0) ? hDeg + 360.0 : hDeg\n    );\n}\n\nvec3 lchToLab(vec3 c) {\n    float L = c.x;\n    float C = c.y;\n    float h = c.z;\n\n    float hRad = degreesToRadians(h);\n    return vec3(\n        L,\n        C * cos(hRad),\n        C * sin(hRad)\n    );\n}\n\n\n/*\n * sRGB\n */\n\nvec3 srgbTransfer(vec3 c) {\n    vec3 gamma = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;\n    vec3 linear = 12.92 * c;\n    bvec3 selectParts = lessThan(c, vec3(0.0031308));\n    return mix(gamma, linear, selectParts);\n}\n\nvec3 srgbTransferInv(vec3 c) {\n    vec3 gamma = pow((c + 0.055)/1.055, vec3(2.4));\n    vec3 linear = c / 12.92;\n    bvec3 selectParts = lessThan(c, vec3(0.04045));\n    return mix(gamma, linear, selectParts);\n}\n\nbool linearSrgbInGamut(vec3 c) {\n    vec3 clamped = clamp(c, 0.0, 1.0);\n    return c == clamped;\n}\n\nfloat _int8ToFloat(int x) {\n    return float(x) / 255.0;\n}\n\nvec3 rgb8ToFloat(int c) {\n    return vec3(\n        _int8ToFloat((c >> 16) & 0xff),\n        _int8ToFloat((c >> 8) & 0xff),\n        _int8ToFloat(c & 0xff)\n    );\n}\n\n\n/*\n * XYZ\n */\n\nconst vec3 D65 = vec3(0.95047, 1.0, 1.08883);\nconst vec3 DCI_P3 = vec3(0.89458689, 1.0, 0.95441595);\n\nconst mat3 M_SRGB_TO_XYZ = mat3(\n    0.4123908 , 0.21263901, 0.01933082,\n    0.35758434, 0.71516868, 0.11919478,\n    0.18048079, 0.07219232, 0.95053215\n);\nconst mat3 M_XYZ_TO_SRGB = mat3(\n     3.24096994, -0.96924364,  0.05563008,\n    -1.53738318,  1.8759675 , -0.20397696,\n    -0.49861076,  0.04155506,  1.05697151\n);\n\nconst mat3 M_DISPLAY_P3_TO_XYZ = mat3(\n     0.48657095,  0.22897456, -0.        ,\n     0.26566769,  0.69173852,  0.04511338,\n     0.19821729,  0.07928691,  1.04394437\n);\nconst mat3 M_XYZ_TO_DISPLAY_P3 = mat3(\n     2.49349691, -0.82948897,  0.03584583,\n    -0.93138362,  1.76266406, -0.07617239,\n    -0.40271078,  0.02362469,  0.95688452\n);\n\nconst mat3 M_BT2020_TO_XYZ = mat3(\n    0.63695805, 0.26270021, 0.        ,\n    0.1446169 , 0.67799807, 0.02807269,\n    0.16888098, 0.05930172, 1.06098506\n);\nconst mat3 M_XYZ_TO_BT2020 = mat3(\n     1.71665119, -0.66668435,  0.01763986,\n    -0.35567078,  1.61648124, -0.04277061,\n    -0.25336628,  0.01576855,  0.94210312\n);\n\nconst mat3 M_DCI_P3_TO_XYZ = mat3(\n     0.44516982,  0.20949168, -0.        ,\n     0.27713441,  0.72159525,  0.04706056,\n     0.17228267,  0.06891307,  0.90735539\n);\nconst mat3 M_XYZ_TO_DCI_P3 = mat3(\n     2.72539403, -0.79516803,  0.04124189,\n    -1.01800301,  1.68973205, -0.08763902,\n    -0.4401632 ,  0.02264719,  1.10092938\n);\n\nvec3 linearSrgbToXyz(vec3 c) {\n    return M_SRGB_TO_XYZ * c;\n}\n\nvec3 xyzToLinearSrgb(vec3 c) {\n    return M_XYZ_TO_SRGB * c;\n}\n\n\n/*\n * CIELAB\n */\n\n\nfloat cielabF(float x) {\n    if (x > 216.0/24389.0) {\n        return cbrt(x);\n    } else {\n        return x / (108.0/841.0) + 4.0/29.0;\n    }\n}\n\nfloat cielabFInv(float x) {\n    if (x > 6.0/29.0) {\n        return cube(x);\n    } else {\n        return (108.0/841.0) * (x - 4.0/29.0);\n    }\n}\n\nvec3 xyzToCielab(vec3 c) {\n    float L = 116.0 * cielabF(c.y / D65.y) - 16.0;\n    float a = 500.0 * (cielabF(c.x / D65.x) - cielabF(c.y / D65.y));\n    float b = 200.0 * (cielabF(c.y / D65.y) - cielabF(c.z / D65.z));\n    return vec3(L, a, b);\n}\n\nvec3 cielabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float lp = (L + 16.0) / 116.0;\n    float x = D65.x * cielabFInv(lp + (a / 500.0));\n    float y = D65.y * cielabFInv(lp);\n    float z = D65.z * cielabFInv(lp - (b / 200.0));\n    return vec3(x, y, z);\n}\n\n\n/*\n * Oklab\n */\n\nvec3 xyzToOklab(vec3 c) {\n    float l = 0.8189330101 * c.x + 0.3618667424 * c.y - 0.1288597137 * c.z;\n    float m = 0.0329845436 * c.x + 0.9293118715 * c.y + 0.0361456387 * c.z;\n    float s = 0.0482003018 * c.x + 0.2643662691 * c.y + 0.6338517070 * c.z;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553f*l_ + 0.7936177850f*m_ - 0.0040720468f*s_,\n        1.9779984951f*l_ - 2.4285922050f*m_ + 0.4505937099f*s_,\n        0.0259040371f*l_ + 0.7827717662f*m_ - 0.8086757660f*s_\n    );\n}\n\nvec3 oklabToXyz(vec3 c) {\n    float L = c.x;\n    float a = c.y;\n    float b = c.z;\n\n    float l_ = L + 0.3963377774f * a + 0.2158037573f * b;\n    float m_ = L - 0.1055613458f * a - 0.0638541728f * b;\n    float s_ = L - 0.0894841775f * a - 1.2914855480f * b;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    return vec3(\n        +1.2270138511 * l - 0.5577999807 * m + 0.2812561490 * s,\n        -0.0405801784 * l + 1.1122568696 * m - 0.0716766787 * s,\n        -0.0763812845 * l - 0.4214819784 * m + 1.5861632204 * s\n    );\n}\n\nvec3 linearSrgbToOklab(vec3 c) {\n    return xyzToOklab(linearSrgbToXyz(c));\n}\n\nvec3 oklabToLinearSrgb(vec3 c) {\n    return xyzToLinearSrgb(oklabToXyz(c));\n}\n\n\n/*\n * Oklab gamut clipping\n */\n\n/*\n * Ported from the original C/C++ implementation:\n *\n * Copyright (c) 2021 Bjrn Ottosson\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328f * a - 0.80936493f * b > 1.0)\n    {\n        // Red component\n        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n    }\n    else if (1.81444104f * a - 1.19445276f * b > 1.0)\n    {\n        // Green component\n        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n        wl = -1.2681437731f; wm = +2.6097574011f; ws = -0.3413193965f;\n    }\n    else\n    {\n        // Blue component\n        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    float k_l = +0.3963377774f * a + 0.2158037573f * b;\n    float k_m = -0.1055613458f * a - 0.0638541728f * b;\n    float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n    {\n        float l_ = 1.f + S * k_l;\n        float m_ = 1.f + S * k_m;\n        float s_ = 1.f + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.f * k_l * l_ * l_;\n        float m_dS = 3.f * k_m * m_ * m_;\n        float s_dS = 3.f * k_s * s_ * s_;\n\n        float l_dS2 = 6.f * k_l * k_l * l_;\n        float m_dS2 = 6.f * k_m * k_m * m_;\n        float s_dS2 = 6.f * k_s * k_s * s_;\n\n        float f  = wl * l     + wm * m     + ws * s;\n        float f1 = wl * l_dS  + wm * m_dS  + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1*f1 - 0.5f * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklabToLinearSrgb(vec3( 1.0, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by\n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cuspC - (cuspL - L0) * C1) <= 0.f)\n    {\n        // Lower half\n\n        t = cuspC * L0 / (C1 * cuspL + cuspC * (L0 - L1));\n    }\n    else\n    {\n        // Upper half\n\n        // First intersect with triangle\n        t = cuspC * (L0 - 1.f) / (C1 * (cuspL - 1.f) + cuspC * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774f * a + 0.2158037573f * b;\n            float k_m = -0.1055613458f * a - 0.0638541728f * b;\n            float k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.f - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.0;\n                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2681437731f * l + 2.6097574011f * m - 0.3413193965f * s - 1.0;\n                float g1 = -1.2681437731f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n                float g2 = -1.2681437731f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.0;\n                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.f ? t_r : FLT_MAX;\n                t_g = u_g >= 0.f ? t_g : FLT_MAX;\n                t_b = u_b >= 0.f ? t_b : FLT_MAX;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nvec3 gamut_clip_preserve_lightness(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float L0 = cuspL;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5f;\n    float e1 = 0.5f + abs(Ld) + alpha * C;\n    float L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linearSrgbToOklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001f;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n    float cuspL = cusp.x;\n    float cuspC = cusp.y;\n\n    float Ld = L - cuspL;\n    float k = 2.f * (Ld > 0.0 ? 1.f - cuspL : cuspL);\n\n    float e1 = 0.5f*k + abs(Ld) + alpha * C/k;\n    float L0 = cuspL + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.f - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\n\n/*\n * ZCAM (JCh values)\n */\n\nconst float B = 1.15;\nconst float G = 0.66;\nconst float C1 = 3424.0 / 4096.0;\nconst float C2 = 2413.0 / 128.0;\nconst float C3 = 2392.0 / 128.0;\nconst float ETA = 2610.0 / 16384.0;\nconst float RHO = 1.7 * 2523.0 / 32.0;\nconst float EPSILON = 3.7035226210190005e-11;\n\nconst float SURROUND_DARK = 0.525;\nconst float SURROUND_DIM = 0.59;\nconst float SURROUND_AVERAGE = 0.69;\n\nstruct ZcamViewingConditions {\n    // Given\n    float F_s;\n    float L_a;\n    float Y_b;\n    vec3 refWhite;\n    float whiteLuminance;\n\n    // Calculated\n    float F_b;\n    float F_l;\n    float refWhiteIz;\n};\n\nfloat pq(float x) {\n    float num = C1 + C2 * pow(x / 10000.0, ETA);\n    float denom = 1.0 + C3 * pow(x / 10000.0, ETA);\n\n    return pow(num / denom, RHO);\n}\n\nfloat pqInv(float x) {\n    float num = C1 - pow(x, 1.0/RHO);\n    float denom = C3*pow(x, 1.0/RHO) - C2;\n\n    return 10000.0 * pow(num / denom, 1.0/ETA);\n}\n\nvec3 xyzToIzazbz(vec3 c) {\n    float xp = B*c.x - (B-1.0)*c.z;\n    float yp = G*c.y - (G-1.0)*c.x;\n\n    float rp = pq( 0.41478972*xp + 0.579999*yp + 0.0146480*c.z);\n    float gp = pq(-0.20151000*xp + 1.120649*yp + 0.0531008*c.z);\n    float bp = pq(-0.01660080*xp + 0.264800*yp + 0.6684799*c.z);\n\n    float az = 3.524000*rp + -4.066708*gp +  0.542708*bp;\n    float bz = 0.199076*rp +  1.096799*gp + -1.295875*bp;\n    float Iz = gp - EPSILON;\n\n    return vec3(Iz, az, bz);\n}\n\nfloat hpToEz(float hp) {\n    return 1.015 + cos(degreesToRadians(89.038 + hp));\n}\n\nfloat izToQz(float Iz, ZcamViewingConditions cond) {\n    return 2700.0 * pow(Iz, (1.6 * cond.F_s) / pow(cond.F_b, 0.12)) *\n            (pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2));\n}\n\nZcamViewingConditions createZcamViewingConditions(float F_s, float L_a, float Y_b, vec3 refWhite, float whiteLuminance) {\n    float F_b = sqrt(Y_b / refWhite.y);\n    float F_l = 0.171 * cbrt(L_a) * (1.0 - exp(-48.0/9.0 * L_a));\n    float refWhiteIz = xyzToIzazbz(refWhite).x;\n\n    return ZcamViewingConditions(\n        F_s, L_a, Y_b, refWhite, whiteLuminance,\n        F_b, F_l, refWhiteIz\n    );\n}\n\nstruct Zcam {\n    float brightness;\n    float lightness;\n    float colorfulness;\n    float chroma;\n    float hueAngle;\n    /* hue composition is not implemented */\n\n    float saturation;\n    float vividness;\n    float blackness;\n    float whiteness;\n\n    ZcamViewingConditions cond;\n};\n\nZcam xyzToZcam(vec3 c, ZcamViewingConditions cond) {\n    /* Step 2 */\n    // Achromatic response\n    vec3 izazbz = xyzToIzazbz(c);\n    float Iz = izazbz.x;\n    float az = izazbz.y;\n    float bz = izazbz.z;\n    float Iz_w = cond.refWhiteIz;\n\n    /* Step 3 */\n    // Hue angle\n    float hz = radiansToDegrees(atan2(bz, az));\n    float hp = (hz < 0.0) ? hz + 360.0 : hz;\n\n    /* Step 4 */\n    // Eccentricity factor\n    float ez = hpToEz(hp);\n\n    /* Step 5 */\n    // Brightness\n    float Qz = izToQz(Iz, cond);\n    float Qz_w = izToQz(cond.refWhiteIz, cond);\n\n    // Lightness\n    float Jz = 100.0 * (Qz / Qz_w);\n\n    // Colorfulness\n    float Mz = 100.0 * pow(square(az) + square(bz), 0.37) *\n            ((pow(ez, 0.068) * pow(cond.F_l, 0.2)) /\n                    (pow(cond.F_b, 0.1) * pow(Iz_w, 0.78)));\n    \n    // Chroma\n    float Cz = 100.0 * (Mz / Qz_w);\n\n    /* Step 6 */\n    // Saturation\n    float Sz = 100.0 * pow(cond.F_l, 0.6) * sqrt(Mz / Qz);\n\n    // Vividness, blackness, whiteness\n    float Vz = sqrt(square(Jz - 58.0) + 3.4 * square(Cz));\n    float Kz = 100.0 - 0.8 * sqrt(square(Jz) + 8.0 * square(Cz));\n    float Wz = 100.0 - sqrt(square(100.0 - Jz) + square(Cz));\n\n    return Zcam(\n        Qz,\n        Jz,\n        Mz,\n        Cz,\n        hp,\n\n        Sz,\n        Vz,\n        Kz,\n        Wz,\n\n        cond\n    );\n}\n\nvec3 zcamToXyz(vec3 c, ZcamViewingConditions cond) {\n    float Jz = c.x;\n    float Cz = c.y;\n    float hz = c.z;\n\n    float Iz_w = cond.refWhiteIz;\n    float Qz_w = izToQz(Iz_w, cond);\n\n    /* Step 1 */\n    // Achromatic response\n    float Iz_denom = 2700.0 * pow(cond.F_s, 2.2) * pow(cond.F_b, 0.5) * pow(cond.F_l, 0.2);\n    float Iz_src = (Jz * Qz_w) / (Iz_denom * 100.0);\n    float Iz = pow(Iz_src, pow(cond.F_b, 0.12) / (1.6 * cond.F_s));\n\n    /* Step 2 */\n    // Chroma\n    /* skipped because we take Cz as input */\n\n    /* Step 3 is missing because hue composition is not supported */\n\n    /* Step 4 */\n    // ... and back to colorfulness\n    float Mz = (Cz * Qz_w) / 100.0;\n    float ez = hpToEz(hz);\n    float Cz_p = pow((Mz * pow(Iz_w, 0.78) * pow(cond.F_b, 0.1)) /\n            // Paper specifies pow(1.3514) but this extra precision is necessary for more accurate inversion\n            (100.0 * pow(ez, 0.068) * pow(cond.F_l, 0.2)), 1.0 / 0.37 / 2.0);\n    float az = Cz_p * cos(degreesToRadians(hz));\n    float bz = Cz_p * sin(degreesToRadians(hz));\n\n    /* Step 5 */\n    float I = Iz + EPSILON;\n\n    float r = pqInv(I + 0.2772100865*az +  0.1160946323*bz);\n    float g = pqInv(I);\n    float b = pqInv(I + 0.0425858012*az + -0.7538445799*bz);\n\n    float xp =  1.9242264358*r + -1.0047923126*g +  0.0376514040*b;\n    float yp =  0.3503167621*r +  0.7264811939*g + -0.0653844229*b;\n    float z  = -0.0909828110*r + -0.3127282905*g +  1.5227665613*b;\n\n    float x = (xp + (B - 1.0)*z) / B;\n    float y = (yp + (G - 1.0)*x) / G;\n\n    return vec3(x, y, z);\n}\n\nvec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 xyzAbs = zcamToXyz(jch, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\nconst float ZCAM_CHROMA_EPSILON = 0.0001;\nconst bool CLIP_ZCAM = false;\nvec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {\n    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);\n    if (linearSrgbInGamut(initialResult)) {\n        return initialResult;\n    }\n\n    float lightness = jch.r;\n    float chroma = jch.g;\n    float hue = jch.b;\n    if (lightness <= ZCAM_CHROMA_EPSILON) {\n        return vec3(0.0);\n    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {\n        return vec3(1.0);\n    }\n\n    float lo = 0.0;\n    float hi = chroma;\n\n    vec3 newLinearSrgb = initialResult;\n    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {\n        float mid = (lo + hi) / 2.0;\n\n        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);\n        if (!linearSrgbInGamut(newLinearSrgb)) {\n            hi = mid;\n        } else {\n            float mid2 = mid + ZCAM_CHROMA_EPSILON;\n\n            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);\n            if (linearSrgbInGamut(newLinearSrgb2)) {\n                lo = mid;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return newLinearSrgb;\n}\n\n\n/*\n * Theme generation\n */\n\nconst float OKLAB_ACCENT1_CHROMA = 0.1328123146401862;\nconst float OKLAB_LIGHTNESS_MAP[13] = float[](\n    1.0,\n    0.9880873963836093,\n    0.9551400440214246,\n    0.9127904082618294,\n    0.8265622041716898,\n    0.7412252673769428,\n    0.653350946076347,\n    0.5624050605208273,\n    0.48193149058901036,\n    0.39417829080418526,\n    0.3091856317280812,\n    0.22212874192541768,\n    0.0\n);\n\nconst float ZCAM_ACCENT1_CHROMA = 20.54486422; // careful!\nconst float ZCAM_ACCENT1_COLORFULNESS = 36.47983487;\nconst float ZCAM_LIGHTNESS_MAP[13] = float[](\n    100.00000296754273,\n    98.60403974009428,\n    94.72386350388908,\n    89.69628870011267,\n    79.3326296037671,\n    68.938947819272,\n    58.15091644790415,\n    46.991689840263206,\n    37.24709908558773,\n    26.96785892507836,\n    17.67571012446932,\n    9.36696155986009,\n    0.0\n);\n\nconst float CIELAB_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    49.6,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst float ZCAM_LINEAR_LIGHTNESS_MAP[13] = float[](\n    100.0,\n    99.0,\n    95.0,\n    90.0,\n    80.0,\n    70.0,\n    60.0,\n    50.0,\n    40.0,\n    30.0,\n    20.0,\n    10.0,\n    0.0\n);\n\nconst int REF_ACCENT1_COLOR_COUNT = 9;\nconst int REF_ACCENT1_COLORS[9] = int[](\n    0xd3e3fd,\n    0xa8c7fa,\n    0x7cacf8,\n    0x4c8df6,\n    0x1b6ef3,\n    0x0b57d0,\n    0x0842a0,\n    0x062e6f,\n    0x041e49\n);\n\nconst float SWATCH_CHROMA_SCALES[5] = float[](\n    1.0, // accent1\n    1.0 / 3.0, // accent2\n    (1.0 / 3.0) * 2.0, // accent3\n    1.0 / 8.0, // neutral1\n    1.0 / 5.0 // neutral2\n);\n\nvec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {\n    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];\n    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];\n    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);\n    float chroma = targetChroma * scaleC * chromaFactor;\n    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;\n\n    return vec3(lightness, chroma, hue);\n}\n\nvec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));\n    float lightness = xyzToOklab(cielabXyz).x;\n\n    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nZcamViewingConditions getZcamCond() {\n    float whiteLuminance = SRGB_WHITE_LUMINANCE;\n\n    // Dynamic luminance for testing\n    //whiteLuminance = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n\n    float dynVal1 = (iMouse.x / iResolution.x) * whiteLuminance;\n    float dynVal2 = (iMouse.y / iResolution.y) * whiteLuminance;\n\n    ZcamViewingConditions cond = createZcamViewingConditions(\n        /* surround */ SURROUND_AVERAGE,\n        /* L_a */ 0.4 * whiteLuminance,\n        /* Y_b */ cielabToXyz(vec3(50.0, 0.0, 0.0)).y * whiteLuminance,\n        /* ref white */ D65 * whiteLuminance,\n        /* white luminance */ whiteLuminance\n    );\n\n    return cond;\n}\n\nvec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    float cielabL = CIELAB_LIGHTNESS_MAP[shade];\n    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;\n    float lightness = xyzToZcam(cielabXyz, cond).lightness;\n\n    // Calculate accent1 chroma given the viewing conditions\n    float chromaAcc = 0.0;\n    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {\n        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;\n        Zcam zcam = xyzToZcam(xyzAbs, cond);\n        chromaAcc += zcam.chroma;\n    }\n    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);\n\n    // For constant values\n    //lightness = ZCAM_LIGHTNESS_MAP[shade];\n    //avgChroma = ZCAM_ACCENT1_CHROMA;\n    // For linear shade lightness in ZCAM\n    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];\n\n    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\nvec3 getThemeColor(vec2 uv, float hue) {\n    int shadeIdx = int(uv.x * 13.0);\n    int swatchIdx = int((1.0 - uv.y) * 5.0);\n    float seedChroma = 1000000.0;\n\n    if (shadeIdx == 0) {\n        return vec3(1.0);\n    } else if (shadeIdx == 12) {\n        return vec3(0.0);\n    }\n\n    if (iMouse.z > 0.0) {\n        return gamut_clip_preserve_lightness(generateShadeOklab(swatchIdx, shadeIdx, seedChroma, hue, 1.0));\n    } else {\n        return generateShadeZcam(swatchIdx, shadeIdx, seedChroma, hue, 1.0);\n    }\n}\n\n\n/*\n * Color space interfaces\n */\n\nvec3 getColorOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness, rawChroma, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getColorCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getColorZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 jch = vec3(rawLightness * 100.0, rawChroma * 170.0, hue);\n\n    if (CLIP_ZCAM) {\n        return clipZcamJchToLinearSrgb(jch, cond);\n    } else {\n        return zcamJchToLinearSrgb(jch, cond);\n    }\n}\n\n\nvec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma, 0.0, hue);\n    vec3 oklab = lchToLab(lch);\n    return oklabToLinearSrgb(oklab);\n}\n\nvec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {\n    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);\n    vec3 cielab = lchToLab(lch);\n    return xyzToLinearSrgb(cielabToXyz(cielab));\n}\n\nvec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);\n\n    vec3 xyzAbs = zcamToXyz(zcam, cond);\n    vec3 xyzRel = xyzAbs / cond.whiteLuminance;\n    return xyzToLinearSrgb(xyzRel);\n}\n\n\n/*\n * Blending\n */\n\nvec3 blendZcam(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    ZcamViewingConditions cond = getZcamCond();\n\n    Zcam lhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(lhsRgb)) * cond.whiteLuminance, cond);\n    Zcam rhs = xyzToZcam(linearSrgbToXyz(srgbTransferInv(rhsRgb)) * cond.whiteLuminance, cond);\n\n    vec3 lhsJch = vec3(lhs.lightness, lhs.chroma, lhs.hueAngle);\n    vec3 rhsJch = vec3(rhs.lightness, rhs.chroma, lhs.hueAngle);\n    return clipZcamJchToLinearSrgb(mix(lhsJch, rhsJch, uv.x), cond);\n}\n\nvec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    vec3 lhs = srgbTransferInv(lhsRgb);\n    vec3 rhs = srgbTransferInv(rhsRgb);\n\n    return srgbTransfer(mix(lhs, rhs, uv.x));\n}\n\nvec3 blendSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {\n    return mix(lhsRgb, rhsRgb, uv.x);\n}\n\n\n/*\n * Main\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // NDC (0-1)\n\n    float rawLightness = uv.y;\n    float rawChroma = uv.x;\n    float hue = mod(iTime * HUE_RATE, 360.0); // degrees\n    //hue = 286.66117416556847;\n    vec3 camOut;\n\n    // Rainbow\n    //rawLightness = 0.7502;\n    //rawChroma = 0.138;\n    //hue = uv.x * 360.0;\n\n    // Gamut/cusp animation\n    if (iMouse.z > 0.0) {\n        camOut = getColorOklab(rawLightness, rawChroma, hue);\n        //camOut = gamut_clip_preserve_lightness(camOut);\n    } else {\n        camOut = getColorZcam(rawLightness, rawChroma, hue);\n    }\n\n    // Lightness ramp\n    /*if (iMouse.z > 0.0) {\n        camOut = getLightnessOklab(rawLightness, rawChroma, hue);\n    } else {\n        camOut = getLightnessZcam(rawLightness, rawChroma, hue);\n    }*/\n\n    // Theme generation\n    //camOut = getThemeColor(uv, hue);\n\n    // Chroma contrast\n    /*int testSwatch = 3; // neutral1\n    int testShade = 11; // 900\n    testShade = 4; // 200\n    testSwatch = 0; // accent1\n    if (uv.x > 0.5) {\n        ZcamViewingConditions cond = getZcamCond();\n        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(rgb8ToFloat(0x533b79))) * cond.whiteLuminance;\n        Zcam seed = xyzToZcam(xyzAbs, cond);\n        camOut = generateShadeZcam(testSwatch, testShade, seed.chroma, seed.hueAngle, 1.0);\n    } else {\n        testSwatch = 3;\n        testShade = 11;\n        camOut = generateShadeZcam(testSwatch, testShade, 0.0, 0.0, 1.0);\n    }*/\n\n    // Blending\n    /*if (uv.y >= 0.5) {\n        camOut = blendZcam(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    } else {\n        camOut = blendSrgb(uv, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    }*/\n\n    // Oklab gamut clipping\n    //camOut = gamut_clip_preserve_lightness(camOut);\n    //camOut = gamut_clip_project_to_0_5(camOut);\n    //camOut = gamut_clip_project_to_L_cusp(camOut);\n    //camOut = gamut_clip_adaptive_L0_0_5(camOut, 0.05);\n    //camOut = gamut_clip_adaptive_L0_L_cusp(camOut, 0.05);\n\n    // Simple RGB clipping (also necessary after gamut clipping)\n    //camOut = clamp(camOut, 0.0, 1.0);\n\n    if (linearSrgbInGamut(camOut)) {\n        vec3 dither = texture(iChannel0, uv * (iResolution.xy / 64.0)).rgb * 2.0 - 1.0;\n        dither = sign(dither) * (1.0 - sqrt(1.0 - abs(dither))) / 64.0;\n        fragColor = vec4(srgbTransfer(camOut) + dither, 1.0);\n    } else {\n\t    vec2 fontSize = vec2(16.0, 30.0);\n        float digit = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, hue, 3.0, 0.0);\n        fragColor = vec4(vec3(0.5) + digit, 1.0);\n    }\n\n    // Print dynamic sRGB white luminance\n    /*\n    float whiteL = pow(10.0, (iMouse.x / iResolution.x) * (log(SRGB_WHITE_LUMINANCE_DYN_MAX) / log(10.0)));\n    vec2 fontSize = vec2(16.0, 30.0);\n    float digit2 = PrintValue((fragCoord - vec2(iResolution.x - 80.0, 10.0)) / fontSize, whiteL, 3.0, 0.0);\n    fragColor = vec4(fragColor.rgb + digit2, 1.0);\n    */\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsd3R2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1447, 1447, 1480, 1480, 1509], [1511, 1511, 1544, 1544, 1573], [1575, 1575, 1606, 1606, 1690], [1692, 1692, 1713, 1713, 1760], [1762, 1762, 1785, 1785, 1805], [1807, 1807, 1828, 1828, 1852], [1854, 1854, 1878, 1878, 1968], [2147, 2147, 2178, 2178, 2336], [2338, 2338, 2432, 2432, 3544], [3615, 3615, 3638, 3638, 3849], [3851, 3851, 3874, 3874, 4052], [4071, 4071, 4098, 4098, 4283], [4285, 4285, 4315, 4315, 4494], [4496, 4496, 4528, 4528, 4594], [4596, 4596, 4623, 4623, 4654], [4656, 4656, 4681, 4681, 4817], [6255, 6255, 6285, 6285, 6317], [6319, 6319, 6349, 6349, 6381], [6403, 6403, 6427, 6427, 6546], [6548, 6548, 6575, 6575, 6691], [6693, 6693, 6719, 6719, 6936], [6938, 6938, 6964, 6964, 7227], [7247, 7247, 7272, 7272, 7791], [7793, 7793, 7818, 7818, 8344], [8346, 8346, 8378, 8378, 8423], [8425, 8425, 8457, 8457, 8502], [9711, 9875, 9923, 10081, 12107], [12109, 12200, 12234, 12297, 12674], [12676, 12814, 12893, 12936, 15967], [15969, 15969, 16015, 16015, 16585], [16587, 16587, 16629, 16629, 17184], [17186, 17186, 17231, 17231, 17992], [17994, 17994, 18050, 18050, 18725], [18727, 18727, 18786, 18786, 19737], [20350, 20350, 20369, 20369, 20507], [20509, 20509, 20531, 20531, 20663], [20665, 20665, 20691, 20691, 21137], [21139, 21139, 21163, 21163, 21220], [21222, 21222, 21274, 21274, 21422], [21424, 21424, 21545, 21545, 21821], [22110, 22110, 22162, 22206, 23442], [23444, 23444, 23496, 23496, 25007], [25009, 25009, 25073, 25073, 25199], [25273, 25273, 25341, 25341, 26380], [28004, 28004, 28129, 28129, 28517], [28519, 28519, 28620, 28620, 28955], [28957, 28957, 28994, 28994, 29658], [29660, 29660, 29760, 29760, 30886], [30888, 30888, 30928, 30928, 31395], [31432, 31432, 31500, 31500, 31622], [31624, 31624, 31693, 31693, 31844], [31846, 31846, 31913, 31913, 32170], [32173, 32173, 32245, 32245, 32358], [32360, 32360, 32433, 32433, 32567], [32569, 32569, 32640, 32640, 32868], [32891, 32891, 32942, 32942, 33385], [33387, 33387, 33444, 33444, 33573], [33575, 33575, 33626, 33626, 33666], [33685, 33685, 33740, 33740, 36644]]}
{"id": "7dcGz2", "name": "Cellular automata life simulator", "author": "Skele7on1250", "description": "cellular automata with keyboard/mouse controll. GUIDE TO CONTROL IN\"Common\"  FILE", "tags": ["cellularautomata", "lifesimulator"], "likes": 3, "viewed": 313, "published": 3, "date": "1630226640", "time_retrieved": "2024-07-30T19:04:18.659190", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define Key_R 82.\n#define Key_C 67.\n#define Key_G 71.\n#define Key_E 69.\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel2, uv).r;\n\n        return key > 0.0;\n}\nbool isToggled(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.75);\n        float key = texture(iChannel2, uv).r;\n\n        return key > 0.0;\n}\nbool isKeyDown(float keyCode){\n    return(texelFetch( iChannel2, ivec2(keyCode, 0),0 ).x==1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int sizeOfCell=10;\n    vec3 col;\n    \n    col=texture(iChannel0,uv).rgb;\n    \n    \n    if(isToggled(Key_E)){\n       col=texture(iChannel3,uv).rgb;\n    }\n    if(isKeyDown(Key_R)||iTime<=0.5f){\n         col=texture(iChannel1,uv).rgb;\n    }\n    if(isKeyDown(Key_C)){\n        col=vec3(0,0,0);\n    }\n    \n    if(!isToggled(Key_G)&&((int(fragCoord.x)%sizeOfCell==0&&fragCoord.x>1.)||(int(fragCoord.y)%sizeOfCell==0&&fragCoord.y>1.))){\n        col=Color(uv,iTime);\n    }\n    else if(((int(fragCoord.x)%sizeOfCell==0&&fragCoord.x>1.)||(int(fragCoord.y)%sizeOfCell==0&&fragCoord.y>1.))){\n        col=vec3(0,0,0);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int sizeOfCell=10;\n    vec3 col=texture(iChannel0,uv).rgb;\n    vec2 coord=vec2(int(fragCoord.x)/sizeOfCell+1,int(fragCoord.y)/sizeOfCell+1);\n    int cnt=0;\n    \n    for(int i=0;i<=8;i++){\n        int posx,posy;\n        if(i%3==0){\n            posx=-1;\n        }\n        else if((i+1)%3==0){\n            posx=1;\n        }\n        else{\n            posx=0;\n        }\n        if(i>=6){\n            posy=1;\n        }\n        else if(i<=2){\n            posy=-1;\n        }\n        else{\n            posy=0;\n        }\n        \n        vec2 newCoord=coord+vec2(posx,posy);\n        if(i!=4&&(texture(iChannel0,(newCoord*float(sizeOfCell)-vec2(1,1))/iResolution.xy).rgb!=vec3(0,0,0))&&newCoord.x>=0.&&newCoord.y>=0.){\n            cnt+=1;\n            //col=normalize(vec3(newCoord*float(sizeOfCell)/iResolution.xy,1.));\n        }\n        \n    }\n    if(cnt==3&&col==vec3(0,0,0)){\n        col=Color(uv,iTime);\n    }\n    else if(cnt>=2&&cnt<=3&&col!=vec3(0,0,0)){\n        col=Color(uv,iTime);\n    }\n    else if(cnt<2||cnt>3){\n        col=vec3(0,0,0);\n    }\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nControl\nToggle Key E - edit field (LMB to create/delete cell)\nToggle Key G - enable/disable grid\nPress Key C - clear field\nPress Key R - randomize field\n\n\n\n\n*/\n\n\n\n\n\nvec3 Color( vec2 uv , float iTime )\n{\n    return 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n}\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int sizeOfCell=10; \n    vec3 col=vec3(0,0,0);\n    vec2 coord=vec2(int(fragCoord.x)/sizeOfCell,int(fragCoord.y)/sizeOfCell);\n    if(rand(coord*iTime*float(iFrame))>=0.5f){\n        col=Color(uv,iTime);\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_c_inputs": [], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int sizeOfCell=10; \n    vec2 coord=vec2(int(fragCoord.x)/sizeOfCell,int(fragCoord.y)/sizeOfCell);\n    vec3 col=texture(iChannel0,uv).rgb;\n    if(vec2(int(iMouse.x)/sizeOfCell,int(iMouse.y)/sizeOfCell)==coord&&(iMouse.w>0.)){\n        if(col==vec3(0,0,0)){\n            col=Color(uv,iTime);\n        }\n        else{\n            col=vec3(0,0,0);\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 113, 290]]}
{"id": "fdt3zj", "name": "Infinite spider web", "author": "sunhokim", "description": "Spider web!", "tags": ["procedual", "spider"], "likes": 9, "viewed": 425, "published": 3, "date": "1630215030", "time_retrieved": "2024-07-30T19:04:19.573745", "image_code": "// golfed version by FabriceNeyret2 (208 chars)\nvoid mainImage( out vec4 O,  vec2 p )\n{   \n    vec2  R = iResolution.xy;\n    float l = length( p -= .5 * R ) / R.y,\n          a = atan(p.y,p.x);\n\n\tO =     .3 * l \n        + ( .01 + .006 / ( 1.  + sin( 6.*l - 3.*iTime ) *.8 ) ) \n          / abs(  sin( 15.*a) \n                * sin( l*l*l*27. -1.5*iTime - a*.5 - l ) \n                * sin( l*2.7 ) \n               ) - O;\n}\n\n// golfed version by FabriceNeyret2 (218 chars)\n/*\nvoid mainImage( out vec4 O,  vec2 p )\n{   \n    vec2  R = iResolution.xy;\n    float l = length( p -= .5 * R ) / R.y,\n          a = atan(p.y,p.x);\n\n\tO =     .3 * l \n        + ( .01 + .03 / ( 1.  + sin( 6.*l - 3.*iTime ) *.8 ) / vec4(5,5,4,1) ) \n          / abs(  sin( 15.*a) \n                * sin( l*l*l*27. -1.5*iTime - a*.5 - l ) \n                * sin( l*2.7 ) \n               );\n}\n*/\n\n// original\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 p = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    float r = length(p)*3.0;\n    float a = atan(p.y,p.x);\n    float r2 = a*0.5+length(p);\n    vec3 color = vec3(0.1)*r;\n    float web = sin(15.0*a)*sin(pow(r, 3.0)-r2-1.5*iTime)*sin(r*0.9);\n    float ww = (abs(1.0 / (web * 30.7)) - 0.01);\n    float ww2 = (abs(1.0 / (web * (30.7-sin(-r*2.0+3.0*iTime)*25.0))) - 0.04);\n    color += vec3(0.3)*ww;\n    color += vec3(0.2,0.2,0.25)*ww2;\n\tfragColor = vec4(color, 1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 48, 87, 87, 420]]}
{"id": "NsdGRj", "name": "video test 01", "author": "J450N", "description": "I guess JCVD finds a glitch in the matrix", "tags": ["hmm"], "likes": 3, "viewed": 334, "published": 3, "date": "1630208830", "time_retrieved": "2024-07-30T19:04:20.531185", "image_code": "float threshold = 0.55;\nfloat padding = 0.05;\n\n\n\n\n\n\nvec4 background (vec2 uv)\n{\n    vec4 color = vec4(1.0,1.0,1.0,1.0);\n    \n    color.r = uv.x;\n    color.g = uv.y;\n    \n    float t1 = sin( iTime * 10.20 ) * 0.05;\n    \n    float scale = 1.50;\n    \n    int maxIter = 8;\n\n    for (int i = 0; i < maxIter; i++)\n    {\n        float t = (float(i) / float(maxIter));\n        \n    \n        color.r *= 1.0 + (sin (uv.x * iTime * scale) + (0.15 * t));\n        color.g *= 1.0 + (sin (uv.y * iTime * scale) + (0.15 * t));\n        color.b *= 1.0 + (sin ( sin(uv.x + uv.y) * iTime * scale) + 0.05);\n        \n        color.r += atan (color.g) * t * t1;\n        color.g += atan (color.b) * t * t1;\n        color.b += atan (color.r) * t * t1;\n        \n        color.r -= sin (color.b) * 100.25 * t1 * t;\n        color.g -= sin (color.r) * 50.25 * t1 * t;\n        color.b -= sin (color.g) * 10.25 * t1 * t;\n        \n        \n        uv.x += 10.1 * t;\n        uv.y += 10.1 * t;\n        \n        float r = sqrt(pow(uv.x, 2.0) + pow(uv.y, 2.0)) * (1.0 + t);\n        float theta = atan(uv.y/ uv.x);\n        vec2 uv3 = vec2( r * sin(theta), r * cos(theta));\n        \n        color.r *= 1.0 + (sin (uv3.x * iTime * 0.05) + t1);\n        color.g *= 1.0 + (sin (uv3.y * iTime * 0.05) + t1);\n        color.b *= 1.0 + (sin (sin(uv3.x + uv3.y) * iTime * 0.05) + 0.05);\n        \n    }\n    \n\n    \n    \n    return color;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvOrig = uv;\n    \n\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\nfloat t1 = sin( iTime * 1.0 ) * 5.1;\nfloat t2 = sin( iTime * 10.0 ) * 8.1;\n\nint maxIter = 5;\n\n\n//---- loop through \nfor (int i = 0; i < maxIter; i++)\n{\n    float t = (float(i) / float(maxIter));\n    float uvScale = 1.0 + (t * 001.50) * t2;\n\n\n    vec2 uv2 = uv;\n    \n    vec4 tex = texture(iChannel0, uv2);\n    \n    uv2.x -= 0.5;\n    uv2.y -= 0.5;\n\n    uv2.x *= 1.0 + ((1.0 - tex.r) * 0.03 * uvScale);\n    uv2.y *= 1.0 + ((1.0 - tex.r) * 0.03 * uvScale);\n    \n    uv2.x *= 1.0 - ((1.0 - tex.r) * 0.01 * uvScale);\n    uv2.y *= 1.0 - ((1.0 - tex.r) * 0.01 * uvScale);\n\n\n    uv2.x += 0.5;\n    uv2.y += 0.5;\n\n    uv = uv2;\n}\n\n\n\n\nvec2 finalUV = mix(uv, uvOrig, clamp(t2,0.0,0.5));\n\n\n\nvec4 color = texture(iChannel0, finalUV);\n\nvec4 greenScreen = vec4(0.0,1.0,0.0,1.0);\nvec4 black = vec4(0.0,0.0,0.0,1.0);\n\n\n\n\nvec3 diff = color.xyz - greenScreen.xyz;\nfloat fac = smoothstep(threshold-padding,threshold+padding, dot(diff,diff));\n\n\nfinalUV = mix(finalUV, uvOrig,  (1.0 - fac) + (finalUV) );\n\ncolor = mix(color, background(finalUV), 1.0 - fac);\n//color = mix(color, black, 1.0 - fac);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//fragColor = vec4(col * tex.xyz ,1.0);\nfragColor = vec4( color.xyz ,1.0);\n\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdGRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "fdt3Rj", "name": "Lightning algorithm", "author": "hippiman", "description": "Shader version of Matt Henderson's lightning algorithm from numberphile https://www.youtube.com/watch?v=akZ8JJ4gGLs", "tags": ["2d", "lightning", "numberphile"], "likes": 18, "viewed": 487, "published": 3, "date": "1630204740", "time_retrieved": "2024-07-30T19:04:21.564422", "image_code": "// Shader version of Matt Henderson's Lightning Algorithm from numberphile https://www.youtube.com/watch?v=akZ8JJ4gGLs\n// resize and try different seeds with constants after comment \"play with these\" in Common\n// random functions taken from other shadertoys (author next to functions in Common)\n\n// (doesn't work very well with fullscreen)\n\nivec2 getCoords(ivec2 q) {\n   return ivec2(((vec2(q) + vec2(.5,.5)) / SCALE * iResolution.y + iResolution.xy) / 2.);\n}\n\nvec4 old(ivec2 q) {\n  return texelFetch(iChannel0, getCoords(q), 0);\n}\n\nfloat squish(float s) {\n  return pow(s, iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n  vec2 s = uv * SCALE;\n  ivec2 q = ivec2(floor(s));\n  \n  int edges = getAllEdges(SEED, q);\n  bool isBottomEdge = mod(s.y, 1.) < EDGE_WIDTH && HAS_EDGE(BOTTOM_EDGE, edges);\n  bool isRightEdge = mod(s.x, 1.) > (1. - EDGE_WIDTH) && HAS_EDGE(RIGHT_EDGE, edges);\n  \n  vec3 col = vec3(1., 1., 0.) * squish(smoothstep((0.), (1.), (old(q).r / float(iFrame) * float(FPA))));\n  col = isBottomEdge || isRightEdge ? vec3(1.,0.,0.) : col;\n  \n\n  col = s.y < -(SCALE-EDGE_WIDTH) ? vec3(0., 1., 0.) : col;\n  col = old(q).g > 0. ? vec3(1., 1., 0.) : col;\n\n  fragColor = vec4(col, 1.);\n  \n  // show underlying Buffer A\n  // fragColor = old(q);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// rand/hash from iq:\n//------------------------------------------------------------------\n// oldschool rand() from Visual Studio\n//------------------------------------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n//------------------------------------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n//------------------------------------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n  return n * (n * n * 15731 + 789221) + 1376312589;\n}\nfloat fhash(int n, int w, ivec2 q) {\n   srand(hash(q.x + hash(q.y + hash(w + hash(n))))); return frand();\n}\n\n//------------------------------------------------------------------\n// play with these\n//------------------------------------------------------------------\n#define SCALE (iResolution.y/2.)\n#define EDGE_WIDTH 0.\n#define FPA 1\n#define SEED 1\n#define LR_P .5\n#define TB_P .4\n//------------------------------------------------------------------\n//------------------------------------------------------------------\n\n// other constants\n#define TOP_EDGE 1\n#define RIGHT_EDGE 2\n#define BOTTOM_EDGE 4\n#define LEFT_EDGE 8\n\n#define HAS_EDGE(W, E) ((E & W) > 0)\n\nint getAllEdges(int seed, ivec2 q) {\n  return (fhash(seed, BOTTOM_EDGE, q) < TB_P ? BOTTOM_EDGE : 0)\n   | (fhash(seed, RIGHT_EDGE, q) < LR_P ? RIGHT_EDGE : 0)\n   | (fhash(seed, BOTTOM_EDGE, q + ivec2(0, 1)) < TB_P ? TOP_EDGE : 0)\n   | (fhash(seed, RIGHT_EDGE, q + ivec2(-1, 0)) < LR_P ? LEFT_EDGE : 0);\n}\n", "buffer_a_code": "ivec2 getCoords(ivec2 q) {\n   return ivec2(((vec2(q) + vec2(.5,.5)) / SCALE * iResolution.y + iResolution.xy) / 2.);\n}\n\nvec4 old(ivec2 q) {\n  return texelFetch(iChannel0, getCoords(q), 0);\n}\n\nvec3 neighbor(vec4 self, bool cond, ivec2 q, float m, vec3 f) {\n  vec4 old = old(q);\n  return cond && old.g > 0. && ((q.y < (-(int(SCALE)-1))) || self.r == old.r - 1.)\n    ? vec3(self.r, old.g + 1., 0.)\n    : cond && old.r > 0. \n      ? vec3(old.r+1., f.g, 0.) : f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n  vec2 s = uv * SCALE;\n  ivec2 q = ivec2(floor(s));\n  \n  int edges = getAllEdges(SEED, q);\n  bool isBottomEdge = mod(s.y, 1.) < .1 && HAS_EDGE(BOTTOM_EDGE, edges);\n  bool isRightEdge = mod(s.x, 1.) > .9 && HAS_EDGE(RIGHT_EDGE, edges);;\n  vec3 yellow = vec3(1., 0., 0.);\n  vec3 col = s.y > SCALE-1. && s.x > 0. && s.x < 1. ? yellow : vec3(0.);\n  \n  vec4 o = old(q);\n  bool hasOld = o.r > 0.;\n  if(iFrame % FPA == 0) {\n    col = neighbor(o, !HAS_EDGE(TOP_EDGE, edges), q+ivec2(0,1), 1., col);\n    col = neighbor(o, !HAS_EDGE(BOTTOM_EDGE, edges), q+ivec2(0,-1), 1., col);\n    col = neighbor(o, !HAS_EDGE(RIGHT_EDGE, edges), q+ivec2(1,0), 1., col);\n    col = neighbor(o, !HAS_EDGE(LEFT_EDGE, edges), q+ivec2(-1,0), 1., col);\n    col = hasOld ? vec3(o.r, col.gb) : col;\n    col = col.r > 0. && q.y < -int(SCALE)+1 ? vec3(0., 1., 0.) : col;\n  } else {\n    col = o.rgb;\n  }\n  \n  fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[341, 341, 367, 367, 459], [461, 461, 480, 480, 531], [533, 533, 556, 556, 590], [592, 592, 649, 649, 1338]]}
{"id": "sd33R2", "name": " ", "author": "unjello", "description": "Source for Oftenhide production - 4KiB executable moving picture \" \" aka \"Xenium Noir\", published at Xenium Demoparty 2021. 1st place, counting backwards :), in 4k intro competition.\n\nCode: Angelo", "tags": ["source", "exegfx"], "likes": 12, "viewed": 402, "published": 3, "date": "1630182872", "time_retrieved": "2024-07-30T19:04:22.913815", "image_code": "///   / oftenhide, a 4kib executable moving picture\n/// 1st place, counting backwards :) @ Xenium 2021\n/// License: CC0\n///\n/// Effects inspired by:\n/// Night Sneakings / crocidb: https://www.shadertoy.com/view/tlVXRz\n/// Neontoy / Flyguy: https://www.shadertoy.com/view/4sc3Wn\n/// Sound visualizer with hexagons / levonchic: https://www.shadertoy.com/view/wscfzX\n/// Lagomorph Noir / Soulman: https://www.pouet.net/prod.php?which=88672\n///\n/// <3 to all the authors, et al.\n///\n\n#define ZERO (min(iFrame, 0))\n#define DRAW_DISTANCE 25.\n#define AA  1\n#define SURFACE_DISTANCE 0.001\n\nfloat pi = atan(1.0)*4.;\nfloat epsilon = 1e-3;\nfloat infinity = 1e6;\n\nbool in_hexagon(vec2 p, vec2 pos, float d, float a) {\n    float x_ = pos.x - p.x;\n    float y_ = pos.y - p.y;\n    float s_ = sin(a);\n    float c_ = cos(a);\n    float dx = abs(x_ * c_ - y_ * s_)/d;\n    float dy = abs(x_ * s_ + y_ * c_)/d;\n    float ar = 0.25 * sqrt(3.0);\n    return (dy <= ar) && (ar * dx + 0.25 * dy <= 0.5 * ar);\n}\n\nvec4 render_background(vec2 fragCoord) {\n\tvec4 color = vec4(0., 0., 0., 1.);\n\tfloat grad = 1.0 - length(fragCoord - iResolution.xy / 2.0) / length(iResolution.xy) * 1.6;\n    color += grad / 3.0;\n\n    float d = 0.33 * iResolution.y;\n\tvec2 center = iResolution.xy / 2.0;\n\t\n\tfloat s = 1.0;\n\tfor (float i = 1.; i < 9.; i+=1.) {\n\t\tif(in_hexagon(fragCoord, center, d*i, (.4+i)*s)) {\n\t\t\tcolor += .025*s;\n\t\t}\n\t\ts *= -1.;\n\t}\n    return color*0.1;\n}\n\n\nfloat sdf_line(vec2 start, vec2 end, vec2 uv) {\n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\n\nfloat sdf_arc(vec2 origin, float start, float sweep, float radius, vec2 uv) { \n\tuv -= origin;\n\tuv *= mat2(cos(start), sin(start),-sin(start), cos(start));\n\n    float offs = (sweep / 2.0 - pi);\n    float ang = mod(atan(uv.y, uv.x) - offs, pi*2.) + offs;\n    ang = clamp(ang, min(0.0, sweep), max(0.0, sweep));\n\n    return distance(radius * vec2(cos(ang), sin(ang)), uv);\n}\n\n#define sdf_polygon(points, num_segments) for (int i = 0; i < num_segments*2; i+=2) { dist = min(dist, sdf_line(vec2(points[i], points[i+1]), vec2(points[i+2], points[i+3]), uv)); }\nfloat render_logo(vec2 uv) {\n\tfloat dist = infinity;\n    \n    sdf_polygon(float[8](0.,-.002,.053,-.057,.107,-.002,0.,-.002),3);\n    sdf_polygon(float[26](.319,.119,.42,-.002,.34,-.002,.279,.076,.216,.012,.135,.012,.239,.119,.071,.297,.151,.297,.279,.162,.326,.211,.406,.211,.319,.119),12);\n    sdf_polygon(float[10](.437,.262,.437,.333,.336,.226,.468,.226,.437,.262),4);\n    sdf_polygon(float[22](.596,.142,.383,.142,.434,.085,.447,.085,.447,.012,.577, .012,.577,.071,.499,.071,.499,.085,.545,.085,.596,.142),10);\n    sdf_polygon(float[10](.447,.213,.577,.213,.577,.152,.447,.152,.447,.213),4);\n    sdf_polygon(float[22](.662,.098,.662,.012,.608,.012,.608,.24,.662,.183,.715,.126,.715,.211,.769,.211,.769,-.015,.715,.041,.662,.098),10);\n    sdf_polygon(float[10](.796,.012,.796,.155,.85,.211,.85,.012,.796,.012),4);\n    sdf_polygon(float[6](1.065,.213,1.013,.213,1.013,.112),2);\n    sdf_polygon(float[14](.929,.112,.929,.212,.929,.225,.929,.295,.863,.225,.876,.214,.876,.112),6);\n    sdf_polygon(float[8](1.062,.112,1.062,.152,1.156,.213,1.065,.213),3);\n    sdf_polygon(float[48](1.25,.098,1.25,.24,1.198,.183,1.146,.126,1.093,.07,1.025,-.002,.779,-.002,.779,-.044,.742,-.002,.124,-.002,.07,-.06,1.053,-.06,1.146,.04,1.199,.098,1.199,-.044,1.253,.012,1.28,.041,1.333,.098,1.333,.012,1.384,.012,1.384,.24,1.333,.183,1.278,.126,1.25,.098),23);\n    sdf_polygon(float[10](1.4,.24,1.4,.185,1.477,.267,1.374,.267,1.4,.24),4);\n    sdf_polygon(float[8](1.436,.012,1.4,.051,1.4,.012,1.436,.012),3);\n    sdf_polygon(float[68](1.054,.303,1.06,.286,1.058,.277,1.053,.27,1.046,.266,1.04,.263,1.034,.262,1.028,.26,1.024,.256,1.022,.25,1.022,.236,1.058,.236,1.06,.234,1.06,.23,1.058,.227,1.015,.227,1.013,.23,1.013,.25,1.015,.26,1.02,.266,1.027,.27,1.033,.272,1.04,.274,1.046,.276,1.05,.28,1.051,.286,1.047,.296,1.038,.3,1.015,.3,1.013,.303,1.013,.306,1.015,.309,1.038,.309,1.054,.303),33);\n    sdf_polygon(float[44](1.082,.232,1.078,.245,1.078,.291,1.082,.304,1.095,.309,1.11,.309,1.123,.304,1.127,.291,1.127,.245,1.123,.232,1.11,.227,1.094,.227,1.118,.247,1.118,.289,1.116,.297,1.109,.3,1.096,.3,1.089,.297,1.087,.289,1.087,.247,1.089,.239,1.082,.232),21);\n    sdf_polygon(float[66](1.186,.303,1.192,.286,1.19,.277,1.185,.27,1.178,.266,1.171,.263,1.166,.262,1.16,.26,1.155,.256,1.154,.25,1.154,.236,1.189,.236,1.192,.234,1.192,.23,1.189,.227,1.147,.227,1.144,.23,1.144,.25,1.147,.26,1.152,.266,1.159,.27,1.165,.272,1.172,.274,1.177,.276,1.181,.28,1.183,.286,1.179,.296,1.17,.3,1.147,.3,1.144,.303,1.147,.309,1.17,.309,1.186,.303),32);\n    sdf_polygon(float[24](1.207,.3,1.205,.303,1.205,.306,1.207,.309,1.223,.309,1.225,.306,1.225,.23,1.223,.227,1.219,.227,1.216,.23,1.216,.3,1.207,.3),11);\n\n\tdist = min(dist, sdf_arc(vec2(0.971,0.112),3.14, 3.14, .041, uv));\n\tdist = min(dist, sdf_arc(vec2(0.969,0.112),3.14, 3.14, .093, uv));\n\treturn dist;\n}\n\nfloat render_border(vec2 uv) {\n    float dist = infinity;\n    \n\tdist = min(dist, sdf_line(vec2(0.027,0.422), vec2(1.488,0.422), uv));\n    dist = min(dist, sdf_line(vec2(0.027,0.4), vec2(0.772,0.4), uv));\n    dist = min(dist, sdf_line(vec2(0.827,0.4), vec2(1.488,0.4), uv));\n    dist = min(dist, sdf_line(vec2(-0.05,-.088), vec2(-0.016,0.355), uv));\n    dist = min(dist, sdf_line(vec2(-0.072,-.088), vec2(-0.038,0.355), uv));\n\tdist = min(dist, sdf_line(vec2(1.555,0.355), vec2(1.522,-0.138), uv));\n\tdist = min(dist, sdf_line(vec2(1.533,0.355), vec2(1.5,-0.138), uv));\n    dist = min(dist, sdf_line(vec2(1.455,-0.183), vec2(-.011,-0.133), uv));\n    dist = min(dist, sdf_line(vec2(1.455,-0.205), vec2(0.694,-0.180), uv));\n\tdist = min(dist, sdf_line(vec2(0.655,-0.180), vec2(-.011,-0.155), uv));\n    \n\n    dist = min(dist, sdf_arc(vec2(1.488,0.355),0.000, 1.571, 0.044, uv));\n    dist = min(dist, sdf_arc(vec2(1.488,0.355),0.000, 1.571, 0.066, uv));\n    dist = min(dist, sdf_arc(vec2(1.455,-0.138),4.712, 1.571, 0.044, uv));\n    dist = min(dist, sdf_arc(vec2(1.455,-0.138),4.712, 1.571, 0.066, uv));\n    dist = min(dist, sdf_arc(vec2(0.027,0.355),1.571, 1.571, 0.066, uv));\n    dist = min(dist, sdf_arc(vec2(0.027,0.355),1.571, 1.571, 0.044, uv));\n    dist = min(dist, sdf_arc(vec2(-0.005,-0.088),3.142, 1.571, 0.066, uv));\n    dist = min(dist, sdf_arc(vec2(-0.005,-0.088),3.142, 1.571, 0.044, uv));\n    \n    return dist;\n}\n\nvec3 render_neon(vec2 uv) {\n\tuv.y += 0.0045*sin(22.*iTime+uv.x*22.0+uv.y*77.)*0.3*sin(56.*iTime)*cos(14.*iTime);\n    vec2 offs = vec2(0.75, 0.125);\n    \n    float dist = 0.0;\n    float shade = 0.0;\n    vec3 color = vec3(0);\n    \n    float tf_text = max(epsilon*22., iTime - 0.6);\n    const float brightness = 0.00035;\n    float bright_text = brightness *2.2 * min(1.0, 1.0 - sin(tf_text*0.6 * pi * 50.0) / (0.3+tf_text*0.6 * pi * 1.3)); \n\tdist = render_logo(uv + offs);\n\tshade = bright_text / max(epsilon, dist*1.5 - 0.004*0.125);\n\tcolor += vec3(.9, .8, 0.8) * shade;\n    \n    tf_text = max(epsilon*22., iTime - 0.5);\n    bright_text = brightness * 3.5* min(1.0, 1.0 - sin(tf_text*0.5 * pi * 50.0) / (0.3+tf_text*0.5 * pi * 1.3));\n    dist = render_border(uv + offs);\n\tshade = bright_text / max(epsilon, dist - 0.003);\n\tcolor += vec3(2.25, 0.15, 0.10) * shade / (dist*10.);\n\t\n    return clamp(color,0.0001,1.);\n}\n\n\nfloat sdf_box(vec3 p, vec3 b)  {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n}\n\nfloat sdf_vertical_capsule(vec3 p, float h, float r) {\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\n\n\nvec2 sdf_wall(vec3 p, bool complete) {\n\n    // mortar\n    float f = dot(p, vec3(0.0, 0.0, -1.0)); \n   \tvec2 wall = vec2(f, 2.);\n\n\tif(complete)\n\t{\n\t    float abs_noise_1 = abs(noise(p * 50.0));\n    \tfloat abs_noise_2 = abs(noise(p * 5.0));\n    \n\t    // bricks\n\t    vec3 c = vec3(0.7, 0.65, 0.0);\n\t    vec3 bp = p - vec3(0.0, 0.0, 0.004);\n\t    vec3 bp1 = mod(bp + 0.5 * c, c) - 0.5 * c;\n\t    bp -= vec3(0.35, 0.33, 0.0);\n\t    vec3 bp2 = mod(bp + 0.5 * c, c) - 0.5 * c;\n\t    \n\t    float b = sdf_box(bp1, vec3(0.288, 0.08, 0.03));\n\t    b = min(b, sdf_box(bp2, vec3(0.288, 0.09, 0.03)));\n\t    vec2 bricks = vec2(b - abs_noise_1 * 0.005 - abs_noise_2 * 0.02 - .020, 3.);\n\t    \n\t    return wall.x < bricks.x ? wall : bricks;\n    }\n\n    return wall;\n}\n\nvec2 map(vec3 p, bool complete) {\n\tvec2 result = vec2(DRAW_DISTANCE, 0.);\n\t\n\t// floor 1.\n\tfloat f = dot(p + vec3(0.0, 0.3, 0.0), vec3(0.0, 1.0, 0.0));\n\t// sidewalk\n    f = min(f, sdf_box(p + vec3(0.0, 0.32, 0.0), vec3(30.2, 0.3, 2.7)) - .025);\n    f = min(f, sdf_box(p + vec3(-1.5, 0.32, 0.0), vec3(1.5, 0.3, 30.2)) - .025);\n    if (f < result.x) result = vec2(f, 1.0);\n    \n    vec2 wall1 = sdf_wall(p, complete);\n    if (wall1.x < result.x) result = wall1;\n    \n    vec3 p2 = p;\n    p2.x -= 3.0;\n    p2.xz = p2.zx;\n    vec2 wall2 = sdf_wall(p2, complete);\n\tif (wall2.x < result.x) result = wall2;\n    \n    float door = sdf_box(p+vec3(-3.93,-2,5.), vec3(1.1,3.,1.5));\n    if (door < result.x) result = vec2(door, 4.);\n    \n    float pipe = sdf_vertical_capsule(p + vec3(-2.7, 4.4, .3), 20., .11);\n    if (pipe < result.x) result = vec2(pipe, 5.);\n    \n\tfloat ddoor = sdf_box(p+vec3(-4.2,-2,3.5), vec3(4.1,3.,.05));\n\tif (ddoor < result.x) result = vec2(ddoor, 6.);\n\n    return result;\n}\n\nvec3 estimate_normal(vec3 p) {\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.0001*e, true).x;\n    }\n    return normalize(n);\n}\n\nvec2 ray_march(vec3 ray_origin, vec3 ray_destination) {\n    float total_distance = 0.0;\n    vec3 point;\n    vec2 result;\n    for (int i = 0; i < 20; i++) {\n        point = ray_origin + total_distance * ray_destination;\n       \t\n        result = map(point, true);\n        \n        if (result.x < SURFACE_DISTANCE || total_distance > DRAW_DISTANCE) break;\n        \n        total_distance += result.x;\n    }\n    \n    result.x = total_distance;\n    return result;\n}\n\n// Lighting\nfloat ambient_occlusion(vec3 p, vec3 n) {\n\tfloat stepSize = 0.002f;\n\tfloat t = stepSize;\n\tfloat oc = 0.0f;\n\tfor(int i = 0; i < 10; ++i) {\n\t\tvec2 obj = map(p + n * t, false);\n\t\toc += t - obj.x;\n\t\tt += pow(float(i), 2.2) * stepSize;\n\t}\n\n\treturn 1.0 - clamp(oc * 0.2, 0.0, 1.0);\n}\n\nfloat get_visibility(vec3 p0, vec3 p1, float k) {\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0f * SURFACE_DISTANCE;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0f;\n\twhile(t < maxt || t < DRAW_DISTANCE) {\n\t\tvec2 o = map(p0 + rd * t, false);\n\n\t\tif(o.x < SURFACE_DISTANCE)\n\t\t\treturn 0.0f;\n\n\t\tf = min(f, k * o.x / t);\n\t\tt += o.x;\n\t}\n\treturn f;\n}\n\n\nvec3 render(vec2 obj, vec3 p, vec3 rd, vec2 uv) {\n\tvec3 col;\n\tvec3 normal = estimate_normal(p);\n\tfloat fog;\n\t\n    vec3 background = vec3(0.0, 0.01, 0.05);\n    float n = noise(uv * 250.0);\n    n = smoothstep(0.6, 0.65, n) * .5;\n    background *= n;\n\t\n\tif (obj.x >= DRAW_DISTANCE) {\n\t\tcol = background;\n\t} else {\n\t\tfloat wallnoise = ((noise(p * 2.0)) * .2 + 0.7);\n\t\tvec3 albedo = vec3(0.285, 0.364, 0.294) * 0.6;\n        fog = pow((obj.x / DRAW_DISTANCE), 6.8);\n        float aa = ambient_occlusion(p, normal);\n        \n        float diff_mask = 1.0;\n        float spec_power = 10.0;\n        float spec_mask = .5;\n        \n\n    \tcol += albedo * pow(aa, 4.0) * .7+.03;\n    \tif (obj.y >= 6.0) { // door\n        \n            albedo = vec3(.055, .194, .184) ;\n            \n            spec_power = 20.0;\n            spec_mask = 10.;\n        } else if (obj.y >= 5.0) { // pipe\n        \n            albedo = vec3(0.505, 0.194, 0.184) ;\n            \n\n            spec_power = 20.0;\n            spec_mask = 1.;\n        } else if (obj.y >= 4.0) { // door\n            albedo = vec3(.505, .194, .084) ;\n            \n            spec_power = 20.0;\n            spec_mask = smoothstep(0.1, 1.,sin(iTime*0.5)-0.2)+normal.y*2.;\n        } else if (obj.y >= 3.0) { // bricks\n            float n = abs(noise(uv * 2.0));\n            albedo = vec3(0.405, 0.194, 0.184) * (n * 0.4 + 0.6);\n            \n            spec_power = 50.0;\n            spec_mask = .3;\n        } else if (obj.y >= 2.) { // mortar\n            albedo = vec3(0.305, 0.354, 0.384) * wallnoise *0.5;\n        } else if (obj.y >= 1.) { // floor\n        \tfloat floornoise = ((noise(p * 22.0)) * .02 + 0.7);\n            albedo = vec3(0.285, 0.364, 0.294) * 0.7 * floornoise;\n\n            spec_power = 10.0;\n            spec_mask = 0.5;\n        }\n    \t{\n            vec3 light_pos = vec3(-32.0, 35.0, -35.);\n            vec3 light_col = vec3(0.2, 0.2, .2);\n            vec3 light_dir = normalize(light_pos - p);\n\t\n\t\t\tvec3 refd = reflect(rd, normal);\n\n   \n            float diffuse = dot(light_dir, normal);\n            float visibility = get_visibility(p, light_pos, 10.0);\n        \tfloat spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diff_mask * diffuse * albedo * visibility * light_col * 3.5;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n        {\n            vec3 light_pos = vec3(1.8, 3.2, -5.);\n            vec3 light_col = vec3(1.725, 1.285, 1.0);\n            vec3 normal = normal;\n            normal.y*=sin(iTime*0.5);\n         \n            vec3 refd = reflect(rd, normal);\n            vec3 light_dir = normalize(light_pos - p);\n\n            float diffuse = dot(light_dir, normal);\n            float visibility = get_visibility(p, light_pos, 20.0);\n            float spec = pow(max(0.0, dot(refd, light_dir)), spec_power);\n\n            col += diffuse * albedo * 0.2 * light_col;\n            col += spec * (light_col * albedo) * spec_mask;\n        }\n\t}\n\t\n\treturn mix(col, background, fog);\n}\n\n\nvec3 render_from(vec2 uv, vec3 eye_position, vec3 look_at, vec3 up) {\n    vec3 forward = normalize(look_at - eye_position);\n    vec3 right = normalize(cross(up, forward));\n    up = cross(-right, forward);\n    float focal_length = 1.0;\n    vec3 start_pos = eye_position + forward * focal_length + right * uv.x + up * uv.y;\n    vec3 direction = normalize(start_pos - eye_position);\n\n    vec2 obj = ray_march(start_pos, direction);\n    vec3 p = start_pos + obj.x * direction;\n    vec3 color = render(obj, p, direction, uv);\n    color = pow(vec3(dot(color, vec3(.2126, .7152, .0722))), vec3(0.995));\n\tcolor -= vec3(0.315); \n  \treturn color*0.729;\n}\n\nvec3 volumetric_fog(vec2 uv, vec3 bg) {\n    float T = 5.0;\n    float t = iTime*0.05;\n    float iterations = 30.;\n    float fog_density = .5;\n    float view_distance = 6.0;\n    float fog_intensity = 2.0;\n\tvec3 fog_color = vec3(.13, .1, .1);\n   \n    float tr = (t / 2.0 + 910. / 200.0);\n    float r = (1.0 + cos(tr)) * 15.0;\n    \n    float tx = t * 0.1 - 1400. / 1000.0;\n    float camx = r * cos(tx / T * (2.0 * pi));\n    float camy = 0.0;\n    float camz = r * sin(tx / T * (2.0 * pi));\n        \n    vec3 cam_pos = vec3(camx, camy, camz);\n    vec3 cam_up = vec3(0, 1, 0);\n    vec3 cam_dir = normalize(cam_pos);\n    vec3 cam_right = cross(cam_up, cam_dir);\n    \n    vec3 ray = cam_up * uv.y + cam_right * uv.x + cam_dir;\n    vec3 pos = cam_pos;\n\n    vec3 p = pos;\n    float density = 0.0;\n\n    for (float i = 0.0; i < iterations; i++) {\n        float f = i / iterations;\n        float alpha = smoothstep(0.0, iterations * 0.2, i) * (1.0 - f) * (1.0 - f);\n        float dense_fog = smoothstep(fog_density, 0.75, noise(p));\n        float light_fog = (smoothstep(-0.2, 1.2, noise(p * 2.0)) - 0.5) * 0.5;\n        density += (light_fog + dense_fog) * alpha;\n        p = pos + ray * f * view_distance;\n    }\n\n    float l = (density / iterations) * fog_intensity;\n    return bg+(fog_color+fog_color*l*8.)*0.35;\n}\n\nvec3 render_left(vec2 uv) {\n\treturn volumetric_fog(uv*4., render_from(uv, vec3(-12., 1.5, -5.), vec3(12., 4.,-1.), vec3(0.,.2, .1)));\n}\n\n\nvec3 render_right(vec2 uv) {\n\tvec3 neon = render_neon(uv*2.1);\n\treturn render_from(uv, vec3(-6., 3., -15.), vec3(-6., 5., 0.), vec3(0.,1.,0.))\n\t*(-0.001+pow(neon, vec3(0.35)))\n\t+neon+0.0025;\n}\n\nvec3 render(vec2 uv) {\n\tuv /= 1.45;\n\n    float lw = 0.005;\n    float split = uv.x - 0.45 * uv.y;\n\n\tif (abs(uv.x) > 1.-lw || abs(uv.y) > iResolution.y/iResolution.x - lw) {\n\t\treturn vec3(-1.);\n\t}\n    if (abs(split) < lw*.5 || abs(uv.x) > 1.-lw*2. || abs(uv.y) > iResolution.y/iResolution.x - lw*2.) {\n        return vec3(1.);\n    }\n    if (abs(split) < lw*2. || abs(uv.x) > 1.-lw*3. || abs(uv.y) > iResolution.y/iResolution.x - lw*3.) {\n        return vec3(0.);\n    }\n    if (split > 0.) {\n        return render_right(uv-vec2(0.5,0.));\n    } else {\n        return render_left(uv+vec2(0.5,0.));\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 total_color = vec4(0.);\n\t\n\tfor(int m=0; m<AA; m++) \n    for(int n=0; n<AA; n++) {\n        vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n        vec2 uv = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n   \n   \t\tvec4 color = render_background(fragCoord);\n   \t\tvec3 c = render(uv);\n   \t\tif (c.x > -0.5) {\n   \t\t   \tcolor = vec4(c,1.);\n   \t\t}\n\n    \tcolor.xyz = pow( color.xyz, vec3(0.795) );\n\t    color *= 2.5;\n\t   \tcolor *= 0.5;\n\t    color = 1.-exp(color*-2.);\n\t    \n\t    total_color += color;\n\t}\n\ttotal_color /= float(AA*AA);\n    fragColor = total_color;\n}", "image_inputs": [], "common_code": "// value noise as seen on iq's tutorials \n// https://iquilezles.org/articles/morenoise\nfloat hash1(vec2 p) {\n    p=50.0*fract(p*0.3183099 );\n    return fract(p.x*p.y*(p.x+p.y));\n}\n\nfloat hash1(float n) {\n    return fract(n*17.0*fract(n*0.3183099));\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\n\nfloat noise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    return -1.0+2.0*(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd33R2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[672, 672, 725, 725, 1004], [1006, 1006, 1046, 1046, 1445], [1448, 1448, 1495, 1495, 1636], [1638, 1638, 1715, 1715, 2009], [2193, 2193, 2221, 2221, 5023], [5025, 5025, 5055, 5055, 6444], [6446, 6446, 6473, 6473, 7358], [7361, 7361, 7393, 7393, 7447], [7449, 7449, 7503, 7503, 7558], [7562, 7562, 7600, 7615, 8305], [8307, 8307, 8340, 8340, 9293], [9295, 9295, 9325, 9325, 9529], [9531, 9531, 9586, 9586, 9992], [9994, 10006, 10047, 10047, 10283], [10285, 10285, 10334, 10334, 10628], [10631, 10631, 10680, 10680, 13625], [13628, 13628, 13697, 13697, 14272], [14274, 14274, 14313, 14313, 15576], [15578, 15578, 15605, 15605, 15713], [15716, 15716, 15744, 15744, 15908], [15910, 15910, 15932, 15932, 16510], [16513, 16513, 16568, 16568, 17146]]}
{"id": "Nt23RD", "name": "Pythagorean Triples", "author": "iq", "description": "Pythagorean triples. All points in the plane which distance to the origin is an integer are green. In this render every pixel represents a 8x8 grid of integers.", "tags": ["2d", "math", "maths", "pythagorean", "triplets"], "likes": 32, "viewed": 927, "published": 3, "date": "1630181305", "time_retrieved": "2024-07-30T19:04:23.938076", "image_code": "// Created by inigo quilez - iq/2021\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// Pythagorean triples - https://en.wikipedia.org/wiki/Pythagorean_triple\n//\n// All points in the plane for which the distance to the origin\n// is an integer. In this render every pixel represents a 8x8 grid\n// of integers. You can change that in line 15.\n\n\n#define INTS_PER_PIXEL 8\n#define USE_EXACT_SQRT 0\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 6\n#endif\n\n#if USE_EXACT_SQRT==1\nuint intsqrt( uint s );\n#endif\n\nvec3 render( in vec2 px )\n{\n    float s = exp2( -(1.0+cos(6.283185*iTime/20.0)) );\n    uvec2 p = uvec2( abs(floor((px-iResolution.xy*0.5)*s)) );\n\n    const uint S = uint(INTS_PER_PIXEL);\n    \n    float f = 0.0;\n    for( uint j=0u; j<S; j++ )\n    for( uint i=0u; i<S; i++ )\n    {\n        uvec2 q = S*p + uvec2(i,j);\n        uint h2 = q.x*q.x + q.y*q.y;\n        \n        #if USE_EXACT_SQRT==0\n        uint h = uint(round(sqrt(float(h2))));\n        #else\n        uint h = intsqrt(h2);\n        #endif\n        \n        if( h*h==h2 ) { f = 1.0; break; }\n    }\n    \n    return vec3(0.5*f,f,0.0);\n}\n\n\n// --------------------------------------\n// Integer square root\n// https://en.wikipedia.org/wiki/Integer_square_root\n// --------------------------------------\n#if USE_EXACT_SQRT==1\nuint intsqrt( uint s )\n{\n\tuint x0 = s >> 1;\n    if( x0==0u ) return s;\n    uint x1 = ( x0 + s / x0 ) >> 1;\n    while( x1 < x0 )\n    {\n        x0 = x1;\n        x1 = ( x0 + s / x0 ) >> 1;\n    }\n    return x0;\n}\n#endif\n\n\n\n#if AA>1\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n#endif\n\n// --------------------------------------\n// main\n// --------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA>1\n    seed = hash( int(fragCoord.y)*3840 + int(fragCoord.x) );\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = 2.0*vec2(float(m)+frand(),float(n)+frand())/float(AA)-1.0;\n        col += render(fragCoord+o);\n    }\n    col /= float(AA*AA);\n#else\n    vec3 col = render(fragCoord);\n#endif\n    col = sqrt(col);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt23RD.jpg", "access": "api", "license": "proprietary-license", "functions": [[1022, 1022, 1049, 1049, 1612], [2579, 2671, 2728, 2728, 3135]]}
{"id": "7sc3zj", "name": "Disk Reconfigurator [Livecode]", "author": "Tater", "description": "My shader from the 2021 Chaos Constructions Shader jam.\n\n[url]https://www.youtube.com/watch?v=gcoDX7bonX0[/url]", "tags": ["3d", "raymarching", "jam", "bonzomatic", "livecode", "shaderjam"], "likes": 14, "viewed": 512, "published": 3, "date": "1630180222", "time_retrieved": "2024-07-30T19:04:24.904492", "image_code": "\n#define fGlobalTime iTime\n#define STEPS 128.0\n#define MDIST 2000.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define fft1 texelFetch( iChannel0, ivec2(1,0), 0 ).x*0.08\n#define fft2 texelFetch( iChannel0, ivec2(128,0), 0 ).x*0.04\n#define fft3 texelFetch( iChannel0, ivec2(25,0), 0 ).x*0.02\nvec3 glow = vec3(0);\nvec3 cam = vec3(0);\nbool bnc = false;\nvoid mo(inout vec2 p){if(p.y<p.x) p = p.yx;}\nvoid boxFold(inout vec3 z, vec3 r){\n  z = clamp(z,-r,r)*2.0-z;\n}\nfloat frame (vec3 p, vec3 s, float r){\n  p = abs(p)-s;\n  mo(p.xz);\n  mo(p.zy);\n  p.z=max(0.,p.z);\n  return length(p)-r; \n}\nfloat ext(vec3 p, float s, float h){\n  vec2 b = vec2(s,abs(p.y)-h);\n  return min(max(b.x,b.y),0.)+length(max(b,0.));\n}\n\nfloat disks(vec3 p, float t){\n  float m = 1.0+fft1*20.0;\n  float id = floor(p.y/m)+0.5;\n  p.y = pmod(p.y, m);\n  float width = 5.0-id*0.1;\n  \n  p.zx*=rot(id*3.0*t*0.1);\n  p.zx = abs(p.zx)-6.0+sin(t*2.5);\n  float a = length(p.xz)-width;\n  a = ext(p,a,0.3);\n  a-=0.15;\n  return a;\n}\nvec2 map(vec3 p){\n  float t= mod(fGlobalTime,999.0);\n  vec3 po = p;\n  vec2 a = vec2(1);\n  vec2 b = vec2(2);\n  \n  \n   //FANCY ROT\n  float tt = pow(fract(t*2.2),3.0)+floor(t*2.2);\n  p.xy*=rot(tt*pi/3.0);\n  p.zx*=rot(-tt*pi/3.0);\n  p.yz*=rot(-tt*pi/3.0);\n  \n  p = abs(p)-40.0-fft2*1000.0;\n  \n  p.yz*=rot(-0.4);\n  p.zx*=rot(-0.4);\n  p.xy*=rot(0.4);\n   //FANCY ROT\n // float tt = pow(fract(t*1.5),3.0)+floor(t*1.5);\n  p.xy*=rot(tt*pi/3.0);\n  p.zx*=rot(-tt*pi/3.0);\n  p.yz*=rot(tt*pi/3.0);\n \n  \n  //DISKS\n  a.x = disks(p,t);\n  a.x*=0.6;\n  a.y = 1.0;\n  glow+=0.1/(0.1+a.x*a.x)*vec3(0.75,0.3,0.1);\n  \n  \n  //FRAME\n  p.zx*=rot(t);\n  b.x = frame(p,vec3(15,200,15),0.75);\n  glow+=0.1/(0.1+b.x*b.x)*vec3(0.4,0.23,0.6);\n  b.y = 2.0;\n  a =(a.x<b.x)?a:b;\n  \n  //SPHERE \n  p = po;\n  \n  p.xy*=rot(-tt*pi/16.0);\n  p.zx*=rot(-tt*pi/16.0);\n  p.yz*=rot(-tt*pi/16.0);\n  \n  \n  boxFold(p,vec3(110.0));\n  b.x = length(p)-40.0;\n  p.zx*=rot(-t*0.75);\n  p*=0.1;\n  float disp = sin(p.x)*sin(p.y)*sin(p.z);\n\n  b.y = 3.0;\n  glow+=0.3/(0.1+b.x*b.x)*\n  mix(vec3(0,0.2,0.6),vec3(0.600,0.102,0.392),clamp(length(po/300.0),0.0,1.0));\n  b.x+=disp*(1.5+fft3*200.0);\n  a =(a.x<b.x)?a:b;\n  \n  //POLE\n  p = po;\n  b.y = 5.0;\n  p.zx = pmod(p.zx,600.0);\n  p.xy = pmod(p.xy,600.0);\n  p.yz = pmod(p.yz+300.0,600.0);\n  b.x = length(p.zx)-20.0;\n  b.x = min(b.x,length(p.xy)-20.0);\n  b.x = min(b.x,length(p.yz)-20.0);\n  //glow+=\n  if(!bnc)a =(a.x<b.x)?a:b;\n  \n  a.x = max(a.x,-(length(po-cam)-35.0));\n\n  return a;\n}\nvec3 norm(vec3 p){\n  vec2 e = vec2(0.01,0);\n  return normalize(map(p).x-vec3(\n  map(p-e.xyy).x,\n  map(p-e.yxy).x,\n  map(p-e.yyx).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 col = vec3(0);\n  float t= mod(fGlobalTime,999.0);\n  vec3 ro = vec3(0,20.0+sin(t)*70.0,-70.0)*2.2;\n  ro.zx*=rot(t*0.2);\n  cam = ro;\n  vec3 lk = vec3(0,10,0);\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = normalize(f*0.65+uv.x*r+uv.y*cross(f,r));\n  vec3 p = ro;\n  vec2 d;\n  float shad, dO;\n  bool hit = false;\n  //bool bnc = false;\n  for(float i = 0.0; i<STEPS; i++){\n    p = ro+rd*dO;\n    d = map(p);\n    \n    if(abs(d.x)<0.005){\n      if(!bnc&&d.y==3.0){\n        vec3 n = norm(p);\n        ro = p+n*0.05;\n        rd = n;\n        dO = 0.0;\n        bnc = true;\n      }\n      else{\n        hit = true;\n      shad = i/STEPS;\n      break;\n      }\n    }\n    if(dO>MDIST){\n      dO=MDIST;\n      break;\n    }\n    dO+=d.x*0.8;\n  }\n  col+=glow*0.1;\n  \n  if(hit){\n    \n    vec3 ld = vec3(-1,1,1);\n    float shadow = 1.0;\n    for(float h = 0.4;h<100.0;){\n      float dd = map(p+ld*h).x;\n      if(dd<0.1){shadow = 0.; break;}\n      h+=dd*0.9;\n      shadow = min(shadow,dd*3.0);\n    }\n    shadow = max(0.4,shadow);\n    \n    vec3 n = norm(p);\n    //col = vec3(shad);\n    col += vec3(length(n*0.5+0.5))*0.6;\n    col *=shadow;\n    \n    if(d.y==5.0)col = glow*3.0;\n  }\n  \n  //if(bnc) col = 1.0-col;\n\tfragColor = vec4(col,0);\n}", "image_inputs": [{"id": 28011, "src": "https://soundcloud.com/syntheofficial/moonstone", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[418, 418, 440, 440, 462], [463, 463, 498, 498, 527], [528, 528, 566, 566, 650], [651, 651, 687, 687, 769], [771, 771, 800, 800, 1050], [1051, 1051, 1068, 1068, 2517], [2518, 2518, 2536, 2536, 2653], [2655, 2655, 2712, 2712, 4100]]}
{"id": "ssc3zj", "name": "2 much drugs again", "author": "xenn", "description": "Displacement mapping with chromatic dispersion. The displacement vectors are supplied by an underlying dynamical system. Click to paint.", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "likes": 6, "viewed": 542, "published": 3, "date": "1630179877", "time_retrieved": "2024-07-30T19:04:25.949698", "image_code": "// Fork of \"2 much drugs\" by xenn. https://shadertoy.com/view/7d33zj\n// 2021-08-28 19:43:01\n\n// Fork of \"Another Mess with Dispersion\" by xenn. https://shadertoy.com/view/Ndc3zj\n// 2021-08-28 16:03:28\n\n// Fork of \"A Handsome Mess with Dispersion\" by xenn. https://shadertoy.com/view/fdc3zj\n// 2021-08-28 10:49:54\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),440.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,50.0)*.85;\n    //spec=0.0;\n\tfragColor = texture(iChannel2,uv)*vec4(diff)+vec4(spec);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n/*    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n*/    \n    vec4 u =    texture(iChannel2, fract(vUv));\n    vec4 u_n =  texture(iChannel2, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel2, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel2, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel2, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel2, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel2, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel2, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel2, fract(vUv+texel*se));\n    \n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n /*   vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n  */  \n     vec4 uv =    texture(iChannel2, fract(vUv));\n    vec4 uv_n =  texture(iChannel2, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel2, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel2, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel2, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel2, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel2, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel2, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel2, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 9\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.00251*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Mashup Fork of \"Displacement with Dispersion\" by cornusammonis. https://shadertoy.com/view/4ldGDB\n// 2021-08-28 10:34:29\n// & this https://www.shadertoy.com/view/MsGSRd by flockeroo\n\n// displacement amount\n#define DISP_SCALE 2.0\n\n// chromatic dispersion samples\n#define SAMPLES 128\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssc3zj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[925, 925, 948, 948, 996], [1002, 1002, 1037, 1037, 1176], [1178, 1178, 1235, 1235, 1648]]}
{"id": "7d33zj", "name": "2 much drugs", "author": "xenn", "description": "Displacement mapping with chromatic dispersion. The displacement vectors are supplied by an underlying dynamical system. Click to paint.", "tags": ["displacement", "chromatic", "aberration", "mapping", "dispersion"], "likes": 4, "viewed": 377, "published": 3, "date": "1630176790", "time_retrieved": "2024-07-30T19:04:26.890183", "image_code": "// Fork of \"Another Mess with Dispersion\" by xenn. https://shadertoy.com/view/Ndc3zj\n// 2021-08-28 16:03:28\n\n// Fork of \"A Handsome Mess with Dispersion\" by xenn. https://shadertoy.com/view/fdc3zj\n// 2021-08-28 10:49:54\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),999.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel2,uv)*vec4(diff)+vec4(spec);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n    A fracturing dynamical system\n\tsee: https://www.shadertoy.com/view/MsyXRW\n*/\n\n#define _G0 0.25\n#define _G1 0.125\n#define _G2 0.0625\n#define W0 -3.0\n#define W1 0.5\n#define TIMESTEP 0.1\n#define ADVECT_DIST 2.0\n#define DV 0.70710678\n\n// nonlinearity\nfloat nl(float x) {\n    return 1.0 / (1.0 + exp(W0 * (W1 * x - 0.5))); \n}\n\nvec4 gaussian(vec4 x, vec4 x_nw, vec4 x_n, vec4 x_ne, vec4 x_w, vec4 x_e, vec4 x_sw, vec4 x_s, vec4 x_se) {\n    return _G0*x + _G1*(x_n + x_e + x_w + x_s) + _G2*(x_nw + x_sw + x_ne + x_se);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\nvec4 advect(vec2 ab, vec2 vUv, vec2 step) {\n    \n    vec2 aUv = vUv - ab * ADVECT_DIST * step;\n    \n    vec2 n  = vec2(0.0, step.y);\n    vec2 ne = vec2(step.x, step.y);\n    vec2 e  = vec2(step.x, 0.0);\n    vec2 se = vec2(step.x, -step.y);\n    vec2 s  = vec2(0.0, -step.y);\n    vec2 sw = vec2(-step.x, -step.y);\n    vec2 w  = vec2(-step.x, 0.0);\n    vec2 nw = vec2(-step.x, step.y);\n\n    vec4 u =    texture(iChannel0, fract(aUv));\n    vec4 u_n =  texture(iChannel0, fract(aUv+n));\n    vec4 u_e =  texture(iChannel0, fract(aUv+e));\n    vec4 u_s =  texture(iChannel0, fract(aUv+s));\n    vec4 u_w =  texture(iChannel0, fract(aUv+w));\n    vec4 u_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 u_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 u_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 u_se = texture(iChannel0, fract(aUv+se));\n    \n    return gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n}\n\n#define SQRT_3_OVER_2 0.86602540378\n#define SQRT_3_OVER_2_INV 0.13397459621\n\nvec2 diagH(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_v) * SQRT_3_OVER_2_INV + (x_h + x_d) * SQRT_3_OVER_2);\n}\n\nvec2 diagV(vec2 x, vec2 x_v, vec2 x_h, vec2 x_d) {\n    return 0.5 * ((x + x_h) * SQRT_3_OVER_2_INV + (x_v + x_d) * SQRT_3_OVER_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    vec2 n  = vec2(0.0, 1.0);\n    vec2 ne = vec2(1.0, 1.0);\n    vec2 e  = vec2(1.0, 0.0);\n    vec2 se = vec2(1.0, -1.0);\n    vec2 s  = vec2(0.0, -1.0);\n    vec2 sw = vec2(-1.0, -1.0);\n    vec2 w  = vec2(-1.0, 0.0);\n    vec2 nw = vec2(-1.0, 1.0);\n\n/*    vec4 u =    texture(iChannel0, fract(vUv));\n    vec4 u_n =  texture(iChannel0, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel0, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel0, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel0, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel0, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel0, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel0, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel0, fract(vUv+texel*se));\n*/    \n    vec4 u =    texture(iChannel2, fract(vUv));\n    vec4 u_n =  texture(iChannel2, fract(vUv+texel*n));\n    vec4 u_e =  texture(iChannel2, fract(vUv+texel*e));\n    vec4 u_s =  texture(iChannel2, fract(vUv+texel*s));\n    vec4 u_w =  texture(iChannel2, fract(vUv+texel*w));\n    vec4 u_nw = texture(iChannel2, fract(vUv+texel*nw));\n    vec4 u_sw = texture(iChannel2, fract(vUv+texel*sw));\n    vec4 u_ne = texture(iChannel2, fract(vUv+texel*ne));\n    vec4 u_se = texture(iChannel2, fract(vUv+texel*se));\n    \n    \n    const float vx = 0.5;\n    const float vy = SQRT_3_OVER_2;\n    const float hx = SQRT_3_OVER_2;\n    const float hy = 0.5;\n\n    float di_n  = nl(distance(u_n.xy + n, u.xy));\n    float di_w  = nl(distance(u_w.xy + w, u.xy));\n    float di_e  = nl(distance(u_e.xy + e, u.xy));\n    float di_s  = nl(distance(u_s.xy + s, u.xy));\n    \n    float di_nne = nl(distance((diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)), u.xy));\n    float di_ene = nl(distance((diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)), u.xy));\n    float di_ese = nl(distance((diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)), u.xy));\n    float di_sse = nl(distance((diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)), u.xy));    \n    float di_ssw = nl(distance((diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)), u.xy));\n    float di_wsw = nl(distance((diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)), u.xy));\n    float di_wnw = nl(distance((diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)), u.xy));\n    float di_nnw = nl(distance((diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)), u.xy));\n\n    vec2 xy_n  = u_n.xy + n - u.xy;\n    vec2 xy_w  = u_w.xy + w - u.xy;\n    vec2 xy_e  = u_e.xy + e - u.xy;\n    vec2 xy_s  = u_s.xy + s - u.xy;\n    \n    vec2 xy_nne = (diagV(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ vx, + vy)) - u.xy;\n    vec2 xy_ene = (diagH(u.xy, u_n.xy, u_e.xy, u_ne.xy) + vec2(+ hx, + hy)) - u.xy;\n    vec2 xy_ese = (diagH(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ hx, - hy)) - u.xy;\n    vec2 xy_sse = (diagV(u.xy, u_s.xy, u_e.xy, u_se.xy) + vec2(+ vx, - vy)) - u.xy;\n    vec2 xy_ssw = (diagV(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- vx, - vy)) - u.xy;\n    vec2 xy_wsw = (diagH(u.xy, u_s.xy, u_w.xy, u_sw.xy) + vec2(- hx, - hy)) - u.xy;\n    vec2 xy_wnw = (diagH(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- hx, + hy)) - u.xy;\n    vec2 xy_nnw = (diagV(u.xy, u_n.xy, u_w.xy, u_nw.xy) + vec2(- vx, + vy)) - u.xy;\n\n    vec2 ma = di_nne * xy_nne + di_ene * xy_ene + di_ese * xy_ese + di_sse * xy_sse + di_ssw * xy_ssw + di_wsw * xy_wsw + di_wnw * xy_wnw + di_nnw * xy_nnw + di_n * xy_n + di_w * xy_w + di_e * xy_e + di_s * xy_s;\n\n    vec4 u_blur = gaussian(u, u_nw, u_n, u_ne, u_w, u_e, u_sw, u_s, u_se);\n    \n    vec4 au = advect(u.xy, vUv, texel);\n    vec4 av = advect(u.zw, vUv, texel);\n    \n    vec2 dv = av.zw + TIMESTEP * ma;\n    vec2 du = au.xy + TIMESTEP * dv;\n\n    if (iMouse.z > 0.0) {\n    \tvec2 d = fragCoord.xy - iMouse.xy;\n        float m = exp(-length(d) / 50.0);\n        du += 0.2 * m * normz(d);\n    }\n    \n    vec2 init = texture(iChannel1, vUv, 4.0).xy;\n    // initialize with noise\n    if((length(u) < 0.001 && length(init) > 0.001) || reset()) {\n        fragColor = 8.0 * (vec4(-0.5) + vec4(init.xy, init.xy));\n    } else {\n        du = length(du) > 1.0 ? normz(du) : du;\n        fragColor = vec4(du, dv);\n    }\n    \n\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n    A fluid-like dynamical system\n\tsee: https://www.shadertoy.com/view/XddSRX\n*/\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0.0, 0.0) ? vec2(0.0, 0.0) : normalize(x);\n}\n\n// reverse advection\nvec4 advect(vec2 ab, vec2 vUv, vec2 step, float sc) {\n    \n    vec2 aUv = vUv - ab * sc * step;\n    \n    const float _G0 = 0.25; // center weight\n    const float _G1 = 0.125; // edge-neighbors\n    const float _G2 = 0.0625; // vertex-neighbors\n    \n    // 3x3 neighborhood coordinates\n    float step_x = step.x;\n    float step_y = step.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n    vec4 uv =    texture(iChannel0, fract(aUv));\n    vec4 uv_n =  texture(iChannel0, fract(aUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(aUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(aUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(aUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(aUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(aUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(aUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(aUv+se));\n    \n    return _G0*uv + _G1*(uv_n + uv_e + uv_w + uv_s) + _G2*(uv_nw + uv_sw + uv_ne + uv_se);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float _K0 = -20.0/6.0; // center weight\n    const float _K1 = 4.0/6.0;   // edge-neighbors\n    const float _K2 = 1.0/6.0;   // vertex-neighbors\n    const float cs = -3.0;  // curl scale\n    const float ls = 3.0;  // laplacian scale\n    const float ps = 0.0;  // laplacian of divergence scale\n    const float ds = -12.0; // divergence scale\n    const float dp = -6.0; // divergence update scale\n    const float pl = 0.3;   // divergence smoothing\n    const float ad = 6.0;   // advection distance scale\n    const float pwr = 1.0;  // power when deriving rotation angle from curl\n    const float amp = 1.0;  // self-amplification\n    const float upd = 0.99;  // update smoothing\n    const float sq2 = 0.6;  // diagonal weight\n    \n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    \n    // 3x3 neighborhood coordinates\n    float step_x = texel.x;\n    float step_y = texel.y;\n    vec2 n  = vec2(0.0, step_y);\n    vec2 ne = vec2(step_x, step_y);\n    vec2 e  = vec2(step_x, 0.0);\n    vec2 se = vec2(step_x, -step_y);\n    vec2 s  = vec2(0.0, -step_y);\n    vec2 sw = vec2(-step_x, -step_y);\n    vec2 w  = vec2(-step_x, 0.0);\n    vec2 nw = vec2(-step_x, step_y);\n\n /*   vec4 uv =    texture(iChannel0, fract(vUv));\n    vec4 uv_n =  texture(iChannel0, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel0, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel0, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel0, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel0, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel0, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel0, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel0, fract(vUv+se));\n  */  \n     vec4 uv =    texture(iChannel2, fract(vUv));\n    vec4 uv_n =  texture(iChannel2, fract(vUv+n));\n    vec4 uv_e =  texture(iChannel2, fract(vUv+e));\n    vec4 uv_s =  texture(iChannel2, fract(vUv+s));\n    vec4 uv_w =  texture(iChannel2, fract(vUv+w));\n    vec4 uv_nw = texture(iChannel2, fract(vUv+nw));\n    vec4 uv_sw = texture(iChannel2, fract(vUv+sw));\n    vec4 uv_ne = texture(iChannel2, fract(vUv+ne));\n    vec4 uv_se = texture(iChannel2, fract(vUv+se));\n    \n    // uv.x and uv.y are the x and y components, uv.z and uv.w accumulate divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(uv_n + uv_e + uv_w + uv_s) + _K2*(uv_nw + uv_sw + uv_ne + uv_se);\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = uv_n.x - uv_s.x - uv_e.y + uv_w.y + sq2 * (uv_nw.x + uv_nw.y + uv_ne.x - uv_ne.y + uv_sw.y - uv_sw.x - uv_se.y - uv_se.x);\n    \n    // compute angle of rotation from curl\n    float sc = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = uv_s.y - uv_n.y - uv_e.x + uv_w.x + sq2 * (uv_nw.x - uv_nw.y - uv_ne.x - uv_ne.y + uv_sw.x + uv_sw.y + uv_se.y - uv_se.x);\n    \n    vec2 norm = normz(uv.xy);\n    \n    float sdx = uv.z + dp * uv.x * div + pl * lapl.z;\n    float sdy = uv.w + dp * uv.y * div + pl * lapl.w;\n\n    vec2 ab = advect(vec2(uv.x, uv.y), vUv, texel, ad).xy;\n    \n    // temp values for the update rule\n    float ta = amp * ab.x + ls * lapl.x + norm.x * ps * lapl.z + ds * sdx;\n    float tb = amp * ab.y + ls * lapl.y + norm.y * ps * lapl.w + ds * sdy;\n\n    // rotate\n    float a = ta * cos(sc) - tb * sin(sc);\n    float b = ta * sin(sc) + tb * cos(sc);\n    \n    vec4 abd = upd * uv + (1.0 - upd) * vec4(a,b,sdx,sdy);\n    \n    fragColor = vec4(abd);\n    \n    abd.xy = clamp(length(abd.xy) > 1.0 ? normz(abd.xy) : abd.xy, -1.0, 1.0);\n    fragColor = vec4(abd);\n    \n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel2,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Mashup Fork of \"Displacement with Dispersion\" by cornusammonis. https://shadertoy.com/view/4ldGDB\n// 2021-08-28 10:34:29\n// & this https://www.shadertoy.com/view/MsGSRd by flockeroo\n\n// displacement amount\n#define DISP_SCALE 2.0\n\n// chromatic dispersion samples\n#define SAMPLES 24\n\n// contrast\n#define SIGMOID_CONTRAST 12.0\n\n// channels to use for displacement, either xy or zw\n#define CH xy\n\n\nvec3 contrast(vec3 x) {\n\treturn 1.0 / (1.0 + exp(-SIGMOID_CONTRAST * (x - 0.5)));    \n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(0) ? vec2(0) : normalize(x);\n}\n\n/*\n\tThis function supplies a weight vector for each color channel.\n\tIt's analogous to (but not a physically accurate model of)\n\tthe response curves for each of the 3 cone types in the human eye.\n\tThe three functions for red, green, and blue have the same integral\n    over [0, 1], which is 1/3.\n    Here are some other potential terms for the green weight that \n\tintegrate to 1/3:\n        2.0*(1-x)*x\n        10.0*((1-x)*x)^2\n        46.667*((1-i)*i)^3\n        210.0*((1-x)*x)^4\n        924.0*((1-x)*x)^5\n    By the way, this series of coefficients is OEIS A004731 divided by 3,\n    which is a pretty interesting series: https://oeis.org/A002457\n*/\nvec3 sampleWeights(float i) {\n\treturn vec3(i * i, 46.6666*pow((1.0-i)*i,3.0), (1.0 - i) * (1.0 - i));\n}\n\nvec3 sampleDisp(vec2 uv, vec2 dispNorm, float disp) {\n    vec3 col = vec3(0);\n    const float SD = 1.0 / float(SAMPLES);\n    float wl = 0.0;\n    vec3 denom = vec3(0);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 sw = sampleWeights(wl);\n        denom += sw;\n        col += sw * texture(iChannel1, uv + dispNorm * disp * wl).xyz;\n        wl  += SD;\n    }\n    \n    // For a large enough number of samples,\n    // the return below is equivalent to 3.0 * col * SD;\n    return col / denom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 texel = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 n  = vec2(0.0, texel.y);\n    vec2 e  = vec2(texel.x, 0.0);\n    vec2 s  = vec2(0.0, -texel.y);\n    vec2 w  = vec2(-texel.x, 0.0);\n\n    vec2 d   = texture(iChannel0, uv).CH;\n    vec2 d_n = texture(iChannel0, fract(uv+n)).CH;\n    vec2 d_e = texture(iChannel0, fract(uv+e)).CH;\n    vec2 d_s = texture(iChannel0, fract(uv+s)).CH;\n    vec2 d_w = texture(iChannel0, fract(uv+w)).CH; \n\n    // antialias our vector field by blurring\n    vec2 db = 0.4 * d + 0.15 * (d_n+d_e+d_s+d_w);\n\n    float ld = length(db);\n    vec2 ln = normz(db);\n\n\tvec3 col = sampleDisp(uv, ln, DISP_SCALE * ld);\n    \n    fragColor = vec4(contrast(col), 1.0);\n\n}", "buffer_d_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d33zj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[832, 832, 855, 855, 903], [909, 909, 944, 944, 1083], [1085, 1085, 1142, 1142, 1555]]}
{"id": "fd33z2", "name": "neonwave heartbeat", "author": "pali6", "description": "Clickdrag mouse to rotate the camera.", "tags": ["raymarching"], "likes": 3, "viewed": 326, "published": 3, "date": "1630169486", "time_retrieved": "2024-07-30T19:04:27.644167", "image_code": "vec3 camPos = vec3(0, 0, 0);\nvec3 camDir = vec3(0, 0, -1);\nvec3 camUp = vec3(0, 450. / 800., 0);\nfloat camF = 0.4;\nfloat rtStep = 0.2;\nfloat rtlStep = 0.025;\nfloat rtglStep = 0.2;\nconst int maxSteps = 48;\nconst int maxlSteps = 32;\nconst int maxglSteps = 64;\n\nfloat time;\n\nvec3 lightPos = vec3(4, 3, -1);\n\nvec3 INVALID = vec3(1e10, 1e20, -1e30);\n\nfloat smin(float a, float b)\n{\n    float x = b - a;\n    return a + ((1. - 0.5)*x+0.55)*(1. - smoothstep(-1.8,0.4,x))+(0.5*x - 0.55)*(1. - smoothstep(-0.86,1.6,x));\n    // return (a + b - log(exp(a - b) + exp(b - a))) / 2.;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rayDir(vec2 uv)\n{\n    vec3 camRight = normalize(cross(camDir, camUp));\n    return normalize(camDir * camF + (uv.y - 0.5) * 2. * camUp + (uv.x - 0.5) * 2. * camRight);\n}\n\nvec3 orbit(vec3 normal, float dist, float speed, float offset)\n{\n    vec3 v1 = normalize(cross(normal, vec3(0.42, 0.1, -0.1)));\n    vec3 v2 = normalize(cross(normal, v1));\n    return dist * (v1 * cos(time * speed + offset) + v2 * sin(time * speed + offset));\n}\n\nfloat scene(vec3 pos)\n{\n    vec3 ballCenter = vec3(0, 0, -5);\n    float ballRadius = 2.;\n    float result =  distance(pos, ballCenter) - ballRadius + sin(pos.y * 5. + time) / 3. * cos(time * 0.2);\n    vec3 ballCenter2 = ballCenter + orbit(vec3(0, 1, 0), 3., 1., 0.);\n    result = smin(result, distance(pos, ballCenter2) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 12, 0), 2.7, 1.7, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 2, 5), 2.7, 1.8, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(8, 7, -8), 2.7, 1.9, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-14, -5, -1), 2.7, 2.0, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(1, 12, 0), 2.7, 0.8, 0.8)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-7, -5, 8), 2.6, 1.7, 0.1)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-1, 1, 22), 2.5, 1.2, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter2 + orbit(vec3(0.1, -0.5, -1), 0.8, -0.41, -0.2)) - 0.15);\n    /*\n    result -= (dot(pos - ballCenter, normalize(vec3(1, 3, 7)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(-7, 2, 1)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(2, -1, 0.3)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(4, 3, -1)))) * 0.1;\n    */\n    // result += 1./distance(pos, vec3(-2, -2, -7));\n    result = 2. - abs(result - 2.);\n    result = smin(result, length((pos - ballCenter).xz) - 0.3);\n    return result;\n}\n\nvec3 sceneNormal(vec3 pos)\n{\n    float d = 0.001;\n    float base = scene(pos);\n    return normalize(vec3(\n        scene(pos + vec3(d, 0, 0)) - base,\n        scene(pos + vec3(0, d, 0)) - base,\n        scene(pos + vec3(0, 0, d)) - base\n    ));\n}\n\nvec4 rt(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    float retVal = 0.;\n    float stp = rtStep;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(val < 0.001)\n        {\n            retVal = 1.;\n        }\n        if(sign(val * lastVal) == -1.)\n            stp /= 2.;\n        lastVal = val;\n        rayPos += rayDir * stp * sign(val);\n    }\n    return vec4(rayPos, 1.);\n}\n\nvec4 rtl(vec3 rayPos, vec3 rayDir, float maxDist)\n{\n    float lastVal = 0.;\n    float tot = 0.;\n    for(int i = 0; i < maxlSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(maxDist <= 0.1 || val > 40.)\n        {\n            float a = -val / (lastVal - val);\n            rayPos -= rtStep * rayDir * a;\n            return vec4(rayPos, tot);\n        }\n        if(val <= 0.001)\n            tot += rtlStep * (-val);\n        lastVal = val;\n        float step = rtlStep;\n        maxDist -= length(rayDir) * step;\n        rayPos += rayDir * step;\n    }\n    return vec4(rayPos, tot);\n}\n\nvec3 rtgl(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    vec3 result = vec3(0., 0., 0.);\n    for(int i = 0; i < maxglSteps; i++)\n    {\n        float val = scene(rayPos);\n        float sound = texture(iChannel0, vec2(abs(rayPos.y) * 0.1, 0)).x;\n        float power = sound * 5. + 0.1;\n        val = sign(val) * pow(abs(val), power) * (1. + power * 0.2) ;\n        if(val < 0.01)\n        {\n            float a = -val / (lastVal - val);\n            // val = (lastVal + val) / 2.;\n            //result += rtStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.2, 0.3, val)) * val * a;\n            return result;\n        }\n        //if(lastVal > 0.1 && val < 0.09)\n        //    result += rtStep * val * 3.;\n        float xd = rtglStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.3, 0.4, val)) * val * val;\n        result.x += xd;\n        result.y += xd * min(1., sound * 1.5 + 0.2);\n        // result += min(10., 1. / pow(val, 2.2) * smoothstep(0., 1., (val - 0.05) / 0.1)) * rtStep;\n        rayPos += rayDir * rtglStep * min(max(0.1, val), 1.0);\n        lastVal = val;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime * 0.1;\n    lightPos = vec3(3., 3.*sin(iTime), -4. + cos(iTime));\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    if(mousePos.x <= 0.01 && mousePos.y <= 0.01)\n        mousePos.y = 0.5;\n    camPos = vec3(cos(mousePos.x * 3.14 * 2.)*sin(mousePos.y * 3.14), -cos(mousePos.y * 3.14), sin(mousePos.x * 3.14 * 2.)*sin(mousePos.y * 3.14)) * 5. + vec3(0, 0, -5);\n    camDir = normalize(vec3(0, 0, -5) - camPos);\n    vec3 lol = camDir;\n    if(lol.y < 0.)\n        lol *= -1.;\n    lol.y = 0.;\n    camUp = normalize(cross(camDir, cross(camDir, lol))) * iResolution.y / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    /*\n    vec4 hitInfo = rt(camPos, rayDir(uv));\n    vec3 hit = hitInfo.xyz;\n    if(hitInfo.w != 0.)\n    {\n        vec4 lightHitInfo = rtl(lightPos, hit - lightPos, distance(hit, lightPos));\n        vec3 lightHit = lightHitInfo.xyz;\n        col = mix(vec3(1, 0.1, 0.2), vec3(0.4, 0.4, 0.2), distance(hit, vec3(0, 0, -5)) / 6.);\n        float light = 0.1;\n        light += 4. / distance(lightHit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)) * (1. / (1. + lightHitInfo.w * 100.)));\n        // light += 4. / distance(hit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)));\n        col *= light;\n        // col -= vec3(1.-light, 1.-light, 1.-light);\n    }\n    else\n    {\n        col = vec3(0, 0, 0); //texture(iChannel0, hit.xy / 5.0 - vec2(1, 1)).xyz;\n    }\n    */\n    vec3 gl = rtgl(camPos, rayDir(uv));\n    col.b += gl.x * 2.;\n    col.r += gl.y * 2.5;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd33z2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 346, 376, 376, 570], [572, 572, 593, 593, 663], [665, 665, 687, 687, 838], [840, 840, 904, 904, 1100], [1102, 1102, 1125, 1125, 2714], [2716, 2716, 2744, 2744, 2959], [2961, 2961, 2996, 2996, 3381], [3383, 3383, 3434, 3434, 3973], [3975, 3975, 4012, 4012, 5081], [5083, 5083, 5140, 5140, 6729]]}
{"id": "fscGz2", "name": "Stars with no for loops", "author": "TestCoder", "description": "stars", "tags": ["stars"], "likes": 3, "viewed": 383, "published": 3, "date": "1630165832", "time_retrieved": "2024-07-30T19:04:28.470956", "image_code": "float getSoftNoise(float x) {\n    float wave = sin(x / 32.)\n            + sin(x)\n            + cos(2. * x) / 2.\n            + sin(4. * x) / 4.\n            + sin(8. * x) / 8.\n            + sin(16. * x) / 16.\n            + sin(32. * x) / 32.;\n    return wave / 1000.;\n}\n\nfloat getStarSwitch(float x) {\n    float zoom = 1000000.;\n    float softNoise = getSoftNoise(x * zoom);\n    float density = .000001;\n\n    if (softNoise < 0. && softNoise > -density) {\n        return -softNoise * (1. / density) * sin(\n            iTime + sin(x * 50.) * 5.\n        );\n    }\n\n    return 0.;\n}\n\nfloat getStarPattern(vec2 uv) {\n    float voidSwitch = (\n        getStarSwitch(uv.x + cos(uv.x) * sin(uv.y)) +\n        getStarSwitch(uv.y + sin(uv.x) * cos(uv.y) / 20.)\n    );\n\n    return voidSwitch;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = getStarPattern(uv) * vec3(1, 1, 2);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscGz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 267], [269, 269, 299, 299, 575], [577, 577, 608, 608, 778], [780, 780, 835, 835, 1010]]}
{"id": "fscGR2", "name": "crate", "author": "yasuo", "description": "crate", "tags": ["crate"], "likes": 7, "viewed": 253, "published": 3, "date": "1630157526", "time_retrieved": "2024-07-30T19:04:29.274808", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n#define MATERIAL_DIFFUSE0 0\n#define MATERIAL_REFLECT 10\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat crateSide(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.11,0.11,0.005));\n    float d3 = max(-B3D(p,vec3(0.11,0.11,0.02)),B3D(p,vec3(0.13,0.13,0.015)));\n    p.xy = mod(p.xy,0.03)-0.015;\n    float d2 = B3D(p,vec3(0.01,0.01,0.02));\n    d = max(-d2,d);\n    d = min(d,d3);\n    \n    p = prevP;\n    d2 = B3D(p-vec3(0.0,-0.06,0.0),vec3(0.055,0.025,0.02));\n    d = max(-d2,d);\n    \n    return d;\n}\n\nfloat crateTop(vec3 p){\n    vec3 prevP = p;\n    float d = B3D(p,vec3(0.11,0.005,0.11));\n    p.xz = mod(p.xz,0.03)-0.015;\n    float d2 = B3D(p,vec3(0.01,0.02,0.01));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat crate(vec3 p){\n    vec3 prevP = p;\n    float dist = 0.115;\n    p.z = abs(p.z);\n    p.z -= dist;\n    float d = crateSide(p);\n    p = prevP;\n    p.xz *= Rot(radians(90.0));\n    p.z = abs(p.z);\n    p.z -= dist;\n    float d2 = crateSide(p);\n    d = min(d,d2);\n    p = prevP;\n    d2 = crateTop(p-vec3(0.0,0.12,0.0));\n    return min(d,d2);\n}\n\nfloat crateAll(vec3 p){\n    vec3 prevP = p;\n    \n    float d = crate(p-vec3(0.0,-0.125,0.0));\n    \n    p.x = abs(p.x);\n    p.x-=.225;\n    p.y+=0.125;\n    float d2 = crate(p);\n    d = min(d,d2);\n    p = prevP;\n    d2 = crate(p-vec3(0.0,0.125,0.0));\n    d = min(d,d2);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    p.x+=iTime*0.5;\n    p.x = mod(p.x,1.5)-0.75;\n    float d = crateAll(p);\n    vec2 res = vec2(d, MATERIAL_REFLECT);\n        \n    vec2 model = res;\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    float IOR = 1.6; //IOR:index of reflection\n    vec3 rdIn = refract(rd,n,1.0/IOR); \n    vec3 refTex = texture(iChannel0,rdIn).rgb;\n    return refTex;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 col) {\n    float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n    return vec3(dif)*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, 1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-20.0));    \n    \n    if(mod(iTime,20.0)<10.0){\n        ro.xz *= Rot(radians(-30.0));\n    } else {\n        ro.xz *= Rot(radians(0.0));\n    }\n    \n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.);\n    vec3 col = vec3(0.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        \n        int mat = int(d.y);\n        if(mat == MATERIAL_DIFFUSE0){\n            col = diffuseMaterial(n,vec3(1.0));\n        } else if(mat == MATERIAL_REFLECT) {\n            col = reflectMaterial(p,rd,n);\n        }\n\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 525, 525, 567], [569, 569, 596, 596, 650], [652, 652, 676, 676, 1056], [1058, 1058, 1081, 1081, 1258], [1260, 1260, 1280, 1280, 1601], [1603, 1603, 1626, 1626, 1885], [1887, 1887, 1909, 1909, 2103], [2105, 2105, 2150, 2150, 2410], [2412, 2412, 2436, 2436, 2637], [2639, 2639, 2686, 2686, 2841], [2843, 2843, 2885, 2885, 3080], [3082, 3082, 3122, 3122, 3205], [3207, 3207, 3264, 3264, 4176]]}
{"id": "fdcGRj", "name": " - Quicky#058", "author": "totetmatt", "description": "One logpolar is nice, but how about a second one ? ", "tags": ["logpolar"], "likes": 9, "viewed": 363, "published": 3, "date": "1630133339", "time_retrieved": "2024-07-30T19:04:30.022807", "image_code": "/*\n\n Blame @byt3_m3chanic for the abuse of LogPolar\n and djH0ffman for the overuse of good sounds :D \n \n Thanks folks !\n\n*/\n\n#define PI 3.141592\n#define fGlobalTime iTime\nvec2 logpol(vec2 uv){\n    return vec2(log((length(uv))),atan(uv.y,uv.x));\n }\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n    vec3 col;\n\n   \n  uv*=rot(fGlobalTime*.5);\n  \n  uv = -logpol(uv)*3.0;\n  \n  uv+=fGlobalTime*.5;\n  uv = asin(sin(uv));\n  \n\n  uv = logpol(uv)*3.5*.5; // A 2 c'est MIEUX :D \n\n  uv.x -=sqrt(texture(iChannel0,fract(vec2(.1))).r*10.)*2.+fGlobalTime*1.0;\n  uv.y +=pow(fGlobalTime,1.2);\n  vec2 id = floor(uv);\n  uv = fract(uv)*2.-1.;\n  float d = length(uv)-.35-sin(id.x*3.+id.y*4.)*.2;\n  d/=3.5;\n  d = smoothstep(fwidth(d),0.,d);\n  d = d+abs(uv.x)-.1;\n    d = smoothstep(fwidth(d),-0.01,d);\n   \n  col  = mod(length(floor(uv)),2.) == 0. ? 1.-vec3(d) :  vec3(d);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 27994, "src": "https://soundcloud.com/freestylers/black-blue-feat-blapps-posse", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 192, 192, 247], [248, 248, 266, 266, 313], [314, 314, 371, 421, 1070]]}
{"id": "7dt3zB", "name": "Hill Pattern", "author": "TestCoder", "description": "hill pattern", "tags": ["hillpattern"], "likes": 2, "viewed": 228, "published": 3, "date": "1630123321", "time_retrieved": "2024-07-30T19:04:30.884503", "image_code": "float getHillPattern(float x) {\n   return -(sin(-x)+2.)*log(abs(abs(mod(x,2.)) - 1.)) / 100.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n\n    // Time varying pixel color\n    vec3 col = (\n            getHillPattern((uv.x/uv.y+iTime/10.)*10.)\n    )*vec3(0,2,4);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 95], [97, 97, 154, 204, 428]]}
{"id": "7ddGzS", "name": "Turbulent cloud flythrough", "author": "jarble", "description": "A modified version of Shane's [url=https://www.shadertoy.com/view/Xsc3R4]\"Cheap Cloud Flythrough\"[/url] with some [url=https://www.shadertoy.com/view/7sc3z7]fake fluid physics[/url].", "tags": ["noise", "cloud", "volumetric", "turbulence", "turbulence", "sinusoidal", "flythrough"], "likes": 19, "viewed": 766, "published": 3, "date": "1630102945", "time_retrieved": "2024-07-30T19:04:31.842941", "image_code": "/*\n\n\tCheap Cloud Flythrough \n\t----------------------\n\t\n\t\"Cheap\" should probably refer to the quality of the physics in this shader, which is\n\tvirtually non-existent, but it actually refers to the fake cloud algorithm... if you could \n\tcall it that. :)\n\t\n\tThis is merely an attempt to give the impression of a cloud flythrough, whilst maintaining\t\n\ta reasonably acceptable framerate. The key to that is keeping the distance field as simple \n\tas possible.\n\n\tDue to the amount of cost cutting, it's far from  perfect. However, there's still plenty \n\tof room for improvement.\n\n    I've used density based accumulation, which in one way or another, uses concepts from many \n\tvolumetric examples, but particularly from the following:\n\t\n\tCloudy Spikeball - Duke\n    https://www.shadertoy.com/view/MljXDw\n    // Port from a demo by Las - Worth watching.\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n    \n    Other shaders worth looking at:\n\n\tClouds - IQ: One of my favorite shaders, and everyone elses, it seems.\n\thttps://www.shadertoy.com/view/XslGRr\n\t\t\n\tSample Pinning - huwb: Fast, and pretty.\n\thttps://www.shadertoy.com/view/XdfXzn\n\t\n\tFakeVolumetricClouds - Kuvkar: Fast, using parallax layers. Really cool.\n\thttps://www.shadertoy.com/view/XlsXzN\n\n    Emission clouds - Duke: Nice, and straight forward.\n    https://www.shadertoy.com/view/ltBXDm\n\n\n*/\n\n\n// IQ's texture lookup noise... in obfuscated form. There's less writing, so\n// that makes it faster. That's how optimization works, right? :) Seriously,\n// though, refer to IQ's original for the proper function.\n// \n// By the way, you could replace this with the non-textured version, and the\n// shader should run at almost the same efficiency.\nfloat pn( in vec3 p ){\n    \n    vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but sufficient for this example.\nfloat trigNoise3D(in vec3 p){\n\n    p /= 2.;\n    float res = 0., sum = 0.;\n    \n    // IQ's cheap, texture-lookup noise function. Very efficient, but still \n    // a little too processor intensive for multiple layer usage in a largish \n    // \"for loop\" setup. Therefore, just one layer is being used here.\n    float n = pn(p*8. + iTime*2.);\n\n\n    // Two sinusoidal layers. I'm pretty sure you could get rid of one of \n    // the swizzles (I have a feeling the GPU doesn't like them as much), \n    // which I'll try to do later.\n    \n    vec3 t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    p = p*1.5 + (t - 1.5); //  + iTime*0.1\n    res += (dot(t, vec3(0.333)));\n\n    t = sin(p.yzx*3.14159265 + cos(p.zxy*3.14159265+1.57/2.))*0.5 + 0.5;\n    res += (dot(t, vec3(0.333)))*0.7071;    \n\t \n\treturn ((res/1.7071))*0.85 + n*0.15;\n}\n\nvec3 fluid(vec3 uv1,float iters){\n //fake fluid physics\n vec3 uv = uv1;\n for (float i = 1.; i < iters; i++)\n  {\n    uv.x += sin((iTime-uv.y)*.5)*1.5/i* sin(i * uv.y + iTime * 0.5);\n    uv.y += sin((iTime-uv.z)*.5)*1.5/i* sin(i * uv.z + iTime * 0.5 );\n    uv.z += sin((iTime-uv.x)*.5)*1.5/i* sin(i * uv.x + iTime * 0.5 );\n  }\n  return uv;\n}\n\n// Distance function.\nfloat map(vec3 p,float iters) {\n    p = fluid(p,iters);\n    return trigNoise3D(p);\n    \n    // Three layers of noise, for comparison.\n    //p += iTime;\n    //return pn(p*.75)*0.57 + pn(p*1.875)*0.28 + pn(p*4.6875)*0.15;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n    // Unit direction ray vector: Note the absence of a divide term. I came across\n    // this via a comment Shadertoy user \"coyote\" made. I'm pretty easy to please,\n    // but I thought it was pretty cool.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.75)); \n    float t1 = iTime/2.;\n    // Ray origin. Moving along the Z-axis.\n    vec3 ro = vec3(0, 0, t1);\n\n    // Cheap camera rotation.\n    //\n    // 2D rotation matrix. Note the absence of a cos variable. It's there, but in disguise.\n    // This one came courtesy of Shadertoy user, \"Fabrice Neyret.\"\n    vec2 a = sin(vec2(1.5707963, 0) + t1*0.1875); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xy = rd.xy*rM; // Apparently, \"rd.xy *= rM\" doesn't work on some setups. Crazy.\n    rd.xz = rd.xz*rM;\n\n    // Placing a light in front of the viewer and up a little, then rotating it in sync\n    // with the camera. I guess a light beam from a flying vehicle would do this.\n    vec3 lp = vec3( 0, 1, 4);\n    lp.xy = lp.xy*rM;\n    lp.xz = lp.xz*rM;\n    lp += ro;\n\n    // The ray is effectively marching through discontinuous slices of noise, so at certain\n    // angles, you can see the separation. A bit of randomization can mask that, to a degree.\n    // At the end of the day, it's not a perfect process. Note, the ray is deliberately left \n    // unnormalized... if that's a word.\n    //\n    // Randomizing the direction.\n    //rd = (rd + ((rd.zyx)*.006 - .003)); \n    // Randomizing the length also. \n    rd *= (1. + fract((dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.06-0.03);      \n\n    // Local density, total density, and weighting factor.\n    float lDe = 0., td = 0., w = 0.;\n\n    // Closest surface distance, and total ray distance travelled.\n    float d = 1., t = 0.;\n\n    // Distance threshold. Higher numbers give thicker clouds, but fill up the screen too much.    \n    const float h = .5;\n\n\n    // Initializing the scene color to black, and declaring the surface position vector.\n    vec3 col = vec3(0), sp;\n\n\n\n    // Particle surface normal.\n    //\n    // Here's my hacky reasoning. I'd imagine you're going to hit the particle front on, so the normal\n    // would just be the opposite of the unit direction ray. However particles are particles, so there'd\n    // be some randomness attached... Yeah, I'm not buying it either. :)\n    vec3 sn = normalize(-rd);\n\n    // Raymarching loop.\n    for (int i=0; i<64; i++) {\n\n        // Loop break conditions. Seems to work, but let me\n        // know if I've overlooked something.\n        if((td>1.) || d<.01*t || t>80.)break;\n\n\n        sp = ro + rd*t; // Current ray position.\n        d = map(sp,15.-d*15.); // Closest distance to the surface... particle.\n\n        // If we get within a certain distance, \"h,\" of the surface, accumulate some surface values.\n        // The \"step\" function is a branchless way to do an if statement, in case you're wondering.\n        //\n        // Values further away have less influence on the total. When you accumulate layers, you'll\n        // usually need some kind of weighting algorithm based on some identifying factor - in this\n        // case, it's distance. This is one of many ways to do it. In fact, you'll see variations on \n        // the following lines all over the place.\n        //\n        lDe = (h - d)*step(d, h); \n        w = (1. - td)*lDe;   \n\n        // Use the weighting factor to accumulate density. How you do this is up to you. \n        td += w*w*8. + 1./64.; //w*w*5. + 1./50.;\n        //td += w*.4 + 1./45.; // Looks cleaner, but a little washed out.\n\n\n        // Point light calculations.\n        vec3 ld = lp-sp; // Direction vector from the surface to the light position.\n        float lDist = max(length(ld), .001); // Distance from the surface to the light.\n        ld/=lDist; // Normalizing the directional light vector.\n\n        // Using the light distance to perform some falloff.\n        float atten = 1./(1. + lDist*.125 + lDist*lDist*.05);\n\n        // Ok, these don't entirely correlate with tracing through transparent particles,\n        // but they add a little anglular based highlighting in order to fake proper lighting...\n        // if that makes any sense. I wouldn't be surprised if the specular term isn't needed,\n        // or could be taken outside the loop.\n        float diff = max(dot( sn, ld ), 0.);\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 4.);\n\n\n        // Accumulating the color. Note that I'm only adding a scalar value, in this case,\n        // but you can add color combinations. Note the \"d*3. - .1\" term. It's there as a bit\n        // of a fudge to make the clouds a bit more shadowy.\n        col += w*(d*3. - .1)*(.5 + diff + spec*.5)*atten;\n\n        // Try this instead, to see what it looks like without the fake contrasting. Obviously,\n        // much faster.\n        //col += w*atten*1.25;\n\n\n        // Enforce minimum stepsize. This is probably the most important part of the procedure.\n        // It reminds me a little of of the soft shadows routine.\n        t +=  max(d*.5, .02); //\n        // t += .2; // t += d*.5;// These also work, but don't seem as efficient.\n\n    }\n\n    col = max(col, 0.);\n\n    // trigNoise3D(rd*1.)\n    col = mix(pow(vec3(1.5, 1, 1)*col,  vec3(1, 2, 8)), col, dot(cos(rd*6. +sin(rd.yzx*6.)), vec3(.333))*.35 + .65);\n    col = mix(col.zyx, col, dot(cos(rd*9. +sin(rd.yzx*9.)), vec3(.333))*.15 + .85);//xzy\n    \n\n    //col = mix(col.zyx, col, dot(rd, vec3(.5))+.5);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1370, 1716, 1738, 1738, 1906], [1910, 2058, 2087, 2087, 2907], [2909, 2909, 2942, 2964, 3248], [3250, 3272, 3303, 3303, 3493], [3495, 3495, 3552, 3762, 9063]]}
{"id": "Nsd3DH", "name": "path marching scene", "author": "sirjofri", "description": "my first path tracing test with a larger scene. Please don't kill me, I'm just learning.\n\nUse mouse.x to control blur strength.", "tags": ["pathtracing"], "likes": 1, "viewed": 159, "published": 3, "date": "1630091066", "time_retrieved": "2024-07-30T19:04:32.891138", "image_code": "vec2 uv;\nfloat dev;\n\nfloat rand(vec2 n)\n{\n    return fract(sin(dot(n, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvec3 tex(vec2 t)\n{\n    t.y *= iResolution.x/iResolution.y;\n    t *= dev;\n    return texture(iChannel0, uv+t).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.xy;\n    \n    vec4 t = texture(iChannel0, uv);\n    float fd = t.a;\n    float dt = sin(iTime*2.5)*.5+5.5; // focus distance\n    float pd = fd - dt;\n    float r = rand(vec2(iTime, float(iFrame)*45.753)+uv*345.54);\n    dev = min(pd*.001+r*.001, .003);\n    vec3 oimg = t.rgb;\n    \n    // distance-based depth of field\n    vec3 a = tex(vec2(-1., -1.));\n    vec3 b = tex(vec2(0., -1.));\n    vec3 c = tex(vec2(1., -1.));\n    vec3 d = tex(vec2(-1., 0.));\n    vec3 e = tex(vec2(1., 0.));\n    vec3 f = tex(vec2(-1., 1.));\n    vec3 g = tex(vec2(0., 1.));\n    vec3 h = tex(vec2(1., 1.));\n    \n    vec3 j = (a+b+c+d+e+f+g+h)/8.;\n\n    fragColor = vec4(mix(oimg, j, iMouse.x/iResolution.x), fd);\n    //fragColor = vec4(vec3(abs(dev*10.)), 1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define bounces 5\n#define maxsteps 400\n#define maxdist 0.00001\n\n#define Msky     0\n#define Mred     1\n#define Mfloor   2\n#define Mblue    3\n#define Mmirror  4\n#define Mwall    5\n#define Mlight   6\n\nstruct M {\n    int materialID;\n    float dist;\n};\n\nstruct Mat {\n    float refl;\n    vec3 bc;\n};\n\nvec3 rotation = vec3(0.);\nvec2 ouv;\nvec3 campos;\nfloat depth = 0.;\n\n/* stolen: https://www.shadertoy.com/view/Md2BWW */\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udQuad(vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 p)\n{\n    #if 1\n    // handle ill formed quads\n    if( dot( cross( v2-v1, v4-v1 ), cross( v4-v3, v2-v3 )) < 0.0 )\n    {\n        vec3 tmp = v3;\n        v3 = v4;\n        v4 = tmp;\n    }\n    #endif\n\n    \n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                            dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                       min( dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3),\n                            dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) ))\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) ) -.01;\n}\n\nfloat rand(vec2 n)\n{\n    return fract(sin(dot(n, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvec3 rvec(vec3 wp)\n{\n    float t = rand(vec2(iTime, float(iFrame)*45.753));\n    float u = rand(vec2(float(iFrame)*3.6428, iTime));\n    vec2 v = vec2(t, u);\n    return normalize(vec3(\n        rand(wp.xy+v),\n        rand(wp.yz+v),\n        rand(wp.zx+v)\n    )*2.-1.);\n}\n\nvec3 rotate(vec3 p)\n{\n    mat3 yaw = mat3(\n        cos(rotation.x), -sin(rotation.x), 0.,\n        sin(rotation.x),  cos(rotation.x), 0.,\n        0.      ,  0.      , 1.\n    );\n    mat3 pitch = mat3(\n        1.,       0.,        0.,\n        0., cos(rotation.y), -sin(rotation.y),\n        0., sin(rotation.y),  cos(rotation.y)\n    );\n    mat3 roll = mat3(\n         cos(rotation.z), 0., sin(rotation.z),\n               0., 1.,       0.,\n        -sin(rotation.z), 0., cos(rotation.z)\n    );\n    \n    p *= roll;\n    p *= pitch;\n    p *= yaw;\n    return normalize(p);\n}\n\nfloat t_floor(vec3 wp)\n{\n    return textureLod(iChannel1, wp.xy*vec2(.3, .5)*1.5, distance(campos, wp)*.15).r;\n}\n\nMat getMaterial(int mID, vec3 wp)\n{\n    switch(mID){\n    case Msky: // sky\n        return Mat(0., mix(vec3(.2, .1, .05), vec3(.9, .9, 1.), clamp(wp.z/100., 0., 100.))*150.);\n    case Mred: // red sphere\n        return Mat(0.2, vec3(0.9, 0.5, 0.4));\n    case Mfloor: // floor\n        float d = t_floor(wp);\n        return Mat(d*.35, vec3(0.8, 0.8, 0.8)*pow(d, .3));\n    case Mblue: // blue sphere\n        return Mat(.8, vec3(.5, .5, 1.));\n    case Mmirror: // mirror sphere\n        return Mat(.9, vec3(1.));\n    case Mwall: // wall material\n        return Mat(0.2, vec3(1., 1., 0.9));\n    case Mlight: // light material\n        return Mat(0., vec3(1., 1., .9)*100.);\n    }\n    return Mat(0., vec3(0.));\n}\n\nM sdSphere(vec3 p, vec3 pos, float r, int m)\n{\n    M ret;\n    ret.dist = distance(p, pos) - r;\n    ret.materialID = m;\n    return ret;\n}\n\nM sdQuad( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, in vec3 p, in int m)\n{\n    M ret;\n    ret.dist = udQuad(v1, v2, v3, v4, p);\n    ret.materialID = m;\n    return ret;\n}\n\nM opUnion(M a, M b)\n{\n    if (a.dist < b.dist)\n        return a;\n    return b;\n}\n\nM PleftWall(vec3 p)\n{\n    vec3 front_p = vec3(-1.2, -8., 3.);\n    vec3 rear_p = vec3(-2., 6., 3.);\n    M front = sdQuad(\n        vec3(front_p.x, front_p.y, -.5),\n        vec3(front_p.x, -1.5, -.5),\n        vec3(front_p.x, -1.5, front_p.z),\n        vec3(front_p.x, front_p.y, front_p.z),\n        p, Mwall);\n    M rear = sdQuad(\n        vec3(rear_p.x, rear_p.y, -.5),\n        vec3(rear_p.x, -1.5, -.5),\n        vec3(rear_p.x, -1.5, rear_p.z),\n        vec3(rear_p.x, rear_p.y, rear_p.z),\n        p, Mwall);\n    return opUnion(front, rear);\n}\n\nM PrightWall(vec3 p)\n{\n    vec3 front_p = vec3(2., 6., 3.);\n    M front = sdQuad(\n        vec3(front_p.x, front_p.y, 0.),\n        vec3(front_p.x, -8., 0.),\n        vec3(front_p.x, -8., front_p.z),\n        vec3(front_p.x, front_p.y, front_p.z),\n        p, Mwall);\n    return front;\n}\n\nM Proof(vec3 p)\n{\n    float z = 3.;\n    M roof = sdQuad(\n        vec3(-2., -8., z),\n        vec3(-2., 6., z),\n        vec3(2., 6., z),\n        vec3(2., -8., z),\n        p, Mwall);\n    return roof;\n}\n\nM Plights(vec3 p)\n{\n    M l1 = sdSphere(p, vec3(1., 2., 3.), .1, Mlight);\n    M l2 = sdSphere(p, vec3(1.3, 0., 0.6), 0.05, Mlight);\n    return opUnion(l1, l2);\n}\n\nM map(vec3 p)\n{\n    M sky = sdSphere(p, vec3(0.), 200., Msky);\n    sky.dist *= -1.;\n    M ground = sdSphere(p, vec3(0., 0., -1000.), 1000., Mfloor);\n    ground.dist -= t_floor(p)*.02;\n    M sph1 = sdSphere(p, vec3(0., 0., 1.)+sin(p.z*30.)*.01*abs(p.x), 1., Mred);\n    M sph2 = sdSphere(p, vec3(0.5, -.5, .5), .5, Mblue);\n    M sph3 = sdSphere(p, vec3(.7, -1.1, .1), .1, Mmirror);\n    M sph = opUnion(opUnion(sph1, sph2), sph3);\n    M walls = opUnion(Proof(p), opUnion(PleftWall(p), PrightWall(p)));\n    M light = Plights(p);\n    return opUnion(light, opUnion(walls, opUnion(sky, opUnion(ground, sph))));\n}\n\nM march(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    for (int i=0; i<maxsteps; i++){\n        M n = map(ro + rd*d);\n        d += n.dist;\n        if (n.dist < maxdist){\n            n.dist = d;\n            return n;\n        }\n    }\n}\n\nvec3 normal(vec3 wp)\n{\n    float s = .0001;\n    float c = map(wp).dist;\n    float x = map(wp+vec3(s, 0., 0.)).dist;\n    float y = map(wp+vec3(0., s, 0.)).dist;\n    float z = map(wp+vec3(0., 0., s)).dist;\n    return normalize(vec3(x-c, y-c, z-c));\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(1.);\n    vec3 wp = ro;\n    vec3 nrd = rd;\n    float fulld = 0.;\n    int i;\n    for (i=0; i<bounces; i++){\n        M m = march(wp+nrd*0.00015, nrd);\n        fulld += m.dist;\n        if (i == 0)\n            depth = m.dist;\n        wp += nrd*m.dist;\n        Mat mat = getMaterial(m.materialID, wp);\n        col *= mat.bc;\n        if (length(mat.bc) > 10.)\n            return col/fulld;\n        if (length(wp) > 150.0)\n            return col/fulld;\n        vec3 n = normal(wp);\n        float r = mat.refl;\n        nrd = mix(rvec(wp), reflect(nrd, n), r);\n        float dit = dot(nrd, n);\n        if (dit < 0.)\n            return vec3(-1.);\n    }\n    return col/fulld;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    ouv = uv;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0., -6., 2.);\n    campos = ro;\n    rotation = vec3(0., -.2, 0.);\n    vec3 rd = mix(rotate(normalize(vec3(uv.x, 2., uv.y))), rvec(vec3(iTime, float(iFrame)*.0001, ro.z)), 0.0001);\n    \n    M ms = march(ro, rd);\n\n    vec3 col = render(ro, rd);\n    vec3 ocol = texture(iChannel0, ouv).rgb;\n    if (col.x < 0.) // discard swallowed rays\n        discard; //col = ocol;\n    if (distance(col, ocol) > 50.) // noise reduction: filter out extremes\n        discard; //col = ocol;\n    vec3 ncol = mix(ocol, col, 0.01);\n\n    fragColor = vec4(ncol, depth);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float f(vec2 uv)\n{\n    uv.x += floor(uv.y)*.5;\n    vec2 mn = smoothstep(0.52, .5, 1.-abs(mod(uv, 1.)-.5));\n    float n = 1.-max(mn.x, mn.y);\n    return clamp(n, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.;\n    vec3 n = vec3(f(uv));\n    \n    // high quality, but with much more noise\n#if 0\n    n -= texture(iChannel0, uv).r*.1;\n#endif\n    fragColor = vec4(n, 1.0);\n}", "buffer_b_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsd3DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 41, 41, 108], [110, 110, 128, 128, 225], [227, 227, 284, 284, 1046]]}
{"id": "Ndt3zS", "name": "2d light test pt", "author": "pema99", "description": "move mouse on screen\n\nback at it again with the frame killers\n\na moment of silence for anyone viewing on mobile", "tags": ["gi"], "likes": 14, "viewed": 448, "published": 3, "date": "1630075318", "time_retrieved": "2024-07-30T19:04:33.764803", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n    fragColor.xyz /= fragColor.a;\n    \n    fragColor.x = pow(fragColor.x, 1.0/2.2);\n    fragColor.y = pow(fragColor.y, 1.0/2.2);\n    fragColor.z = pow(fragColor.z, 1.0/2.2);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define EPS 0.001\n#define BOUNCES 3\n#define SPP 16\n\nvec2 mouse = vec2(0.8, -0.4);\n\nfloat sdSphere(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\n// from iq\nfloat udSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 2.0 );\n    return length(pa-h*ba);\n}\n\nvec3 emission = vec3(0.);\nfloat map(vec2 p)\n{\n    emission = vec3(0.0);\n    \n    // solids\n    float d1 = sdSphere(p - vec2(0.3, 0.3), 0.3);\n    float d2 = sdSphere(p - vec2(-0.25, -0.2), 0.25);\n    d2 = min(d2, udSegment(p, vec2(-0.25, -0.2), vec2(-0.25, -1.0))-0.02);\n    d2 = min(d2, udSegment(p, vec2(1.0, 1.0), vec2(1.1, 0.5))-0.02);\n    \n    // boundary walls\n    float wall = min(\n        min(p.y+1.0, 1.0-p.y), \n        min(p.x + iResolution.x/iResolution.y, iResolution.x/iResolution.y - p.x));\n    \n    float solid = min(d1, min(d2, wall));\n    \n    // light\n    float d4 = udSegment(p, mouse.xy+vec2(-p.y, p.x)*0.1, mouse.xy-vec2(-p.y, p.x)*0.1) - 0.01;//sdSphere(p - mouse, 0.1);\n    float d5 = sdSphere(p + vec2(1.0, 0.0), 0.1);\n    float light = min(d4, d5);\n    if (light < solid)\n    {\n        if (d4 < d5) emission = vec3(0.0, 0.4, 0.0);\n        else emission = vec3(0.8, 0.0, 0.0);\n    }\n    \n    return min(solid, light);\n}\n\nfloat march(vec2 ro, vec2 rd)\n{\n    float t = 0.;\n    vec2 p = vec2(0.);\n    for (int i; i < 50; i++)\n    {        \n        p = ro + t * rd;\n        float dist = map(p);\n        if (dist < EPS) break;\n        t += dist;\n    }\n    return t;\n}\n\nvec2 normal(vec2 p)\n{\n    vec2 o = vec2(EPS, 0.);\n    return normalize(vec2(\n        map(p + o.xy) - map(p - o.xy),\n        map(p + o.yx) - map(p - o.yx)\n    ));\n}\n\nvec3 trace(vec2 ro)\n{\n    vec3 col = vec3(0.);\n    for (int i = 0; i < SPP; i++)\n    {        \n        vec3 final = vec3(0.);\n        \n        float ang = fract(float(i) / float(SPP) + float(iFrame)/600.0) * 6.28;\n        vec2 tro = ro, trd = vec2(cos(ang), sin(ang));\n        for (int j = 0; j < BOUNCES; j++)\n        {\n            float dist = march(tro, trd);\n\n            if (emission.x > 0. || emission.y > 0. || emission.z > 0.)\n            {\n                final = emission;\n                break;\n            }\n            else\n            {\n                vec2 hit = tro + dist * trd;\n                vec2 norm = normal(hit);\n                \n                tro = hit + norm * EPS;\n                trd = reflect(trd, norm);\n            }\n        }\n        \n        col += final;\n    }\n    return col / float(SPP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup uvs, mouse\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (ouv-0.5)*2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    if (iMouse.xy != vec2(0.))\n    {\n        mouse = (iMouse.xy/iResolution.xy-0.5)*2.0;\n        mouse.x *= iResolution.x/iResolution.y;\n    }\n    \n    // pt\n    vec3 col = vec3(0.);\n    if (map(uv) < 0.)\n        col = emission;\n    else\n        col = trace(uv);\n        \n    vec4 buf = iMouse.z > 0.0 ? vec4(0.) : texture(iChannel0, ouv);\n    \n    fragColor = vec4(col, 1.0) + buf;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 316]]}
{"id": "NlXSDr", "name": "Israel's Flag", "author": "Pelegefen", "description": "It's israel's flag drawn in a shader.", "tags": ["flag", "israel"], "likes": 10, "viewed": 386, "published": 3, "date": "1630073820", "time_retrieved": "2024-07-30T19:04:34.643453", "image_code": "//music link -  https://soundcloud.com/sajankamusic/sajanka-sun-is-coming\n\n//#define DANCING; //uncomment to make the flag dance to the music( By Sajanka, an isreali artist, hence the flag)\n\n\n\n#define WHITE vec3(255,255,255)/255.\n#define BLUE vec3(0,56,184)/255.\n#define PI 3.14159265359\n#define S smoothstep \n\n\n\nfloat StarOfDavid(vec2 uv, float size){\n\n    uv *= size;\n    uv.x = abs(uv.x);\n    uv.y *= 1.4;\n    float a = 1.08;\n    float a2 = 4.286389;\n    float a3 = 2.03;\n    \n    float offs = .1;\n    float d1 = S(-.501,-.50,dot(uv , vec2(0.,1.05 - offs)));\n    float d2 = S(.541,.54,dot(uv , vec2(sin(a),cos(a))));\n    \n    float d11 = S(-.001-offs,-.00-offs,dot(uv , vec2(0.,0.4 - offs)));\n    float d12 = S(.501-offs,.50-offs,dot(uv, vec2(sin(a),cos(a))));\n    \n    float d3 = S(.501,.50,dot(uv, vec2(sin(a3),cos(a3))));\n    float d4 = S(.501,.50,dot(uv , vec2(0.,.8)));\n    \n     float d21 = S(.001+offs,.00+offs,dot(uv , vec2(0.,0.33 - offs)));\n     float d22 =  S(.251+offs,.250+offs,dot(uv, vec2(sin(a3),cos(a3))));\n     \n    float m1 = min(d1,d2);\n    \n    float m11 = min(d11,d12);\n    m1 -= m11;\n    \n    \n    float m2 = min(d4,d3);\n    \n    float m21 = min(d21,d22);\n    m2 -= m21;\n    \n    //if(uv.x>=0. && uv.x <= .01)col = vec3(1.,0.,0.);\n     //if(uv.y>=0. && uv.y <= .01)col = vec3(1.,0.,0.);\n     float s = max(m1, m2);\n     \n  return s; \n   }\n   \n   \n   vec3 Flag(vec2 uv){\n    //blue stripes\n    uv *= 1.5;\n    vec2 st = uv;\n    uv.x *= 1.2;\n    st.y = abs(st.y);\n    \n    \n    float s = S(0.41,.4,abs(st.y));\n    s  -= S(0.26,.25,abs(st.y));\n    vec3 nCol = mix(WHITE,BLUE,s);\n    vec3 col = vec3(nCol);\n\n    \n    float star = StarOfDavid(uv,4.);\n    vec3 cstar =  mix(col, BLUE,star);\n    \n    \n    cstar *= S(0.01,0.,abs(uv.y)-.5+0.012);\n     //cstar *= S(0.01,0.,abs(uv.y)-.5+0.01);\n    return cstar;\n    \n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // unNormalized pixel coordinates (from -.5 to .5)\n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;    \n    \n   # ifdef DANCING\n   float freq = texture( iChannel0, vec2( 0.01, 0.01 ) ).x; \n   float freq1 = texture( iChannel0, vec2( 0.15, 0.15 ) ).x; \n   #else\n   float freq = .5; \n   float freq1 = .5; \n   #endif\n   \n   \n    float t = sin(iTime + sin(iTime + (uv.x  - uv.y))*5.5+5.5)*(.03 );\n    \n    uv.y -= clamp(t / max(freq ,.1),-.5,.5) ;\n    uv.x -= clamp(t / max(freq1,.1),-.5,.5) ;\n    \n    \n    float sd = cos(iTime + sin(iTime + (uv.x - uv.y ))*5.5+5.5)*(.3 );\n    vec3 col = vec3(Flag(uv)) -clamp( sd,0.,1. );\n   \n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,(col.r + col.g + col.b)/3.);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXSDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 352, 352, 1364], [1376, 1376, 1395, 1414, 1838], [1839, 1839, 1896, 1951, 2635]]}
{"id": "NdlXRS", "name": "Beer Bottle Sdf", "author": "Pelegefen", "description": "nothing much, just an sdf that returns a beer bottle i had laying around and tried modeling.\nplanning on making a scene in a bar later using this with random attributes.", "tags": ["3d", "raymarching", "sdf"], "likes": 2, "viewed": 291, "published": 3, "date": "1630068469", "time_retrieved": "2024-07-30T19:04:35.540056", "image_code": "#define MAX_STEPS 100.\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n\n\n\nfloat seed = 22155.;\nfloat GetDist(vec3 p) {\n\n    \n    float d  = 1.;\n    //Bar goes here lol\n    \n    //float sdBeerBottle(vec3 p, float width, float highet, float neckS, float lip, float labelS){\n    float t = floor(iTime*.8);\n    float h = hash11(t);\n        float h1 = hash11(t+214312.);\n    float h2 = hash11(floor(t+2142.));\n    float h3 = hash11(floor(t+12431.));\n    float h4 = hash11(floor(t+21334.));\n\n    d = sdBeerBottle(p,\n    \n    h * .2,\n    //^ float width,\n    \n    h1* .2,\n    //^ float highet,\n    \n    h2,\n    //^ float neckS,\n    \n    h3* .8,\n    //^ float lip,\n    \n    h4\n    //^ float labelSh, \n    \n    )\n    ;\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\t\n    float dv =0.;\n    float dO=dv;\n    \n    \n    for(float i=0.; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n \n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    dv = dO;\n    return dv;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 2, -5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,1.0,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n    float glow = 0.;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(.1,dif*.5,.1);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "float hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\nfloat Union( float d1, float d2 ) { return min(d1,d2); }\n\nfloat Sub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat Intrs( float d1, float d2 ) { return max(d1,d2); }\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n\n\treturn length(p ) - s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBeerBottle(vec3 p, float width, float highet, float neckS, float lip, float labelS){\n  float d  = 1.;\n  float body = sdRoundedCylinder(p, .35 + width,.8,0.7 - highet);\n    \n\n\n    float neck = sdRoundedCylinder(p - vec3(0,1.0 + highet,0),.25+ width ,.32,1.4+ highet);\n    neck += p.y * .1;\n    \n    float nb = body+neck;\n   \n    \n    \n    float mp = sdRoundedCylinder(p - vec3(0,2.35+ highet,0),.14+ width ,.04,0.08)*.8; //mouthpiece\n    float mph = sdRoundedCylinder(p - vec3(0,2.35+ highet,0),.12+ width,.1,2.38) * .8; //mouthpiece hole\n    mp -= abs(p.y - (2.4+ highet)) *.2 ;//shaping the mouthpiece\n    d = min(nb , min(neck,mp));\n    d = max(d,-p.y - .7);\n    \n    \n    \n    float elp = sdEllipsoid(p - vec3(0,-.7,0)  ,vec3(.5 + width,.1,.5 + width));\n    \n    float label = sdCappedCylinder(p- vec3(0,.3,0), 0.65- width,0.7- highet);\n    label = label * 1.4 + neck;\n    d = Sub (elp,d);\n    d = min(d,label);\n    \n    d = min(label * .5,d);\n    d = Sub(mph,d) ;\n\n    \n    d *= .9;\n    return d;\n   \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdlXRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 154, 154, 762], [764, 764, 798, 798, 1064], [1066, 1066, 1090, 1090, 1280], [1282, 1282, 1332, 1332, 1523], [1525, 1525, 1582, 1582, 2219]]}
{"id": "fsd3Dn", "name": "RGB Sludge", "author": "Pelegefen", "description": "some noise blending using fbms and iq's fbm pattern function, modified for my needs.", "tags": ["noise", "value", "generation", "landmass"], "likes": 5, "viewed": 348, "published": 3, "date": "1630067519", "time_retrieved": "2024-07-30T19:04:36.384797", "image_code": "float hash(vec2 p) \n{\n    p  = 50.0*fract( p*0.132151241 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )// thanks to iq\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat pattern( in vec2 p )\n{\n    vec2 q = vec2( noise( p + vec2(0.0,0.0) ),\n                   noise( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( noise( p + 8.0*q + vec2(1.7,9.2) ),\n                   noise( p + 8.0*q + vec2(8.3,2.8) ) );\n\n    return noise( p + 4.0*r );\n}\nvec4 Terrain(vec2 uv){\n\nvec2 ms = (iMouse.xy / iResolution.xy);\nfloat mousePos = length(ms);\nfloat f = 0.0;\n   \n       \tuv *= 5.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( (uv- ms)- iTime ); uv = m*uv;\n\t\tf += 0.2500*noise( (uv+ ms)+ iTime ); uv = m*uv;\n\t\tf += 0.1250*noise( (uv- ms)- (iTime * .25) ); uv = m*uv;\n\t\tf += 0.0625*noise( (uv+ ms) + (iTime * .5)); uv = m*uv;\n        f = ((fract(uv.y * uv.x + iTime)+f ));\n     \n        \n        \n      vec4 landCol = vec4(\n       sin(f*.75+ iTime)*.5+.5,\n       sin(f- iTime)   *.5+.5,\n       sin(f*.1  + iTime)*.5+.5,\n       1.);\n       \n       //landCol *= vec4(.1 + f,.7+ f,.9,1.);\n       \n       \n       vec4 colorLand = vec4(landCol + pow(f , smoothstep(.2,.21,f)));\n       float b = smoothstep(.05,.08,f);\n       float c = smoothstep(.1,.2,f);\n      float d = smoothstep(.25,.3,f);\n       vec4 color = vec4(f); \n       \n      // float  iTime = iTime - 200000.;\n        color = max(color , colorLand );\n       return color - (c * d * b) * max(pattern((uv-iTime) *.04), pattern((uv+iTime) *.04));\n       \n       }\n       \n       \n       \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3 col;\n     vec2 p = fragCoord.xy / iResolution.xy;\n    vec4 color;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0)+ 1000. ;\n\tuv -= (iMouse.xy / iResolution.xy);\n        color = Terrain(uv*1.) ;\n\n    //vignnette\n    color -= length((p*vec2(iResolution.x/iResolution.y,1.0)-vec2(.85,.5))*2.);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsd3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 127], [129, 129, 170, 170, 464], [465, 465, 493, 493, 736], [737, 737, 759, 759, 1827], [1852, 1852, 1909, 1909, 2238]]}
{"id": "7sc3zB", "name": "Pixelization Blur", "author": "stoman", "description": "Blur the right side of your webcam!", "tags": ["blur"], "likes": 2, "viewed": 439, "published": 3, "date": "1630064074", "time_retrieved": "2024-07-30T19:04:37.152744", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int blurSize = 10;\n    \n    if(fragCoord.x < iResolution.x/2.0) {\n        blurSize = 1;\n    }\n\n    vec2 coord = fragCoord - mod(fragCoord, vec2(float(blurSize), float(blurSize)));\n    fragColor = texture(iChannel0, coord/iResolution.xy);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 301]]}
{"id": "ss33zB", "name": "Right Box Blur", "author": "stoman", "description": "Blur the right side of your webcam!", "tags": ["blur"], "likes": 1, "viewed": 299, "published": 3, "date": "1630063253", "time_retrieved": "2024-07-30T19:04:37.914707", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int blurSize = 5; // take that many pixels in each direction, so (blurSize+1)^2 pixels total\n    \n    if(fragCoord.x < iResolution.x/2.0) {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    }\n    else {\n        fragColor = vec4(0,0,0,0);\n        for(int x = -blurSize; x <= blurSize; x++) {\n            for(int y = -blurSize; y <= blurSize; y++) {\n                vec2 coord = fragCoord + vec2(float(x), float(y));\n                fragColor += texture(iChannel0, coord/iResolution.xy) / pow(float(2*blurSize+1), 2.0);\n            }\n        }\n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss33zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 631]]}
{"id": "7dcGzB", "name": "Webcam Demo", "author": "stoman", "description": "Yourself in a grid, but without colors!", "tags": ["tutorial"], "likes": 5, "viewed": 346, "published": 3, "date": "1630062853", "time_retrieved": "2024-07-30T19:04:38.679661", "image_code": "vec4 grayscale(vec4 c) {\n  float v = (c.x + c.y + c.z) / 3.0;\n  return vec4(v, v, v, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float copies = 5.0;\n\n    fragColor = grayscale(texture(iChannel0, mod(uv, 1.0 / copies) * copies));\n    \n    // Printing the webcam 1:1 works like this:\n    // fragColor = texture(iChannel0, uv)\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 92], [94, 94, 151, 151, 392]]}
{"id": "7sc3RB", "name": "Pentakis Reflections", "author": "dr2", "description": "Reflections from spheres on surface of pentakis dodecahedron", "tags": ["dodecahedron", "symmetry"], "likes": 13, "viewed": 289, "published": 3, "date": "1630061412", "time_retrieved": "2024-07-30T19:04:39.447608", "image_code": "// \"Pentakis Reflections\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nint idObj;\nbool isRefl;\nconst float pi = 3.1415927;\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 t;\n  float dMin, d, a1, a2, rEx, s;\n  rEx = 3.;\n  dMin = dstFar;\n  t = vec2 (0.365, -1.);\n  q = DodecSym (p);\n  a1 = 0.5 * acos (-1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  d = length (q) - rEx;\n  d = SmoothMax (d, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.04, 0.04);\n  DMIN (1);\n  s = - dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi)));\n  q.yz -= t * 0.82 * rEx;\n  d = length (q) - 0.17 * rEx;\n  d = max (s - 0.91 * rEx, - d);\n  DMIN (1);\n  q.yz -= t * 0.05 * rEx;\n  if (! isRefl) { \n    d = length (q) - 0.16 * rEx;\n    DMIN (2);\n  }\n  q.yz -= t * 6. * rEx;\n  d = length (q) - rEx;\n  DMIN (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjCol (vec3 rd, vec3 vn)\n{\n  vec4 col4;\n  vec3 col;\n  if (idObj == 1) col4 = vec4 (0.7, 0.5, 0., 0.2);\n  else if (idObj == 2) col4 = vec4 (0.6, 0.6, 0.7, 0.5);\n  else if (idObj == 3) col4 = vec4 (1., 0., 0., -1.);\n  if (col4.a >= 0.) col = col4.rgb * (0.1 + 0.2 * max (- dot (vn, ltDir), 0.) +\n     0.8 * max (dot (vn, ltDir), 0.)) + col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  else col = col4.rgb * (0.2 + 0.8 * max (- dot (vn, rd), 0.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, vn;\n  float dstObj;\n  isRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = ObjCol (rd, vn);\n    if (idObj == 2) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      isRefl = true;\n      dstObj = ObjRay (ro, rd);\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        vn = ObjNf (ro);\n        colR = ObjCol (rd, vn);\n      } else colR = vec3 (0.1, 0.1, 0.2);\n      col = mix (col, colR, 0.7);\n    }\n  } else col = vec3 (0.1, 0.1, 0.2);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.03 * pi * tCur;\n    el -= 0.1 * pi * sin (0.02 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -18.);\n  zmFac = 5.;\n  dstFar = 50.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3RB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[520, 520, 544, 544, 1095], [1097, 1097, 1119, 1119, 1847], [1849, 1849, 1882, 1882, 2066], [2068, 2068, 2089, 2089, 2344], [2346, 2346, 2378, 2378, 2826], [2828, 2828, 2863, 2863, 3434], [3478, 3478, 3534, 3534, 4568], [4570, 4570, 4603, 4603, 4630], [4632, 4632, 4677, 4677, 4769], [4771, 4771, 4816, 4816, 4854], [4856, 4856, 4892, 4892, 5098], [5100, 5100, 5130, 5130, 5243], [5245, 5245, 5276, 5276, 5340]]}
{"id": "sdcGRB", "name": "Bad Mandelbrot", "author": "stoman", "description": "Learning how to draw the Mandelbrot set.", "tags": ["tutorial"], "likes": 0, "viewed": 200, "published": 3, "date": "1630057626", "time_retrieved": "2024-07-30T19:04:40.411032", "image_code": "vec2 complexSquare(vec2 v) {\n  return vec2(v.x*v.x-v.y*v.y, 2.0*v.x*v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - vec2(-0.5, 0.5)) / iResolution.x * 50.0/(exp(iTime)+50.0);\n    vec2 z = vec2(0,0);\n    int maxIt = 500;\n    int i = 0;\n    \n    for(; i < maxIt && length(z) < 1.0; i++) {\n        z = complexSquare(z) + uv;\n    }\n    \n    float progress = float(i) / float(maxIt);\n    \n    vec3 col = vec3(sqrt(progress),progress,0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 75], [77, 77, 134, 134, 511]]}
{"id": "7sc3RS", "name": "Temporal Fire [golf] [252 char]", "author": "Tater", "description": "Golfed version of https://shadertoy.com/view/fs23zy", "tags": ["2d", "fire", "golf"], "likes": 8, "viewed": 391, "published": 3, "date": "1630057286", "time_retrieved": "2024-07-30T19:04:41.230840", "image_code": "// Fork of \"Temporal Fire\" by Tater. https://shadertoy.com/view/fs23zy\n// 2021-08-27 07:55:20\n\n//My first golfed shader\n#define b(a) step(max(abs(U.x),U.y),a)\nvoid mainImage(out vec4 O,vec2 C)\n{\n    for(O-=O; ++O.w<7.;){\n        vec2 U=C/iResolution.xy-.5;\n        U.y=U.y*.4+.2+U.x*U.x;        \n        U.x+=U.y*sin(O+O+U.y*25.-iTime*9.).w*.2;\n        U.y-=asin(sin(U.x*34.))/20.;\n        O+=.3*vec4(.8*b(.3)+b(.2),b(.2),b(.1),5);       \n    }\n}\n\n/* original 263 chars\n#define b(a) step(max(d.x,d.y),a)\nvoid mainImage(out vec4 O,vec2 C){\n    for(;O.w++<3.;){\n        vec2 d,U=C.yx/iResolution.yx;   \n        U.y-=.5;\n        U.x=U.x*.4+U.y*U.y;        \n        U.y+=U.x*sin(-iTime*9.+O.w*2.+U.x*25.)*.2;\n        U.x-=asin(sin(U.y*34.))/20.;\n        d=abs(U);\n        O+=.3*vec4(.8*b(.3)+b(.2),b(.2),b(.1),-1.);       \n    }\n}\n*/\n\n/*\n#define b(a) step(max(d.x,d.y),a)\nvoid mainImage(out vec4 O,vec2 C){for(;O.w++<3.;){vec2 d,U=C.yx/iResolution.yx;U.y=U.y-.5;U.x=U.x*.4+U.y*U.y;U.y+=U.x*sin(-iTime*9.+O.w*2.+U.x*25.)*.2;U.x-=asin(sin(U.y*34.))/20.;d=abs(U);O+=.3*vec4(.8*b(.3)+b(.2),b(.2),b(.1),-1.);}}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 194, 194, 446]]}
{"id": "7dc3zS", "name": "Colorful circle", "author": "stoman", "description": "Learning how this stuff works", "tags": ["tutorial"], "likes": 1, "viewed": 176, "published": 3, "date": "1630055337", "time_retrieved": "2024-07-30T19:04:42.048654", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dist = distance(fragCoord, iResolution.xy/2.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    if(dist < iResolution.y/4.0) {\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    else {\n        col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dc3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 370]]}
{"id": "fdtGW8", "name": "Text Fixed Color", "author": "Glsl_Fish", "description": "it is just  a  simple trying of my first shadertoy; ", "tags": ["test"], "likes": 0, "viewed": 207, "published": 3, "date": "1630051723", "time_retrieved": "2024-07-30T19:04:42.912345", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1.0);\n    float a = 0.5+0.5*cos(iTime +uv.x+uv.y+iMouse.x*0.01);\n    float b = 0.5+0.5*sin(iTime +uv.x+uv.y+iMouse.x*0.01);\n    if(uv.x>a && uv.y>a)\n    {\n        // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    else if(uv.x>a && uv.y<a)\n    {\n        col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    }\n    else if(uv.x<a && uv.y<a)\n    {\n        col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,6));\n    }\n    else\n    {\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,6));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 747]]}
{"id": "7scGRS", "name": "Small fast texture smooth shader", "author": "MODer", "description": "i just tried to make fast texture smoothing", "tags": ["texture", "fast", "smooth"], "likes": 0, "viewed": 224, "published": 3, "date": "1630047756", "time_retrieved": "2024-07-30T19:04:43.769054", "image_code": "float n(vec2 uv){return fract(sin(uv.x*124.2+uv.y*2374.73)*8667.673);}\n\nvec4 SmootTextureNoiseMipLv(sampler2D textures, vec2 uv, float size){\n    \n    vec2 d = vec2(n(uv), n(vec2(uv.y,uv.x)));\n    \n    vec4 defcolor = texture(textures, uv, size/1.2);\n    \n    float f = (1.-(1./(size+1.)));\n    \n    f *= f;\n    \n    uv += (d-0.5)*f/9.;\n    \n    return mix(defcolor, texture(iChannel0, uv, size), f );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float mx = iMouse.x/iResolution.x;\n    uv.x += iTime/4.;\n    \n    fragColor = SmootTextureNoiseMipLv(iChannel0, uv, mx*8.);\n    /*\n    \n    const float size = 58.;\n    const float p = 0.6;\n    \n    vec2 d = vec2(n(vec3(uv.x,uv.y,1.)), n(vec3(uv.y,uv.x,8.)));\n    \n    vec4 defcolor = texture(iChannel0, uv, 6.);\n    \n    uv.x += (d.x-0.5)/size;\n    uv.y += (d.y-0.5)/size;\n    \n    \n    \n    fragColor = mix(defcolor, texture(iChannel0, uv, 3.), 0.6 );\n    */\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 70], [72, 72, 141, 141, 403], [405, 405, 462, 462, 968]]}
{"id": "7scGWM", "name": "physics test", "author": "ArmandB", "description": "a 2d physics example\nclick on a ball to pick it up and release to throw it\n\ninelastic collisions from: https://imada.sdu.dk/~rolf/Edu/DM815/E10/2dcollisions.pdf", "tags": ["physics", "buffers"], "likes": 5, "viewed": 472, "published": 3, "date": "1630027804", "time_retrieved": "2024-07-30T19:04:44.631748", "image_code": "//Image\n//all the drawing stuff\n\nvec2 toUV(vec2 pos){\n    pos = pos/iResolution.xy*1000.0-500.0;\n    pos.x *= iResolution.x/iResolution.y;\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set uv coords + col\n    vec2 uv = toUV(fragCoord);\n    vec3 col = vec3(0);\n    ivec2 iCoord = ivec2(fragCoord);\n    \n    //draw walls\n    if (!(\n        uv.x < walls.x &&\n        uv.x > walls.z &&\n        uv.y < walls.y &&\n        uv.y > walls.w\n    )){ \n        col = vec3(1); \n        //show data storage\n        if(texelFetch(iChannel0, ivec2(iCoord), 0) != vec4(0)){\n            col = texelFetch(iChannel0, ivec2(iCoord), 0).xyz;\n        }\n    } \n    else { \n        //loop through balls\n        for (int i = 0; i < ballCount; i++){\n            //read data\n            vec2 position = texelFetch(iChannel0, ivec2(loopCoord(float(i), vec2(iResolution))), 0).xy;\n            //draw object\n            if ( distance(uv, position) <= radius ){ \n                col = (i==0) ? vec3(1,0.5,0) : vec3(0,float(i)/float(ballCount), 1.0 - float(i)/float(ballCount)); \n                //col = ;\n            }\n        }\n    }\n  \n    // Output to screen\n    fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Parameters\n//all parameters for the simulation\nconst vec2 acceleration = vec2(0.0, -0.2); //divide by target fps\nconst float radius = 50.0;\nconst float bounciness = 1.0;\nconst int ballCount = 5; //current max ballcount is canvas size.x\nconst vec4 walls = vec4(890, 500, -890, -500);\n\n//loops a point over the screen width\nvec2 loopCoord(float coord, vec2 resolution){\n    float y = floor(coord/(resolution.x-1.0));\n    float x = mod(coord, (resolution.x-1.0));\n    return vec2(x, y);\n}\n\n//unloops a point over the screen width\nfloat unLoop(vec2 coord, vec2 resolution){\n    return coord.x + resolution.x*coord.y;\n}\n\nfloat rand(int i){ // a (weak) random  function\n    vec2 o = vec2(i);\n    o = sin(vec2(iDate.w * o.x, iDate.w * o.y * 11.0));\n    return fract(sin(dot(o, vec2(12.9898, 78.233))) * 43758.5453);\n}", "buffer_b_code": "//Buff A\n//all the motion stuff, but with continuous collision detection\n\n//add interpolation so balls can't go through eachother\n//optimize?\n\nvec2 toUV(vec2 pos){ //converts a screen coord to a uv coord\n    pos = pos/iResolution.xy*1000.0-500.0;\n    pos.x *= iResolution.x/iResolution.y;\n    return pos;\n}\n\nfloat collideTime(vec2 p1, vec2 v1, vec2 p2, vec2 v2, float r1, float r2){\n    //constants for the equation\n    float a = p1.x;\n    float b = p1.y;\n    float c = v1.x;\n    float d = v1.y;\n    float e = p2.x;\n    float f = p2.y;\n    float g = v2.x;\n    float h = v2.y;\n    float i = r1;\n    float j = r2;\n\n    //solves for t when:\n    //((p2.x + v2.x*t) - (p1.x + v1.x*t))^2 + ((p2.y + v2.y*t) - (p1.y + v1.y*t))^2 - radius1 + radius2 = 0\n    //this means it finds the time that the 2 balls will colide where time is 0 (this frame) to 1 (next frame)\n    float A = c*c + d*d + g*g + h*h - 2.0*c*g - 2.0*d*h;\n    float B = 2.0*(a*c + b*d + e*g + f*h - a*g - b*h - e*c - f*d);\n    float C = a*a + b*b + e*e + f*f - 2.0*(a*e + b*f) - i*i - 2.0*i*j - j*j;\n\n    float discriminant = B*B - 4.0*A*C;\n    if ( discriminant >= 0.0){ //check that quadratic equation has root\n        return (-B - sqrt(discriminant)) / (2.0*A); //run quadratic formula for smallest root\n    }\n    return -1.0;\n        \n}\n\nvoid wallCollision(inout vec2 v, inout vec2 p, in float r){\n    vec2 penetration = vec2(0);\n    if (p.x + r > walls.x) {\n        v = v*vec2(-1,1);\n        if (p.x + r - walls.x > 0.0)\n            penetration.x = p.x + r - walls.x;\n    }\n    if (p.y + r > walls.y) {\n        v = v*vec2(1,-1);\n        if (p.y + r - walls.y > 0.0)\n            penetration.y = p.y + r - walls.y;\n    }\n    if (p.x - r < walls.z) {\n        v = v*vec2(-1,1);\n        if (p.x - r - walls.z < 0.0)\n            penetration.x = p.x - r - walls.z;\n    }\n    if (p.y - r < walls.w) {\n        v = v*vec2(1,-1);\n        if (p.y - r - walls.w < 0.0)\n            penetration.y = p.y - r - walls.w;\n    }\n    p -= penetration;\n    return;\n}\n\nvoid ballCollision(inout vec2 p1, inout vec2 p2, inout vec2 v1, inout vec2 v2, in float r1, in float r2){\n\n    float m1 = 1.0;\n    float m2 = 1.0;\n\n    vec2 n = normalize(p2 - p1);//the normal of the collision\n    vec2 t = vec2(-n.y, n.x);//the tangent of the collision (perpendicular to normal)\n    \n    float v1n = dot(v1,n);//v1 projected onto normal\n    float v2n = dot(v2,n);//v2 projected onto normal\n    float v1t = dot(v1,t);//v1 projected onto tangent\n    \n    float s1f = (v1n*(m1-m2)+2.0*m2*v2n)/(m1+m2);//the final speed of v1 along the normal vector\n    \n    vec2 v1f = s1f*n + v1t*t; //the final velocity of ball1\n    \n    float penetration = r1+r2-length(p2 - p1);\n    if (penetration < r1+r2){\n        p1 += n*penetration;\n    }\n    \n    v1 = v1f;\n    return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0); //initialize col\n    ivec2 iCoord = ivec2(fragCoord); //set up coords\n    \n    //setup mouse\n    vec4 m = vec4(toUV(iMouse.xy), toUV(iMouse.zw)); //get the mousepos in uv units\n    vec2 prevMousePos = texelFetch(iChannel0, ivec2(0, iResolution.y-1.0), 0).xy;\n    if (prevMousePos == vec2(0)){\n        prevMousePos = m.xy;\n    }\n    vec2 mouseVel = m.xy-prevMousePos;\n    if (length(mouseVel) >= 30.0){\n        mouseVel = normalize(mouseVel)*30.0;\n    }\n    int heldball = int(texelFetch(iChannel0, ivec2(1, iResolution.y-1.0), 0).x);\n    if (texelFetch(iChannel0, ivec2(1, iResolution.y-1.0), 0).y == 0.0){\n        heldball == -1;\n    }\n    \n    //loopthrough balls\n    for (int i = 0; i < ballCount; i++){\n        //get ball pos\n        vec4 position = texelFetch(iChannel0, ivec2(loopCoord(float(i), vec2(iResolution))), 0);\n        \n        //check if mouse is holding\n        if(\n            m.z + 1000.0 > 0.0 && (\n                heldball == i || (\n                    distance(position.xy, m.xy) <= radius &&\n                    heldball == -1\n                )\n            )\n        ){ //if mouse is over ball, pick up\n            heldball = i; \n        } else if(m.z + 1000.0 <= 0.0){\n            heldball = -1;\n        }\n    }\n    \n    \n    //main physics\n    if (float(iCoord.y) <= loopCoord(float(ballCount), vec2(iResolution)).y && unLoop(vec2(iCoord), vec2(iResolution)) <= float(ballCount)){\n        int i = iCoord.x;\n        \n        //read data\n        vec4 position = texelFetch(iChannel0, ivec2(loopCoord(float(i), vec2(iResolution))), 0);\n        \n        if (position.zw == vec2(0,0) && iTime < 1.0) //set init velocity\n            position.zw = vec2(1.0);\n            \n        //deal with acceleration\n        position.zw += acceleration;\n        \n        //bounce (balls)\n        //loop through the other balls\n        for (int c = 0; c < ballCount; c++){ \n            if (c == i){continue;} //skip if ball is attempting bounce on self\n            if (heldball == i){break;}\n            vec4 otherPosition = texelFetch(iChannel0, ivec2(loopCoord(float(c), vec2(iResolution))), 0);\n\n            vec2 p1 = position.xy;\n            vec2 p2 = otherPosition.xy;\n            vec2 v1 = position.zw;\n            vec2 v2 = otherPosition.zw;\n            float r1 = radius;\n            float r2 = radius;\n            \n            if (distance(p1, p2) <= radius*2.0){ //deal with current frame collisions\n                if(p1.xy == p2.xy){ //handle case where 2 pos are same\n                    p1.xy += vec2(1.0-rand(c),rand(c))*radius;\n                }\n                ballCollision(p1, p2, v1, v2, r1, r2);\n            } else {\n                float t = collideTime(p1, v1, p2, v2, radius, radius);\n                if(!(t > 1.0 || t < 0.0)){ //deal with between frame collisions\n                    p1 += t*v1;\n                    p2 += t*v2;\n                    ballCollision(p1, p2, v1, v2, r1, r2);\n                }\n                \n            }\n            position = vec4(p1, v1);\n        }\n        \n        //get mouse inputs\n        if(heldball == i){ //if ball is held, move to mouse\n            position.xy = m.xy;\n            position.zw = mouseVel;\n        }\n        \n        //bounce(walls)\n        wallCollision(position.zw, position.xy, radius);\n\n        //itterate position\n        position.xy += position.zw;\n\n        //write data\n        col = position;\n    } else {\n        //write mouse pos to be read back for velocity\n        if (vec2(iCoord) == vec2(0, iResolution.y-1.0)){\n            col = vec4(m.xy, mouseVel);\n        } else if(vec2(iCoord) == vec2(1, iResolution.y-1.0)){ //what ball is held? (fix)\n            col = vec4(heldball,1.0,1.0,1.0);\n        }\n    }\n    \n    //set colors\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 53, 53, 156], [158, 158, 215, 241, 1196]]}
{"id": "Nd33zB", "name": "Natural RYB Color Wheel", "author": "harry7557558", "description": "The idea comes from a picture on my art teacher's color theory intro slide.\nIgnore my terrible tracing skill.", "tags": ["color", "space", "rgb", "wheel", "ryb"], "likes": 7, "viewed": 430, "published": 3, "date": "1630026712", "time_retrieved": "2024-07-30T19:04:45.464521", "image_code": "// Desmos version:\n// https://www.desmos.com/calculator/w4thzt4ofr\n\n#define PI 3.1415926\n\n// RYB/RGB\n#define RYB 1\n\n// smoothed color gradient or not\n#define SMOOTH 0\n\n\n// Color space conversion\n\nfloat hue2rgb(float p, float q, float t) {\n    if (t < 0.) t += 1.;\n    if (t > 1.) t -= 1.;\n    if (t < 1./6.) return mix(p, q, 6. * t);\n    if (t < 1./2.) return q;\n    if (t < 2./3.) return mix(p, q, (2./3. - t) * 6.);\n    return p;\n}\nvec3 hsl2rgb(float h, float s, float l) {\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n    float p = 2. * l - q;\n    return vec3(\n        hue2rgb(p, q, h + 1./3.),\n        hue2rgb(p, q, h),\n        hue2rgb(p, q, h - 1./3.)\n    );\n}\n\nvec3 ryb2rgb(vec3 ryb) {\n    const vec3 ryb000 = vec3(1, 1, 1);\n    const vec3 ryb001 = vec3(0.163, 0.373, 0.6);\n    const vec3 ryb010 = vec3(1, 1, 0);\n    const vec3 ryb100 = vec3(1, 0, 0);\n    const vec3 ryb011 = vec3(0, 0.66, 0.2);\n    const vec3 ryb101 = vec3(0.5, 0, 0.5);\n    const vec3 ryb110 = vec3(1, 0.5, 0);\n    const vec3 ryb111 = vec3(0, 0, 0);\n    return mix(mix(\n        mix(ryb000, ryb001, ryb.z),\n        mix(ryb010, ryb011, ryb.z),\n        ryb.y), mix(\n        mix(ryb100, ryb101, ryb.z),\n        mix(ryb110, ryb111, ryb.z),\n        ryb.y), ryb.x);\n}\n\n\n// Mask layer - please ignore my terrible tracing skill\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat mask(float x, float y) {\n    float head = smax(x+0.25*y-0.65, -0.27*x+y-0.94-0.01*cos(3.0*x), 0.6); // head back\n    float face = -x-0.08*y-0.6 + 0.03*cos(6.0*y-1.0);  // face\n    face -= -0.2+0.2*tanh(18.0*(y+0.4)) + 0.1*exp(-3.0*y-2.2); // chin/neck\n    face -= 0.04*exp(-100.0*(y-0.1)*y)*(0.8-x+10.0*y);  // nose\n    face -= 0.03*sin(40.0*(y-0.03))*exp(-100.0*y*y);  // mouth\n    float d = smax(head, face, 0.2);\n    d = smax(d, 0.3*x-y-0.87 - 0.1*x*x, 0.05);  // bottom\n    float back = x+0.7*y+0.05 - 0.1*exp(-3.0*y-2.2);  // bottom-right block\n    back = smax(-back, -0.6*x+y+0.72-0.05*sin(8.0*x), 0.02);\n    d = smax(d, -back, 0.02);\n    return d;\n}\n\n\n// Noise\n\nvec2 hash22(vec2 p) {\n    // from David Hoskins's https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat SimplexNoise(vec2 xy) {\n    const float K1 = 0.3660254038;  // (sqrt(3)-1)/2\n    const float K2 = 0.2113248654;  // (-sqrt(3)+3)/6\n    vec2 p = xy + (xy.x + xy.y)*K1;\n    vec2 i = floor(p);\n    vec2 f1 = xy - (i - (i.x + i.y)*K2);\n    vec2 s = f1.x < f1.y ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 f2 = f1 - s + K2;\n    vec2 f3 = f1 - 1.0 + 2.0*K2;\n    vec2 n1 = 2.0 * hash22(i) - 1.0;\n    vec2 n2 = 2.0 * hash22(i + s) - 1.0;\n    vec2 n3 = 2.0 * hash22(i + 1.0) - 1.0;\n    vec3 v = vec3(dot(f1, n1), dot(f2, n2), dot(f3, n3));\n    vec3 w = max(-vec3(dot(f1, f1), dot(f2, f2), dot(f3, f3)) + 0.5, vec3(0.0));\n    return dot((w*w*w*w) * v, vec3(32.0));\n}\n\n\n// Main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Cartesian coordinate\n    vec2 pos = 2.0 * fragCoord/iResolution.xy - 1.0;\n    pos *= iResolution.xy / min(iResolution.x, iResolution.y);\n\n    // polar coordinate\n    vec2 p = pos - vec2(-0.0, 0.15);\n    float r = length(p);\n    float a = atan(p.x, p.y) / (2.0*PI);\n    if (a < 0.0) a += 1.0;\n\n    // color\n    float noise = SimplexNoise(vec2(40.0*a, 8.0*sqrt(r)));\n#if !SMOOTH\n    a = round(12.0*a)/12.0;\n    r = round(3.0*r)/3.0;\n#endif\n    vec3 col = hsl2rgb(a, 1.0, (1.0-0.1*noise)*(1.0-0.8*exp(-0.8*r)));\n#if RYB\n    col = ryb2rgb(col);\n#endif\n\n    // apply mask\n    float m = mask(pos.x, pos.y);\n    if (m > 0.0) col = vec3(1.0);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd33zB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 238, 238, 433], [434, 434, 475, 475, 675], [677, 677, 701, 701, 1245], [1305, 1305, 1344, 1344, 1445], [1446, 1446, 1485, 1485, 1516], [1518, 1518, 1548, 1548, 2180], [2193, 2193, 2214, 2280, 2416], [2418, 2418, 2447, 2447, 3079], [3091, 3091, 3146, 3175, 3823]]}
{"id": "7sc3z7", "name": "Fake fluid physics", "author": "jarble", "description": "This fluid simulation is completely fake, but it somehow manages to look realistic.\nThis illusion works [url=https://www.shadertoy.com/view/7ddGzS]in 3 dimensions[/url], too.", "tags": ["fluid", "physics"], "likes": 6, "viewed": 437, "published": 3, "date": "1630026035", "time_retrieved": "2024-07-30T19:04:46.233465", "image_code": "vec2 fluid(vec2 uv){\n float t1 = iTime*2.;\n \n //uv *= 8.;\n float turbulence = 4.;\n //decrease this number to increase the turbulence\n \n for (float i = 1.; i < 8.; i += 1.)\n  {\n    \n    //float i1=i;\n    //uv.x += sin(uv.y*(i-1.)+t1/i)/i;\n    //uv.y += cos(uv.x*(i-1.)+t1/i)/i;\n    \n    //uv.x += sin((t1-uv.y)*.5)*1.5/i* sin(i * uv.y + t1 * 0.5);\n    //uv.y += sin((t1-uv.x)*.5)*1.5/i* sin(i * uv.x + t1 * 0.5 );\n    \n    //uv.x += sin(uv.y*i-t1-uv.y)/i;\n    //uv.y += sin(uv.x*i)/i;\n\n    //uv.x += sin(uv.y*i)/i;\n    //uv.y += cos(uv.x*i+t1)/i;\n    \n    //uv.x += (sin(uv.y*i1)/i1+t1/i1/i1)/turbulence;\n    //uv.y += cos(uv.x*i1)/i1/turbulence;\n    \n    uv.x += (cos(uv.y*i+t1))/turbulence;\n    uv.y += sin(uv.x*i)/turbulence;\n    uv = uv.yx;\n    \n  }\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord/iResolution.xy*10.;\n uv = fluid(uv);\n float r = abs(sin(uv.x))+.5;\n float g =abs(sin(uv.x+2.+iTime*.2))-.2;\n float b = abs(sin(uv.x+4.));   \n vec3 col = vec3(r,g,b);   \n \n fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 767], [769, 769, 826, 826, 1049]]}
{"id": "NdcGzS", "name": "Black hole simulation", "author": "Skele7on1250", "description": "Simply black hole simulation based on ray tracing ", "tags": ["raytracing", "space", "blackhole"], "likes": 3, "viewed": 373, "published": 3, "date": "1630003480", "time_retrieved": "2024-07-30T19:04:47.035321", "image_code": "#define H 6.626176f*10e-34\n#define C 299792458.\n#define HL 380.\n#define sunM 1.989f*10e30\n//I choose this mass for more beauty effect\n#define photonM 0.0000000000000000000000000001f\n#define G 6.67f*10e-11\nstruct BlackHole{\n    vec3 pos;\n    float radius;\n    float mass;\n    vec3 discColor;\n};\nvec3 CalculateRayDir(vec3 origin,float fov,vec2 fragCoord);\nvec3 TraceRay(vec3 origin,vec3 dir,float t);\nvec3 CalculateColor(vec3 origin,vec3 dir,int rayDistance,BlackHole blackHole);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    BlackHole blackHole=BlackHole(vec3(cos(iTime/3.)*50.+50.,0,100.),5.,sunM*10e6,vec3(1.,0.4f,0.));\n\n    // Output to screen\n    vec3 cameraPos=vec3(0,0,0);\n    vec3 col=CalculateColor(cameraPos,CalculateRayDir(cameraPos,45.,fragCoord),100,blackHole);\n    fragColor = vec4(col,1.0);\n}\nvec3 CalculateRayDir(vec3 origin,float fov,vec2 fragCoord){\n    float d=1./tan(fov/2.);\n    float px=fragCoord.x+0.5f;\n    float py=fragCoord.y+0.5f;\n    float aspect_ratio=iResolution.x/iResolution.y;\n    return vec3(aspect_ratio*(2.*px/iResolution.x)-1.,(2.*py/iResolution.y)-1.,d);\n}\nfloat hypot(vec3 first,vec3 second){\n    vec3 resVec=second-first;\n    return sqrt(pow(resVec.x,2.0f)+pow(resVec.y,2.0f)+pow(resVec.z,2.0f)); \n}\nvec3 CalculateColor(vec3 origin,vec3 dir,int rayDistance,BlackHole blackHole){\n    vec3 bhDir;\n    float F;\n    while(rayDistance>0){   \n        origin=TraceRay(origin,dir,1.);\n        //Return black hole color\n        if(hypot(origin,blackHole.pos)<=blackHole.radius){\n            return vec3(0,0,0);\n        }\n        //Return calculation for disc color\n        if(hypot(origin,blackHole.pos)<=blackHole.radius*3.&&abs(origin.y-blackHole.pos.y)<=0.3f){\n            return blackHole.discColor*max(0.4f,((blackHole.radius*3.-hypot(origin,blackHole.pos))/blackHole.radius*3.));\n        }\n        \n        //Calculate direction to black hole\n        bhDir=normalize(blackHole.pos-origin);\n        //Calculate F of black hole\n        F=G*(photonM*blackHole.mass)/(pow(hypot(origin,blackHole.pos),2.));\n        bhDir*=F;\n        //Calculate new direction\n        dir+=bhDir;\n        rayDistance-=1;\n    }\n    return texture( iChannel0, dir ).rgb;\n    \n    \n}\nvec3 TraceRay(vec3 origin,vec3 dir,float t){\n    return(origin+dir*t);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[478, 478, 535, 535, 821], [822, 822, 881, 881, 1108], [1109, 1109, 1145, 1145, 1253], [1254, 1254, 1332, 1332, 2208], [2209, 2209, 2253, 2253, 2281]]}
{"id": "fdcGRS", "name": "GLSL bug #61 ( Windows )", "author": "FabriceNeyret2", "description": "WIP.   bug chasing by simplifying https://shadertoy.com/view/fdt3Rn (with its bug reintroduced line 39).\nOn windows/Angle + nvidia , the right part is plain white ( spiral shape missing ), \n+ red where assert find mod(x,1) != fract().\nCorrect = bi-spiral", "tags": ["spiral", "logarithm", "project"], "likes": 2, "viewed": 224, "published": 3, "date": "1629999915", "time_retrieved": "2024-07-30T19:04:47.799278", "image_code": "// bug chasing by simplifying https://shadertoy.com/view/fdt3Rn ( pb not only line39, after all )\n// bug report: https://bugs.chromium.org/p/chromium/issues/detail?id=1245259\n\n#define rot(a)     mat2(cos(a + vec4(0,11,33,0))) // 2D rotation\n\nfloat  pi = 3.141592653;\n\nfloat ObjDf (vec3 p)  // --- define the spiral shape\n{\n  float dMin=100., wSep=5.77, d, r, a, dc;\n\n// float k = -1.; {  // <<< left (only) = bug\n// float k =  1.; {  // <<< right (only) = nobug \n// <<< no bug if loop content moved in a function and called with k = -1. then 1.\n  for (float k = -1.; k <= 1.; k += 2.) { // 2 symmetric spirals\n    vec3 q = p;\n    q.x -= k * wSep;\n    r = length (q.xz);\n    if (r > -.01) // <<< always true but everything bugguy if commented\n    {\n      q.xz *= k;\n      dc = max (r - wSep - .45, min (r - wSep + .55, - q.z)); \n      \n      a = atan (q.z, q.x) / pi;\n      vec2 v = vec2 ( pi * log(r) - .5*a, -5.*a) + .5 ; // <<< only .x used, but bug only shows if vec \n      q.xz = mod  (v, 1.) - .5;  // <<< bug\n   // q.xz = fract(v) - .5;      // <<< equivalent, but nobug\n   // q.x = mod  (v.x, 1.) - .5; // <<< q.z unused, but vec op bug while nobug without q.z\n   \n      st_assert( abs( fract(a+.5) - mod(a+.5,1.) ) < .95, 0 ); // <<< red if fract != mod(x,1).\n                                //  unrelated ? at least correlated as side effect\n      \n      d = max ( r * length (max (abs (q.xy) -.1, .0)), dc );\n      dMin = min(d,dMin); \n    }\n  }\n  return 0.1 * dMin;\n}\n\nvec4 ShowScene (vec3 ro, vec3 rd) // --- ray marching\n{\n  vec3 p;\n  float dHit=0., d=9.;\n  for (int j = 0; j < 300 && d > .01; j ++) { \n    p = ro + dHit * rd;\n    dHit += d = ObjDf (p);\n  }\n  return vec4(dHit/100.);\n}\n\nvoid mainImage (out vec4 O, vec2 u) // --------------------------------\n{\n    vec2 R = iResolution.xy, \n    uv = ( 2.*u - R ) / R.y;\n\n    vec3 ro = vec3 (0, 0, -30),  // setup camera for ray marching\n         rd = normalize (vec3 (uv , 4));\n    ro.yz *= rot(-pi/4.); \n    rd.yz *= rot(-pi/4.); \n\n    float sr =  mod ( mod (floor(R), 2.).x  , 2.) ; // <<< unused, but commenting it fixes the bug !\n      // <<< only use mod().x . still, using R.x, or deleting one mod(), fixes the bug\n                    \n    float a = min(0.,iTime);  // <<< is indeed 0, but as uniform.       \n // float  a = 0.;            // <<< otherwise  left = bug as well\n              // <<< loop does 1 step, but bug without it\n    if (uv.x<0.) for (; a < 1.; a++ ) O = ShowScene(ro,rd); // left = nobug\n    else                              O = ShowScene(ro,rd); // right = bug\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 322, 322, 1478], [1480, 1480, 1535, 1535, 1698], [1700, 1700, 1773, 1773, 2555]]}
{"id": "Nd3GRS", "name": "Gaussian curvature of implicit", "author": "sibaku", "description": "This shader shows the Gaussian curvature of a few implicit functions", "tags": ["raymarch", "gradient", "curvature", "implicitfunction", "hessian", "autodiff", "automaticdifferentiation", "gaussiancurvature"], "likes": 8, "viewed": 359, "published": 3, "date": "1629998999", "time_retrieved": "2024-07-30T19:04:48.747742", "image_code": "// This shader computes the exact gaussian curvature of implicit surfaces\n// For that the Hessian matrix and gradient of the implicit equation are found\n// by using automatic differentiation\n\n// Negative curvature is blue, positive red.\n\n// If you want, you can implement your own functions, a few helpers are already there\n\n// Note that for pure distance fields, this can be accomplished easier\n// as the determinant of the hessian matrix (which in that case equals the shape operator)\n// This is used here (https://www.shadertoy.com/view/4stSRf) to compute the principal curvatures\n\n// Tracing is done with a simple first order approximation. \n// See here (https://www.shadertoy.com/view/MdtXWM) for a second order showcase, which handles\n// higher distortions better without the need to introduce a scaling hyperparameter\n\nfloat curvature(HNum3 fx) {\n\n  // numerator of gaussian curvature for implicit surfaces\n  mat4 G = mat4(fx.h);\n  G[3].xyz = fx.g;\n  G[0][3] = fx.g[0];\n  G[1][3] = fx.g[1];\n  G[2][3] = fx.g[2];\n\n  G[3][3] = 0.0;\n\n  float gl2 = dot(fx.g, fx.g);\n\n  return -determinant(G) / (gl2 * gl2);\n}\n\nHNum3 a_length2(HNum3 x, HNum3 y, HNum3 z) {\n  return add(mult(x, x), add(mult(y, y), mult(z, z)));\n}\n\nHNum3 a_length2(HNum3 x, HNum3 y) { return add(mult(x, x), mult(y, y)); }\nHNum3 a_length(HNum3 x, HNum3 y) { return a_sqrt(a_length2(x, y)); }\n\nHNum3 a_length(HNum3 x, HNum3 y, HNum3 z) { return a_sqrt(a_length2(x, y, z)); }\n\nvoid timeblend(float showDuration, float blendDuration, int numEntries,\n               out int index, out float blend) {\n  float duration = showDuration + blendDuration;\n  // compute function offset for time\n  float timeGrid = floor(iTime / duration);\n  index = int(mod(timeGrid, float(numEntries)));\n  float inDur = iTime - timeGrid * duration;\n  // start blending to the next after show duration is over\n  blend = smoothstep(showDuration, duration, inDur);\n}\n\nHNum3 a_clamp(HNum3 a, float low, float high) {\n  return a_max(constH3(low), a_min(constH3(high), a));\n}\nHNum3 opIntersect(HNum3 d0, HNum3 d1) { return a_max(d0, d1); }\nHNum3 opUnion(HNum3 d0, HNum3 d1) { return a_min(d0, d1); }\nHNum3 opSubtract(HNum3 d0, HNum3 d1) { return a_max(d0, neg(d1)); }\n\nHNum3 opSmoothSubtraction(HNum3 d1, HNum3 d2, float k) {\n  HNum3 h = a_clamp(sub(0.5, mult(0.5 / k, add(d2, d1))), 0.0, 1.0);\n  return add(a_mix(d2, neg(d1), h), mult(k, mult(h, sub(1.0, h))));\n}\n\nHNum3 opSmoothIntersection(HNum3 d1, HNum3 d2, float k) {\n  HNum3 h = a_clamp(sub(0.5, mult(0.5 / k, sub(d2, d1))), 0.0, 1.0);\n  return add(a_mix(d2, d1, h), mult(k, mult(h, sub(1.0, h))));\n}\n\nHNum3 opSmoothUnion(HNum3 d1, HNum3 d2, float k) {\n  HNum3 h = a_clamp(add(0.5, mult(0.5 / k, (sub(d2, d1)))), 0.0, 1.0);\n\n  return sub(a_mix(d2, d1, h), mult(h, mult(k, sub(1.0, h))));\n}\n\nvoid tTwist(HNum3 x, HNum3 y, HNum3 z, float k, out HNum3 xp, out HNum3 yp,\n            out HNum3 zp) {\n  HNum3 c = a_cos(mult(k, y));\n  HNum3 s = a_sin(mult(k, y));\n\n  // rotate xz\n  xp = add(mult(c, x), mult(s, z));\n  yp = sub(mult(c, z), mult(s, x));\n  zp = y;\n}\n\nHNum3 sdSphere(HNum3 x, HNum3 y, HNum3 z, float r) {\n  HNum3 s = sub(a_length(x, y, z), r);\n  return s;\n}\n\nHNum3 sdTorus(HNum3 x, HNum3 y, HNum3 z, vec2 t) {\n\n  HNum3 qx = sub(a_length(x, z), t.x);\n  HNum3 qy = y;\n\n  return sub(a_length(qx, qy), t.y);\n}\n\nHNum3 f0(HNum3 x, HNum3 y, HNum3 z) {\n  HNum3 s = sdSphere(x, y, z, 2.0);\n  s = add(s, mult(0.2, a_sin(mult(10.0, mult(x, z)))));\n  return s;\n}\n\nHNum3 f1(HNum3 x, HNum3 y, HNum3 z) {\n\n  vec2 t = vec2(2, 0.4);\n\n  tTwist(x, y, z, 2.0, x, y, z);\n\n  HNum3 d = sdTorus(x, y, z, t);\n  return d;\n}\n\n// Combination of two spheres\n// Here you can see how, aside from the transition region, both spheres have constant curvature!\nHNum3 f2(HNum3 x, HNum3 y, HNum3 z) {\n\n  HNum3 s1 = sdSphere(x, y, z, 2.0);\n  HNum3 s2 = sdSphere(add(x, -3.0), y, add(z, 0.5), 1.5);\n\n  return opSmoothUnion(s1, s2, 0.4);\n}\n\nHNum3 f(vec3 p, int index) {\n\n  if(index == 0) {\n      return f0(varH3x(p.x), varH3y(p.y), varH3z(p.z));\n  }\n  else if(index == 1) {\n      return f1(varH3x(p.x), varH3y(p.y), varH3z(p.z));\n  }\n  else if(index == 2) {\n      return f2(varH3x(p.x), varH3y(p.y), varH3z(p.z));\n  }\n  else {\n      return constH3(0.0);\n  }\n\n}\n\nint modi(int i, int m) { return int(mod(float(i), float(m))); }\n\nHNum3 f(vec3 p) {\n  int index;\n  float blend;\n\n  const int NUM = 3;\n  timeblend(3.0, 1.0, NUM, index, blend);\n\n  HNum3 v0 = f(p, index);\n  HNum3 v1 = f(p, modi(index + 1, NUM));\n\n  return a_mix(v0, v1, blend);\n}\nmat3 rotx(float a) {\n  float ca = cos(a);\n  float sa = sin(a);\n\n  return mat3(1.0, 0.0, 0.0, 0.0, ca, sa, 0.0, -sa, ca);\n}\n\nmat3 roty(float a) {\n  float ca = cos(a);\n  float sa = sin(a);\n\n  return mat3(ca, 0.0, -sa, 0.0, 1.0, 0.0, sa, 0.0, ca);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aspect = iResolution.x / iResolution.y;\n\n  vec2 mousePx = iMouse.xy / iResolution.xy;\n\n  mousePx.y = 1.0 - mousePx.y;\n\n  mousePx -= 0.5;\n\n  const float pi = 3.14159265;\n  float theta = pi * mousePx.y;\n  float phi = -2.0 * pi * mousePx.x;\n\n  vec3 eye = vec3(0.0, 6.0, -10.0) * 0.6;\n  mat3 R = roty(phi) * rotx(theta);\n  eye = R * eye;\n  vec3 up = R * vec3(0.0, 1.0, 0.0);\n  vec3 center = vec3(0.0, 0.0, 0.0);\n  \n\n  // inverse projection and view matrices\n  mat4 PInv = perspectiveInv(radians(90.0), aspect, 0.1, 100.0);\n  mat4 VInv = lookAtInv(eye, center, up);\n\n  // normalization of screen coordinates\n  // already includes +0.5\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  vec3 rayDir = createRay(uv, PInv, VInv);\n\n  vec3 col = vec3(0.0);\n  float t = 0.0;\n  float tmax = 10.0;\n  const int max_it = 300;\n  int it = 0;\n  const float eps = 1E-2;\n\n  const vec3 bgCol = vec3(0.0);\n\n  // range in which to show the curvature values inbetween\n  const float krange = 1.0;\n\n  bool found = false;\n  // while (it < max_it && t < tmax && val.val > eps) {\n  while (it < max_it) {\n    // first order approximation with a scaling to account\n    vec3 p = eye + t * rayDir;\n    HNum3 d = f(p);\n    float dt = d.val / length(d.g);\n    t += dt * 0.25 ;\n\n    if (t > tmax) {\n      break;\n    }\n    if (dt < eps) {\n      found = true;\n      break;\n    }\n    it++;\n  }\n\n  if (found) {\n\n    vec3 p = eye + t * rayDir;\n    HNum3 d = f(p);\n\n    float K = curvature(d);\n    \n    // hopefully colorblind friendly color palette\n    // color for negative curvature\n    vec3 c0 = vec3(0.0, 66.0, 157.0) / 255.0;\n    // color for no curvature\n    vec3 c1 = vec3(255.0, 255.0, 224.0) / 255.0;\n    // color for positive curvature\n    vec3 c2 = vec3(147.0, 0.0, 58.0) / 255.0;\n\n    if (K < 0.0) {\n      col = mix(c0, c1, smoothstep(-krange, 0.0, K));\n    } else {\n      col = mix(c1, c2, smoothstep(0.0, krange, K));\n    }\n  } else {\n    col = bgCol;\n  }\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "// Part of my very simple forward-autodiff code from:\n// https://github.com/sibaku/glsl-autodiff\n// below are also functions for the camera and matrix transforms\n\n#ifndef HESSNUM_3_H_\n#define HESSNUM_3_H_\n\n// This file contains methods to compute the gradient and hessian \n// of a scalar valued 3 dimensional function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 3 dimensional function\n// These should be created by the constH3 (for constants) and varH3 (for variables) helpers\nstruct HNum3\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec3 g;\n    // The current hessian\n    mat3 h;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant HNum3\n* @param val The current value of the constant\n*/\nHNum3 constH3(in float val);\n/**\n* Creates a HNum3 corresponding to the variable with the given index\n* @param val The current value of the variable\n* @param index The variable's index\n*/\nHNum3 varH3(in float val, in int index);\n/**\n* Creates a HNum3 corresponding to the variable x (index = 0)\n* @param val The current value of the variable\n*/\nHNum3 varH3x(in float val);\n/**\n* Creates a HNum3 corresponding to the variable y (index = 1)\n* @param val The current value of the variable\n*/\nHNum3 varH3y(in float val);\n/**\n* Creates a HNum3 corresponding to the variable z (index = 2)\n* @param val The current value of the variable\n*/\nHNum3 varH3z(in float val);\nHNum3 add(in HNum3 a, in HNum3 b);\nHNum3 add(in HNum3 a, in float b);\nHNum3 add(in float a, in HNum3 b);\nHNum3 sub(in HNum3 a, in HNum3 b);\nHNum3 sub(in HNum3 a, in float b);\nHNum3 sub(in float a, in HNum3 b);\nHNum3 mult(in HNum3 a, in HNum3 b);\nHNum3 mult(in HNum3 a, in float b);\nHNum3 mult(in float a, in HNum3 b);\nHNum3 neg(in HNum3 a);\nHNum3 div(in HNum3 a, in HNum3 b);\nHNum3 div(in HNum3 a, in float b);\nHNum3 div(in float a, in HNum3 b);\nHNum3 inv(in HNum3 a);\nHNum3 a_pow(in HNum3 a, in HNum3 b);\nHNum3 a_pow(in HNum3 a, in float b);\nHNum3 a_pow(in float a, in HNum3 b);\nHNum3 a_ipow(in HNum3 x, in int n);\nHNum3 a_min(in HNum3 a, in HNum3 b);\nHNum3 a_max(in HNum3 a, in HNum3 b);\nHNum3 a_exp2(in HNum3 a);\nHNum3 a_inversesqrt(in HNum3 a);\nHNum3 a_atan(in HNum3 a);\nHNum3 a_sqrt(in HNum3 a);\nHNum3 a_sinh(in HNum3 a);\nHNum3 a_ceil(in HNum3 a);\nHNum3 a_tan(in HNum3 a);\nHNum3 a_asinh(in HNum3 a);\nHNum3 a_asin(in HNum3 a);\nHNum3 a_acosh(in HNum3 a);\nHNum3 a_abs(in HNum3 a);\nHNum3 a_exp(in HNum3 a);\nHNum3 a_cosh(in HNum3 a);\nHNum3 a_floor(in HNum3 a);\nHNum3 a_log(in HNum3 a);\nHNum3 a_atanh(in HNum3 a);\nHNum3 a_log2(in HNum3 a);\nHNum3 a_acos(in HNum3 a);\nHNum3 a_tanh(in HNum3 a);\nHNum3 a_cos(in HNum3 a);\nHNum3 a_sin(in HNum3 a);\nHNum3 a_atan2(in HNum3 y, in HNum3 x);\nHNum3 a_atan2(in HNum3 y, in float x);\nHNum3 a_atan2(in float y, in HNum3 x);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t);\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t);\nHNum3 a_mix(in HNum3 a, in float b, in float t);\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t);\nHNum3 a_mix(in float a, in HNum3 b, in float t);\nHNum3 a_mix(in float a, in float b, in HNum3 t);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define HESSIAN3(f,x, y, z,result)  {     result = f(varH3x(x), varH3y(y), varH3z(z)); }\n\n//--------------------------------\n// Utilities prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b);\n\n//--------------------------------\n// Implementation\n//--------------------------------\n\nHNum3 constH3(in float val)\n{\n    return HNum3(val, vec3(0.0), mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3(in float val, in int index)\n{   \n    vec3 g = vec3(0.0);\n    g[index] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3x(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[0] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3y(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[1] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 varH3z(in float val)\n{   \n    vec3 g = vec3(0.0);\n    g[2] = 1.0;\n    return HNum3(val, g, mat3(0.0));\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val + b.val , a.g + b.g, a.h + b.h);\n}\n//--------------------------------\nHNum3 add(in HNum3 a, in float b)\n{\n    return HNum3(a.val + b , a.g, a.h);\n}\n//--------------------------------\nHNum3 add(in float a, in HNum3 b)\n{\n    return HNum3(a + b.val , b.g, b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val - b.val , a.g - b.g, a.h - b.h);\n}\n//--------------------------------\nHNum3 sub(in HNum3 a, in float b)\n{\n    return HNum3(a.val - b , a.g, a.h);\n}\n//--------------------------------\nHNum3 sub(in float a, in HNum3 b)\n{\n    return HNum3(a - b.val , - b.g, - b.h);\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in HNum3 b)\n{\n    return HNum3(a.val * b.val, \n        a.val*b.g + b.val*a.g, \n        a.val*b.h + b.val*a.h + a_outerProduct(b.g,a.g) + a_outerProduct(a.g,b.g)\n    );\n}\n//--------------------------------\nHNum3 mult(in HNum3 a, in float b)\n{\n    return HNum3(a.val * b, b*a.g, b*a.h);\n}\n//--------------------------------\nHNum3 mult(in float a, in HNum3 b)\n{\n    return HNum3(a * b.val, a*b.g, a*b.h);\n}\n//--------------------------------\nHNum3 neg(in HNum3 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2, \n        2.0*a.val/b3*a_outerProduct(b.g,b.g) \n        - a.val/b2*b.h\n        + a.h/b1 \n        - a_outerProduct(b.g/b2, a.g)\n        - a_outerProduct(a.g/b2, b.g)\n    );\n}\n//--------------------------------\nHNum3 div(in HNum3 a, in float b)\n{\n    return HNum3(a.val / b, a.g/b, a.h/b);\n}\n//--------------------------------\nHNum3 div(in float a, in HNum3 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n    float b3 = b2*b1;\n\n    return HNum3(a / b.val, \n        -a*b.g/b2, \n        2.0*a/b3*a_outerProduct(b.g,b.g) - a/b2*b.h\n    );\n}\n//--------------------------------\nHNum3 inv(in HNum3 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in HNum3 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nHNum3 a_pow(in HNum3 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    float dda = b*(b-1.0)*pow(a.val,b-2.0); // second derivative f''(a(x))\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_pow(in float a, in HNum3 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n//--------------------------------\nHNum3 a_ipow(in HNum3 x, in int n)\n{\n    // based on https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    if (n < 0)\n    {   \n        x = div(1.0,x);\n        n = -n;\n    }\n    if (n == 0) \n    {\n        return constH3(1.0);\n    }\n    HNum3 y = constH3(1.0);\n    while (n > 1)\n    {\n        if (n % 2 == 0)\n        {   \n            x = mult(x,x);\n            \n        }\n        else\n        {    \n            y = mult(x, y);\n            x = mult(x, x);\n        }\n\n        n = n / 2;\n    }\n    \n    return mult(x, y);\n}\n\n//--------------------------------\nHNum3 a_min(in HNum3 a, in HNum3 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_max(in HNum3 a, in HNum3 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nHNum3 a_exp2(in HNum3 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n    float dda = log(2.0)*log(2.0)*exp2(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_inversesqrt(in HNum3 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n    float dda = 0.75/pow(sqrt(a.val),5.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan(in HNum3 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -2.0*a.val/pow(1.0 + a.val * a.val, 2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sqrt(in HNum3 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n    float dda = -0.25/pow(sqrt(a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sinh(in HNum3 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n    float dda = sinh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_ceil(in HNum3 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tan(in HNum3 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n    float dda = 2.0*tan(a.val)*(1.0 + pow(tan(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asinh(in HNum3 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_asin(in HNum3 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acosh(in HNum3 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(-1.0 + a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_abs(in HNum3 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_exp(in HNum3 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n    float dda = exp(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cosh(in HNum3 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n    float dda = cosh(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_floor(in HNum3 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n    float dda = 0.0; // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log(in HNum3 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atanh(in HNum3 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = 2.0*a.val/pow(1.0 - a.val * a.val,2.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_log2(in HNum3 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n    float dda = -1.0/(a.val * a.val * log(2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_acos(in HNum3 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n    float dda = -a.val/pow(sqrt(1.0 - a.val * a.val),3.0); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_tanh(in HNum3 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n    float dda = -2.0*tanh(a.val)*(1.0 - pow(tanh(a.val),2.0)); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_cos(in HNum3 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n    float dda = -cos(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_sin(in HNum3 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n    float dda = -sin(a.val); // second derivative f''(a(x))\n\n    return HNum3(v , da * a.g,  da * a.h + dda * a_outerProduct(a.g,a.g));\n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in HNum3 x)\n{\n    const float pi = 3.14159265; \n    // from https://en.wikipedia.org/wiki/Atan2\n    if(x.val > 0.0)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(y, add(n,x));\n        \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > 1E-6)\n    {\n        HNum3 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        HNum3 inner = div(sub(n,x),y);\n         return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= 1E-6)\n    {\n        return constH3(pi);\n    }\n    // return 0 for undefined\n    return constH3(0.0); \n}\n//--------------------------------\nHNum3 a_atan2(in HNum3 y, in float x)\n{\n    return a_atan2(y,constH3(x));\n}\n//--------------------------------\nHNum3 a_atan2(in float y, in HNum3 x)\n{\n    return a_atan2(constH3(y),x);\n}\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in HNum3 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in HNum3 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in HNum3 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nHNum3 a_mix(in float a, in float b, in HNum3 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n\n//--------------------------------\n// Implementation prototypes\n//--------------------------------\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n    return mat3(a * b[0], a * b[1], a * b[2]);\n}\n\n\n#endif // HESSNUM_3_H_\n\n\n#ifndef MATRIX_OPS_H_\n#define MATRIX_OPS_H_\n\n// matrix operations\nmat4 translate(vec3 t)\n{\n \treturn mat4(\n        vec4(1.,0.,0.,0.),\n        vec4(0.,1.,0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(t,1.)\n        );\n}\nmat4 translateInv(vec3 t)\n{\n \treturn translate(-t);   \n}\n\nmat4 scale(vec3 s)\n{\n \treturn mat4(\n        vec4(s.x,0.,0.,0.),\n        vec4(0.,s.y,0.,0.),\n        vec4(0.,0.,s.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\nmat4 scaleInv(vec3 s)\n{\n \treturn scale(1./s);   \n}\n\nmat4 rightToLeft()\n{\n    // 1 0 0  0\n    // 0 1 0  0\n    // 0 0 -1 0\n    // 0 0 0  1\n \treturn scale(vec3(1.,1.,-1.));\n}\n\nmat4 rightToLeftInv()\n{\n    // same matrix\n    return rightToLeft();\n}\n\t\n#endif // MATRIX_OPS_H_\n\n\n\n#ifndef CAMERA_H_\n#define CAMERA_H_\n\n\n// This assumes the pixel position px to be in [0,1], \n// which can be done by (x+0.5)/w or (y+0.5)/h (or h-y +0.5 for screens\n// with top left origin) to sample pixel centers\nvec3 createRay(vec2 px, mat4 PInv, mat4 VInv)\n{\n\t \n\t// convert pixel to NDS\n\t// [0,1] -> [-1,1]\n\tvec2 pxNDS = px*2. - 1.;\n\n\t// choose an arbitrary point in the viewing volume\n\t// z = -1 equals a point on the near plane, i.e. the screen\n\tvec3 pointNDS = vec3(pxNDS, -1.);\n\n\t// as this is in homogenous space, add the last homogenous coordinate\n\tvec4 pointNDSH = vec4(pointNDS, 1.0);\n\t// transform by inverse projection to get the point in view space\n\tvec4 dirEye = PInv * pointNDSH;\n\n\t// since the camera is at the origin in view space by definition,\n\t// the current point is already the correct direction (dir(0,P) = P - 0 = P\n\t// as a direction, an infinite point, the homogenous component becomes 0\n\t// the scaling done by the w-division is not of interest, as the direction\n\t// in xyz will stay the same and we can just normalize it later\n\tdirEye.w = 0.;\n\n\t// compute world ray direction by multiplying the inverse view matrix\n\tvec3 dirWorld = (VInv * dirEye).xyz;\n\n\t// now normalize direction\n\treturn normalize(dirWorld); \n}\n\n\n\nmat4 ortho(float l, float r, float b, float t, float n, float f)\n{\n\n    \n       // translation and scale\n    return scale(vec3(2./(r-l),2./(t-b),2./(f-n))) * \n                 translate(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.));\n    \n}\n\nmat4 orthoInv(float l, float r, float b, float t, float n, float f)\n{\n    return translateInv(vec3(-(l+r)/2.,-(t+b)/2.,-(f+n)/2.)) *\n        scaleInv(vec3(2./(r-l),2./(t-b),2./(f-n)));\n}\n\nmat4 projection(float n, float f)\n{\n \t// n 0 0 0\t0\n    // 0 n 0 0\t0\n    // 0 0 n+f\t-fn\n    // 0 0 1\t0\n    return mat4(\n        vec4(n,0.,0.,0.),\n        vec4(0.,n,0.,0.),\n        vec4(0.,0.,n+f,1.),\n        vec4(0.,0.,-f*n,0.)\n        );\n}\n\nmat4 projectionInv(float n, float f)\n{\n \t// 1/n \t0 \t0 \t\t0\n    // 0 \t1/n\t0 \t\t0\n    // 0\t0\t0 \t\t1\n    // 0\t0\t-1/fn\t(f+n)/fn\n    \n    return mat4(\n        vec4(1./n,0.,0.,0.),\n        vec4(0.,1./n,0.,0.),\n        vec4(0.,0.,0.,-1./(f*n)),\n        vec4(0.,0.,1.,(f+n)/(f*n))\n        );\n}\n\n\nmat4 perspective(float fov, float aspect, float n, float f)\n{\n \t   float l = tan(fov/2.)*n;\n       float b = l/aspect;\n    \n    \treturn ortho(-l,l,-b,b,n,f)*\n            projection(n,f)*rightToLeft();\n}\n\n\nmat4 perspectiveInv(float fov, float aspect,float n, float f)\n{\n     float l = tan(fov/2.)*n;\n       float b = l/aspect;\n    \n    return rightToLeftInv()*\n        projectionInv(n,f)*\n        orthoInv(-l,l,-b,b,n,f);\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n \t\n    vec3 z = normalize(eye-center);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = cross(z,x);\n    \n    mat4 v = mat4(\n        vec4(x.x,y.x,z.x,0.),\n        vec4(x.y,y.y,z.y,0.),\n        vec4(x.z,y.z,z.z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n    \n    return v*translate(-eye);\n}\n\nmat4 lookAtInv(vec3 eye, vec3 center, vec3 up)\n{\n \tvec3 z = normalize(eye-center);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = cross(z,x);  \n    \n    return translateInv(-eye)*mat4(\n        vec4(x,0.),\n        vec4(y,0.),\n        vec4(z,0.),\n        vec4(0.,0.,0.,1.)\n        );\n}\n\n\n\n#endif //CAMERA_H_", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3GRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[826, 826, 853, 913, 1111], [1113, 1113, 1157, 1157, 1214], [1216, 1216, 1251, 1251, 1289], [1290, 1290, 1324, 1324, 1358], [1360, 1360, 1403, 1403, 1440], [1442, 1442, 1562, 1562, 1902], [1904, 1904, 1951, 1951, 2008], [2009, 2009, 2048, 2048, 2072], [2073, 2073, 2108, 2108, 2132], [2133, 2133, 2171, 2171, 2200], [2202, 2202, 2258, 2258, 2397], [2399, 2399, 2456, 2456, 2590], [2592, 2592, 2642, 2642, 2779], [2781, 2781, 2884, 2884, 3046], [3048, 3048, 3100, 3100, 3153], [3155, 3155, 3205, 3205, 3301], [3303, 3303, 3340, 3340, 3446], [3448, 3448, 3485, 3485, 3593], [3595, 3722, 3759, 3759, 3895], [3897, 3897, 3925, 3925, 4216], [4218, 4218, 4242, 4242, 4281], [4283, 4283, 4300, 4300, 4494], [4495, 4495, 4515, 4515, 4617], [4619, 4619, 4639, 4639, 4741], [4743, 4743, 4798, 4798, 6763]]}
{"id": "sddGW7", "name": "pali raymarching 1", "author": "pali6", "description": "A very basic raymarching thingie.\nClickdrag mouse to rotate camera.", "tags": ["raymarching"], "likes": 3, "viewed": 172, "published": 3, "date": "1629992019", "time_retrieved": "2024-07-30T19:04:49.659305", "image_code": "vec3 camPos = vec3(0, 0, 0);\nvec3 camDir = vec3(0, 0, -1);\nvec3 camUp = vec3(0, 450. / 800., 0);\nfloat camF = 0.5;\nfloat rtStep = 0.4;\nfloat rtlStep = 0.025;\nfloat rtglStep = 0.3;\nconst int maxSteps = 32;\nconst int maxlSteps = 32;\nconst int maxglSteps = 32;\n\nfloat time;\n\nvec3 lightPos = vec3(4, 3, -1);\n\nvec3 INVALID = vec3(1e10, 1e20, -1e30);\n\nfloat smin(float a, float b)\n{\n    return (a + b - log(exp(a - b) + exp(b - a))) / 2.;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rayDir(vec2 uv)\n{\n    vec3 camRight = normalize(cross(camDir, camUp));\n    return normalize(camDir * camF + (uv.y - 0.5) * 2. * camUp + (uv.x - 0.5) * 2. * camRight);\n}\n\nvec3 orbit(vec3 normal, float dist, float speed, float offset)\n{\n    vec3 v1 = normalize(cross(normal, vec3(0.42, 0.1, -0.1)));\n    vec3 v2 = normalize(cross(normal, v1));\n    return dist * (v1 * cos(time * speed + offset) + v2 * sin(time * speed + offset));\n}\n\nfloat scene(vec3 pos)\n{\n    vec3 ballCenter = vec3(0, 0, -5);\n    float ballRadius = 2.;\n    float result =  distance(pos, ballCenter) - ballRadius + sin(pos.y * 5. + time) / 3. * cos(time * 0.2);\n    vec3 ballCenter2 = ballCenter + orbit(vec3(0, 1, 0), 3., 1., 0.);\n    result = smin(result, distance(pos, ballCenter2) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 12, 0), 2.7, 1.7, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 2, 5), 2.7, 1.8, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(8, 7, -8), 2.7, 1.9, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-14, -5, -1), 2.7, 2.0, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(1, 12, 0), 2.7, 0.8, 0.8)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-7, -5, 8), 2.6, 1.7, 0.1)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-1, 1, 22), 2.5, 1.2, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter2 + orbit(vec3(0.1, -0.5, -1), 0.8, -0.41, -0.2)) - 0.15);\n    /*\n    result -= (dot(pos - ballCenter, normalize(vec3(1, 3, 7)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(-7, 2, 1)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(2, -1, 0.3)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(4, 3, -1)))) * 0.1;\n    */\n    // result += 1./distance(pos, vec3(-2, -2, -7));\n    result = 2. - abs(result - 2.);\n    result = smin(result, length((pos - ballCenter).xz) - 0.3);\n    return result;\n}\n\nvec3 sceneNormal(vec3 pos)\n{\n    float d = 0.001;\n    float base = scene(pos);\n    return normalize(vec3(\n        scene(pos + vec3(d, 0, 0)) - base,\n        scene(pos + vec3(0, d, 0)) - base,\n        scene(pos + vec3(0, 0, d)) - base\n    ));\n}\n\nvec4 rt(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    float retVal = 0.;\n    float stp = rtStep;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(val < 0.001)\n        {\n            retVal = 1.;\n        }\n        if(sign(val * lastVal) == -1.)\n            stp /= 2.;\n        lastVal = val;\n        rayPos += rayDir * stp * sign(val);\n    }\n    return vec4(rayPos, 1.);\n}\n\nvec4 rtl(vec3 rayPos, vec3 rayDir, float maxDist)\n{\n    float lastVal = 0.;\n    float tot = 0.;\n    for(int i = 0; i < maxlSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(maxDist <= 0.1 || val > 40.)\n        {\n            float a = -val / (lastVal - val);\n            rayPos -= rtStep * rayDir * a;\n            return vec4(rayPos, tot);\n        }\n        if(val <= 0.001)\n            tot += rtlStep * (-val);\n        lastVal = val;\n        float step = rtlStep;\n        maxDist -= length(rayDir) * step;\n        rayPos += rayDir * step;\n    }\n    return vec4(rayPos, tot);\n}\n\nfloat rtgl(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    float result = 0.;\n    for(int i = 0; i < maxglSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(val < 0. || val > 40.)\n        {\n            float a = -val / (lastVal - val);\n            // val = (lastVal + val) / 2.;\n            //result += rtStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.2, 0.3, val)) * val * a;\n            return result;\n        }\n        //if(lastVal > 0.1 && val < 0.09)\n        //    result += rtStep * val * 3.;\n        result += rtglStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.2, 0.3, val)) * val * val;\n        // result += min(10., 1. / pow(val, 2.2) * smoothstep(0., 1., (val - 0.05) / 0.1)) * rtStep;\n        rayPos += rayDir * rtglStep * val;\n        lastVal = val;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    lightPos = vec3(3., 3.*sin(iTime), -1. + cos(iTime));\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    camPos = vec3(cos(mousePos.x * 3.14 * 2.), -(mousePos.y - 0.5) * 1.5, sin(mousePos.x * 3.14 * 2.)) * 4.5 + vec3(0, 0, -5);\n    camDir = normalize(vec3(0, 0, -5) - camPos);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    \n    vec4 hitInfo = rt(camPos, rayDir(uv));\n    vec3 hit = hitInfo.xyz;\n    if(hitInfo.w != 0.)\n    {\n        vec4 lightHitInfo = rtl(lightPos, hit - lightPos, distance(hit, lightPos));\n        vec3 lightHit = lightHitInfo.xyz;\n        col = mix(vec3(1, 0.1, 0.2), vec3(0.4, 0.4, 0.2), distance(hit, vec3(0, 0, -5)) / 6.);\n        /*if(distance(hit, vec3(0, 0, -5)) > 4.)\n            col = vec3(0.4, 0.25, 0.2);\n        else\n            col = vec3(1, 0.1, 0.2);// * (1.-abs(dot(rayDir(uv), sceneNormal(hit))));\n        */\n        float light = 0.1;\n        light += 4. / distance(lightHit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)) * (1. / (1. + lightHitInfo.w * 100.)));\n        // light += 4. / distance(hit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)));\n        col *= light;\n        // col -= vec3(1.-light, 1.-light, 1.-light);\n    }\n    else\n    {\n        col = vec3(0, 0, 0); //texture(iChannel0, hit.xy / 5.0 - vec2(1, 1)).xyz;\n    }\n    col.b += rtgl(camPos, rayDir(uv)) * 5.;\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 346, 376, 376, 434], [436, 436, 457, 457, 527], [529, 529, 551, 551, 702], [704, 704, 768, 768, 964], [966, 966, 989, 989, 2578], [2580, 2580, 2608, 2608, 2823], [2825, 2825, 2860, 2860, 3245], [3247, 3247, 3298, 3298, 3837], [3839, 3839, 3877, 3877, 4662], [4664, 4664, 4721, 4721, 6163]]}
{"id": "Ndd3D7", "name": "GLSL bug #60 : fract != mod(x,1)", "author": "FabriceNeyret2", "description": "should be white ( fract(x) == mod(x,1) ).\non windows / angle, I get this https://i.imgur.com/dWeuVR6.png\nBut the difference is weak: ~1e-6 ( uncomment last line to see ).", "tags": ["glsl", "bug"], "likes": 3, "viewed": 348, "published": 3, "date": "1629977740", "time_retrieved": "2024-07-30T19:04:50.500057", "image_code": "// acid test for https://www.shadertoy.com/view/fdt3Rn lines 39,43\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U *= .1;\n    O = vec4( fract(U) == mod(U,1.) );\n    \n // O = vec4( abs ( fract(U) - mod(U,1.) ) * 5e5, 0,1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndd3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 106, 106, 222]]}
{"id": "7s33WM", "name": "Persian carpet 5", "author": "jarble", "description": "A slightly simpler formula, with a much nicer range of colors.", "tags": ["fractal", "carpet", "rug"], "likes": 8, "viewed": 300, "published": 3, "date": "1629939421", "time_retrieved": "2024-07-30T19:04:51.261023", "image_code": "\n//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((iTime+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = .25;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float t3 = float(c)+t2;\n        vec3 random2 = hash31(1.+t3);\n        float scale2 = 1.+random2.x;\n        //vec3 col_prev = 0.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = -1.1;\n            \n            uv = triangle_wave(uv.yx+1.5,scale)+triangle_wave(uv,scale);\n            for(int j = 0; j < 3;j++){\n                uv = triangle_wave((uv+offset),scale);\n            }\n            uv.x /= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            //uv = -uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/8.;\n            if(i>0) col = (col.yzx*random2.x + col_prev*random2.y)/(random2.x+random2.y);\n            col[c] = fract((uv.x)-(uv.y));\n\n            \n\n        }\n\n            //random3 = (hash31(2.+t3)-vec3(.5))/4.;\n            //random4 = (hash31(3.+t3)-vec3(.5))/4.;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s33WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 456, 478, 523, 656], [658, 658, 697, 697, 742], [744, 744, 801, 801, 2284]]}
{"id": "NscGDM", "name": "Caustics 4", "author": "FabriceNeyret2", "description": "WIP\nDraw the caustic of a given heightfield ( set in BuffD ), at a depth controlled by mouse.y or time.\nUses the Voronoi particle tracking method to display the lightwave surface at given depth.", "tags": ["2d", "particles", "splat", "swarm", "boids", "voronoitracking", "write2xy", "writetoxy", "voronoiparticlestracking"], "likes": 30, "viewed": 1085, "published": 3, "date": "1629920309", "time_retrieved": "2024-07-30T19:04:52.142665", "image_code": "// Fork of \"Crowdy waves 2\" by FabriceNeyret2. https://shadertoy.com/view/3ty3Dy\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = T2(I) * vec4(.7,1,2,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// === particle Physics: caustic surface = surface mesh BuffD offseted in the refracted direction.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n\n#define T(U) texture( iChannel2, (U)/R ).r\n\n    vec3 L = vec3(0,0,-1);\n    vec2 d = vec2(1,0);\n    float M = iMouse.z > 0. ? 2.* iMouse.y/R.y - 1.\n                            : sin(iTime);\n                            \n    O = R.y*vec4( U/R.y, T(U), 1 );      // O.xyz = 3D height field\n    vec3 N = normalize(vec3( T(U+d)-T(U-d), T(U+d.yx)-T(U-d.yx), 2./R.y ) ),\n         D = refract(L,N, 1./1.33);      // refracted light direction\n    O.xyz += R.y* .15 * M * D;           // offset the lightwave surface\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// === Vorono buffer: manage tracking of particles Ids\n\n// --- insert (i,d) and maintain the 4 closest (i_,d_) \nvoid list_insert(inout vec4 i, inout vec4 d, float i_, float d_){\t\n    if(i_ == 0.) return;           // not a particle : exit\n    if(any(equal(vec4(i_),i))) return; // already in top4 : exit\n    if     (d_ < d[0])             // closer to closest: insert here\n        i = vec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             // closer to 2nd closest: insert here\n        i = vec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])             // closer to 3rd closest: insert here\n        i = vec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])             // closer to 4th closest: insert here\n        i = vec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec4  i = vec4(0),\n         i0 = T1( I ),             // 4 closests particles here and around\n         ia = T1( I + vec2( 1, 0) ),  // NB: could use an array.\n         ib = T1( I + vec2( 0, 1) ),\n         ic = T1( I + vec2(-1, 0) ),\n         id = T1( I + vec2( 0,-1) );\n\n//#define dist(i) length( A(i).xy - I )\n//#define dist(i) length( mod( A(i).xy-I + R/2., R) - R/2. )  \nvec2 D;\n#define dist(i) ( D = mod( A(i).xy-I + R/2., R) - R/2., dot(D,D) )\n\n    vec4  d = vec4(1e9); \n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, i0[k], dist(i0[k]) );\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#if 0 // also checking diagonal (to test possibly axis bias)\n    ia = T1( I + vec2( 1, 1) ),\n    ib = T1( I + vec2(-1, 1) ),\n    ic = T1( I + vec2( 1,-1) ),\n    id = T1( I + vec2(-1,-1) );\n    for(int k = 0; k < 4; k++){    // sorts all these\n        list_insert( i, d, ia[k], dist(ia[k]) );\n        list_insert( i, d, ib[k], dist(ib[k]) );\n        list_insert( i, d, ic[k], dist(ic[k]) );\n        list_insert( i, d, id[k], dist(id[k]) );\n    }\n#endif\n    \n    for(int k = 0; k < 1; k++){    // try to re-insert some random particle (possibly escaped from tracking)\n      //int r = IHash( int(I.x) + int(I.y)*2048 + iFrame*2048*2048 +k*11131); //deterministic\n        int r = IHash( int(I.x) + int(I.y)*2141 + iFrame*2141*2141 +k*11131); //without 2048 bias\n      //int r = IHash( int(I.x) + int(I.y)*2048 + (int(iTime*2048.)+iFrame)*2048 +k*11131);\n        int i_ =  1 + r % ( int(R.x*R.y)/int(Nb) ); // [ why /10? ]\n        list_insert(i, d, float(i_), dist(i_) );\n    }\n    O = vec4(i);                   // stores 4 closest\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Nb 1. // 10. use only 1/N % of the max Rx*Ry particles (for readability)\n\n// Buff B (1) store Vorono tracking acceleration structure;\n//            xyzw: ids of 4 closest partics to buffer location\n// Buff A (0) stores particles: \n//            xy: position zw: velocity\n\n// --- translate particle id (in [1,Rx*Ry] ) to buffer pixel \n#define A(n) T0( vec2( (int(n)-1) % iR.x,      \\\n                       (int(n)-1) / iR.x ) +.5 )  // +.5 useless\n\n// --- utils\n                           \n#define R     iResolution.xy\n#define iR    ivec2(iResolution)\n#define T0(U) texelFetch( iChannel0, ivec2(U)   , 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U)%iR, 0 )\n#define T2(U) texelFetch( iChannel2, ivec2(U)   , 0 )\n\n#define l2(x) dot(x,x)\n\n#define TAU 6.2831853\n                           \n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n                           \n// --- keyboard\n#define key(k,mode) ( texelFetch( iChannel3, ivec2(k,mode), 0 ).x > .5 )\n#define keyDown(k) key(k,0)\n#define  keyHit(k) key(k,1)\n#define keyFlip(k) key(k,2)\n\n\n// --- random numbers\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\n#define Hash(a) ( float(IHash(a)) / float(0x7FFFFFFF) ) // Uniform in [0,1]\n\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\n\n// --- normal law random generator\nvec2 randn(vec2 r){ // r: randuniform\n    r.x = sqrt( -2.* log(1e-9+abs(r.x)));\n    r.y *= TAU;\n    return r.x * vec2(cos(r.y),sin(r.y));\n}\n", "buffer_c_code": "// === draw + blend with fading past\n\n//  WIP: for doing lightwave surface\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n#define Ad(n,X,Y) T0( vec2( (int(n)-1) % iR.x,      \\\n                       (int(n)-1) / iR.x ) +.5 +vec2(X,Y) )  // +.5 useless\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = vec4(0);\n    vec4 a = T1(I), P;         // 4 particule id (supposed to be particles closest to I)\n    \n    float d = 99.;\n    for(int i = 0; i < 4; i++) // draw Gaussian blobs\n        P = A(a[i]),\n #if 0                         // WIP: drawing mesh of lightwave surface\n        d = min(d, line(I,P.xy, Ad(a[i],-1, 0).xy) ),\n        d = min(d, line(I,P.xy, Ad(a[i], 0, 1).xy) ),\n        d = min(d, line(I,P.xy, Ad(a[i], 1, 0).xy) ),\n        d = min(d, line(I,P.xy, Ad(a[i], 0,-1).xy) );\n    O = vec4(smoothstep(1.5,0.,d));\n#else\n        O += .4* exp( -.5* l2( I - P.xy ) ) \n             ; //*  ( .5+.5*texture(iChannel3,P.xy/R) ); // color surface by the source texture\n    O = mix(O, T2(I), .9);     // blend with fading past\n // O = mix(O, texture(iChannel2,-.01+1.02*I/R), .9); // false-3D variant\n#endif\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// --- source height field\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texture(iChannel0,.3*U/R) / .3;\n // U *= 30./R.y; O = vec4( sin(U.x + sin(.3*U.y) - 0.*iTime ) );\n}", "buffer_d_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscGDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 120, 120, 154]]}
{"id": "Nd3GDM", "name": "Republic Of Korea Flag", "author": "hyunamy", "description": "Republic Of Korea Flag", "tags": ["flag", "korea", "rok", "nation"], "likes": 8, "viewed": 272, "published": 3, "date": "1629911556", "time_retrieved": "2024-07-30T19:04:53.033284", "image_code": "// Created by hyunamy - 2021.08\n// License Creative Commons Attribution-NonCommercial-Share Hyunamy 3.0 Unported License.\n\nconst float PI = 3.141592;\n\nvec3 RED = vec3(206., 17., 39.) / 255.;\nvec3 BLUE = vec3(0., 62., 135.) / 255.;\n\nconst float PadX = .39;\nconst float PadY = .26;\n\nconst float LW = .3;\nconst float CenterScale = .625;\nconst float WingScale = .43;\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s = sin(angle), c=cos(angle);\n    return mat2( c, -s, s, c );\n}\n\nfloat Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1 * step2;\n}\n\nfloat Rect(vec2 uv, float l, float r, float b, float t, float blur) \n{\n    float band1 = Band(uv.x, l, r, blur);\n    float band2 = Band(uv.y, b, t, blur);    \n    \n    return band1 * band2;\n}\n\nvec4 LeftTop(vec2 uv, float angle, float scale)  \n{\n    vec4 col = vec4(0);\n    \n    uv *= rotationMatrix(angle) / scale;\n    \n    col += Rect(uv, -LW, LW, .1, .2, .005);   \n    col += Rect(uv, -LW, LW, -.05, .05, .005);   \n    col += Rect(uv, -LW, LW, -.2, -.1, .005);   \n    col.rgb *= 0.;\n    \n    return col;\n}\n\nvec4 RightTop(vec2 uv, float angle, float scale)\n{\n    vec4 col = vec4(0);   \n    \n    uv *= rotationMatrix(angle) / scale;\n    \n    float w = .45;\n    float l = LW - LW * w;\n    float r = LW - LW * w;\n    \n    col += Rect(uv, -LW * w - l, LW * w - l, .1, .2, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, .1, .2, .005);   \n    col += Rect(uv, -LW, LW, -.05, .05, .005);    \n    col += Rect(uv, -LW * w - l, LW * w - l, -.2, -.1, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, -.2, -.1, .005);   \n    \n    col.rgb *= 0.;\n    return col;\n}\n\nvec4 LeftBottom(vec2 uv, float angle, float scale)\n{\n    vec4 col = vec4(0);   \n    \n    uv *= rotationMatrix(angle) / scale;\n    \n    float w = .45;\n    float l = LW - LW * w;\n    float r = LW - LW * w;\n    \n    col += Rect(uv, -LW, LW, .1, .2, .005);   \n    col += Rect(uv, -LW * w - l, LW * w - l, -.05, .05, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, -.05, .05, .005);\n    col += Rect(uv, -LW, LW, -.2, -.1, .005); \n    \n    col.rgb *= 0.;\n    return col;\n}\n\nvec4 RightBottom(vec2 uv, float angle, float scale)\n{\n    vec4 col = vec4(0);   \n    \n    uv *= rotationMatrix(angle) / scale;\n    \n    float w = .45;\n    float l = LW - LW * w;\n    float r = LW - LW * w;\n     \n    col += Rect(uv, -LW * w - l, LW * w - l, .1, .2, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, .1, .2, .005);   \n    col += Rect(uv, -LW * w - l, LW * w - l, -.05, .05, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, -.05, .05, .005);\n    col += Rect(uv, -LW * w - l, LW * w - l, -.2, -.1, .005);   \n    col += Rect(uv, -LW * w + r, LW * w + r, -.2, -.1, .005);     \n    \n    col.rgb *= 0.;\n    return col;\n}\n\nvec4 CenterBody(vec2 uv, float scale)\n{\n    vec2 rotatedUV = uv * rotationMatrix(30.) / scale;\n    \n    float body = smoothstep(0.01, 0., rotatedUV.y);    \n    vec4 col = vec4(mix(RED, BLUE, body), 1.);\n\n    float d = length(rotatedUV);\n    col.a = smoothstep(0.4, 0.39, d);    \n    \n    float sd = length(rotatedUV - vec2(-0.2, 0.0));\n    float sc = smoothstep(0.205, 0.195, sd);\n    col.rgb = mix(col.rgb, RED, sc);\n    \n    sd = length(rotatedUV - vec2(0.2, 0.0));\n    sc = smoothstep(0.205, 0.195, sd);\n    col.rgb = mix(col.rgb, BLUE, sc);\n    \n    return col;\n}\n\nvec4 Flag(vec2 uv)\n{\n    vec4 col = vec4(0); \n    \n    vec4 body = CenterBody(uv, CenterScale);    \n    col = mix(col, body, body.a);\n    \n    vec4 lt = LeftTop(uv - vec2(-PadX,PadY), -50., WingScale);\n    col = mix(col, lt, lt.a);\n    \n    vec4 rt = RightTop(uv - vec2(PadX,PadY), 50., WingScale);\n    col = mix(col, rt, rt.a);\n    \n    vec4 lb = LeftBottom(uv - vec2(-PadX,-PadY), 50., WingScale);\n    col = mix(col, lb, lb.a);\n    \n    vec4 rb = RightBottom(uv - vec2(PadX,-PadY), -50., WingScale);\n    col = mix(col, rb, rb.a);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float t = uv.x * 5. - iTime * 1.4 + uv.y * 3.5;\n    uv.y += sin(t)*.035;\n    \n    vec4 col = vec4(1);    \n    \n    vec4 flag = Flag(uv);\n    col = mix(col, flag, flag.a);\n    float shadow = .95 + cos(t) *.156;    \n    col *= shadow;\n    col *= smoothstep(0.5, 0.495, abs(uv.y)); \n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3GDM.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[364, 364, 398, 398, 494], [496, 496, 553, 553, 691], [693, 693, 763, 763, 884], [886, 886, 937, 937, 1200], [1202, 1202, 1252, 1252, 1757], [1759, 1759, 1811, 1811, 2232], [2234, 2234, 2287, 2287, 2873], [2875, 2875, 2914, 2914, 3442], [3444, 3444, 3464, 3464, 3998], [4000, 4000, 4057, 4057, 4438]]}
{"id": "fsd3WN", "name": "Explicit Time Integration Spring", "author": "A1exandre", "description": "Press SPACE to reset simulation.\nCLICK to attract end of pendulum.\n\nForked used to create an example for graphics gems.", "tags": ["simulation", "interactive", "physics", "pendulum", "spring", "forwardeuler"], "likes": 15, "viewed": 401, "published": 3, "date": "1629910977", "time_retrieved": "2024-07-30T19:04:54.443514", "image_code": "float udTriangleWave(in vec2 p, in float freq, in float amp) {\n    float pw = 1.0 / freq, qw = 0.25 * pw;\n    vec2 sc = vec2(2.0 * amp, pw);\n    float l = length(sc);\n    p.x = abs(mod(p.x + qw, pw) - 0.5 * pw) - qw;\n    p *= mat2(sc, -sc.y, sc.x) / l;\n    return length(vec2(p.x, max(0.0, abs(p.y) - 0.25 * l)));\n}\n\nvoid drawSpring(in vec2 fragCoord, in vec2 p0, in vec2 p1, in vec2 thickness,\n                in int loops, in vec4 color, inout vec4 outputColor) {\n\n    vec2 n = p1 - p0;\n    float l = length(n), hl = l * 0.5;\n\n    fragCoord -= p0;\n    fragCoord *= mat2(n, n.y, -n.x) / l;\n\n    float d = max(udTriangleWave(fragCoord, float(loops) / l, thickness.x) - thickness.y, abs(fragCoord.x - hl) - hl);\n    outputColor = mix(outputColor, color, smoothstep(1.0, 0.0, d));\n}\n\nvoid drawPendulum(in vec2 fragCoord, inout vec4 outColor) {\n  float totalMass = 0.0;\n  for (int i = 0; i < rods; i++) {\n    totalMass += masses[i];\n  }\n\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  vec2 previous = anchor;\n  for (int i = 0; i <= rods; i++) {\n    vec2 position;\n    if (i < rods) {\n      position = anchor + ballData(STORAGE, i).xy * scale;\n      drawSpring(\n          fragCoord, previous, position,\n          vec2(0.8 * scale, clamp(0.05 * stiffnesses[i], 0.05, 0.12) * scale), 9,\n          vec4(vec3(0.0), 1.0), outColor);\n    }\n\n    float radius = i == 0 ? 0.05 : 0.4 * pow(masses[i - 1] / totalMass, 0.6);\n    vec3 color = i == 0 || black ? vec3(0.0) : palette[(i - 1) % colors];\n\n    drawDisk(fragCoord, previous, (radius + 0.1) * scale, vec4(vec3(0.0), 1.0),\n             outColor);\n    drawDisk(fragCoord, previous, radius * scale, vec4(color, 1.0), outColor);\n\n    previous = position;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  fragColor = texture(iChannel1, uv);\n\n  drawPendulum(fragCoord, fragColor);\n\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int rods = 3;\nconst vec2 center = vec2(0.0, 5.3);\nconst float[] lengths = float[](3.0, 3.0, 3.0, 2.5, 3.0, 4.0);\nconst float[] angles = float[](-70.0, -30.0, 70.0, 0.0, 0.0, 0.0);\nconst float[] masses = float[](1.0, 1.0, 2.0, 1.0, 1.0, 1.0);\nconst float[] stiffnesses = float[](0.7, 0.7, 0.7, 0.7, 0.7, 0.7);\nconst float[] dampings = float[](0.01, 0.01, 0.01, 0.01, 0.01, 0.01);\nconst bool continuous = true;\nconst bool black = false;\nconst int colors = 6;\nconst vec3[] palette =\n    vec3[](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0),\n           vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0));\nconst float fade = 0.03;\nconst float damping = 1.0;\nconst vec2 g = vec2(0.0, -9.8); // gravity\nconst float h = 0.01; //time step\n\n#define STORAGE iChannel0\nconst ivec2 resolutionDataLocation = ivec2(0, 2);\n\n#define KEY_SPACE 32\nbool isKeyPressed(in sampler2D keyboard, in int keyCode) {\n  return texelFetch(keyboard, ivec2(keyCode, 1), 0).x > 0.0;\n}\n\nvec4 ballData(in sampler2D storage, in int index) {\n  return texelFetch(storage, ivec2(index, 0), 0);\n}\n\nvec2 previousBallPosition(in sampler2D storage, int index) {\n  return texelFetch(storage, ivec2(index, 1), 0).xy;\n}\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvoid drawDisk(in vec2 fragmentCoordinates, in vec2 center, in float radius,\n              in vec4 color, inout vec4 outputColor) {\n  float d = distance(fragmentCoordinates, center);\n  float a = 1.0 - clamp(d - radius + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}", "buffer_a_code": "#define KEYBOARD iChannel1\n\nconst float pi = 3.1416;\n\nbool saveResolutionData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == resolutionDataLocation) {\n    vec4 previousResolutionData = texelFetch(STORAGE, fragCoord, 0);\n    vec2 oldResolution = previousResolutionData.xy;\n    fragColor = vec4(iResolution.xy, oldResolution);\n\n    return true;\n  }\n\n  return false;\n}\n\nbool isMousePressed() { return iMouse.z > 0.0; }\n\nvec2 hookesLaw(in vec2 anchorPosition, in vec2 massPosition,\n               in float l0, float k) {\n  //Finding the spring direction vector\n  vec2 springDirection = anchorPosition - massPosition;\n  if (length(springDirection) < 0.0001) {\n    return vec2(0.0);\n  }\n  \n  //Computing the spring length\n  float l = length(springDirection);\n  \n  //Computing spring contribution\n  return k * (l - l0) * normalize(springDirection);\n}\n\nvoid forwardEuler(inout vec4 current, in float h) {\n  //Adding Gravity\n  current.zw += g * h;\n\n  // Forward Euler\n  current.xy += current.zw * h;\n}\n\nbool initialization(in ivec2 fragCoord, out vec4 fragColor) {\n  if (iFrame > 0 && !isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    return false;\n  }\n\n  if (fragCoord.x > rods || fragCoord.y > 1) {\n    return false;\n  }\n\n  vec2 position = vec2(0.0);\n  float angle = pi / 2.0;\n  for (int i = 0; i < rods; i++) {\n    angle += angles[i] * pi / 180.0;\n    position += vec2(sin(angle), cos(angle)) * lengths[i];\n    vec4 data = vec4(position, vec2(0.0));\n    if (fragCoord.x == i) {\n      fragColor = data;\n    }\n  }\n\n  return true;\n}\n\nbool simulation(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord.x > rods || fragCoord.y > 1) {\n    return false;\n  }\n\n  if (fragCoord.y == 1) {\n    fragColor = ballData(STORAGE, fragCoord.x);\n    return true;\n  }\n\n  vec4[rods] data;\n  for (int i = 0; i < rods; i++) {\n    data[i] = ballData(STORAGE, i);\n  }\n\n    //Particles\n    for (int i = 0; i < rods; i++) {\n      vec4 previous = i > 0 ? data[i - 1] : vec4(0.0);\n\n      // Spring\n      vec2 force =\n          hookesLaw(previous.xy, data[i].xy, lengths[i], stiffnesses[i]);\n          \n      vec2 impulse = (force / masses[i]);\n      data[i].zw += impulse;\n\n      if (i > 0) {\n        data[i - 1].zw -= (force / masses[i - 1]);\n      }\n\n      // Damper\n      vec2 toAnchor = previous.xy - data[i].xy;\n      if (length(toAnchor) > 0.0001) {\n        toAnchor = normalize(toAnchor);\n        vec2 velocityDelta = previous.zw - data[i].zw;\n        vec2 dampingForce = dampings[i] * velocityDelta;\n        data[i].zw += dampingForce;\n        if (i > 0) {\n          data[i - 1].zw -= dampingForce;\n        }\n      }\n    \n    for (int i = 0; i < rods; i++) {\n      forwardEuler(data[i], h);\n    }\n  }\n\n  float damp = damping;\n  if (isMousePressed()) {\n    float scale = iResolution.y / 20.0;\n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.0) / scale - center;\n    vec2 toMouse = mouse - data[rods - 1].xy;\n    float magnitude = length(toMouse);\n    if (magnitude > 0.1) {\n      data[rods - 1].zw += normalize(toMouse) * magnitude;\n      damp = 0.96;\n    }\n  }\n\n  if (damp < 1.0) {\n    for (int i = 0; i < rods; i++) {\n      data[i].zw *= damp;\n    }\n  }\n\n  int i = fragCoord.x;\n  fragColor = data[i];\n\n  return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  ivec2 iFragCoord = ivec2(fragCoord);\n\n  if (saveResolutionData(iFragCoord, fragColor)) {\n    return;\n  }\n\n  if (initialization(iFragCoord, fragColor)) {\n    return;\n  }\n\n  simulation(iFragCoord, fragColor);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define KEYBOARD iChannel2\n\nbool resolutionChanged() {\n  vec4 resolutionData = texelFetch(STORAGE, resolutionDataLocation, 0);\n  return resolutionData.xy != resolutionData.zw;\n}\n\nvoid drawTrials(in vec2 fragCoord, inout vec4 outColor) {\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  for (int i = 0; i < rods; i++) {\n    vec2 position = anchor + ballData(STORAGE, i).xy * scale;\n    vec3 color = black ? vec3(0.0) : palette[i % colors];\n    if (continuous) {\n      vec2 previous = anchor + previousBallPosition(STORAGE, i).xy * scale;\n      drawSegment(fragCoord, position, previous, 0.14 * pow(scale, 0.7),\n                  vec4(color, 1.0), outColor);\n    } else {\n      drawDisk(fragCoord, position, 0.11 * pow(scale, 0.7), vec4(color, 1.0),\n               outColor);\n    }\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec4 background = vec4(vec3(0.85), 1.0);\n  if (iFrame == 0 || resolutionChanged() || isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    fragColor = background;\n  } else {\n    fragColor = mix(texture(iChannel1, uv), background, fade);\n  }\n  drawTrials(fragCoord, fragColor);\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsd3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 315], [317, 317, 465, 465, 780], [782, 782, 841, 841, 1747], [1749, 1749, 1804, 1804, 1972]]}
{"id": "fsc3WM", "name": "Planar Light", "author": "rodousse", "description": "Just a plane and a quad, playing around with polygonal mesh lights as a first draft of a real time implementation ", "tags": ["raytracingbrdfplanarlight"], "likes": 11, "viewed": 383, "published": 3, "date": "1629909690", "time_retrieved": "2024-07-30T19:04:55.330143", "image_code": "#define PI 3.14159265\n//Camera field of view \n#define FOV 45.0\n//Camera rotation speed \n#define ROTATION_SPEED 0.5\n//distance of the camera from the sphere\n#define CAM_DISTANCE 10.0\n//distance of the camera from the ground\n#define CAM_HEIGHT 3.0\n\nvec3 center = vec3(0.0,1.0,0.0);\n\nvec3 lightColor = vec3(1.0,1.0,1.0);\nfloat intensity = 5.0;\nvec3 diffuse = vec3(1.0,1.0,1.0);\nvec3 spec = vec3(1.0, 1.0,1.0);\n\nvec3 quadCenter = vec3(0.0,1.0,0.0);\nvec3 quadNormal = normalize(vec3(1.0,0.0,0.0)); // fix Y orientation causing trouble to compute the up vector\nvec2 quadSize = vec2(3.5, 2.0);\n\nvec3 background = vec3(.05); \n\n//Todo : Compute the spherical triangle area not the planar triangle\nfloat triangleArea(vec3 A, vec3 B, vec3 C)\n{\n    return length(cross(B-A, C-A))*0.5;\n}\n\n// Diffuse BRDF\n// Todo, sample the quad domain, and weight the samples with a ggx\nvec3 BRDF(vec3 normal, vec3 pos, vec3 qc, vec3 qn, vec2 qs)\n{\n    vec3 right = normalize(cross(qn, vec3(0., 1., 0.)));\n    vec3 up = cross(right, qn);\n    vec2 qsH = qs*0.5;\n    vec3 qcPos = qc - pos;\n    vec3 hRight = right * qsH.x;\n    vec3 hUp = up * qsH.y;\n    \n    //Coordinate of the rectangle vertices on the unit sphere\n    vec3 A = normalize(qcPos - hRight - hUp);\n    vec3 B = normalize(qcPos - hRight + hUp);\n    vec3 C = normalize(qcPos + hRight + hUp);\n    vec3 D = normalize(qcPos + hRight - hUp);\n    \n    return intensity * lightColor * (triangleArea(A, B, C) + triangleArea(A, D, C)) / (2. * PI);\n}\n\n\nfloat hitPlane(vec3 dir, vec3 rayPoint, vec3 center, vec3 normal)\n{\n    return max(-(dot(rayPoint, normal)-dot(center, normal)) / dot(normal, dir),0.0);\n}\n\nfloat hitQuad(vec3 dir, vec3 rayPoint, vec3 center, vec3 normal, vec2 size, out vec2 uv)\n{\n    float t = hitPlane(dir, rayPoint, center, normal);\n    vec3 interPoint = rayPoint + t*dir;\n    vec3 right = normalize(cross(normal, vec3(0., 1., 0.)));\n    vec3 up = cross(right, normal);\n    vec3 interVec = interPoint - center;\n    uv = vec2(dot(right, interVec), dot(up, interVec));\n    vec2 posCenter = abs(uv);\n    uv = (uv/size) + vec2(.5);\n    if(posCenter.x<size.x*0.5 && posCenter.y<size.y*0.5)\n        return t;\n    else\n        return -9999999999999.;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    quadNormal.y = quadNormal.y - .000001;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (uv - vec2(0.5)) * 2.0 * vec2(1.0, float(iResolution.x)/float(iResolution.y));\n    \n    // Camera infos\n    vec3 cam = vec3(CAM_DISTANCE, 1.0, CAM_DISTANCE) * vec3(cos(iTime * ROTATION_SPEED), CAM_HEIGHT, sin(iTime * ROTATION_SPEED)) ;\n    \n    float near = 0.01f;\n    float viewportHeight = 2.0f * near * tan(FOV * 0.5f * PI/180.0f);\n    float viewportWidth = viewportHeight * iResolution.x / iResolution.y;\n    vec3 forward = normalize(center-cam) * near;\n\n    vec3 right = normalize(cross(forward, vec3(0.0,1.0,0.0)));\n    vec3 up = normalize(cross(right, forward)) / (float(iResolution.x)/float(iResolution.y));\n    \n    // Ray generation\n    vec3 dir = (right * cuv.x * (viewportWidth/2.0f));\n    dir += (up * cuv.y * (viewportHeight/2.0f));\n    dir += forward;\n    dir = normalize(dir);\n    \n    // Raytrace ground\n    vec3 normal = vec3(0.0,1.0,0.0);\n    float t = hitPlane(dir, cam, vec3(0.0,0.0,0.0), normal);\n    vec3 colGround = BRDF(normal, cam + dir*t, quadCenter, quadNormal , quadSize);\n    \n    //Raytrace quad\n    vec2 quadUv;\n    float quadT = hitQuad(dir, cam, quadCenter, quadNormal , quadSize, quadUv);\n    vec3 colQuad = lightColor;\n    \n    //Compose\n\tvec3 col;\n    if(length(t*dir) < length(quadT*dir))\n     col = colGround;\n    else\n     col = colQuad;\n     \n    col = mix(background, col, min(max(t, quadT),1.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsc3WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 690, 734, 734, 776], [778, 861, 922, 922, 1476], [1479, 1479, 1546, 1546, 1633], [1635, 1635, 1725, 1725, 2193]]}
{"id": "NsdGDN", "name": "Urban Smog", "author": "dr2", "description": "Where's the fresh air?", "tags": ["fog", "city", "glider", "flight", "skyscraper"], "likes": 24, "viewed": 594, "published": 3, "date": "1629879378", "time_retrieved": "2024-07-30T19:04:56.366372", "image_code": "// \"Urban Smog\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat BumpFbm3 (vec3 p);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm1 (float p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flyerMat;\nvec3 flyerPos, qHit, sunDir, noiseDisp;\nvec2 cId, cIdT;\nfloat dstFar, tCur, szFacFl, flrHt, bShape, bWid, bWidU, bHt, bHtU, hiMid,\n   tWid, twHt, nFloor, fogAmp, fogTop;\nint idObj;\nconst int idBldgF = 1, idBldgC = 2, idTwr = 3, idTwrTop = 4, idRoad = 5, idSWalk = 6,\n   idFlyer = 7;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a;\n  dMin = dstFar / szFacFl;\n  q = flyerMat * (p - flyerPos) / szFacFl;\n  q.x = abs (q.x);\n  a = 0.22 * pi;\n  q.z -= -0.25;\n  qq = q;\n  qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), - a);\n  d = abs (max (max (abs (dot (vec2 (qq.y, abs (dot (vec2 (qq.x, qq.z - 1.1),\n     sin (0.012 * pi + vec2 (0.5 * pi, 0.))))), sin (a + vec2 (0.5 * pi, 0.)))) -\n     0.002, 0.), max (dot (q.xz, sin (0.15 * pi + vec2 (0.5 * pi, 0.))) - 0.5, - q.z - 0.5))) - 0.02;\n  DMINQ (idFlyer);\n  return szFacFl * dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0002 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid SetBldgParms ()\n{  //  (based on \"Urban Growth\")\n  bHt = (0.25 * Hashfv2 (13. * cId) + 0.05) * (1. + 0.15 / flrHt) + 0.1;\n  nFloor = floor (bHt * (0.6 + 0.4 * length (sin (0.125 * pi * cId))) / flrHt);\n  bHt = (nFloor + 0.3) * flrHt;\n  bWid = floor ((0.17 /*0.2*/ + Hashfv2 (11. * cId) * 0.1) / flrHt + 0.5) * flrHt;\n  bShape = Hashfv2 (17. * cId);\n  cIdT = mod (cId + 8., vec2 (16.)) - 8.;\n  hiMid = 0.75 * clamp (4. / max (length (cIdT), 1.), 0., 1.);\n  bWidU = floor (bWid * (0.5 + 0.3 * Hashfv2 (12. * cId)) / flrHt + 0.5) * flrHt;\n  bHt = (0.5 * Hashfv2 (13. * cId) + 0.05) * hiMid *\n     (1.5 + (bWid - 0.15) / flrHt) + 0.1;\n  bHtU = 0.25 * bHt + 0.75 * max (0., Hashfv2 (15. * cId) - 0.5) * hiMid + 0.05;\n  bHt = (floor (bHt / flrHt) + 0.2) * flrHt;\n  bHtU = floor (bHtU / flrHt) * flrHt;\n  if (bHtU > 0.) bHtU += 0.2 * flrHt;\n  if (cIdT == vec2 (0.)) {\n    bHt = max (bHt, 40.2 * flrHt);\n    bHtU = max (bHtU, 20.2 * flrHt);\n  }\n  tWid = ((bHtU > 0.) ? bWidU : bWid) - 0.0125;\n}\n\nfloat BldgDf (vec3 p, float dMin)\n{\n  vec3 pp, q;\n  vec2 s;\n  float d;\n  q = p;\n  d = q.y;\n  DMINQ (idRoad);\n  pp = p;\n  pp.xz = fract (pp.xz) - vec2 (0.5);\n  q = pp;\n  q.y -= 0.0015;\n  d = PrBoxDf (q, vec3 (0.35, 0.0015, 0.35));\n  DMINQ (idSWalk);\n  if (bHt > 0.) {\n    q.y -= bHt - 0.2 * flrHt + 0.0005;\n    if (bShape > 0.25) {\n      d = PrBoxDf (q, vec3 (bWid, bHt, bWid));\n      DMINQ (idBldgF);\n    } else {\n      d = PrCylDf (q.xzy, bWid, bHt);\n      DMINQ (idBldgC);\n    }\n    q.y -= bHt + bHtU - 0.2 * flrHt - 0.001;\n    if (bHtU > 0.) {\n      if (bShape > 0.5) {\n        d = max (PrBoxDf (q, vec3 (bWidU, bHtU, bWidU)),\n           - PrBoxDf (q - vec3 (0., bHtU, 0.), vec3 (tWid, 0.1 * flrHt, tWid)));\n        DMINQ (idBldgF);\n      } else {\n        d = max (PrCylDf (q.xzy, bWidU, bHtU),\n           - PrCylDf ((q - vec3 (0., bHtU, 0.)).xzy, tWid, 0.1 * flrHt));\n        DMINQ (idBldgC);\n      }\n    }\n    q.y -= bHtU - 0.2 * flrHt - 0.001;\n    if (bShape < 0.1) {\n      d = PrCapsDf (q.xzy, 0.4 * bWidU, 1.25 * flrHt);\n      DMINQ (idBldgC);\n    } else if (bShape > 0.7) {\n      d = PrBoxDf (q, vec3 (0.25 * bWidU, 1.25 * flrHt, 0.25 * bWidU));\n      DMINQ (idBldgF);\n    }\n    if (bHt + bHtU > 30. * flrHt) {\n      twHt = 0.1 * (bHt + bHtU);\n      q.y -= twHt;\n      d = PrCapsDf (q.xzy, 0.3 * flrHt, twHt);\n      DMINQ (((q.y > 0.9 * twHt) ? idTwrTop : idTwr));\n    }\n    if (cIdT.x == 0. && cIdT.y == 0.) {\n      q = pp;\n      q.y -= 2. * (bHt + bHtU) + 0.2 * flrHt;\n      d = PrCylDf (q.xzy, 0.3, flrHt);\n      DMINQ (idBldgC);\n    }\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  return BldgDf (p, dstFar);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 cIdP, rdi, s;\n  float dHit, d;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi = 1. / rd.xz;\n  cIdP = vec2 (-999.);\n  dHit = 0.01;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p.xz);\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetBldgParms ();\n    }\n    d = ObjDf (p);\n    s = (cId + step (0., rd.xz) - p.xz) * rdi.xy;\n    dHit += min (d, 0.001 + max (0., min (s.x, s.y)));\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 BldgCol (vec3 vn)\n{\n  vec4 col4;\n  vec2 g;\n  float wFac, f;\n  wFac = 1.;\n  col4 = vec4 (HsvToRgb (vec3 (0.7 * Hashfv2 (19. * cId), 0.2,\n     0.4 + 0.2 * Hashfv2 (21. * cId))), 0.3);\n  if (abs (vn.y) < 0.05) {\n    f = mod (qHit.y / flrHt - 0.2, 1.) - 0.5;\n    wFac = 1. - (step (0., f) - 0.5) * step (abs (abs (f) - 0.24), 0.02) -\n       0.801 * step (abs (f), 0.22);\n    if (wFac < 0.2) {\n      f = (idObj == idBldgF) ? 1.5 * dot (qHit.xz, normalize (vn.zx)) :\n         length (qHit.xz) * (atan (qHit.z, qHit.x) + 0.5 * pi);\n      wFac = min (0.2 + 0.8 * floor (fract (f / flrHt + 0.25) *\n         (1. + Hashfv2 (51. * cId))), 1.);\n    }\n    col4.rgb *= wFac;\n  } else if (vn.y > 0.95) {\n    g = step (0.05, fract (qHit.xz * 70.));\n    col4.rgb *= mix (0.8, 1., g.x * g.y);\n  }\n  if (vn.y < 0.95 && wFac > 0.5)\n     col4.rgb *= (0.8 + 0.2 * Noisefv2 (512. * vec2 (qHit.x + qHit.z, qHit.y)));\n  if (wFac < 0.5) col4.a = -2.;\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, vec3 vn)\n{\n  vec4 col4;\n  col4 = vec4 (0.);\n  if (idObj == idBldgF || idObj == idBldgC) {\n    col4 = BldgCol (vn);\n  } else if (idObj == idTwr) {\n    col4 = vec4 (0.3);\n  } else if (idObj == idTwrTop) {\n    col4 = vec4 (1., 0., 0., -2.);\n  } else if (idObj == idRoad) {\n    col4.rgb = vec3 (0.15, 0.15, 0.17);\n  } else if (idObj == idSWalk) {\n    col4.rgb = vec3 (0.2);\n  }\n  return col4;\n}\n\nfloat FogHt (vec2 p)\n{  // (based on \"Misty Terraces\")\n  mat2 qRot;\n  vec4 t4;\n  vec2 q, t, tw;\n  float wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  q = p + vec2 (0., 0.05 * tCur);\n  wAmp = 1.;\n  h = 0.;\n  tw = 0.05 * tCur * vec2 (1., -1.);\n  for (int j = 0; j < 5; j ++) {\n    q *= 2. * qRot;\n    t4 = abs (sin (2. * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wAmp *= 0.5;\n  }\n  return fogTop - 0.5 * h;\n}\n\nfloat FogDens (vec3 p)\n{\n  return fogAmp * (0.2 + 0.8 * smoothstep (0., 1., 1. - p.y / fogTop)) *\n     BumpFbm3 (0.03 * (p + noiseDisp)) * smoothstep (0., 1., FogHt (0.1 * p.xz) - p.y);\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{\n  float s, ds, f, fn;\n  s = 1.;\n  ds = 1.;\n  fn = FogDens (ro + s * rd);\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    s += ds;\n    f = fn;\n    fn = FogDens (ro + (s + 0.5 * ds * Hashfv3 (16. * rd)) * rd);\n    col = mix (col, vec3 (0.95, 0.95, 1.) * (1. - clamp (f - fn, 0., 1.)),\n       min (f * (1. - smoothstep (0.5 * dHit, dHit, s)), 1.));\n    if (s > dHit) break;\n  }\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 p, col, clCol;\n  float fd, f, ff;\n  rd.y = (rd.y + 0.1) / 1.1;\n  rd = normalize (rd);\n  col = vec3 (0.7);\n  if (rd.y > 0.) {\n    p = rd * (200. - ro.y) / max (rd.y, 0.0001);\n    p += ro + 4. * tCur;\n    p *= 0.01;\n    ff = Fbm2 (p.xz);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (p.xz + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.7, 0.7, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd),\n       clCol, 0.1 + 0.9 * f * fd);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, rdr;\n  vec2 g, vf;\n  float dstObj, dstFlyer, s, f;\n  noiseDisp = 0.02 * tCur * vec3 (-1., 0., 1.) + 0.5 * sin (vec3 (0.2, 0.1, 0.3) * pi * tCur);\n  fogAmp = 1.;\n  fogTop = 4.;\n  roo = ro;\n  vf = vec2 (0.);\n  dstFlyer = FlyerRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < min (dstFlyer, dstFar)) {\n    ro += dstObj * rd;\n    cId = floor (ro.xz);\n    SetBldgParms ();\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro, rd, vn);\n    col = col4.rgb;\n    if (col4.a >= 0.) {\n      if (idObj == idRoad) vf = vec2 (512., 1.);\n      else if (idObj == idBldgF || idObj == idBldgC) vf = vec2 (512., 0.5);\n      if (vf.x > 0.) vn = VaryNf (vf.x * qHit, vn, vf.y);\n      col = col * (0.3 + 0.3 * max (dot (vn.xz, - normalize (sunDir.xz)), 0.) +\n         0.2 * max (vn.y, 0.) + 0.7 * max (dot (vn, sunDir), 0.)) +\n         col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else if (col4.a == -2.) {\n      rdr = reflect (rd, vn);\n      g = Rot2D (rdr.xz, 5.1 * atan (20. + cId.y, 20. + cId.x));\n      f = step (1., 0.3 * ro.y + 4. * rdr.y -\n         0.1 * floor (5. * IFbm1 (0.3 * atan (g.y, g.x) + pi) + 0.05));\n      if (idObj == idBldgF || idObj == idBldgC) {\n        if (f == 1.) col = mix (0.7 * col, BgCol (ro, rdr), 0.5);\n        else col += 0.05;\n      }\n    }\n    if (col4.a == -2.) col *= 1. - 0.95 * smoothstep (0.4, 0.7, dstObj / dstFar);\n    col = mix (col, vec3 (0.3), smoothstep (0.6, 1., dstObj / dstFar));\n  } else if (dstFlyer < dstFar) {\n    ro += dstFlyer * rd;\n    vn = FlyerNf (ro);\n    col = vec3 (0.3, 1., 0.3);\n    col = mix (col, 1. - col, smoothstep (0.02, 0.04, abs (length (vec2 (qHit.xz -\n       vec2 (0.3, -0.1))) - 0.17)) * (1. - smoothstep (0.95, 0.97, qHit.z)));\n    col = col * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n       0.2 *  pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  col = FogCol (col, roo, rd, min (dstFlyer, dstObj));\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{ \n  vec3 p;\n  float pLen, s, cCount;\n  pLen = 2.;\n  p.y = 2.5;\n  s = mod (t, 11.);\n  if (s < 7.) p.xz = (s < 4.) ? vec2 (0., s) : vec2 (s - 4., 4.);\n  else p.xz = (s < 9.) ? vec2 (3., 11. - s) : vec2 (12. - s, 2.);\n  cCount = floor (t / 11.);\n  if (mod (cCount, 2.) == 0.) p.x *= -1.;\n  else p.x -= 1.;\n  p.z += 2. * cCount;\n  p.xz *= pLen;\n  return p;\n}\n\nvoid FlyerPM (float s, float rl, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, ca, sa;\n  float ds, rlFac, elFac, el, az;\n  ds = 0.12;\n  elFac = 0.7;\n  rlFac = 0.02;\n  fpF = 0.5 * (TrackPath (s + 2. * ds) + TrackPath (s + ds));\n  fpB = 0.5 * (TrackPath (s - 2. * ds) + TrackPath (s - ds));\n  vel = normalize (fpF - fpB);\n  acc = (fpF - 2. * TrackPath (s) + fpB) / (2.25 * ds * ds);\n  flPos = 0.5 * (fpF + fpB);\n  va = cross (acc, vel);\n  el = - elFac * asin (vel.y);\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  rl += rlFac * length (va) * sign (va.y);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, flMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, ori, ca, sa, vd;\n  vec2 canvas, uv, uvv;\n  float spd, el, az, zmFac, asp, sr, tPos;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  el = 0.;\n  az = 0.;\n  spd = 0.3;\n  tPos = spd * tCur;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = clamp (0.45 * pi * mPtr.y, -0.18 * pi, 0.18 * pi);\n  }\n  zmFac = 2.5;\n  asp = canvas.x / canvas.y;\n  szFacFl = 0.04;\n  FlyerPM (tPos, 0.2 * pi * (Fbm1 (3.5 * tPos) - 0.5), 1., flyerPos, flyerMat);\n  flyerPos.y -= 0.2;\n  FlyerPM (tPos - 0.3, 0., 0., ro, flMat);\n  ro.xz += 0.01;\n  ori = vec3 (-0.02 * pi, 0.001 * pi, 0.1 * pi * (Fbm1 (1.5 * tPos) - 0.5));\n  ori.xy += vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.);\n  dstFar = 50.;\n  flrHt = 0.07;\n  sunDir = normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    rd = normalize (vec3 (2. * tan (0.5 * atan (uvv.x / (asp * zmFac))) * asp, uvv.y / zmFac, 1.));\n    rd = (vuMat * rd) * flMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nfloat BumpFbm3 (vec3 p)\n{\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 0.5;\n    a *= 0.75;\n  }\n  return f;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat IFbm1 (float p)\n{\n  float s, a;\n  p *= 5.;\n  s = 0.;\n  a = 10.;\n  for (int j = 0; j < 4; j ++) {\n    s += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return 0.1 * s;\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdGDN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1126, 1126, 1150, 1150, 1672], [1674, 1674, 1709, 1709, 1895], [1897, 1897, 1920, 1920, 2172], [2174, 2174, 2196, 2227, 3165], [3167, 3167, 3202, 3202, 4735], [4737, 4737, 4759, 4759, 4790], [4792, 4792, 4825, 4825, 5346], [5348, 5348, 5369, 5369, 5626], [5628, 5628, 5652, 5652, 6573], [6575, 6575, 6616, 6616, 6996], [6998, 6998, 7020, 7052, 7546], [7548, 7548, 7572, 7572, 7735], [7737, 7737, 7791, 7791, 8179], [8181, 8181, 8212, 8212, 8861], [8863, 8863, 8898, 8898, 10923], [10925, 10925, 10951, 10951, 11305], [11307, 11307, 11383, 11383, 12186], [12188, 12188, 12244, 12244, 13975], [13977, 13977, 14009, 14009, 14109], [14111, 14111, 14153, 14153, 14204], [14206, 14206, 14249, 14249, 14313], [14315, 14315, 14372, 14372, 14455], [14457, 14457, 14487, 14487, 14600], [14602, 14602, 14633, 14633, 14697], [14699, 14699, 14723, 14723, 14840], [14842, 14842, 14868, 14868, 14930], [14932, 14932, 14957, 14957, 15019], [15021, 15021, 15046, 15046, 15310], [15344, 15344, 15368, 15368, 15405], [15407, 15407, 15431, 15431, 15491], [15493, 15493, 15517, 15517, 15582], [15584, 15584, 15608, 15608, 15661], [15663, 15663, 15687, 15687, 15799], [15801, 15801, 15825, 15825, 15888], [15890, 15890, 15914, 15914, 16057], [16059, 16059, 16084, 16084, 16230], [16232, 16232, 16257, 16257, 16443], [16445, 16445, 16470, 16470, 16807], [16809, 16809, 16831, 16831, 16985], [16987, 16987, 17010, 17010, 17174], [17176, 17176, 17197, 17197, 17352], [17354, 17354, 17383, 17383, 17595], [17597, 17597, 17636, 17636, 17888]]}
{"id": "fstGDN", "name": "effin w/Silexars' shader XsXXDn ", "author": "femalefaust", "description": "all in title.  see https://www.shadertoy.com/view/XsXXDn.  ", "tags": ["silexars", "sphere"], "likes": 14, "viewed": 1340, "published": 3, "date": "1629876546", "time_retrieved": "2024-07-30T19:04:57.264970", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(tan(z)+1.)*abs(tan(l*9.-z*2.));\n\t\tc[i]=.01/length(abs(mod(uv,1.)-.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}\n\n// based on this shader by Silexars\n// https://www.shadertoy.com/view/XsXXDn", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstGDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 224, 224, 468]]}
{"id": "NddGWN", "name": "CubeLand", "author": "scry", "description": "why are there cubes\n\nidk why I couldn't quite get the fllor on line 68 to line up correctly\nalso if anyone knows why is gets grainy as it gets to ~300 iTime, that would be appreciated.", "tags": ["3d", "raymarch", "trippy", "polar", "logpolar"], "likes": 6, "viewed": 311, "published": 3, "date": "1629864618", "time_retrieved": "2024-07-30T19:04:58.026932", "image_code": "#define time iTime\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 map(vec3 p) {\n    \n    p.z -= 5.;\n    //p.z += time*20.; \n    //p.xy -= (sin(time)*3);\n    //p.yz *= r2d(-02);\n    vec3 o = p;\n    float d = 1000.;\n    p = o;\n    float lxz = (length(p.xz));\n    //vec2 pc = p.xz;\n    vec2 pc = vec2(log(lxz),atan(p.x,p.z));\n    //p.y += (sin(pc.x*10.-time*30)+sin(pc.y*1.+lxz+time*10.)*3)*0.01*lxz;\n    //pc.y += time*0.01;\n    //pc = vec2(log(length(pc)),atan(pc.x,pc.y));\n    \n    float ns = 1.;\n    //pc.y *= 3./3.141;\n    //pc.y = (fract(pc.y-0.5));\n    //pc.y *= 2./3.141;\n    \n    pc.x -= time*0.3;\n\n\n    vec3 bp = p;\n    float fy = 0.;\n    float bps = 0.6;\n    vec2 fpc = pc;\n    //fpc.y *= .;\n    //fpc.x *= 16./3.14159; \n    fpc = floor(fpc/bps)*bps;\n   \n    //fpc.y = floor(fpc.y/bps)*bps;\n    //fpc.y += sin(time);\n    for (int i=0;i<4;i++) {\n        ns += 1.0;\n        //p.y += (sin(pc.x*10*ns*0.1*pc.y*0.00)*0.4)*lxz*0.1;\n        p.y += (sin(pc.y*6.*ns*0.5+pc.x*sin(ns*0.5)*10.)*0.04)*lxz;\n        p.y += (sin(pc.y*2.*ns*0.5+pc.x*sin(ns*20.)*20.)*0.04)*lxz;\n        fy += (sin(fpc.y*6.*ns*0.5+fpc.x*sin(ns*0.5)*10.)*0.04)*lxz;\n        fy += (sin(fpc.y*2.*ns*0.5+fpc.x*sin(ns*20.)*20.)*0.04)*lxz;\n        //p.y += (sin(pc.x*sin(ns)*20.03)+sin(pc.y*sin(ns)*40.+pc.x*0.1))*0.01*lxz;\n        //p.y += (sin(pc.x*ns-time*3*ns+pc.y)+sin(pc.y*ns+pc.x))*0.04*lxz;\n        \n    }\n    bp.zx = pc;\n    //bp.z *= 1;\n    bp.y += 1.; \n    bp.x /= 1./bps;\n    bp.x *= 8./3.14159;\n    bp.x += sin(bp.z*.1)*5.;\n    bp.xz = (fract(bp.xz/bps)-0.5)*bps;\n    //bp.y /= lxz;\n    //bp.y += -0.05;\n    \n    bp.y += (fy*sin(log(lxz)*2.+time));\n    bp.y -= 0.2;\n    bp.y /= lxz;\n    bp.xz *= r2d(pc.y*0.1);\n    bp.xy *= r2d(pc.y*0.4);\n    //bp.y *= 0.3;\n    float db = sdBoxFrame(bp,vec3(0.03),0.004)*(lxz+0.1)*0.5;\n    //db *= lxz;\n    //db *= 0.99;\n    //db -= 0.001;\n    //d = min(d,//);\n    //pc.y *= 3./3.141;\n    //pc.y = (fract(pc.y-0.5));\n    //pc.y += 1./3.14;\n    \n    //pc.y *= 10./3.14;\n    //p.y += sin(pc.y*10.+pc.x*20.+time*4.)*0.2;\n    //p.y += lxz;\n    if (p.y+1. > db) {\n        pc.y -= 2.;\n    }\n    d = db-0.;\n    d = min(d,length(p.y+1.)*0.3);\n    //d += 0.01;\n    //float d = length(p)-1.;\n    return vec4(pc.x,lxz,pc.y,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<64;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.02;\n        if (dO > 24.2 || dS < 0.0005) {break;}\n    }\n    return vec2(dO,ii);\n}\n\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.00003; // or some other value\n    const vec2 h = vec2(eps,0.);\n    return normalize( vec3(map(p+h.xyy).w - map(p-h.xyy).w,\n                           map(p+h.yxy).w - map(p-h.yxy).w,\n                           map(p+h.yyx).w - map(p-h.yyx).w ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * (fragCoord/iResolution.xy);\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x*=ar;\n    float c = length(uv);\n    //uv.y -= 0.3;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,0.,2.);\n    vec3 rd = normalize(vec3(uv,.75+c*0.75));\n    vec2 ra = vec2(cos(time),sin(time))*0.3;\n\n    //ro.z += sin(uv.x*4.*uv.y+time*2.)-c*2.;\n    //ro.z *= 0.2;\n    //ra.z += sin(time+sin(uv.x));\n    //ra.x += floor(sin((uv.x*1.)*150.*(sin(uv.x*0.01+time*0.1)*0.5+0.5)))*0.1;\n    //ra.y += floor(sin((uv.y*1.)*150.*(sin(uv.y*0.01+time*0.08)*0.5+0.5)))*0.1;\n    //ra.x += sin(uv.y*1.+time)*0.2;\n    //ro.xz *= r2d(ra.x);\n    //rd.xz *= r2d(ra.x);\n    //ro.yz *= r2d(ra.y);\n    rd.yz *= r2d(-.25);\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    \n    vec3 mp = map(p).xyz;\n    //p.xy *= r2d(time);\n    vec3 norm = calcNormal(p);\n    p.z -= 5.;\n    float lz = length(p.xz);\n    \n    //col = 1.-d.xxx*.1;\n    col = hsv2rgb(vec3(floor(mp.z/3.14/2.*5.+mp.x*0.4)/5.,floor(sin(mp.x*10.1+mp.z*2.)*2.)/2.,(1.15-d.x*0.2)));\n    \n    //col = hsv2rgb(vec3(floor(mp.z/3.14/2*5.+mp.x*0.4)/5.,floor(sin(mp.x*10.1+mp.z*2.)*2.)/2,clamp(1.-d.x*0.1,0.,1.)));\n    col += (clamp(sin(mp.z*30.)+sin(mp.x*90.),-0.,0.1)*5.-0.5)+d.y*0.08;\n    norm.xz *= r2d(mp.x*0.2);\n    col += (norm.x*2.)*0.4;\n    //col.rg += (d.y*0.05-0.5);\n    fragColor = vec4(col,1.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddGWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 88], [90, 90, 135, 135, 417], [419, 478, 500, 500, 831], [835, 894, 916, 916, 1085], [1087, 1087, 1105, 1105, 3258], [3260, 3260, 3287, 3287, 3527], [3530, 3530, 3581, 3581, 3854], [3856, 3856, 3913, 3913, 5368]]}
{"id": "fsdGD4", "name": "smokering doodle", "author": "elenzil", "description": "trying out this iterating deformation of coordinates thing..", "tags": ["doodle"], "likes": 30, "viewed": 1840, "published": 3, "date": "1629850332", "time_retrieved": "2024-07-30T19:04:58.788895", "image_code": "const float zoom = 0.5;\nconst float pi   = 3.0;\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY ) {\n    float smallResDim = min(iResolution.x, iResolution.y);\n    vec2 P = (2.0 * XY - iResolution.xy) / smallResDim;\n    P /= zoom;\n    float smoothEpsilon = 10.0 / smallResDim;\n    \n    const int iters = 140;\n    vec2 p = P;\n    vec2 q = P;\n    for (int iter = 0; iter < iters; ++iter) {\n        p.x += sin(p.y * pi * 2.0 + iTime * 0.97) * 0.005;\n        p.y += sin(p.x * pi * 2.0 + iTime * 0.13) * 0.005;\n        \n        p *= rot2(0.01);\n        \n        if (iter % 2 == 0) {\n            q.x += 2.0 * sin(p.y * pi * 2.0 + iTime * 0.97) * 0.005;\n            q.y += 2.0 * sin(p.x * pi * 2.0 + iTime * 0.13) * 0.005;\n\n            q *= rot2(0.02);\n        }\n    }\n    \n    float d = length(p);\n    float e = length(q);\n    float dd = d - (sin(iTime * 0.1) * 0.2 + 1.2);\n    float c = smoothstep(0.0, smoothEpsilon, abs(dd) - 0.2);\n    float h = 1.0 - smoothstep(0.0, 0.4, abs(dd) - 0.01);\n    c = max(c, 1.0 - (h * 0.97));\n    \n    if (dd < 0.0) {\n        vec2 uv = XY/iResolution.xy;\n        uv.x = 1.0 - uv.x;\n        c = mix(c, min(c, pow(1.0 - texture(iChannel0, uv).r, 5.0) + 0.8), sin(iTime * 0.231) * 0.2 + 0.2);\n    }\n \n#if 0\n    float theta = atan(q.y, q.x);\n    float g = sin(theta * 2.0 + iTime * 1.1);\n    c = max(c, smoothstep(0.0, smoothEpsilon, 1.0 - abs(g - 1.992)));\n#endif\n    \n    RGBA = vec4(vec3(c), 1.0);\n    \n    float shadow = 1.0 - 0.4 * (1.0 - smoothstep(0.0, 0.4, abs(e - (sin(iTime * 0.1) * 0.2 + 1.2)) - 0.1));\n    RGBA.rgb = min(RGBA.rgb, mix(vec3(0.3, 0.5, 0.0), vec3(1.0), shadow));\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdGD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 73, 73, 157], [159, 159, 204, 204, 1718]]}
{"id": "Ndc3DN", "name": "sunbeam diffraction", "author": "mdb", "description": "2D visualisation of a laser with realistic like physics", "tags": ["glass", "pathtracing", "laser", "diffraction"], "likes": 42, "viewed": 1192, "published": 3, "date": "1629824630", "time_retrieved": "2024-07-30T19:04:59.746336", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;   \n        \n    \n    col += 0.01;\n    col = 1.0 - exp(-0.7*col);\n    //col *= 1.0 - exp(-dot(col, vec3(0.213, 0.715, 0.072)));\n    \n    // add triangle in the center\n    uv = uv*2.0 - 1.0;\n    uv.x = abs(uv.x);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    col *= mix(1.0, 0.7, clamp(length(uv)*4.0 - 0.4, -0.5, 1.0)*smoothstep(-0.01, 0.01, uv.y + 0.25)*smoothstep(-0.01, 0.01, dot(uv - vec2(0.0, 0.5), vec2(-sqrt(3.0)*0.5, -0.5))));\n    \n    // Output to screen\n    col = pow(col, vec3(1.0/2.2)); // sRGB encoding\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define laserBounces 6\n#define SPP 30\n//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRandomGenerator(fragCoord);\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    for(int j = 0; j < SPP; j++){\n    \n    //laser color\n    float w = mix(380.0, 780.0, random());\n    const float A = 1.2280;\n    const float B = 0.09;\n    float n2 =  A + B/(w*w*1e-6);\n    vec3 color = waveLenghtToRGB(w);\n    \n    float n1 = 1.0;\n    // float n2 = 1.333;\n    float R0 = pow((n1 - n2)/(n1 + n2), 2.0);\n    \n    \n    //laser setup\n    vec2 p0 = vec2(-2.0, 0.0);\n    float k = 0.04+ 0.2*sin(iTime*0.2);\n    //k = 0.04 - 0.17;\n    vec2 rd = vec2(cos(k), sin(k));\n    float inside = -1.0;\n    for(int b = 0; b < laserBounces; b++){\n        //intesect\n        vec2 normal;\n        float tmin = map(p0, rd, normal);\n        \n       \n        float t = tmin;\n        if(t < 0.0) t = 1e7;\n        \n        // color\n        vec2 nrd = vec2(-rd.y, rd.x);\n        float d2 = dot(rd, uv - p0);\n        if( d2 > 0.0 && d2 < t) col += 10.0*color * exp(-50.0*abs(dot(nrd, uv - p0)));\n        vec2 p2 = p0 + rd * t;\n        \n        vec2 uvp2 = p2 - uv;\n        float l = length(uvp2);\n        if(dot(normal, -uvp2) > -0.1) col += 2.0*color * 0.01*smoothstep(-0.05, 0.05, dot(normal, -uvp2/l)) / (l*l + 0.07);\n        if(dot(normal, -uvp2) < 0.1) col += 1.0*color * 0.01*smoothstep(0.05, -0.05, dot(normal, -uvp2/l)) / (l*l + 0.07);\n        \n        //next ray setup\n        float R = R0 + (1.0 - R0)*dot(normal, -rd);\n        if(random() < 1.0 - R){\n            rd = reflect(rd, normal);\n        }else{\n            rd = refract(rd, normal, pow(n2, inside));\n            inside = -inside;\n        }\n        \n        p0 = p2 + rd*0.00001;\n        \n        if(tmin < 0.0) break;\n    \n    }\n    \n    }\n    col /= float(SPP);\n    vec3 last = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    col = mix(col, last, 0.95);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct triangle {vec2 a, b, c;};\n\ntriangle[] scene = triangle[](triangle(0.5*vec2(0.0, 1.0),\n                                       0.5*vec2(sqrt(3.0)*0.5, -0.5),\n                                       0.5*vec2(-sqrt(3.0)*0.5, -0.5)));\n\n\nfloat Isegment(vec2 ro, vec2 rd, vec2 p0, vec2 p1, out vec2 n)\n{\n    vec2 v1 = ro - p0;\n    vec2 v2 = p1 - p0;\n    vec2 v3 = vec2(-rd.y, rd.x);\n\n\n    float d =  dot(v2, v3);\n    float t1 = -((v1.x*v2.y) - (v1.y*v2.x)) / d;\n    float t2 = dot(v1, v3) / d;\n\n    if (t1 >= 0.0 && (t2 >= 0.0 && t2 <= 1.0)){\n        n = normalize(vec2(-v2.y, v2.x));\n        n *= -sign(dot(n, rd));\n        return t1;\n    }\n\n    return -1.0;\n}\n\nfloat Itriangle(vec2 ro, vec2 rd, triangle tri, out vec2 n){\n    float t, tmin;\n    vec2 n2;\n    tmin = Isegment(ro, rd, tri.a, tri.b, n);\n    \n    t = Isegment(ro, rd, tri.a, tri.c, n2);\n    if(t >= 0.0 && (t < tmin || tmin < 0.0)) {tmin = t; n = n2;}\n    \n    t = Isegment(ro, rd, tri.b, tri.c, n2);\n    if(t >= 0.0 && (t < tmin || tmin < 0.0)) {tmin = t; n = n2;}\n    return tmin; \n\n}\n\nfloat map(vec2 ro, vec2 rd, out vec2 normal){\n    float tmin = -1.0;\n    for(int i = 0; i < 1; i++){ // scene.length()\n        triangle tri = scene[i];\n        vec2 n;\n        float t = Itriangle(ro, rd, tri, n);\n        if(t >= 0.0 && (t < tmin || tmin < 0.0)) {tmin = t; normal = n;}\n    }\n    return tmin;\n}\n\n//wavelength stuff\n\n// from https://www.shadertoy.com/view/7tjSDh\n// http://www.cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[81] =\n    vec3[81] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);\n\n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}\n\nvec3 waveLenghtToRGB(float w){\n    float bb = 1e-13 * BlackBody(6000.0, w);\n    vec3 XYZ = bb*WavelengthToXYZLinear(w);\n    return XYZtosRGB(XYZ);\n\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 748]]}
{"id": "7dt3WH", "name": "Silence of the Lambs", "author": "dean_the_coder", "description": "Hannibal Lecter's cell from the 'Silence of the Lambs' movie.", "tags": ["3d", "raymarching", "voronoi", "rock", "dungeon", "horror", "movie", "cineshader"], "likes": 33, "viewed": 6650, "published": 3, "date": "1629804106", "time_retrieved": "2024-07-30T19:05:00.604042", "image_code": "// 'Silence of the Lambs' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/7dt3WH (YouTube: https://youtu.be/DkaaJbfpNxE)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Hannibal Lecter's cell from the 'Silence of the Lambs' movie.\n// I wish my GPU has enough power to render some posters and drawings\n// on the cell wall! Probably quite doable if I used multiple buffers,\n// but I always try to make my code single-buffer with no predefined\n// textures.\n//\n// Tricks to ('try and'!) get the performance:\n// - The stone walls are flat planes, and the material is bump-mapped.\n//   Adding texture by adjusting the SDF would look nice, but increase\n//   the number of steps in the march loop.\n//   (I use dFdx and dFdy to approximate the normal of the texture.)\n// - The material code (lights()) is called _outside_ the raymarch loop\n//   to keep the loop code minimal (should the compiler decide to unroll it).\n// - The glass is a flat plane, so the normal passed into 'reflect()'\n//   can be hard-coded.\n// - The FBM noise function is only called once in lights(), and then used\n//   by several materials.\n// - Lots of use of abs() to mirror along axis.\n//   (There's only one 'actual' prison cell - The other is mirrored.)\n// - Use of fract() on the x-axis to repeat the holes in the glass.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle, totetmatt, byt3_m3chanic, and a bunch of others for sharing\n// their time and knowledge! If you want to get into shader coding, I'd\n// recommend giving them a 'Google'.\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define LIGHT_RGB\tvec3(4.9, 3.9, 3.5)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define NM normalize\n#define minH(a, b)\t{ float u = a; if (u < h.x) h = vec2(u, b); }\n\nfloat g = 0.;\n\nvec2 h22(vec2 v) {\n\tvec3 p = fract(v.xyx * vec3(.1031, .103, .0973));\n\tp += dot(p, p.yzx + 33.33);\n\treturn fract((p.xx + p.yz) * p.zy);\n}\n\nvec4 h44(vec4 p) { p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p)); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat min3(vec3 v) { return min(v.x, min(v.y, v.z)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = NM(lookAt - ro),\n\t     r = NM(cross(vec3(0, 1, 0), f));\n\treturn NM(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec4 brkT(vec3 p) {\n\tfloat n = n31(p * 7.),\n\t      s = step(.4, dot(vec3(n31(p), n, n31(p * 15.)), vec3(.75, .15, .1)));\n\tp.y -= .03;\n\tp.x -= step(fract(p.y * 1.87 - .05), .5) * 2.6;\n\tp.z -= .33;\n\tvec3 c = vec3(.2, .03, .01);\n\tc *= .2 + n * n * .5;\n\treturn vec4(mix(vec3(.2), c, sat(S(0., .02, min3(abs(fract(p * vec3(1, 3.74, 2.23)) - .1))) - s)), (s + n) * .01);\n}\n\nvec2 proj(vec3 p, vec3 n) {\n\tn = abs(n);\n\tfloat m = max3(n);\n\treturn n.x == m ? p.zy : n.y == m ? p.xz : p.xy;\n}\n\nfloat vor(vec2 p) {\n\tvec2 o,\n\t     g = floor(p);\n\tp -= g;\n\tvec3 d = vec3(2);\n\tfor (int y = -1; y <= 1; y++) {\n\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\to = vec2(x, y);\n\t\t\to += h22(g + o) * vec2(.5, .7) - p;\n\t\t\td.z = dot(o, o);\n\t\t\td.y = max(d.x, min(d.y, d.z));\n\t\t\td.x = min(d.x, d.z);\n\t\t}\n\t}\n\n\treturn d.y - d.x;\n}\n\nvec2 map(vec3 p, bool addGlass) {\n\tfloat f, e, l,\n\t      d = 1e7;\n\tvec2 h;\n\th.x = 1e7;\n\tvec3 pp,\n\t     cp = p,\n\t     op = p;\n\tif (addGlass) {\n        minH(max(abs(p.z - 3.2), abs(p.x) - 4.), 11);\n\t} else {\n\t\tp.x = fract(p.x * 1.74) / 1.74 - .25;\n\t\tp.y = abs(p.y + .7) - 1.5;\n\t\tp.z -= 3.4;\n\t\tminH(max(abs(length(p.xy) - .06) - .0015, abs(p.z) - .03), 9);\n\t}\n\n\tp = cp;\n\tp.y += 3.5;\n\tp = p.zyx;\n\tp.xz *= rot(.2);\n\tminH(max(max(cap(p, 1., .45), abs(p.y) - .05), -p.x), 8);\n\tp.x -= .15;\n\tp.z = abs(p.z) - .5;\n\tp.xy *= rot(-.1);\n\td = max(length(p.xz) - .04, p.y - .5);\n\tp.xy *= rot(.6);\n\tp.x -= .3;\n\tminH(smin(d, max(length(p.xz) - .04, p.y - .8), .04), 3);\n\tp.z = cp.x - .03;\n\tp.xy = p.yx;\n\tminH(max(max(cap(p, .6, .45), abs(p.y) - .04), .3 - p.x), 8);\n\tp = cp;\n\tp -= vec3(9, -4.7, 5);\n\tmat2 r = rot(.36);\n\tfor (f = 0.; f < 5.; f++) {\n\t\tminH(max(box(p, vec3(2, .3, 10)), p.z - .5), 1);\n\t\td = smin(d, abs(-8.1 - p.z), 2.);\n\t\tp.xz *= r;\n\t\tp.y -= .6;\n\t}\n\n\tminH(d, 1);\n\tp = cp;\n\tp.y++;\n\td = min(box(p, vec3(90, 4, 3)), 8. - p.x);\n\tp.x = abs(p.x + 8.) - 8.;\n\tp.z -= 7.;\n\tcp = p;\n\td = -min(d, box(p, vec3(4, 4, 4.1)));\n\tminH(d, 1);\n\td = length(p - vec3(0, 4, 0)) - .2;\n\tg += .005 / (.01 + d * d);\n\tminH(d, 12);\n\tp += vec3(-2.48, 1.8, 2.4);\n\te = box(p, vec3(1.4, .02, .5));\n\tp.x = abs(p.x) - .8;\n\td = max(box(p, vec3(.05, 5, .05)), p.y);\n\tp = cp - vec3(0, .8, 3.95);\n\tminH(box(p, vec3(.5, .7, .01)), 10);\n\tminH(box(p, vec3(.6, .8, .01)), 8);\n\tp.y += 2.;\n\tl = length(p) - .8;\n\tf = min(max(max(min(min(l + .05, max(l, abs(p.x) - .2)), max(l, abs(p.y) - .1)), p.y - .1), -l - .1), max(box(p, vec3(.65, .8, .1)), -p.y - .2));\n\tminH(f, 4);\n\tp.x = abs(p.x) - .3;\n\tp.y -= .35;\n\td = min(d, length(p) - .1);\n\tp = cp + vec3(-2.48, 2.5, 1.2);\n\te = min(e, box(p, vec3(1.4, .02, .3)));\n\tp.x = abs(p.x) - .8;\n\td = min(d, max(box(p, vec3(.05, 5, .05)), p.y));\n\te -= .03;\n\tp = cp + vec3(3.7, -.5, -2);\n\te = min(e, box(p, vec3(.3, .05, 1)));\n\tp.y -= .48;\n\tp.z = abs(abs(p.z - .4) - .3) - .15;\n\tminH(box(p, vec3(.2, .4, .05)) - .03, 5);\n\tminH(d - .04, 3);\n\tminH(e, 8);\n\tp = cp;\n\tp.x += 2.8;\n\tp.y += 2.4;\n\tminH(box(p, vec3(.94, .08, 2.9)) - .1, 7);\n\tp.y += .23;\n\td = box(p, vec3(1.02, .08, 3.05));\n\tp.y += .7;\n\tp.z = abs(p.z) - 3.;\n\td = min(d, box(p, vec3(1.02, .78, .08)));\n\tp = cp;\n\tp.x = abs(abs(p.x) - 2.1) - .75;\n\tp.z += 3.8;\n\td = min(d, box(p, vec3(.1, 4, .1)));\n\tpp = p;\n\tp.y = fract(p.y) - .5;\n\tp.z += .12;\n\td = min(d, length(p) - .01);\n\tp = pp;\n\tminH(d - .04, 3);\n\td = box(cp - vec3(0, 3.5, -3.8), vec3(4, .5, .5));\n\tp.x = abs(cp.x) - 3.5;\n\tp.z = abs(p.z + 3.175) - 3.175;\n\td = min(d, box(p, vec3(.5, 4, .5)));\n\td -= brkT(op).a;\n\tminH(d, 2);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h, false).x;\n\t}\n\n\treturn NM(n);\n}\n\nfloat shadow(vec3 p, vec3 lp) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .1,\n\t      mxt = length(p - lp);\n\tvec3 ld = (lp - p) / mxt;\n\tfor (float i = Z0; i < 2e2; i++) {\n\t\td = map(t * ld + p, false).x;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.1, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p, true).x / h; }\n\nvec3 lights(vec3 p, vec3 rd, float d, vec2 h) {\n\tvec4 t;\n\tfloat spe = 1.,\n\t      gg = g,\n\t      f = h.y <= 6. ? fbm(p * 7.5) : 0.;\n\tvec3 c,\n\t     ld = NM(vec3(0, 2.8, 7) - p),\n\t     n = N(p, d);\n\tif (h.y == 1.) {\n\t\tvec2 uv = proj(p, n) * vec2(1, 2);\n\t\tfloat d = S(0., .15, vor(uv) * f);\n\t\tn.xy += vec2(dFdx(d), -dFdy(d)) * 1.5;\n\t\tn = NM(n);\n\t\td += f;\n\t\tc = mix(vec3(.15, .09, .06), vec3(.04, .03, .04) + S(.4, 1., S(.6, .5, d + f) * n31(p)) * vec3(.054, .06, .04), S01(d + .4));\n\t\tspe = .3;\n\t}\n\telse if (h.y == 2.) {\n\t\tt = brkT(p);\n\t\tc = t.rgb;\n\t\tn.xy += f;\n\t\tn = NM(n);\n\t\tspe = .1;\n\t}\n\telse if (h.y == 7.) c = vec3(.01, .013, .01);\n\telse if (h.y == 10.) {\n\t\tc = vec3(.02);\n\t\tspe = 15.;\n\t}\n\telse if (h.y == 3.) c = mix(vec3(.15, .05, .01), vec3(.16, .2, .24) * (.2 + .8 * f), S(0., .15, f));\n\telse if (h.y == 8.) c = mix(vec3(.04, .02, .02), vec3(.06, .04, .02), S01(n31(p * vec3(2.3, 1, 20))));\n\telse if (h.y == 5.) c = vec3(.12, .11, 0) - f * .2;\n\telse if (h.y == 4.) c = vec3(.4, .4, .38) - f * .4;\n\telse if (h.y == 9.) c = vec3(.9);\n\telse return LIGHT_RGB;\n\n\tfloat ao = sat(mix(ao(p, n, .2), ao(p, n, 2.), .7)),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.05 + .95 * shadow(p, vec3(0, 2.8, 7))) * (.3 + .7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .2 + pow(sat(dot(rd, reflect(ld, n))), 10.) * spe;\n\tg = gg;\n\treturn (l1 + l2 * ao) * c * LIGHT_RGB;\n}\n\nbool hitGlass;\nvec3 ghit;\nvec3 march(inout vec3 p, vec3 rd, float s) {\n\tfloat i,\n\t      d = .01;\n\tg = 0.;\n\tvec2 h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p, !hitGlass);\n\t\tif (abs(h.x) < .0015) {\n\t\t\tif (h.y == 11.) {\n\t\t\t\thitGlass = true;\n\t\t\t\tghit = p;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\td += h.x;\n\t\tp += h.x * rd;\n\t}\n\n\treturn g * LIGHT_RGB + lights(p, rd, d, h);\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n\thitGlass = false;\n\tvec3 p = ro,\n\t     col = march(p, rd, 120.) * exp(dot(p - ro, p - ro) * -.001);\n\tif (hitGlass) {\n\t\trd = reflect(rd, vec3(0, 0, -1));\n\t\tp = ghit;\n\t\tcol += .01 + .99 * sat(march(p, rd, 64.));\n\t}\n\n\treturn col;\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(iTime), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(ro, rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tfloat t = mod(iTime, 25.),\n\t      f = S(0., 18., t);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     q = fc.xy / R.xy;\n\tvec3 ro = vec3(-23. + 22.5 * f, 0, 0),\n\t     col = scene(ro, rayDir(ro, vec3(0, mix(-1. - sat(t), 0., S(16., 20., t)), -sin(S01(f) * 5.7) * 5.), uv));\n\tcol *= .2 + .4 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dt3WH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1992, 1992, 2010, 2010, 2129], [2131, 2131, 2149, 2149, 2217], [2219, 2219, 2238, 2238, 2483], [2485, 2485, 2504, 2504, 2636], [2638, 2638, 2677, 2677, 2759], [2761, 2761, 2781, 2781, 2815], [2817, 2817, 2837, 2837, 2871], [2873, 2873, 2892, 2892, 2959], [2961, 2961, 2988, 2988, 3059], [3061, 3061, 3098, 3098, 3150], [3152, 3152, 3196, 3196, 3311], [3313, 3313, 3332, 3332, 3679], [3681, 3681, 3708, 3708, 3793], [3795, 3795, 3814, 3814, 4103], [4105, 4105, 4138, 4138, 6737], [6739, 6739, 6764, 6764, 6983], [6985, 6985, 7016, 7016, 7287], [7289, 7289, 7324, 7324, 7361], [7363, 7363, 7410, 7410, 8737], [8765, 8765, 8809, 8809, 9093], [9095, 9095, 9125, 9125, 9354], [9431, 9431, 9491, 9491, 9556], [9558, 9558, 9603, 9603, 9964]]}
{"id": "fd33DN", "name": "Pentile LCD display", "author": "OskarSwierad", "description": "Shader simulating a pentile RGB sub-pixel grid. Antialiased through procedural filtering", "tags": ["grid", "checker", "display"], "likes": 4, "viewed": 463, "published": 3, "date": "1629801700", "time_retrieved": "2024-07-30T19:05:01.439807", "image_code": "// Author: Oskar Swierad, 2021\n// Copyright and related rights waived via CC0\n\nconst float TILING = 81.0; // Spatial frequency of the pattern\nconst vec3 SUBPIXEL_WEIGHTS = vec3(0.8, 0.5, 1.0);\nconst vec3 LUM_WEIGHTS_LINEAR = vec3(0.213, 0.515, 0.272); // Must sum to 1.0\nconst float COLOR_INTENSITY = 0.8; // Range [0,1]\nconst float INTENSITY = 0.5; // Range [0,1]\n\nfloat filteredSquares( in vec2 p, in vec2 dpdx, in vec2 dpdy, float N )\n{\n    // https://iquilezles.org/articles/filterableprocedurals\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return i.x*i.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy * vec2(1.0, aspectRatio);\n    \n    vec2 uvTiledR1 = (uv) * TILING + vec2(0.25);\n    vec2 uvTiledR2 = (uv) * TILING + vec2(0.75, 0.75);\n    \n    vec2 uvTiledG = uv * 2.0 * TILING;\n    \n    vec2 uvTiledB1 = (uv) * TILING + vec2(0.25, 0.75);\n    vec2 uvTiledB2 = (uv) * TILING + vec2(-0.25, 0.25);\n\n    float maskR = filteredSquares(uvTiledR1, dFdx(uvTiledR1), dFdy(uvTiledR1), 6.0) +\n                  filteredSquares(uvTiledR2, dFdx(uvTiledR2), dFdy(uvTiledR2), 6.0);\n    float maskG = filteredSquares(uvTiledG,  dFdx(uvTiledG),  dFdy(uvTiledG),  3.0);\n    float maskB = filteredSquares(uvTiledB1, dFdx(uvTiledB1), dFdy(uvTiledB1), 6.0) + \n                  filteredSquares(uvTiledB2, dFdx(uvTiledB2), dFdy(uvTiledB2), 6.0);\n    \n    vec3 subpixels = vec3(maskR, maskG, maskB);\n    subpixels *= SUBPIXEL_WEIGHTS;\n    \n    vec3 lcd = mix(\n        vec3(dot(subpixels, LUM_WEIGHTS_LINEAR)), // Grayscale\n        subpixels * SUBPIXEL_WEIGHTS,\n        COLOR_INTENSITY\n    );\n    lcd *= 8.0; // Compensate for lost luminance\n    \n    vec2 vidAspectRatio = vec2(1.0, 640.0/480.0);\n    vec2 videoUV = uv;\n    videoUV = round(videoUV * TILING * 2.0) / (TILING * 2.0);\n    videoUV *= vidAspectRatio;\n    //videoUV += vec2(0.5) / TILING;\n    vec3 video = texture(iChannel0, videoUV).rgb;\n    video = pow(video, vec3(2.2)); // De-gamma\n    \n    vec3 outColor = mix(\n        video * 0.2,\n        video * lcd,\n        INTENSITY\n    );\n    \n    outColor = pow(outColor, vec3(1.0 / 2.2)); // Gamma\n    fragColor = vec4(outColor,1.0);\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd33DN.jpg", "access": "api", "license": "cc0-1.0", "functions": [[366, 366, 439, 500, 740], [742, 742, 799, 799, 2412]]}
{"id": "7tjXWd", "name": "Day 60smth WIP", "author": "jeyko", "description": "poto", "tags": ["pathtracing", "monochrome", "mdtmjvm"], "likes": 9, "viewed": 338, "published": 3, "date": "1629793699", "time_retrieved": "2024-07-30T19:05:02.397248", "image_code": "// box intersection from IQ\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C= T(U);\n    C = pow(C,vec4(0.4545));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T(u) texture(iChannel0,(u)/R)\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}", "buffer_a_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat r11(float g){return fract(sin(g*12.5)*4.5);}\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n#define pmod(p,a) mod(p,a) - 0.5*a\nvec3 gp;\nvec3 get(vec3 p){\np.xz *=rot(0.25);\n    p.x += iTime + sin(iTime);\n    vec3 c = vec3(0);\n    p*=1.16;\n    gp = p;\n    float md = 0.2;\n    //p.x += iTime + sin(iTime);\n    vec3 id = floor(p/md);\n    //p.x = pmod(p.x,md);\n    c += mod(id.x,2.);\n    c = vec3(dot(c,c));\n    c = clamp(c*20.,0.06,1.);\n    return c;\n}\nvec3 n;\nvec2 intersect(vec3 ro, vec3 rd){\n    return boxIntersection(ro,rd,vec3(1),n);\n\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n    vec2 uvn = U.xy/R;\n\n    C = T(U);\n    C -= C;\n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv,0.2));\n    float t = iTime + sin(iTime + 3.);\n    rd.xz *= rot((t)*0.4);\n    rd.xy *= rot((t)*0.4);\n    vec3 p = ro;\n    vec3 att = vec3(1);\n    \n    for(float bnc = 0.; bnc < 1.; bnc++){\n        vec2 box = intersect(p,rd);\n        p = p + rd*box.y;\n        vec3 c = get(p);\n        //C.xyz += c*att;\n        att *= c;\n        float bncSubCnt = 40.;\n        float ratio = 0.2 + 0.9*floor(mod(gp.y*2.,2.));;\n        \n        p += n*0.001;\n        for(float bncSub = 0.; bncSub < bncSubCnt; bncSub++){\n            vec3 diff = hash33(vec3(uv*16.,bncSub + float(iFrame)*0.6));\n            diff = normalize(diff);\n            if(dot(diff,n)<0.)\n                diff = -diff;\n            \n            vec3 brd = reflect(rd,n);\n            brd = mix(-brd,diff,ratio);\n            brd = normalize(brd);\n            vec2 scene = intersect(p,brd);\n            vec3 pp = p + brd * scene.y;\n            vec3 c = get(pp);\n            C.xyz += c*att/bncSubCnt;\n            //att *= c;\n        \n            //vec2 \n        }\n    }\n    //C += box.y*0.1;\n    \n    \n    \n    \n    \n    if(iFrame == 0){\n        C = vec4(0,0,0,1);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 136]]}
{"id": "fscGWr", "name": "Something Logarithmic", "author": "byt3_m3chanic", "description": "Something Logarithmic - not it's final form - but another good experiment in raymarching log spherical warps. The texture gets crunchy near the center - but not sure how to fix.", "tags": ["raymarching", "animation", "truchet", "logarithmic"], "likes": 33, "viewed": 581, "published": 3, "date": "1629791349", "time_retrieved": "2024-07-30T19:05:03.346709", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Something Logarithmic\n    @byt3_m3chanic 08/24/21\n    \n    More ray marching a log spherial mapped animated\n    truchet tile system. More learning shader and \n    something to keep in my toolbox for later use.\n    \n    fun to play with tile size (sz) and density\n    \n    found post online on Log Spherical Warping \n    https://www.osar.fr/notes/logspherical/\n    \n*/\n\n#define R\t\t\tiResolution\n#define T\t\t\tiTime\n#define M\t\t\tiMouse\n\n#define PI2\t\t\t6.28318530718\n#define PI\t\t\t3.14159265358\n\n#define MAX_DIST \t85.\n#define MIN_DIST\t.0001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// constants \nconst float sz = 2.,hl = sz*.5;\nconst vec2 boxSize = vec2(sz*.475,.12);\n\nconst float density = 10.;\nconst float dshalf = density/2.;\n\n//globals and stuff\nvec3 hit, hitPoint;\nvec2 sid, cellId;\nfloat shorten = 1., lpscale, movement, trackspeed, time;\nmat2 turn;\n\nvec2 map(vec3 q){\n    vec2 res = vec2(1e5,0.);\n\n    vec3 p = q;\n    p.xz*=turn;\n\n    // log-spherical map\n    float r = length(p);\n    float mul = r/lpscale;\n    p = vec3(log(r), acos(p.y / r ), atan(p.z, p.x));\n    p *= lpscale;\n    p -= vec3(movement,dshalf,hl);\n    \n    vec2 id = floor((p.xz+hl)/sz);\n    p.xz = mod(p.xz+hl,sz)-hl;\n\n    float hs = hash21(id);\n    float dir = mod(id.y + id.x,2.) <.5 ? -1. : 1.;\n\n    if(hs>.5) p.x *= -1.;\n    // get closest point and make vector for 1/4 torus\n    vec2 d2 = vec2(length(p.xz - hl), length(p.xz + hl));  \n    vec2 pp = d2.x<d2.y ? vec2(p.xz - hl) : vec2(p.xz + hl);\n    float pth = abs(min(d2.x, d2.y) - hl);\n\n    float tr = length(vec2(pth, p.y+.15))-.25;\n    float bx = box(p,boxSize.xyx)-.025;\n\n    bx = max(bx,-tr);\n    if(bx<res.x) {\n        res = vec2(bx,3.);\n        sid = id;\n        hit = p;\n    }\n    \n    //balls\n    pp *= rot(trackspeed*dir);\n     \n    float amt = 4.;\n    float dbl = 8.;\n    \n    float a = atan(pp.y, pp.x);\n    // make id\n    float ai = floor(dir*a/PI*amt);\n    a = (floor(a/PI2*dbl) + .5)/dbl;\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= hl;\n\n    vec3 bq = vec3(qr.x, p.y+.15, qr.y);\n   \n    float sph = length(bq)-.1;\n    \n    if(sph<res.x) {\n        res = vec2(sph,4.);\n        sid = vec2(ai,dir);\n        hit = bq;\n    }\n\n    res.x *= mul/shorten;\n    return res;\n} \n// @iq https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t){\n    float e = t*MIN_DIST;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t \t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n//@iq https://iquilezles.org/articles/palettes\nconst vec3 c = vec3(0.959,0.970,0.989),\n           d = vec3(0.067,0.812,0.910);\nvec3 hue(float t){ \n    return .45 + .45*cos(PI2*t*(c+d) ); \n}\n\nvec4 FC= vec4(0.000,0.000,0.000,0.);\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d) {\n    \n    vec3 C = vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    \n    // marcher\n    for(int i=0;i<150;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<128? ray.x*.5: ray.x * .75;\n        m  = ray.y;\n    } \n    \n    cellId = sid;\n    hitPoint = hit;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST) {\n    \n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(2.0,5.0,3.85);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n        float diff = clamp(dot(n,l),.03,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n        fresnel = mix(.01, .9, fresnel);\n\n        float shdw = 1.;\n        float t=.0;\n        for( float i=.01; i < 32.;i++ ){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 24.);\n        \n        h = vec3(1);\n\n        if(m==3.) {\n            vec3 uv = hitPoint;\n            float px  = fwidth(uv.x*1.75);\n            \n            vec2 id = cellId;\n            vec2 grid = uv.xz;\n            float hs = hash21(id);\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n            vec2 d2 = vec2(length(grid-hl), length(grid+hl));\n            vec2 gx = d2.x<d2.y? vec2(grid-hl) : vec2(grid+hl);\n            float pth = abs(min(d2.x,d2.y)-hl);\n            vec2 vuv = vec2(pth, uv.z);\n            \n            float back = length(gx)-hl;\n            back=(chk>0.^^ hs>.5) ? smoothstep(-px,px,back) : smoothstep(px,-px,back);\n            \n            vec2 pid = floor(grid*4.);\n            vec2 puv = fract(grid*4.)-.5;\n            float fs = hash21(pid);\n            if(fs>.5)puv.x*=-1.;\n            vec2 d5 = vec2(length(puv-.5), length(puv+.5));\n            vec2 kx = d5.x<d5.y? vec2(puv-.5) : vec2(puv+.5);\n            \n            float ptrn = length(kx)-.5;\n            ptrn = smoothstep(px,-px,abs(abs(abs(abs(ptrn)-.1)-.1)-.1)-.05);\n            vec3 c2 = hue((10.+cellId.x*.05) );\n            vec3 c3 = hue((1. -cellId.x*.075) );\n            vec3 c4 = hue((cellId.x)*.05);\n            \n            h = mix(c3,mix(c3, c2,ptrn),back);\n            \n            float circle4;\n            float circle2 = length(gx)-hl;\n            float circle3 = smoothstep(px,-px,abs(circle2)-.13);\n            circle4 = smoothstep(px,-px,abs(abs(abs(circle2)-.2)-.065)-.012);\n            circle2 = smoothstep(px,-px,abs(abs(circle2)-.125)-.15);\n            \n            h=mix(h,vec3(.4),circle2);\n            h=mix(h,c4,circle3);\n            h=mix(h,vec3(0),circle4);\n \n            ref = mix(vec3(0),h-fresnel,circle2);\n        }\n\n        if(m==4.) {\n            h=mod(cellId.x+25.,2.)==0.?vec3(.03):vec3(.9);\n            ref = h-fresnel;\n        }\n        \n        C = diff*h+spec;\n        \n        ro = p+n*.001;\n        rd = reflect(rd,n);\n        \n    } else {\n        C = FC.rgb;\n    }\n    return C;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    time = iTime;\n  \n    lpscale = floor(density)/PI;\n    turn = rot(time*5.*PI/180.);\n\n    trackspeed = .75*time;\n    movement = .95*T*lpscale*.125;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,9.);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    float y = M.xy == vec2(0) ? 0. : (M.x/R.x * 1. - .5) * PI;\n    \n    mat2 rx = rot(.8+.1*sin(time*.1));\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fill=vec3(1.);\n    \n    float d =0.;\n    //@BigWIngs - reflection loop\n    for(float i=0.; i<2.; i++) {\n        vec3 pass = render(ro, rd, ref, d);\n        C += pass*fill;\n        fill*=ref;\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00015*d*d*d));\n    }\n\n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(MIN_DIST),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n// end", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscGWr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[638, 638, 659, 659, 714], [715, 715, 733, 733, 778], [780, 780, 807, 807, 894], [1171, 1171, 1188, 1188, 2523], [2525, 2575, 2604, 2604, 2825], [2953, 2953, 2971, 2971, 3015], [6342, 6342, 6383, 6397, 7294]]}
{"id": "Ndc3W4", "name": "Ray March Phong Template + color", "author": "CannaVizion", "description": "Just the same template as @alijaya's, but added the color picking system I learnt from @samlo https://www.shadertoy.com/view/wd2SR3", "tags": ["raymarching"], "likes": 1, "viewed": 254, "published": 3, "date": "1629768721", "time_retrieved": "2024-07-30T19:05:04.275226", "image_code": "//Fork from @alijaya Ray Marching Phong Template https://www.shadertoy.com/view/4t2fR1\n//Added the color picking system I learnt from @samlo https://www.shadertoy.com/view/wd2SR3\n\n#define EPSILON 0.01\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 2000.0\n#define MAX_MARCHING_STEP 256\n\n#define COLOR1 1.\n#define COLOR2 2.\n#define COLOR3 3.\n\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n// sphere function\nfloat sdSphere( vec3 p, float radius ) {\n    return length(p) - radius;\n}\n\n// box function\nfloat sdBox( vec3 p, float width, float height, float depth ) {\n    vec3 d = abs(p) - vec3(width, height, depth);\n    return max(d.x, max(d.y, d.z));\n}\n\n// cylinder function\nfloat sdCylinder( vec3 p, float radius, float height ) {\n    return max(length(p.xz) - radius, abs(p.y) - height);\n}\n\nfloat sdUnion( float sd1, float sd2 ) {\n    return min(sd1, sd2);\n}\n\nfloat sdIntersect( float sd1, float sd2 ) {\n    return max(sd1, sd2);\n}\n\nfloat sdSubstract( float sd1, float sd2 ) {\n    return max(sd1, -sd2);\n}\n\nfloat add (inout vec2 a, vec2 b){\n    a = mix(a,b,step(b.x,a.x));\n    return 0.;\n}\n\n// change this            \\\\\\now, instead of returning a float with the distance, returns vec2(distance,colorID)\nvec2 sdScene( vec3 p ) {\n    float sphere = sdSphere( p-vec3(-100), 220. );\n    float box = sdBox(p-vec3(-150), 200., 50., 200.);\n    float box2 = sdBox(p, 50., 200., 200.);\n    float cylinder = sdCylinder(p-vec3(100), 150., 250.);\n    vec2 S = vec2(sphere,COLOR1);\n    vec2 B = vec2(box,COLOR2);\n    vec2 C = vec2(max(-box2,cylinder),COLOR3);\n    vec2 result = C;\n    add(result,S);\n    add(result,B);\n    return result;\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n        sdScene(p+xe).x - sdScene(p-xe).x,\n        sdScene(p+ye).x - sdScene(p-ye).x,\n        sdScene(p+ze).x - sdScene(p-ze).x\n    ));\n}\n\n// ray marching algorithm\nvec2 getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    float matID;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d ).x;      //checks distance\n        matID = sdScene (r.o + depth * r.d).y;            //checks colorID\n        \n        if (dist < EPSILON) { // inside a scene\n            return vec2(depth,matID);\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return vec2(MAX_DISTANCE,matID);\n        }\n    }\n    \n    return vec2(MAX_DISTANCE,matID);\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    }\n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n    return color;\n}\n\nvec3 calcMaterial (float id) { //here you assign the colors you want\n    if (id == COLOR1)      return vec3(1.,0,0);\n    if (id == COLOR2)     return vec3(0,1.,0);\n    if (id == COLOR3)     return vec3(0,0,1.);\n    return vec3(1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 circleMovement = vec3(600. * cos(iTime * 2.), 600. * cos(iTime * 2.), 600. * sin(iTime * 2.)); // to get circle movement\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 200.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 0., 0.); // where to look at (this camera use two point system)\n    cam.pos = circleMovement; // the position of the camera\n    \n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n\n    \n    // render\n    float dist = getSDF(ray).x;\n    float colID = getSDF(ray).y;\n\n\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(0.);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1);\n    vec3 diffuseColor = calcMaterial(colID);//transforms the colorID to assigned colors\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(500. * sin(iTime), 500. * cos(iTime), 400.);\n    light1.color = vec3(1., .3, .1);\n    \n    Light light2;\n    light2.pos = vec3(1000. * cos(iTime), 400., 1000. * sin(iTime));\n    light2.color = vec3(.1, .3, 1.);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3W4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[666, 712, 747, 747, 1629], [1631, 1655, 1698, 1698, 1996], [1998, 2046, 2090, 2090, 2273], [2275, 2364, 2435, 2435, 2499], [2501, 2520, 2560, 2560, 2593], [2595, 2611, 2674, 2674, 2762], [2764, 2785, 2841, 2841, 2901], [2903, 2903, 2942, 2942, 2970], [2972, 2972, 3015, 3015, 3043], [3045, 3045, 3088, 3088, 3117], [3119, 3119, 3152, 3152, 3201], [3203, 3316, 3340, 3340, 3739], [3741, 3773, 3804, 3804, 3969], [3971, 3997, 4019, 4019, 4573], [4575, 4575, 4615, 4615, 4642], [4644, 4644, 4753, 4753, 5508], [5510, 5510, 5540, 5578, 5742], [5744, 5744, 5800, 5873, 7472]]}
{"id": "7st3DH", "name": "Persian carpet 4", "author": "jarble", "description": "A slightly simpler formula, with a much nicer range of colors.", "tags": ["fractal", "carpet", "rug"], "likes": 2, "viewed": 273, "published": 3, "date": "1629758307", "time_retrieved": "2024-07-30T19:05:05.160858", "image_code": "\n//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   //from David Hoskins' \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((iTime+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    \n    \n    float offset = .25;\n    \n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float scale1 = 1.0;\n        float t3 = float(c)+t2;\n        vec3 random2 = hash31(1.+t3);\n        float scale2 = 1.+random2.x;\n        //vec3 col_prev = 0.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = -1.1;\n            \n            uv = triangle_wave(uv.yx+1.5,scale)+triangle_wave(uv,scale);\n            uv.x *= factor;\n\n            uv = triangle_wave((uv+offset),scale);\n            uv.x /= factor;\n            \n            uv = triangle_wave(uv+offset,scale);\n            uv.x *= factor;\n            \n            uv = triangle_wave((uv+offset),scale);\n            uv.x /= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            //uv = -uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/8.;\n            if(i>0) col = (col.yzx*random2.x + col_prev*random2.y)/(random2.x+random2.y);\n            col[c] = fract((uv.x)-(uv.y));\n\n            \n\n        }\n\n            //random3 = (hash31(2.+t3)-vec3(.5))/4.;\n            //random4 = (hash31(3.+t3)-vec3(.5))/4.;\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7st3DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 456, 478, 523, 656], [658, 658, 697, 697, 742], [744, 744, 801, 801, 2466]]}
{"id": "7dc3D8", "name": "Return from space", "author": "Tater", "description": "Inspired by @byt3_m3chanic's experiments with log polar mapping. I still have some more ideas I might try with it. ", "tags": ["3d", "raymarching", "space", "logpolar"], "likes": 16, "viewed": 381, "published": 3, "date": "1629750658", "time_retrieved": "2024-07-30T19:05:06.079403", "image_code": "#define STEPS 200.0\n#define MDIST 150.0\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box(vec3 p, vec3 b){\n    vec3 d = abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\n\nvec3 glow;\n\nvec2 pmodp(vec2 p, float x){\n    float a = atan(p.y,p.x);\n    a = mod(a-x/2.,x)-x/2.;\n    return vec2 (cos(a),sin(a))*length(p);\n}\nfloat vSeg(vec3 p, float h, float r){\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p)-r;\n}\n\nvec2 map(vec3 p){\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    vec3 po = p;\n    float t= mod(iTime,999.);\n    p.xz*=rot(t*0.2);\n\n    //Log-polar mapping from\n    //https://www.osar.fr/notes/logspherical/\n    vec2 p2 = p.xz;\n    float r = length(p2);\n    p2 = vec2(log(r),atan(p2.y,p2.x));  \n    float scl = 12.0/pi;\n    \n    t*=0.65;\n    p2.x+=t;\n    float yoff = 20.5;\n\n    //p.y+=t*scl*(2.0/3.0)*yoff;\n    \n    p2 *= scl;\n    \n    vec2 id = vec2(floor((p2.x)/1.5)+0.5,floor(p2.y/1.5)+0.5);\n    \n    p2 = pmod(p2,1.5);\n\n    p.y-=sin(id.y+t)*0.75;\n    p.y-=sin(id.x+t*2.5)*0.75;\n    \n    float dSpd = 10.0;\n    float uSpd = 15.0;\n    \n    //apply up/down warp-in motion\n    float ring =smoothstep(6.0,9.0,id.x-t*scl*(2.0/3.0))*yoff*dSpd*floor(mod(id.x,2.0));\n          ring -= smoothstep(6.0,9.0,id.x-t*scl*(2.0/3.0))*yoff*uSpd*floor(mod(id.x+1.0,2.0));\n    p.y -= ring;\n    \n    float mul = r/(scl);\n    \n    vec3 p3 = vec3(p2.x, p.y/mul,p2.y);\n     \n    //======BEGIN NON-DOMAIN WARPED SDF======  \n    \n    //Boxes\n    a.x = box(p3,vec3(0.6,0.6+0.15,0.6));\n    a.x = max(a.x,-box(p3,vec3(3.0,0.3,0.3)));\n    //a.x-=0.1;\n    \n    //anti overstep artifact hidden stuff\n        vec3 d = abs(p3)-1.0;\n        float outerBox = max(d.x,d.z);    \n        if(length(po.xz)>0.1) a.x = min(-outerBox,a.x);\n    \n    //=======END NON-DOMAIN WARPED SDF=======\n    a.x*=mul;\n    \n    //if(length(po.xz)<0.3) a.x = 0.1;\n    a.x = max(a.x,(length(p.xz)-20.0));\n    a.x = max(a.x,-(length(p.xz)-0.3)); //this ended up being useless\n    \n    p = po;\n    //GLOWY BEAM THING\n    b.x = length(p.xz)-0.8-sin(p.y-t*10.0)*0.2-sin(p.y*0.3-t*20.0)*0.2-abs(p.y)*0.2;\n    glow+=vec3(0.529,0.400,1.000)*0.1/(0.1+b.x*b.x);\n    \n    a =(a.x<b.x)?a:b;\n    \n    //ROTATING SEGMENTS\n    p.zx*=rot(t);\n    float alpha = atan(p.z,p.x);\n    p.y = abs(p.y)-9.0;\n    p.xz = pmodp(p.zx,pi/16.);\n    p-=vec3(17,sin(alpha*3.0-t)*2.0,0);\n    p.xy*=rot(alpha*1.5-t*3.0);\n    p.y+=2.;\n    \n    b.x = vSeg(p, 4.0,0.4);\n    b.y = 3.0;\n    a =(a.x<b.x)?a:b;\n\n    return a;\n}\n\n\nvec3 norm(vec3 p, float s){\n    vec2 e= vec2(s,0);\n    return normalize(vec3(\n    map(p+e.xyy).x,map(p+e.yxy).x,\n    map(p+e.yyx).x)-vec3(map(p-e.xyy).x,\n    map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = mod(iTime,999.);\n    vec3 ro = vec3(0,2.0+14.0*sin(t),-29.0);\n    \n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*0.7+uv.x*r+uv.y*cross(f,r));\n    \n    float dO, shad;\n    bool hit = false;\n    vec2 d; vec3 p;\n    \n    for(float i = 0.0; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+= d.x*0.85;\n        \n        if(abs(d.x)<0.005){\n            shad = i/STEPS;\n            hit = true;\n            break;\n        }\n        if(dO>MDIST){\n            dO = MDIST; break;\n        }\n    }\n    if(hit){\n        vec3 n = norm(p,0.02);\n        float edge = length(n-norm(p,0.12))*min(1.0,length(p)*0.2);\n        //edge =smoothstep(0.,0.15,edge);\n        \n        if(d.y == 1.0) col = vec3(0.388);\n        if(d.y == 2.0) col = vec3(0.502,0.000,1.000);\n        if(d.y == 3.0) col = vec3(0.388);\n        \n        //Shamelessly stealing blackle's lighting techniques \n        float ao = smoothstep(-.1,.1,map(p+n*.1).x)*\n                   smoothstep(-.3,.3,map(p+n*.3).x)*\n                   smoothstep(-.7,.7,map(p+n*.7).x);\n        vec3 r = reflect(rd, n);\n        float diff = length(sin(n*3.)*.7+.3)/sqrt(3.);\n        float spec = length(sin(r*3.)*.5+.5)/sqrt(3.);\n        float fres = 1.-abs(dot(rd,n))*.95;\n        col = col*pow(diff,3.0) + pow(spec, 12.)*fres*vec3(0.463,0.490,0.898);\n        col*=ao;\n        \n        if(d.y == 1.0)col+=smoothstep(0.,0.1,edge)*vec3(0.188,0.804,0.910);\n        if(d.y == 3.0)col+=smoothstep(0.,0.15,edge)*vec3(0.659,0.188,0.910)*10.0;\n    }\n\n    col = mix(col,mix(vec3(0.075),vec3(0.),length(uv)),dO/MDIST);\n    col+=glow*0.6;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dc3D8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 119, 119, 162], [164, 164, 190, 190, 249], [263, 263, 291, 291, 393], [394, 394, 431, 431, 484], [486, 486, 503, 503, 2517], [2520, 2520, 2547, 2547, 2712], [2715, 2715, 2772, 2772, 4564]]}
{"id": "sst3WH", "name": "Complex Math Utilities", "author": "oneshade", "description": "Complex math goodies.", "tags": ["math", "complex", "utilities"], "likes": 25, "viewed": 266, "published": 3, "date": "1629750378", "time_retrieved": "2024-07-30T19:05:06.958054", "image_code": "#define iTime (0.25 * iTime)\n\n// Complex function\nvec2 f(in Complex z) {\n    return casin(cmul(ctan(3.0 * z), cexp(iTime * i))) * 0.8;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Complex z = f((fragCoord - 0.5 * iResolution.xy) / iResolution.y);\n    fragColor = vec4(hue2rgb(carg(z) / tau + 0.5) * (1.0 - exp(-1.5 * cmod(z))), 1.0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(fwidth(z.x) * 1.5, 0.0, abs(mod(z.x + 0.125, 0.25) - 0.125)));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), smoothstep(fwidth(z.y) * 1.5, 0.0, abs(mod(z.y + 0.125, 0.25) - 0.125)));\n    //fragColor.rgb = hue2rgb(fragCoord.x / iResolution.x);\n}", "image_inputs": [], "common_code": "// Joke of the day:\n// Complex numbers are real.\n\n// Constants\n#define pi 3.14159265359     // Ratio between the circumference and diameter of a circle\n#define rho 1.57079632679    // /2\n#define tau 6.28318530718    // 2\n#define e 2.7182818284       // Euler's number\n#define i Complex(0.0, 1.0)  // Complex unit\n\n// Hue to RGB conversion (https://www.desmos.com/calculator/amac5m7utl)\nvec3 hue2rgb(in float hue) {\n    //return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n    //return smoothstep(0.0, 1.0, abs(2.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0)) - 1.0)) * 1.2;\n    //return clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0);\n    return smoothstep(0.0, 1.0, clamp(abs(6.0 * fract(vec3(hue, hue - 1.0 / 3.0, hue - 2.0 / 3.0)) - 3.0) - 1.0, 0.0, 1.0));\n}\n\n// -------------------------- Complex math --------------------------\n#define Complex vec2\n#define re x\n#define im y\n\n// Miscellaneous\nfloat carg(in Complex z) { return atan(z.im, z.re); }\nfloat cmod(in Complex z) { return length(z); }\nComplex cconj(in Complex z) { return Complex(z.re, -z.im); }\n\n// Elementary operations (+, -, *, /)\nComplex cadd(in Complex z, in Complex w) { return z + w; }\nComplex cadd(in Complex z, in float w) { return Complex(z.re + w, z.im); }\nComplex cadd(in float z, in Complex w) { return Complex(z + w.re, w.im); }\n\nComplex csub(in Complex z, in Complex w) { return z - w; }\nComplex csub(in Complex z, in float w) { return Complex(z.re - w, z.im); }\nComplex csub(in float z, in Complex w) { return Complex(z - w.re, -w.im); }\n\nComplex cmul(in Complex z, in Complex w) { return mat2(z, -z.im, z.re) * w; }\nComplex cmul(in Complex z, in float w) { return z * w; }\nComplex cmul(in float z, in Complex w) { return z * w; }\n\nComplex cinv(in Complex z) { return Complex(z.re, -z.im) / dot(z, z); }\nComplex cdiv(in Complex z, in Complex w) { return cmul(z, cinv(w)); }\nComplex cdiv(in Complex z, in float w) { return z / w; }\nComplex cdiv(in float z, in Complex w) { return z * cinv(w); }\n\n// Exponentials\nComplex cexp(in Complex z) { return exp(z.re) * Complex(cos(z.im), sin(z.im)); }\nComplex clog(in Complex z) { return Complex(0.5 * log(dot(z, z)), carg(z)); }\n\n// Powers\nComplex cpow(in Complex z, in Complex w) { return cexp(cmul(clog(z), w)); }\nComplex cpow(in float z, in Complex w) { return cexp(log(z) * w); }\nComplex cpow(in Complex z, in float w) {\n    float a = carg(z) * w;\n    return Complex(cos(a), sin(a)) * pow(dot(z, z), 0.5 * w);\n}\n\nComplex csqr(in Complex z) { return Complex(z.re * z.re - z.im * z.im, 2.0 * z.re * z.im); }\nComplex csqrt(in Complex z) {\n    Complex c = 0.5 * Complex(cmod(z), z.re);\n    return Complex(sqrt(c.re + c.im), sign(z.im) * sqrt(c.re - c.im));\n}\n\n// Hyperbolic functions\nComplex csinh(in Complex z) { return Complex(sinh(z.re) * cos(z.im), cosh(z.re) * sin(z.im)); }\nComplex ccosh(in Complex z) { return Complex(cosh(z.re) * cos(z.im), sinh(z.re) * sin(z.im)); }\nComplex ctanh(in Complex z) {\n    vec4 c = vec4(sinh(z.re), cosh(z.re), sin(z.im), cos(z.im));\n    return cdiv(c.xy * c.wz, c.yx * c.wz);\n}\n\n// Inverse hyperbolic functions\nComplex casinh(in Complex z) { return clog(z + cpow(cadd(cmul(z, z), 1.0), 0.5)); }\nComplex cacosh(in Complex z) { return clog(z + cpow(csub(cmul(z, z), 1.0), 0.5)); }\nComplex catanh(in Complex z) { return 0.5 * clog(cdiv(cadd(1.0, z), csub(1.0, z))); }\n\n// Trigonometric functions\nComplex csin(in Complex z) { return csinh(z.yx).yx; }\nComplex ccos(in Complex z) { return ccosh(Complex(z.im, -z.re)); }\nComplex ctan(in Complex z) {\n    vec4 c = vec4(sin(z.re), cos(z.re), sinh(z.im), cosh(z.im));\n    return cdiv(c.xy * c.wz, Complex(c.y, -c.x) * c.wz);\n}\n\n// Inverse trigonometric functions\nComplex casin(in Complex z) { return casinh(z.yx).yx; }\nComplex cacos(in Complex z) { return csub(rho, casin(z)); }\nComplex catan(in Complex z) { return catanh(z.yx).yx; }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sst3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 50, 72, 72, 136], [138, 138, 193, 193, 661]]}
{"id": "sdd3D8", "name": "Water Alphabet on window", "author": "sunhokim", "description": "Alphabet \"S\" made out of water is lying on the window.\n\nThis is my first serious shader. I brought a lot of code from iq's tutorials.", "tags": ["sdf", "refraction", "water"], "likes": 27, "viewed": 779, "published": 3, "date": "1629740650", "time_retrieved": "2024-07-30T19:05:07.911504", "image_code": "#define M_PI (3.1415926535897932384626433832795)\n#define ZERO (min(int(iTime), 0))\n\n#define LETTER_INDEX (1.3)\n#define LETTER_R0 ((LETTER_INDEX - 1.0) * (LETTER_INDEX - 1.0) / ((LETTER_INDEX + 1.0) * (LETTER_INDEX + 1.0)))\n#define LETTER_BEAM ((vec3(1) - vec3(0.66, 0.95, 1)) * 0.5)\n\n//******************\n//* sdf primitives *\n//******************\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdArc(in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb)\n{\n  p *= mat2(sca.x, sca.y, -sca.y, sca.x);\n  p.x = abs(p.x);\n  float k = (scb.y * p.x > scb.x * p.y) ? dot(p, scb) : length(p);\n  return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nfloat opExtrusion(in float z, in float d, in float h)\n{\n  vec2 w = vec2(d, abs(z) - h);\n  return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat sdC(vec3 p, vec3 size) {\n  float d = sdArc(p.xy, vec2(0.0, 1.0), vec2(sin(M_PI * 0.5), cos(M_PI * 0.5)), size.x, size.y);\n  return opExtrusion(p.z, d, size.z);\n}\n\nfloat sdVerticalCapsule(vec3 p, float h, float r)\n{\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n  return (-d1.x > d2.x) ? vec2(-d1.x, d1.y) : d2;\n}\n\nvec4 opElongate(in vec3 p, in vec3 h)\n{\n  vec3 q = abs(p) - h;\n  return vec4(max(q, 0.0), min(max(q.x, max(q.y, q.z)), 0.0));\n}\n\n//*********\n//* utils *\n//*********\nvec3 rotateX(in vec3 p, float t)\n{\n  float co = cos(t);\n  float si = sin(t);\n  p.yz = mat2(co, -si, si, co) * p.yz;\n  return p;\n}\n\nvec3 rotateY(in vec3 p, float t)\n{\n  float co = cos(t);\n  float si = sin(t);\n  p.xz = mat2(co, -si, si, co) * p.xz;\n  return p;\n}\n\nvec3 rotateZ(in vec3 p, float t)\n{\n  float co = cos(t);\n  float si = sin(t);\n  p.xy = mat2(co, -si, si, co) * p.xy;\n  return p;\n}\n\nfloat noise(in vec3 x)\n{\n  return texture(iChannel0, x / 32.0).x;\n}\n\nfloat noise2(in vec2 p) {\n  return noise(vec3(p, 0.5));\n}\n\nvec3 refractRay(in vec3 rd, in vec3 normal, float indexRatio) {\n  float cosTh = dot(rd, normal);\n  float cosPhi2 = 1.0 - (1.0 - cosTh * cosTh) / (indexRatio * indexRatio);\n  if (cosPhi2 < 0.0) {\n    // total internal reflection\n    return rd;\n  }\n  vec3 firstTerm = (rd - normal * cosTh) / indexRatio;\n  vec3 secondTerm = normal * sqrt(cosPhi2);\n  return normalize(firstTerm - secondTerm);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldOfView) / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(in vec3 eye, in vec3 look)\n{\n  vec3 w = normalize(eye - look);\n  vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n  vec3 v = cross(w, u);\n  return transpose(mat3(u, v, w));\n}\n\nfloat fresnel(float R0, float cosTh) {\n  float a = (1.0 - cosTh);\n  return R0 + (1.0 - R0) * (a * a * a * a * a);\n}\n\nvec2 iSphere(in vec3 ro, in vec3 rd, in float rad)\n{\n  float b = dot(ro, rd);\n  float c = dot(ro, ro) - rad * rad;\n  float h = b * b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\n//************\n//* geometry *\n//************\nfloat mountainfbm(in vec2 x)\n{\n  float G = 0.30;\n  float a = 1.0;\n  float t = 0.0;\n  const mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n  for (int i = 0; i < 6; i++)\n  {\n    t += a * noise2(x);\n    a *= -G;\n    x = rotate2D * x;\n  }\n\n  return t;\n}\n\nvec2 mountain(vec3 p) {\n  if (p.z > -2.0) return vec2(1e10, 0.0);\n  vec2 q = 0.1 * p.xz;\n  float height = mountainfbm(0.5 * q + vec2(7.0, 3.0));\n  height *= 15.0;\n  height = mix(height, 1.5 * noise2(q * 1.2) - 7.1, 1.0 - smoothstep(50.0, 140.0, length(p)));\n  float h = (-height - p.y) * 0.4;\n  return vec2(h, 2.0);\n}\n\nfloat waveoctave(vec3 uv) {\n  uv += noise(uv);\n  vec3 wv = 1.0 - abs(sin(uv));\n  vec3 swv = abs(cos(uv));\n  wv = mix(wv, swv, wv);\n  return 1.0 - pow(wv.x * wv.y * wv.z, 0.65);\n}\n\nfloat wavefbm(in vec3 uv)\n{\n  float G = 0.3;\n  float f = 1.9;\n  float a = 1.0;\n  float t = 0.0;\n\n  float d = 0.0;\n  for (int i = 0; i < 6; i++)\n  {\n    float k = waveoctave((0.5 * iTime + uv) * f);\n    d += k * a;\n    a *= G;\n    f *= 2.0;\n  }\n\n  return d;\n}\n\nfloat table(vec3 p, float h) {\n  vec4 q = opElongate(rotateX(p, M_PI * 0.5), vec3(7.0, 0.0, 0.0));\n  return max(sdTriPrism(q.xyz, vec2(5.0, h)), sdBox(p - vec3(0.0, 0.0, -5.0), vec3(9.0, h + 0.1, 5.0)));\n}\n\nfloat windowPart(vec3 p) {\n  float window = sdBox(p, vec3(3.75, 7.4, 0.5));\n  float windowCut = sdBox(p, vec3(3.75 - 0.7, 7.4 - 0.7, 0.6));\n  window = max(-windowCut, window);\n  vec3 q = rotateZ(p - vec3(3.75, 2.2, 0.0), M_PI * 0.5);\n  window = opSmoothUnion(window, sdVerticalCapsule(q, 7.2, 0.2), 0.3);\n  q = rotateZ(p - vec3(3.75, -2.2, 0.0), M_PI * 0.5);\n  window = opSmoothUnion(window, sdVerticalCapsule(q, 7.2, 0.2), 0.3);\n  return window;\n}\n\nvec2 window(vec3 p) {\n  vec2 res = vec2(1e10, 0.0);\n  {\n    res = opU(res, vec2(table(p - vec3(0.0, 0.2, 2.0), 0.2), 3.0));\n  }\n  {\n    vec3 q = p - vec3(-3.5, -7.2, -3.7);\n    res = opU(res, vec2(windowPart(q), 3.0));\n    q = p - vec3(3.5, -7.2, -3.7);\n    res = opU(res, vec2(windowPart(q), 3.0));\n  }\n  return res;\n}\n\nvec2 mapBackground(vec3 p) {\n  vec2 res = vec2(1e10, 0.0);\n  res = opU(res, mountain(p));\n  {\n    res = opU(res, window(p));\n  }\n  {\n    vec3 q = p - vec3(0.0, -17.0, 37.0);\n    vec2 room = vec2(sdBox(q, vec3(35.0, 25.0, 40.0)), 6.0);\n    vec2 roomcut1 = vec2(sdBox(q, vec3(35.0 - 3.0, 25.0 - 2.0, 40.0 - 5.0)), 6.0);\n    room = opS(roomcut1, room);\n\n    q = p * 0.995 - vec3(0.0, -7.0, 2.0);\n    vec2 windowcut2 = vec2(table(q, 7.4), 6.0);\n    room = opS(windowcut2, room);\n    res = opU(res, room);\n  }\n  return res;\n}\n\nvec2 letter(vec3 p) {\n  vec2 res = vec2(1e10, 0.0);\n  res = opU(res, vec2(sdC(rotateZ(p, -M_PI * 0.2), vec3(0.8, 0.4, 0.5)), 1.0));\n  res = opU(res, vec2(sdC(rotateZ(p, M_PI * 0.8) - vec3(0.0, 1.6, 0), vec3(0.8, 0.4, 0.5)), 1.0));\n  return res;\n}\n\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.0);\n  {\n    vec3 q = (rotateY(rotateZ(p, M_PI * 0.1), -M_PI * 0.01) - vec3(0, -3.6, 0.0)) / 2.5;\n    vec2 a = letter(q) / 2.5;\n\n    float h = 0.04 * wavefbm(q);\n    res = opU(res, vec2(a.x - h, a.y));\n  }\n\n  {\n    res = opU(res, mapBackground(p));\n  }\n\n  return res;\n}\n\n//***********************\n//* shading subroutines *\n//***********************\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k)\n{\n  float res = 1.0;\n  float t = 0.01;\n  for (int i = 0; i < 128; i++)\n  {\n    float h = mapBackground(ro + rd * t).x;\n    if (h < 0.001 || (ro + rd * t).y > 10.0)\n      return 0.0;\n    res = min(res, k * max(h, 0.0) / t);\n    t += h;\n  }\n  return res;\n}\n\nfloat ao(vec3 p, vec3 n) {\n  float occ = 0.0;\n  for (int i = ZERO; i < 32; i++)\n  {\n    float h = 0.01 + 2.0 * pow(float(i) / 31.0, 2.0);\n    occ += clamp(2.0 * mapBackground(p + h * n).x / h, -1.0, 1.0);\n  }\n  return clamp(occ / 32.0, 0.0, 1.0);\n}\n\nvec3 applyFog(in vec3 rgb,\n  in float distance,\n  in vec3 rayOri,\n  in vec3 rayDir)\n{\n  const float b = 0.005; // beam transmittance\n  float fogAmount = 1.0 - exp(-distance * b);\n  vec3 fogColor = vec3(0.5, 0.6, 0.6);\n  return mix(rgb, fogColor, fogAmount);\n}\n\nfloat cloudfbm(in vec2 x)\n{\n  float f = 1.0;\n  float G = 0.30;\n  float a = 1.0;\n  float t = 0.0;\n  for (int i = 0; i < 1; i++)\n  {\n    t += a * noise2(f * x);\n    a *= G;\n    f *= 2.0;\n  }\n\n  return t;\n}\n\nvec3 skyColor(vec3 rd) {\n  float k = (max(-rd.y, 0.0) * 1.2 + 0.2) * 0.8;\n  vec3 sky = vec3(pow(1.0 - k, 2.0), 1.0 - k, 0.6 + (1.0 - k) * 0.46) * 1.1;\n  float v = (-200.0) / rd.y;\n  rd.xz *= v;\n  rd.xz *= 0.005;\n  float f = (cloudfbm(rd.xz) - 0.6) * 20.0;\n  sky = mix(sky, vec3(.9, .9, .9), clamp(f * -rd.y, 0.0, 1.0));\n  return sky;\n}\n\nfloat woodfbm(in vec3 x)\n{\n  float G = 0.5;\n  float f = 0.6;\n  float a = 1.0;\n  float t = 0.0;\n  for (int i = 0; i < 4; i++)\n  {\n    t += a * noise(f * x);\n    f *= 2.0;\n    a *= G;\n  }\n  return t;\n}\n\n//********************\n//* ray intersection *\n//********************\nvec3 calcNormal(in vec3 p, float h)\n{\n  vec3 n = vec3(0.0);\n  for (int i = ZERO; i < 4; i++)\n  {\n    vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n    n += e * map(p + e * h).x;\n  }\n  return normalize(n);\n}\n\nvec2 raycast(in vec3 ro, in vec3 rd)\n{\n  vec2 res = vec2(-1.0);\n\n  vec2 tminmax = iSphere(ro, rd, 300.0);\n  if (tminmax.y > 0.0)\n  {\n    float t = max(tminmax.x, 0.01);\n    for (int i = 0; i < 400 && t < tminmax.y; i++)\n    {\n      vec2 h = map(ro + t * rd);\n      if (h.x < 0.001) { res = vec2(t, h.y); break; }\n      t += h.x;\n    }\n  }\n\n  return res;\n}\n\nvec2 raycastBackground(in vec3 ro, in vec3 rd)\n{\n  vec2 res = vec2(-1.0);\n\n  vec2 tminmax = iSphere(ro, rd, 300.0);\n  if (tminmax.y > 0.0)\n  {\n    float t = max(tminmax.x, 0.001);\n    for (int i = 0; i < 400 && t < tminmax.y; i++)\n    {\n      vec2 h = mapBackground(ro + t * rd);\n      if (h.x < 0.001) { res = vec2(t, h.y); break; }\n      t += h.x;\n    }\n  }\n\n  return res;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd) {\n  const int STEP_SIZE = 30;\n  const float TIME_MAX = 3.0;\n  const float EPSILON = 0.0;\n  const float STEP = TIME_MAX / float(STEP_SIZE);\n  float time = 0.0;\n  for (int i = 0; i < STEP_SIZE; ++i) {\n    vec2 h = map(ro + time * rd);\n    if (h.x > EPSILON) {\n      return time;\n    }\n    time += STEP;\n  }\n  return TIME_MAX;\n}\n\nstruct RayHit {\n  vec2 res;\n  vec3 rd;\n  vec3 color;\n  vec3 albedo;\n  vec3 normal;\n  vec3 pos;\n};\n\nRayHit rayIntersect(in vec3 ro, vec3 rd)\n{\n  vec2 res = raycast(ro, rd);\n  vec3 pos = ro + res.x * rd;\n  if (res.y < 0.1 || res.y > 1.1) {\n    vec3 normal = calcNormal(pos, 0.1);\n    return RayHit(res, rd, vec3(0.0), vec3(1.0), normal, pos);\n  }\n\n  // Letter intersected; process refraction\n  vec3 origNormal = calcNormal(pos, 0.1);\n  float F = fresnel(LETTER_R0, dot(origNormal, -rd));\n  rd = refract(rd, origNormal, 1.0 / LETTER_INDEX);\n  vec3 origRefracted = rd;\n\n  float marchTime = raymarch(pos - origNormal * 0.01, rd);\n  vec3 extPos = pos + marchTime * rd;\n  vec3 extNormal = calcNormal(extPos, 0.05);\n  rd = refractRay(rd, -extNormal, LETTER_INDEX);\n\n  vec3 trans = vec3(exp(-LETTER_BEAM.x * marchTime), exp(-LETTER_BEAM.y * marchTime), exp(-LETTER_BEAM.z * marchTime));\n  vec3 albedo = vec3(0.0);\n  albedo += (1.0 - F) * trans * vec3(1);\n  albedo *= max(dot(origNormal, -origRefracted), 0.0);\n\n  res = raycastBackground(extPos, rd);\n  vec3 backgroundPos = extPos + res.x * rd;\n  vec3 backgroundNormal = calcNormal(backgroundPos, 0.05);\n  return RayHit(res, rd, vec3(F), albedo, backgroundNormal, backgroundPos);\n}\n\n//**************\n//* entrypoint *\n//**************\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  //\n  // Camera\n  //\n  const float R = 38.0;\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  if (mouse == vec2(0.0)) {\n    mouse = vec2(0.5, 0.5);\n  }\n  vec2 spr = vec2(0.2 * (mouse.x - 0.5) * M_PI, 0.05 * (mouse.y - 0.5) * M_PI - 0.45 * M_PI);\n  vec3 eye = vec3(-R * sin(spr.x) * sin(spr.y), -R * cos(spr.y), -R * sin(spr.y) * cos(spr.x)) + vec3(0.0, -2.0, 0.0);\n  vec3 look = vec3(0.0, -5.0, 0);\n  mat3 view = viewMatrix(eye, look);\n  vec3 dir = view * rayDirection(45.0, iResolution.xy, fragCoord);\n\n  RayHit gb = rayIntersect(eye, dir);\n  vec3 col = vec3(0.0);\n\n  //\n  // Lighting\n  //\n  if (gb.res.x < 0.01) {\n    col = skyColor(gb.rd);\n  } else {\n    vec3 sunDir = normalize(vec3(-0.3, -1.3, -0.9));\n    vec3 mate;\n    float skyamb = 0.0;\n    float roomamb = 0.0;\n    float ksp = 100.0;\n\n    if (gb.res.y < 2.1) {\n      // mountain\n      float h = noise(gb.pos * 0.1 + noise(gb.pos * 0.3));\n      h = clamp(h, 0.1, 1.0);\n      h *= 0.7;\n      mate = mix(vec3(0.7 * h + 0.2, 0.7 * h + 0.1, 0.7 * h + 0.1), vec3(0.2 * h + 0.3, 0.2 * h + 0.15, 0.2 * h + 0.15), h);\n      skyamb = 1.0;\n      ksp = 100000.0;\n    } else if (gb.res.y < 3.1) {\n      // wood\n      float g = 0.8 + woodfbm(vec3(1.0, 10.0, 5.0) * gb.pos);\n      mate = mix(vec3(0.48, 0.3, 0.09), vec3(0.36, 0.22, 0.06), g);\n      roomamb = 1.0;\n      ksp = 10.0;\n    } else if (gb.res.y < 6.1) {\n      // wall\n      mate = vec3(0.69, 0.68, 0.57);\n      roomamb = 1.0;\n    }\n\n    vec3 linDir = normalize(vec3(sunDir.x, sunDir.y, sunDir.z + 0.3 * smoothstep(50.0, 100.0, length(gb.pos))));\n    float dif = clamp(dot(gb.normal, linDir), 0.0, 1.0);\n    float bak = clamp(dot(gb.normal, normalize(vec3(-linDir.x, linDir.y, -linDir.z))), 0.0, 1.0);\n    float sha = softshadow(gb.pos + gb.normal * 0.1, sunDir, 0.04, 30.0, 400.0);\n    float occ = ao(gb.pos + gb.normal * 0.01, gb.normal);\n    float indw = smoothstep(4.0, -2.0, gb.pos.z) * smoothstep(-5.0, 5.0, gb.pos.x);\n    float ind2mask = smoothstep(1.9, 1.91, gb.pos.z) * dot(gb.normal, vec3(0, 0, 1));\n    indw += 5.0 / exp(0.16 * length(gb.pos.xy-1.5*noise2(0.3*gb.pos.xy) - vec2(3.0, -5.0))) * smoothstep(-5.0, 5.0, gb.pos.x) * ind2mask;\n    indw += 5.0 / length(gb.pos.xy - vec2(0.0, -5.0)) * smoothstep(5.0, -5.0, gb.pos.x) * ind2mask;\n    dif = clamp(dif * sha, 0.0, 1.0);\n    col += 5.0 * dif * vec3(0.99, 0.54, 0.24);\n    col += 0.3 * skyamb * bak * vec3(0.11, 0.24, 0.35) * occ;\n    col += 0.3 * skyamb * vec3(0.11, 0.24, 0.35) * occ;\n    col += 0.3 * roomamb * vec3(0.44, 0.38, 0.13) * (0.5 * occ + 0.5);\n    col += 1.0 * roomamb * indw * vec3(0.51, 0.51, 0.44) * (0.5 + 0.5 * occ);\n    col *= mate;\n\n    vec3 hal = normalize(linDir - gb.rd);\n    float spe = pow(clamp(dot(gb.normal, hal), 0.0, 1.0), ksp) * sha * (0.5 + 0.5 * occ);\n    float d = length(gb.pos - eye);\n    col += vec3(0.8) * spe;\n    col = applyFog(col, smoothstep(80.0, 100.0, d) * d, eye, gb.rd);\n    col = gb.albedo * col + gb.color;\n  }\n\n  col = pow(col, vec3(1.0 / 2.2));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdd3D8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 347, 376, 376, 467], [469, 469, 542, 542, 727], [729, 729, 784, 784, 874], [876, 876, 906, 906, 1043], [1045, 1045, 1096, 1096, 1151], [1153, 1153, 1187, 1187, 1284], [1286, 1286, 1336, 1336, 1439], [1441, 1441, 1469, 1469, 1505], [1507, 1507, 1535, 1535, 1587], [1589, 1589, 1628, 1628, 1716], [1718, 1754, 1788, 1788, 1883], [1885, 1885, 1919, 1919, 2014], [2016, 2016, 2050, 2050, 2145], [2147, 2147, 2171, 2171, 2214], [2216, 2216, 2241, 2241, 2273], [2275, 2275, 2338, 2338, 2666], [2668, 2668, 2733, 2733, 2859], [2861, 2861, 2905, 2905, 3047], [3049, 3049, 3087, 3087, 3164], [3166, 3166, 3218, 3218, 3385], [3387, 3432, 3462, 3462, 3689], [3691, 3691, 3714, 3714, 4008], [4010, 4010, 4037, 4037, 4188], [4190, 4190, 4217, 4217, 4448], [4450, 4450, 4480, 4480, 4655], [4657, 4657, 4683, 4683, 5105], [5107, 5107, 5128, 5128, 5426], [5428, 5428, 5456, 5456, 5948], [5950, 5950, 5971, 5971, 6196], [6198, 6198, 6216, 6216, 6511], [6513, 6591, 6666, 6666, 6919], [6921, 6921, 6947, 6947, 7169], [7171, 7171, 7256, 7256, 7430], [7432, 7432, 7459, 7459, 7635], [7637, 7637, 7661, 7661, 7972], [7974, 7974, 8000, 8000, 8173], [8175, 8244, 8281, 8281, 8489], [8491, 8491, 8529, 8529, 8846], [8848, 8848, 8896, 8896, 9224], [9226, 9226, 9266, 9266, 9590], [9691, 9691, 9733, 9733, 10813], [10815, 10866, 10921, 10943, 13917]]}
{"id": "sst3W8", "name": "double AA with fwidth (color)", "author": "FabriceNeyret2", "description": "left:   bottom:   no AA\n         top:         only the strip borders are AA with fwidth. Problem when strip themselves get too thin.\nright:                too thin strips are AA too with another fwidth.\n\ntry variant patterns for 'a' ", "tags": ["moire", "aa", "fwidth"], "likes": 13, "viewed": 331, "published": 3, "date": "1629734403", "time_retrieved": "2024-07-30T19:05:08.684437", "image_code": "// different pattern + color, from https://shadertoy.com/view/fdd3D8\n\n  #define SQR(v)     ( (v)*(v) )\n  #define fwidth2(v)  sqrt( SQR(dFdx(v)) + SQR(dFdy(v)) ) // for more isotropic\n//#define fwidth2(v)  fwidth(v)\n\nvoid mainImage(out vec4 O, vec2 u ) {    \n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n          \n    float l = length(U), A = atan(U.y,U.x);\n    vec4  a = round(R.y/6.) * ( .00*sin(50.*U.x) + sin(4.*A -2.*l - iTime ) +cos(5.*l-A +iTime) - sin(l*l+ vec4(0,.1,.2,0)) ) , //  pattern\n          s = sin( a ),                                   // strip base\n          v = U.y > 0.\n                ? clamp(.5 + .5 * s/fwidth(s), 0.,1.)     // top: strip pattern with AA borders\n                : step( 0., s ),                          // bottom: no AA\n      aa = smoothstep(3.14/3., 6.28/3., fwidth2(a));      // detect param going too fast\n          \n     if (U.x > 0.) v = mix(  v, vec4(.5), aa );           // right: switch to grey to AA high strip freq\n    \n    O =  sqrt( v ) ;                                      // to sRGB\n\n    if ( int(u.x)==int(R.x)/2 ) O = vec4(1,0,0,1);        // vertical separator\n    if ( int(u.y)==int(R.y)/2 ) O = vec4(1,0,0,1);        // horizontal separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sst3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 253, 253, 1225]]}
{"id": "Nst3DH", "name": "looking glass test", "author": "z0rg", "description": "zefzef", "tags": ["zef"], "likes": 3, "viewed": 342, "published": 3, "date": "1629730325", "time_retrieved": "2024-07-30T19:05:09.504246", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define QUILT\n\n#if HW_PERFORMANCE==0\n#else\n//#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_DIST\t\t150.\nconst float PI = radians(180.);\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l =abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nfloat _cucube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    float cube = max(max(l.x, l.y), l.z);\n    l = abs(l)-0.01;\n    float x = max(l.y, l.z);\n    //l.xy *= r2d(iTime*.5+l.y);\nfloat y = max(l.x, l.z);\n    float z = max(l.x, l.y);\n    \n    float cucube = max(min(min(x, y), z), cube);\n    return cucube;\n}\n\nfloat map(vec3 p)\n{\np.xy += vec2(sin(iTime), cos(iTime*.5))*.5;\np*=2.+sin(iTime*.5)*.2;\n    vec3 pouter = p;\n    float acc = 1000.;\n    for (int i = 0; i < 5; ++i)\n    {\n        pouter.xy *= r2d(-iTime*.2);\n        pouter.yz *= r2d(iTime*.25);\n        acc = min(acc, _cucube(pouter, vec3(.4+float(i+1)*.07)));\n    }\n\n    p.xy *= r2d(iTime);\n    p.xz *= r2d(iTime*.5);\n\treturn acc;//min(acc,_cube(p, vec3(.5)));\n}\n\n#define sat(a) clamp(a, 0., 1.)\nvec3 accCol;\nfloat rayMarch(in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 200; i++)\n  {\n      vec3 p = ro + rd * t;\n    float h = map(p);\n    t += h*.5;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n        accCol += vec3(sin(p.z*3.+iTime)*.5+.5,.3+.3*sin(p.x),.3)*(1.-sat(h/.25))*.2;\n  }\n  return t;\n}\n\n#define EPS  0.01\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 applyFog(vec3 rgb,float distance, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*0.2 );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    accCol = vec3(0.);\n    float t = rayMarch(ro, rd, 0.);\n    vec3\tcol = vec3(0);\n    \n    vec2 fakeuv = rd.xy-vec2(-1.,1.)*.5+vec2(sin(iTime), cos(iTime))*.1;\n    col = vec3(.34, .2, .3)*pow(length(fakeuv), 5.)*texture(iChannel1, vec2(atan(fakeuv.y, fakeuv.x)*.1, length(fakeuv.xy*.01)-.02*iTime)).xxx;\n    if(t < MAX_DIST)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        vec3 lpos = vec3(5.);\n        vec3 ldir = lpos-p;\n        //col = texture(iChannel0, reflect(rd, n)).rgb;\n        col = vec3(.05)\n        +sat(dot(n, ldir))*vec3(.1,.2,.4)*(length(ldir)/4.)*.0\n        +pow(sat(dot(n, normalize(ldir+rd))),.2)*vec3(.1,.2,.3);\n        \n    }\n    col += accCol;\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro + vec3(0, 0, 9), rd), 1);\n}\n\n\n// Comment the original mainImage\n#ifndef QUILT\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5) + PI * 0.3;\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5) - PI / 2.;\n        vec3 ro = 2. * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        tot += Render(ro ,rd);\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n#else // QUILT\n\n    #define QAA\t2                                     \n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize = 2.0;\nconst float\taspectRatio = 0.75;\nconst vec3  \tVROffset = vec3(0, 0, 9);\nfloat quiltColumns\t=\t8.;\nfloat quiltRows\t\t=\t6.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\taccColor = vec4(0.);\n    for( int m = 0; m < QAA; m++ )\n    for( int n = 0; n < QAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m), float(n)) / float(QAA) - 0.5) / iResolution.xy                                                                                 ;\n\t\t\n\t\tvec2\tcoord = (fragCoord / iResolution.xy  + o) * vec2(quiltColumns,quiltRows);\n\t\tvec2\tfract = fract(coord);\n\t\tvec2\tfloor = floor(coord);\n\t\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\t\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\t\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\t\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\t\n\t\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\t\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\t\tvec3\tdir = normalize(screenPos - camPos);\n\t\tvec4\tcolor;\n\t\tmainVR(color, fragCoord, camPos - VROffset, dir);\n\t\taccColor += clamp(color, 0.0, 1.0);\n\t}\n\tfragColor = accColor / float(QAA*QAA);\n}\n#endif\n\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nst3DH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[258, 258, 277, 277, 335], [337, 337, 366, 366, 426], [428, 428, 459, 459, 736], [738, 738, 757, 757, 1150], [1197, 1197, 1252, 1252, 1525], [2082, 2082, 2137, 2137, 2233], [2236, 2236, 2273, 2273, 2985], [2987, 2987, 3029, 3029, 3193], [3195, 3195, 3273, 3273, 3332]]}
{"id": "fst3DH", "name": "Straight Lines", "author": "rexim", "description": "Supplementary Shader for a Tsoding Session: https://www.youtube.com/watch?v=cU5WcrU_YI4", "tags": ["education", "geometry", "tsoding"], "likes": 4, "viewed": 2068, "published": 3, "date": "1629729246", "time_retrieved": "2024-07-30T19:05:10.276182", "image_code": "#define MARKER_RADIUS 12.5\n#define THICCNESS 10.0\n\nfloat sin01(float x)\n{\n    return (sin(x) + 1.0) / 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0);\n\n    vec2 p1 = vec2(200.0, 200.0);\n    vec2 p2 = iMouse.xy;\n\n    if (length(fragCoord.xy - p1) < MARKER_RADIUS) {\n        fragColor += vec4(1.0, 0.0, 0.0, 1.0);\n    }\n\n    if (length(fragCoord.xy - p2) < MARKER_RADIUS) {\n        fragColor += vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \n    vec2 p3 = fragCoord.xy;\n    vec2 p12 = p2 - p1;\n    vec2 p13 = p3 - p1;\n\n    float d = dot(p12, p13) / length(p12); // = length(p13) * cos(angle)\n    vec2 p4 = p1 + normalize(p12) * d;\n    if (length(p4 - p3) < THICCNESS/* * sin01(iTime * 4.0 + length(p4 - p1)* 0.02)*/\n          && length(p4 - p1) <= length(p12)\n          && length(p4 - p2) <= length(p12)) {\n        fragColor += vec4(0.0, 1.0, 0.0, 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fst3DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 73, 73, 108], [110, 110, 165, 165, 891]]}
{"id": "Ndt3WH", "name": "GLSL bug #59", "author": "FabriceNeyret2", "description": "please uncomment line #7 ( for instance ) \nregression: mat4 constructor on not-vec4 aligned data won't compile if multiplied by float\nit doesn't compile on OpenGL ( linux ). What about windows ?", "tags": ["glsl", "bug"], "likes": 2, "viewed": 255, "published": 3, "date": "1629714762", "time_retrieved": "2024-07-30T19:05:11.052107", "image_code": "// acid test derived from: https://shadertoy.com/view/tlSyDz\n// Bug report: https://bugs.chromium.org/p/chromium/issues/detail?id=1242336\n\nvoid mainImage( out vec4 O, vec2 U ) {    \n    O = vec4(1);\n    \n // O =  .5 * mat4( 1,1, O,U, O, O ) * O ;  // doesn't compile\n // O =       mat4( 1,1, O,U, O, O ) * O ;  //         compiles\n // O =  .5*( mat4( 1,1, O,U, O, O ) * O ); //         compiles\n // O =   O * mat4( 1,1, O,U, O, O ) * .5 ; //         compiles !\n \n // O =  .5 * mat4( 1,1,U, O, O, O ) * O ;  //         compiles\n // O =  .5 * mat4(  O ,  O , O, O ) * O ;  //         compiles\n \n // O *= .5 * mat4( 1,1, O,U, O , O )  ;    // doesn't compile\n // O *=      mat4( 1,1, O,U, O , O )  ;    //         compiles\n // O *=      mat4( 1,1, O,U, O , O ) *.5 ; // doesn't compile\n \n // mat4 M =  .5 * mat4( 1,1, O,U, O , O ); //         compiles !\n // mat4 M =  mat4( 1,1, O,U, O , O ) * .5; //         compiles\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 177, 177, 916]]}
{"id": "fdd3D8", "name": "double AA with fwidth", "author": "FabriceNeyret2", "description": "left:   bottom:   no AA\n         top:         only the strip borders are AA with fwidth. Problem when strip themselves get too thin.\nright:                too thin strips are AA too with another fwidth.\n\ntry variant patterns for 'a' ", "tags": ["moire", "aa", "fwidth"], "likes": 14, "viewed": 432, "published": 3, "date": "1629707617", "time_retrieved": "2024-07-30T19:05:11.818059", "image_code": "  #define SQR(v)     ( (v)*(v) )\n  #define fwidth2(v)  sqrt( SQR(dFdx(v)) + SQR(dFdy(v)) ) // for more isotropic\n//#define fwidth2(v)  fwidth(v)\n\nvoid mainImage(out vec4 O, vec2 u ) {    \n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n          \n    float a = round(R.y/2.) * atan(U.y,U.x) + 3.*iTime,   // strip parameterization\n       // a = round(R.y/6.) * ( sin(4.*atan(U.y,U.x)) - length(U) ) , // variant pattern\n          s = sin( a ),                                   // strip base\n          v = U.y > 0.\n                ? clamp(.5 + .5 * s/fwidth(s), 0.,1.)     // top: strip pattern with AA borders\n                : step( 0., s ),                          // bottom: no AA\n      aa = smoothstep(3.14/3., 6.28/3., fwidth2(a));      // detect param going too fast\n          \n     if (U.x > 0.) v = mix(  v, .5, aa );                 // right: switch to grey to AA high strip freq\n    \n    O = vec4( sqrt( v ) );                                // to sRGB\n\n    if ( int(u.x)==int(R.x)/2 ) O = vec4(1,0,0,1);        // vertical separator\n    if ( int(u.y)==int(R.y)/2 ) O = vec4(1,0,0,1);        // horizontal separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdd3D8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 183, 183, 1144]]}
{"id": "sscGWH", "name": "meme path tracer", "author": "pema99", "description": "click to move cam\n\nyet more attempts to keep sharp and write stuff without looking at any resources\n\npls don't do raymarching for just spheres and planes xd", "tags": ["raymarching", "gi", "pathtracing"], "likes": 14, "viewed": 502, "published": 3, "date": "1629685807", "time_retrieved": "2024-07-30T19:05:12.584011", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n    fragColor.xyz /= fragColor.a;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define EPS 0.001\n#define BOUNCES 5\n#define SPP 16\n#define MAXDIST 10.0\n\n#define PI 3.14\n#define TWOPI 6.28\n\n// Cheat: taken from iq\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 emission = vec3(0.);\nint brdf = 0;\nfloat map(vec3 p)\n{\n    emission = vec3(0.);\n    brdf = 0;\n\n    // metaball\n    float d = length(p + vec3(0.4, 0.5, -0.5)) - 0.5;\n    d = smin(d, length(p + vec3(0.7, 0.2, -0.3)) - 0.4, 0.1);\n    if (d <= EPS*2.0)\n        brdf = 1;\n    \n    // ball\n    d = min(d, length(p + vec3(-0.5, 0.5, 0.3)) - 0.5);\n    \n    // walls\n    d = min(d, abs(p.y+1.0));\n    d = min(d, abs(p.y-1.0));\n    d = min(d, abs(p.x+1.5));\n    d = min(d, abs(p.x-1.5));\n    d = min(d, abs(p.z+3.5));\n    d = min(d, abs(p.z-2.0));\n    \n    //light\n    if (p.y > 0.99)\n        emission = vec3(1.0, 1.0, 0.8) * PI;\n\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    vec3 p = vec3(0.);\n    int i = 0;\n    for (; i < 50; i++)\n    {        \n        p = ro + t * rd;\n        float dist = map(p);\n        if (dist < EPS || dist > MAXDIST) break;\n        t += dist;\n    }\n    return vec2(t, i);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(EPS, 0.);\n    return normalize(vec3(\n        map(p + o.xyy) - map(p - o.xyy),\n        map(p + o.yxy) - map(p - o.yxy),\n        map(p + o.yyx) - map(p - o.yyx)\n    ));\n}\n\nvec3 sf(float i)\n{\n    float ux = i / float(128);\n    float uy = fract(i * 1.6180);\n    \n    float phi = acos((ux - 0.5) * 2.0);\n    float theta = TWOPI * uy;\n\n    return vec3(\n        sin(phi) * cos(theta),\n        sin(phi) * sin(theta),\n        cos(phi)\n    );\n}\n\nvec3 hemisphere(vec3 up, float seed)\n{\n    // worlds worst sampling function\n    vec3 dir = normalize(sf(seed));\n    dir.xz *= rot((seed+float(iFrame)*1.));\n    dir.yz *= rot((seed+float(iFrame)*2.));\n    dir.xy *= rot((seed+float(iFrame)*3.));\n    if (dot(dir, up) < 0.)\n        dir = -dir;\n    return dir;\n}\n\nvec3 trace(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.);\n    for (int i = 0; i < SPP; i++)\n    {\n        vec3 tro = ro, trd = rd;\n        vec3 throughput = vec3(1.);\n        vec3 final = vec3(0.);\n        \n        for (int j = 0; j < BOUNCES; j++)\n        {\n            vec2 res = march(tro, trd);\n            float dist = res.x;\n            float iters = res.y;\n\n            if (emission.x > 0. || emission.y > 0. || emission.z > 0.)\n            {\n                final = emission * throughput;\n                break;\n            }\n            else\n            {\n                vec3 hit = tro + dist * trd;\n                vec3 norm = normal(hit);\n                vec3 albedo = (norm * 0.5 + 0.5);\n                \n                tro = hit + norm * EPS;\n                if (brdf == 1)\n                    trd = reflect(rd, norm);\n                else\n                    trd = hemisphere(norm, mod(float(i+j+iFrame), 128.0));\n                \n                throughput *= albedo * dot(norm, trd);\n            }\n        }\n        \n        col += final;\n    }\n    return col / float(SPP);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = 2.0 * (ouv - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 jitter = vec2(float(iFrame%100)/10.0, mod(float(iFrame), 10.0)) / 5.0 / iResolution.xy;\n    \n    vec3 ro = vec3(0., 0., -3.);\n    vec3 rd = normalize(vec3(uv + jitter, 0.) - ro);\n    vec2 mouse = iMouse.xy == vec2(0.) ? vec2(0., -0.15) : 2.0 * ((iMouse.xy / iResolution.xy) - 0.5);\n    rd.xz *= rot(mouse.x);\n    rd.yz *= rot(mouse.y);\n    \n    vec4 col = vec4(trace(ro, rd), 1.0);\n    vec4 buf = iMouse.z > 0.0 ? vec4(0.) : texture(iChannel0, ouv);\n    \n    fragColor = col + buf;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 176]]}
{"id": "7dc3WH", "name": "spec-test", "author": "made", "description": "sprctrum test", "tags": ["spectrum"], "likes": 12, "viewed": 1344, "published": 3, "date": "1629679094", "time_retrieved": "2024-07-30T19:05:13.349963", "image_code": "vec3 B2_spline(vec3 x) { // returns 3 B-spline functions of degree 2\n    vec3 t = 3.0 * x;\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\n\treturn 0.5 * (\n    \tb0 * pow(t, vec3(2.0)) +\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + \n    \tb2 * pow(3.0-t,vec3(2.0))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float fVBars = 100.;\n    float fHSpacing = 1.00;\n    \n    float fHFreq = (uv.x * 3.14);\n\tfloat squarewave = sign(sin(fHFreq*fVBars)+1.0-fHSpacing);\n    \n    float x = floor(uv.x * fVBars)/fVBars;\n    float fSample = texture( iChannel0, vec2(abs(2.0 * x - 1.0), 0.25)).x;\n  \n\tfloat fft = squarewave * fSample* 0.5;\n    \n    float fHBars = 100.0;\n    float fVSpacing = 0.180;\n    float fVFreq = (uv.y * 3.14);\n\tfVFreq = sign(sin(fVFreq * fHBars)+1.0-fVSpacing);\n\n    vec2 centered = vec2(1.0) * uv - vec2(1.0);\n    float t = iTime / 100.0;\n    float polychrome = 1.0;\n    vec3 spline_args = fract(vec3(polychrome*uv.x-t) + vec3(0.0, -1.0/3.0, -2.0/3.0));\n    vec3 spline = B2_spline(spline_args);\n    \n    float f = abs(centered.y);\n    vec3 base_color  = vec3(1.0, 1.0, 1.0) - f*spline;\n    vec3 flame_color = pow(base_color, vec3(3.0));\n    \n    float tt = 0.3 - uv.y;\n    float df = sign(tt);\n    df = (df + 1.0)/0.5;\n    vec3 col = flame_color * vec3(1.0 - step(fft, abs(0.3-uv.y))) * vec3(fVFreq);\n    col -= col * df * 0.180;\n    \n\t// output final color\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dc3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 68, 375], [377, 377, 434, 466, 1601]]}
{"id": "sdcGWH", "name": "RayMarching Army", "author": "CannaVizion", "description": "Thanks to @iq @BigWIngs for their time sharing their knowledge and specially to @samlo because today I learnt how to colorize different objects! \nCheck https://www.shadertoy.com/view/wd2SR3 !\nAnd now with fog thanks to @FabriceNeyret2 !", "tags": ["raymarching", "sdf", "instances", "instancing", "army"], "likes": 12, "viewed": 448, "published": 3, "date": "1629676780", "time_retrieved": "2024-07-30T19:05:14.305409", "image_code": "//Second shader after watching some tutorials from The Art of Code (AKA BigWIngs) https://www.youtube.com/c/TheArtofCodeIsCool/videos\n//and getting some code from Iigo Quilez (https://iquilezles.org/articles/distfunctions)\n//Also many thanks to @samlo for his great explanation on how to colorize diferent objects https://www.shadertoy.com/view/wd2SR3\n//First steps... totally unoptimized and I still get some artifacts on the feet and the shadows\n//Starts dropping frames when in fullscreen @4K\n//This one is inspired on a video I saw about the Chinese army\n//Play around with Camera Rotation and/or Mouse Rotation\n//It's a pitty I can't add a song that matches the rhythm (something seems to be wrong when importing links from SoundCloud) \n//Feedback appreciated!\n//---Edit:\n//Added fog thanks to @FabriceNeyret2!!\n//---Edit:\n//And now with Phong illumination!\n//I replaced the previous code (see bellow) with a fork of Ray Marching Phong Template by @alijaya https://www.shadertoy.com/view/4t2fR1\n//where I added the color picking system I learnt from @samlo\n\n\n#define EPSILON 0.01\n#define MIN_DISTANCE 0.1 \n#define MAX_DISTANCE 100.0\n#define MAX_MARCHING_STEP 200\n\n#define CAM_ROTATION 1\n#define MOUSE_CAM_ROT 0\n#define HEAD_ROTATION 0                 \n#define SHADOWS 1                       //change it to 0 to disable shadows\n\n#define DARK_ID 0.\n#define CLOTH_ID 1.\n#define SKIN_ID 2.\n#define WHITE_ID 3.\n#define GROUND_ID 4.\n\n#define time iTime*4.\n#define PI 3.14159265\n\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction, always normalized\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookAt;\n    float focal;\n    vec2 sensorSize;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n    \nvec3 xe = vec3(EPSILON, 0., 0.);\nvec3 ye = vec3(0., EPSILON, 0.);\nvec3 ze = vec3(0., 0., EPSILON);\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nmat2 rotMat(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2 (c,-s,s,c);\n}\n\n\n// get corresponding ray from uv (0.0 -> 1.0)\nRay getRay( Camera cam, vec2 uv ) {\n    vec3 camDir = normalize(cam.lookAt - cam.pos); // the camera direction\n    vec3 center = cam.pos + cam.focal * camDir; // get the coordinate of the screen center\n    vec2 coord = (uv - 0.5) * cam.sensorSize; // convert from 0.0 -> 1.0 to -sensorSize / 2. -> sensorSize / 2.\n    \n    // axis relative to camera\n    vec3 zpos = -camDir; // k hat, outward the screen\n    vec3 xpos = cross(vec3(0., 1., 0.), zpos); // i hat, cross from ypos global and zpos local\n    vec3 ypos = cross(zpos, xpos); // j hat, cross from zpos local and xpos local\n    \n    // target in screen\n    vec3 target = center + coord.x * xpos + coord.y * ypos; // get pixel target coordinate from the screen\n    \n    Ray ray;\n    ray.o = cam.pos; // the origin of the ray is from the camera duh\n    ray.d = normalize(target - cam.pos); // the direction is from the camera to the target\n    \n    return ray;\n}\n\n// project point to ray\nvec3 projPoint2Ray( vec3 point, Ray ray ) {\n    vec3 rel = point - ray.o; // get relative vector from the point to the ray origin\n    float len = dot(rel, ray.d); // project that vector to vector direction of the ray, we get the length\n    return len * ray.d + ray.o; // multiply the length with unit vector direction and add to ray origin\n}\n\n// get the distance from point to ray (or line)\nfloat distPoint2Ray( vec3 point, Ray ray ) {\n    vec3 proj = projPoint2Ray(point, ray); // project it first to the ray\n    return distance(proj, point); // get the distance from the projected position to the original position\n}\n\n// just linear interpolation, map value v between fromA and fromB to between toA and toB\nfloat lerp( float v, float fromA, float fromB, float toA, float toB ) {\n    return (v - fromA) / (fromB - fromA) * (toB - toA) + toA;\n}\n\n\n// box function\nfloat sdBox( vec3 p, vec3 s ) {\n    vec3 d = abs(p) - s;\n    return max(d.x, max(d.y, d.z));\n}\n\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q ;\n}\n\nfloat add (inout vec2 a, vec2 b){\n    a = mix(a,b,step(b.x,a.x));\n    return 0.;\n}\n\nvec2 sdScene( vec3 p ) {\n    vec3 armSize = vec3 (.2,.4,.2);                           //Arms Size\n    vec3 handSize = vec3 (.2,.2,.13);          \n    vec3 legSize = vec3 (.22,.8,.2);\n    vec3 bodySize = vec3 (.6,1.,.3);\n    vec3 headSize = vec3(.3,.35,.3);\n    vec3 footSize = vec3(.2,.1,.43);\n    vec3 capSize = vec3(.36,.1,.45);\n\n    vec3 clothColor = vec3(0.027,0.27,0.05);\n    vec3 skinColor = vec3(0.764,0.6,0.552);\n\n    vec3 pG = p;\n    pG.z += mod(time,4.);                                                //Global Position\n    pG = opRep(pG,vec3(3,0,4));\n    vec3 pB = pG;                                               //Body Position\n    vec3 pH = pG -vec3(0,bodySize.y+headSize.y+0.05,0);         //Head Position\n#if HEAD_ROTATION \n    pH.xz *= rotMat(-sin(time)*.5);                               //Head Rotation\n#endif\n    vec3 pCap = pH - vec3(0,headSize.y+capSize.y-.05,-capSize.z/3.3);                                               \n    vec3 pShouldL = pG - vec3 (-(bodySize.x+armSize.x+0.05),bodySize.y,0);   //Shoulder Position\n    pShouldL.yz *= rotMat(sin(time));                          //Shoulder Rotation    \n    vec3 pArmL = pShouldL + vec3 (0,armSize.y,0);               //Arm Position\n    vec3 pForeL = pShouldL-vec3(0,-2.*armSize.y-0.05,0);                       //Forearm Position\n    pForeL.xz *= rotMat(radians(90.));                           //Forearm Rotation\n    pForeL.yz *= rotMat(clamp(-sin(time)*PI/2.,0.,PI/2.));\n    pForeL += vec3(0,armSize.y,0);                             //Forearm Anchor P reposition\n    vec3 pHandL = pForeL-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandL.xz *= rotMat(-1.*clamp(-sin(time)*PI,0.,PI/2.)+PI);    \n    vec3 pLegL = pB - vec3(-.4,-bodySize.y-.05,0);\n    pLegL.yz *= rotMat(-sin(time));\n    pLegL += vec3(0,legSize.y,0);\n    vec3 pFootL = pLegL - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n    vec3 pShouldR = pG - vec3(bodySize.x+armSize.x+0.05,bodySize.y,0);\n    pShouldR.yz *= rotMat(-sin(time));\n    vec3 pArmR = pShouldR + vec3 (0,armSize.y,0);;\n    vec3 pForeR = pShouldR-vec3(0,-2.*armSize.y-0.05,0);\n    pForeR.xz *= rotMat(radians(-90.));\n    pForeR.yz *= rotMat(clamp(sin(time)*PI/2.,0.,PI/2.));\n    pForeR += vec3(0,armSize.y,0);\n    vec3 pHandR = pForeR-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandR.xz *= rotMat(-1.*clamp(-sin(time)*PI,-PI/2.,0.)+PI);\n    vec3 pLegR = pB - vec3(.4,-bodySize.y-.05,0);\n    pLegR.yz *= rotMat(sin(time));\n    pLegR += vec3(0,legSize.y,0);\n    vec3 pFootR = pLegR - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n\n    vec2 body = vec2(sdBox(pB,bodySize),CLOTH_ID);\n    vec2 head = vec2(sdBox(pH,headSize),SKIN_ID);\n    vec2 cap = vec2(sdBox(pCap,capSize)*.5,CLOTH_ID);                      \n    \n    vec2 armL = vec2(sdBox (pArmL,armSize),CLOTH_ID); \n    vec2 foreL = vec2(sdBox(pForeL,armSize),CLOTH_ID);\n    vec2 handL = vec2(sdBox(pHandL,handSize),WHITE_ID);\n    vec2 legL = vec2(sdBox(pLegL,legSize),CLOTH_ID);\n    vec2 footL = vec2(sdBox(pFootL,footSize)*.5,DARK_ID);\n\n    vec2 armR = vec2(sdBox(pArmR,armSize),CLOTH_ID);\n    vec2 foreR = vec2(sdBox(pForeR,armSize),CLOTH_ID);\n    vec2 handR = vec2(sdBox(pHandR,handSize),WHITE_ID);\n    vec2 legR = vec2(sdBox(pLegR,legSize),CLOTH_ID);\n    vec2 footR = vec2(sdBox(pFootR,footSize)*.5,DARK_ID);\n\n    vec2 floor = vec2(sdPlane(p,vec3(0,1.,0),3.),GROUND_ID);\n    // vec2 floor = vec2(p.y+3,GROUND_ID);\n\n    vec2 result = body;\n    // result = mix(result,head,step(head.x,result.x));\n    // result = mix(result,cap,step(cap))\n    add (result,head);\n    add (result,cap);\n    add (result,armL);\n    add (result,foreL);\n    add (result,handL);\n    add (result,legL);\n    add (result,footL);\n    add (result,armR);\n    add (result,foreR);\n    add (result,handR);\n    add (result,legR);\n    add (result,footR);\n    add (result,floor);\n\n    return result;\n}\n\n// estimate normal with nudging\nvec3 estimateNormal( vec3 p ) {\n    return normalize(vec3(\n        sdScene(p+xe).x - sdScene(p-xe).x,\n        sdScene(p+ye).x - sdScene(p-ye).x,\n        sdScene(p+ze).x - sdScene(p-ze).x\n    ));\n}\n\n// ray marching algorithm\nvec2 getSDF( Ray r ) {\n    float depth = MIN_DISTANCE;\n    float matID;\n    for (int i=0; i<MAX_MARCHING_STEP; i++) {\n        float dist = sdScene( r.o + depth * r.d ).x;\n        matID = sdScene (r.o + depth * r.d).y;\n        \n        if (dist < EPSILON) { // inside a scene\n            return vec2(depth,matID);\n        }\n        \n        depth += dist; // circle marching!\n        \n        if (depth >= MAX_DISTANCE) {\n            return vec2(MAX_DISTANCE,matID);\n        }\n    }\n    \n    return vec2(MAX_DISTANCE,matID);\n}\n\nvec3 ambientLight( vec3 ambientColor ) {\n    return ambientColor;\n}\n\nvec3 phongLight( vec3 diffuseColor, vec3 specularColor, float shininess, Ray ray, float dist, Light light ) {\n    vec3 p = ray.o + dist * ray.d;\n    \n    vec3 N = estimateNormal(p); // surface normal\n    vec3 L = normalize(light.pos - p); // surface to light direction\n    vec3 V = -ray.d; // surface to camera direction\n    vec3 R = reflect(-L, N); // mirror of L by the axis N\n    \n    float dotLN = dot(L, N); // project light direction to surface normal\n    float dotRV = dot(R, V); // project light reflection direction to direction to camera\n    \n    vec3 color = vec3(0.);\n    if (dotLN > 0.) { // we can see the diffuse\n        color += diffuseColor * dotLN;\n    } \n    if (dotRV > 0.) { // we can see the specular\n        color += specularColor * pow(dotRV, shininess);\n    }\n    color *= light.color; // influence of color of the light\n#if SHADOWS\n    float dif = clamp(dotLN*.5+0.5,0.,1.);\n    vec3 n = estimateNormal(p);\n    Ray shadow;\n    shadow.o = p+n*EPSILON;\n    shadow.d = L; \n    float d = getSDF(shadow).x;\n    if (d<length(light.pos-p)) color *=.1;\n#endif\n\n    return color;\n}\n\n\nvec3 calcMaterial (float id) {\n    if (id == DARK_ID)      return vec3(.1, .1, .1);\n    if (id == CLOTH_ID)     return vec3(61., 74., 37.)/256.;\n    if (id == SKIN_ID)     return vec3(0.764,0.6,0.552);\n    if (id == WHITE_ID)     return vec3(1.);\n    if (id == GROUND_ID)     return vec3(.4);\n    return vec3(.2);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // convert from fragCoord (0.0 -> iResolution.xy) to uv (0.0 -> 1.0)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 m  = iMouse.xy/iResolution.xy;\n    vec3 circleMovement = vec3(600. * cos(iTime * 2.), 600. * cos(iTime * 2.), 600. * sin(iTime * 2.)); // to get circle movement\n    \n    // set camera\n    Camera cam;\n    cam.sensorSize = iResolution.xy; // set sensor size to the screenSize\n    cam.focal = 400.; // set the focal length (distance between sensor (screen) to the aperture\n    cam.lookAt = vec3(0., 1., 0.); // where to look at (this camera use two point system)\n    cam.pos = vec3(0,4,-4.2);//circleMovement; // the position of the camera#if CAM_ROTATION\n#if CAM_ROTATION\n    cam.pos = vec3 (sin(time*.1)*8.,7.+sin(time*.05)*4.,cos(time*.1)*8.);\n#endif\n#if MOUSE_CAM_ROT\n    cam.pos.yz *= rotMat(m.y*3.14);\n    cam.pos.xz *= rotMat(-m.x*6.2831);\n#endif\n    // get ray\n    Ray ray = getRay(cam, uv); // get corresponding ray, given the uv\n\n    \n    // render\n    float dist = getSDF(ray).x;\n    float colID = getSDF(ray).y;\n\n\n    if (dist > MAX_DISTANCE - EPSILON) { // don't hit anything, set to background\n        fragColor = vec4(vec3(.7,.8,1.),1);\n        return; // or discard?\n    }\n    \n    vec3 ambientColor = vec3(0.1);\n    vec3 diffuseColor = calcMaterial(colID);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    Light light1;\n    light1.pos = vec3(0,4,-5);\n    light1.color = vec3(1);\n    \n    // Light light2;\n    // light2.pos = vec3(4,4,4);\n    // light2.color = vec3(1);\n    \n    vec3 color = vec3(0.);\n    color += ambientLight(ambientColor);\n    color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light1);\n    \n    color = mix(vec3(.7,.8,1.), color, exp(-max(0.,dist-12.)/20.)  );\n    // color += phongLight(diffuseColor, specularColor, shininess, ray, dist, light2);\n    fragColor = vec4(color, 1.);\n}\n\n\n\n\n/* OLD_CODE\n\n#define HEAD_ROTATION 1\n#define CAM_ROTATION 1\n#define MOUSE_CAM_ROT 0\n\n#define time iTime*4.\n\n#define MAX_STEPS 120\n#define MAX_DIST 60.\n#define SURF_DIST 0.001\n\n\n#define DARK_ID 0.\n#define CLOTH1_ID 1.\n#define CLOTH2_ID 1.5\n#define SKIN_ID 2.\n#define WHITE_ID 3.\n#define GROUND_ID 4.\n\n\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nmat2 rotMat(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2 (c,-s,s,c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+max3(min(p, vec3(0)))-0.02;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat add (inout vec2 a, vec2 b){\n    a = mix(a,b,step(b.x,a.x));\n    return 0.;\n}\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q ;\n}\n\nvec2 GetDist (vec3 p){\n    \n    vec3 armSize = vec3 (.2,.4,.2);                           //Arms Size\n    vec3 handSize = vec3 (.2,.2,.13);          \n    vec3 legSize = vec3 (.22,.8,.2);\n    vec3 bodySize = vec3 (.6,1.,.3);\n    vec3 headSize = vec3(.3,.35,.3);\n    vec3 footSize = vec3(.2,.1,.43);\n    vec3 capSize = vec3(.36,.1,.45);\n\n    vec3 pG = p;\n    pG.z += mod(time,4.);                                                //Global Position\n    pG = opRep(pG,vec3(3,0,4));\n    vec3 pB = pG;                                               //Body Position\n    vec3 pH = pG -vec3(0,bodySize.y+headSize.y+0.05,0);         //Head Position\n#if HEAD_ROTATION \n    pH.xz *= rotMat(-sin(time)*.5);                               //Head Rotation\n#endif\n    vec3 pCap = pH - vec3(0,headSize.y+capSize.y-.05,-capSize.z/3.3);                                               \n    vec3 pShouldL = pG - vec3 (-(bodySize.x+armSize.x+0.05),bodySize.y,0);   //Shoulder Position\n    pShouldL.yz *= rotMat(sin(time));                          //Shoulder Rotation    \n    vec3 pArmL = pShouldL + vec3 (0,armSize.y,0);               //Arm Position\n    vec3 pForeL = pShouldL-vec3(0,-2.*armSize.y-0.05,0);                       //Forearm Position\n    pForeL.xz *= rotMat(radians(90.));                           //Forearm Rotation\n    pForeL.yz *= rotMat(clamp(-sin(time)*PI/2.,0.,PI/2.));\n    pForeL += vec3(0,armSize.y,0);                             //Forearm Anchor P reposition\n    vec3 pHandL = pForeL-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandL.xz *= rotMat(-1.*clamp(-sin(time)*PI,0.,PI/2.)+PI);    \n    vec3 pLegL = pB - vec3(-.4,-bodySize.y-.05,0);\n    pLegL.yz *= rotMat(-sin(time));\n    pLegL += vec3(0,legSize.y,0);\n    vec3 pFootL = pLegL - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n    vec3 pShouldR = pG - vec3(bodySize.x+armSize.x+0.05,bodySize.y,0);\n    pShouldR.yz *= rotMat(-sin(time));\n    vec3 pArmR = pShouldR + vec3 (0,armSize.y,0);;\n    vec3 pForeR = pShouldR-vec3(0,-2.*armSize.y-0.05,0);\n    pForeR.xz *= rotMat(radians(-90.));\n    pForeR.yz *= rotMat(clamp(sin(time)*PI/2.,0.,PI/2.));\n    pForeR += vec3(0,armSize.y,0);\n    vec3 pHandR = pForeR-vec3(0,-armSize.y-handSize.y-0.05,0);\n    pHandR.xz *= rotMat(-1.*clamp(-sin(time)*PI,-PI/2.,0.)+PI);\n    vec3 pLegR = pB - vec3(.4,-bodySize.y-.05,0);\n    pLegR.yz *= rotMat(sin(time));\n    pLegR += vec3(0,legSize.y,0);\n    vec3 pFootR = pLegR - vec3(0,-legSize.y-footSize.y-0.05,-footSize.z/2.);\n\n\n    vec2 body = vec2(sdBox(pB,bodySize),CLOTH1_ID);\n    vec2 head = vec2(sdBox(pH,headSize),SKIN_ID);\n    vec2 cap = vec2(sdBox(pCap,capSize),CLOTH2_ID);                      \n    \n    vec2 armL = vec2(sdBox (pArmL,armSize),CLOTH1_ID); \n    vec2 foreL = vec2(sdBox(pForeL,armSize),CLOTH1_ID);\n    vec2 handL = vec2(sdBox(pHandL,handSize)*.5,WHITE_ID);\n    vec2 legL = vec2(sdBox(pLegL,legSize),CLOTH2_ID);\n    vec2 footL = vec2(sdBox(pFootL,footSize),DARK_ID);\n\n    vec2 armR = vec2(sdBox(pArmR,armSize),CLOTH1_ID);\n    vec2 foreR = vec2(sdBox(pForeR,armSize),CLOTH1_ID);\n    vec2 handR = vec2(sdBox(pHandR,handSize)*.5,WHITE_ID);\n    vec2 legR = vec2(sdBox(pLegR,legSize),CLOTH2_ID);\n    vec2 footR = vec2(sdBox(pFootR,footSize),DARK_ID);\n\n    vec2 floor = vec2(sdPlane(p,vec3(0,1.,0),3.),GROUND_ID);\n    // vec2 floor = vec2(p.y+3,GROUND_ID);\n\n    vec2 result = body;\n    // result = mix(result,head,step(head.x,result.x));\n    // result = mix(result,cap,step(cap))\n    add (result,head);\n    add (result,cap);\n    add (result,armL);\n    add (result,foreL);\n    add (result,handL);\n    add (result,legL);\n    add (result,footL);\n    add (result,armR);\n    add (result,foreR);\n    add (result,handR);\n    add (result,legR);\n    add (result,footR);\n    add (result,floor);\n\n    return result;\n}\n\nvec3 calcMaterial (float id) {\n    if (id == DARK_ID)      return vec3(.1, .1, .1);\n    if (id == CLOTH1_ID)     return vec3(92., 112., 56.)/256.;\n    if (id == CLOTH2_ID)    return vec3(61., 74., 37.)/256.;\n    if (id == SKIN_ID)     return vec3(0.764,0.6,0.552);\n    if (id == WHITE_ID)     return vec3(1.);\n    if (id == GROUND_ID)     return vec3(.4);\n    return vec3(.2);\n}\n\nvec4 RayMarch (vec3 ro, vec3 rd){\n    float dO = 0.;\n    vec3 color;\n\n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p).x;\n        float matID = GetDist(p).y;\n        color = calcMaterial(matID);\n        dO += dS;\n        if (dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n\n    }    \n    \n    return vec4(color,dO);\n}\n\nvec3 GetNormal (vec3 p){\n    vec2 d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n\n    vec3 n = d.x - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3 (1.,10.,-10.);\n    //lightPos.xz += vec2(sin(time),cos(time));\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal (p);\n    float dif = clamp(dot(n,l)*.5+0.5,0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l).w;\n    if (d<length(lightPos-p)) dif *= .1;  //Shadows\n\n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1.,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m  = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);        //vec3(0.,.3,.6)*smoothstep(-0.1,1.,length(uv.y));\n\n    vec3 ro = vec3 (0,4,-4.2);\n#if CAM_ROTATION\n    ro = vec3 (sin(time*.1)*8.,7.+sin(time*.05)*4.,cos(time*.1)*8.);\n#endif\n#if MOUSE_CAM_ROT\n    ro.yz *= rotMat(m.y*3.14);\n    ro.xz *= rotMat(-m.x*6.2831);\n#endif\n    vec3 la = vec3(0,0,1.);\n    vec3 rd = R(uv, ro, la,.7);\n\n    float d = RayMarch(ro,rd).w;\n    vec3 c = RayMarch(ro,rd).xyz;\n    if (d<MAX_DIST){\n        vec3 p = ro + rd*d;\n        float difuse = GetLight(p);\n        difuse = pow(difuse,.4545);\n        col= vec3(difuse)*c;\n\n    }\n\n    col = mix(vec3(.8,.9,1.), col, exp(-max(0.,d-12.)/30.)  );  //Thanks to FabriceNeyret2 for the fog!\n    //col = mix(vec3(.8,.9,1.), col, exp(-d/90.)  );\n    fragColor = vec4 (col,1.);\n\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1806, 1806, 1827, 1827, 1865], [1867, 1867, 1888, 1888, 1962], [1965, 2011, 2046, 2046, 2928], [2930, 2954, 2997, 2997, 3295], [3297, 3345, 3389, 3389, 3572], [3574, 3663, 3734, 3734, 3798], [3801, 3817, 3848, 3848, 3911], [3914, 3914, 3956, 3982, 4007], [4009, 4009, 4045, 4045, 4097], [4099, 4099, 4132, 4132, 4181], [4183, 4183, 4207, 4207, 8022], [8024, 8056, 8087, 8087, 8252], [8254, 8280, 8302, 8302, 8805], [8807, 8807, 8847, 8847, 8874], [8876, 8876, 8985, 8985, 9974], [9977, 9977, 10007, 10007, 10292], [10297, 10297, 10353, 10426, 12251]]}
{"id": "7s3GWH", "name": "phong box", "author": "pema99", "description": "more attempts to keep sharp and write stuff without looking at any resources", "tags": ["phong"], "likes": 1, "viewed": 259, "published": 3, "date": "1629675417", "time_retrieved": "2024-07-30T19:05:15.164113", "image_code": "float smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat map(vec3 p)\n{\n    // ball\n    float d = length(p + vec3(0., 0.5, -0.5)) - 0.5;\n    \n    // walls\n    d = min(d, abs(p.y+1.0));\n    d = min(d, abs(p.y-1.0));\n    d = min(d, abs(p.x+1.5));\n    d = min(d, abs(p.x-1.5));\n    d = min(d, abs(p.z-2.0));\n\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    vec3 p = ro;\n    int i = 0;\n    for (; i < 50; i++)\n    {\n        float dist = map(p);\n        if (dist < 0.001) break;\n        t += dist;\n        p = ro + t * rd;\n    }\n    return vec2(t, i);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 o = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p + o.xyy) - map(p - o.xyy),\n        map(p + o.yxy) - map(p - o.yxy),\n        map(p + o.yyx) - map(p - o.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * ((fragCoord/iResolution.xy) - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < 2; i++)\n    {\n        for (int j = 0; j < 2; j++)\n        {\n            vec3 ro = vec3(0., 0., -3.);\n            vec3 rd = normalize(vec3(uv + vec2(float(i)*0.5+0.25, float(j)*0.5+0.25)*0.006, 0.) - ro);\n\n            vec2 res = march(ro, rd);\n            float dist = res.x;\n            float iters = res.y;\n\n            if (dist < 10.)\n            {\n                vec3 hit = ro + dist * rd;\n                vec3 light = vec3(sin(iTime), 0.5, cos(iTime)) - hit;\n                vec3 ld = normalize(light);\n                vec3 norm = normal(hit);\n                vec3 albedo = (norm * 0.5 + 0.5);\n                float diff = 0.;\n                \n                if (march(hit + norm * 0.001, ld).x >= length(light))\n                {\n                    diff = dot(norm, ld);\n                }\n                \n                col += max(diff, 0.2) * albedo;\n            }\n        }\n    }\n    \n    fragColor = vec4(col / 4.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3GWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 142], [144, 144, 163, 163, 215], [217, 217, 236, 248, 486], [488, 488, 518, 518, 735], [737, 737, 758, 758, 947], [949, 949, 1006, 1056, 2146]]}
{"id": "7d3GD8", "name": "torus interior in colors", "author": "FabriceNeyret2", "description": ".", "tags": ["torus", "short"], "likes": 11, "viewed": 373, "published": 3, "date": "1629663876", "time_retrieved": "2024-07-30T19:05:16.063707", "image_code": "\n#define r(a)    mat2( cos(a+vec4(0,11,33,0)) )                // rotation                  \n#define hue(v) ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )     // hue\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 30./R, q,                                       // marching point along ray \n          M = cos(iTime+vec3(0,11,0)) / vec3(1,2,.5);         // camera animation\n    float t=9.,d;\n     \n    for ( O += 1.1-O ; O.x > 0. && t > .01 ; O-=.01 ) //  O.x>0. just for security\n        q = p, \n        q.yz *= r( .5+M.y ),                                  // rotations\n        q.xz *= r(    M.x ),          // R0=20        R1=17\n        t = abs( length(vec2(d=length(q.xz)-20., q.y)) - 17.),// abs for inside + outside\n        p += .9*t*D;                                          // step forward = dist to obj\n\n    U  = 2.* atan( q.zy, vec2(q.x,d) );                       // strip texture  \n    O *= ( .5 + .5* sin(9.*(U.x+=U.y)) )  * hue(U.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3GD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 199, 199, 1099]]}
{"id": "Ndc3DH", "name": "Fork: [TWITCH] The mess I am ", "author": "Danguafer", "description": "Original author: Flopine\nOriginal shader: https://www.shadertoy.com/view/stfSW7\nOriginal description:\nA piece made live on Twitch, with some help from BigWings :) \nYou can watch all my streams here: https://www.twitch.tv/flopine", "tags": ["2d", "chromaticaberration", "pattern", "live", "twitch"], "likes": 6, "viewed": 498, "published": 3, "date": "1629653648", "time_retrieved": "2024-07-30T19:05:16.935377", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings and FabriceNeyret for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\nvec4 diffract (vec2 uv, float offset)\n{return texture(iChannel0,uv+offset);}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uu = fragCoord.xy/iResolution.xy;\n  fragColor = texture(iChannel0, uu);\n  \n  fragColor += vec4 (\n                      diffract(uu*0.98, 0.01).r,\n                      diffract(uu*0.98, 0.015).g,\n                      diffract(uu*0.98, 0.02).b,\n                      1.\n                    )*.7;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI acos(-1.)\n#define TAU 6.283185\n#define time iTime\n\n#define circle(u,s) (length(u)-s) \n#define square(u,s) ((max(abs(u.x),abs(u.y)))-s)\n#define hr vec2(1.,sqrt(3.))\n#define hexa(u,s) (max(abs(u.x), dot(abs(u),normalize(hr)))-s*mod(iTime, 4.0))\n\n#define ss(thre, value) smoothstep(thre,thre*1.2, value)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash11(x) fract(sin(x)*124.4)\n\nfloat frame(vec2 uv)\n{ \n  vec2 ga=mod(uv,hr)-hr*.5 , \n  gb=mod(uv-hr*.5,hr)-hr*.5, \n  guv=(dot(ga,ga)<dot(gb,gb))?ga:gb, \n  gid = uv-guv;\n  \n  float thicc = 0.04, size=.45;\n  float shapes = ss(thicc, abs(hexa(guv,size)));\n  for (int i=0; i<3; i++)\n  {\n    thicc -= 0.008; size -= 0.1; \n    shapes *= ss(thicc, abs(hexa(guv,size)));\n  }\n\n  float rep = TAU/2.;\n  float a = mod(atan(guv.x,guv.y),rep)-rep*.5;\n  guv = vec2(cos(a),sin(a))*length(guv);\n  float foreground = shapes+ss(0.02, abs(guv.x-.3));\n  guv *= rot(PI/6.*floor(length(gid+.1)));\n  foreground *= ss(0.03, abs(hexa(guv,.49)));\n  \n  return (1.-foreground);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n  vec2 uu = fragCoord.xy/iResolution.xy;\n\n  uv *= rot(time*.08);\n\n  for(float i=0.; i<1.; i+=1./3.)\n  {\n    float zplane = fract(time*.1+i);\n    float fadeinout = smoothstep(.5, .25, abs(zplane-.5));\n\n    float size = mix(4.,.01, zplane);\n    fragColor += vec4(frame(uv*size)*fadeinout);\n  }\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3DH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 395, 395, 432], [434, 434, 490, 490, 795]]}
{"id": "sd33Wr", "name": "sh light from env map", "author": "sunhokim", "description": "Calculate spherical harmonics parameters from environment cube map and light based on it. Only 9 vectors are used to encode the environment lighting.\n\nThanks to koulatko & alro for helps.", "tags": ["sphericalharmonics", "sh"], "likes": 5, "viewed": 484, "published": 3, "date": "1629652099", "time_retrieved": "2024-07-30T19:05:17.800065", "image_code": "#define M_PI\t(3.14159265359)\n\n// An Efficient Representation for Irradiance Environment Maps (Ravi et al)\n// https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 map(vec3 p) {\n    vec4 res = vec4(1e10, 0.0, 0.0, 0.0);\n    {\n    res = opU(res, vec4(sdSphere(p, 1.0),vec3(0.0)));\n    }\n    return res;\n}\n\nvec3 calcNormal( in vec3 p, float h)\n{\n    #define ZERO (min(int(iTime),0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.0, 0.0, 0.0, 0.0);\n    \n    vec2 tminmax = iSphere( ro, rd, 100.0 );\n\tif( tminmax.y>0.0 )\n    {\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<256 && t<tminmax.y; i++ )\n        {\n            vec4 h = map(ro+t*rd);\n            if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\nvec3 skyColor(vec3 rd) {\n    return mix(vec3(0.2), vec3(0.7), rd.y);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix( in vec3 eye, in vec3 look )\n{\n    vec3 w = normalize(eye-look);\n    vec3 u = normalize(cross(w, vec3(0,-1,0)));\n    vec3 v = cross(w, u);\n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float r = 10.0;\n   \n    vec2 mouse = iMouse.xy /iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        mouse = vec2(0.5,0.5);\n    }\n    vec2 spr = vec2(mouse.x * M_PI - M_PI/2.0, mouse.y*M_PI-M_PI)*0.8;\n    vec3 eye = vec3( -r*sin(spr.x)*sin(spr.y), -r*cos(spr.y),-r*sin(spr.y)*cos(spr.x)) + vec3(0.0, -2.0, 0.0);\n    vec3 look = vec3(0.0,0.0,0);\n    mat3 view = viewMatrix(eye, look);\n    vec3 dir = view * rayDirection(45.0, iResolution.xy, fragCoord);\n\n\n    vec4 res = raycast(eye, dir);\n    vec3 pos = eye + res.x*dir;\n    if (res.x < 0.0) {\n        fragColor = vec4(skyColor(dir),1.0);\n        return;\n    }\n    \n    //***********************************\n    //* SH light irradiance calculation *\n    //***********************************\n    vec3 coefs[9];\n    for (int i = 0; i < 9; i ++) {\n        coefs[i] = texelFetch(iChannel0, ivec2(i,0), 0).rgb;\n    }\n\n    float c1 = 0.429043;\n    float c2 = 0.511664;\n    float c3 = 0.743125;\n    float c4 = 0.886227;\n    float c5 = 0.247708;\n    vec3 L00 = coefs[0];\n    vec3 L1_1 = coefs[1];\n    vec3 L10 = coefs[2];\n    vec3 L11 = coefs[3];\n    vec3 L2_2 = coefs[4];\n    vec3 L2_1 = coefs[5];\n    vec3 L20 = coefs[6];\n    vec3 L21 = coefs[7];\n    vec3 L22 = coefs[8];\n    \n    mat4 RM = mat4(vec4(c1*L22.r,c1*L2_2.r,c1*L21.r,c2*L11.r),\n              vec4(c1*L2_2.r,-c1*L22.r,c1*L2_1.r,c2*L1_1.r),\n              vec4(c1*L21.r,c1*L2_1.r,c3*L20.r,c2*L10.r),\n              vec4(c2*L11.r,c2*L1_1.r,c2*L10.r,c4*L00.r-c5*L20.r));\n\n    mat4 GM = mat4(vec4(c1*L22.g,c1*L2_2.g,c1*L21.g,c2*L11.g),\n          vec4(c1*L2_2.g,-c1*L22.g,c1*L2_1.g,c2*L1_1.g),\n          vec4(c1*L21.g,c1*L2_1.g,c3*L20.g,c2*L10.g),\n          vec4(c2*L11.g,c2*L1_1.g,c2*L10.g,c4*L00.g-c5*L20.g));\n\n    mat4 BM = mat4(vec4(c1*L22.b,c1*L2_2.b,c1*L21.b,c2*L11.b),\n          vec4(c1*L2_2.b,-c1*L22.b,c1*L2_1.b,c2*L1_1.b),\n          vec4(c1*L21.b,c1*L2_1.b,c3*L20.b,c2*L10.b),\n          vec4(c2*L11.b,c2*L1_1.b,c2*L10.b,c4*L00.b-c5*L20.b));\n\n    vec4 normal = vec4(calcNormal(pos, 0.001),1.0);\n    vec3 diffuse = vec3(dot(normal, RM*normal), dot(normal, GM*normal), dot(normal, BM*normal));\n\n    fragColor = vec4(pow(diffuse/M_PI, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define M_PI\t(3.14159265359)\n\nfloat[9] shCoeffs(vec3 w)\n{\n    float[9] result;\n\n    result[0] = 0.282095f;\n \n    result[1] = 0.488603f * w.y;\n    result[2] = 0.488603f * w.z;\n    result[3] = 0.488603f * w.x;\n \n    result[4] = 1.092548f * w.x * w.y;\n    result[5] = 1.092548f * w.y * w.z;\n    result[6] = 0.315392f * (3.0f * w.z * w.z - 1.0f);\n    result[7] = 1.092548f * w.x * w.z;\n    result[8] = 0.546274f * (w.x * w.x - w.y * w.y);\n \n    return result;\n}\n\nvec3 sampleSky(vec3 dir){\n    return pow(texture(iChannel0, dir).xyz, vec3(2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //**********************************\n    //* SH light parameter calculation *\n    //**********************************\n    const float DEL_PHI = M_PI*0.05; \n    const float DEL_TH = M_PI*0.05;\n\n    vec3 res = vec3(0);\n    if(fragCoord.x < 10.0 && fragCoord.y < 1.0){\n        float sampleCount = 0.0;\n        for (float phi = 0.0; phi < 2.0*M_PI; phi += DEL_PHI) {\n            for (float theta = 0.0; theta < M_PI; theta += DEL_TH) {\n                vec3 w = vec3(cos(phi)*sin(theta),sin(phi)*sin(theta), cos(theta));\n                res += shCoeffs(w)[int(fragCoord.x)]*sampleSky(vec3(w.x,w.y,w.z)).rgb*sin(theta);\n                sampleCount += 1.0;\n            }\n        }\n        res /= sampleCount;\n        res *= 4.0*M_PI;\n        fragColor = vec4(res, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd33Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 221, 221, 381], [383, 383, 418, 418, 442], [444, 444, 474, 474, 507], [509, 509, 527, 527, 653], [655, 655, 693, 693, 948], [950, 950, 990, 990, 1363], [1365, 1365, 1389, 1389, 1435], [1437, 1437, 1502, 1502, 1634], [1636, 1636, 1682, 1682, 1820], [1822, 1822, 1879, 1879, 4056]]}
{"id": "fscGDH", "name": "shortest torus interior mesh", "author": "FabriceNeyret2", "description": ".", "tags": ["torus", "short", "golf", "tokamak"], "likes": 22, "viewed": 474, "published": 3, "date": "1629651091", "time_retrieved": "2024-07-30T19:05:18.684700", "image_code": "// more readable version at the end ;-)\n\n// ---  -9 by Fab     now starting with the obfuscating golfing\n\n#define r mat2( cos( A.xyzx + .5 + cos( iTime + A )  // rotation from camera animation\n                                \nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R;                                          // marching point along ray \n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        O.xyz = p, \n        O.yz *= r.y/4.)),                                     // rotations       \n        O.w = length(O.xz *= r.x/2.)) ) - 20., // R0=20   R1=17\n        t = 17. - length(O.wy),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(O.xy,O.zw)) ) / fwidth(U), 1.); // mesh\n    O = l* U.x * U.yyyy;    // O = l* vec4(U,0,0);   // colored\n // U  = 18.*atan(O.xy,O.zw); O = l*(.5+.5*sin(U.x+U.yyyy));      // strips\n} \n/**/\n\n\n\n\n\n\n/* // --- 346: -10 by Fab\n\n#define r(a) mat2( cos( .5 + cos( iTime + A ).a + A.xyzx ) )  // rotation from camera animation\n                                \nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R;                                          // marching point along ray \n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        O.xyz = p, \n        O.yz *= r( y/4. ),                                    // rotations\n        O.xz *= r( x/2. ),         \n        O.w = length(O.xz) - 20., // R0=20   R1=17\n        t = 17. - length(O.wy),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(O.xy,O.zw)) ) / fwidth(U), 1.); // mesh\n    O = l* U.x * U.yyyy;    // O = l* vec4(U,0,0);   // colored\n // U  = 18.*atan(O.xy,O.zw); O = l*(.5+.5*sin(U.x+U.yyyy));      // strips\n} \n/**/\n\n\n\n\n\n\n/* //---  // 356: -4 by Fab \n\n#define r(a)    mat2( cos( .5 + M.a + A.xyzx ) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R,                                          // marching point along ray \n          M = cos( iTime + A ) / vec3(2,4,1);                 // camera animation\n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        O.xyz = p, \n        O.yz *= r( y ),                                       // rotations\n        O.xz *= r( x ),         \n        O.w = length(O.xz) - 20., // R0=20   R1=17\n        t = 17. - length(O.wy),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(O.xy,O.zw)) ) / fwidth(U), 1.); // mesh\n    O = l* U.x * U.yyyy;    // O *= vec4(U,0,0);   // colored\n // U  = 18.*atan(q.zy,vec2(q.x,d)); O *= .5+.5*sin(U.x+U.y);     // strips\n} \n/**/\n\n\n\n\n\n\n/* //---  // 360: -2 by Fab\n\n#define r(a)    mat2( cos( .5 + M.a + A.xyzx ) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R, q,                                       // marching point along ray \n          M = cos( iTime + A ) / vec3(2,4,1);                 // camera animation\n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        q = p, \n        q.yz *= r( y ),                                       // rotations\n        q.xz *= r( x ),         \n        O = vec4( q, length(q.xz)-20. ), // R0=20   R1=17\n        t = 17. - length(O.wy),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(O.xy,O.zw)) ) / fwidth(U), 1.); // mesh\n    O += l* U.x * U.y - O;    // O *= vec4(U,0,0);   // colored\n // U  = 18.*atan(q.zy,vec2(q.x,d)); O *= .5+.5*sin(U.x+U.y);     // strips\n} \n/**/\n\n\n\n\n\n\n/* //---  // 362: -5 by Fab\n\n#define r(a)    mat2( cos( .5 + M.a + A.xyzx ) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R, q, d,                                    // marching point along ray \n          M = cos( iTime + A ) / vec3(2,4,1);                 // camera animation\n    float l = 1.1, t=l;\n     \n    for ( ; l > 0. && t > .01 ; l-=.01 ) //  O.x>0. just for security\n        q = p, \n        q.yz *= r( y ),                                       // rotations\n        q.xz *= r( x ),         \n        d = vec3( length(q.xz)-20., q ), // R0=20   R1=17\n        t = 17. - length(d.xz),                               // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(q.yz,d.xy)) ) / fwidth(U), 1.); // mesh\n    O += l* U.x * U.y - O;    // O *= vec4(U,0,0);   // colored\n // U  = 18.*atan(q.zy,vec2(q.x,d)); O *= .5+.5*sin(U.x+U.y);     // strips\n} \n/**/\n\n\n\n\n\n\n/* //---  367:  -4 by Xor\n\n#define r(a)    mat2( cos( a + A.xyzx ) )                     // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    vec3  A = vec3(0,11,33),\n          R = iResolution,     // 3.*R.y for normal field of view\n          D = normalize(vec3( U+U, -R.y ) - R ),              // ray direction\n          p = 20./R, q,                                       // marching point along ray \n          M = cos( iTime + A ) / vec3(2,4,1);                 // camera animation\n    float t=9.,d;\n     \n    for ( O += 1.1-O ; O.x > 0. && t > .01 ; O-=.01 ) //  O.x>0. just for security\n        q = p, \n        q.yz *= r( .5+M.y ),                                  // rotations\n        q.xz *= r(    M.x ),    // R0=20   R1=17\n        t = 17. - length(vec2(d=length(q.xz)-20., q.y)),      // abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj\n                                                              // texture                        \n    U = min( abs(U = sin(18.*atan(q.yz,vec2(d,q))) ) / fwidth(U), 1.); // mesh\n    O *= U.x * U.y;    // O *= vec4(U,0,0);   // colored\n // U  = 18.*atan(q.zy,vec2(q.x,d)); O *= .5+.5*sin(U.x+U.y);          // strips\n}  \n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "Nd3GWH", "name": "Persian carpet 3", "author": "jarble", "description": "Another random carpet generator, with an even greater variety of shapes and colors.", "tags": ["fractal", "carpet", "rug"], "likes": 5, "viewed": 279, "published": 3, "date": "1629641985", "time_retrieved": "2024-07-30T19:05:19.562353", "image_code": "\n//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0))*10.;\n    float t2 = floor((iTime+25.)/20.0+uv.x);\n    vec3 random2 = hash31(1.+t2);\n    //vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.*.0;\n    \n    \n    //float offset = 0.;\n    float scale2 = 1.+random2.x/2.;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float scale1 = 1.0;\n        float t3 = float(c)+t2;\n        vec3 random1 = 4.-hash31(t3)*8.;\n        random2 = hash31(1.+t3);\n        //random3 = (hash31(2.+t3)-vec3(.5))/4.;\n        vec3 random4 = (hash31(3.+t3)-vec3(.5))/4.;\n        //vec3 col_prev = 0.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            \n            uv = triangle_wave(uv.yx+2.-floor(random4.z*4.)+.5,scale)+triangle_wave(uv,scale);\n            uv.x *= -1.;\n\n            uv = triangle_wave((uv+random1.x)/(random4.y+1.),scale);\n            uv.x /= -1.;\n            \n            uv = triangle_wave(uv+random1.y,scale);\n            uv.x *= -1.;\n            \n            uv = triangle_wave((uv+random1.z)*(random4.x+1.),scale);\n            uv.x /= -1.;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*(col.x);\n            //offset *= scale2/(1.+random4.x);\n            \n            uv = -uv.yx;\n            //uv = uv.yx;\n            scale2 = 1.+(random2.z)/2.;\n            if(i>0) col = (col.yzx*random2.x + col_prev*random2.y)/(random2.x+random2.y);\n            col[c] = fract((uv.x)-(uv.y));\n\n            \n\n        }\n\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3GWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 456, 478, 524, 657], [659, 659, 698, 698, 743], [745, 745, 802, 802, 2561]]}
{"id": "fd3GD8", "name": "Falling off", "author": "Daizuukee", "description": "Casually falling off an infinite tower has a vibe for some godforbid reason... i am not here to question why. Im just here to create the vibe.\n\nImprovements could have been made if i made resolution a variable instead of fixing the y resolution to 64", "tags": ["sunset", "rain", "city"], "likes": 6, "viewed": 454, "published": 3, "date": "1629631763", "time_retrieved": "2024-07-30T19:05:20.422055", "image_code": "#define topSky vec3(0.2235, 0.0667, 0.2549)\n#define bottomSky vec3(0.1765, 0.1373, 0.3608)\n#define sunCol vec3(0.4471, 0.4039, 0.1412)\n#define sunPos vec2(iResolution.x/iResolution.y/2.,0.4)\n#define cityBack vec3(0.8353, 0.8275, 0.6471)\n#define cityFront vec3(0.3569, 0.2118, 0.4078)\n#define rainSpeed 1.5\n#define fallSpeed 3.5\n#define rainColor vec3(0.451, 0.6431, 0.702)\n#define cityRandomness 0.5\n#define colors 12.\n#define height 8.\n#define zoom 3.\n\nbool Glass(vec2 pos) {\n    return fract(pos.y) < 2./64. || \n    fract(pos.y + 0.1) < 1./64. || \n    fract(pos.y - 0.1) < 1./64. || \n    fract(pos.x*2. - 0.5) < 1./64.;\n}\n\nvec4 ground(vec2 pos) {\n    for(float i = 0.; i < 22.; i+=2.) {\n        vec4 c = texture(iChannel0,vec2(pos.x,i/64.));\n        if((1.-c.r)/64.*height > pos.y-sin(iTime/4.)/64.-i/64.)\n            return vec4(((cityBack - cityFront) * i/24. + cityFront) * (1.-(texture(iChannel0,vec2(i/64.+pos.x*100.)).r*cityRandomness)),1.);\n    }\n    return vec4(0);\n}\n\nvec4 background(vec2 pos) {\n    vec3 back = (topSky-bottomSky)*pos.y+bottomSky;\n    back += sunCol*(0.1/distance(pos,sunPos));\n    vec4 ground = ground(pos);\n    if(ground.a > 0.) {\n        back = (back - ground.rgb) * min(1.,0.25 + distance(pos,sunPos) / 3.) + ground.rgb;\n    }\n    return vec4(back,1);\n}\n\nvec4 rain(vec2 pos) {\n    for(float i = 1.; i < rainSpeed * 4.; i++) {\n        vec4 tex = texture(iChannel0, pos / vec2(4.,1.) + floor(vec2(0,iTime*rainSpeed)*64.)/64. - vec2(0,i)/64.);\n        if(tex.g < 0.01 && int(pos.x * iResolution.x)%2 != 0)\n            return vec4(rainColor * 1./i,1);\n    }\n    return vec4(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=floor(fragCoord/iResolution.yy*(64.*zoom))/(64.*zoom);\n    uv *= zoom;\n    uv -= vec2(iResolution.x/iResolution.y/2.,0.5) * (zoom-1.);\n    if(uv.y>0. && uv.y < 1.) {\n        fragColor = background(uv);\n\n        if(Glass(uv - vec2(floor(iResolution.x/iResolution.y/2.*64.)/64.,0.5) - floor(vec2(0,iTime*fallSpeed)*64.)/64.)) {\n            fragColor = vec4(0,0,0,1);\n        }\n        if(Glass(uv - vec2(floor(iResolution.x/iResolution.y/2.*64.+2.)/64.,0.5 - 1./64.) - floor(vec2(0,iTime*fallSpeed)*64.)/64.)) {\n            fragColor -= vec4(0.1,0.1,0.1,0);\n        }\n        fragColor += rain(floor(vec2(uv.x - uv.y*0.5, uv.y + uv.x*0.5)*64.)/64.);\n        fragColor.xyz = floor(fragColor.xyz*colors)/colors;\n    } else {\n        fragColor = vec4(0,0,0,1);\n    }\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3GD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 476, 476, 623], [625, 625, 648, 648, 977], [979, 979, 1006, 1006, 1285], [1287, 1287, 1308, 1308, 1607], [1609, 1609, 1662, 1662, 2438]]}
{"id": "Nsc3W8", "name": "Fiber", "author": "yasuo", "description": "fiber", "tags": ["fiber"], "likes": 12, "viewed": 292, "published": 3, "date": "1629629227", "time_retrieved": "2024-07-30T19:05:21.272780", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 100\n#define MAX_DIST 80.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nconst float Epsilon = 1e-10;\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * .6, cos(z * .5), z);\n    return p;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec4 GetDist(vec3 p) {\n    p.xy -= path(p.z).xy;\n\n    float d = -length(p.xy) + 1.;\n    \n    p.z+=iTime*3.0;\n    float nn = cnoise(p.xy*6.0+p.z);\n    vec3 col = vec3(.3,0.0,0.8);\n    col += nn*5.0;\n    \n    vec4 model = vec4(col,d);\n    \n    p.z = 0.0;\n    \n    vec3 prevP = p;\n    \n    p.xy*=Rot(radians(iTime*50.0));\n    \n    col = vec3(.7,0.0,0.5);\n    nn = cnoise(p.xy*10.0);\n    col += nn*3.0;\n    \n    float c = 0.06;\n    p.xy = mod(p.xy,c)-0.5*c;\n    d = sdOctahedron(p,0.02);\n    p = prevP;\n    float d2 = length(p)-0.5;\n    d = max(d2,d);\n\n    vec4 model2 = vec4(col,d);\n    \n    return combine(model,model2);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(3,5,0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.2;\n    \n    return vec2((lambert+dif),0.9) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*2.0;\n    vec3 col = vec3(0);\n    vec3 ro = path(t+1.5);\n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 0.6);\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n        vec3 n = GetNormal(p);\n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.rgb;\n        col *= dif.y;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsc3W8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[523, 612, 631, 631, 667], [668, 668, 689, 689, 726], [728, 728, 749, 749, 1826], [1828, 1828, 1848, 1848, 1912], [1914, 1914, 1950, 1950, 1992], [1994, 1994, 2032, 2032, 2085], [2087, 2087, 2109, 2109, 2707], [2709, 2709, 2742, 2742, 3049], [3051, 3051, 3075, 3075, 3276], [3278, 3278, 3301, 3301, 3591], [3593, 3593, 3635, 3635, 3830], [3832, 3832, 3889, 3889, 4320]]}
{"id": "ssc3Dn", "name": "Conformal Torus Texture Map II", "author": "mla", "description": "Conformal texture map, based on [url]https://www.shadertoy.com/view/tdGfzz[/url], but computing the R4 torus dimensions from the R3. See code for controls etc..", "tags": ["torus", "texture", "conformal", "quartic", "clifford"], "likes": 22, "viewed": 563, "published": 3, "date": "1629629183", "time_retrieved": "2024-07-30T19:05:22.386802", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Torus Conformal Texture Map II\n//\n// Controls:\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>, <page up/page down>: change texture proportions\n// 'a': multisampling AA\n// 'b': background\n// 'c': no circles\n// 'r': autorotation\n// 's': no reflections\n// 't': transparency\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat torusr2, torusR2; // R3 torus dimensions\nfloat N = 16.0, M = 17.0; // Subdivisions for xy and zw torus components\n\n// Clifford torus (in R4)\n// The Clifford torus is the intersection of the hypersurface x+y=S with\n// the unit hypersphere x+y+z+w = 1, so it also satisfies z+w=s where\n//  S+s = 1.\n//\n// Stereographic projection to R3 (from eg. (0,0,0,1)) gives a normal R3\n// torus with radii R and r, where S = 1/R and s = r/R, so R = 1/S and\n// r = s/S and R = r+1:\n//\n// The projection is equivalent to inversion in a sphere, radius = 2,\n// centre (0,0,0,-1) so points (S,0,0,-s) and (S,0,0,s) project to \n// (X,0,0) and (Y,0,0) on the x-axis, where X = S/(1-s),0,0) Y = S/(1+s),\n// and (X+Y)/2 = R and (X-Y)/2 = r where R & r are major and minor\n// axes of the R3 torus. Some algebra shows that S = 1/R, s = r/R and\n// we have the requirement that R = 1+r to ensure the projection\n// lies on the hypersphere, but the R3 torus can be scaled to R' = tR \n// and r' = tr, for some t to ensure this is true.\n//\n// If we want particular proportions between S and s, with eg.\n// s/S = M/N, so r = M/N, R = (r+1) are the required dimensions.\n\nbool getcolor(vec3 p3, out vec3 color) {\n  // Find scaling factor.\n  // (1+kr)/(kR) = 1  k = 1/(R-r)\n  float k = sqrt(1.0/(torusR2-torusr2)); // Scale factor\n  float R = sqrt(torusR2), r = sqrt(torusr2);\n  R *= k; r *= k; p3 *= k;       // Rescale\n  float S = 1.0/R, s = r/R;      // Clifford torus radii\n\n  // Invert to hyperspace, ie. do an inverse stereographic projection,\n  // equivalent to inverting in sphere, radius = 2, centre (0,0,0,-1).\n  // This is also the forward projection from R4 to R3.\n  vec4 p = vec4(p3,0);\n  p.w += 1.0; \n  p *= 2.0/dot(p,p);\n  p.w -= 1.0;\n\n  // Find coordinates on R4 torus\n  float phi = atan(p.x,p.y)/(2.0*PI);\n  float theta = atan(p.z,p.w)/(2.0*PI);\n  if (phi < 0.0) phi += 1.0;\n  if (theta < 0.0) theta += 1.0;\n  vec2 uv = vec2(phi,s*theta/S); // Scale by Clifford radii\n  uv *= N; // Subdivide\n  vec2 uv2 = floor(uv);\n  uv -= uv2;\n  uv -= 0.5; // Centre cell\n  float l = length(uv), d = 0.8*fwidth(l);\n  color = h2rgb(hash((int(uv2.x)<<10) + int(uv2.y)));\n  if (key(CHAR_C)) return true;\n  if (key(CHAR_T))return l < 0.45;\n  color = mix(color,vec3(0),smoothstep(-d,d, l-0.4 )); // AA by Fabrice\n  return true;\n}\n\n// R3 torus intersection and normal\nint torus(vec3 p, vec3 r, out vec4 res) {\n  // Parametrization of the torus by phi and theta angles.\n  // x = (R+r*cos(theta))*cos(phi)\n  // y = (R+r*cos(theta))*sin(phi)\n  // z = r*sin(theta)\n    \n  // U*t^2 + V*t + W = 2*r*R*cos(theta)\n  float A,B,C,D,E;\n  if (key(CHAR_X)) {\n    float U = 1.0; //dot(r,r);\n    float V = 2.0*dot(p,r);\n    float W = dot(p,p) - (torusR2+torusr2);\n    \n    // A*t^4 + B*t^3 + C*t^2 + D*t + E = 0\n    A = 1.0; //U*U;\n    B = 2.0*U*V;\n    C = V*V + 2.0*U*W + 4.0*torusR2*r.z*r.z;\n    D = 2.0*V*W + 8.0*torusR2*p.z*r.z;\n    E = W*W + 4.0*torusR2*(p.z*p.z-torusr2);\n  } else {\n    // If we have fixed p so p.r = 0, simplifications are possible\n    float W = dot(p,p) - (torusR2+torusr2);\n    A = 1.0;\n    B = 0.0;\n    C = 2.0*W + 4.0*torusR2*r.z*r.z;\n    D = 8.0*torusR2*p.z*r.z;\n    E = W*W + 4.0*torusR2*(p.z*p.z-torusr2);\n  }\n  int n = quartic(A,B,C,D,E,res);\n  return n;\n}\n\nvec3 torusnormal(vec3 p) {\n  float k = sqrt(torusR2/dot(p.xy,p.xy));\n  p.xy -= k*p.xy;\n  return normalize(p);\n}\n\nint AA = 1;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\nvec3 applylighting(vec3 basecolor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = basecolor*ambient;\n  c += basecolor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 color;\n  float t;\n};\n\nbool solve(vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = torus(p0,r,roots);\n  if (nroots == 0) return false;\n  // Sort the roots.\n  if (roots.x > roots.y) roots.xy = roots.yx; \n  if (nroots > 2) {\n    if (roots.y > roots.z) roots.yz = roots.zy; \n    if (roots.x > roots.y) roots.xy = roots.yx;\n  }\n  if (nroots > 3) {\n    if (roots.z > roots.w) roots.zw = roots.wz; \n    if (roots.y > roots.z) roots.yz = roots.zy; \n    if (roots.x > roots.y) roots.xy = roots.yx; \n  }\n  for (int i = 0; i < nroots; i++) {\n    float t = roots[i];\n    if (t < tmin) continue;\n    vec3 p = p0 + t*r;\n    vec3 n = torusnormal(p);\n    if (dot(n,r) > 0.0) n = -n;\n    vec3 basecolor;\n    if (getcolor(p, basecolor)) {\n      result.p = p; \n      result.n = n; \n      result.color = applylighting(basecolor,p,n,r);\n      return true;\n    }\n  }\n  return false;\n}\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 color = vec3(0);\n  float attenuation = 1.0;\n  for (int i = 0; i < 6; i++) {\n    // Solve from closest point to origin.\n    // This makes p.r = 0.\n    float tmin = 0.0;\n    if (!key(CHAR_X)) tmin = -dot(p,r);\n    p += tmin*r;\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    if (!solve(p,r,-tmin,res)) break;\n    if (key(CHAR_S)) return res.color;\n    color += attenuation*res.color;\n    attenuation *= 0.5;\n    p = res.p;\n    r = reflect(r,res.n);\n    p += 0.001*r;\n  }\n  if (!key(CHAR_B)) color += attenuation*pow(abs(r),vec3(2));\n  return color;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime;\n    //t += 3.5;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if (key(CHAR_A)) AA = 2;\n  // Set torus parameters\n  N += float(keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  M += float(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP));\n  torusr2 = M*M/(N*N);\n  torusR2 = torusr2+1.0;\n  \n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float camera = 2.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0.0, 0.0, -camera);\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = (2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = vec3(uv, 2.0);\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.r = 1.0;\n  fragColor = vec4(color,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\nvoid mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n#if 0\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        //vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0) {\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n#endif\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// common\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat evalquadratic(float x, float A, float B, float C) {\n  return (A*x+B)*x+C;\n}\n\nfloat evalcubic(float x, float A, float B, float C, float D) {\n  return ((A*x+B)*x+C)*x+D;\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n\n// Quadratic solver from Kahan\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Numerical Recipes algorithm for solving cubic equation\nint cubic(float a, float b, float c, float d, out vec3 res) {\n  if (a == 0.0) {\n    return quadratic(b,c,d,res.xy);\n  }\n  if (d == 0.0) {\n    res.x = 0.0;\n    return 1+quadratic(a,b,c,res.yz);\n  }\n  float tmp = a; a = b/tmp; b = c/tmp; c = d/tmp;\n  // solve x^3 + ax^2 + bx + c = 0\n  float Q = (a*a-3.0*b)/9.0;\n  float R = (2.0*a*a*a - 9.0*a*b + 27.0*c)/54.0;\n  float R2 = R*R, Q3 = Q*Q*Q;\n  if (R2 < Q3) {\n    float X = clamp(R/sqrt(Q3),-1.0,1.0);\n    float theta = acos(X);\n    float S = sqrt(Q); // Q must be positive since 0 <= R2 < Q3\n    res[0] = -2.0*S*cos(theta/3.0)-a/3.0;\n    res[1] = -2.0*S*cos((theta+2.0*PI)/3.0)-a/3.0;\n    res[2] = -2.0*S*cos((theta+4.0*PI)/3.0)-a/3.0;\n    return 3;\n  } else {\n    float alpha = -sgn(R)*pow(abs(R)+sqrt(R2-Q3),0.3333);\n    float beta = alpha == 0.0 ? 0.0 : Q/alpha;\n    res[0] = alpha + beta - a/3.0;\n    return 1;\n  }\n}\n\nfloat qcubic(float B, float C, float D) {\n  vec3 roots;\n  int nroots = cubic(1.0,B,C,D,roots);\n  // Select the largest\n  float psi = roots[0];\n  if (nroots > 1) psi = max(psi,roots[1]);\n  if (nroots > 2) psi = max(psi,roots[2]);\n  \n  // Give a quick polish with Newton-Raphson\n  for (int i = 0; i < 2; i++) {\n    float delta = evalcubic(psi,1.0,B,C,D)/evalquadratic(psi,3.0,2.0*B,C);\n    psi -= delta;\n  }\n  return psi;\n}\n\n// The Lanczos quartic method\nint lquartic(float c1, float c2, float c3, float c4, out vec4 res) {\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  // There _should_ be a root >= 0, but sometimes the cubic\n  // solver misses it (probably a double root around zero).\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int resn = quadratic(1.0,alpha+a,beta+b,res.xy);\n  vec2 tmp;\n  if (quadratic(1.0,alpha-a,beta-b,tmp) != 0) { \n    res.zw = res.xy;\n    res.xy = tmp;\n    resn += 2;\n  }\n  return resn;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Sometimes it's advantageous to solve for the reciprocal (if there\n  // are very large solutions), but this doesn't seem needed here.\n  if (true) { //abs(B/A) < abs(D/E)) {\n    nroots = lquartic(B/A,C/A,D/A,E/A,roots);\n  } else {\n    nroots = lquartic(D/E,C/E,B/E,A/E,roots);\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  assert(nroots == 0 || nroots == 2 || nroots == 4);\n  return nroots;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(int x) {\n  return float(ihash(uint(x)))/pow(2.0,32.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssc3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2820, 2856, 2897, 3093, 3761], [3763, 3763, 3789, 3789, 3874], [4021, 4021, 4081, 4081, 4318], [4385, 4385, 4447, 4447, 5257], [5259, 5259, 5287, 5287, 5853], [5855, 5855, 5882, 5882, 6242], [6244, 6244, 6301, 6301, 7248]]}
{"id": "NdcGW8", "name": "i spy", "author": "j0", "description": "", "tags": ["eyes"], "likes": 4, "viewed": 262, "published": 3, "date": "1629627496", "time_retrieved": "2024-07-30T19:05:23.269442", "image_code": "\nfloat eye(vec2 uv, float time) {\n    // magic numbers\n    const float pinch = 0.15;\n    const float radius = 0.25;\n    const float eyeballRadius = 0.44;\n    const float pupilRadius = 0.48;\n    const float blinkingSpeed = 2.5;\n    const float eyeballRange = 0.08;\n    float outsideThickness = 10./iResolution.x;\n    \n    // open and close based on noise (0.0 -> open; 1.0 -> closed)\n    float closed = clamp(cnoise(vec2(time * 0.25, 0.0)) * 10.0, 0.0, 1.0);\n    // blink\n    closed = 1.0 - (1.0 - closed) * clamp(1.0 - smoothstep(0.0, 1.5, 18.0 * (sin(time * blinkingSpeed) * 0.5 + 0.5) - 17.0), 0.0, 1.0);\n    // scale eye and outline based on open/closed status\n    float scale = mix(1.0, 50.0, closed);\n    \n    // select direction the eye is looking in (-1..1 on both axes)\n    vec2 direction = clamp(cnoise2(vec2(time * 0.4, 0.0)) * 100.0, -1.0, 1.0);\n    // look directly at viewers every now and then\n    direction *= clamp(1.0 - smoothstep(0.0, 0.1, 3.0 * (sin(time + 0.723) * 0.5 + 0.5) - 2.0), 0.0, 1.0);\n    \n    // create eyeball\n    float ballL = 0.5-length(uv - direction * eyeballRange);\n    float eyeball = smoothstep(eyeballRadius, eyeballRadius + outsideThickness * 0.3, ballL);\n    eyeball -= smoothstep(eyeballRadius + outsideThickness * 0.7, eyeballRadius + outsideThickness, ballL);\n    eyeball += smoothstep(pupilRadius, pupilRadius + outsideThickness * 0.3, ballL);\n    float full = eyeball;\n    \n    // pinch out the extremities of the eye\n    uv.y *= scale;\n    outsideThickness *= scale;\n    uv.y -= (step(uv.y, 0.0) * 2.0 - 1.0) * pinch;\n    // draw outline\n    float fullL = 0.5-length(uv);\n    full *= smoothstep(radius + outsideThickness * 0.3, radius + outsideThickness * 0.3, fullL);\n    full += smoothstep(radius, radius + outsideThickness * 0.3, fullL);\n    full -= smoothstep(radius + outsideThickness * 0.7, radius + outsideThickness, fullL);\n    return clamp(full, 0.0, 1.0) * smoothstep(0.9, 0.91, 1.0 - closed);\n}\n\n\n// Palette based on iq's implementation (see Common)\nvec3 palette(float x) {\n    return pal( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = ((uv.y - 0.5) / iResolution.x * iResolution.y) + 0.5;\n    uv += iTime * 0.02 * vec2(-1.0, 0.5);\n    uv *= 12.0;\n    uv -= iMouse.xy * 0.01;\n    \n    // assign tile values to the invidual eyes (drives colour + animation)\n    float tile1 = cnoise(floor(uv) + 0.5) * 97.2;\n    float tile2 = 0.726 + cnoise(floor(uv + 0.5) + 0.5) * 76.01;\n    \n    // stack eyes together (2 passes to achieve the hexagonal alignment easily)\n    vec3 eyes = eye((fract(uv) - 0.5) * 0.45, iTime * 0.5 + tile1) * palette(tile1 + iTime * 0.1 + iMouse.x * 0.006);\n    eyes += eye((fract(uv + 0.5) - 0.5) * 0.45, iTime * 0.5 + tile2) * palette(tile2 + iTime * 0.1 + iMouse.y * 0.006);\n    \n    fragColor = vec4(eyes, 1.0);\n}\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "\n\n// Colour palette by iq https://www.shadertoy.com/view/ll2GD3\n//\n// The MIT License\n// Copyright  2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Return a 2D position\nvec2 cnoise2(vec2 p){\n    return vec2(cnoise(p), cnoise(p.yx));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 33, 54, 1953], [1956, 2009, 2032, 2032, 2130], [2134, 2134, 2189, 2189, 2938]]}
{"id": "sdt3Dr", "name": "General Relativistic Black Hole ", "author": "copperbotte", "description": "light funny", "tags": ["raytracing", "physics"], "likes": 4, "viewed": 238, "published": 3, "date": "1629617507", "time_retrieved": "2024-07-30T19:05:24.319634", "image_code": "\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n//another random number generator\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat hashrandom( float x )\n{\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n\n\n\n//color space transforms\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 XYZ_to_lsrgb(vec3 XYZ)\n{\n    mat3 tolsrgb = transpose(mat3( 3.2406,-1.5372,-0.4986,\n                                  -0.9689, 1.8758, 0.0415,\n                                   0.0557,-0.2040, 1.0570));\n    return tolsrgb * XYZ;\n}\n\nvec3 lsrgb_to_XYZ(vec3 lsrgb)\n{\n    mat3 toXYZ = transpose(mat3(0.4124, 0.3576, 0.1805,\n                                0.2126, 0.7152, 0.0722,\n                                0.0193, 0.1192, 0.9505));\n    return toXYZ * lsrgb;\n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        //hsv.yz /= hsv.z; // saturation clip\n        hsv.z /= hsv.z; // luminance clip\n    \n    /*\n    if(1.0 < hsv.y) // what??\n        //hsv.yz /= hsv.z;\n        hsv.y /= hsv.y;\n    */\n    return hsv2rgb(hsv);\n}\n\n// This code was rewritten on the morning of 2022 March 25.\n\n//events are in the form of (x,y,z,t) for ease of programming.\n\nmat4 trace(vec4 tr)\n{\n    mat4 m = mat4(0.0);\n    for(int n=0; n<4; ++n)\n        m[n][n] = tr[n];\n    return m;\n}\n\n// [r, theta, psi, t]\n\nvec3 MorrisThorneCoefficients(float r, float rs)\n{\n    float a0 = rs*2.0;\n    float b0 = a0*3.0;\n    float Phi = 0.0;\n    /*\n    float b = 1.0 - (r - b0)/a0;\n    float db = -(2.0*b0/a0)*b;\n    \n    if(r <= b0)\n        b = b0*b*b;\n    else\n    {\n        b = 0.0;\n        db = 0.0;\n    }*/\n    \n    float b = exp(-r*r/(a0*a0));\n    float db = -b*r/(a0*a0);\n    \n    return vec3(b, db, Phi);\n}\n\nmat4 p_schwarzschildMetric(vec4 p_event, float rs)\n{\n\n    float k = 1.0 - rs / p_event.x;\n    float r2 = p_event.x * p_event.x;\n    float s2 = sin(p_event.y);\n    s2 *= s2;\n    ///*\n    vec4 tr = vec4(1.0/k, r2, r2*s2, -k);\n    mat4 metric = trace(tr);\n    return metric;\n    /*/\n    \n    // Morris-Thorne metric, from here\n    // https://uncw.edu/phy/documents/mceachern_09.pdf\n    // Uses a redshift function Phi = 0, and b = b0(1-(r-b0)/a0)^2 from page 46\n    \n    vec3 MTC = MorrisThorneCoefficients(p_event.x, rs);\n    float b = MTC.x;\n    float db = MTC.y;\n    float Phi = MTC.z;\n    \n    vec4 tr = vec4(1.0/(1.0 - b/p_event.x), r2, r2*s2, -exp(2.0*Phi));\n    mat4 metric = trace(tr);\n    return metric;\n    */\n}\n\n// This code was written from my rewrite of this in March 2022.\nvec4 p_sc_4_accel(in vec4 p_event, in vec4 p_devent, float rs, float c)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    float Dr = r - rs;\n    \n    float dr = p_devent.x;\n    float dth = p_devent.y;\n    float dph = p_devent.z;\n    float dt = p_devent.w;\n    \n    float i_r = 1.0 / r;\n    float dr_r = dr * i_r;\n    \n    float c_t = cos(theta);\n    float s_t = sin(theta);\n    float t_t = tan(theta);\n    ///*\n    vec4 Out;\n    Out = vec4(\n        -(c*c*dt*dt*Dr)*rs/(2.0*r*r*r) + dr*dr*rs/(2.0*r*Dr) + (dth*dth + dph*dph*s_t*s_t)*Dr,\n        -2.0*dr_r*dth + dph*dph*s_t*c_t,\n        -2.0*dph*(dr_r + dth*c_t/s_t),\n        -dr_r*dt*rs/Dr);\n    return Out;\n    /*/\n    vec3 MTC = MorrisThorneCoefficients(p_event.x, rs);\n    float b = MTC.x;\n    float db = MTC.y;\n    float Phi = MTC.z;\n    \n    vec4 Out;\n    Out = vec4(\n        (r - b)*(dth*dth + dph*dph*s_t*s_t) + (dr*dr*(b - r*db))/(2.0*r*(r - b)),\n        -(2.0*dr*dth/r) + dph*dph*c_t*s_t,\n        -(2.0*dph*(dr+dth*r/t_t))/r,\n        -0.0);\n    \n    return Out;\n    */\n}\n\nvec4 toPolar(vec4 event)\n{\n    vec3 x = event.xyz;\n    float r = length(x);\n    float xyr = length(x.xy);\n    float theta = atan(xyr, x.z);\n    float psi = atan(x.y, x.x);\n    return vec4(r, theta, psi, event.w);\n}\n\nvec4 toEuclid(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float x = r*sin(theta)*cos(psi);\n    float y = r*sin(theta)*sin(psi);\n    float z = r*cos(theta);\n    \n    return vec4(x, y, z, p_event.w);\n}\n\nmat4 e_p_jacobian(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float c_p = cos(psi);\n    float s_p = sin(psi);\n    float c_t = cos(theta);\n    float s_t = sin(theta);\n    \n    mat4 J = mat4(   s_t*c_p,   s_t*s_p,    c_t, 0,\n                   r*c_t*c_p, r*c_t*s_p, -r*s_t, 0,\n                  -r*s_t*s_p, r*s_t*c_p,      0, 0,\n                           0,         0,      0, 1);\n    \n    return J;\n}\n\nmat4 e_p_i_jacobian(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float c_p = cos(psi);\n    float s_p = sin(psi);\n    float c_t = cos(theta);\n    float s_t = sin(theta);\n    \n    mat4 iJ = mat4(s_t*c_p, c_t*c_p/r, -s_p/(r*s_t), 0.0,\n                   s_t*s_p, c_t*s_p/r,  c_p/(r*s_t), 0.0,\n                       c_t,    -s_t/r,          0.0, 0.0,\n                       0.0,       0.0,          0.0, 1.0);\n    \n    return iJ;\n}\n\n\nbool hitPlane(vec4 p0, vec4 p1, vec3 normal, float offset, out vec4 hit)\n{\n    float d0 = dot(p0.xyz, normal) - offset;\n    float d1 = dot(p1.xyz, normal) - offset;\n    if(sign(d0) == sign(d1))\n        return false;\n\n    //intermediate value theorem\n    float s = (offset-d0) / (d1-d0);\n    vec4 dp = p1 - p0;\n    hit = dp*s + p0;\n    return true;\n}\n\nbool hitAccrete(vec4 p0, vec4 p1, out vec4 hit, in float rs)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    \n    float theta = -3.141592 / 6.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    \n    vec4 x0 = vec4(0,0,0,0);\n    \n    vec3 normal = normalize(vec3(0,0,1));\n    normal = rotate * normal;\n    vec4 s_hit;\n    if(!hitPlane(p0-x0, p1-x0, normal, 0.0, s_hit))\n        return false;\n    \n    float lh = length(s_hit.xyz) / 0.25;// / rs;\n    if(lh < 3.0 || 6.0 < lh)\n        return false;\n    \n    hit = s_hit;\n    return true;\n}\n\nbool hitFloor(vec4 p0, vec4 p1, out vec4 hit)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    vec4 x0 = vec4(0,0,-1,0);\n    //vec3 x0 = vec3(0,0,-1);\n    //x0.y = sin(iTime * 3.141592 / 5.0);\n    vec3 normal = normalize(vec3(0,0,1));\n    \n    vec4 s_hit;\n    if(!hitPlane(p0, p1, normal, dot(normal, x0.xyz), s_hit))\n        return false;\n    \n    float planesize = 40000.0;\n    \n    if(planesize < length(s_hit.xy))\n        return false;\n     \n    hit = s_hit;\n    return true;\n}\n\nbool hitStar(vec4 coord0, vec4 coord1, out vec4 hitcoord, float rn)\n{\n    // Find if the ray passed through the emissive surface\n    if(rn < coord1.x)\n        return false;\n        \n    //intermediate value theorem\n    float s = (rn-coord0.x) / (coord1.x - coord0.x);\n    vec4 dcoord = coord1 - coord0; // no this is awful dont do this\n    hitcoord = dcoord*s + coord0.x;\n    return true;\n}\n\nvec3 colorAccrete(vec4 hit, vec4 vel, mat4 g, in float rs)\n{\n    float theta = 3.141592 / 6.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    hit.xyz = rotate * hit.xyz;\n    vel.xyz = rotate * vel.xyz;\n\n    float angle = atan(hit.y, hit.x);\n    angle /= 3.141592 * 2.0;\n    angle += 0.5;\n    \n    angle += hit.w / 3.0;\n    /*\n    vec4 localvel = vec4(hit.y, -hit.x, 0.0, 0.0) / 3.0;\n    localvel.w = sqrt(1.0 - dot(localvel, vel));\n    \n    float gamma = 1.0/sqrt(1.0 - (1.0/9.0));\n    \n    \n    float redshift = sqrt((1.0 + beta) / (1.0 - beta));\n    */\n    \n    angle *= 8.0;\n    bool color = 0.5 < angle - floor(angle);\n    float radius = length(hit.xy) / 0.25;// / rs;\n    radius = (radius - 3.0)/(6.0 - 3.0);\n    color = color != (0.5 < radius - floor(radius));\n    \n    if(color)\n        return srgb2lsrgb(vec3(0.75,0.75,0.75));\n    else\n        return srgb2lsrgb(vec3(0.25,0.25,0.25));\n    \n}\n\nvec3 colorPlane(vec4 hit)\n{\n    //vec2 pos = hit.xz / 2.0;\n    //vec2 pos = hit.xz * 4.0;\n\n    //bool color = 0.5 < mod(pos.x, 1.0);\n    //color = color != 0.5 < mod(pos.y, 1.0);\n    \n    //if(color)\n    //    return vec3(0.75,0.25,0.25);\n    //else\n    //    return vec3(0.25,0.0625,0.0625);\n    \n    vec2 pos = hit.xy / 8.0;\n    //pos.x += sin(hit.w) / (1.0 + exp(5.0-hit.w));\n    \n    vec2 t_uv = mod(pos, 1.0);\n    ivec2 xor = ivec2(t_uv * 256.0);\n    float c = float(xor.x ^ xor.y) / 256.0;\n    \n    vec3 highColor = vec3(0.75,0.25,0.25);// * (1.0 + sin(hit.w)*2.0/(1.0 + exp(5.0-hit.w)))/2.0;\n    vec3 lowColor = highColor * 0.25;\n    \n    return srgb2lsrgb(mix(lowColor, highColor, c));\n}\n\n//hehe i'm 12\nvec3 colorHole(vec4 coord)\n{\n    //return texture(iChannel1, toEuclid(coord).xzy).xyz;\n    \n\n    vec2 uv = coord.yz / (3.141592);\n    \n    uv = mod(uv * 4.0, 1.0);\n    \n    bool color = 0.5 < uv.x - floor(uv.x);\n    color = color != 0.5 < uv.y - floor(uv.y);\n    \n    vec3 highColor = vec3(0.75) * 0.25;\n    vec3 lowColor = highColor * 0.0;\n    \n    if(color)\n        return srgb2lsrgb(highColor);\n    else\n        return srgb2lsrgb(lowColor);\n}\n\n// this is an extremely heavy function. Uses the majority of the redshift via sampled spectra code to produce a color.\n// https://www.shadertoy.com/view/NdGGDy\n\nfloat p_gauss(float am, float A, float mu, float sigmaLow, float sigmaHigh)\n{\n    float sigma;\n    if(am < mu)\n        sigma = sigmaLow;\n    else\n        sigma = sigmaHigh;\n    float dx = am - mu;\n    return A*exp(dx*dx / (-2.0*sigma*sigma));\n}\n\n// https://en.wikipedia.org/wiki/CIE_1931_color_space#CIE_standard_observer\n// https://www.shadertoy.com/view/NdyGWc\nfloat isample_luma()\n{\n    const float sqpi_2 = sqrt(3.141592 / 2.0);\n    \n    // normalized distribution sample\n    vec4 Lum = vec4(0.0);\n    Lum[0] = 0.821 * 46.9 * sqpi_2;\n    Lum[1] = 0.821 * 40.5 * sqpi_2;\n    Lum[2] = 0.286 * 16.3 * sqpi_2;\n    Lum[3] = 0.286 * 31.1 * sqpi_2;\n    \n    vec4 csum = vec4(0.0);\n    csum[0] = Lum[0];\n    csum[1] = csum[0] + Lum[1];\n    csum[2] = csum[1] + Lum[2];\n    csum[3] = csum[2] + Lum[3];\n    \n    float weight = rnd() * csum[3];\n    int i=0;\n    for(; i<4; ++i)\n    {\n        if(weight <= csum[i])\n            break;\n    }\n    \n    // from the given selection, inverse sample the distribution\n    vec4 mus = vec4(568.8, 568.8, 530.9, 530.9);\n    vec4 sigmas = vec4(-46.9, 40.5, -16.3, 31.1);\n    \n    //float xi = rnd();\n    //float angstrom = -sigmas[i]*erfinv(xi) + mus[i];\n    //return isample_hgauss(mus[i], sigmas[i]); // exact!\n    vec2 xi = vec2(rnd(), rnd());\n    float r = sqrt(-2.0*log(1.0 - xi.x)) * sin(xi.y * 3.141592);\n    return r*sigmas[i] + mus[i];\n}\n\nfloat pdf_luma(float wavelength_nm)\n{\n    // Find the normalized luminance for this frequency\n    //norm = 106.9224850198325\n    const float sqpi_2 = sqrt(3.141592 / 2.0);\n    const float norm = (0.821 * (46.9 + 40.5) + 0.286 * (16.3 + 31.1)) * sqpi_2;\n\n    float Y = p_gauss(wavelength_nm, 0.821, 568.8, 46.9, 40.5);\n    Y += p_gauss(wavelength_nm, 0.286, 530.9, 16.3, 31.1);\n\n    return Y / norm;\n}\n\n\nfloat isample_wien(float temperature, float redshift)\n{\n    // Importance sample the blackbody spectra using Wien's approximation\n    // Approximate the hard integral inverse\n    // B = 2hc^2 / L^5 * 1 / (Exp(hc/LkT) - 1)\n    // u = hc/kT\n    // B = (2hc^2/u^5) * (u/L)^5 / (Exp(u/L) - 1)\n    // L/u = v\n    // B = (2hc^2/u^5) * (1/v)^5 / (Exp(1/v) - 1)\n    //\n    // Wien's approximation\n    // B ~ (2hc^2/u^5) * (1/v)^5 * Exp(-1/v)\n    // \n    // the integral of B has the constant term fall out, resulting in:\n    // I = Exp(-1/v) / v^5\n    // \n    // The integral of I from 0 to infinity is 6, with a normalized integral resulting in:\n    // Ihat = exp(-1/v)*(1 + 1/L + 1/(2L^2) + 1/(6L^3))\n    //\n    // Its derivative is exp(-1/v)/(6*v^5)\n    // It is vaguely approximately v^2 * 0.9 + 0.1\n    // Using this, we can compute the inverse of Ihat, and solve for v given xi\n    \n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n    const float pi = 3.141592;\n    \n    float u = h*c/(k*temperature);\n    \n    float xi = rnd();\n    \n    // Initial approximation via Softplus inverse\n    float v = exp(1.0) - (2.0*log(exp(1.0-xi) - 1.0));\n    \n    // Newton iteration 4 times is pretty close\n    for(int i=0; i<1; ++i)\n    {\n        float wien = exp(-v)*v*v*v/6.0;\n        float iwien = 1.0 - exp(-v)*(1.0 + v + v*v/2.0 + v*v*v/6.0);\n        float v2 = v - (iwien - xi) / wien;\n        if(v2 < 0.0 || v2 != v2)\n            v2 = v - 10.0*(iwien - xi);\n        v = v2;\n    }\n    \n    float nm = (u/v) * 1e9 * redshift; // returns nanometers\n    //if(nm != nm) nm = 0.0;\n    \n    return nm;\n    \n}\n\nfloat pdf_wien(float wavelength_nm, float temperature, float redshift)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n    const float pi = 3.141592;\n    \n    float u = h*c/(k*temperature);\n    float L = wavelength_nm;\n    float v = (u/L) * 1e9 * redshift;\n    \n    return exp(-v) * v*v*v / 6.0;\n}\n\nfloat isample_uniform()\n{\n    return rnd() * (780.0 - 380.0) + 380.0;\n}\n\nfloat pdf_uniform(float nm)\n{\n    if(nm < 380.0 || 780.0 < nm)\n        return 0.0;\n    return 1.0 / (780.0 - 380.0);\n}\n\nfloat plancks_law(float wavelength_nm, float temperature)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n\n    float m = wavelength_nm * 1.0e-9;\n    float m2 = m*m;\n\n    float Rayleigh_Jeans = 2.0*h*c*c/(m2*m2*m);\n    float quantum_temp_ratio = h*c/(k*m*temperature);\n    float Wien = exp(quantum_temp_ratio) - 1.0;\n    \n    return Rayleigh_Jeans / Wien;\n}\n\nfloat stefan_boltzmann(float temperature)\n{\n    const float c = 299792458.0; // m/s\n    const float h = 6.62607015e-34; // J/hz\n    const float k = 1.308649e-23; // J/Kelvin\n    const float pi = 3.141592;\n    \n    const float kpi_h = k*pi/h;\n    const float kpi_h3 = kpi_h*kpi_h*kpi_h;\n    \n    const float sigma = 2.0*pi*pi*k*kpi_h3 / (15.0*c*c);\n    \n    return sigma*temperature*temperature*temperature*temperature;\n\n}\n\nvec3 spectra_to_XYZ(float wavelength_nm)\n{\n    float X, Y, Z;\n    X  = p_gauss(wavelength_nm, 1.056, 599.8, 37.9, 31.0);\n    X += p_gauss(wavelength_nm, 0.362, 442.0, 16.0, 26.7);\n    X += p_gauss(wavelength_nm,-0.065, 501.1, 20.4, 26.2);\n\n    Y  = p_gauss(wavelength_nm, 0.821, 568.8, 46.9, 40.5);\n    Y += p_gauss(wavelength_nm, 0.286, 530.9, 16.3, 31.1);\n\n    Z  = p_gauss(wavelength_nm, 1.217, 437.0, 11.8, 36.0);\n    Z += p_gauss(wavelength_nm, 0.681, 459.0, 26.0, 13.8);\n    \n    return vec3(X, Y, Z);\n}\n\n\n\nvec3 colorStar(vec4 x_p, float rs, float localres)\n{\n    // Compute redshift using this formula. In the future, this will be computed generally.\n    // https://en.wikipedia.org/wiki/Gravitational_redshift#Spherically_symmetric_gravitational_field\n    \n    float redshift = 1.0 / sqrt(1.0 - (rs / x_p.x)); // is this gamma?\n    //float redshift = 1.0 / (1.0 - (rs / x_p.x)); // is this gamma?\n    \n    redshift *= localres;\n    \n    const float temp = 9940.0; // sirius\n    //const float temp = 5900.0; // sun\n    \n    vec3 srgb_avg = vec3(0.0);\n    const int spectral_samples = 32;\n    \n    vec3 srgb_samples[spectral_samples]; // RIS\n    float pdf_samples[spectral_samples];\n    float cumsum_samples[spectral_samples+1];\n    \n    for(int i=0; i<spectral_samples; ++i)\n    {\n        //float nm = isample_luma();\n        //float pdf = pdf_luma(nm) * float(spectral_samples);\n        \n        //float nm = isample_wien(temp, redshift);\n        //float pdf = pdf_wien(nm, temp, redshift) * float(spectral_samples);\n\n        //float nm = isample_uniform();\n        //float pdf = pdf_uniform(nm) * float(spectral_samples);\n        \n        // MIS luma uniform, and wien\n        // Randomly select a sampling strategy\n        float nm;\n        const float pct_luma = 1.0 / 2.0;\n        const float pct_uni  = 1.0 / 2.0;\n        const float pct_wien = 0.0;\n        \n        //float dice = rnd();\n        //if(dice < pct_luma) nm = isample_luma();\n        //else if(dice < pct_luma + pct_uni) nm = isample_uni();\n        //else nm = isample_wien(temp, redshift);\n        \n        if(float(i) / float(spectral_samples) < pct_luma) // Sampling without replacement\n            nm = isample_luma();\n        else if(float(i) / float(spectral_samples) < pct_luma + pct_uni)\n            nm = isample_uniform();\n        else \n            nm = isample_wien(temp, redshift);\n        \n        float pdf = (pdf_luma(nm)*pct_luma + pdf_uniform(nm)*pct_uni + pdf_wien(nm, temp, redshift)*pct_wien);\n        //    * float(spectral_samples);\n        \n        \n        float planck = plancks_law(nm / redshift, temp);\n        \n        vec3 srgb = XYZ_to_lsrgb(spectra_to_XYZ(nm)) * planck;\n        srgb_avg += srgb / (pdf * float(spectral_samples));\n        srgb_samples[i] = srgb;\n        pdf_samples[i] = pdf;\n        //cumsum_samples[i+1] = cumsum_samples[i] + pdf_samples[i];\n    }\n    /*\n    cumsum_samples[0] = 0.0;\n    for(int i=0; i<spectral_samples; ++i) // RIS loops, this loop significantly reduces the speed\n        cumsum_samples[i+1] = cumsum_samples[i] + pdf_samples[i];\n        \n    for(int i=0; i<spectral_samples; ++i)\n    {\n        cumsum_samples[i] /= cumsum_samples[spectral_samples];\n        //pdf_samples[i] /= cumsum_samples[spectral_samples];\n    }\n        \n    const int RIS_samples = 32;\n    srgb_avg = vec3(0);\n    \n    // RIS Resamples the given sample set as if they're a finite dataset, with replacement\n    for(int i=0; i<RIS_samples; ++i)\n    {\n        float xi = rnd();\n        int select = 0;\n        for(;select < spectral_samples; select++)\n            if(cumsum_samples[select] < xi)\n                break;\n        srgb_avg += srgb_samples[select];// / float(RIS_samples);\n    }\n    */\n    \n    float dim = 1e-16; // otherwise it looks weird\n    //dim = 5e-17;\n    //dim = 1.0;\n    //dim = 1e-15;\n    \n    //dim = 1.0;\n    //if(1.0 < XYZ_avg.y)\n    // Dim via stefan boltzmann brightness\n    dim = 5e-8 / stefan_boltzmann(temp);\n    //dim = 1.0;\n    \n    //dim *= 5e2;\n    \n    //dim = 1e30; \n    \n    return srgb_avg * dim / redshift;\n}\n\n\n// This version of ColorAccrete uses an emissive disc of a constant temperature, to emphesize redshifting.\nvec3 colorAccrete_rs(vec4 hit, vec4 vel, vec4 x_p, vec4 v_p, mat4 g, in float rs, float c)\n{\n    float theta = 3.141592 / 6.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    hit.xyz = rotate * hit.xyz;\n    vel.xyz = rotate * vel.xyz;\n\n    float angle = atan(hit.y, hit.x);\n    angle /= 3.141592 * 2.0;\n    angle += 0.5;\n    \n    float speed = 1.0 / 3.0; // 1.95 is very close to the speed of light at the edge\n    angle += hit.w * speed;\n    \n    //speed = c*rs/sqrt(2.0 * x_p.x*x_p.x*x_p.x); // proper orbital speed\n    \n    speed = 0.5;\n    \n    vec3 localvel = vec3(hit.y, -hit.x, 0.0) * speed / x_p.x;\n    localvel *= x_p.x; // rigid body rotation\n    \n    \n    vec3 beta3 = localvel / c;\n    float gamma = 1.0/sqrt(1.0 - dot(beta3, beta3));\n    \n    // use the generalized boost matrix!!!\n    // only the energy component is needed for light, no fun boost matrix :(\n    // Locally, the basis vectors are orthonormal. Their lengths aren't orthogonal, which may produce a quirk of this renderer.\n    // 1 - the dot product of the incoming velocity vector's normal and the local beta finds the redshift.\n    \n    float redshift = gamma * (1.0 - dot(beta3, -normalize(vel.xyz)));\n    //float redshift = gamma * dot(vec4(-1, beta3), g * (-vel));\n    \n    \n    \n    //float redshift = sqrt((1.0 + beta) / (1.0 - beta));\n    \n    \n    angle *= 8.0;\n    bool color = 0.5 < angle - floor(angle);\n    float radius = length(hit.xy) / 0.25;// / rs;\n    radius = (radius - 3.0)/(6.0 - 3.0);\n    color = color != (0.5 < radius - floor(radius));\n    \n    vec3 lc = vec3(1);\n    \n    if(color)\n        lc = vec3(0.75);\n    else\n        lc = vec3(0.25);\n    lc = srgb2lsrgb(lc);\n    \n    \n    //lc = lc * 1e-17; // this term was moved into colorStar\n    //lc = lc * 1e-16;// this one looks sick\n        \n    return lc * colorStar(x_p, rs, redshift);\n    \n}\n\nvoid traverse_2nd(inout vec4 x_p, inout vec4 v_p, float rs, float rn, float c)\n{\n\n    vec4 x1 = toEuclid(x_p);\n    vec4 vel = vec4(normalize((e_p_jacobian(x_p) * v_p).xyz), 0.0);\n    for(int i=0; i<1024; ++i)\n    {\n        float dT = 0.05 * sin(x_p.y) * x_p.x;\n        \n        vec4 a_p = p_sc_4_accel(x_p, v_p, rs, c);\n        \n        // Update via finite difference\n        //v_p += a_p * dT;\n        //x_p += v_p * dT;\n        \n        // RK4\n        // https://www.ctcms.nist.gov/~langer/oof2man/RegisteredClass-RK4.html\n        vec4 k1v = dT * p_sc_4_accel(x_p, v_p, rs, c);\n        vec4 k1x = dT * v_p;\n        \n        vec4 k2v = dT * p_sc_4_accel(x_p + k1x/2.0, v_p + k1v/2.0, rs, c);\n        vec4 k2x = dT * (v_p + k1v/2.0);\n        \n        vec4 k3v = dT * p_sc_4_accel(x_p + k2x/2.0, v_p + k2v/2.0, rs, c);\n        vec4 k3x = dT * (v_p + k2v/2.0);\n        \n        vec4 k4v = dT * p_sc_4_accel(x_p + k3x, v_p + k3v, rs, c);\n        vec4 k4x = dT * (v_p + k3v);\n        \n        vec4 p_x_p = x_p;\n        \n        v_p += (k1v + 2.0*k2v + 2.0*k3v + k4v) / 6.0;\n        x_p += (k1x + 2.0*k2x + 2.0*k3x + k4x) / 6.0;\n        \n        // RK4 doesn't like dropping below the event horizon, simulate a finite difference step\n        if((x_p + k1x + k1v*dT).x < rs)\n        //if(x_p.x < rs)\n            //return colorHole(x_p);\n            return;// vec3(0);\n        \n        /*\n        g = p_schwarzschildMetric(x_p, rs);\n        halfmag = g * v_p;\n        spacemag = dot(v_p.xyz, halfmag.xyz);\n        v_p.w = -sqrt((c*c - spacemag)/g[3][3]);\n        \n        \n        //if(x_p.x < rs)\n        //if((x_p + k1x + k1v*dT).x < 0.0*rs)\n        //    return colorHole(x_p);\n        if(x_p.x < 0.0)\n        {\n            v_p *= sign(v_p.x);\n            x_p *= -1.0;\n        }*/\n        \n        vec4 x2 = toEuclid(x_p);\n        \n        if(hitFloor(x2, x1, x2))\n            return;// colorPlane(x2);\n        \n        if(hitStar(x_p, p_x_p, x_p, rn))\n            return;// colorStar(x_p, rs, 1.0);\n        \n        \n        if(hitAccrete(x2, x1, x2, rs))\n        {\n            vel = v_p;\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);\n            mat4x4 g = p_schwarzschildMetric(x_p, rs);\n            //return colorAccrete(x2, vel, g, rs);\n            return;// colorAccrete_rs(x2, vel, x_p, v_p, g, rs, c);\n        }\n        \n        if(x_p.x > 10000.0)\n        {\n            // Solve for the outgoing cartesian velocity\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);    \n            return;// srgb2lsrgb(texture(iChannel0, vel.xzy).xyz);\n        }\n        \n        x1 = x2;\n    }\n\n    return;// vec3(0);\n\n}\n\n//random point in sphere\nvec3 randSphere()\n{\n    float xi1 = rnd() * 2.0 - 1.0;\n    float xi2 = rnd();\n\n    float theta = xi2 * 2.0 * 3.141592;\n    float sinp = sqrt(1.0 - xi1*xi1);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = xi1;\n\n    return vec3(x, y, z);\n}\nvec3 sampleSphere(vec3 normal, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randSphere();\n    \n    if(dot(rOut, normal) < 0.0)\n        rOut = reflect(rOut, normal);\n    \n    //should these be packed into the sampler?\n    //float pdf = 1.0; // no numerator pdf\n    pdf /= 2.0 * 3.141592; // 4pi r^2 / 2, half a sphere's area (clamped)\n    \n    return rOut;\n}\nfloat pdfSphere()\n{\n    return 1.0 / (2.0 * 3.141592);\n}\n\nvec3 traverse(vec4 x_p, vec4 v_p, float rs, float rn, float c)\n{\n    vec4 x1 = toEuclid(x_p);\n    vec4 vel = vec4(normalize((e_p_jacobian(x_p) * v_p).xyz), 0.0);\n    for(int i=0; i<1024; ++i)\n    {\n        float dT = 0.05 * sin(x_p.y) * x_p.x;\n        \n        vec4 a_p = p_sc_4_accel(x_p, v_p, rs, c);\n        \n        // Update via finite difference\n        //v_p += a_p * dT;\n        //x_p += v_p * dT;\n        \n        // RK4\n        // https://www.ctcms.nist.gov/~langer/oof2man/RegisteredClass-RK4.html\n        vec4 k1v = dT * p_sc_4_accel(x_p, v_p, rs, c);\n        vec4 k1x = dT * v_p;\n        \n        vec4 k2v = dT * p_sc_4_accel(x_p + k1x/2.0, v_p + k1v/2.0, rs, c);\n        vec4 k2x = dT * (v_p + k1v/2.0);\n        \n        vec4 k3v = dT * p_sc_4_accel(x_p + k2x/2.0, v_p + k2v/2.0, rs, c);\n        vec4 k3x = dT * (v_p + k2v/2.0);\n        \n        vec4 k4v = dT * p_sc_4_accel(x_p + k3x, v_p + k3v, rs, c);\n        vec4 k4x = dT * (v_p + k3v);\n        \n        vec4 p_x_p = x_p;\n        \n        v_p += (k1v + 2.0*k2v + 2.0*k3v + k4v) / 6.0;\n        x_p += (k1x + 2.0*k2x + 2.0*k3x + k4x) / 6.0;\n        \n        // RK4 doesn't like dropping below the event horizon, simulate a finite difference step\n        if((x_p + k1x + k1v*dT).x < rs)\n        //if(x_p.x < rs)\n            //return colorHole(x_p);\n            return vec3(0);\n        \n        /*\n        g = p_schwarzschildMetric(x_p, rs);\n        halfmag = g * v_p;\n        spacemag = dot(v_p.xyz, halfmag.xyz);\n        v_p.w = -sqrt((c*c - spacemag)/g[3][3]);\n        \n        \n        //if(x_p.x < rs)\n        //if((x_p + k1x + k1v*dT).x < 0.0*rs)\n        //    return colorHole(x_p);\n        if(x_p.x < 0.0)\n        {\n            v_p *= sign(v_p.x);\n            x_p *= -1.0;\n        }*/\n        \n        vec4 x2 = toEuclid(x_p);\n        \n        if(hitFloor(x2, x1, x2))\n            return colorPlane(x2);\n        \n        if(hitStar(x_p, p_x_p, x_p, rn))\n            return colorStar(x_p, rs, 1.0);\n        \n        \n        if(hitAccrete(x2, x1, x2, rs))\n        {\n            vel = v_p;\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);\n            mat4x4 g = p_schwarzschildMetric(x_p, rs);\n            //return colorAccrete(x2, vel, g, rs);\n            return colorAccrete_rs(x2, vel, x_p, v_p, g, rs, c);\n        }\n        \n        if(x_p.x > 10000.0)\n        {\n            // Solve for the outgoing cartesian velocity\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);    \n            return srgb2lsrgb(texture(iChannel0, vel.xzy).xyz);\n        }\n        \n        x1 = x2;\n    }\n}\n\n\n\nvec3 render( in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    //uv /= 5.0;\n    \n    //view rotation matrix\n    //yaw\n    float th_yaw = 3.141592 * iTime / (2.0 * 5.0);\n    float th_pitch = 3.141592 * (0.25 / 2.0);\n    //th_yaw = 1.25;\n    //th_yaw = 0.0;\n    \n    //th_pitch = 0.0;\n    //th_pitch = 0.5;\n    \n    if(0.5 < iMouse.z)\n    {\n        th_yaw = 3.141592 * (iMouse.x / iResolution.x);\n        th_pitch = 3.141592 * (0.5 - iMouse.y / iResolution.y);\n    }\n    mat3 yaw = mat3(vec3(cos(th_yaw), -sin(th_yaw), 0.0),\n                    vec3(sin(th_yaw),  cos(th_yaw), 0.0),\n                    vec3(        0.0,          0.0, 1.0));\n    \n    mat3 pitch = mat3(vec3(1.0,           0.0,           0.0),\n                      vec3(0.0, cos(th_pitch), -sin(th_pitch)),\n                      vec3(0.0, sin(th_pitch), cos(th_pitch)));\n    \n    mat3 view = yaw * pitch;\n    \n    vec3 dir = normalize(vec3(uv.x, 1.0, uv.y));\n    vec3 src = vec3(0.0, -4.0, 0.0);\n    \n    src.xyz += texture(iChannel2, vec2(0)).xyz;\n    \n    dir = view * dir;\n    src = view * src;\n    \n    // Find initial point in polar coords\n    vec4 src_t = vec4(src, iTime);\n    vec4 x_p = toPolar(src_t);\n    // [r, theta, psi, t]\n    \n    // Find initial velocity in polar coords at x_p\n    mat4 iJ = e_p_i_jacobian(x_p);\n    vec4 v_p = iJ * vec4(dir, 1.0);\n    \n    // Correct the time component\n    float c = 1.0;\n    float rs = 0.25;\n    rs *= 1.0/(1.0+exp(10.0*(1.0-iTime/3.0)));\n    //float rn = 0.28;//0.25 + exp(-iTime);\n    float rn = 0.2499;\n    \n    mat4 g = p_schwarzschildMetric(x_p, rs);\n    vec4 halfmag = g * v_p;\n    float spacemag = dot(v_p.xyz, halfmag.xyz); // treat this as beta, not v.\n    v_p.w = -sqrt((1.0 - spacemag)/g[3][3]);\n    \n    // Iterate to find the coordinates over time\n    //traverse(x_p, v_p, rs, c, rn, g);\n    vec4 x1 = toEuclid(x_p);\n    vec4 vel = vec4(normalize((e_p_jacobian(x_p) * v_p).xyz), 0.0);\n    for(int i=0; i<1024; ++i)\n    {\n        float dT = 0.05 * sin(x_p.y) * x_p.x;\n        \n        vec4 a_p = p_sc_4_accel(x_p, v_p, rs, c);\n        \n        // Update via finite difference\n        //v_p += a_p * dT;\n        //x_p += v_p * dT;\n        \n        // RK4\n        // https://www.ctcms.nist.gov/~langer/oof2man/RegisteredClass-RK4.html\n        vec4 k1v = dT * p_sc_4_accel(x_p, v_p, rs, c);\n        vec4 k1x = dT * v_p;\n        \n        vec4 k2v = dT * p_sc_4_accel(x_p + k1x/2.0, v_p + k1v/2.0, rs, c);\n        vec4 k2x = dT * (v_p + k1v/2.0);\n        \n        vec4 k3v = dT * p_sc_4_accel(x_p + k2x/2.0, v_p + k2v/2.0, rs, c);\n        vec4 k3x = dT * (v_p + k2v/2.0);\n        \n        vec4 k4v = dT * p_sc_4_accel(x_p + k3x, v_p + k3v, rs, c);\n        vec4 k4x = dT * (v_p + k3v);\n        \n        vec4 p_x_p = x_p;\n        \n        v_p += (k1v + 2.0*k2v + 2.0*k3v + k4v) / 6.0;\n        x_p += (k1x + 2.0*k2x + 2.0*k3x + k4x) / 6.0;\n        \n        // RK4 doesn't like dropping below the event horizon, simulate a finite difference step\n        if((x_p + k1x + k1v*dT).x < rs)\n        //if(x_p.x < rs)\n            //return colorHole(x_p);\n            return vec3(0);\n        \n        /*\n        g = p_schwarzschildMetric(x_p, rs);\n        halfmag = g * v_p;\n        spacemag = dot(v_p.xyz, halfmag.xyz);\n        v_p.w = -sqrt((c*c - spacemag)/g[3][3]);\n        \n        \n        //if(x_p.x < rs)\n        //if((x_p + k1x + k1v*dT).x < 0.0*rs)\n        //    return colorHole(x_p);\n        if(x_p.x < 0.0)\n        {\n            v_p *= sign(v_p.x);\n            x_p *= -1.0;\n        }*/\n        \n        vec4 x2 = toEuclid(x_p);\n        \n        if(hitFloor(x2, x1, x2))\n        {\n            return colorPlane(x2);\n            /*\n            vec3 albedo = colorPlane(x2);\n            vec3 wsum = vec3(0.0);\n            float pdf = 0.0;\n            const int lsamples = 10;\n            for(int j=0; j<lsamples; ++j)\n            {\n                // Randomly choose a point on a sphere\n                float spdf = 0.0;\n                dir = sampleSphere(vec3(0,0,1), spdf);\n                v_p = e_p_i_jacobian(x_p) * vec4(dir, 1.0);\n                vec3 lit = traverse(x_p, v_p, rs, rn, c);\n                wsum += lit;///spdf;\n                //pdf += 1.0/spdf;\n            }\n            return albedo*wsum/float(lsamples);\n            */\n        }\n        \n        if(hitStar(x_p, p_x_p, x_p, rn))\n            return colorStar(x_p, rs, 1.0);\n        \n        \n        if(hitAccrete(x2, x1, x2, rs))\n        {\n            vel = v_p;\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);\n            g = p_schwarzschildMetric(x_p, rs);\n            //return colorAccrete(x2, vel, g, rs);\n            return colorAccrete_rs(x2, vel, x_p, v_p, g, rs, c);\n        }\n        \n        if(x_p.x > 10000.0)\n        {\n            // Solve for the outgoing cartesian velocity\n            vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);    \n            return srgb2lsrgb(texture(iChannel0, vel.xzy).xyz);\n        }\n        \n        x1 = x2;\n    }\n\n    return vec3(0);\n\n    // Solve for the outgoing cartesian velocity\n    vel.xyz = normalize((e_p_jacobian(x_p) * v_p).xyz);    \n    return texture(iChannel0, vel.xzy).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    seed = hashrandom(iTime + iResolution.y * uv.x + uv.y);\n\n    //vec3 col = render(fragCoord);\n    vec3 col = vec3(0.0);\n    \n    const bool AntiAlias = false;\n    if(AntiAlias)\n    {\n        const int samples = 4;\n        //vec3 sample_arr[samples];\n        for(int i=0; i<samples; ++i)\n        {\n            //sample_arr[i] = render(fragCoord + ((vec2(rnd(), rnd())-0.5)));\n            //col += sample_arr[i];\n            col += render(fragCoord + ((vec2(rnd(), rnd())-0.5)));\n        }\n        /*\n        for(int i=0; i<samples; ++i) // ris?\n            col += sample_arr[int(float(samples)*rnd())];\n        */\n        \n        col /= float(samples);\n    }else{\n        col = render(fragCoord);\n    }\n    \n    col = saturationClip(col);\n    // Luminance clip\n    /*\n    vec3 XYZ = lsrgb_to_XYZ(col);\n    float control = lsrgb_to_XYZ(vec3(1)).y;\n    if(control < XYZ.y)\n        XYZ.y = control;\n    col = XYZ_to_lsrgb(XYZ);\n    */\n    \n    col = clamp(col, vec3(0), vec3(1));\n    fragColor = vec4(lsrgb2srgb(col),1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// stores user interaction states\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    // https://www.shadertoy.com/view/4dGyDm\n    const int kc_le = 37; \n    const int kc_up = 38; \n    const int kc_ri = 39; \n    const int kc_do = 40; \n    const int kc_sp = 32; \n    bool k_le = texelFetch(iChannel0, ivec2(kc_le, 0), 0).x > 0.;\n    bool k_up = texelFetch(iChannel0, ivec2(kc_up, 0), 0).x > 0.;\n    bool k_ri = texelFetch(iChannel0, ivec2(kc_ri, 0), 0).x > 0.;\n    bool k_do = texelFetch(iChannel0, ivec2(kc_do, 0), 0).x > 0.;\n    bool k_sp = texelFetch(iChannel0, ivec2(kc_sp, 0), 0).x > 0.;\n    \n    if(iFrame == 0 || k_sp)\n    {\n        fragColor = vec4(0);\n    }\n    else\n    {\n        vec4 dx = vec4(0);\n        if(k_le) dx += vec4(-1, 0,0,0);\n        if(k_ri) dx += vec4( 1, 0,0,0);\n        if(k_up) dx += vec4( 0, 1,0,0);\n        if(k_do) dx += vec4( 0,-1,0,0);\n\n        fragColor = texture(iChannel1, fragCoord) + dx * iTimeDelta;\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 93, 106, 106, 149], [151, 334, 355, 355, 486], [488, 646, 678, 678, 1098], [1100, 1149, 1178, 1178, 1233], [1238, 1263, 1297, 1297, 1424], [1426, 1426, 1458, 1458, 1538], [1540, 1540, 1573, 1573, 1693], [1695, 1695, 1726, 1726, 1803], [1805, 1883, 1910, 1910, 2261], [2263, 2263, 2290, 2290, 2466], [2468, 2468, 2497, 2497, 2704], [2706, 2706, 2737, 2737, 2935], [2937, 2937, 2971, 2971, 3240], [3367, 3367, 3388, 3388, 3480], [3505, 3505, 3555, 3555, 3895], [3897, 3897, 3949, 3949, 4615], [4617, 4681, 4754, 4754, 5746], [5748, 5748, 5774, 5774, 5962], [5964, 5964, 5993, 5993, 6225], [6227, 6227, 6260, 6260, 6689], [6691, 6691, 6726, 6726, 7180], [7183, 7183, 7257, 7257, 7532], [7534, 7534, 7596, 7658, 8207], [8209, 8209, 8256, 8318, 8709], [8711, 8711, 8780, 8839, 9101], [9103, 9103, 9163, 9163, 10121], [10123, 10123, 10150, 10415, 10818], [10820, 10834, 10862, 10920, 11279], [11442, 11442, 11519, 11519, 11686], [11688, 11805, 11827, 11827, 12817], [12819, 12819, 12856, 12943, 13219], [13222, 13222, 13277, 14097, 14896], [14898, 14898, 14970, 14970, 15279], [15281, 15281, 15306, 15306, 15352], [15354, 15354, 15383, 15383, 15472], [15474, 15474, 15533, 15533, 15914], [15916, 15916, 15959, 15959, 16337], [16339, 16339, 16381, 16381, 16848], [16852, 16852, 16904, 17098, 20402], [20405, 20512, 20604, 20604, 22475], [22477, 22477, 22557, 22557, 25119], [25121, 25146, 25165, 25165, 25417], [25418, 25418, 25465, 25465, 25777], [25778, 25778, 25797, 25797, 25834], [25836, 25836, 25900, 25900, 28421], [28425, 28425, 28459, 28509, 33708], [33710, 33710, 33767, 33767, 34832]]}
{"id": "7dd3Dn", "name": "Chess table", "author": "TestCoder", "description": "chess", "tags": ["chess"], "likes": 2, "viewed": 241, "published": 3, "date": "1629606277", "time_retrieved": "2024-07-30T19:05:25.178338", "image_code": "float getSquareSine(float x) {\n    return sign(sin(x));\n}\n\nfloat getRotatingMagnifier(vec2 uv, float radius, float rotationDisplacement) {\n    return distance(\n        uv,\n        vec2(\n            sin(iTime + rotationDisplacement),\n            cos(iTime + rotationDisplacement)\n        )\n    ) * radius;\n}\n\n\nfloat getChessPattern(vec2 uv, float size) {\n    return (\n        (\n            getSquareSine(-uv.x * size) + getSquareSine(-uv.y * size)\n        ) * -1. * (\n            getSquareSine(uv.x * size) + getSquareSine(uv.y * size)\n        )\n    );\n}\n\nfloat getDistortedTable(vec2 uv, float radius, float size, float rotationDisplacement) {\n    float magnifier = getRotatingMagnifier(uv, radius, rotationDisplacement);\n\n    return (\n        getChessPattern(\n            uv\n\n            // table distortion\n            * magnifier\n            ,\n            size\n        ) * magnifier * (1. - magnifier)\n    );\n}\n\nfloat getDistortionStack(vec2 uv, float slicingSteps) {\n    float distortionStack = 0.;\n    \n    for (float timeSlice = 1.; timeSlice <= pow(2., slicingSteps); timeSlice += timeSlice) {\n        distortionStack +=\n             getDistortedTable(uv, 1., 50., sin(iTime / timeSlice))\n           + getDistortedTable(uv, 1., 50., cos(iTime / timeSlice));\n    }\n\n    return distortionStack;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    \n    uv.y *= iResolution.y / iResolution.x;\n    \n    float distortionStack = getDistortionStack(uv, 3.);\n\n    vec3 col = distortionStack * vec3(1);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dd3Dn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 57], [59, 59, 138, 138, 306], [309, 309, 353, 353, 553], [555, 555, 643, 643, 913], [915, 915, 970, 970, 1301], [1303, 1303, 1360, 1360, 1589]]}
{"id": "sdt3Wn", "name": "Logzoom", "author": "oneshade", "description": "More log-repeat fun.", "tags": ["zoom", "infinite"], "likes": 10, "viewed": 166, "published": 3, "date": "1629592304", "time_retrieved": "2024-07-30T19:05:26.087906", "image_code": "void mainImage(out vec4 o, vec2 u) {\n    u /= iResolution.x * exp2(fract(iTime));\n    u /= exp2(ceil(log2(u.x))) * .5;\n    o = step(-1., -u.y) * smoothstep(2., .2, u.x -= 1.) * texture(iChannel0, u);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 201]]}
{"id": "sdtGWn", "name": "Mipmap Generator - Code Golf", "author": "oneshade", "description": "Can you make it shorter?\nI prefer the original look (the one on display) but I'll allow it to be horizontally and/or vertically flipped as long as the texture maintains the original orientation.", "tags": ["texture", "mipmap", "codegolf", "generate"], "likes": 9, "viewed": 500, "published": 3, "date": "1629589139", "time_retrieved": "2024-07-30T19:05:26.972541", "image_code": "/* 135 chars by (by @Xor) - horizontally and vertically flipped *\nvoid mainImage(out vec4 o, vec2 u) {\n    u /= iResolution.xy;\n    u /= exp2(floor(log2(u.y + ceil(u.x = u.x * 1.5 - .5))));\n    o = u.x > -1. ? texture(iChannel0, u): o - o; // Changing -o to more compatible o-o\n}\n/**/\n\n/* 144 chars (by @Xor) - original look */\nvoid mainImage(out vec4 o, vec2 u) {\n    u /= iResolution.xy;\n    o = texture(iChannel0, u /= u.x < .5 ?\n        vec2(.5, 1): -exp2(floor(log2(u = vec2(.5, 1)-u).yy))) - floor(u.x);\n}\n/**/\n\n/* 145 chars (by @Jodie) - horizontally and vertically flipped *\nvoid mainImage(out vec4 o, vec2 u) {\n    u /= iResolution.xy;\n    o -= o;\n    u.x = u.x * 1.5 - .5;\n    u /= exp2(floor(log2(u.y + ceil(u.x))));\n    if (u.x > -1.) {\n        o = texture(iChannel0, u);\n    }\n}\n/**/\n\n/* 201 chars (original) *\nvoid mainImage(out vec4 o, vec2 u) {\n    u /= iResolution.xy;\n    o -= o;\n\n    if (u.x < .5) {\n        u.x *= 2.;\n        o = texture(iChannel0, u);\n    }\n\n    else {\n        u = vec2(u.x - .5, 1. - u.y);\n        u /= exp2(floor(log2(u.y)));\n        if (u.x < 1.) {\n            u.y = 2. - u.y;\n            o = texture(iChannel0, u);\n        }\n    }\n}\n/**/\n\n/* Less compressed version *\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(0.0);\n\n    if (uv.x < 0.5) {\n        uv.x *= 2.0;\n        fragColor = texture(iChannel0, uv);\n    }\n\n    else {\n        uv = vec2(uv.x - 0.5, 1.0 - uv.y);\n        uv /= exp2(floor(log2(uv.y)));\n        if (uv.x < 1.0) {\n            uv.y = 2.0 - uv.y;\n            fragColor = texture(iChannel0, uv);\n        }\n    }\n}\n/**/", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 328, 364, 364, 511]]}
{"id": "fljXWt", "name": "Primitive retro blur", "author": "frhun", "description": "Retro-y pixelated blur, or rather scatter.\nThe background in Buffer A is taken straight from https://www.shadertoy.com/view/XstXR2", "tags": ["blur", "pixel", "scatter", "serenity"], "likes": 4, "viewed": 446, "published": 3, "date": "1629573141", "time_retrieved": "2024-07-30T19:05:27.865154", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixCo = ivec2(fragCoord.xy);\n    int s = 8;\n    int a = pixCo.x>>1,\n        b = pixCo.y>>1,\n        c = ((pixCo.x) + (pixCo.y))&3,\n        d = ((a&1) + ((b&1)) )*s;\n    ivec2 offset = ivec2(0);\n    \n    if(c == 1){\n        offset.x = d;\n    }else if(c == 2){\n        offset.y = d;\n    }else{\n        offset.x = d;\n        offset.y = d;\n    }\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy) + ivec2(offset), 0).rgb;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535897932384626433832795\n\nconst float wave_amplitude = 0.076;\nconst float period = 2.*PI;\n\nfloat wave_phase() {\n    return iTime;\n}\n\nfloat square(vec2 st) {\n    vec2 bl = step(vec2(0.), st);       // bottom-left\n    vec2 tr = step(vec2(0.),1.0-st);   // top-right\n    return bl.x * bl.y * tr.x * tr.y;\n}\n\nvec4 frame(vec2 st) {\n    float tushka = square(st*mat2((1./.48), 0., 0., (1./.69)));\n    \n    mat2 sector_mat = mat2(1./.16, 0., 0., 1./.22);\n    float sectors[4];\n    sectors[0] = square(st * sector_mat + (1./.16)*vec2(0.000,-0.280));\n    sectors[1] = square(st * sector_mat + (1./.16)*vec2(0.000,-0.060));\n    sectors[2] = square(st * sector_mat + (1./.16)*vec2(-0.240,-0.280));\n    sectors[3] = square(st * sector_mat + (1./.16)*vec2(-0.240,-0.060));\n    vec3 sector_colors[4];\n    sector_colors[0] = vec3(0.941, 0.439, 0.404) * sectors[0];\n    sector_colors[1] = vec3(0.435, 0.682, 0.843) * sectors[1];\n    sector_colors[2] = vec3(0.659, 0.808, 0.506) * sectors[2];\n    sector_colors[3] = vec3(0.996, 0.859, 0.114) * sectors[3];\n    \n    return vec4(vec3(sector_colors[0] + sector_colors[1] +\n                     sector_colors[2] + sector_colors[3]), tushka);\n}\n\nvec4 trail_piece(vec2 st, vec2 index, float scale) {\n    scale = index.x * 0.082 + 0.452;\n    \n    vec3 color;\n    if (index.y > 0.9 && index.y < 2.1 ) {\n        color = vec3(0.435, 0.682, 0.843);\n        scale *= .8;\n    } else if (index.y > 3.9 && index.y < 5.1) {\n        color = vec3(0.941, 0.439, 0.404);\n        scale *= .8;\n    } else {\n        color = vec3(0., 0., 0.);\n    }\n    \n    float scale1 = 1./scale;\n    float shift = - (1.-scale) / (2. * scale);\n    vec2 st2 = vec2(vec3(st, 1.) * mat3(scale1, 0., shift, 0., scale1, shift, 0., 0., 1.));\n    float mask = square(st2);\n\n    return vec4( color, mask );\n}\n\nvec4 trail(vec2 st) {\n    // actually 1/width, 1/height\n    const float piece_height = 7. / .69;\n    const float piece_width = 6. / .54;\n  \n    // make distance between smaller segments slightly lower\n    st.x = 1.2760 * pow(st.x, 3.0) - 1.4624 * st.x*st.x + 1.4154 * st.x;\n    \n    float x_at_cell = floor(st.x*piece_width)/piece_width;\n    float x_at_cell_center = x_at_cell + 0.016;\n    float incline = cos(0.5*period + wave_phase()) * wave_amplitude;\n    \n    float offset = sin(x_at_cell_center*period + wave_phase())* wave_amplitude + \n        incline*(st.x-x_at_cell)*5.452;\n    \n    float mask = step(offset, st.y) * (1.-step(.69+offset, st.y)) * step(0., st.x);\n    \n    vec2 cell_coord = vec2((st.x - x_at_cell) * piece_width,\n                           fract((st.y-offset) * piece_height));\n    vec2 cell_index = vec2(x_at_cell * piece_width, \n                           floor((st.y-offset) * piece_height));\n    \n    vec4 pieces = trail_piece(cell_coord, cell_index, 0.752);\n    \n    return vec4(vec3(pieces), pieces.a * mask);\n}\n\nvec4 logo(vec2 st) {\n    if (st.x <= .54) {\n        return trail(st);\n    } else {\n        vec2 st2 = st + vec2(0., -sin(st.x*period + wave_phase())*wave_amplitude);\n        return frame(st2 + vec2(-.54, 0));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    st += vec2(.0);\n    st *= 1.472;\n    st += vec2(-0.7,-0.68);\n    float rot = PI*-0.124;\n    st *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));\n    vec3 color = vec3(1.);\n    \n    vec4 logo_ = logo(st);    \n    fragColor = mix(vec4(0.,.5,.5,1.000), logo_, logo_.a);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 525]]}
{"id": "7sc3Dr", "name": "easing cheat sheet", "author": "yasuo", "description": "easing cheat sheet", "tags": ["easing"], "likes": 19, "viewed": 608, "published": 3, "date": "1629557432", "time_retrieved": "2024-07-30T19:05:28.910359", "image_code": "#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n#define S(p,d,b) smoothstep(fwidth(uv.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\n// easing functions:https://github.com/glslify/glsl-easings\nfloat linear(float t) {\n  return t;\n}\n\nfloat backInOut(float t) {\n  float f = t < 0.5\n    ? 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n\n  float g = pow(f, 3.0) - f * sin(f * PI);\n\n  return t < 0.5\n    ? 0.5 * g\n    : 0.5 * (1.0 - g) + 0.5;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n  \nfloat quarticInOut(float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat qinticInOut(float t) {\n  return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\n\nvec3 testGraphic(vec2 uv, vec3 col, float ease, float y){\n    float r = 0.03;\n    \n    vec2 pos = vec2(0.0,y);\n    float d = B(uv+pos,vec2(2.0,0.001));\n    col = mix(col,vec3(0.2),S(uv,d,0.0));    \n    \n    pos = vec2(0.0,y);\n    d = B(uv+pos,vec2(ease,0.001));\n    col = mix(col,vec3(0.8),S(uv,d,0.0));    \n    \n    pos = vec2(ease,y);\n    d = length(uv+pos)-r;\n    col = mix(col,vec3(1),S(uv,d,0.0));    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    float endTime = 4.0;\n    float t = mod(iTime,endTime);\n    float dist = 1.4;\n    float end = dist;\n    float time = t;\n    float start = -(dist*0.5);\n    if(t>=1.0 && t<2.0){\n        time = 1.0;\n    }\n    if(t>=2.0 && t<3.0){\n        end = -dist;\n        time = 1.0-(3.0-t);\n        start = dist*0.5;\n    }\n    if(t>=3.0){\n        end = -dist;\n        time = 1.0;\n        start = dist*0.5;\n    }\n    \n    // backInOut\n    float ease = start+backInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.4);\n    \n    // cubicInOut\n    ease = start+cubicInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.32);   \n    \n    // quarticInOut\n    ease = start+quarticInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.24);     \n        \n    // exponentialInOut\n    ease = start+exponentialInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.16);   \n            \n    // sineInOut\n    ease = start+sineInOut(time)*end;\n    col = testGraphic(uv,col,ease,-0.08);  \n                \n    // elasticInOut\n    ease = start+elasticInOut(time)*end;\n    col = testGraphic(uv,col,ease,0.0);  \n                    \n    // quadraticInOut\n    ease = start+quadraticInOut(time)*end;\n    col = testGraphic(uv,col,ease,0.08); \n                        \n    // qinticInOut\n    ease = start+qinticInOut(time)*end;\n    col = testGraphic(uv,col,ease,0.16); \n                            \n    // circularInOut\n    ease = start+circularInOut(time)*end;\n    col = testGraphic(uv,col,ease,0.24);\n                            \n    // bounceOut\n    ease = start+bounceOut(time)*end;\n    col = testGraphic(uv,col,ease,0.32);    \n                                \n    // linear\n    ease = start+linear(time)*end;\n    col = testGraphic(uv,col,ease,0.4);  \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 219, 242, 242, 256], [258, 258, 284, 284, 454], [456, 456, 483, 483, 567], [571, 571, 600, 600, 682], [684, 684, 717, 717, 864], [866, 866, 892, 892, 931], [933, 933, 962, 962, 1161], [1163, 1163, 1194, 1194, 1266], [1268, 1268, 1296, 1296, 1385], [1387, 1387, 1417, 1417, 1541], [1543, 1543, 1569, 1569, 1963], [1966, 1966, 2023, 2023, 2395], [2397, 2397, 2454, 2454, 4329]]}
{"id": "ssc3Dr", "name": "Buffer Sample Test", "author": "Lazar_Andrei", "description": "Sample from bufferA test", "tags": ["texture", "buffer"], "likes": 2, "viewed": 204, "published": 3, "date": "1629557359", "time_retrieved": "2024-07-30T19:05:29.788013", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 channelAColor = texture(iChannel0, uv);\n    vec4 textureBColor = texture(iChannel1, uv);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime * 2.0+uv.xyx+vec3(0,2,4));\n\n    float lerpFactor = (sin(iTime * 5.0) + 1.0) * 0.5;\n    // Output to screen\n    fragColor = mix(channelAColor, textureBColor, lerpFactor) * vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssc3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 451]]}
{"id": "ssc3Wr", "name": "nyooooooom", "author": "HaleyHalcyon", "description": "a", "tags": ["a"], "likes": 13, "viewed": 454, "published": 3, "date": "1629550170", "time_retrieved": "2024-07-30T19:05:30.651703", "image_code": "#define PI (3.14159265358979)\n\n// gives pure saturated color from input [0, 6) for phase\nvec3 hue(float x) {\n    x = mod(x, 6.);\n    return clamp(vec3(\n        abs(x - 3.) - 1.,\n        -abs(x - 2.) + 2.,\n        -abs(x - 4.) + 2.\n    ), 0., 1.);\n}\n\n// does pseudo overexposure filter\nvec3 deepfry(vec3 rgb, float x) {\n    rgb *= x;\n    return rgb + vec3(\n      max(0., rgb.g - 1.) + max(0., rgb.b - 1.),\n      max(0., rgb.b - 1.) + max(0., rgb.r - 1.),\n      max(0., rgb.r - 1.) + max(0., rgb.g - 1.)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod(iTime, 6.);\n    // Scales coords so that the diagonals are all dist 1 from center\n    float scale = length(iResolution.xy);\n    vec2 uv = (fragCoord / scale\n\t- (iResolution.xy / scale / 2.)) * 2.;\n    \n    // for wormhole or perspective effect\n    float r = (log(uv.x*uv.x+uv.y*uv.y) + length(uv) * -1.6) * (1.0 + 0.4 * sin(time * PI / 3.));\n    float theta = atan(uv.y, uv.x);\n    \n    \n    // if you want the angle in range [0, 1) and not (-, ]\n    // divide angle by 2pi and mod1 it\n    // float theta = fract(atan(uv.y, uv.x) / 6.2831853071795);\n\n    // Time varying pixel color\n    vec3 col = deepfry(\n        hue(r * -3. + theta * 6. / PI + time * 3.),\n        1. + 0.5 * sin(r * 1.8 + theta * 1.0 + time * -2. * PI)\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssc3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 89, 108, 108, 248], [250, 285, 318, 318, 510], [512, 512, 569, 569, 1382]]}
{"id": "sstGRM", "name": "2 x Gyroid ", "author": "Tater", "description": "easeOutElastic is a new favorite. ", "tags": ["3d", "raymarching", "gyroid", "rubiks"], "likes": 24, "viewed": 640, "published": 3, "date": "1629527522", "time_retrieved": "2024-07-30T19:05:31.500434", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define on(a,x) (abs(a)-(x))\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)*0.5*(x))\n#define STEPS 128.0\n#define MDIST 150.0\nvec3 glow;\nfloat gyr(vec3 p){\n    return dot(sin(p),cos(p.yzx));\n}\nfloat rand(float a){\n    return fract(sin(a*4131.22)*94935.34);\n}\n\n//iq stuff\nfloat smin(float d1, float d2, float k){\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\nfloat box(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat frame( vec3 p, vec3 b, float e ){\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n//end iq stuff\n\nvec3 rubik(vec3 p, float t, float id){\n    float rt = floor(rand(id)*3.0);\n    float s = sign(rand(id*100.0)-0.5);\n    float s2 = sign(rand(id*200.0)-0.5);\n    if(rt == 0.0){\n    p.xy*=rot(s*step(s2*p.z,0.0)*t*pi/2.0);\n    }\n    if(rt == 1.0){\n    p.yz*=rot(s*step(s2*p.x,0.0)*t*pi/2.0);\n    }\n    if(rt == 2.0){\n    p.zx*=rot(s*step(s2*p.y,0.0)*t*pi/2.0);\n    }\n    return p;\n}\n\nfloat easeOutElastic(float x) {\n    float c4 = (2. * pi) / 3.;\n    return x = pow(1.5,-10.*x) * sin((x*5.5-.75)*c4)+1.;\n}\n\nvec2 map(vec3 p){\n    vec3 po = p;\n    float tt = iTime*pi/3.0;\n    float t = easeOutElastic(fract(tt))+floor(tt);\n    \n    p.xy*=rot(t*0.6);\n    p.yz*=rot(t*0.6);\n    p.zx*=rot(t*0.6);\n    p.y+=t*2.0;\n    \n    vec2 a = vec2(1.0);\n    a.x = on(on(gyr(p*2.0)/2.0,0.1),0.3+(sin(t)*0.5+0.5)*0.2);\n    \n    p = po;\n    p = rubik(p,t,floor(tt));\n\n    p = abs(p)-3.1-abs(asin(sin(t*pi*0.25)))*2.;\n    float clipBox = box(p,vec3(3));\n    \n    a.x = smin(-clipBox,a.x,0.3);\n    glow+=mix(vec3(0.639,0.180,0.318),vec3(0.412,0.180,0.639),sin(length(p)*3.0)*0.5+0.5)\n    *1./(1.+a.x*a.x);\n    \n    float fr = frame(p,vec3(3.1),0.2);\n\n    vec2 b = vec2(fr,2);\n    a.x = -a.x;\n    \n    a=(a.x<b.x)?a:b;\n    \n    //anti artifact fuckery\n    p = po;\n    p = abs(p)-3.1;\n    float domBox = box(p-2.2,vec3(6.0));\n    float outBox = box(po,vec3(8.25));\n    domBox = max(outBox,-domBox);\n    a.x = min(domBox,a.x);\n    \n    return a;  \n}\nvec3 norm(vec3 p){\n    vec2 e= vec2(0.05,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,11,20);\n    ro.xz*=rot(iTime*pi/6.0);\n    \n    vec3 lk = vec3(0,-2,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*0.65+uv.x*r+uv.y*cross(f,r);\n    \n    vec3 p = ro;\n    float shad, dO;\n    vec2 d;\n    bool hit = false;\n    \n    for(float i = 0.; i <STEPS; i++){\n        d = map(p);\n        if(abs(d.x)<0.001){ \n            hit = true; \n            shad = i/STEPS;\n            break;\n        }\n        if(d.x>MDIST) {dO = MDIST;break;}\n        dO+=d.x*0.8;\n        p =ro+rd*dO;\n    }\n    if(hit){\n        vec3 n = norm(p);\n        //vec3 r = reflect(rd, n);\n        float ao = smoothstep(-.1,.1,map(p+n*.1).x)*smoothstep(-.2,.2,map(p+n*.2).x);\n        //ao*=ao;\n        \n        col = 1.0-(n*0.5+0.5);\n        if(d.y == 2.0) col *=0.2;\n        //col*=pow(1.0-shad,3.0);\n        \n        //fabe ibl from blackle\n        float diff = length(sin(n*3.0)*.4+.6)/sqrt(3.);\n        col=col*diff*vec3(0.996,0.784,0.784);\n        col*=ao;\n    }\n    col = mix(col,vec3(0.145,0.067,0.435),(dO/(MDIST)));\n        col = pow(col,vec3(0.7));\n\n    col*=(1.0-length(uv*uv));\n    col+=glow*0.02;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstGRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 209, 209, 246], [247, 247, 267, 267, 312], [314, 325, 365, 365, 441], [442, 442, 468, 468, 555], [556, 556, 595, 595, 875], [892, 892, 930, 930, 1270], [1272, 1272, 1303, 1303, 1393], [1395, 1395, 1412, 1412, 2313], [2314, 2314, 2332, 2332, 2458], [2459, 2459, 2516, 2516, 3781]]}
{"id": "sd3Gz7", "name": "Blur primitives", "author": "miyaokamarina", "description": "A collection of simple blur passes.", "tags": ["blur", "boxblur", "gaussianblur", "kawase"], "likes": 9, "viewed": 453, "published": 3, "date": "1629515412", "time_retrieved": "2024-07-30T19:05:32.539656", "image_code": "// Blur strength.\n// Actual blur radius may vary depending on blur type.\n#define r 20.0\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    vec2 uv = pos / res;\n\n    col = texture(tex, pos);\n\n    col =    ubox09(tex, uv, res, r);    // classical box            :: flat 33 kernel\n    col =  kawase04(tex, uv, res, r);    // kawase kernel            :: corners only\n    col =  kawase05(tex, uv, res, r);    // dual kawase downsampling :: corners + center\n    col =  kawase08(tex, uv, res, r);    // dual kawase upsampling   :: diamond-like\n    col =    uhex07(tex, uv, res, r);    // uniform hexagon          :: like box, but a hexagon\n    col =    ghex07(tex, uv, res, r);    // gaussian hexagon         :: like hex, but with non-linear coefficients\n    col =    uhex13(tex, uv, res, r);    // uniform double hexagon   :: like hex, but applied twice at different scales\n    col =    ghex13(tex, uv, res, r);    // gaussian double hexagon  :: like hex-13, but with non-linear coefficients\n    col = urandomxx(tex, uv, res, r, 4); // random blur\n    col = grandomxx(tex, uv, res, r, 4); // gaussian random\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI      3.141592653589793\n#define PI2     6.283185307179586\n#define SQRT2   1.414213562373095\n#define SQRT22  0.707106781186548\n#define SQRT3   1.732050807568877\n#define SQRT32  0.866025403784439\n#define FLT_MAX 3.40282346600e+38\n\n#define rand  random(state)                        // uniform random float [0, 1]\n#define urand (vec2(rand - 0.5, rand - 0.5) * 2.0) // uniform random vec2 [-1, +1]\n#define grand bmt(vec2(rand, rand))                // gaussian random vec2 [-1, +1]\n#define crand crandom(state)                       // random within a unit circle\n\nvec4 upick(sampler2D tex, vec2 pos, vec2 res, vec2 o, float r);\nvec4 gpick(sampler2D tex, vec2 pos, vec2 res, vec2 o, float r, inout float s);\n\nvec2 bmt(vec2 u);\n\nfloat next(float state);\nfloat seed(vec2 pos);\nfloat random(inout float state);\nvec2  crandom(inout float state);\n\nvec4 ubox09(sampler2D tex, vec2 uv, vec2 res, float r) {\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(-1, -1), r);\n    col += upick(tex, uv, res, vec2(-1, 0.), r);\n    col += upick(tex, uv, res, vec2(-1, +1), r);\n    col += upick(tex, uv, res, vec2(0., -1), r);\n    col += upick(tex, uv, res, vec2(0., 0.), r);\n    col += upick(tex, uv, res, vec2(0., +1), r);\n    col += upick(tex, uv, res, vec2(+1, -1), r);\n    col += upick(tex, uv, res, vec2(+1, 0.), r);\n    col += upick(tex, uv, res, vec2(+1, +1), r);\n\n    return col / 9.0;\n}\n\nvec4 kawase04(sampler2D tex, vec2 uv, vec2 res, float r) {\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(-1, -1), r);\n    col += upick(tex, uv, res, vec2(-1, +1), r);\n    col += upick(tex, uv, res, vec2(+1, -1), r);\n    col += upick(tex, uv, res, vec2(+1, +1), r);\n\n    return col / 4.0;\n}\n\nvec4 kawase05(sampler2D tex, vec2 uv, vec2 res, float r) {\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(0., 0.), r) * 4.0;\n    col += upick(tex, uv, res, vec2(-1, -1), r);\n    col += upick(tex, uv, res, vec2(-1, +1), r);\n    col += upick(tex, uv, res, vec2(+1, -1), r);\n    col += upick(tex, uv, res, vec2(+1, +1), r);\n\n    return col / 8.0;\n}\n\nvec4 kawase08(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float u = 0.5;\n\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(0., +1), r);\n    col += upick(tex, uv, res, vec2(-1, 0.), r);\n    col += upick(tex, uv, res, vec2(+1, 0.), r);\n    col += upick(tex, uv, res, vec2(0., -1), r);\n\n    col += upick(tex, uv, res, vec2(-u, -u), r) * 2.0;\n    col += upick(tex, uv, res, vec2(-u, +u), r) * 2.0;\n    col += upick(tex, uv, res, vec2(+u, -u), r) * 2.0;\n    col += upick(tex, uv, res, vec2(+u, +u), r) * 2.0;\n\n    return col / 12.0;\n}\n\nvec4 uhex07(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float u = 0.5;\n    float v = SQRT32;\n\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(+u, +v), r);\n    col += upick(tex, uv, res, vec2(+1, 0.), r);\n    col += upick(tex, uv, res, vec2(+u, -v), r);\n    col += upick(tex, uv, res, vec2(0., 0.), r);\n    col += upick(tex, uv, res, vec2(-u, -v), r);\n    col += upick(tex, uv, res, vec2(-1, 0.), r);\n    col += upick(tex, uv, res, vec2(-u, +v), r);\n\n    return col / 7.0;\n}\n\nvec4 ghex07(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float s;\n\n    float u = 0.5;\n    float v = SQRT32;\n\n    vec4 col;\n\n    col += gpick(tex, uv, res, vec2(+u, +v), r, s);\n    col += gpick(tex, uv, res, vec2(+1, 0.), r, s);\n    col += gpick(tex, uv, res, vec2(+u, -v), r, s);\n    col += gpick(tex, uv, res, vec2(0., 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-u, -v), r, s);\n    col += gpick(tex, uv, res, vec2(-1, 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-u, +v), r, s);\n\n    return col / s;\n}\n\nvec4 uhex13(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float u = 0.5;\n    float v = SQRT32;\n\n    float w = SQRT2 / (1.0 + SQRT3);\n    float x = w * 0.5;\n    float y = w * SQRT32;\n\n    vec4 col;\n\n    col += upick(tex, uv, res, vec2(+u, +v), r);\n    col += upick(tex, uv, res, vec2(+1, 0.), r);\n    col += upick(tex, uv, res, vec2(+u, -v), r);\n    col += upick(tex, uv, res, vec2(0., 0.), r);\n    col += upick(tex, uv, res, vec2(-u, -v), r);\n    col += upick(tex, uv, res, vec2(-1, 0.), r);\n    col += upick(tex, uv, res, vec2(-u, +v), r);\n\n    col += upick(tex, uv, res, vec2(+y, +x), r);\n    col += upick(tex, uv, res, vec2(0., +u), r);\n    col += upick(tex, uv, res, vec2(+y, -x), r);\n    col += upick(tex, uv, res, vec2(0., 0.), r);\n    col += upick(tex, uv, res, vec2(-y, -x), r);\n    col += upick(tex, uv, res, vec2(0., -u), r);\n    col += upick(tex, uv, res, vec2(-y, +x), r);\n\n    return col / 14.0;\n}\n\nvec4 ghex13(sampler2D tex, vec2 uv, vec2 res, float r) {\n    float s;\n\n    float u = 0.5;\n    float v = SQRT32;\n\n    float w = SQRT2 / (1.0 + SQRT3);\n    float x = w * 0.5;\n    float y = w * SQRT32;\n\n    vec4 col;\n\n    col += gpick(tex, uv, res, vec2(+u, +v), r, s);\n    col += gpick(tex, uv, res, vec2(+1, 0.), r, s);\n    col += gpick(tex, uv, res, vec2(+u, -v), r, s);\n    col += gpick(tex, uv, res, vec2(0., 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-u, -v), r, s);\n    col += gpick(tex, uv, res, vec2(-1, 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-u, +v), r, s);\n\n    col += gpick(tex, uv, res, vec2(+y, +x), r, s);\n    col += gpick(tex, uv, res, vec2(0., +u), r, s);\n    col += gpick(tex, uv, res, vec2(+y, -x), r, s);\n    col += gpick(tex, uv, res, vec2(0., 0.), r, s);\n    col += gpick(tex, uv, res, vec2(-y, -x), r, s);\n    col += gpick(tex, uv, res, vec2(0., -u), r, s);\n    col += gpick(tex, uv, res, vec2(-y, +x), r, s);\n\n    return col / s;\n}\n\nvec4 urandomxx(sampler2D tex, vec2 uv, vec2 res, float r, int i) {\n    float s = float(i);\n    float state = seed(uv);\n\n    vec4 col;\n\n    for (; i > 0; i--) {\n        col += upick(tex, uv, res, crand, r);\n    }\n\n    return col / s;\n}\n\nvec4 grandomxx(sampler2D tex, vec2 uv, vec2 res, float r, int i) {\n    float s;\n    float state = seed(uv);\n\n    vec4 col;\n\n    for (; i > 0; i--) {\n        col += gpick(tex, uv, res, grand, r, s);\n    }\n\n    return col / s;\n}\n\nvec4 upick(sampler2D tex, vec2 uv, vec2 res, vec2 o, float r) {\n    return texture(tex, uv + o * r / res);\n}\n\nvec4 gpick(sampler2D tex, vec2 uv, vec2 res, vec2 o, float r, inout float v) {\n    o *= r;\n\n    // https://dsp.stackexchange.com/a/74157\n    float n = r + r;\n    float s = n / 2.0;\n    float t = 2.0 * s * s;\n    float w = exp(-(o.x * o.x + o.y * o.y) / t);\n\n    v += w;\n\n    return texture(tex, uv + o / res) * w;\n}\n\nvec2 bmt(vec2 u) {\n    float r = sqrt(-2.0 * log(u.x));\n    float t = PI2 * u.y;\n\n    return clamp(vec2(r * cos(t), r * sin(t)), -1.0, +1.0);\n}\n\n#define SEED 0.2434\n\nfloat next(float state) {\n    state = (34.0 * state + 1.0) * state;\n    state = state - floor(state * 0.0034602) * 289.0;\n\n    return state;\n}\n\nfloat seed(vec2 pos) {\n    vec3  m = vec3(pos, SEED) + vec3(1.0);\n    float state;\n\n    state = next(m.x) + m.y;\n    state = next(state) + m.z;\n    state = next(state);\n\n    return state;\n}\n\nfloat random(inout float state) {\n    float r = fract(state * 0.02439);\n\n    state = next(state);\n\n    return r;\n}\n\nvec2 crandom(inout float state) {\n    float a = rand * PI2;\n    float r = sqrt(rand);\n\n    return vec2(r * cos(a), r * sin(a));\n}\n\n#define tex iChannel0\n#define res iResolution.xy\n", "buffer_a_code": "#define u     20.0 // Grid unit\n#define ul    (u * 2.0)\n#define uxl   (u * 3.0)\n#define uxxl  (u * 4.0)\n#define uxxxl (u * 5.0)\n#define us    (u / 2.0)\n\n#define crop(x1, y1, x2, y2) float(p.x > x1 && p.x < x2 && p.y > y1 && p.y < y2)\n#define rad(d) (d * 0.0174533)\n\nvec4 mix(vec4 a, vec4 b, bool c) {\n    return mix(a, b, float(c));\n}\n\nfloat mix(float a, float b, bool c) {\n    return mix(a, b, float(c));\n}\n\nvec4 alpha(vec4 b, vec4 s) {\n    float t = b.a * (1.0 - s.a);\n    float a = s.a + t;\n\n    vec3 rgb = s.rgb * s.a + b.rgb * t;\n\n    return vec4(rgb, a);\n}\n\nfloat hsluv_from_linear(float x) {\n    return x <= 0.003 ? 13.0 * x : 1.055 * pow(x, 0.416) - 0.055;\n}\n\nvec3 hsluv(float h, float s, float l) {\n    const float[6] N = float[6](\n        /* [1, 1] :: 632260 * M[2] - 126452 * M[1] */ -120846.0,\n        /* [1, 2] :: 284517 * M[0] -  94839 * M[2] */ 969398.0,\n        /* [2, 1] :: 632260 * M[5] - 126452 * M[4] */ -210946.0,\n        /* [2, 2] :: 284517 * M[3] -  94839 * M[5] */ -279707.0,\n        /* [3, 1] :: 632260 * M[8] - 126452 * M[7] */ 694074.0,\n        /* [3, 2] :: 284517 * M[6] -  94839 * M[8] */ -84414.0\n    );\n\n    float hsin = sin(h);\n    float hcos = cos(h);\n\n    float a = l + 16.0;\n    float r;\n    float g;\n    float b = a / 116.0;\n\n    float c;\n    float d;\n    float e = 769860.0 * l;\n\n    int i;\n\n    a = a * a * a / 1560896.0;  //   a is sub1\n    a = a > 0.01 ? a : l / 903.0; // a is sub2\n\n    h = 3.402823466e+38;          // h is cmax\n\n    for (; i < 6; ) {\n        r = N[i++] * a;\n        g = N[i++] * a * hcos;\n\n        c = e * a / (r * hsin - g); //                      c is length\n        h = c >= 0.0 ? min(h, c) : h; //                    h is cmax\n\n        c = e * (a - 1.0) / ((r + 126452.0) * hsin - g); // c is length\n        h = c >= 0.0 ? min(h, c) : h; //                    h is cmax\n    }\n\n    h = h / 100.0 * s / (13.0 * l); //       h is c / (13 * l)\n\n    s = hcos * h + 0.19783; //               s is varU\n    h = 1.0 / (hsin * h + 0.4683); //        h is 1 / varV\n\n    l = l <= 8.0 ? l / 903.0 : b * b * b; // l is y\n    s = 9.0 * l * h * s / 4.0; //            s is x\n    h = 3.0 * l * h - s / 3.0 - 5.0 * l; //  h is z\n\n    r = hsluv_from_linear(+3.2410 * s + -1.5373 * l + -0.4986 * h);\n    g = hsluv_from_linear(-0.9692 * s + +1.8760 * l + +0.0416 * h);\n    b = hsluv_from_linear(+0.0556 * s + -0.2040 * l + +1.0570 * h);\n\n    return vec3(r, g, b);\n}\n\nvec3 hsl(int h, float s, float l) {\n    return hsluv(rad(float(h)), s * 100.0, l * 100.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    return hsluv(rad(h * 360.0), s * 100.0, l * 100.0);\n}\n\nvec4 draw_circle(vec3 c, vec2 p, float radius) {\n    return vec4(c, 1.0) * step(length(p), radius);\n}\n\nvec4 draw_stripes(vec3 c, float o, float size, float m) {\n    return vec4(c, 1.0) * mod(floor(o / size), m);\n}\n\nvec4 draw_checkerboard(vec3 c, float o, float p, float size) {\n    return vec4(c, 1.0) * float(mod(floor(o / size), 2.0) != mod(floor(p / size), 2.0));\n}\n\nvec4 testpattern(vec2 pos) {\n    vec2 uv = pos / res;\n    vec2 c  = res / 2.0; // center coordinates\n    vec2 p  = pos - c;   // point coordinates relative to center\n\n    vec4 ne_st = draw_stripes(hsl(uv.x, uv.y, 0.5), p.x + ul, uxxl, 2.0);\n    vec4 se_st = draw_stripes(hsl(150, 1.0, 0.3),   p.y + ul, uxxl, 2.0);\n    vec4 sw_st = draw_stripes(hsl(260, 1.0, 0.4),   p.y - ul, uxxl, 2.0);\n    vec4 nw_st = draw_stripes(hsl(180, 1.0, 0.6),   p.x,      us,   2.0);\n\n    vec4 nw_d0 = draw_circle(hsl(-10, 1.0, 0.5), p - vec2(-u * 7.7, u), us * 0.9);\n    vec4 nw_d1 = draw_circle(hsl( 30, 1.0, 0.5), p - vec2(-u * 5.7, u), us * 0.9);\n    vec4 nw_d2 = draw_circle(hsl( 60, 1.0, 0.5), p - vec2(-u * 3.7, u), us * 0.9);\n    vec4 nw_d3 = draw_circle(hsl(120, 1.0, 0.5), p - vec2(-u * 1.7, u), us * 0.9);\n    vec4 nw_d4 = draw_circle(hsl(270, 1.0, 0.5), p - vec2(-u * 0.0, 0), us * 1.0);\n\n    vec4 sw_cb = draw_checkerboard(hsl(uv.x * 2.0, 1.0 - uv.y, 0.5), p.x, p.y, ul);\n\n    vec4 col;\n\n    col = vec4(0, 0, 0, 1);\n\n    col = alpha(col, nw_st * crop(   -uxxxl,     -ul,       ul,     c.y));\n    col = alpha(col, nw_st * crop(-u * 15.0, u * 6.0, -u * 6.0, u * 8.5));\n    col = alpha(col, ne_st * crop(      0.0,     0.0,      c.x,     c.y));\n    col = alpha(col, se_st * crop(       ul,    -c.y,      c.x,     0.0));\n    col = alpha(col, sw_st * crop(-u * 10.0,    -c.y,      0.0,     -ul));\n    col = alpha(col, sw_cb * crop(-c.x,         -c.y, -u * 4.0,   -uxxl));\n\n    col = alpha(col, nw_d0);\n    col = alpha(col, nw_d1);\n    col = alpha(col, nw_d2);\n    col = alpha(col, nw_d3);\n    col = alpha(col, nw_d4);\n\n    col = clamp(col, 0.0, 1.0);\n\n    return col;\n}\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    col = testpattern(pos);\n}\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3Gz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 132, 132, 1103]]}
{"id": "Nd33Dr", "name": "HSLuv", "author": "miyaokamarina", "description": "Minimal HSL implementation. Like HSL, but more uniform by L.", "tags": ["color", "hsl", "hsluv"], "likes": 3, "viewed": 251, "published": 3, "date": "1629511062", "time_retrieved": "2024-07-30T19:05:33.397363", "image_code": "#define PI2 6.283185307179586\n\nfloat hsluv_from_linear(float x) {\n    return x <= 0.003 ? 13.0 * x : 1.055 * pow(x, 0.416) - 0.055;\n}\n\nvec3 hsluv(float h, float s, float l) {\n    const float[6] N = float[6](\n        /* [1, 1] :: 632260 * M[2] - 126452 * M[1] */ -120846.0,\n        /* [1, 2] :: 284517 * M[0] -  94839 * M[2] */ 969398.0,\n        /* [2, 1] :: 632260 * M[5] - 126452 * M[4] */ -210946.0,\n        /* [2, 2] :: 284517 * M[3] -  94839 * M[5] */ -279707.0,\n        /* [3, 1] :: 632260 * M[8] - 126452 * M[7] */ 694074.0,\n        /* [3, 2] :: 284517 * M[6] -  94839 * M[8] */ -84414.0\n    );\n\n    float hsin = sin(h);\n    float hcos = cos(h);\n\n    float a = l + 16.0;\n    float r;\n    float g;\n    float b = a / 116.0;\n\n    float c;\n    float d;\n    float e = 769860.0 * l;\n\n    int i;\n\n    a = a * a * a / 1560896.0;  //   a is sub1\n    a = a > 0.01 ? a : l / 903.0; // a is sub2\n\n    h = 3.402823466e+38;          // h is cmax\n\n    for (; i < 6; ) {\n        r = N[i++] * a;\n        g = N[i++] * a * hcos;\n\n        c = e * a / (r * hsin - g); //                      c is length\n        h = c >= 0.0 ? min(h, c) : h; //                    h is cmax\n\n        c = e * (a - 1.0) / ((r + 126452.0) * hsin - g); // c is length\n        h = c >= 0.0 ? min(h, c) : h; //                    h is cmax\n    }\n\n    h = h / 100.0 * s / (13.0 * l); //       h is c / (13 * l)\n\n    s = hcos * h + 0.19783; //               s is varU\n    h = 1.0 / (hsin * h + 0.4683); //        h is 1 / varV\n\n    l = l <= 8.0 ? l / 903.0 : b * b * b; // l is y\n    s = 9.0 * l * h * s / 4.0; //            s is x\n    h = 3.0 * l * h - s / 3.0 - 5.0 * l; //  h is z\n\n    r = hsluv_from_linear(+3.2410 * s + -1.5373 * l + -0.4986 * h);\n    g = hsluv_from_linear(-0.9692 * s + +1.8760 * l + +0.0416 * h);\n    b = hsluv_from_linear(+0.0556 * s + -0.2040 * l + +1.0570 * h);\n\n    return vec3(r, g, b);\n}\n\n#define res iResolution\n\nvoid mainImage(out vec4 col, in vec2 pos) {\n    vec2 uv = pos / res.xy;\n\n    col = vec4(hsluv(uv.x * PI2, uv.y * 100.0, 50.0), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd33Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 65, 65, 133], [1904, 1904, 1947, 1947, 2036]]}
{"id": "Ndd3z7", "name": "3D Planet w/ weather & moon", "author": "Pelegefen", "description": "a little procedural planet made from FBM noise and a projected onto a sphere, with a bit of tricks thrown here and there.\nUse the Mouse to rotate around the planet!\nenjoy~!\n\nthe 2D version - https://www.shadertoy.com/view/fsd3R7", "tags": ["3d", "raymarching", "sun", "interactive", "space", "planet", "moon"], "likes": 10, "viewed": 528, "published": 3, "date": "1629498320", "time_retrieved": "2024-07-30T19:05:34.198221", "image_code": "\n\n\n\n\n\nfloat GetDist(vec3 p) {\n\n    vec3 n = p;\n    float d  = 0.;\n        p.xz *= Rot(iTime * .4);\n\n    vec2 uv1 = vec2((atan(p.z,p.x)/6.2832), 2.*p.y/13.);\n    \n\n    //d = sdSphere(p, 1.5);\n    float planet = sdSphere(p, 1.5);\n    \n    //---------displacement-----------\n    float disp = (heightMap(uv1*2.))*.2;\n    planet += disp * smoothstep(.2,.0,abs(uv1.y));\n    //--------------------------------\n    \n    d = planet;\n    float m = sdSphere(p +vec3(4.,0.,0.),.25);    \n    \n    n.xz *= Rot(iTime * .25);\n\n    float sun = sdSphere(-n +vec3(3.,0.,3.) * 20.,6.25);  \n    return min(d,min(m,sun));\n}\n\nint GetMat(vec3 p) {\n\n     vec3 n = p;\n    float d  = 0.;\n        p.xz *= Rot(iTime * .4);\n    float planet = sdSphere(p, 1.5);\n    \n    \n    d = planet;\n    float m = sdSphere(p +vec3(4.,0.,0.),.25);\n    \n    n.xz *= Rot(iTime * .25);\n\n    float sun = sdSphere(-n +vec3(3.,0.,3.) * 20.,6.25);  \n    \n    float dist = min(d,min(m,sun));\n    \n    \n    \n    if(dist == planet)\n    return 1;\n    else if(dist == m)\n    return 2;\n    else if(dist == sun)\n    return 3; else return 0;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\t\n    float dv =0.;\n    float dO=dv;\n    \n    float mat;\n    for(float i=0.; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n         mat =  float(GetMat(p));\n\n        dO += dS;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    dv = dO;\n    return vec2(dv,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec4 Planet(vec2 uv){\n\n     vec3 col;\nfloat blend = S(.43,.481,abs(uv.x));\n        float blend1 = S(0.1,.2,abs(uv.y));\n\tvec4 color = Terrain(uv*2.);\n    \n    //atmosphere winds\n    float f = min(\n    noise((uv * 1.5) - iTime * 0.1 ),\n    pattern((uv * 1.) + noise(uv * 2.5) + vec2(iTime,0.)* .15 ) \n    );\n    \n    \n\n    //clouds\n    f += pattern(uv + iTime * .1);\n    f = ((max(f * .2,noise(uv  *25. + vec2(iTime,0.))) * (color.g + color.b)/.3) +color.a)* 1.-blend-blend1;\n    f -= blend;\n    f -= blend1;\n    color = max (color, vec4(f)* 1.-blend-blend1);\n\n    return color;\n    \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    m.y = m.y*.25-1.75;\n    vec3 ro = vec3(0, 1, -5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.0,0), 1.);\n    vec3 col = vec3(0);\n    \n    vec2 d = RayMarch(ro, rd);\n\n    //bg\n    float s = S(.0,.3,abs(rd.y)+.1);\n    vec2 rot = rd.xz *Rot(iTime * .25);\n\n    vec3 stars = floor(vec3(  noise((rot) * 125.)+.1)*s) ;\n    col = stars;\n    \n    float glow = 0.;\n    \n        if(d.x<MAX_DIST)\n        {\n            vec3 p = ro + rd * d.x;\n            vec3 n = GetNormal(p);\n            vec3 r = reflect(vec3(rot,rd.z), n);\n             n.xz *= Rot(iTime * .25);\n            p.xz *= Rot(iTime * .4);\n            vec2 uv1 = vec2((atan(p.z,p.x)/6.2832), 2.*p.y/13.);\n            vec4 planet = Planet(uv1);\n\n\n            float dif = dot(n, normalize(vec3(3,0,3)))*.5+.5;\n\n\n            col *= 1.-sign((col.r+col.g+col.b)+5.);;\n            col += planet.rgb;\n            col *= pow(dif,5.);\n            int mat =  int(floor(d.y));\n\n                if(mat == 1){//planet\n\n                }else if(mat == 2){//moon\n                col = vec3(pow(dif,5.) );\n                }else if(mat == 3){//sun\n                col = vec3(.9,.8,.2 );\n\n                }\n\n\n\n        }\n        \n    col = pow(col, vec3(.4545));\t// gamma correction\n    //col = Terrain(uv).rgb;//uncomment to see 2D terrain only\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define MAX_STEPS 100.\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\nfloat Union( float d1, float d2 ) { return min(d1,d2); }\n\nfloat Sub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat Intrs( float d1, float d2 ) { return max(d1,d2); }\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n\n\treturn length(p ) - s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat hash(vec2 p)  // thanks to iq\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )// thanks to iq\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat pattern( in vec2 p )// thanks to iq\n{\n    vec2 q = vec2( noise( p + vec2(0.0,0.0) ),\n                   noise( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( noise( p + 8.0*q + vec2(1.7,9.2) ),\n                   noise( p + 8.0*q + vec2(8.3,2.8) ) );\n\n    return noise( p + 8.0*r );\n}\n\n\n\nfloat heightMap(vec2 uv){\n\n       float f = 0.0;\n       float symZone = S(.95,1.,abs(uv.x));\n\n       \tuv *= 15.0;\n        \n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv  ); uv = m*uv;\n\t\tf += 0.2500*noise( uv  ); uv = m*uv;\n\t\tf += 0.1250*noise( uv  ); uv = m*uv;\n\t\tf += 0.0625*noise( uv  ); uv = m*uv;\n        f -= symZone;\n        f = max(f,.1);\n\nreturn - f;\n\n}\n\nvec4 Terrain(vec2 uv){\n\n      vec2 ouv = uv;\n      float f = 0.0;\n      float blend = S(.43,.481,abs(ouv.x));\n      float symZone = S(.95,1.,abs(ouv.x));\n      uv *= 15.0;\n      \n      mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n        f  = 0.5000*noise( uv  ); uv = m*uv;\n        f += 0.2500*noise( uv  ); uv = m*uv;\n        f += 0.1250*noise( uv  ); uv = m*uv;\n        f += 0.0625*noise( uv  ); uv = m*uv;\n        f -= symZone ;\n         \n        \n        \n      vec4 landCol = vec4(\n       sin(f*.75)*.5+.5,\n       sin(f)   *.5+.5,\n       sin(f*.1)*.5+.5,\n       1.);\n       \n       landCol *= vec4(.4 + f,.7+ f,.1,1.);\n       \n       \n       vec4 colorLand = vec4(landCol / pow(f , S(.2,.21,f)));\n       \n       float c = S(.1,.4,f);\n       vec4 color = vec4(.05,c,.6,1.) + (f*.5); \n       \n       \n        color = max(color , colorLand);\n        \n        //poles\n        float poleMask = S(.4,.45,abs(ouv.y));\n        color += poleMask + poleMask;\n        \n        //edges symmetry\n        \n        color =clamp(color- c,vec4(0.1),vec4(1.) );\n        \n        color.a = f;\n       return clamp(color,vec4(0.),vec4(1.));\n       \n       }\n       \n       ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndd3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6, 6, 29, 29, 601], [603, 603, 623, 623, 1084], [1086, 1086, 1119, 1119, 1438], [1440, 1440, 1464, 1464, 1654], [1656, 1656, 1706, 1706, 1897], [1899, 1899, 1920, 1920, 2482], [2487, 2487, 2544, 2544, 4019]]}
{"id": "fdc3Wn", "name": "Basic SVG", "author": "jorge2017a1", "description": "test--svg-n2\n//Referencia\n///https://www.shadertoy.com/view/ldXyRn... FabriceNeyret2", "tags": ["basicsvg"], "likes": 12, "viewed": 1730, "published": 3, "date": "1629470913", "time_retrieved": "2024-07-30T19:05:35.064904", "image_code": "//Por Jorge2017a1..Jorge Flores.P.---Ago-2021-\n//Referencia\n//https://iquilezles.org/articles/distfunctions2d\n///https://www.shadertoy.com/view/ldXyRn... FabriceNeyret2\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(1.0),b,d)\n\n\nfloat d;\nfloat _x,_y;\nfloat x0,y0;\nvec2 gUV;\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\nreturn colOut;\n}\n\nvoid IniciarPath(vec2 uv)\n{   gUV=uv;\n    d=10000.0;\n}\n\n//moveto\nvoid M(float x, float y)\n{   _x = x;\n    _y = y;\n    x0 = x;\n    y0 = y;   \n}\n\n\nvec3 FinPath( vec3 colIn, vec3 colOut)\n{   colOut= DrawFig(colIn, colOut,d);\n    return colOut;\n}\n\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat circle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nvoid Z(void)\n{ d = unionSDF(d, line(gUV, vec2(_x,_y), vec2(x0,y0)) );  }\n\n//line\nvoid L(float x, float y)\n{    float d1=line(gUV, vec2(_x,_y), vec2(x,y));\n    d = unionSDF(d, d1 ); \n    _x=x;\n    _y=y;\n}\n\n\nvoid Ci(float x, float y,float r)\n{    float d1=circle(vec2(gUV.x- x,gUV.y-y),r);\n    d = unionSDF(d, d1 ); \n    _x=x;\n    _y=y;\n}\n\n//https://www.shadertoy.com/view/sdX3zN\nvec3 getBackgroundColor(vec2 uv) \n{\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(0., 0., 0.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n     vec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    uv*=0.8;\n    uv-=vec2(-0.5,-0.5);\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //vec3 col =vec3(1.0);\n    vec3 col = getBackgroundColor(uv); \n    \n     //cuarto casa\n     IniciarPath(uv );\n     M(0.2,0.5);\n     L(0.5 ,0.6);\n     L(0.5 ,0.3);\n     L(0.6 ,0.3);\n     L(0.6 ,0.12);\n     L(0.2 ,0.12);\n     Z();\n     col= FinPath(vec3(0.0,0.0,0.0), col);\n     \n     ///ventana\n     IniciarPath(uv );\n     M(0.3,0.2);\n     L(0.3 ,0.4);\n     L(0.4 ,0.4);\n     L(0.4 ,0.2);\n     Z();\n     col= FinPath(vec3(0.0,0.0,1.0), col);\n     \n     //ventana division\n     IniciarPath(uv );\n     M(0.3,0.3);\n     L(0.4 ,0.3);\n     Z();\n     col= FinPath(vec3(0.5,0.0,1.0), col);\n     \n     //pasto\n     IniciarPath(uv );\n     for(float i=0.0; i<5.0;i+=0.02)\n     {\n         M(-2.2+i,0.0);\n         L(-2.25+i,0.1);\n         col= FinPath(vec3(0.0,1.0,0.0), col);\n     }\n  \n  \n    \n     //montaa\n     IniciarPath(uv );\n     M(-0.3,0.7);\n     L(0.0 ,0.3);\n     L(0.2 ,0.6);\n     L(0.3 ,0.8);\n     L(0.4 ,0.7);\n     L(0.6 ,0.9);\n     L(0.8 ,0.7);\n     L(0.9 ,0.9);\n     L(1.0 ,0.7);\n     L(1.1 ,0.6);\n     L(1.3 ,0.9);\n     col= FinPath(vec3(1.0,0.0,0.0), col);\n     \n     //nube\n     float py=0.1*sin(iTime);\n     IniciarPath(uv );\n     Ci(0.3, 0.7+ py,0.05);\n     Ci(0.4, 0.7+ py,0.06);\n     Ci(0.35,0.72+py,0.05);\n     Ci(0.45,0.7 +py,0.05);\n     col= FinPath(vec3(0.5,0.5,1.0), col);\n     \n     \n     //arbol\n     IniciarPath(uv-vec2(0.2,-0.2) );\n     M(0.5,0.3);\n     L(0.5 ,0.4);\n     L(0.55 ,0.5);\n     M(0.5,0.4);\n     L(0.5,0.5);\n     L(0.4,0.6);\n     M(0.5,0.4);\n     L(0.5,0.6);\n     Ci(0.5, 0.6,0.05);\n     Ci(0.55, 0.55,0.05);\n     Ci(0.43, 0.6,0.04);\n     col= FinPath(vec3(0.0,0.8,0.0), col);\n     \n     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdc3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[375, 419, 466, 466, 493], [494, 494, 537, 537, 564], [565, 565, 613, 613, 641], [647, 647, 709, 709, 899], [902, 902, 959, 959, 1025], [1027, 1027, 1054, 1054, 1081], [1083, 1092, 1118, 1118, 1169], [1172, 1172, 1212, 1212, 1269], [1272, 1272, 1319, 1319, 1438], [1440, 1440, 1473, 1473, 1501], [1504, 1504, 1518, 1518, 1576], [1578, 1585, 1611, 1611, 1707], [1710, 1710, 1745, 1745, 1840], [1842, 1882, 1917, 1917, 2169], [2172, 2172, 2229, 2229, 4131]]}
{"id": "Ns3GWn", "name": "Persian carpet 2", "author": "jarble", "description": "Another random carpet generator, with an even greater variety of shapes and colors.", "tags": ["fractal", "carpet", "rug"], "likes": 3, "viewed": 268, "published": 3, "date": "1629468331", "time_retrieved": "2024-07-30T19:05:35.892691", "image_code": "\n//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//to do: drag and drop using https://www.shadertoy.com/view/WdGGWh\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5*3./2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    float t2 = floor((iTime+4.)/20.0+uv.x);\n    //vec3 random2 = hash31(1.+t2);\n    //vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    \n    \n    for(int c=0;c<3;c++){\n    float scale = c1.z;\n    float scale1 = 1.0;\n    float t3 = float(c)+t2;\n    vec3 random2 = hash31(1.+t3);\n    vec3 random3 = (hash31(2.+t3)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t3)-vec3(.5))/4.;\n    float offset = .16+random4.z*.04;\n    float scale2 = 1.+random2.x;\n        //vec3 col_prev = 0.0;\n        for(int i=0;i<3;i++)\n        {\n            vec3 col_prev = col;\n            float factor = -1.1;\n            uv = triangle_wave(uv.yx+1.5,scale)+triangle_wave(uv,scale);\n            uv.x *= factor;\n\n            uv = triangle_wave((uv+offset)/(random4.y+1.),scale+random3.x);\n            uv.x /= factor;\n            \n            uv = triangle_wave(uv+offset,scale+random3.y);\n            uv.x *= factor;\n            \n            uv = triangle_wave((uv+offset)*(random4.x+1.),scale+random3.z);\n            uv.x /= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            uv = -uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/8.;\n            if(i>0) col = (col.yzx*random2.x + col_prev*random2.y)/(random2.x+random2.y);\n            col[c] = fract((uv.x)-(uv.y));\n\n            \n\n        }\n\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3GWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 456, 478, 524, 657], [659, 659, 698, 698, 743], [745, 745, 802, 802, 2546]]}
{"id": "ssdGzM", "name": "~Conformal Woobly Torus Mapping3", "author": "FabriceNeyret2", "description": "WIP\n  Right: naive tiling of the woobly torus\n  Left: vaguely conformal mapping\nThere is no strict conformal mapping on this things.\nI just separately reparameterize the u and v as in https://shadertoy.com/view/sdd3R4\n( tuned for mid crown on top view )", "tags": ["torus", "uv", "conformal", "short"], "likes": 29, "viewed": 486, "published": 3, "date": "1629459096", "time_retrieved": "2024-07-30T19:05:36.730451", "image_code": "//variant of https://shadertoy.com/view/sdd3R4\n\nfloat  R0 = 20., R1 = 10.,                                    // large and small radii\n        k = 2., // .9                                         // tile multiplier\n        S = .4;\n  #define T 0.\n//#define T iTime\n#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )    // hue\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n#define SQR(x)  ( (x)*(x) )\n\n#define f(x)  DX * sqrt( 1. + SQR( S*6.*R1/R0*cos(6.*x+T) ) )  \\\n                 / mix( 1.,sin(6.*x+T), S );\n\nfloat intX( float a ) {                                       // --- antiderivative of large circumference\n    a = mod(a,6.2832);   // if you know a close form ( or good approx ), welcome ! :-)\n // return  2.808*a + .32  *(cos(6.*a) -1.); // fitting for S = .4, N=6  https://www.desmos.com/calculator/uepjhnpyap\n // return  1.85 *a + .129 *(cos(6.*a) -1.); //             S = .3 \n // return  1.40 *a + .057 *(cos(6.*a) -1.); //             S = .2 \n // return  1.143*a + .002 *(cos(6.*a) -1.); //             S = .1 \n // return  2.516*a + .45  *(cos(6.*a) -1.); //             S = .4, N=4 \n    float x, s = 0., DX = 0.01;  // indeed, approx above better than DX=.01\n    for( x = 0.; x < a; x += DX )\n        s += f(x);\n    return s += ( a - (x-DX) )/DX * f(x) ;                    // smooth integral\n}\n\nfloat a,b,r1,d; vec3 M;\n\nfloat map(vec3 q) {                                           // --- shape\n    q.yz *= rot( .5+6.*M.y),                                  // rotations\n    q.xz *= rot( 2.-6.*M.x),\n    a = atan(q.z,q.x),\n    b = atan(q.y,d),\n    r1 = R1* mix( 1., sin(6.*a+T) , S);\n    return min( 9., length(vec2(d=length(q.xz)-R0,q.y)) - r1 ); // abs for inside + outside\n}\n\nvec3 normal( vec3 p ) { // --- smart gradient  https://iquilezles.org/articles/normalsSDF\n    float h = 1e-4; \n    vec2 k = vec2(1,-1);\n    return normalize( k.xyy* map( p + k.xyy*h ) + \n                      k.yyx* map( p + k.yyx*h ) + \n                      k.yxy* map( p + k.yxy*h ) + \n                      k.xxx* map( p + k.xxx*h ) );\n}\n\nvoid mainImage(out vec4 O, vec2 U) {    // ===================================\n    float t=9.;\n\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 90./R, q;                                       // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1. && t > .01 ; O+=.01 )\n        t = map(p), // also set a,b,r1,d\n        p += .5*t*D;                                          // step forward = dist to obj          \n\n    O = O.x > 1. ? vec4(0.) : exp(-3.*O/4.);                  // luminance (depth + pseudo-shading )\n    if ( U.x < R.x/2. ) {                                     // left: conformal mapping\n        a = intX(a); \n        float// s = S*6.*cos(6.*a+T),\n             // r = r1/R0, //*sqrt(1.+s*s), \n                r = R1/R0,\n               ir = sqrt(1.-r*r);                   // antiderivative of 1/circonf(b) \n        b = .996*  2./ir* atan( (r-1.)/ir* tan(b/2.) );        \n     //                                NB: tan(b/2) = ( -d + sqrt(d*d+q.y*q.y) )/q.y )        \n    } \n    \n    if (O.x>0.) {\n        O = hue( mod(floor(k*R0*a/6.283),floor(k*R0*intX(-1e-5)/6.283)) \n                + 17.*mod(round(k*R1*b/6.283), floor(k*R1)) ); // colored tiles \n        a = sin(k*R0*a/2.), b = cos(k*R1*b/2.);\n        O *= sqrt( min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) );// tiles borders\n        O *= .3 + .7*max(0.,dot(normal(p),vec3(.58))); // shading\n    }\n    if (int(U)==int(R/2.) ) O++;                              // vertical separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[566, 566, 589, 672, 1366], [1393, 1393, 1412, 1467, 1749], [1751, 1751, 1774, 1840, 2092], [2094, 2094, 2130, 2172, 3760]]}
{"id": "7d3GRM", "name": "Log Spherical Map Test", "author": "byt3_m3chanic", "description": "2D  Log Spherical Map Test - link in comments, pretty good explanation and examples. I tried this once before but didn't understand tiling and the basics - so taking a second look at uses and examples to put in the toolbox.", "tags": ["2d", "truchet", "spherical", "log"], "likes": 15, "viewed": 321, "published": 3, "date": "1629455642", "time_retrieved": "2024-07-30T19:05:37.477453", "image_code": "/**\n\n    Log Spherical Mapping / Log Polar Coords\n    @byt3_m3chanic 08/20/21\n    \n    2D Version used to create the 3D ray marched\n    tile system. \n    \n    https://www.osar.fr/notes/logspherical/\n*/\n\n\n#define R\t\t\tiResolution\n#define T\t\t\tiTime\n#define M\t\t\tiMouse\n\n#define PI2\t\t\t6.28318530718\n#define PI\t\t\t3.14159265358\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nvec2 logPolar(vec2 p) {\n\tp = vec2(log(length(p)), atan(p.y, p.x));\n\treturn p;\n}\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 d = vec3(1.000,0.792,0.220);\n    return .45+.4*cos( PI2*t*vec3(.95,.97,.98)*d ); \n}\nvec3 truchet(vec2 p) {\n\n    float px = fwidth(length(p)-1.);\n    p.x+=T*.5;\n    vec2 grid = fract(p.xy)-.5;\n    vec2 id   = floor(p.xy);\n    \n    float hs = hash21(id);\n    if(hs>.5) grid.x*=-1.;\n    \n    vec3 bc = vec3(.05);\n    vec3 h = hue(length(p.x+50.)*.12); \n    h=clamp(h+.45,vec3(0),vec3(1));\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n    vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n    float circle = length(gx)-.5;\n    float l1 = .025+.065*cos(p.x*3.25);\n    float l2 = .085+.065*sin(p.x*3.25);\n    float l3 = .085+.065*sin(T+p.x*2.25);\n    float circle2 = abs(abs(circle)-l1)-(l2);\n    circle2=smoothstep(-px,px,circle2);\n    // color flip for every other one and then ones \n    // thats are flipped by the hash\n    circle=(chk>0.^^ hs>.5) ? smoothstep(-px,px,circle) : smoothstep(px,-px,circle);\n    \n    vec2 sx = abs(grid)-.5;\n    float cbx = length(sx)-.1;\n    cbx=abs(cbx)-(l3*.75);\n    cbx=smoothstep(px,-px,cbx);\n\n    h = mix(h, bc,min(circle2,circle));\n    h = mix(h, bc,cbx);\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    // make uvs - line up colors etc\n    vec2 p  =  uv-vec2(.375,0);\n    vec2 pv = (uv-vec2(0,.5))*vec2(-8,8.);\n    \n    p.xy*=rot(T*5.*PI/180.);\n    \n    //why 3.5 here?\n    p=logPolar(p)*3.5;\n    \n    vec3 col = vec3(0);\n    \n    if(uv.x>-.25) {\n        col=truchet(p);\n    } else {\n        col=truchet(pv.yx);\n    }\n    if(uv.x<-.25&&uv.x>-.26) col = vec3(.05);\n    // Output to screen\n    O  = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3GRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 343, 343, 405], [406, 406, 425, 425, 470], [472, 472, 495, 495, 551], [552, 599, 617, 617, 711], [1795, 1795, 1836, 1836, 2295]]}
{"id": "7d33zM", "name": "Marched Log Spherical", "author": "byt3_m3chanic", "description": " Log Spherical Map Test - link in comments, pretty good explanation and examples. I tried this once before but didn't understand tiling and the basics - so taking a second look at uses and examples to put in the toolbox.\n\n(mouseable)", "tags": ["2d", "raymarching", "warp", "truchet", "spherical", "polar"], "likes": 20, "viewed": 451, "published": 3, "date": "1629454571", "time_retrieved": "2024-07-30T19:05:38.240414", "image_code": "/**\n    Log Spherical Mapping / Log Polar Coords\n    @byt3_m3chanic 08/20/21\n    \n    Found this post online and started to try some of\n    it out in 2D and 3D. I hope I got this kind\n    of right.. some guessing about a few of the\n    numbers used. (mouseable)\n\n    also I need to branch out into other tile systems,\n    truchets are easy to set up - but what are other good\n    examples with square tiled grids.\n    \n    https://www.osar.fr/notes/logspherical/\n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    30.00\n#define MIN_DIST    0.001\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ \n    vec3 d = vec3(0.110,0.584,0.949);\n    return .45+.4*cos( PI2*t*vec3(.95,.97,.88)*d ); \n}\n\n//@iq cylinder\t\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nconst float sz = 2.;\nconst float hl = sz*.5;\nconst vec2 boxSize = vec2(sz*.465 ,.25);\nconst float density = 16.;\n\n//global\nvec3 hit,ghp;\nvec2 cellId,gid;\nfloat lpscale,movement;\nmat2 turn;\n\nvec2 map(vec3 q){\n    vec2 res = vec2(1e5,0.);\n\n    vec2 p = q.xz;\n    p*=turn;\n    float r = length(p);\n\tp = vec2(log(r), atan(p.y, p.x));\n\n\tp *= lpscale;\n\tfloat mul = r/lpscale;\n    p.y -= hl;\n    \n    p.x += .0 + movement;\n    \n    vec2 id = floor((p+hl)/sz) - 1.5;\n    p = mod(p+hl,sz)-hl;\n\n    vec3 lp = vec3(p.x, max(0.0, q.y/mul), p.y);\n    \n    float bx = box(lp,boxSize.xyx)-.035;\n    if(bx<res.x) {\n        res = vec2(bx*mul,2.);\n        gid = id;\n        ghp = lp;\n    }\n   \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\nvec3 truchet(vec2 vuv) {\n\n    float px = fwidth(length(vuv)/PI);\n\n    vec2 id   = cellId;\n    vec2 grid = vuv;\n    \n    float hs = hash21(id);\n    if(hs>.5) grid.x*=-1.;\n    \n    vec3 h = vec3(0); \n    vec3 bc = vec3(1);\n    \n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n    vec2 d2 = vec2(length(grid-hl), length(grid+hl));\n    vec2 gx = d2.x<d2.y? vec2(grid-hl) : vec2(grid+hl);\n\n    float circle = length(gx)-hl;\n    float circle2 = abs(abs(circle)-.125)-(.085+.065*sin(vuv.x*3.25) );\n    circle2=abs(abs(circle2)-.04)-.02;\n    circle2=smoothstep(-px,px,circle2);\n    \n    // color flip for every other one and then ones \n    // thats are flipped by the hash\n    circle=(chk>0.^^ hs>.5) ? smoothstep(-px,px,circle) : smoothstep(px,-px,circle);\n    \n    vec2 sx = abs(grid)-hl;\n    float cbx = length(sx)-.35;\n    cbx=abs(abs(cbx)-.075)-(.025+.015*sin(vuv.x*3.25));\n    cbx=smoothstep(px,-px,cbx);\n    h = mix(h, bc, min(circle2,circle));\n    h = mix(h, bc, cbx);\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // pre-cal\n    lpscale = floor(density)/PI;\n    movement = iTime*lpscale * .123;\n    turn = rot(T*5.*PI/180.);\n    //\n    \n    \n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0, 0, 8);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // mouse //\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*.5-.25)*PI;\n    mat2 rx =rot((-.75+.2*sin(T*.1))+x);\n    mat2 ry =rot((.8*sin(T*.3))+y);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    float d = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<100;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<64? ray.x*.5: ray.x;\n        m  = ray.y;\n    } \n\n    hit = ghp;\n    cellId = gid;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(0,8,.5)*lpscale;\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(view, ret), 0.), 24.);\n\n        vec3 h = vec3(.05);\n  \n        if(m==2.) h = truchet(hit.xz)* hue(cellId.x*.1);\n\n        C = h * diff + spec;\n    }\n    C = mix(vec3(.0),C,exp(-.0015*d*d*d));\n    \n    C=pow(C, vec3(.4545));\n    // Output to screen\n    O = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d33zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[680, 680, 701, 701, 763], [764, 764, 783, 783, 828], [830, 877, 895, 895, 989], [991, 1007, 1034, 1034, 1121], [1313, 1313, 1330, 1330, 1816], [1818, 1893, 1923, 1923, 2162], [3149, 3149, 3190, 3205, 4620]]}
{"id": "sdt3R7", "name": "Engine Sketches", "author": "dr2", "description": "Design drawings for \"Steam Engine No.3\" (mouseable)", "tags": ["projection", "drawing", "machine"], "likes": 32, "viewed": 433, "published": 3, "date": "1629454000", "time_retrieved": "2024-07-30T19:05:39.175913", "image_code": "// \"Engine Sketches\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\n\nvec3 qHit, pgSize, ltDir, ltDirS;\nvec2 aCs[3], crCs[3], crMid[3];\nfloat tCur, dstFar, dMiss, crRad, crLen, aRot, szFac, aPen;\nint idObj;\nbool isSh;\nconst int idWhl = 1, idSpk = 2, idCrnk = 3, idAx = 4, idPis = 5, idCrod = 6, idCyl = 7,\n   idCylEnt = 8, idValv = 9, idPipes = 10, idSup = 11, idBase = 12, idPen = 13, idFrm = 14;\nconst float pi = 3.1415927;\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat CrnkDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dz;\n  for (int k = 0; k < 3; k ++) {\n    dz = float (1 - k) * 4.;\n    q = p;\n    q.xy = Rot2Cs (q.xy, aCs[k]);\n    q.z -= dz;\n    d = min (PrRoundBoxDf (vec3 (q.x + 0.5 * crRad, q.y, abs (q.z) - 0.5),\n       vec3 (0.5 * crRad, 0.2, 0.1), 0.02), PrRoundCylDf (vec3 (abs (q.x + 0.5 * crRad) -\n       0.5 * crRad, q.y, abs (q.z) - 0.5), 0.6, 0.02, 0.1));\n    DMIN (idCrnk);\n    d = PrRoundCylDf (vec3 (q.x + crRad, q.yz), 0.3, 0.02, 0.65);\n    DMIN (idAx);\n    q = p;\n    q.z -= dz;\n    q.xy = Rot2Cs (q.xy + crMid[k], crCs[k]);\n    d = min (PrCylDf (vec3 (abs (q.y) - 0.12, q.zx), 0.15, crLen - 0.5),\n       PrCylDf (vec3 (abs (q.x) - crLen, q.yz), 0.6, 0.15));\n    DMIN (idCrod);\n    q = p;\n    q.xz -= vec2 (- (4.5 + crMid[k].x + crLen * crCs[k].x), dz);\n    d = PrCylDf (q.yzx, 0.25, 3.7);\n    DMIN (idPis);\n    d = PrCylDf ((q - vec3 (0.7, 1.7, 0.)).yzx, 0.07, 3.);\n    DMIN (idPis);\n    q.x -= 4.5;\n    d = PrRoundCylDf (q, 0.3, 0.02, 0.5);\n    DMIN (idAx);\n    d = min (min (PrCylDf ((q - vec3 (-0.8, 0., 0.)).yzx, 0.6, 0.13),\n       PrCylDf ((q - vec3 (-0.8, 0.8, 0.)).xzy, 0.08, 0.95)),\n       PrRoundCylDf (vec3 (q.xy, abs (q.z) - 0.35), 0.7, 0.02, 0.1));\n    DMIN (idCrnk);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dz;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  p.x -= 12.;\n  q = p;\n  if (! isSh) d = PrCapsDf (q.yzx, 10., 7.);\n  if (isSh || d < 0.2) {\n    p.x -= 8.;\n    q = p;\n    d = max (PrCylDf (q, 0.3, 8.2), min (0.35 - abs (mod (q.z + 2., 4.) - 2.), 6. - abs (q.z)));\n    DMIN (idAx);\n    q.xy = Rot2Cs (q.xy, aCs[0]);\n    q.z = abs (q.z) - 7.3;\n    d = min (SmoothMax (abs (length (q.xy) - 4.) - 0.2, abs (q.z) - 0.8, 0.04),\n       PrRoundCylDf (q, 0.6, 0.02, 0.8));\n    DMINQ (idWhl);\n    q.xy = Rot2D (q.xy, 2. * pi * (floor (6. * atan (q.y, - q.x) / (2. * pi) + 0.5)) / 6.);\n    d = PrRoundBoxDf (vec3 (q.x + 2.2, q.y, abs (q.z) - 0.5), vec3 (1.7, 0.15, 0.25), 0.04);\n    DMIN (idSpk);\n    dMin = CrnkDf (p, dMin);\n    q = p ;\n    q.z = mod (q.z + 2., 4.);\n    q.xz -= vec2 (-16.9, 2.);\n    d = max (PrCylDf ((q + vec3 (-3.5, 0., 0.)).yzx, 0.7, 0.2), abs (p.z) - 6.);\n    DMINQ (idCylEnt);\n    d = max (PrRoundCylDf (q.yzx, 1.5, 0.02, 3.5), abs (p.z) - 6.);\n    DMINQ (idCyl);\n    q = p;\n    q.z = mod (q.z + 2., 4.);\n    q -= vec3 (-16.9, 1.7, 2.);\n    d = max (PrRoundCylDf (q.yzx, 0.5, 0.02, 2.5), abs (p.z) - 6.);\n    DMINQ (idValv);\n    q = p;\n    q.x = abs (q.x + 16.9);\n    q.xy -= vec2 (1.5, 2.7);\n    d = min (min (max (PrCylDf ((vec3 (q.x, q.y, mod (q.z + 2., 4.) - 2.)).xzy, 0.35, 0.75),\n       abs (p.z) - 6.), PrCylDf (vec3 (q.x, q.y - 0.75, q.z), 0.35, 4.)),\n       PrSphDf (vec3 (q.x, q.y - 0.75, abs (q.z) - 4.), 0.35));\n    q = p;\n    q.xy -= vec2 (-16.9, 1.);\n    d = min (d, min (PrCylDf ((q + vec3 (-1.5, 0., 2.)).xzy, 0.35, 2.5),\n       PrCylDf ((q + vec3 (1.5, 0., -2.)).xzy, 0.35, 2.5)));\n    DMINQ (idPipes);\n    q = p;\n    q.z = abs (abs (q.z) - 4.) - 1.7;\n    d = min (PrRoundBoxDf (q + vec3 (0., 1.6, 0.), vec3 (0.48, 1.5, 0.2), 0.02),\n       PrRoundCylDf (q, 0.5, 0.02, 0.25));\n    DMINQ (idSup);\n    q = p;\n    q.yz -= vec2 (1.8, -2.3);\n    if (! isSh) d = PrSphDf (q, 1.);\n    if (isSh || d < 0.1) {\n      d = PrCylDf ((q + vec3 (0., 0.6, 0.)).xzy, 0.12, 0.8);\n      q.xz = Rot2D (q.xz, 4. * aRot);\n      q.xz = Rot2D (q.xz, 2. * pi * (floor (4. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 4.);\n      q.xy = Rot2D (q.xy, -0.25 * pi);\n      d = min (d, PrCylDf ((q + vec3 (0.4, -0.1, 0.)).yzx, 0.05, 0.4));\n      DMIN (idAx);\n      d = PrSphDf (q + vec3 (0.7, -0.1, 0.), 0.15);\n      DMIN (idPis);\n    } else dMin = min (dMin, d);\n    q = p;\n    q.xy -= vec2 (-8., -4.);\n    d = min (PrRoundBoxDf (q, vec3 (13., 1., 6.), 0.04),\n       PrRoundBoxDf (vec3 (abs (q.x + 9.) - 2., q.y - 1.5, q.z), vec3 (1., 1.4, 5.), 0.04));\n    DMINQ (idBase);\n    dMin *= szFac;\n    dMiss = min (dMiss, dMin);\n  } else dMin = min (dMin, d) * szFac;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q -= vec3 (2.5, -2.2, -6.8);\n  q.xz = Rot2D (q.xz, 0.2 * pi);\n  q.yz = Rot2D (vec2 (q.y, q.z + 4.5), 0.035 * pi + aPen) - vec2 (0., 4.5);\n  d = PrRoundCylDf (q, 0.33, 0.02, 5.);\n  d = max (d, - dot (vec2 (q.z, dot (q.xy, cos (2. * pi * floor (16. * (atan (q.y, - q.x) / (2. * pi) +\n     0.5) + 0.5) / 16. + vec2 (0., 0.5 * pi)))), sin (-0.4 * pi + vec2 (0.5 * pi, 0.))) - 1.6);\n  DMINQ (idPen);\n  q = p;\n  q.yz -= vec2 (-2.6, -4.);\n  d = max (PrRoundBoxDf (q, vec3 (pgSize + vec3 (1., 0.1, 1.)), 0.03), - PrBox2Df (q.xz, pgSize.xz));\n  DMINQ (idFrm);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.xy, 1. - 0.1 * sq.x * sq.y).xzy;\n}\n\nvec2 ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, fcBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bSize;\n  } else qBlk = vec2 (0.);\n  return qBlk;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 ObjCol (inout vec3 vn)\n{\n  vec4 col4;\n  vec3 rg;\n  float a, s;\n  bool fxz;\n  if (idObj == idBase) {\n    col4 = vec4 (0.7, 0.8, 0.4, 0.1);\n    if (abs (vn.y) < 0.01) {\n      rg = qHit;\n      rg.y += 0.5;\n      fxz = (abs (vn.x) > 0.99);\n      rg = ShGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.), 1);\n      col4 *= rg.y;\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n    } else {\n      rg = ShGrid (qHit.xz, vec2 (1.), 0);\n      col4 *= rg.y;\n      if (vn.y > 0.99) {\n        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n        else vn.yx = Rot2D (vn.yx, rg.x);\n      }\n    }\n  } else if (idObj == idCyl) {\n    col4 = vec4 (0.8, 0.5, 0.2, 0.2);\n    a = atan (qHit.z, - qHit.y) / (2. * pi);\n    if (abs (vn.x) > 0.99) {\n      col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *\n         SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));\n    } else {\n      col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));\n      a = mod (32. * a, 1.);\n      if (abs (qHit.x) < 3.3) vn.yz = Rot2D (vn.yz, 0.4 * SmoothBump (0.25, 0.75, 0.2, a) *\n         sign (a - 0.5));\n    }\n  } else if (idObj == idWhl) {\n    col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n    if (abs (vn.z) < 0.01) {\n      s = length (qHit.xy);\n      qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);\n      if (s > 4.1) {\n        s = mod (4. * qHit.z, 1.);\n        vn.z = -0.2 * SmoothBump (0.25, 0.75, 0.15, s) * sign (s - 0.5) * sign (qHit.z);\n        vn = normalize (vn);\n      }\n    }\n  } else if (idObj == idSpk) {\n    col4 = 1.1 * vec4 (0.8, 0.8, 0.85, 0.1);\n  } else if (idObj == idCrnk) {\n    col4 = vec4 (0.7, 0.7, 0.8, 0.2);\n  } else if (idObj == idAx) {\n    col4 = vec4 (0.8, 0.6, 0.2, 0.3);\n  } else if (idObj == idPis) {\n    col4 = vec4 (0.7, 0.7, 0.4, 0.3);\n  } else if (idObj == idCrod) {\n    col4 = vec4 (0.7, 0.75, 0.7, 0.3);\n  } else if (idObj == idCylEnt) {\n    col4 = vec4 (0.85, 0.5, 0.3, 0.2) * (0.5 + 0.5 * step (0.33, length (qHit.yz)));\n  } else if (idObj == idValv) {\n    col4 = vec4 (0.8, 0.5, 0.2, 0.2) * mix (1., 0.5 + 0.5 * step (0.13, length (qHit.yz)),\n       step (0., vn.x));\n  } else if (idObj == idPipes) {\n    col4 = vec4 (0.8, 0.5, 0.2, 0.2);\n  } else if (idObj == idSup) {\n    col4 = vec4 (0.8, 0.9, 0.3, 0.05);\n  }\n  return col4;\n}\n\nvoid SetConf ()\n{\n  aRot = -0.4 * 2. * pi * tCur;\n  aCs[0] = vec2 (cos (aRot), sin (aRot));\n  aCs[1] = vec2 (cos (aRot + pi * 2./3.), sin (aRot + pi * 2./3.));\n  aCs[2] = vec2 (cos (aRot + pi * 4./3.), sin (aRot + pi * 4./3.));\n  crRad = 2.;\n  crLen = 5.;\n  for (int k = 0; k < 3; k ++) {\n    crMid[k].y = -0.5 * crRad * aCs[k].y;\n    crCs[k] = vec2 (cos (asin (crMid[k].y / crLen)), crMid[k].y / crLen);\n    crMid[k].x = crLen * crCs[k].x + crRad * aCs[k].x;\n  }\n  aPen = 0.015 * pi * max (sin (pi * tCur), 0.);\n}\n\nvec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)\n{\n  vec4 col4, vn4;\n  vec3 col, vn;\n  float dstObj;\n  dMiss = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn4 = ObjNfL (ro);\n    vn = vn4.xyz;\n    col4 = ObjCol (vn);\n    col = vec3 (1., 0.98, 0.96) * pow (Maxv3 (col4.rgb), 0.7);\n    col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *\n       (0.9 + 0.2 * Noisefv2 (Rot2D (uv, 0.2 * pi) * vec2 (16., 256.))) *\n       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));\n    dMiss = dstFar;\n  } else {\n    col = vec3 (1.);\n  }\n  col = mix (col, vec3 (0.3), exp (- 64. * dMiss));\n  return clamp (col, 0., 1.);\n}\n\nvec3 SkMain (vec2 fCoord, float vp)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col;\n  vec2 uv;\n  float el, az, szFacT;\n  szFacT = szFac;\n  uv = fCoord / vec2 (5., 5.5);\n  if (vp == 0.) {\n    szFac = 0.38;\n    uv -= vec2 (-0.9, -1.1);\n    el = -0.3 * pi;\n    az = 0.1 * pi;\n  } else if (vp == 1.) {\n    szFac = 0.32;\n    uv -= vec2 (-0.4, -0.7);\n    el = -0.13 * pi;\n    az = -0.4 * pi;\n  } else if (vp == 2.) {\n    szFac = 0.4;\n    uv -= vec2 (0.3, -1.4);\n    el = -0.25 * pi;\n    az = 0.7 * pi;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -5., -20.);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  ltDirS = vuMat * normalize (vec3 (0.7, 1., -0.7));\n  col = SkShowScene (ro, rd, uv);\n  szFac = szFacT;\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitEx;\n  vec2 qBlk, q, sq;\n  float dstObj, dstExObj, sh, r;\n  int idObjEx;\n  bool isBg;\n  SetConf ();\n  szFac = 0.5;\n  pgSize = vec3 (15., 0.1, 10.);\n  isBg = false;\n  isSh = false;\n  dstExObj = ExObjRay (ro, rd);\n  idObjEx = idObj;\n  qHitEx = qHit;\n  dstObj = ObjRay (ro, rd);\n  db4 = BlkHit (ro - vec3 (0., -2.6, -4.), rd, pgSize);\n  if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n    if (dstObj < dstExObj) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      qBlk = mod (2. * ExBlkHit (ro, reflect (rd, vn)), 1.);\n      col4 = ObjCol (vn);\n    } else {\n      ro += dstExObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == idPen) {\n        r = length (qHit.xy);\n        col4 = mix (vec4 (0.9, 0.7, 0.1, 0.), vec4 (1., 0.9, 0.1, 0.01), step (0.34, r));\n        col4 = mix (vec4 (0.3, 0.3, 0.3, 0.), col4, step (0.18, r));\n        col4 = mix (vec4 (0.8, 0.4, 0.1, 0.2), col4, step (qHitEx.z, 4.5));\n      } else if (idObjEx == idFrm) {\n        col4 = vec4 (0.4, 0.5, 0.6, 0.) * (0.9 + 0.1 * Noisefv2 (32. * qHit.xz));\n      }\n    }\n  } else if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    q = ro.xz - vec2 (0., -4.);\n    if (vn.y > 0.5 && PrBox2Df (q, pgSize.xz - 0.96) < 0.) {\n      sq = sign (q);\n      col = (sq.x < 0. || sq.y < 0.) ? SkMain (q - 0.5 * sq * pgSize.xz,\n         sq.y + 1. + 0.5 * (sq.x + 1.)) : vec3 (1.);\n      if (Minv3 (col) > 0.95) {\n        q = smoothstep (0.02, 0.05, abs (mod (q + 0.5, 1.) - 0.5));\n        col = mix (vec3 (0.6, 0.8, 0.9), vec3 (1.), min (q.x, q.y));\n      }\n    } else {\n      col = vec3 (1.) * (0.8 + 0.2 * step (0.5, vn.y));\n      sh = 1.;\n    }\n  } else {\n    isBg = true;\n  }\n  if (! isBg) {\n    isSh = true;\n    sh = min (ObjSShadow (ro + 0.01 * vn, ltDir), ExObjSShadow (ro + 0.01 * vn, ltDir));\n    if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col += col4.a * vec3 (0.5) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n         SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n    } else {\n      col *= 0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.);\n    }\n  } else {\n    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);\n    col = vec3 (0.4, 0.5, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.28 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.5 * pi, -0.1 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -4.8, -40.);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -0.7));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3R7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1249, 1249, 1284, 1284, 2508], [2510, 2510, 2532, 2532, 5228], [5230, 5230, 5263, 5263, 5446], [5448, 5448, 5469, 5469, 5724], [5726, 5726, 5748, 5748, 6077], [6079, 6079, 6116, 6116, 6345], [6347, 6347, 6371, 6371, 6994], [6996, 6996, 7031, 7031, 7215], [7217, 7217, 7240, 7240, 7497], [7499, 7499, 7538, 7538, 7769], [7771, 7771, 7811, 7811, 8175], [8177, 8177, 8211, 8211, 8655], [8657, 8657, 8701, 8701, 9057], [9059, 9059, 9088, 9088, 11576], [11578, 11578, 11595, 11595, 12092], [12094, 12094, 12140, 12140, 12741], [12743, 12743, 12780, 12780, 13476], [13478, 13478, 13513, 13513, 16040], [16042, 16042, 16095, 16095, 16717], [16719, 16719, 16765, 16765, 16812], [16814, 16814, 16847, 16847, 16936], [16938, 16938, 16971, 16971, 16998], [17000, 17000, 17042, 17042, 17093], [17095, 17095, 17138, 17138, 17202], [17204, 17204, 17261, 17261, 17337], [17339, 17339, 17361, 17361, 17399], [17401, 17401, 17423, 17423, 17461], [17463, 17463, 17508, 17508, 17600], [17602, 17602, 17647, 17647, 17685], [17687, 17687, 17744, 17744, 17827], [17829, 17829, 17865, 17865, 18071], [18073, 18073, 18103, 18103, 18216], [18218, 18218, 18249, 18249, 18313], [18347, 18347, 18371, 18371, 18483], [18485, 18485, 18510, 18510, 18696]]}
{"id": "sstGzM", "name": "Chinese Ink-wash Painting I", "author": "Delincoter", "description": "I have always wanted to implement ink style rendering in a computer,this is my first attempts in 2D.", "tags": ["2d"], "likes": 49, "viewed": 1125, "published": 3, "date": "1629443127", "time_retrieved": "2024-07-30T19:05:39.947848", "image_code": "#define S smoothstep\n\n//noise funtion abstract from https://www.shadertoy.com/view/4sc3z2\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n    \n    //return normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor(p + (p.x + p.y) * K1);\n    \n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - (o - K2);\n    vec2 c = a - (1.0 - 2.0 * K2);\n    \n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n    \n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\nfloat noise_sum(vec2 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * simplex_noise(p); p = 2.0 * p;\n    f += 0.5000 * simplex_noise(p); p = 2.0 * p;\n\tf += 0.2500 * simplex_noise(p); p = 2.0 * p;\n\tf += 0.1250 * simplex_noise(p); p = 2.0 * p;\n\tf += 0.0625 * simplex_noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\n\n\nvec2 drawMountain(vec2 uv, float f, float d)\n{\n    float Side = uv.y + noise_sum(vec2(uv.x, mix(uv.y,0.,uv.y))*f)*0.1;\n    float detal = noise_sum(vec2(uv.x, uv.y)*8.)*0.005;\n    Side += detal;\n\n    float Mountain = S(0.48, 0.49, Side);\n    float fog = S(d, noise_sum(vec2(uv.x+iTime*0.06, uv.y)*0.2)*0.2, Side);\n    \n    return clamp(vec2(Side+fog, Mountain),0.,1.);\n}\n\nfloat drawSun(vec2 uv)\n{\n    vec2 u = uv;\n    u -= 0.5;\n    u.x *= iResolution.x/iResolution.y;  \n    \n    float Sun = S(0.09, 0.1, length(vec2(u.x-.5, u.y-.3)));\n    \n    float fog = S(0.7,noise_sum(vec2(uv.x+iTime*0.001, uv.y)*2.)*0.05,u.y)*1.4;\n    \n    return clamp(Sun+fog,0.,1.);\n}\n\nfloat drawBird(vec2 uv)\n{\n    uv = (uv-.5)*20.;\n    uv.x -= uv.y;\n\n    uv.y = uv.y+.45+(sin((iTime*0.5-abs(uv.x))*3.)-1.)*abs(uv.x)*0.5;\n    \n    float S1 = smoothstep(0.45,0.4,length(uv));\n    \n    uv.y += .1;\n    float S2 = smoothstep(0.5,0.45,length(uv));\n    \n    float S = S1-S2;\n    return S;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = iTime*0.5;\n    \n    vec3 c = vec3(1.);\n    \n    \n    float Sun = drawSun(uv);\n    c = mix(vec3(1.,0.2,0.0), c, Sun);  \n    \n    float Bird = drawBird(vec2(uv.x-.15,uv.y-.4));\n    c = mix(c, vec3(1.)*.65, Bird);\n    \n    uv.y -= .2;\n    uv.x += t*0.001;\n    vec2 Mountain1 = drawMountain(uv, .4, 1.);\n    c = mix(vec3(Mountain1.r), c, Mountain1.g);\n    \n    uv.y += .1;\n    uv.x += 1.;\n    uv.x += t*0.005;\n    Mountain1 = drawMountain(uv, .3, .8);\n    c = mix(vec3(Mountain1.r), c, Mountain1.g);\n    \n    uv.y += .1;\n    uv.x += 2.42;\n    uv.x += t*0.01;\n    Mountain1 = drawMountain(uv, .2, 0.6);\n    c = mix(vec3(Mountain1.r), c, Mountain1.g);\n    \n    uv.y += .1;\n    uv.x += 12.84;\n    uv.x += t*0.05;\n    Mountain1 = drawMountain(uv, .2, 0.4);\n    c = mix(vec3(Mountain1.r)-0.01, c, Mountain1.g);\n \n       \n    vec3 col = vec3(c);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstGzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 90, 111, 111, 309], [311, 311, 340, 340, 884], [886, 886, 911, 911, 1204], [1208, 1208, 1254, 1254, 1577], [1579, 1579, 1603, 1603, 1866], [1868, 1868, 1893, 1893, 2168], [2170, 2170, 2227, 2227, 3156]]}
{"id": "Ndt3z7", "name": "spinning...cirles?", "author": "watershed", "description": "rotating circles domain warped via fbm(cellular_noise(st))", "tags": ["noise", "rotation", "domainwarp"], "likes": 7, "viewed": 294, "published": 3, "date": "1629415986", "time_retrieved": "2024-07-30T19:05:40.694852", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n#define PI 3.141592653589793\n#define HALF_PI 1.5707963267948966\n\nfloat circle(in vec2 st, in vec2 center, float r, float smoothing_factor){\n    return 1.0-smoothstep(r-smoothing_factor, r+smoothing_factor, distance(st, center)); //*sin(atan(st.y,st.x))); //*TWO_PI*6.)+smoothstep(0.,1.,fract(st.x))));\n}\n\nfloat rand(float x){\n    return fract(sin(12.59585855*PI*x)+4102200.398383);\n}\n\nfloat circle_outline(in vec2 st, in vec2 center, float r, float stroke_weight){\n    float d = distance(st, center);\n    return smoothstep(fwidth(d), 0.0, abs(d-r));\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n\n//below fuctions from https://github.com/ashima/webgl-noise via Patricio Gonzalez\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n// vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\t\n\n\nfloat fbm(vec2 x)\n{    \n    float G = 0.5; //exp2(-H);\n    float freq = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*snoise(freq*x);\n        freq = pow(2.0, float(i));\n        // f += 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\nfloat map(float x, float oldMin, float oldMax, float newMin, float newMax){\n    return (newMax-newMin) - (x-oldMin)/(oldMax-oldMin) + newMin;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 scale(float _scale){ //overload for scalar \n    return mat2(_scale,0.0,\n                0.0,_scale);\n}\n\nfloat spinning_cirlces_illusion(vec2 st, float time_scale, float offset){\n    vec2 center = vec2(.5); //translate to center of screen (assumes normalized st coords)\n    st -= center; //translate coords - remember origin in in the btm left\n    st = rotate2d((offset)) * st; //rotate\n    float circle = circle_outline(st, vec2(0), 0.25, 0.005); //circle centered at 0,0 since already translated\n    st += center; //untranslate coords \n\n    int t = 12;\n    for(int i=0; i<12; i++){\n        float r = 0.25;\n        // st = scale(1.5)*st;\n        vec2 new_center = vec2(r*cos(float(i)*TWO_PI/18.), r*sin(float(i)*TWO_PI/18.)); //relative to translated coord sys (dividing with numbers with various common factors leads to more symmetric or chaotic ring resonance)\n        st -= center; //translate coords - remember origin in in the btm left\n        st = rotate2d(iTime*time_scale) * st; //rotate\n        // circle += plot(st, r);\n        \n        circle += circle_outline(st, new_center, 0.25, 0.005); //circle centered at 0,0 since already translated\n        st += center; //untranslate coords \n    }\n\n    return circle;\n}\n\nfloat spinning_cirlces_illusion(vec2 st, float time_scale, float offset, float smoothing_factor){\n    vec2 center = vec2(.5); //translate to center of screen (assumes normalized st coords)\n    st -= center; //translate coords - remember origin in in the btm left\n    st = rotate2d((offset)) * st; //rotate\n    // float circle = (0.);\n    float circle = circle_outline(st, vec2(0), 0.25, 0.005); //circle centered at 0,0 since already translated\n    st += center; //untranslate coords \n\n    int t = 12;\n    for(int i=0; i<12; i++){\n        float r = 0.25;\n        // st = scale(1.5)*st;\n        vec2 new_center = vec2(r*cos(float(i)*TWO_PI/18.), r*sin(float(i)*TWO_PI/18.)); //relative to translated coord sys (dividing with numbers with various common factors leads to more symmetric or chaotic ring resonance)\n        st -= center; //translate coords - remember origin in in the btm left\n        st = rotate2d(iTime*time_scale) * st; //rotate\n        // circle += plot(st, r);\n        vec2 travelling_center = vec2(0);\n\n\n        circle += circle_outline(st, new_center, 0.25, smoothing_factor); //circle centered at 0,0 since already translated\n        st += center; //untranslate coords \n    }\n\n    return circle;\n}\n\nvec2 random2(vec2 st){ //generate 2d random values (i.e. a random gradient in 2d)\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return fract(sin(st)*43758.5453123);\n}\n\nfloat cellular_noise(vec2 st, float scale){\n    st *= scale;\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    float m_dist = 100.;\n    //loop through neighboring cells to check points\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n            //find the neighbor\n            vec2 neighbor = vec2(float(i), float(j));\n            //random (deterministicallly) point\n            vec2 point = random2(i_st+neighbor);\n            // point = 0.5 + 0.5*sin(u_time + 6.2831*point); //animate\n            //vector from pixel to point \n            vec2 diff = neighbor + point - f_st;\n            //dist \n            float dist = length(diff);\n            //keep closer distance \n            m_dist=min(m_dist, dist);\n        }\n    }\n    return m_dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 st = fragCoord.xy/iResolution.xy;   \n    vec2 xy=st;\n    \n    float s = 2.0;\n    st = scale(s) * st;\n    st = fract(st);\n    \n    \n\n\n    // float warp = fbm(xy*cellular_noise(st, 5.));\n    vec2 warp = rotate2d((0.3*fbm(xy*cellular_noise(st, 5.)))) * st; //rotate\n    float circle = (circle(warp, vec2(0.5), 0.25, .035) + circle_outline(warp, vec2(0.5)+vec2(0.25,0), 0.25, 0.05));\n\n    vec3 color = vec3(0);\n\n    // color += circle;\n    color += spinning_cirlces_illusion(st, 0.15,  fbm(xy*cellular_noise(st, 5.)*sin(iTime)), 0.005);\n\n    fragColor = vec4(color, 1.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3z7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 214, 214, 378], [380, 380, 400, 400, 458], [460, 460, 539, 539, 626], [628, 628, 651, 651, 723], [809, 809, 830, 830, 877], [878, 878, 899, 899, 946], [947, 947, 969, 969, 1004], [1072, 1072, 1094, 1147, 2844], [2849, 2849, 2868, 2868, 3123], [3126, 3126, 3201, 3201, 3269], [3271, 3271, 3299, 3299, 3385], [3387, 3387, 3411, 3411, 3474], [3476, 3476, 3501, 3524, 3583], [3585, 3585, 3658, 3658, 4704], [4706, 4706, 4803, 4803, 5923], [5925, 5925, 5947, 6006, 6134], [6136, 6136, 6179, 6179, 6907], [6910, 6910, 6967, 6967, 7547]]}
{"id": "NddGz7", "name": "Persian carpet", "author": "jarble", "description": "These patterns resemble Persian carpets.\nI also made [url=https://www.shadertoy.com/view/Ns3GWn]a better version[/url] of this shader with more randomized colors and patterns.", "tags": ["fractal", "carpet", "rug"], "likes": 4, "viewed": 322, "published": 3, "date": "1629413956", "time_retrieved": "2024-07-30T19:05:41.441854", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 4.5/2.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    //vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.*.0;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random2 = (hash31(1.+t2)-vec3(.5))/4.;\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .5;\n    float scale2 = 1.16;\n    for(int c=0;c<3;c++){\n        float bend = 1.;\n        float scale = c1.z;\n        //float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            //float factor = 1.16;\n            //uv.y *= factor;\n            \n            //float bend = abs(fract((uv.x)*1.)-.5)/1.+1.;\n            //float bend = 1.+1./3.;\n\n            uv = triangle_wave(uv.yx-offset,scale)/bend+triangle_wave(uv,scale)*bend;\n            //bend = 1.+uv.x/2.;\n\n            //bend = uv.x+uv.y;\n            for(int k = 0; k < 3; k++){\n                //uv *= bend+col.x;\n                uv.y /= scale2;\n                \n                uv = triangle_wave((uv-random2[k])/(random4[k]+1.),scale+random3[k]);\n                //bend = 1.+uv.x/2.;\n                uv.x /= -scale2;\n                //uv *= bend+col.x;\n\n            }\n            //uv.x *= factor;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= 1.+scale2*col.x;\n            //offset *= scale2/(1.+random4.x);\n            \n            uv = -uv.yx;\n            \n            scale2 += col.x/8.;\n            //scale2 = 1./(.75+col.x);\n\n            //col = (col*random1[i]+col_prev.yzx*(1.-random1[i]));\n            col[c] = fract((uv.x)-(uv.y));\n            //col[c] = abs(-col[c]-uv.x+uv.y);\n\n        }\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [590, 590, 629, 629, 674], [676, 676, 733, 733, 2752]]}
{"id": "Ns3GRM", "name": "Conformal Torus Stars", "author": "pyBlob", "description": "Draws a star shape onto the torus surface using local uv coordinates (orange) and onto the screen (black). When the conformal map is used, the pointy ends of the triangles match exactly. Bottom left shows inside, top right shows outside of torus.", "tags": ["torus", "conformal"], "likes": 7, "viewed": 298, "published": 3, "date": "1629413088", "time_retrieved": "2024-07-30T19:05:42.198830", "image_code": "/*\nhttps://en.wikipedia.org/wiki/Conformal_map\n    \"In mathematics, a conformal map is a function that locally preserves angles\"\n    \"The transformation is conformal whenever the Jacobian at each point is\n        a positive scalar times a rotation matrix.\"\n\nIdea:\n    The two vectors of the jacobian of a torus parameterized using uv angles\n    are orthogonal. It remains to scale one of them to arrive at a scaled rotation\n    matrix.\n\nMouse:\n    - conformal (default) vs naive (click)\n\nStars:\n    - Black: fixed screen coordinates\n    - Orange: local uv on torus surface\n\nSymmetries:\n    - Rotation along y axis (-> only sample uv.u = 0)\n    - Mirror along xz plane (-> only sample uv.v > 0)\n\nDerivation of exact conformal warp formula at end of common tab.\n\nUsing 4-space:\n    mla: https://www.shadertoy.com/view/tdGfzz\n\nSimilar formula using atan:\n    FabriceNeyret2: https://www.shadertoy.com/view/sdd3R4\n\n*/\n\nfloat warp(float b, vec2 torus)\n{\n    float rm = torus.x / torus.y;\n    float fp = sqrt(rm + 1.);\n    float fn = sqrt(rm - 1.);\n    \n    return 2. * atan(fn * tan(b / 2.), fp) / (fn * fp);\n}\n\nbool star(vec2 uv, float r, float s)\n{\n    float w = fract(atan(uv.y, uv.x) / tau * 8.);\n    bool star = any(lessThan(vec2(w, 1.-w), vec2(s))) && length(uv) < r;\n    return star;\n}\n\nvoid slice(inout vec4 C, in vec2 O, float a)\n{\n    vec2 torus = vec2(5., 1.5);\n\n    vec3 rd = normalize(vec3(O * f, 1.));\n    vec3 ro = vec3(0, 0, -torus.r);\n    \n    rd.yz *= R(a);\n    ro.yz *= R(a);\n    \n    ro.y += torus.x;\n\n    float t = mTorus(ro, rd, torus);\n    if (t > 0.)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 normal = nTorus(pos, torus);\n        float light = clamp(.2 + dot(normal, -rd), 0., 1.);\n        float fog = smoothstep(1. + 2. * torus.x, 1., t);\n\n        vec2 v1 = pos.xy;\n        vec2 v2 = vec2(pos.z, length(pos.xy) - torus.x);\n        vec2 ab = vec2(atan(v1.x, v1.y), atan(v2.x, v2.y));\n\n        // cmod and wmod moves uv origin to screen center\n        vec2 uv_naive = vec2(\n            ab.x,\n            cmod(ab.y - (a - radians(90.)), tau)\n        ) * vec2(20., 5.5) / tau;\n\n        vec2 uv_conformal = vec2(\n            ab.x,\n            wmod(warp(ab.y, torus), warp(a - radians(90.), torus), torus)\n        ) * 20. / tau;\n        \n        vec2 uv;\n        uv = uv_naive;\n        if (iMouse.z <= 0.)\n            uv = uv_conformal;\n\n        bvec2 bchecker = lessThan(fract(uv), vec2(.5));\n        bool checker = bchecker.x != bchecker.y;\n        C = vec4(1) * fog * light * mix(.2, .4, checker);\n\n        if (star(uv, .5, .1))\n            C = vec4(1, .5, 0, 1);\n        if (star(O, .2 * res.y, .05))\n            C = vec4(0, 0, 0, 1);\n    }\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    vec2 N = vec2(6, 3);\n    float a = N.x * N.y, b = N.y;\n    res = iResolution.xy / N;\n    f = 1. / res.y;\n\n    vec2 view = floor(O / res);\n    O = mod(O, res);\n    float id = (view.x / a + view.y / b) * (a + 1.) / a;\n\n    if (any(lessThan(vec4(O, res - O), vec4(1))))\n    {\n        C = vec4(0);\n        return;\n    }\n\n    C = vec4(0);\n    float AA = 4.;\n    for (vec2 x=vec2(0) ; x.y<AA ; ++x.y)\n    for (x.x=0. ; x.x<AA ; ++x.x)\n    {\n        vec4 c = vec4(.2, .5, 1, 1);\n        slice(c, O - res / 2. + x / AA - .5, radians(mix(-90., 90., id)));\n        C += c;\n    }\n    C /= AA * AA;\n}\n", "image_inputs": [], "common_code": "float f;\nvec2 res;\n\nconst float pi = radians(180.);\nconst float tau = 2. * pi;\n\nfloat cmod(float x, float f)\n{\n    if (x < -f / 2.)\n        x += tau;\n    if (x > f / 2.)\n        x -= tau;\n    return x;\n}\n\nfloat halfwarp(vec2 torus)\n{\n    float rm = torus.x / torus.y;\n    float fp = sqrt(rm + 1.);\n    float fn = sqrt(rm - 1.);\n\n    return pi / (fn * fp);\n}\n\nfloat wmod(float a, float shift, vec2 torus)\n{\n    float hw = halfwarp(torus);\n    a -= shift;\n    if (a > hw)\n        a -= 2.*hw;\n    if (a < -hw)\n        a += 2.*hw; \n    return a;\n}\n\nmat2 R(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat mTorus(in vec3 ro, in vec3 rd, in vec2 tor)\n{\n    float t = 0.;\n    for (int i=0 ; i<100 ; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float d = length(vec2(length(p.xy) - tor.x, p.z)) - tor.y;\n        t += d;\n        if (t > 10. * tor.x)\n            return -1.;\n    }\n    return t;\n}\n\nfloat iTorus(in vec3 ro, in vec3 rd, in vec2 tor)\n{\n    // f(x) = (|x| + R - r) - 4R|xy| = 0\n    // https://www.shadertoy.com/view/4sBGDy\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n        float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n        if( h<0.0 ) return -1.0;\n        //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\nvec3 nTorus(in vec3 pos, vec2 tor)\n{\n    // df(x)/dx\n    // https://www.shadertoy.com/view/4sBGDy\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n/*\nDerivation of the warp function:\n\nParametric torus (+x-zero, xz-plane, y-up):\n\n    R a = mat2 (cos a) (-sin a)\n               (sin a) ( cos a)\n    \n    mat3_xz f (mat2 xx xz\n                    zx zz) = mat3 xx 0 xz\n                                   0 f  0\n                                  zx 0 zz\n    \n    torus u v =\n            (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * R_u\n        where\n            R_u = mat3_xz 1 (R u)\n            R_v = mat3_xy 1 (R v)\n\nTangents:\n\n    W a = D 0 R a\n        = mat2 (-sin a) (-cos a)\n               ( cos a) (-sin a)\n\n    d0 u v\n        = D 0 torus u v\n        = (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * W_u\n        where\n            W_u = mat3_xz 0 (W u)\n\n    d1 u v\n        = D 1 torus u v\n        = vec3 r_inner 0 0 * W_v * R_u\n        where\n            W_v = mat3_xy 0 (W v)\n\nTangents rotated by \"inverse R_u\":\n\n    T = W u * inverse (R u)\n      = mat2 (-sin u) (-cos u)\n             ( cos u) (-sin u) * mat2 ( cos u) (sin u)\n                                      (-sin u) (cos u)\n      = mat2 0 (-1)\n             1   0\n\n    d0' u v\n        = D 0 torus u v                                     * inverse R_u\n        = (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * W_u * inverse R_u\n        = (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * mat3_xz T\n        =  vec3     (r_inner * cos v + r_outer) (r_inner * sin v) 0 * mat3_xz T\n        =  vec3 0 0 (r_inner * cos v + r_outer)\n\n    d1' u v\n        = D 1 torus u v                * inverse R_u\n        = vec3 r_inner 0 0 * W_v * R_u * inverse R_u\n        = vec3 r_inner 0 0 * W_v\n        = vec3 (-r_inner * sin v) (r_inner * cos v) 0\n\n    -- good: d0' and d1' are trivially orthogonal\n    dot (d0' u v) (d1' u v)\n        = dot (vec3 0 0 _) (vec3 _ _ 0)\n        = 0\n    \n    -- bad: d0' and d1' have different lengths in most places\n    length (d0' u v) = r_inner * cos v + r_outer\n    length (d1' u v) = r_inner\n    \n    --> naive map is not conformal\n\nConformal warp function:\n\n    conformal_torus u V =\n            (vec3 r_inner 0 0 * R_v + vec3 r_outer 0 0) * R_u\n        where\n            R_u = mat3_xz 1 (R u)\n            R_v = mat3_xy 1 (R v)\n            v = unwarp V\n\n    -- d0' does not change when warping v\n    conformal_d0' u V = d0' u (unwarp V)\n    \n    -- d1' scales when warping v\n    conformal_d1' u V = d1' u (unwarp V) * D 0 unwarp V\n\n    length (conformal_d0' u V) = r_inner * cos (unwarp V) + r_outer\n    length (conformal_d1' u V) = r_inner * D 0 unwarp V\n    \n    -- solve for derivative of unwarp using equal lengths\n    D 0 warp V = r_outer / r_inner + cos (unwarp V)\n    \n    -- we have this function:\n    unwarp V = v\n    \n    -- but texturing needs this:\n    warp v = V\n    \n    -- when r_outer > r_inner, unwarp is inverse of warp:\n    unwarp (warp v) = v\n\n    -- when r_outer > r_inner, derivatives are related by reciprocal:\n    D 0 warp v = 1 / D 0 unwarp (warp v)\n               = 1 / (r_outer / r_inner + cos (unwarp (warp v)))\n               = 1 / (r_outer / r_inner + cos v)\n\nFinally integrate (D 0 warp v) from 0..v:\n\n    d_warp a v = 1 / (a + cos v)\n    \n    -- by lookup in clever program\n    integrate 0 (d_warp a) 0 v =\n            2 * atan (fn * tan (v / 2) / fp) / (fn * fp)\n        where\n            fn = sqrt (a - 1)\n            fp = sqrt (a + 1)\n\n    warp v = integrate 0 (D 0 warp) 0 v\n           = integrate 0 (d_warp (r_outer / r_inner)) 0 v\n\nSome warp evaluations:\n\n    unwarp 0 = 0\n    D 0 unwarp 0 = r_outer / r_inner + cos (unwarp 0)\n                 = r_outer / r_inner + 1\n    warp 0 = 0\n    warp pi = pi / (fn * fp)\n    warp -pi = -pi / (fn * fp)\n\n*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3GRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[915, 915, 948, 948, 1105], [1107, 1107, 1145, 1145, 1287], [1289, 1289, 1335, 1335, 2669], [2671, 2671, 2710, 2710, 3303]]}
{"id": "Ndt3zM", "name": "Perspective Correct Interp.", "author": "oneshade", "description": "Implementation of perspective correct interpolation.\nContinuing to learn about rasterization!\nLeft: rasterized (background is red when perspective correction is turned off, green when turned on)\nRight: raytraced (gives direct access to the 3D coordinates)", "tags": ["perspective", "interpolation", "correct"], "likes": 16, "viewed": 214, "published": 3, "date": "1629399761", "time_retrieved": "2024-07-30T19:05:42.947827", "image_code": "// From this lesson:\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/perspective-correct-interpolation-vertex-attributes\n\nstruct TriIntersect {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 bary;\n};\n\nTriIntersect iTriangle(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c) {\n    ro -= a; b -= a; c -= a; a = vec3(0.0);\n    vec3 ba = b - a, cb = c - b, ac = a - c;\n\n    vec3 n = cross(ba, -ac);\n    float denom = dot(rd, n);\n    if (denom != 0.0) {\n        float t = -dot(ro, n) / denom;\n\n        vec3 p = ro + rd * t;\n        vec3 pa = p - a, pb = p - b, pc = p - c;\n\n        float abc = length(n);\n        float u = length(cross(cb, pb)) / abc;\n        float v = length(cross(ac, pc)) / abc;\n        float w = length(cross(ba, pa)) / abc;\n\n        return TriIntersect(abs(u + v + w - 1.0) < 0.001, p, t, vec3(u, v, w));\n    }\n\n    return TriIntersect(false, vec3(0.0), 0.0, vec3(0.0));\n}\n\nbool pointInTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    bool pa = p.y > a.y, pb = p.y > b.y, pc = p.y > c.y;\n    bool wa = pa != pc && pc != ((c.x - a.x) * (p.y - a.y) > (c.y - a.y) * (p.x - a.x));\n    bool wb = pb != pa && pa != ((a.x - b.x) * (p.y - b.y) > (a.y - b.y) * (p.x - b.x));\n    bool wc = pc != pb && pb != ((b.x - c.x) * (p.y - c.y) > (b.y - c.y) * (p.x - c.x));\n    return wa ^^ wb ^^ wc;\n}\n\nvec3 barycentric(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n\n    float abc = abs(ba.y * ac.x - ba.x * ac.y);\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n\n    return vec3(bcp, cap, abp) / abc;\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y - vec2(0.5 * aspect, 0.5);\n    float unit = 2.0 / iResolution.y;\n    float offset = 0.25 * aspect;\n    vec3 color = vec3(0.0);\n\n    // Vertices\n    float transition = smoothstep(1.0, 0.0, abs(mod(iTime * 0.25, 2.0) - 1.0));\n    vec3 a = mix(vec3(-2.0, -2.0, -6.0), vec3(-2.0, -1.0, -7.0), transition);\n    vec3 b = mix(vec3( 2.0, -2.0, -6.0), vec3(2.0, -1.0, -5.0), transition);\n    vec3 c = mix(vec3( 2.0,  2.0, -6.0), vec3(0.0, 1.5, -11.0), transition);\n\n    // UVs\n    vec2 uv1 = vec2(0.0, 0.0);\n    vec2 uv2 = vec2(1.0, 0.0);\n    vec2 uv3 = vec2(1.0, 1.0);\n\n    if (uv.x > 0.0) { // Raytrace triangle on right\n        uv.x -= offset; // Recenter\n\n        vec3 ro = vec3(0.0, 0.0, 0.0);\n        vec3 rd = normalize(vec3(uv, -1.0));\n\n        // Blue gradient background\n        color.b += exp(-2.0 * length(fragCoord / iResolution.xy * vec2(2.0, 1.0) - vec2(1.5, 0.5)));\n\n        TriIntersect tri = iTriangle(ro, rd, a, b, c);\n        if (tri.hit) {\n            vec2 triUv = uv1 * tri.bary.x + uv2 * tri.bary.y + uv3 * tri.bary.z;\n\n            float grid = 1.0 - max(smoothstep(0.01, 0.0, abs(mod(triUv.x + 0.1, 0.2) - 0.1) - 0.002),\n                                   smoothstep(0.01, 0.0, abs(mod(triUv.y + 0.1, 0.2) - 0.1) - 0.002));\n\n            color = vec3(grid);\n        }\n\n        uv.x += offset;\n    }\n\n    if (uv.x < 0.0) { // Rasterize triangle on left\n        uv.x += offset; // Recenter\n\n        // Toggle perspective correction\n        bool correct = mod(iTime, 16.0) < 8.0;\n\n        // Gradient background (red when perspective correction is off, green when its on)\n        color.rg = vec2(!correct, correct) * exp(-2.0 * length(fragCoord / iResolution.xy * vec2(2.0, 1.0) - 0.5));\n\n        // Compute inverse z coordinates\n        float azInv = 1.0 / a.z;\n        float bzInv = 1.0 / b.z;\n        float czInv = 1.0 / c.z;\n\n        // Project (flipping the z due to the camera facing in the -z direction)\n        vec2 aProj = a.xy * -azInv;\n        vec2 bProj = b.xy * -bzInv;\n        vec2 cProj = c.xy * -czInv;\n\n        if (pointInTriangle(uv, aProj, bProj, cProj)) {\n            vec3 bary = barycentric(uv, aProj, bProj, cProj);\n\n            // Divide attributes by corresponding z coordinate\n            if (correct) {\n                uv1 *= azInv;\n                uv2 *= bzInv;\n                uv3 *= czInv;\n            }\n\n            vec2 triUv = uv1 * bary.x + uv2 * bary.y + uv3 * bary.z; // Interpolate like usual\n\n            if (correct) {\n                float z = 1.0 / (azInv * bary.x + bzInv * bary.y + czInv * bary.z); // Perspective correct z coordinate\n                triUv *= z;\n            }\n\n            float grid = 1.0 - max(smoothstep(0.01, 0.0, abs(mod(triUv.x + 0.1, 0.2) - 0.1) - 0.002),\n                                   smoothstep(0.01, 0.0, abs(mod(triUv.y + 0.1, 0.2) - 0.1) - 0.002));\n\n            color = vec3(grid);\n        }\n\n        uv.x -= offset;\n    }\n\n    color = mix(color, vec3(0.8, 0.6, 0.0), smoothstep(unit, 0.0, abs(uv.x) - 0.005));\n    fragColor.rgb += color;\n}\n\n// Supersample\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n     fragColor = vec4(0.0);\n     render(fragColor, fragCoord);\n     render(fragColor, fragCoord + vec2(0.5, 0.0));\n     render(fragColor, fragCoord + vec2(0.0, 0.5));\n     render(fragColor, fragCoord + vec2(0.5, 0.5));\n     fragColor.rgb /= 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndt3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 339, 339, 953], [1376, 1376, 1438, 1438, 1762], [1764, 1764, 1818, 1818, 4936], [4938, 4953, 5008, 5008, 5256]]}
{"id": "fdcGz7", "name": "ripple implementation", "author": "unicrongalactus", "description": "Ripple shader from here:\nhttps://adrianboeing.blogspot.com/2011/02/ripple-effect-in-webgl.html", "tags": ["water", "ripple"], "likes": 2, "viewed": 300, "published": 3, "date": "1629351679", "time_retrieved": "2024-07-30T19:05:43.691838", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    float cLength = length(cPos);\n\n    vec2 uv = fragCoord.xy/iResolution.xy+(cPos/cLength)*cos(cLength*12.0-iTime*4.0)*0.03;\n    vec3 col = texture(iChannel0,uv).xyz;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 101, 101, 363]]}
{"id": "fd3Gz7", "name": "transform test", "author": "lasoy", "description": "transform test", "tags": ["sdf"], "likes": 0, "viewed": 255, "published": 3, "date": "1629350940", "time_retrieved": "2024-07-30T19:05:44.545557", "image_code": "#define PI 3.1415926\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x,d.y), 0.0);\n}\n\nmat2 rot(float a) {\n    float cs = cos(a);\n    float ss = sin(a);\n    return mat2(cs, ss, -ss, cs);\n}\n\n\nmat2 scale(float sx) {\n    return mat2(sx, 0., 0., sx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float pix = 2./iResolution.y;\n    \n    float a = fract(iTime / 6.);\n    \n    float n = floor(a * 5.);\n    float t = fract(a * 5.);\n    t = smoothstep(.2, .8, t);\n    if (n < 1.) {\n        uv += t * .4;\n    } else if (n < 2.) {\n        uv += .4;\n        uv = rot(t * PI * 2.) * uv;\n    } else if (n < 3.) {\n        uv += .4;\n        uv.y -= .8 * t;\n    \n    } else if (n < 4.) {\n        uv.x += .4;\n        uv.y -= .4;\n        \n        uv.x -= .8 * t;\n        uv.y += .8 * t;\n        \n        uv = rot(t * 2. * PI) * uv;\n        uv = scale(1./(1. + t)) * uv;\n        \n        \n    } else if (n < 5.) {\n        uv.x -= .4;\n        uv.y += .4;\n        uv = scale(.5) * uv;\n  \n        uv.x += .2 * t;\n        uv.y -= .2 * t;\n        uv = scale(1. + t) * uv;\n        uv = rot(t * 2. * PI) * uv;\n    }\n    \n    vec3 col = vec3(smoothstep(pix, -pix, sdBox(uv, vec2(.1, .1))), .0, .0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3Gz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 56, 56, 140], [142, 142, 161, 161, 243], [246, 246, 268, 268, 303], [305, 305, 362, 412, 1393]]}
{"id": "fs33zM", "name": "Arbitrary Precision Mandelbrot", "author": "Zi7ar21", "description": "I am using someone's library from GitHub. I know it isn't practical, but it sure is cool!\nhttps://github.com/alexozer/glsl-arb-prec", "tags": ["mandelbrot", "precision", "arbitrary"], "likes": 5, "viewed": 563, "published": 3, "date": "1629343139", "time_retrieved": "2024-07-30T19:05:45.297545", "image_code": "// ####### Arbitrary Precision Mandelbrot #######\n// Demo Made by Jacob Bingham (Zi7ar21) on August 18th, 2021\n\n/*\nThis is a demo of a cool arbitrary-precision library I found on GitHub:\nhttps://github.com/alexozer/glsl-arb-prec/issues/1\n*/\n\n// ##### Parameters #####\n\n// Mandelbrot Set Iterations\n#define iterations 128\n\n// Offset\n#define offset vec2(-0.8216345, 0.2000020)\n\n// Scale Factor (Higher = More Zoomed)\n//#define scaling loadFloat(2.0);\n#define scaling loadFloat(1.0/exp(5.0*sin(0.125*pi*iTime)+5.0))\n\n// ##### Constants and Macros #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.141592653589793\n\n// Traditional Uniform Identifiers\n#define resolution iResolution\n#define time iTime\n\n// ##### Rendering #####\n\n//\nfloat mandelbrot(int[n_int] c_r, int[n_int] c_i)\n{\n    int z_r[n_int], z_i[n_int], pz_r[n_int], pz_i[n_int];\n    result = loadFloat(0.0);\n    z_r = result;\n    z_i = result;\n    pz_r = result;\n    pz_i = result;\n\n    for(int i = 0; i < iterations; i++)\n    {\n        mul(pz_r, pz_r);\n        int orbitSize[n_int];\n        orbitSize = result;\n        mul(pz_i, pz_i);\n        add(orbitSize, result);\n        orbitSize = result;\n        int bailoutRadius[n_int] = loadFloat(4.0);\n        negate(bailoutRadius);\n        add(orbitSize, bailoutRadius);\n        // I have no idea how this works lol, I just played until the bailout worked\n        // I guess I could use signp...\n        if(signp(result))\n        {\n            float t = float(i)/float(iterations);\n            return 0.5*sin(4.0*pi*t)+0.5;\n        }\n\n        mul(pz_r, pz_r);\n        z_r = result;\n        mul(pz_i, pz_i);\n        negate(result);\n        add(z_r, result);\n        z_r = result;\n\n        mul(pz_r, pz_i);\n        z_i = result;\n        mul(z_i, loadFloat(2.0));\n        z_i = result;\n\n        add(z_r, c_r);\n        z_r = result;\n        add(z_i, c_i);\n        z_i = result;\n\n        pz_r = z_r;\n        pz_i = z_i;\n    }\n\n    return 0.0;\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(gl_FragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Initialize Variables\n    int uv_x[n_int], uv_y[n_int], offset_x[n_int], offset_y[n_int], scale[n_int];\n\n    // Convert Screen UV Coordinates to Arbitrary-Precision\n    uv_x = loadFloat(uv.x);\n    uv_y = loadFloat(uv.y);\n\n    // Convert Transformations to Arbitrary-Precision\n    offset_x = loadFloat(offset.x);\n    offset_y = loadFloat(offset.y);\n    scale = scaling;\n\n    // Apply Scale Transformations\n    mul(uv_x, scale);\n    uv_x = result;\n    mul(uv_y, scale);\n    uv_y = result;\n\n    // Apply Offset Transformations\n    add(uv_x, offset_x);\n    uv_x = result;\n    add(uv_y, offset_y);\n    uv_y = result;\n\n    // Calculate and Color the Mandelbrot Set\n    vec3 color = vec3(1.000, 1.000, 1.000)*mandelbrot(uv_x, uv_y);\n\n    // Output the Rendered Frame\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// GLSL Arbitrary Precision (modified a little bit)\n// https://github.com/alexozer/glsl-arb-prec\n\n// Number of Integers used to store an Arbitrary-Precision Number\n//const int n_int = 3;\n#define n_int 3\n\n// Power of 10 one larger than the maximum value per int\n//const int limit = 10000;\n#define limit 32768\n\nconst float limitFlt = float(limit);\n\nint result[n_int];\n\n#define zero(x, len) for(int i=0;i<len;i++){x[i]=0;}\n#define assign(x, y) for(int i=0;i<n_int;i++){x[i]=y[i];}\n#define negate(x) for(int i=0;i<n_int;i++){x[i]=-x[i];}\n\nbool signp(int[n_int] a)\n{\n    return a[n_int-1] >= 0;\n}\n\nint keepVal, carry;\n\nvoid roundOff(int x)\n{\n    carry = x/limit;\n    keepVal = x-carry*limit;\n}\n\nvoid add(int[n_int] a, int[n_int] b) {\n    bool s1 = signp(a), s2 = signp(b);\n\n    carry = 0;\n\n    for(int i = 0; i < n_int-1; i++) {\n        roundOff(a[i] + b[i] + carry);\n\n        if(keepVal < 0) {\n            keepVal += limit;\n            carry--;\n        }\n\n        result[i] = keepVal;\n    }\n    roundOff(a[n_int-1] + b[n_int-1] + carry);\n    result[n_int-1] = keepVal;\n    \n    if(s1 != s2 && !signp(result)) {\n        negate(result);\n\n        carry = 0;\n\n        for(int i = 0; i < n_int; i++) {\n            roundOff(result[i] + carry);\n\n            if(keepVal < 0) {\n                keepVal += limit;\n                carry--;\n            }\n\n            result[i] = keepVal;\n        }\n\n        negate(result);\n    }\n}\n\nvoid mul(int[n_int] a, int[n_int] b) {\n    bool toNegate = false;\n\n    if(!signp(a)) {\n        negate(a);\n        toNegate = !toNegate;\n    }\n    if(!signp(b)) {\n        negate(b);\n        toNegate = !toNegate;\n    }\n\n    const int lenProd = (n_int-1)*2+1;\n    int prod[lenProd];\n    zero(prod, lenProd);\n\n    for(int i = 0; i < n_int; i++) {\n        for(int j = 0; j < n_int; j++) {\n            prod[i+j] += a[i] * b[j];\n        }\n    }\n\n    carry = 0;\n    const int clip = lenProd - n_int;\n    for(int i = 0; i < clip; i++) {\n        roundOff(prod[i] + carry);\n        prod[i] = keepVal;\n    }\n\n    if(prod[clip-1] >= limit/2) {\n        carry++;\n    }\n\n    for(int i = clip; i < lenProd; i++) {\n        roundOff(prod[i] + carry);\n        prod[i] = keepVal;\n    }\n\n    for(int i = 0; i < lenProd - clip; i++) {\n        result[i] = prod[i+clip];\n    }\n\n    if(toNegate) {\n        negate(result);\n    }\n}\n\nint[n_int] loadFloat(float f)\n{\n    int x[n_int];\n\n    for(int i = n_int-1; i >= 0; i--)\n    {\n        int fCurr = int(f);\n        x[i] = fCurr;\n        f -= float(fCurr);\n        f *= limitFlt;\n    }\n\n    return x;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs33zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2012, 2043, 2098, 2127, 3017]]}
{"id": "NdcGzM", "name": "test truchet v3", "author": "jorge2017a1", "description": "test truchet v3", "tags": ["testtruchetv3"], "likes": 3, "viewed": 250, "published": 3, "date": "1629335771", "time_retrieved": "2024-07-30T19:05:46.325796", "image_code": "//por jorge2017a1---18-ago-2021\n\n//referencia:\n//byt3_m3chanic,  UV Mapping Truchet Tiles \n//https://iquilezles.org/articles/distfunctions\n//https://www.youtube.com/watch?v=2R7h76GoIJM ....Art Code\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n  \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    \n    p.y=p.y-5.0;\n    \n    vec2 sc = vec2(0.05);\n    vec2 hsc = 5.0/sc; \n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/sc;\n    vec3 q = vec3(r.x,p.y,r.y);\n    \n    float sdc1=sdCylinderXZ( q-vec3(0.0,3.0,0.0), vec2(4.0,20.0) );\n    float idc=length(id+1.0)+id.y+id.x+1.0;\n    res =opU3(res, vec3(sdc1,idc+1.0,15.0));\n    \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  \n  vec3 l1;\n    \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n    //referencia:  byt3_m3chanic,  UV Mapping Truchet Tiles \n\nif (id_material==15.0)\n    { \n          #define PI2         6.28318530718\n             //angle for the tube\n            float angle = atan(p.y,p.x)/PI2;\n            //angle for the arc/truchet path\n            float gz =  atan( p.z,  length(p.yx)-0.5 ) / PI2;\n            //make the uv\n            vec2 uv = vec2(angle,gz)*150.0;\n            \n            vec3 col=truchet( uv ,iResolution.xy, false, 0.0);\n             l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n        \n        \n    }\n\n\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100  && id_material<0.0)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0  ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n        \n     if (id_material>0.0 && id_color>0)\n        { \n            colobj=getColor(int( id_color));\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n        \n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   \n        //p = (ro + rd * d );  \n        p=mObj.phit;\n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n    \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( 00.0, 5.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-25.0+t);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n//referencia\n//https://www.youtube.com/watch?v=2R7h76GoIJM ....Art Code\nfloat Hash21(vec2 p)\n{\n    p=fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.23);\n    return fract(p.x*p.y);\n}\n\nvec3 truchet( in vec2 fragCoord, vec2 ir , bool blnt, float t)\n{\n    vec2 uv=(fragCoord-0.5*ir.xy)/ir.y;\n    uv*= 100.0;\n    if (blnt=true)\n    uv+=t;\n        vec3 col=vec3(0.0);\n\n    vec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n\n    float n=Hash21(id*2.0); //rango 0.0 a 1.0\n\n    float width=0.1;\n\n    if(n<0.5) gv.x*=-1.0;\n    float d=abs( abs( gv.x+gv.y)-0.5 );\n\n    d=length(gv-sign(gv.x+gv.y-0.001)*0.5 )-0.5;\n\n    float  mask=smoothstep(0.01,-0.01, abs(d)-width);\n    col+=mask;\n    return col;\n }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[659, 659, 698, 698, 793], [796, 834, 870, 870, 915], [916, 981, 1015, 1015, 1111], [1112, 1112, 1146, 1146, 1237], [1238, 1238, 1272, 1272, 1363], [1364, 1404, 1438, 1438, 1533], [1534, 1574, 1599, 1599, 2151], [2153, 2204, 2228, 2228, 2390], [2392, 2392, 2441, 2441, 3072], [3074, 3161, 3197, 3197, 3442], [3443, 3498, 3525, 3525, 3542], [3544, 3544, 3580, 3580, 3672], [3673, 3673, 3719, 3719, 3844], [3846, 3846, 3920, 3920, 5519], [5520, 5575, 5624, 5624, 5867], [5868, 5902, 5982, 5982, 6105], [6148, 6148, 6180, 6180, 6377], [6379, 6427, 6455, 6455, 6643], [6646, 6697, 6744, 6744, 7618], [7620, 7672, 7765, 7765, 8475], [8477, 8477, 8508, 8508, 9139], [9141, 9190, 9216, 9216, 9326], [9328, 9328, 9386, 9386, 9438], [9440, 9489, 9546, 9546, 10096]]}
{"id": "ssdGR4", "name": "Basic adjustments", "author": "miyaokamarina", "description": "Basic color adjustments.", "tags": ["saturation", "luminance", "hue", "adjustment"], "likes": 3, "viewed": 307, "published": 3, "date": "1629328577", "time_retrieved": "2024-07-30T19:05:47.081774", "image_code": "precision lowp float;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = fragCoord / iResolution.xy;\n    vec4 src = texture(iChannel0, pos);\n\n    // CSS-like color inversion:\n    //\n    // -   `0.0`  identity,\n    // -   `0.5`  grey,\n    // -   `1.0`  full inversion.\n    src = simple_inversion(src, 0.0);\n\n    // Like inversion, but doesnt rotate hue:\n    //\n    // -   `0.0`  identity,\n    // -   `0.5`  hue map,\n    // -   `1.0`  full inversion.\n    src = luminance_inversion(src, 1.0);\n\n    // Hue rotation (degrees):\n    //\n    // -   `0.0`  identity.\n    // -   `PI`   hue inversion.\n    src = hue_rotation(src, 0.0);\n\n    // Saturation scale:\n    //\n    // -   `0.0`  luminance map (grayscale).\n    // -   `1.0`  no-op.\n    src = saturation_scale(src, 1.5);\n\n    // Like brightness, but perceptually uniform:\n    //\n    // -   `0.5`  darken,\n    // -   `1.0`  identity,\n    // -   `1.5`  lighten.\n    //\n    // WARNING: It may produce out of gamut results.\n    src = luminance_scale(src, 0.6);\n\n    // Contrast adjustment:\n    //\n    // -   `0.0`  grey,\n    // -   `1.0`  identity.\n    src = contrast_scale(src, 1.1);\n\n    fragColor = src;\n}\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "precision lowp float;\n\n#define PI  3.141592653589793\n#define PI2 6.283185307179586\n\nvec4 simple_inversion(vec4 src, float s) {\n    float t = -2.0*s+1.0;\n\n    return src * mat4(\n        t, 0, 0, s,\n        0, t, 0, s,\n        0, 0, t, s,\n        0, 0, 0, 1.\n    );\n}\n\nvec4 luminance_inversion(vec4 src, float s) {\n    float t  = 1.0-s;\n\n    return src * mat4(\n        +1.000-0.426*s, -1.430+1.430*t, -0.144+0.144*t, s,\n        -0.426+0.426*t, +1.000-1.430*s, -0.144+0.144*t, s,\n        -0.426+0.426*t, -1.430+1.430*t, +1.000-0.144*s, s,\n         0,              0,            0,             1.\n    );\n}\n\nvec4 hue_rotation(vec4 src, float h) {\n    float ch = cos(h);\n    float sh = sin(h);\n\n    return src * mat4(\n        .213+ch*.787-sh*.213, .715-ch*.715-sh*.715, .072-ch*.072+sh*.928, 0,\n        .213-ch*.213+sh*.143, .715+ch*.285+sh*.140, .072-ch*.072-sh*.283, 0,\n        .213-ch*.213-sh*.787, .715-ch*.715+sh*.715, .072+ch*.928+sh*.072, 0,\n        0,                    0,                    0,                    1.\n    );\n}\n\nvec4 saturation_scale(vec4 src, float s) {\n    return src * mat4(\n        .213+.787*s, .715-.715*s, .072-.072*s, 0,\n        .213-.213*s, .715+.285*s, .072-.072*s, 0,\n        .213-.213*s, .715-.715*s, .072+.928*s, 0,\n        0,           0,           0,           1.\n    );\n}\n\n// TODO: Accurate version.\nvec4 luminance_scale(vec4 src, float l) {\n    return src * mat4(\n        .213*l+.787, .715*l-.715, .072*l-.072, 0,\n        .213*l-.213, .715*l+.285, .072*l-.072, 0,\n        .213*l-.213, .715*l-.715, .072*l+.928, 0,\n        0,           0,           0,           1.\n    );\n}\n\n// TODO: Perceptually uniform?\nvec4 contrast_scale(vec4 src, float c) {\n    float t = (1.0 - c) * 0.5;\n\n    return src * mat4(\n        c, 0, 0, t,\n        0, c, 0, t,\n        0, 0, c, t,\n        0, 0, 0, 1.\n    );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 78, 78, 1217]]}
{"id": "Ndc3RM", "name": "Seperable Blur", "author": "oneshade", "description": "Taking 2n samples instead of n^2 samples which is much faster and produces the same result.\nClick with the mouse to see the sample area and weighting.\nDemoing usage for a bloom filter.", "tags": ["blur", "efficient", "gaussian", "seperable"], "likes": 9, "viewed": 218, "published": 3, "date": "1629328207", "time_retrieved": "2024-07-30T19:05:47.859694", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    fragColor += texture(iChannel0, fragCoord / iResolution.xy);\n    if (iMouse.z > 0.0) {\n        vec2 p = fragCoord - iMouse.xy;\n        bool inSampleArea = abs(p.x) < WIDTH && abs(p.y) < HEIGHT;\n        fragColor = vec4(inSampleArea ? gaussian(length(p), BLUR) * BLUR * 2.0 : 0.0);\n        if (inSampleArea) fragColor.g += 0.25 + 0.25 * sin(iTime);\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Horizontal blur pass\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float x=-WIDTH; x < WIDTH; x++) {\n        float weight = gaussian(x, BLUR);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(x, 0.0)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w; // Approaches 1 with more samples but unfortunately we can't take too many\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Vertical blur pass\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float total = 0.0;\n    for (float y=-HEIGHT; y < HEIGHT; y++) {\n        float weight = gaussian(y, BLUR);\n        fragColor += vec4(texture(iChannel0, (fragCoord + vec2(0.0, y)) / iResolution.xy).rgb * weight, weight);\n    }\n\n    fragColor.rgb /= fragColor.w; // Approaches 1 with more samples but unfortunately we can't take too many\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define WIDTH 30.0\n#define HEIGHT 30.0\n#define BLUR 10.0\n\nfloat gaussian(in float x, in float sigma) {\n    x /= sigma;\n    return 0.398942280401 / (sigma * exp(0.5 * x * x)); // 0.398942280401 ~ 1/sqrt(2)\n}", "buffer_c_code": "// One of my previous shaders: https://www.shadertoy.com/view/3ldcD7\nstruct Light {\n    vec3 pos; // Position of the light\n    vec3 col; // Color of the light\n    float Kc; // Constant attenuation term\n    float Kl; // Linear attenuation term\n    float Kq; // Quadratic attenuation term\n};\n\nvec3 getIllumination(in vec3 p, in Light light) {\n    float d = length(p - light.pos);\n    float b = 1.0 / (light.Kc + light.Kl * d + light.Kq * d * d);\n    return light.col * b;\n}\n\nmat2 Rotate(in float a) {\n    float rad = radians(a);\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\n#define t1 0.5 * iTime\n#define t3 1.5 * iTime\n\n#define c1 cos(t1) * 2.0\n#define s1 sin(t1) * 2.0\n#define c2 cos(iTime) * 2.0\n#define s2 sin(iTime) * 2.0\n#define c3 cos(t3) * 2.0\n#define s3 sin(t3) * 2.0\n\n#define blink round(fract(iTime * 3.0))\n#define second fract(iTime)\n#define bounce 4.0 * (second - second * second)\n\n#define light1 Light(vec3(c1, c3, s2), vec3(1.0, 0.0, 0.0) * blink, 1.0, 0.0, 0.5)\n#define light2 Light(vec3(s2, c1, s3), vec3(0.0, 1.0, 0.0) * bounce, 1.0, 0.0, 0.5)\n#define light3 Light(vec3(s2, s3, c1), vec3(0.0, 0.0, 1.0), 1.0, 0.0, 0.5)\n\nfloat mapScene(in vec3 p) {\n    vec3 q = abs(p) - 2.5;\n    float box1 = max(abs(max(q.x, max(q.y, q.z))) - 0.05, p.z - 2.0);\n\n    p.xz *= Rotate(30.0);\n    p -= vec3(0.25, -1.0, -2.0);\n    q = abs(p) - vec3(0.75, 1.5, 0.75);\n    float box2 = max(q.x, max(q.y, q.z));\n\n    p -= vec3(0.8, -0.7, 2.0);\n    p.xz *= Rotate(-55.0);\n    q = abs(p) - 0.8;\n    float box3 = max(q.x, max(q.y, q.z));\n\n    p.y -= 1.3;\n    float sphere1 = length(p) - 0.5;\n\n    p -= vec3(-2.0, -1.0, 1.5);\n    float sphere2 = length(p) - 1.0;\n\n    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),\n                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),\n                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            vec3 l = normalize(light1.pos - p);\n            float diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light1) * diffuse;\n\n            l = normalize(light2.pos - p);\n            diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light2) * diffuse;\n\n            l = normalize(light3.pos - p);\n            diffuse = max(0.0, dot(n, l));\n            fragColor.rgb += getIllumination(p, light3) * diffuse;\n\n            l = normalize(vec3(-1.0, 1.0, 1.0));\n            diffuse = max(0.1, dot(n, l));\n            fragColor.rgb += 0.25 * diffuse;\n\n            break;\n        }\n\n        float ld1 = length(p - light1.pos) - 0.05;\n        float ld2 = length(p - light2.pos) - 0.05;\n        float ld3 = length(p - light3.pos) - 0.05;\n\n        if (ld1 < 0.001) {\n            fragColor.rgb = light1.col;\n        }\n\n        if (ld2 < 0.001) {\n            fragColor.rgb = light2.col;\n        }\n\n        if (ld3 < 0.001) {\n            fragColor.rgb = light3.col;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += min(d, min(ld1, min(ld2, ld3)));\n    }\n}", "buffer_c_inputs": [], "buffer_d_code": "// Thresholding for bloom overlay\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    if (length(fragColor.rgb) < 0.75) fragColor = vec4(0.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 479]]}
{"id": "sdd3RN", "name": "Normal map from height", "author": "OskarSwierad", "description": "Calculating a tangent-space normal map out of a height function", "tags": ["normal"], "likes": 5, "viewed": 510, "published": 3, "date": "1629322160", "time_retrieved": "2024-07-30T19:05:48.619663", "image_code": "const float circleRadius = 0.2;\nconst vec2 circleCenter = vec2(0.5, 0.3);\n\nfloat calcHeight(vec2 uv)\n{\n    float circleShape = distance(uv, circleCenter);\n    circleShape /= circleRadius;\n    float mask = clamp(circleShape, 0.0, 1.0); // cone shape\n    mask = 1.0 - mask; // invert height\n    mask = smoothstep(0.0, 1.0, mask); // bell shape\n    return mask;\n}\n\nvec3 calcNormal(vec2 uv)\n{\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 kernelSize = vec2(0.001) * aspectRatio; // in UV space\n    \n    vec2 uvs[] = vec2[](\n        uv,                           // center\n        uv + vec2(kernelSize.x, 0.0), // to the right\n        uv + vec2(0.0, kernelSize.y)  // to the top\n    );\n\n    float samples[] = float[](\n        calcHeight(uvs[0]), // origin\n        calcHeight(uvs[1]), // to the right\n        calcHeight(uvs[2])  // to the top\n    );\n    \n    float dX = samples[1] - samples[0]; // height difference along X\n    float dY = samples[2] - samples[0]; // height difference along Y\n    float heightScale = 200.0; // normal map strength\n    float x = dX * heightScale;\n    float y = dY * heightScale;\n    float z = sqrt(1.0 - (x*x + y*y)); // derive Z out of X,Y\n    \n    vec3 normal = normalize(vec3(x, y, z)); // [-1,1] range\n    vec3 normalPacked = normal * 0.5 + vec3(0.5); // [0,1] range (bitmap)\n    return normalPacked;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy * vec2(1.0, aspectRatio);\n\n    vec3 normal = calcNormal(uv);\n\n    // Output to screen\n    fragColor = vec4(normal, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdd3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 102, 102, 360], [1352, 1352, 1409, 1409, 1626]]}
{"id": "ssdGzN", "name": "Persian rug patterns 3", "author": "jarble", "description": "These rug-like patterns are generated using triangle waves with a pseudorandom hash function.", "tags": ["fractal", "rug"], "likes": 4, "viewed": 245, "published": 3, "date": "1629318040", "time_retrieved": "2024-07-30T19:05:49.370655", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 6.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    vec3 random1 = hash31(floor((iTime)/10.0+uv.x))*10.;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    vec3 random3 = (hash31(2.+floor((iTime)/10.0+uv.x))-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+floor((iTime)/10.0+uv.x))-vec3(.5))/4.;\n    \n    float offset = .16+random4.z*.04;\n    float scale2 = 1.16+.04*random4.y;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv.x *= -1.0;\n\n            uv = triangle_wave(uv+random1.x,scale+random3.z);\n            uv.x /= -1.0;\n            \n            uv = triangle_wave(uv+random1.y,scale+random3.y);\n            uv.x *= -1.0;\n \n            uv = triangle_wave(uv+random1.z,scale+random3.z);\n            uv.x /= -1.0;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= scale2+col.x/2.;\n            offset *= scale2/(1.+random4.x);\n            \n            //uv = uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/4.;\n            //random1 = random3+hash31(col.x/32.)/2.;\n            //random3 = random4+hash31(col.y/32.)/2.;\n            //random4 = random1+hash31(col.z/32.)/2.;\n            col[c] = fract((uv.y)-(uv.x));\n\n        }\n     \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [591, 591, 630, 630, 675], [677, 677, 734, 734, 2304]]}
{"id": "7stGzN", "name": "2D Coordinate Transforms", "author": "sibaku", "description": "Visualization of a few 2D coordinate transforms. The original grid is shown on the left.The color signifies the squishing (blue) and stretching (red) of space due to the transformation. Deformation is computed via automatic differentiation ", "tags": ["derivative", "transform", "coordinatetransform", "autodiff", "jacobian", "stretching"], "likes": 13, "viewed": 530, "published": 3, "date": "1629317501", "time_retrieved": "2024-07-30T19:05:50.300169", "image_code": "const float pi = 3.14159265;\n\n// simple check if a point is inside bounding box\nbool inside(vec2 p, vec2 bmin, vec2 bmax) {\n  return !any(lessThan(p, bmin)) && !any(greaterThan(p, bmax));\n}\n\n// distance to the closest 1D line with a given spacing\nfloat sdLines(float p, float spacing) {\n  float pl = floor(p / spacing) * spacing;\n\n  float pr = ceil(p / spacing) * spacing;\n\n  return min(abs(p - pl), abs(p - pr));\n}\n\n// gray value for slightly smooth gridlines\n// takes seperate thickness to try to  counteract distortian\nfloat gridColor(vec2 p, float size, float thicknessx, float thicknessy) {\n  float dl1 = sdLines(p.x, size);\n  float dl2 = sdLines(p.y, size);\n\n  float f1 = smoothstep(thicknessx * 0.25, thicknessx, dl1);\n  float f2 = smoothstep(thicknessy * 0.25, thicknessy, dl2);\n  return f1 * f2;\n}\n\n// simple projection from squashed screen coordinate to a scaled world\nvec2 screen2World(vec2 p, vec2 origin, float unitScale, float aspect) {\n  p = p - origin;\n  p *= unitScale;\n  p.y /= aspect;\n  return p;\n}\n\n// inverse polar transfom for first coordinate\nGNum2 invRPolar(GNum2 x, GNum2 y) {\n  return a_sqrt(add(mult(x, x), mult(y, y)));\n}\n// inverse polar transfom for second coordinate\nGNum2 invThetaPolar(GNum2 x, GNum2 y) { return a_atan2(y, x); }\n\n// to sample original grid we need to compute the inverse transform\n// you can implement some transforms yourself using the autodiff functions\n// derivatives are computed automatically\nvoid invtransform(vec2 p, vec2 bmin, vec2 bdelta, vec2 bmax, float unitScale,\n                  float lineThickness, float aspect, int index, float blend,\n                  out vec2 q, out mat2 J) {\n\n  // center of current box\n  vec2 center = screen2World(bmin + 0.5 * bdelta, bmin, unitScale, aspect);\n\n  // create gradient variable\n  GNum2 x = varG2x(p.x);\n  GNum2 y = varG2y(p.y);\n\n  // coordinate system in center\n  GNum2 cx = sub(x, center.x);\n  GNum2 cy = sub(y, center.y);\n\n  // 5 transforms\n  GNum2 tx[5];\n  GNum2 ty[5];\n\n  // polar coordinates\n  {\n    // scaling to better showcase distortion\n    GNum2 sx = mult(cx, 0.75);\n    GNum2 sy = mult(cy, 0.75);\n    tx[0] = invRPolar(sx, sy);\n    ty[0] = invThetaPolar(sx, sy);\n  }\n\n  // y' = y/(1.5 - sin(2pix))\n  {\n\n    tx[1] = cx;\n    ty[1] = mult(cy, sub(1.5, a_sin(mult(2.0 * pi, cx))));\n  }\n\n  // y' = y*(1 + (2x)^2)\n  {\n    GNum2 xm = mult(x, 2.0);\n\n    tx[2] = x;\n    ty[2] = div(y, add(1.0, mult(xm, xm)));\n  }\n\n  // x' = exp(x)\n  {\n    tx[3] = a_log(x);\n    ty[3] = y;\n  }\n\n  // identity\n  {\n    tx[4] = x;\n    ty[4] = y;\n  }\n\n  // interpolate one function with the next with the given factor\n  // -> nice transitions\n  int idxp = int(mod(float(index + 1), 5.0));\n  GNum2 rx = a_mix(tx[index], tx[idxp], blend);\n  GNum2 ry = a_mix(ty[index], ty[idxp], blend);\n\n  // coordinate in original system\n  q.x = rx.val;\n  q.y = ry.val;\n\n  // Jacobian\n  // since we need extra parameters we have to create the Jacobian by ourself\n  // instead of using the JACOBIAN2 macro\n  J = transpose(mat2(rx.g, ry.g));\n}\n\n// 2D rotation\nmat2 rot(float alpha) {\n  float c = cos(alpha);\n  float s = sin(alpha);\n  return mat2(c, s, -s, c);\n}\n// from\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n// from\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangleIsosceles(in vec2 p, in vec2 q) {\n  p.x = abs(p.x);\n  vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n  float s = -sign(q.y);\n  vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n               vec2(dot(b, b), s * (p.y - q.y)));\n  return -sqrt(d.x) * sign(d.y);\n}\n\n// simple SDFs to draw an arrow\nfloat sdArrow(vec2 p, float w, float h) {\n\n  float db = sdBox(p - vec2(-w / 6.0, 0.0), vec2(w * 2.0 / 3.0, h) / 2.0);\n\n  p = p - vec2(w / 6.0, 0.0);\n  p = rot(-pi / 2.0) * p + vec2(0.0, w / 3.0);\n\n  float st = sdTriangleIsosceles(p, vec2(h, w / 3.0));\n\n  return min(db, st);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  float aspect = iResolution.x / iResolution.y;\n\n  float w = 0.4;\n  float h = w * aspect;\n\n  float borderx = (1.0 - 2.0 * w) / 4.0;\n  float bordery = (1.0 - h) / 2.0;\n\n  vec2 bminA = vec2(borderx, bordery);\n  vec2 bdeltaA = vec2(w, h);\n  vec2 bmaxA = bminA + bdeltaA;\n\n  vec2 bminB = vec2(1.0 - w - borderx, bordery);\n  vec2 bdeltaB = vec2(w, h);\n  vec2 bmaxB = bminB + bdeltaB;\n\n  float unitScale = 1.0 / bdeltaA.x;\n  int numGrid = 10;\n  float gridSize = 1.0 / float(numGrid);\n\n  float lineThickness = gridSize / 10.0;\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy;\n\n  vec3 col = vec3(0.4);\n\n  // hopefully colorblind friendly color palette\n  // color for full squish\n  vec3 c0 = vec3(0.0, 66.0, 157.0) / 255.0;\n  // color for no distortion\n  vec3 c1 = vec3(255.0, 255.0, 224.0) / 255.0;\n  // color for full stretch\n  vec3 c2 = vec3(147.0, 0.0, 58.0) / 255.0;\n\n  // arrow in the middle\n  float arrowDist =\n      sdArrow(screen2World(uv - vec2(0.5, 0.5), vec2(0.0), 1.0, aspect),\n              borderx, borderx / 2.0);\n\n  // first box -> original coordinate system\n  if (inside(uv, bminA, bmaxA)) {\n\n    // draw grid\n    col = c1;\n\n    vec2 relA = screen2World(uv, bminA, unitScale, aspect);\n\n    float dl = sdLines(relA.x, gridSize);\n    col *= gridColor(relA, gridSize, lineThickness, lineThickness);\n\n  } else if (inside(uv, bminB, bmaxB)) { // second box -> transformed\n\n    // point position\n    vec2 relB = screen2World(uv, bminB, unitScale, aspect);\n\n    // duration of showing one transform and for blending to the next\n    float durBlend = 3.0;\n    float durShow = 3.0;\n    float dur = durBlend + durShow;\n    float numFuncs = 5.0;\n\n    // compute function offset for time\n    float timeGrid = floor(iTime / dur);\n    int fIndex = int(mod(timeGrid, numFuncs));\n    float inDur = iTime - timeGrid * dur;\n    // start blending to the next after show duration is over\n    float blend = smoothstep(durShow, dur, inDur);\n\n    // inverse transform\n    vec2 relA;\n    mat2 J;\n\n    invtransform(relB, bminB, bdeltaB, bmaxB, unitScale, lineThickness, aspect,\n                 fIndex, blend, relA, J);\n\n    // distance in original system\n    float dl = sdLines(relA.x, gridSize);\n\n    // we want to show the stretch factor of the actual transform given by its\n    // Jacobian determinant as we computed the inverse, we can compute the\n    // original one by 1/det we do not care about reflections here, so we use\n    // the absolute value\n    float dJ = 1.0 / abs(determinant(J));\n\n    // for display show stretching in the intervals:\n    // [0,1) -> squish\n    // [1,2] -> stretch\n    // 1 -> no stretch\n    dJ = clamp(dJ, 0.0, 2.0);\n    if (dJ < 1.0) {\n      col = mix(c0, c1, smoothstep(0.0, 1.0, dJ));\n    } else {\n      col = mix(c1, c2, smoothstep(1.0, 2.0, dJ));\n    }\n\n    // just sampling the lines in the original space will make them small or\n    // large depending on the transforms stretching. Try to counteract that by\n    // computing the stretching of the base unit vectors. For this we need the\n    // original transform, so we invert the Jacobian. As it would get a bit\n    // crowded for many lines with lots of squishing, we only apply the\n    // correction up to a degree\n    mat2 Ji = inverse(J);\n    float thx = lineThickness / max(0.3, length(Ji[0]));\n    float thy = lineThickness / max(0.3, length(Ji[1]));\n\n    // color\n    col *= gridColor(relA, gridSize, thx, thy);\n\n  } else if (arrowDist < 0.0) {\n    // color in the middle arrow\n    col = vec3(1.0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "\n//********************************************************************\n//\n// Begin of automatic differentiation header\n// Full code with additional functions (gradients, jacobians, ...) can be found\n// at: https://github.com/sibaku/glsl-autodiff\n//\n//********************************************************************\n\n#ifndef GRADNUM_2_H_\n#define GRADNUM_2_H_\n\n// This file contains methods to compute the gradient of a scalar valued 2 dimensional\n// function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 2 dimensional function\n// These should be created by the constG2 (for constants) and varG2 (for variables) helpers\nstruct GNum2\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec2 g;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant GNum2\n* @param val The current value of the constant\n*/\nGNum2 constG2(in float val);\nGNum2 varG2(in float val, in int index);\nGNum2 varG2x(in float val);\nGNum2 varG2y(in float val);\nGNum2 add(in GNum2 a, in GNum2 b);\nGNum2 add(in GNum2 a, in float b);\nGNum2 add(in float a, in GNum2 b);\nGNum2 sub(in GNum2 a, in GNum2 b);\nGNum2 sub(in GNum2 a, in float b);\nGNum2 sub(in float a, in GNum2 b);\nGNum2 mult(in GNum2 a, in GNum2 b);\nGNum2 mult(in GNum2 a, in float b);\nGNum2 mult(in float a, in GNum2 b);\nGNum2 neg(in GNum2 a);\nGNum2 div(in GNum2 a, in GNum2 b);\nGNum2 div(in GNum2 a, in float b);\nGNum2 div(in float a, in GNum2 b);\nGNum2 inv(in GNum2 a);\nGNum2 a_pow(in GNum2 a, in GNum2 b);\nGNum2 a_pow(in GNum2 a, in float b);\nGNum2 a_pow(in float a, in GNum2 b);\nGNum2 a_min(in GNum2 a, in GNum2 b);\nGNum2 a_max(in GNum2 a, in GNum2 b);\nGNum2 a_exp2(in GNum2 a);\nGNum2 a_inversesqrt(in GNum2 a);\nGNum2 a_atan(in GNum2 a);\nGNum2 a_sqrt(in GNum2 a);\nGNum2 a_sinh(in GNum2 a);\nGNum2 a_ceil(in GNum2 a);\nGNum2 a_tan(in GNum2 a);\nGNum2 a_asinh(in GNum2 a);\nGNum2 a_asin(in GNum2 a);\nGNum2 a_acosh(in GNum2 a);\nGNum2 a_abs(in GNum2 a);\nGNum2 a_exp(in GNum2 a);\nGNum2 a_cosh(in GNum2 a);\nGNum2 a_floor(in GNum2 a);\nGNum2 a_log(in GNum2 a);\nGNum2 a_atanh(in GNum2 a);\nGNum2 a_log2(in GNum2 a);\nGNum2 a_acos(in GNum2 a);\nGNum2 a_tanh(in GNum2 a);\nGNum2 a_cos(in GNum2 a);\nGNum2 a_sin(in GNum2 a);\nGNum2 a_atan2(in GNum2 y, in GNum2 x);\nGNum2 a_atan2(in GNum2 y, in float x);\nGNum2 a_atan2(in float y, in GNum2 x);\nGNum2 a_mix(in GNum2 a, in GNum2 b, in GNum2 t);\nGNum2 a_mix(in GNum2 a, in GNum2 b, in float t);\nGNum2 a_mix(in GNum2 a, in float b, in GNum2 t);\nGNum2 a_mix(in GNum2 a, in float b, in float t);\nGNum2 a_mix(in float a, in GNum2 b, in GNum2 t);\nGNum2 a_mix(in float a, in GNum2 b, in float t);\nGNum2 a_mix(in float a, in float b, in GNum2 t);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define GRAD2(f,x, y,result)  {     result = f(varG2x(x), varG2y(y)); }\n//--------------------------------\n#define JACOBI2(f1, f2, x, y, result)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult);     result[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult);     result[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI2_VALUE(f1, f2, x, y, result, value)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult); \tvalue[0] = gradResult.val; \tresult[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult); \tvalue[1] = gradResult.val; \tresult[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI32(f1, f2, f3, x, y, result)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult);     result[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult);     result[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  \tGRAD2(f3, x, y, gradResult);     result[0][2] = gradResult.g[0]; \tresult[1][2] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI32_VALUE(f1, f2, f3, x, y, result, value)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult); \tvalue[0] = gradResult.val; \tresult[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult); \tvalue[1] = gradResult.val; \tresult[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  \tGRAD2(f3, x, y, gradResult); \tvalue[2] = gradResult.val; \tresult[0][2] = gradResult.g[0]; \tresult[1][2] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI42(f1, f2, f3, f4, x, y, result)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult);     result[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult);     result[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  \tGRAD2(f3, x, y, gradResult);     result[0][2] = gradResult.g[0]; \tresult[1][2] = gradResult.g[1];  \tGRAD2(f4, x, y, gradResult);     result[0][3] = gradResult.g[0]; \tresult[1][3] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI42_VALUE(f1, f2, f3, f4, x, y, result, value)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult); \tvalue[0] = gradResult.val; \tresult[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult); \tvalue[1] = gradResult.val; \tresult[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  \tGRAD2(f3, x, y, gradResult); \tvalue[2] = gradResult.val; \tresult[0][2] = gradResult.g[0]; \tresult[1][2] = gradResult.g[1];  \tGRAD2(f4, x, y, gradResult); \tvalue[3] = gradResult.val; \tresult[0][3] = gradResult.g[0]; \tresult[1][3] = gradResult.g[1];  }\n\n//--------------------------------\n// Implementation\n//--------------------------------\n\nGNum2 constG2(in float val)\n{\n    return GNum2(val, vec2(0.0));\n}\n//--------------------------------\nGNum2 varG2(in float val, in int index)\n{   \n    vec2 g = vec2(0.0);\n    g[index] = 1.0;\n    return GNum2(val, g);\n}\n//--------------------------------\nGNum2 varG2x(in float val)\n{   \n    vec2 g = vec2(0.0);\n    g[0] = 1.0;\n    return GNum2(val, g);\n}\n//--------------------------------\nGNum2 varG2y(in float val)\n{   \n    vec2 g = vec2(0.0);\n    g[1] = 1.0;\n    return GNum2(val, g);\n}\n//--------------------------------\nGNum2 add(in GNum2 a, in GNum2 b)\n{\n    return GNum2(a.val + b.val, a.g + b.g);\n}\n//--------------------------------\nGNum2 add(in GNum2 a, in float b)\n{\n    return GNum2(a.val + b, a.g);\n}\n//--------------------------------\nGNum2 add(in float a, in GNum2 b)\n{\n    return GNum2(a + b.val, b.g);\n}\n//--------------------------------\nGNum2 sub(in GNum2 a, in GNum2 b)\n{\n    return GNum2(a.val - b.val, a.g - b.g);\n}\n//--------------------------------\nGNum2 sub(in GNum2 a, in float b)\n{\n    return GNum2(a.val - b, a.g);\n}\n//--------------------------------\nGNum2 sub(in float a, in GNum2 b)\n{\n    return GNum2(a - b.val, -b.g);\n}\n//--------------------------------\nGNum2 mult(in GNum2 a, in GNum2 b)\n{\n    return GNum2(a.val * b.val, \n        a.val*b.g + b.val*a.g\n        );\n}\n//--------------------------------\nGNum2 mult(in GNum2 a, in float b)\n{\n    return GNum2(a.val * b, b*a.g);\n}\n//--------------------------------\nGNum2 mult(in float a, in GNum2 b)\n{\n    return GNum2(a * b.val, a*b.g);\n}\n//--------------------------------\nGNum2 neg(in GNum2 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nGNum2 div(in GNum2 a, in GNum2 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n\n    return GNum2(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2\n    );\n}\n//--------------------------------\nGNum2 div(in GNum2 a, in float b)\n{\n    return GNum2(a.val / b, a.g/b);\n}\n//--------------------------------\nGNum2 div(in float a, in GNum2 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n\n    return GNum2(a / b.val, \n        -a*b.g/b2\n    );\n}\n//--------------------------------\nGNum2 inv(in GNum2 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nGNum2 a_pow(in GNum2 a, in GNum2 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nGNum2 a_pow(in GNum2 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_pow(in float a, in GNum2 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n//--------------------------------\nGNum2 a_min(in GNum2 a, in GNum2 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nGNum2 a_max(in GNum2 a, in GNum2 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nGNum2 a_exp2(in GNum2 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_inversesqrt(in GNum2 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_atan(in GNum2 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_sqrt(in GNum2 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_sinh(in GNum2 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_ceil(in GNum2 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_tan(in GNum2 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_asinh(in GNum2 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_asin(in GNum2 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_acosh(in GNum2 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_abs(in GNum2 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_exp(in GNum2 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_cosh(in GNum2 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_floor(in GNum2 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_log(in GNum2 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_atanh(in GNum2 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_log2(in GNum2 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_acos(in GNum2 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_tanh(in GNum2 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_cos(in GNum2 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_sin(in GNum2 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_atan2(in GNum2 y, in GNum2 x)\n{\n    const float pi = 3.14159265; \n    // from https://en.wikipedia.org/wiki/Atan2\n    if(x.val > 0.0)\n    {\n        GNum2 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        GNum2 inner = div(y, add(n,x));\n        \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > 1E-6)\n    {\n        GNum2 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        GNum2 inner = div(sub(n,x),y);\n         return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= 1E-6)\n    {\n        return constG2(pi);\n    }\n    // return 0 for undefined\n    return constG2(0.0); \n}\n//--------------------------------\nGNum2 a_atan2(in GNum2 y, in float x)\n{\n    return a_atan2(y,constG2(x));\n}\n//--------------------------------\nGNum2 a_atan2(in float y, in GNum2 x)\n{\n    return a_atan2(constG2(y),x);\n}\n//--------------------------------\nGNum2 a_mix(in GNum2 a, in GNum2 b, in GNum2 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in GNum2 a, in GNum2 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in GNum2 a, in float b, in GNum2 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in GNum2 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n\n//--------------------------------\nGNum2 a_mix(in float a, in GNum2 b, in GNum2 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in float a, in GNum2 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in float a, in float b, in GNum2 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n\n#endif // GRADNUM_2_H_", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 80, 123, 123, 189], [191, 247, 286, 286, 415], [417, 522, 595, 595, 806], [808, 879, 950, 950, 1017], [1019, 1066, 1101, 1101, 1149], [1150, 1198, 1237, 1237, 1261], [1263, 1448, 1646, 1674, 3009], [3011, 3026, 3049, 3049, 3127], [3128, 3187, 3222, 3222, 3303], [3304, 3363, 3412, 3412, 3717], [3719, 3751, 3792, 3792, 4027], [4029, 4029, 4084, 4084, 7645]]}
{"id": "7dtGzN", "name": "Persian rug patterns 2", "author": "jarble", "description": "These rug-like patterns are generated using triangle waves with a pseudorandom hash function.", "tags": ["fractal", "rug"], "likes": 8, "viewed": 244, "published": 3, "date": "1629317242", "time_retrieved": "2024-07-30T19:05:51.056148", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.5,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 12.0;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = floor((iTime)/10.0+uv.x);\n\n    for(int c=0;c<3;c++){\n        float t3 = t2 + float(c);\n        float scale = c1.z;\n        float scale1 = 1.0;\n        vec3 random1 = hash31(t3)*10.;\n        //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n        vec3 random3 = (hash31(2.+t3)-vec3(.5))/4.;\n        vec3 random4 = (hash31(3.+t3)-vec3(.5))/4.;\n    \n        float offset = .16+random4.z*.04;\n        float scale2 = 1.16+.04*random4.y;\n        for(int i=0;i<3;i++)\n        {\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            //uv.x *= -1.0;\n\n            uv = triangle_wave(uv+random1.x,scale+random3.z);\n            //uv.x /= -1.0;\n            \n            uv = triangle_wave(uv+random1.y,scale+random3.y);\n            //uv.x *= -1.0;\n \n            uv = triangle_wave(uv+random1.z,scale+random3.z);\n            uv.x /= -1.;\n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= scale2+col.x;\n            offset *= scale2/(1.+random4.x);\n            \n            //uv = uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/2.;\n            random1 = random3+hash31(col.x/4.)/4.;\n            random3 = random4+hash31(col.y/4.)/4.;\n            random4 = random1+hash31(col.z/4.)/4.;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 387, 409, 455, 588], [591, 591, 630, 630, 675], [677, 677, 734, 734, 2320]]}
{"id": "7dtGR8", "name": "Classical black hole raytracer", "author": "copperbotte", "description": "This simulates a black hole as if it was an entirely classical effect, if light had mass. Also has light fall downwards due to a very weak gravity.", "tags": ["raytracing", "physics"], "likes": 5, "viewed": 396, "published": 3, "date": "1629312821", "time_retrieved": "2024-07-30T19:05:52.012591", "image_code": "\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\n//another random number generator\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\nfloat hashrandom( float x )\n{\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n\n//color space transforms\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//random point in sphere\nvec3 randSphere()\n{\n    float xi1 = rnd() * 2.0 - 1.0;\n    float xi2 = rnd();\n\n    float theta = xi2 * 2.0 * 3.141592;\n    float sinp = sqrt(1.0 - xi1*xi1);\n\n    float x = sinp * cos(theta);\n    float y = sinp * sin(theta);\n    float z = xi1;\n\n    return vec3(x, y, z);\n}\nvec3 sampleSphere(vec3 normal, out float pdf)\n{\n  \tpdf = 1.0;\n    vec3 rOut = randSphere();\n    \n    if(dot(rOut, normal) < 0.0)\n        rOut = reflect(rOut, normal);\n    \n    //should these be packed into the sampler?\n    //float pdf = 1.0; // no numerator pdf\n    pdf /= 2.0 * 3.141592; // 4pi r^2 / 2, half a sphere's area (clamped)\n    \n    return rOut;\n}\n\n//events are in the form of (x,y,z,t) for ease of programming.\nconst float c = 1.0; //c is merely a scaling factor for r anyway, so using natural units haha\n\nmat4 trace(vec4 tr)\n{\n    mat4 m = mat4(0.0);\n    for(int n=0; n<4; ++n)\n        m[n][n] = tr[n];\n    return m;\n}\n\nvec4 toPolar(vec4 event)\n{\n    vec3 x = event.xzy;\n    float r = length(x);\n    float xyr = length(x.xy);\n    float theta = acos(x.z/xyr);\n    float psi = atan(x.y, x.x);\n    return vec4(r, theta, psi, event.w);\n}\n\nvec4 toEuclid(vec4 p_event)\n{\n    float r = p_event.x;\n    float theta = p_event.y;\n    float psi = p_event.z;\n    \n    float x = r*sin(theta)*cos(psi);\n    float y = r*sin(theta)*sin(psi);\n    float z = r*cos(theta);\n    \n    return vec4(x, z, y, p_event.w);\n}\n\n//calculates the schwarzchild metric for a given 3-vector r measured from an observing coordinate frame.\n//inputs a minkowski event x, and a schwartzchild radius r. \n//returns a 4x4 minkowski metric.\nmat4 schwarzschildMetric(vec4 x, float r)\n{\n    float k = 1.0 - r / length(x.xyz);  \n    \n    vec2 tr = vec2(-k, 1.0/k);\n    //rotate this into minkowski coordinates to eliminate pole problems\n    \n    //for now, rotate coodinate into spherical polar coodinates\n    vec4 rtp_ct = toPolar(x);\n    \n    return mat4(1.0);    \n}\n\n\nmat4 p_schwarzschildMetric(vec4 rtp_ct, float r)\n{\n    float k = 1.0 - r / rtp_ct.x;\n    float r2 = rtp_ct.x * rtp_ct.x;\n    \n    vec4 tr = vec4(1.0/k, r2, r2*sin(rtp_ct.y), -k);\n    mat4 metric = trace(tr);\n    return metric;\n}\n\nbool hitPlane(vec3 p0, vec3 p1, vec3 normal, float offset, out vec3 hit)\n{\n    float d0 = dot(p0, normal) - offset;\n    float d1 = dot(p1, normal) - offset;\n    if(sign(d0) == sign(d1))\n        return false;\n\n    //intermediate value theorem\n    float s = (offset-d0) / (d1-d0);\n    vec3 dp = p1 - p0;\n    hit = dp*s + p0;\n    return true;\n}\n\nbool hitAccrete(vec3 p0, vec3 p1, out vec3 hit)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    \n    float theta = 3.141592 / 4.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    \n    vec3 x0 = vec3(0,-0.1,0);\n    \n    vec3 normal = normalize(vec3(0,0,1));\n    normal = rotate * normal;\n    vec3 s_hit;\n    if(!hitPlane(p0-x0, p1-x0, normal, 0.0, s_hit))\n        return false;\n    \n    float lh = length(s_hit);\n    if(lh < 0.5 || 1.0 < lh)\n        return false;\n    \n    hit = s_hit;\n    return true;\n}\n\nbool hitFloor(vec3 p0, vec3 p1, out vec3 hit)\n{\n    //find if p0 and p1 lie on opposite sides of the xy plane\n    vec3 x0 = vec3(0,-0.25,0);\n    //x0.y = sin(iTime * 3.141592 / 5.0);\n    vec3 normal = normalize(vec3(0,1,0));\n    \n    vec3 s_hit;\n    if(!hitPlane(p0, p1, normal, dot(normal, x0), s_hit))\n        return false;\n    \n    float planesize = 40000.0;\n    \n    if(planesize < abs(s_hit.x) || planesize < abs(s_hit.z))\n        return false;\n     \n    hit = s_hit;\n    return true;\n}\n\nvec3 colorAccrete(vec3 hit)\n{\n    float theta = 3.141592 / 4.0;\n    mat3 rotate = mat3(vec3(1.0, 0.0, 0.0),\n                       vec3(0.0, cos(theta), -sin(theta)),\n                       vec3(0.0, sin(theta), cos(theta)));\n    hit = rotate * hit;\n\n    float angle = atan(hit.z, hit.x);\n    angle /= 3.141592;\n    angle *= 4.0;\n    bool color = 0.5 < angle - floor(angle);\n    float radius = length(hit.xz);\n    radius = (radius - 0.5)/(1.0 - 0.5);\n    radius *= 1.0;\n    color = color != (0.5 < radius - floor(radius));\n    \n    if(color)\n        return vec3(0.75,0.75,0.75);\n    else\n        return vec3(0.25,0.25,0.25);\n}\n\nvec3 colorPlane(vec3 hit)\n{\n    //vec2 pos = hit.xz / 2.0;\n    //vec2 pos = hit.xz * 4.0;\n\n    //bool color = 0.5 < mod(pos.x, 1.0);\n    //color = color != 0.5 < mod(pos.y, 1.0);\n    \n    //if(color)\n    //    return vec3(0.75,0.25,0.25);\n    //else\n    //    return vec3(0.25,0.0625,0.0625);\n    \n    vec2 pos = hit.xz / 8.0;\n    vec2 t_uv = mod(pos, 1.0);\n    ivec2 xor = ivec2(t_uv * 256.0);\n    float c = float(xor.x ^ xor.y) / 256.0;\n    \n    vec3 highColor = vec3(0.75,0.25,0.25);\n    vec3 lowColor = highColor * 0.25;\n    \n    vec3 albedo = mix(lowColor, highColor, c);\n    return albedo;\n    float mass = .25;\n    \n    float m = 1.0;\n    float s0 = 1.0;\n    \n    vec3 wsum = vec3(0);\n    const int lsamples = 10;\n    for(int j=0; j<lsamples; ++j)\n    {\n        float pdf;\n        vec3 vel0 = s0*sampleSphere(vec3(0,0,1), pdf);\n        float lambert = dot(vel0, vec3(0,0,1)) / 3.141592;\n        vec3 src0 = hit;\n        vec3 src = hit;\n        vec3 vel = vel0;\n        for(int i=0; i<256; ++i)\n        {\n            float dt = 0.1;\n            dt = dot(src, src); //based on distance to save on resources\n            dt /= 500.0; \n            dt = max(0.1, dt);\n            vec3 force = -mass * normalize(src) / dot(src, src);\n            //force *= 0.25;\n            //force *= -1.0;\n\n            //as if light had mass, effected by earth\n            //force += 0.001*m*9.807*vec3(0,-1,0);\n\n            //force *= 0.0;\n\n\n            vel += force * dt;\n\n            src0 = src;\n            src += vel * dt;\n\n            if(10000.0 < length(src))\n            {\n                float hitsun = dot(normalize(vel), normalize(vec3(0,0,1)));\n                hitsun = max(0.0, hitsun);\n                hitsun = pow(hitsun, 30.0);\n            \n                wsum += lambert*vec3(hitsun);//texture(iChannel0, vel).xyz;\n                //wsum += lambert*texture(iChannel0, vel).xyz;\n                break;\n            }\n\n            if(length(src) < mass * 0.2 / 0.25) // this is an artistically tuned value haha\n            {\n                wsum += lambert*vec3(0,0,0);\n                break;\n            }\n\n            if(hitFloor(src0, src, src0))\n            {\n                wsum += lambert*vec3(0,0,0);\n                break;\n            }\n\n            if(hitAccrete(src0, src, src0))\n            {\n                wsum += lambert*colorAccrete(src0);\n                break;\n            }\n\n        }\n    }\n    \n    return 100.0*albedo*wsum/float(lsamples);\n}\n\nvec3 render( in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    //uv /= 5.0;\n    \n    //view rotation matrix\n    //yaw\n    float theta = 3.141592 * iTime / (2.0 * 5.0);\n    //theta = 0.0;\n    mat3 yaw = mat3(vec3(cos(theta), 0.0, -sin(theta)),\n                       vec3(0.0, 1.0, 0.0),\n                       vec3(sin(theta), 0.0, cos(theta)));\n                       \n    //pitch\n    theta = 3.141592 * (0.25 / 2.0);\n    //theta = 0.0;\n    theta = 0.1;\n    mat3 pitch = mat3(vec3(1.0, 0.0, 0.0),\n                      vec3(0.0, cos(theta), sin(theta)),\n                      vec3(0.0,-sin(theta), cos(theta)));\n    \n    mat3 view = yaw * pitch;\n    \n    vec3 dir = normalize(vec3(uv.xy, 1.0));\n    vec3 src = vec3(0.0, 0.0, -10.0);\n    \n    dir = view * dir;\n    src = view * src;\n    //src += dir;\n    \n    vec4 src_t = vec4(src, length(src));\n    \n    //vec4 p_src = toPolar(vec4(src, 0.0));\n    \n    //return vec3(abs(p_src.yz), 0.0);\n    //GR Step\n    \n    //vec4 e_src = toEuclidean(p_src);\n    float R = length(src_t.xyz);\n    float kp = 1.0 + 1.0/(4.0*R);\n    float kn = 1.0 - 1.0/(4.0*R);\n    \n    float sp = kp*kp*kp*kp;\n    float st = -(kn*kn)/(kp*kp);\n    \n    mat4x4 metric = trace(vec4(sp, sp, sp, st));\n    \n    vec3 col = texture(iChannel0, dir).xyz;\n    \n    float mass = .25;\n    //mass = sin(iTime * 3.141592 / 10.0);\n    \n    if(true)\n    {\n    \n    //\"classical\" relativity\n    float m = 1.0;\n    float s0 = 1.0;\n    vec3 vel = dir*s0;\n    \n    vec3 src0 = src;\n    \n    for(int i=0; i<256; ++i)\n    {\n        float dt = 0.1;\n        dt = dot(src, src); //based on distance to save on resources\n        dt /= 500.0; \n        dt = max(0.1, dt);\n        vec3 force = -mass * normalize(src) / dot(src, src);\n        //force *= 0.25;\n        //force *= -1.0;\n\n        //as if light had mass, effected by earth\n        //force += 0.001*m*9.807*vec3(0,-1,0);\n\n        //force *= 0.0;\n        \n        \n        vel += force * dt;\n        \n        src0 = src;\n        src += vel * dt;\n        \n        col = texture(iChannel0, vel).xyz;\n        \n        if(10000.0 < length(src))\n            return col;\n        \n        if(length(src) < mass * 0.2 / 0.25) // this is an artistically tuned value haha\n            return vec3(0,0,0);\n            \n        if(hitFloor(src0, src, src0))\n            return colorPlane(src0);\n            \n        if(hitAccrete(src0, src, src0))\n            return colorAccrete(src0);\n    }\n    \n    if(length(src) < 1.0)\n        return vec3(0,0,0);\n    \n    dir = normalize(vel);\n    \n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 col = render(fragCoord);\n    vec3 col = vec3(0.0);\n    \n    seed = hashrandom(iTime + iResolution.y * fragCoord.x + fragCoord.y);\n    \n    bool AntiAlias = true;\n    if(AntiAlias)\n    {\n        const int samples = 4;\n        for(int i=0; i<samples; ++i)\n            col += srgb2lsrgb(render(fragCoord + ((vec2(rnd(), rnd())-0.5))));\n        //for(int i=0; i<4; ++i)\n        //    for(int j=0; j<4; ++j)\n        //        col += srgb2lsrgb(render(fragCoord + ((vec2(i, j)-1.0) / 4.0)));\n        col /= float(samples);\n    }else{\n        col = render(fragCoord);\n    }\n    \n    fragColor = vec4(lsrgb2srgb(col),1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 93, 106, 106, 149], [151, 334, 355, 355, 486], [488, 646, 678, 678, 1098], [1100, 1149, 1178, 1178, 1233], [1236, 1261, 1295, 1295, 1422], [1424, 1424, 1456, 1456, 1536], [1538, 1538, 1571, 1571, 1691], [1693, 1693, 1724, 1724, 1801], [1803, 1828, 1847, 1847, 2099], [2100, 2100, 2147, 2147, 2459], [2619, 2619, 2640, 2640, 2732], [2734, 2734, 2760, 2760, 2947], [2949, 2949, 2978, 2978, 3210], [3212, 3412, 3455, 3455, 3736], [3739, 3739, 3789, 3789, 3967], [3969, 3969, 4043, 4043, 4310], [4312, 4312, 4361, 4423, 4953], [4955, 4955, 5002, 5064, 5446], [5448, 5448, 5477, 5477, 6074], [6076, 6076, 6103, 6368, 8540], [8542, 8542, 8576, 8626, 11230], [11233, 11233, 11290, 11326, 11918]]}
{"id": "7dd3z4", "name": "Inverse Scanline Barycentric", "author": "oneshade", "description": "Testing an idea for calculating barycentric coordinates before implementing in a 3D software renderer I'm working on. Not great method for shaders but the idea should be more efficient in my triangle rasterizer.", "tags": ["scanline", "inverse", "interpolationbarycentric"], "likes": 7, "viewed": 162, "published": 3, "date": "1629307444", "time_retrieved": "2024-07-30T19:05:52.760591", "image_code": "// Utilities\n#define draw(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\nstruct Vertex { float x; float y; vec3 uv; };\n#define makeVertex(pos, uv) Vertex((pos).x, (pos).y, uv)\n#define swap(a, b) { tmp = a, a = b, b = tmp; }\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n\n    float co = cos(iTime), si = sin(iTime);\n    mat2 rot = mat2(co, si, -si, co);\n\n    Vertex a = makeVertex(rot * vec2(cos(      iTime) * 0.5 - 1.0, sin(      iTime) * 0.5 + 1.0), vec3(1.0, 0.0, 0.0));\n    Vertex b = makeVertex(rot * vec2(sin(3.0 * iTime) * 0.2 - 1.0, cos(3.0 * iTime) * 0.2 - 1.0), vec3(0.0, 1.0, 0.0));\n    Vertex c = makeVertex(rot * vec2(cos(2.0 * iTime) * 0.5 + 1.0, sin(2.0 * iTime) * 0.5 - 1.0), vec3(0.0, 0.0, 1.0));\n\n    // Sort vertices in ascending order of the y coordinate\n    Vertex tmp;\n    if (b.y < a.y) swap(a, b);\n    if (c.y < b.y) {\n        if (c.y < a.y) swap(a, c);\n        swap(b, c);\n    }\n\n    // Find the second middle point (across from the middle vertex on the long edge)\n    float tMid = (b.y - a.y) / (c.y - a.y);\n    Vertex mid = Vertex(mix(a.x, c.x, tMid), b.y, mix(a.uv, c.uv, tMid));\n    if (mid.x > b.x) swap(b, mid);\n\n    vec3 bary = vec3(0.0);\n    bool inside = false;\n    if (a.y < uv.y && uv.y < b.y) { // Lower half of the triangle\n        float tA = (uv.y - a.y) / (mid.y - a.y);\n        vec3 baryA = mix(a.uv, mid.uv, tA); // Interpolate UVs along the left edge\n        float isectA = mix(a.x, mid.x, tA); // Left edge intersection\n\n        float tB = (uv.y - a.y) / (b.y - a.y);\n        vec3 baryB = mix(a.uv, b.uv, tB); // Interpolate UVs along the right edge\n        float isectB = mix(a.x, b.x, tB); // Right edge intersection\n\n        bary = mix(baryA, baryB, (uv.x - isectA) / (isectB - isectA)); // Interpolate between the intersections\n        inside = isectA < uv.x && uv.x < isectB;//\n        fragColor.r += 0.5 * float(!inside);//\n    }\n\n    if (b.y < uv.y && uv.y < c.y) { // Upper half of the triangle\n        float tA = (uv.y - mid.y) / (c.y - mid.y);\n        vec3 baryA = mix(mid.uv, c.uv, tA); // Interpolate UVs along the left edge\n        float isectA = mix(mid.x, c.x, tA); // Left edge intersection\n\n        float tB = (uv.y - b.y) / (c.y - b.y);\n        vec3 baryB = mix(b.uv, c.uv, tB); // Interpolate UVs along the right edge\n        float isectB = mix(b.x, c.x, tB);; // Right edge intersection\n\n        bary = mix(baryA, baryB, (uv.x - isectA) / (isectB - isectA)); // Interpolate between the intersections\n        inside = isectA < uv.x && uv.x < isectB;//\n        fragColor.b += 0.5 * float(!inside);//\n    }\n\n    fragColor += vec4(inside ? bary : vec3(0.0), 1.0);\n}\n\n// Supersampled antialiasing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord);\n    render(fragColor, fragCoord + vec2(0.5, 0.0));\n    render(fragColor, fragCoord + vec2(0.0, 0.5));\n    render(fragColor, fragCoord + vec2(0.5, 0.5));\n    fragColor /= 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dd3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 297, 297, 2725], [2727, 2756, 2811, 2811, 3049]]}
{"id": "7tBSR1", "name": "Rave Lasers", "author": "R3N", "description": "Lasers and fog machines", "tags": ["light", "smoke", "laser"], "likes": 44, "viewed": 1521, "published": 3, "date": "1629301539", "time_retrieved": "2024-07-30T19:05:53.510586", "image_code": "// rand [0,1] https://www.shadertoy.com/view/4djSRW\nfloat rand(vec2 p) {\n    p *= 500.0;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// value noise\nfloat noise(vec2 p) {\n\tvec2 f = smoothstep(0.0, 1.0, fract(p));\n\tvec2 i = floor(p);\n\tfloat a = rand(i);\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n// fractal noise\nfloat fbm(vec2 p) {\n    float a = 0.5;\n    float r = 0.0;\n    for (int i = 0; i < 8; i++) {\n        r += a*noise(p);\n        a *= 0.5;\n        p *= 2.0;\n    }\n    return r;\n}\n\n// lasers originating from a central point\nfloat laser(vec2 p, int num) {\n\tfloat r = atan(p.x, p.y);\n\tfloat sn = sin(r*float(num)+iTime);\n    float lzr = 0.5+0.5*sn;\n    lzr = lzr*lzr*lzr*lzr*lzr;\n    float glow = pow(clamp(sn, 0.0, 1.0),100.0);\n\treturn lzr+glow;\n}\n\n// mix of fractal noises to simulate fog\nfloat clouds(vec2 uv) {\n    vec2 t = vec2(0,iTime);\n\tfloat c1 = fbm(fbm(uv*3.0)*0.75+uv*3.0+t/3.0);\n\tfloat c2 = fbm(fbm(uv*2.0)*0.5+uv*7.0+t/3.0);\n\tfloat c3 = fbm(fbm(uv*10.0-t)*0.75+uv*5.0+t/6.0);\n    float r = mix(c1, c2, c3*c3);\n\treturn r*r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 hs = iResolution.xy/iResolution.y*0.5;\n    vec2 uvc = uv-hs;\n\tfloat l = (1.0 + 3.0*noise(vec2(15.0-iTime)))\n        * laser(vec2(uv.x+0.5, uv.y*(0.5 + 10.0*noise(vec2(iTime/5.0))) + 0.1), 15);\n\tl += fbm(vec2(2.0*iTime))\n        * laser(vec2(hs.x-uvc.x-0.2, uv.y+0.1), 25);\n\tl += noise(vec2(iTime-73.0))\n        * laser(vec2(uvc.x, 1.0-uv.y+0.5), 30);\n    float c = clouds(uv);\n    vec4 col = vec4(0, 1, 0, 1)*(uv.y*l+uv.y*uv.y)*c;\n    fragColor = pow(col, vec4(0.75));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 72, 72, 205], [207, 222, 243, 243, 479], [481, 498, 517, 517, 672], [674, 717, 747, 747, 939], [941, 982, 1005, 1005, 1228], [1230, 1230, 1286, 1286, 1805]]}
{"id": "sdd3R4", "name": "Conformal Torus Texture Mapping2", "author": "FabriceNeyret2", "description": "right: naive tiling of the torus\nleft: conformal mapping\n( simpler approach than https://www.shadertoy.com/view/tdGfzz )", "tags": ["torus", "uv", "conformal", "short"], "likes": 29, "viewed": 620, "published": 3, "date": "1629297421", "time_retrieved": "2024-07-30T19:05:54.268559", "image_code": "#define hue(v)  ( .6 + .6 * cos( v  + vec4(0,23,21,0)  ) )    // hue\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )              // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,d,  k = 2., // .9                              // tile multiplier\n          R0 = 20., R1 = 10.;                                 // large and small radii\n\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 90./R, q,                                       // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p,\n        q.yz *= rot( .5+6.*M.y),                              // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        t = min(9., length(vec2(d=length(q.xz)-R0,q.y)) - R1),// abs for inside + outside\n        p += t*D;                                             // step forward = dist to obj          \n\n    O = O.x > 1. ? vec4(0.) : exp(-3.*O/2.);                  // luminance (depth + pseudo-shading )\n    float a = atan(q.z,q.x), b = atan(q.y,d);\n    \n    if (U.x < R.x/2. ) {                                     // left: conformal mapping\n     // b -= R1/R0 * sin(b); //  wrong (or approx): antiderivative of circonf(b)\n        float r = R1/R0, ir = sqrt(1.-r*r);       // antiderivative of 1/circonf(b) \n        b = .996*  2./ir* atan( (r-1.)/ir* tan(b/2.) );        \n     //                                NB: tan(b/2) = ( -d + sqrt(d*d+q.y*q.y) )/q.y )        \n    }\n    O *= hue( floor(k*R0*a/6.283) + 17.*mod(round(k*R1*b/6.283),R1) ); // colored tiles \n\n    a = sin(k*R0*a/2.), b = cos(k*R1*b/2.);\n    O *= sqrt( min(abs(a)/fwidth(a),1.) * min( abs(b)/fwidth(b),1.) );// tiles borders\n    \n    if (int(U)==int(R/2.) ) O++;                              // vertical separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdd3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 198, 198, 1948]]}
{"id": "Nsd3RN", "name": "This Is Not A Reflected Pipe 2", "author": "dr2", "description": "The non-pipe again - now inside a reflecting pentakis dodecahedron", "tags": ["reflection", "art", "symmetry", "magritte", "pentakis"], "likes": 15, "viewed": 355, "published": 3, "date": "1629280445", "time_retrieved": "2024-07-30T19:05:55.019551", "image_code": "// \"This Is Not A Reflected Pipe 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  From \"This Is Not A Pipe\": This is clearly not Magritte's masterpiece.\n  But is the 3D form less 'not a pipe' than the original?\n*/\n\n#define AA  0  // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir;\nfloat dstFar, tCur, szFac;\nint idObj;\nconst int idFace = 1, idEdge = 2, idPipe = 3, idCoal = 4;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat PipeDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 rp;\n  float d;\n  dMin /= szFac;\n  p /= szFac;\n  p.x += 1.;\n  q = p;\n  d = SmoothMax (abs (PrCapsDf (q.xzy, 0.55, 0.25)) - 0.06, q.y - 0.5, 0.05);\n  q.y -= smoothstep (0.5, 2.5, q.x) - 0.5;\n  q.x -= 1.3;\n  rp = vec2 (0.1, 0.17) - vec2 (0.05, 0.06) * (q.x / 0.6 - 1.);\n  d = 0.5 * SmoothMin (d, max (SmoothMin (PrEllCylDf (q.yzx, rp, 1.2),\n     PrEllCylDf (q.yzx - vec3 (0., 0., 1.2), rp + 0.007, 0.007), 0.05),\n     0.03 - length (q.yz * vec2 (1.1, 0.35))), 0.12);\n  DMIN (idPipe);\n  q = p;\n  q.y -= 0.3;\n  d = PrCylDf (q.xzy, 0.5, 0.01);\n  DMIN (idCoal);\n  return szFac * dMin;\n}\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = 0; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.y = - abs (p.y);\n    p.zy = Rot2Cs (p.zy, csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, a1, a2, s;\n  dMin = dstFar;\n  dMin = PipeDf (p, dMin);\n  q = DodecSym (p);\n  a1 = 0.5 * acos (-1. / sqrt (5.));\n  a2 = 0.5 * acos (- (80. + 9. * sqrt (5.)) / 109.);\n  s = abs (dot (q.yz, sin (a1 - a2 + vec2 (0., 0.5 * pi))) + 2.);\n  d = SmoothMax (s - 0.07, min (dot (q.yz, sin (a1 - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.04, 0.05);\n  DMIN (idEdge);\n  d = s - 0.05;\n  DMIN (idFace);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat PipeSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = PipeDf (ro + d * rd, dstFar);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.02;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn, q;\n  float dstObj, sh;\n  int nRef;\n  const int maxRef = 4;\n  szFac = 0.3;\n  bgCol = vec3 (0.3, 0.25, 0.25);\n  col = bgCol;\n  nRef = 0;\n  for (int k = VAR_ZERO; k <= maxRef; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar && idObj == idFace) {\n      ro += dstObj * rd;\n      rd = reflect (rd, ObjNf (ro));\n      ro += 0.001 * rd;\n      nRef = k;\n    } else break;\n  }\n  if (dstObj < dstFar && idObj != idFace) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idEdge) {\n      col = vec3 (0.7, 0.7, 0.75) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n    } else {\n      q = ro / szFac;\n      if (idObj == idPipe) {\n        q.xy -= vec2 (0.4);\n        q.xy = Rot2D (q.xy, -0.2 * pi);\n        if (q.x < -0.03) vn = VaryNf (16. * q, vn, 0.1);\n        col = mix ((q.x < 0.) ? mix (vec3 (0.6, 0.3, 0.), vec3 (0.3, 0.1, 0.), 0.5 * Fbm3 (4. * q)) :\n           vec3 (0.1), vec3 (0.7, 0.6, 0.), SmoothBump (-0.03, 0.03, 0.01, q.x));\n        sh = PipeSShadow (ro, ltDir);\n        col = col * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n           0.2 * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      } else if (idObj == idCoal) {\n        col = mix (vec3 (0.8, 0., 0.) * (0.2 + 0.8 * smoothstep (0.1, 0.9, Fbm1 (0.5 * tCur))),\n           vec3 (0.1, 0., 0.), smoothstep (0.2, 0.7, Fbm2 (64. * q.xz)));\n      }\n    }\n    col = mix (bgCol, col, pow (0.9, 8. * float (nRef) / float (maxRef)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 1.);\n    t = (floor (32. * t) + smoothstep (0.8, 1., mod (32. * t, 1.))) / 32.;\n    az = pi * sin (2. * pi * t);\n    el = -0.1 * pi - 0.2 * pi * sin (4. * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -1.8);\n  zmFac = 3.;\n  dstFar = 10.;\n  ltDir = vuMat * normalize (vec3 (-1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsd3RN.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1062, 1062, 1097, 1097, 1694], [1696, 1696, 1720, 1720, 2270], [2272, 2272, 2294, 2294, 2769], [2771, 2771, 2804, 2804, 2988], [2990, 2990, 3011, 3011, 3266], [3268, 3268, 3306, 3306, 3547], [3549, 3549, 3584, 3584, 5112], [5114, 5114, 5170, 5170, 6333], [6335, 6335, 6377, 6377, 6428], [6430, 6430, 6473, 6473, 6537], [6539, 6539, 6583, 6583, 6658], [6660, 6660, 6705, 6705, 6797], [6799, 6799, 6844, 6844, 6882], [6884, 6884, 6941, 6941, 7024], [7026, 7026, 7056, 7056, 7169], [7171, 7171, 7202, 7202, 7266], [7268, 7268, 7304, 7304, 7510], [7544, 7544, 7568, 7568, 7621], [7623, 7623, 7647, 7647, 7759], [7761, 7761, 7785, 7785, 7928], [7930, 7930, 7955, 7955, 8101], [8103, 8103, 8128, 8128, 8314], [8316, 8316, 8341, 8341, 8566], [8568, 8568, 8590, 8590, 8744], [8746, 8746, 8767, 8767, 8922], [8924, 8924, 8945, 8945, 9100], [9102, 9102, 9131, 9131, 9343], [9345, 9345, 9384, 9384, 9641]]}
{"id": "tdGfzz", "name": "Conformal Torus Texture Map", "author": "mla", "description": "How to map UV coordinates onto a torus conformally. See code for controls.", "tags": ["torus", "uv", "conformal"], "likes": 25, "viewed": 960, "published": 3, "date": "1629278914", "time_retrieved": "2024-07-30T19:05:55.812431", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Conformal Torus UV Mapping\n//\n// The normal method of mapping UV coordinates onto a torus produces a\n// distorted pattern, elongating or compressing the pattern depending\n// on the location on the torus.\n//\n// This can be avoided by doing the UV mapping in 4-dimensional space,\n// then using stereographic projection to map conformally into 3-space.\n//\n// Apply a rotation in 4-space before projection transforms the torus\n// into a cyclide ('r' key). The UV mapping is still conformal though.\n//\n// <mouse>: change view\n// <up/down>: zoom in/out\n// <pageup>/<pagedown>: change torus proportions\n// <left/right>: change angle of pattern\n// 'r': R4 rotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec2 TRATIO = vec2(3,3); // R4 torus proportions\n\n// Inverse stereographic projection of p,\n// p4 lies onto the unit 3-sphere centered at 0.\n// k is scale factor\nvec4 inverseStereographic(vec3 p, out float k) {\n  // Invert in sphere radius = 2, centre (0,0,0,-1)\n  k = 2.0/(1.0+dot(p,p));\n  return vec4(k*p,k-1.0);\n}\n\nvec4 inverseStereographic(vec3 p) {\n  float k;\n  return inverseStereographic(p,k);\n}\n\n// Hypersphere is p.p = 1\n// Torus is (p.xy).(p.xy) = R^2 = 1-(p.zw).(p.zw) \nfloat fTorus(vec4 p4, float R) {\n  // Torus distance\n  // Distance from surface x^2 + y^2 = R^2\n  return abs(R-length(p4.xy));\n}\n\nvec4 quat = vec4(0,0,0,1);\n\nvec4 map4(vec3 p, out float k) {\n  vec4 p4 = inverseStereographic(p,k);\n  // Do a one sided quaternion rotation, otherwise known\n  // as a Clifford Translation, which seems appropriate.\n  if (key(CHAR_R)) p4 = qmul(p4,quat);\n  return p4;\n}\n\nvec4 map4(vec3 p) {\n  float k;\n  return map4(p,k);\n}\n\nfloat map(vec3 p) {\n  float k;\n  vec4 p4 = map4(p,k);\n  float R = sqrt(TRATIO.x*TRATIO.x/dot(TRATIO,TRATIO));\n  float d = fTorus(p4,R);\n  return d/k;\n}\n\nvec3 calcNormal(vec3 p) {\n  vec3 eps = vec3(1e-4,0,0);\n  vec3 n = vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                map(p + eps.yxy) - map(p - eps.yxy),\n                map(p + eps.yyx) - map(p - eps.yyx));\n  return normalize(n);\n}\n\nconst float ITER = 100.0;\nconst float MAX_DIST = 20.0;\n\nvec3 transform(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    //float phi = 0.1*iTime; //(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  p.yz = rotate(p.yz,-0.8);\n  return p;\n}\n\nvec3 getcolor(vec2 uv) {\n  //if (uv.x < 0.0 || uv.x > 1.0) return vec3(0);\n  //if (uv.y < 0.0 || uv.y > 1.0) return vec3(0);\n  float A = 3.0, B = 0.0;\n  if (false && iMouse.x > 0.0) {\n    A = floor(10.0*iMouse.x/iResolution.x);\n    B = floor(10.0*iMouse.y/iResolution.y);\n  }\n  B += float(keycount(KEY_LEFT)-keycount(KEY_RIGHT));\n  float theta = atan(B,A);\n\n  float k = sqrt(A*A+B*B);\n  uv *= k;\n  uv = rotate(uv,-theta);\n  if (key(CHAR_X)) uv.x += iTime;\n  if (!key(CHAR_Y)) uv.y += iTime;\n  vec2 index = floor(uv);\n  uv -= floor(uv);\n\n  vec2 X = vec2(B,A);\n  vec2 Y = vec2(A,-B);\n\n  //assert(idiv(idot(index,X),idot(X,X)) == 0);\n  //assert(idiv(idot(index,Y),idot(Y,Y)) == 0);\n  index -= X*idiv(dot(index,X),dot(X,X));\n  index -= Y*idiv(dot(index,Y),dot(Y,Y));\n  \n  uint h = ihash(uint(int(index.x)) ^ ihash(int(index.y)));// ^ ihash(uint(iTime));\n  vec3 color = hsv2rgb(0.6*float(h)/pow(2.0,32.0),1.0,0.5);\n  vec3 tcolor = texture(iChannel0,uv).xyz;\n  color *= dot(tcolor,vec3(1));\n\n  uv = min(uv,1.0-uv);\n  color = mix(vec3(0),color,smoothstep(0.01,0.02,uv.x));\n  color = mix(vec3(0),color,smoothstep(0.01,0.02,uv.y));\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 light = normalize(vec3(1,.5,0));\n  \n  float focalLength = 2.5;\n  vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n  //uv = rotate(uv,0.1*iTime);\n  //assert(uv.y > 0.0 && uv.x > 0.0);\n  vec3 p = vec3(2.0*uv, focalLength);\n  p = transform(p);\n\n  vec3 rayDirection = normalize(p);\n\n  float camera = 4.0;\n  camera *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  TRATIO.y += float(keycount(KEY_PAGE_UP)-keycount(KEY_PAGE_DOWN));\n  vec3 rayOrigin = vec3(0,0,-camera);\n  rayOrigin = transform(rayOrigin);\n  rayOrigin = rayOrigin;\n\n  light = transform(light);\n  \n  vec3 rayPosition = rayOrigin;\n  float rayLength = 0.0;\n\n  int aindex = 0;//keycount(KEY_PAGE_UP)-keycount(KEY_PAGE_DOWN);\n\n  vec3 axes[] = vec3[] (vec3(1,0,0), vec3(0,1,0), vec3(0,0,1), vec3(1,1,0),\n                        vec3(1,0,1), vec3(0,1,1), vec3(1,1,1));\n  aindex %= axes.length();\n  if (aindex < 0) aindex += axes.length();\n  vec3 axis = key(CHAR_R) ? vec3(1,0,0) : vec3(0,0,-1); //normalize(axes[aindex]);\n  quat = normalize(vec4(-sin(0.5*iTime)*axis,cos(0.5*iTime)));\n\n  vec3 color = vec3(0,0,0.1);\n  if (true) {\n    // Draw background\n    vec2 uv1 = 1.1*uv;\n    color = getcolor(uv1);\n    uv1 = fract(uv1);\n    uv1 = min(uv1,1.0-uv1);\n    color = mix(vec3(1),color,0.5+0.5*smoothstep(0.0,0.01,min(uv1.x,uv1.y)));\n  }\n  for (float i = 0.; i < ITER; i++) {\n    float distance = map(rayPosition);\n    if (distance/rayLength < .001) break;\n    if (rayLength > MAX_DIST) break;\n    //if (distance > 1.0) distance *= 0.5; else distance *= 0.8;\n    distance /= (1.0+0.5*distance);\n    rayLength += distance;\n    rayPosition = rayOrigin + rayDirection * rayLength;\n  }\n  if (rayLength <= MAX_DIST) {\n    vec3 normal = calcNormal(rayPosition);\n    {\n      vec4 p4 = map4(rayPosition);\n      vec2 uv = (vec2(atan(p4.x,p4.y), atan(p4.z,p4.w)))/(2.0*PI);\n      uv *= TRATIO; // Adjust for torus proportions\n      uv = fract(uv);\n      color = getcolor(uv);\n    }\n    color *= dot(light, normal) * .4 + .6;\n    float fog = pow(smoothstep(0.0, MAX_DIST, rayLength), 1.0);\n    color = mix(color, vec3(0), fog);\n    color *= mix(1., .025, fog);\n  }\n  color = pow(color, vec3(1. / 2.2)); // Gamma\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// Common\n////////////////////////////////////////////////////////////////////////////////\n\n//#define DEBUG\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuint ihash(int x) {\n  return ihash(uint(x));\n}\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\n#define PI 3.14159265359\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_G = 71;\nconst int CHAR_R = 82;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\n// This is a counterclockwise rotation with the usual axis directions\nvec2 rotate(vec2 p, float t) {\n    //return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\n\nvec4 qmul(vec4 p, vec4 q) {\n  return vec4(cross(p.xyz,q.xyz)+p.w*q.xyz+q.w*p.xyz,\n              p.w*q.w-dot(p.xyz,q.xyz));\n}\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nfloat idiv(float a, float b) {\n  // Float division producing an integer and with\n  // correct rounding for integral parameters.\n  float d = floor(a/b);\n  if (a-d*b < 0.0) d--;\n  if (a-d*b >= b)  d++;\n  return d;\n}", "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  } else if (i == 1) {\n    if (j == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (j == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[879, 991, 1039, 1093, 1147], [1149, 1149, 1184, 1184, 1233], [1235, 1312, 1344, 1407, 1440], [1470, 1470, 1502, 1502, 1709], [1711, 1711, 1730, 1730, 1763], [1765, 1765, 1784, 1784, 1916], [1918, 1918, 1943, 1943, 2157], [2215, 2215, 2239, 2239, 2576], [2578, 2578, 2602, 2702, 3718]]}
{"id": "Nst3R4", "name": "Persian rug patterns", "author": "jarble", "description": "This shader generates random patterns that resemble Persian rugs.", "tags": ["fractal", "rug"], "likes": 5, "viewed": 327, "published": 3, "date": "1629257212", "time_retrieved": "2024-07-30T19:05:56.560431", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(3.0+c2,2.5+c2,1.45,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n    //from David Hoskin's \"Hash without sine\"\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    \n\n    \n    vec3 col;  \n    float t1 = 3.;\n\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float t2 = floor((iTime)/10.0+uv.x);\n    vec3 random1 = hash31(t2)*10.;\n    //vec3 random2 = hash31(1.+floor((iTime)/10.0+uv.x));\n    vec3 random3 = (hash31(2.+t2)-vec3(.5))/4.;\n    vec3 random4 = (hash31(3.+t2)-vec3(.5))/4.;\n    \n    float offset = .16+random4.z*.04;\n    float scale2 = 1.16+.04*random4.y;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        float scale1 = 1.0;\n        for(int i=0;i<3;i++)\n        {\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            //uv.x *= -1.0;\n\n            uv = triangle_wave((uv+random1.x)/(random4.y*.0+1.),scale+random3.z);\n            //uv.x /= -1.0;\n            \n            uv = triangle_wave(uv+random1.y,scale+random3.y);\n            //uv.x *= -1.0;\n            \n            uv = triangle_wave((uv+random1.z)*(random4.y*.0+1.),scale+random3.z);\n            //if(uv.x > uv.y) uv /= scale;\n\n            uv.x /= -1.0;\n            \n            \n            //uv.x *= -1.0;\n            //uv = triangle_wave(uv+c1.y,scale);\n            scale /= scale2+col.x;\n            offset *= scale2/(1.+random4.x);\n            \n            //uv = uv.yx;\n            //uv = uv.yx;\n            scale2 += col.x/3.;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nst3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 388, 410, 456, 589], [591, 591, 630, 630, 675], [677, 677, 734, 734, 2215]]}
{"id": "sd33zN", "name": "Neural Stanford Bunny (4 kb)", "author": "goingdigital", "description": "Based on Blackle's original work, with an alternative neural network structure and new training script.\n", "tags": ["bunny"], "likes": 18, "viewed": 1026, "published": 3, "date": "1629241493", "time_retrieved": "2024-07-30T19:05:57.307434", "image_code": "// Fork of \"Neural Stanford Bunny (5 kb)\" by blackle. https://shadertoy.com/view/wtVyWK\n\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n// GoingDigital:\n// Ported to Tensorflow SIREN 3x12 / 12x12 / 12x12 / 12x1 network which is a little more compact.\n// Google Colab: https://colab.research.google.com/github/going-digital/ml_sdf/blob/main/ml_sdf.ipynb\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n  if (length(p) > 1.) return length(p)-.8;\n  vec4 x=vec4(p,1),\n    f00=sin(x*mat4(-1.74,-1.05,-1.82,2.64,-3.5,-4.23,2.91,-3.83,-.67,2.72,1.37,10.45,-1.46,-1.9,3.0,5.41)),\n    f01=sin(x*mat4(-3.12,-3.3,1.11,-1.54,2.91,-2.94,.82,-9.88,.92,1.34,2.62,2.71,1.16,1.04,-1.25,-9.69)),\n    f02=sin(x*mat4(3.42,-1.21,2.28,9.64,-2.02,1.15,1.83,-4.09,3.23,-.52,2.07,5.01,.52,-.6,3.35,.87)),\n    f10=sin(mat4(-.99,.53,-.28,.66,.15,-.02,-.09,-.06,-.01,-.05,-.04,-.56,-.1,-.31,-.83,-.43)*f00+mat4(.15,.04,-.09,.21,.42,-.23,.02,.17,.23,.31,.6,.56,-.93,1.47,.0,-.48)*f01+mat4(.71,-.44,-.18,.43,-.6,.42,.45,.5,-.92,.35,-.72,-.44,.0,.76,-.31,-.05)*f02+vec4(-13.95,-3.14,5.36,-9.25)),\n    f11=sin(mat4(-.54,-.75,-.21,-.24,-.38,.06,-.03,.55,.81,.51,-1.12,-.01,-.38,.11,-.02,.67)*f00+mat4(.11,.15,-.05,1.59,.04,-.23,-.18,-1.16,-.08,-.14,-.53,-.07,.23,-.36,-.4,-.15)*f01+mat4(.72,.28,-.18,-.61,.22,-.23,-.65,.28,.83,.41,.11,-.29,-.39,-.32,-.92,-.51)*f02+vec4(-4.81,6.95,9.26,-6.26)),\n    f12=sin(mat4(.73,.76,-.2,-1.04,-.46,.18,.21,1.15,-.06,-.43,.94,.13,.37,-.67,.6,.11)*f00+mat4(.38,.4,.04,.88,-.27,-1.18,.03,-.33,.14,1.54,.69,1.17,.37,1.3,.26,-1.7)*f01+mat4(.33,.42,-.4,-.97,-.23,.84,.42,-.1,-.67,.39,-.84,-.62,.45,.69,.37,1.29)*f02+vec4(-4.38,5.86,13.65,-9.16)),\n    f20=sin(mat4(-.39,.06,1.14,.07,-.06,-.82,.13,-.17,.19,-.79,-1.93,.11,-.39,-.02,-.48,-.05)*f10+mat4(-.51,-.77,-.35,-.02,.1,.47,-1.25,.08,-.1,-.3,1.4,.13,-.1,.21,-.59,.21)*f11+mat4(-.23,.03,-.68,-.08,.06,.15,1.01,-.11,-.27,-.01,-1.56,.02,-.34,.06,.51,.13)*f12+vec4(4.79,-5.84,7.28,4.74)),\n    f21=sin(mat4(.18,.07,.29,-.19,.59,-.03,-.27,.18,.05,.16,.17,-.06,.14,.36,-.24,.0)*f10+mat4(-.38,-.24,-.07,.23,.11,.1,.04,.55,.3,-.2,-.09,.03,.12,.13,.05,.01)*f11+mat4(-.09,.19,.08,.15,.18,.06,-.08,-.03,-.26,-.09,.15,.17,-.06,.07,.14,.19)*f12+vec4(-7.29,1.85,-4.88,.69)),\n    f22=sin(mat4(.32,-.19,.24,.29,.95,.0,.93,.07,1.3,-.76,-.57,-.45,.22,.87,-.6,.95)*f10+mat4(-.65,-.3,-.38,-.3,-.61,.58,-.78,1.04,-.32,-.06,.12,.59,-.94,-.06,-.04,-.07)*f11+mat4(.16,-.5,.46,1.24,.39,-.43,.28,-.91,-.76,-.98,-1.13,.27,-1.26,-.3,-.01,-.11)*f12+vec4(-6.24,1.26,-1.13,-13.77));\n  return dot(vec4(-.18,.16,.02,-.4),f20)+dot(vec4(-.18,-.51,-.55,.39),f21)+dot(vec4(.03,.08,.11,.05),f22)+.28;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>5.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    vec3 nz = p - erot(p, vec3(1), 2.) + erot(p, vec3(1), 4.);\n    float spec = length(sin(r*3.5+sin(nz*120.)*.15)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.3,.2,scene(p+r*.2));\n    vec3 col = vec3(.1,.1,.12)*spec + pow(spec,8.);\n    float bgdot = length(sin(cam*8.)*.4+.6)/2.;\n    vec3 bg = vec3(.1,.1,.11) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = smoothstep(-.02,1.05,sqrt(fragColor)) * (1.- dot(uv,uv)*.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd33zN.jpg", "access": "api", "license": "cc0-1.0", "functions": [[501, 501, 539, 539, 601], [603, 603, 624, 624, 2838], [2840, 2840, 2859, 2859, 2975], [2977, 2977, 3034, 3034, 4302]]}
{"id": "stjSDh", "name": "Metal Donuts & Springs", "author": "byt3_m3chanic", "description": "I'm still pretty jacked up on UV mapping a torus right now!\n\n(Click and mouse to zoom/show enlarged view)", "tags": ["raymarching", "torus", "uv", "isometric"], "likes": 24, "viewed": 536, "published": 3, "date": "1629227685", "time_retrieved": "2024-07-30T19:05:58.065407", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Metal Art Donuts &Springs\n    @byt3_m3chanic | 08/17/21\n\n    you dont learn till you do it over and over and over...\n    Just trying to isolate the UV mapping things\n    playing around with animation and movement.\n    \n    truchet tiles are so hot right now!\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .001\n#define MAX_DIST 90.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n//@iq torus\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time;\n\nconst vec2 sc = vec2(.125), hsc = .5/sc; \n\nvec2 map(vec3 p) {\n    p.y+=2.;\n    p.x+=time;\n    vec2 res = vec2(1e5,0);\n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/sc;\n    vec3 q = vec3(r.x,p.y,r.y);\n\n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n    float rnd = hash21(id);\n\n    float mx = .7+.3*sin(id.x*1.25);\n    float my = .7+.3*sin(id.y*2.);\n    float fid = (mx*my);\n    float wv = 1.65*sin(fid*T*4.5);\n \n    // spheres\n    float b1 = rnd >.2 ? length(q-vec3(0,1.8-wv,0))-(fid) : 1e5;\n    float w1=wv*.3;\n    float w2=wv*.15;\n    vec3 vq = vec3(q.x,abs(abs(q.y-.75-w2)-.5)-.25,q.z);\n    b1 = min(torus(vq,vec2(1.25-w1,.075)),b1);\n    if(b1<res.x) {\n        res = vec2(b1,2.);\n    \thit=p;\n        gid=id;\n        gto=vec3(fid,dir,rnd);\n    }\n\n    float b2 = torus(q-vec3(0, 1.05,0),vec2(2.75 ,1.00 ));\n    if(b2<res.x) {\n        res = vec2(b2,3.);\n    \thit=q;\n        gid=id;\n        gto=vec3(fid,dir,rnd);\n    }\n    \n    // floor\n    float d9 = p.y;\n    d9 = max(d9,-(length(q)-1.25));\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=p;\n        gid=id;\n        gto=vec3(fid,dir,rnd);\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t)\n{ \n    vec3 d = vec3(0.961,0.541,0.220);\n    return .375 + .375*cos(PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nvec4 FC = vec4(0.306,0.337,0.353,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<150;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.5: ray.x*.85;\n        m  = ray.y;\n    } \n\n    hitPoint = hit;\n    sid = gid;\n    sto = gto;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(1,8,0);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.05; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        vec3 h = vec3(.5);\n        \n        if(m==1.) {\n            vec3 hp = hitPoint*sc.xxx;\n            h = vec3(.7);\n            vec2 f = fract(hp.xz*2.)-.5;\n            if(f.x*f.y>0.) h=clamp( hue( fresnel-length(hp.xz*.15) )+.2,vec3(0),vec3(1) );\n            ref = vec3(h*.5)-fresnel;\n        }\n        \n        if(m==2.) {\n            h=vec3(.5);\n            ref = h-fresnel;\n        }\n\n        if(m==3.) {\n            vec3 hp = hitPoint;\n            float fhs = hash21(sid.xy+50.);\n            float angle = atan(hp.z,hp.x)/PI2;\n            float gz =  atan( hp.y,  length(hp.zx)-2.75 ) / PI2;\n\n            vec2 uv = vec2(angle,gz+(T*.1*fhs));\n        \n            float px  = .005*d;\n            vec2 scaler = vec2(48.,32.);\n            vec2 grid = fract(uv.xy*scaler)-.5;\n            vec2 id   = floor(uv.xy*scaler);\n            float hs = hash21(id);\n            if(hs>.5) grid.x*=-1.;\n\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n            float circle = length(gx)-.5;\n            \n            if(fhs>.4){\n                float circle2 = fhs>.85 ? abs(abs(circle)-.25)-.2 : abs(abs(circle)-.15)-.05 ;\n                circle2=smoothstep(-px,.001+px,circle2);\n                circle=(chk>0.^^ hs>.5) ? smoothstep(-px,.001+px,circle) : smoothstep(.001+px,-px,circle);\n                \n                if(fhs>.75) circle= min(circle2,circle);\n                     \n            }else{\n            \n                circle=smoothstep(-px,.001+px,abs(circle)-.15);\n            }\n           \n        \n            h = mix(h, hue(fresnel-(sto.z*3.35)),circle);\n            ref = vec3(.4-circle)-fresnel;\n        }\n        \n        C = h*diff+spec;\n        C = mix(FC.rgb,C,  exp(-.00005*d*d*d));\n    \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC.rgb;\n    } \n    return vec4(clamp(C,vec3(.03),vec3(1.)),alpha);\n}\n\nfloat zoom = 14.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T*.75;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    float x = -1.;\n    \n    if(M.z>0.) x = .5-(M.x-F.x);\n     \n    if(uv.x>x && M.z>0.) zoom *= .5;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n\n    mat2 rx = rot(-45.*PI/180.);\n    mat2 ry = rx;\n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0); \n    vec3 fil=vec3(1);\n    \n    float d =0.;\n    float numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n\n    //C = mix(C,C+.07,hash21(uv));\n    C=clamp(C,vec3(.03),vec3(.9));\n    // gamma correction\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSDh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[522, 522, 542, 542, 587], [588, 588, 612, 612, 670], [672, 684, 715, 715, 780], [879, 879, 897, 897, 1980], [1982, 1982, 2012, 2012, 2251], [2253, 2253, 2272, 2272, 2372], [5592, 5592, 5633, 5633, 6425]]}
{"id": "sscGz4", "name": "exodus", "author": "unjello", "description": "Source for Aberration Creations production - 4KB intro \"Exodus\", published at MAGFest Demoparty 2019. 3rd place in combined demo competition.\n\nCode: Angelo\nMusic: Argasek\n\nWatch the full production here: www.youtube.com/watch?v=HJA1xIevGl0", "tags": ["intro", "source"], "likes": 8, "viewed": 295, "published": 3, "date": "1629223976", "time_retrieved": "2024-07-30T19:05:58.824378", "image_code": "/// Exodus / Aberration Creations, a 4k intro\n/// 3rd place @ MAGFest 2019\n/// License: CC0\n///\n/// Effects inspired by:\n/// Octahedral Voxel Tracing / fizzer: https://www.shadertoy.com/view/4lcfDB\n/// Swirly Strands / Plento: https://www.shadertoy.com/view/MtKfWy\n/// InFX.1 / patu: https://www.shadertoy.com/view/llSSRm\n///\n/// Soundtrack: https://soundcloud.com/argasek/exodus-video\n/// Video: www.youtube.com/watch?v=HJA1xIevGl0\n///\n\n\nfloat MIN_DIST = 0.0;\nfloat MAX_DIST = 120.0;\nfloat EPSILON = 0.0001;\nvec3 K_a = vec3(1.);\nvec3 K_d = vec3(.6);\nvec3 K_s = vec3(0.5, 1.0, 0.5);\nvec3 lp = vec3(0.0, 1.0, -0.5);\nvec3 zero3 = vec3(0.);\n\nint MAX_STEPS = 80;\nint MODE_CROSS_CENTER = 1;\nint MODE_CROSS_JUMPING = 2;\nint MODE_METABALLS_CENTER = 3;\nint MODE_SWIRLS_CENTER = 5;\nint MODE_SWIRLS_SIDE = 6;\n\n// random took from\n// https://thebookofshaders.com/11/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return 0.4*(mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat sdfCubeCheap(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return max(d.x, max(d.y, d.z));\n}\n\nfloat sdfOpUnion(float a, float b) {\n\treturn min(a,b);\n}\n\nvec3 sdfOpMod(vec3 p, vec3 size) {\n    vec3 halfsize = size * 0.5;\n    p = mod(p + halfsize, size) - halfsize;\n    return p;\n}\n\nvec3 opTwist( vec3 p, float r ) {\n    float  c = cos(r * p.y + r);\n    float  s = sin(r * p.y + r);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat opBlob(float d1, float d2, float d3, float d4, float d5, float d6) {\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5)+exp(-k*d6))/k;\n}\n\n\n// https://www1.udel.edu/biology/rosewc/kaap427627/notes/matrices_rotations.pdf\nmat3 fullRotate(vec3 theta) {\n    float sx=sin(theta.x);\n    float cx=cos(theta.x);\n    float sy=sin(theta.y);\n    float cy=cos(theta.y);\n    float sz=sin(theta.z);\n    float cz=cos(theta.z);\n    return mat3(\n        vec3(cy*cz, -cy*sz, sy),\n        vec3(sx*sy*cz+cx*sz, -sx*sy*sz+cx*cz, -sx*cy),\n        vec3(-cx*sy*cz+sx*sz, cx*sy*sz+sx*cz, cx*cy)\n        );\n}\n\nfloat sdf_metaballs(vec3 p) {\n    float t = iTime / 4.;\n\tfloat p1 = sdfSphere(0.5*(p + vec3(cos(t*0.5),sin(t*0.3),cos(t))), 1.+0.5*cos(t*6.0));\n    float p2 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7))), 3.+2.*sin(t))/2.0;\n    float p3 = sdfSphere(2.0*(p + 5.0 * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3))), 3.)/2.0;\n    float p4 = sdfSphere(2.0*(p + 3.0 * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1))), 3.+2.*sin(t))/2.0;\n    float p5 = sdfSphere(2.0*(p + 6.0 * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7))), 3.0+1.5*cos(t))/2.0;\n    float p6 = sdfSphere(2.0*(p + 3.0 * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9))), 3.0)/2.0;\n    return opBlob(p1, p2, p3, p4, p5, p6);\n}\n\nfloat sdf_swirls(vec3 p, int mode) {\n   p -= vec3(1.0, -0.25, 4.0);   \n   p *= fullRotate(vec3(\n       0.0,\n       0.0, \n       mode == MODE_SWIRLS_CENTER ? p.z*0.06+0.2*sin(iTime) : p.z*.06+iTime*0.25\n   ));\n   p.y += sin(p.z + iTime + p.x*1.0)*0.2;\n   p.x += cos(p.y - p.z * 2.0 + iTime)*0.3;\n   p = sdfOpMod(p, vec3(1.5, 1.5, 0.5+0.3*sin(iTime)));\n   \n   return sdfCubeCheap(p, vec3(0.033, 0.033, 2.0));\n}\n\nfloat sdfCross(vec3 p, float w ) {\n  float da = sdfCubeCheap(p.xyz,vec3(20., w, w));\n  float db = sdfCubeCheap(p.yzx,vec3(w, 20., w));\n  float dc = sdfCubeCheap(p.zxy,vec3(w, w , 20.));\n  return sdfOpUnion(sdfOpUnion(sdfOpUnion(db,dc), da), da);\n} \n\nfloat sdf_cross(vec3 p) {\n    float t = iTime / 4.;\n    float w = 1.7 - length(p) / 10.;\n   p = opTwist(p, 0.1*sin(iTime*0.02))*fullRotate(vec3(iTime*0.01, 0.0, iTime*0.02));\n   p *= fullRotate(vec3(sin(iTime*0.1), 0.0, cos(iTime*0.02)));\n   float res = sdfOpUnion(\n       \t\t\t\tsdfCross(p, w),\n       \t\t\t\tsdfCross(p * fullRotate(vec3(3.14/4.0, 0.0, 3.14/4.0)), w));\n   res = sdfOpUnion(res, sdfCross(p * fullRotate(vec3(3.14, 3.14/4.0, 3.14)), w));\n   return res;\n}\n\n\nvec2 render_raymarch(vec3 eye, vec3 dir, int mode) {\n    float dist = MIN_DIST;\n    float glow = 0.0;\n    float minDist = MAX_DIST;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        vec3 v = eye + dist * dir;\n        float step = 0.0;\n        if (mode == MODE_METABALLS_CENTER) {\n            step = sdf_metaballs(v);\n        }\n        if (mode == MODE_CROSS_CENTER || mode == MODE_CROSS_JUMPING) {\n        \tstep = sdf_cross(v);\n        }\n        if (mode == MODE_SWIRLS_CENTER || mode == MODE_SWIRLS_SIDE) {\n\t\t\tstep = sdf_swirls(v, mode);\n        }\n        \n        if (abs(step) < EPSILON) {\n        \treturn vec2(dist, glow);\n        }\n\n        dist += step;\n                \n        minDist = min(minDist, step * 4.);\n        glow = pow( 1. / minDist, 0.4);  \n\n        if (dist >= MAX_DIST) {\n            return vec2(dist, glow);\n        }\n    }\n\treturn vec2(dist, glow);\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// http://learnwebgl.brown37.net/09_lights/lights_attenuation.html\nvec3 getSunLightColor(vec3 eye, vec3 dir, vec3 p, vec3 lp) {\n    vec3 sun_pos = eye;\n\tvec3 L = sun_pos - p;\n    float d = max(length(L), EPSILON);\n    float atten = 1.0 / (1.0 + d*0.2 + d*d*0.1); \n    vec3 c = (K_a + K_d + K_s)*atten;\n\treturn c;\n}\n\nvec3 getFoggyColor(vec3 eye, float d, vec3 dir, vec3 lightPosition) {\n\t    vec3 p = eye + d * dir;\n        vec3 c = getSunLightColor(eye, dir, p, lightPosition);\n        \n        float fog = smoothstep(0.0, 0.68, d*0.005);\n        return mix(c, zero3, fog);\n}   \n\nvec4 effect_swirls(vec2 fragCoord, int mode) {\n        vec2 uv = vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n        vec3 eye = vec3(mode == MODE_SWIRLS_CENTER ? 0.0 : 0.0, 0.0, (mode == MODE_SWIRLS_CENTER ? -17.0 : 2.0)*iTime); \n    \tvec3 viewDir = rayDirection(mode == MODE_SWIRLS_CENTER ? 45.0 : 25.0, iResolution.xy, mode == MODE_SWIRLS_CENTER ? fragCoord : fragCoord.yx);//normalize(vec3(uv,2.0));\n\n        float d = render_raymarch(eye, viewDir, mode).x;\n\n        if (d >= MAX_DIST) {\n            return vec4(0.0);\n        } else {\n            return vec4(getFoggyColor(eye, d, viewDir, lp), 1.0);\n        }\n}\n\nvec4 effect_raymarch(vec2 fragCoord, int mode) {\n    float k = (iTime+150.)/ 2.0;\n    vec3 eye = vec3(\n        mode == MODE_METABALLS_CENTER ? 30. : sin(k) * 40.,\n        1. , \n        mode == MODE_METABALLS_CENTER ? -5.+sin(k) :cos(k) * -20.);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 tt = vec3(10.,\n                   mode == MODE_CROSS_CENTER ? 0. : 20.\n                   , 0.);\n\n    if (mode == MODE_METABALLS_CENTER) {\n        tt.x/=2.;\n        tt.y = 2.5+sin(k);\n    }\n  \t\n    vec2 uv = fragCoord.xy / iResolution.xy - 1.0;\n    vec3 cc = vec3(1.0);\n    if (mode == MODE_CROSS_CENTER) {\n        uv.y += noise(uv)*sin(k*noise(uv*cos(k)));\n\t    uv.x -= sin(k*noise(uv*sin(k)));\n        float n = (ceil(uv.x * uv.y));\n\n        if (abs(n) < EPSILON) {\n        tt.y += 2.0 * sin(iTime);\n        cc = vec3(0.65);\n        }\n    } else {\n        float n, n2, n3;\n        float div = mode == MODE_CROSS_JUMPING ? 1. : -1.;\n        n = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k+noise(uv))));\n        n2 = (ceil(uv.x*2.5 + div*uv.y*2.5 +  2.0*sin(k)));\n        n3 = (ceil(uv.x*2.5 + div*uv.y*2.5 + div*2.0 - div*sin(k)*cos(k)));\n\t\t\n        vec3 cc = vec3(1.0);\n  \n        if (abs(n) < EPSILON) {\n            tt.y += 2.0 * sin(iTime);\n        }\n        if (abs(n2) < EPSILON) {\n            tt.y += 3.0 * cos(iTime);\n        }\n        if (abs(n3) < EPSILON) {\n            tt.y += 4.0 * cos(iTime);\n        }\n        cc = vec3(0.65);\n    }\n    \n    \n    vec3 up = vec3(0.2, 0.2, -1.);\n    if (mode == MODE_CROSS_JUMPING) {\n        up.z = -50.*cos(k);\n    } else if (mode == MODE_CROSS_CENTER) {\n        up.y = sin(k*5.);\n        up.z = cos(k*5.);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, tt, up);\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec2 dd = render_raymarch(eye, worldDir, mode);\n    float d = dd.x;\n    float glow = dd.y;\n\n    vec3 c = zero3;\n    if (d >= MAX_DIST) {\n        float g = glow*glow;\n        c += K_s*glow*0.2 + K_d*g;\n    } else {\n        c = getFoggyColor(eye, d, worldDir, mode == 4 ? vec3(0.0, -10., -15.) : lp);\n    }\n    return vec4(c*cc, 1.0);\n}\n\n\nvec4 intro(vec2 fragCoord) {\n    if (iTime <= 4.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 9.6) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 16.1) {\n\t\treturn effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 19.1) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 25.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 28.7) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 33.7) {\n\t\treturn effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 38.3) {\n        return effect_raymarch(fragCoord, MODE_CROSS_JUMPING);\n    } else if (iTime <= 43.1) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 47.9) {\n        return effect_swirls(fragCoord, MODE_SWIRLS_SIDE);\n    } else if (iTime <= 57.7) {\n        return effect_raymarch(fragCoord, MODE_METABALLS_CENTER);\n    } else if (iTime <= 76.8) {\n        return  effect_raymarch(fragCoord, MODE_CROSS_CENTER);\n    } else {\n        return  effect_swirls(fragCoord, MODE_SWIRLS_CENTER);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy)/ iResolution.xy;\n    fragColor = intro(fragCoord);\n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .4;    \n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.5)) * .7;\n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    if (iTime > 94.0) {\n        fragColor /= (-93.9+iTime)*6.;\n    }\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscGz4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[800, 856, 883, 883, 958], [960, 960, 983, 983, 1506], [1508, 1508, 1542, 1542, 1570], [1572, 1603, 1642, 1642, 1708], [1710, 1710, 1746, 1746, 1766], [1768, 1768, 1802, 1802, 1894], [1896, 1896, 1929, 1929, 2057], [2059, 2059, 2133, 2133, 2237], [2240, 2320, 2349, 2349, 2682], [2684, 2684, 2713, 2713, 3355], [3357, 3357, 3393, 3393, 3765], [3767, 3767, 3801, 3801, 4014], [4017, 4017, 4042, 4042, 4481], [4484, 4484, 4536, 4536, 5364], [5367, 5367, 5432, 5432, 5564], [5566, 5566, 5615, 5650, 5876], [5878, 5945, 6005, 6005, 6192], [6194, 6194, 6263, 6263, 6453], [6458, 6458, 6504, 6504, 7085], [7087, 7087, 7135, 7135, 9229], [9232, 9232, 9260, 9260, 10458], [10461, 10461, 10518, 10518, 10925]]}
{"id": "7sc3R4", "name": "rotatintg A", "author": "sunhokim", "description": "a", "tags": ["sdf"], "likes": 5, "viewed": 242, "published": 3, "date": "1629223648", "time_retrieved": "2024-07-30T19:05:59.571381", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 hash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*13.5453123);\n}\n\nfloat noise( in vec3 p ) {\n    vec3 a = hash3(p);\n    return sin(dot(a,a));\n}\n\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 opS( vec4 d2, vec4 d1 )\n{\n\treturn (-d1.x>d2.x) ? vec4(-d1.x, d1.yzw) : d2;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec4 mapA(vec3 p) {\n    vec3 q = rotateZ(p, M_PI*0.15);\n    vec4 A = vec4(sdBox(q, vec3(0.5,3.0, 0.5)), vec3(1.0));\n    q -= vec3(-1.0, 0.0, 0.0);\n    vec4 D = vec4(sdBox(q, vec3(0.5,3.0, 0.6)), vec3(1.0));\n    q = rotateZ(p- vec3(1.4, 0.0, 0.0), -M_PI*0.15) ;\n    vec4 A2 = vec4(sdBox(q, vec3(0.5,3.0, 0.5)),vec3(1.0));\n    q -= vec3(1.0, 0.0, 0.0);\n    vec4 D2 = vec4(sdBox(q, vec3(0.5,3.0, 0.6)), vec3(1.0));\n    q = p - vec3(0.7, -2.1, 0.0);\n    vec4 D3 = vec4(sdBox(q, vec3(0.7,0.7, 0.6)), vec3(1.0));\n    q = p - vec3(0.7, 1.3, 0.0);\n    vec4 A3 = vec4(sdBox(q, vec3(1.1, 0.4, 0.5)),vec3(1.0));\n    A = opU(A, A2);\n    A = opS(A, D);\n    A = opS(A, D2);\n    A = opS(A, D3);\n    A = opU(A, A3);\n    return A;\n}\n\nvec4 map(vec3 p) {\n    vec4 res = vec4(1e10, 0, 0,0);\n\n    {\n    float s = (1.0+sin((p.x/20.0)*M_PI+(p.z/20.0)*M_PI+iTime*M_PI))/2.0;\n    vec3 c = vec3(10.0, 10.0, 6.0);\n    vec3 q = opRep(p, c);\n    vec3 id = floor((p+0.5*c)/c);\n    float t2 = 2.0*M_PI*noise((id)*0.1);\n    float t = t2;\n    q.xy*=rot(-t);\n    q.yz*=rot(-t);\n    q.zx*=rot(t);\n    vec4 A = mapA(q/s)*s;\n    res = opU(res, A);\n    res.x = max(res.x, sdBox(id, vec3(2.0, 2.0,3.0)));\n    //res.x -= 0.3*noise(p);\n    }\n\n    return res;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.05;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}   \n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.0);\n    vec2 tminmax = iSphere( ro, rd, 100.0 );\n\tif( tminmax.y>0.0 )\n    {\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<256 && t<tminmax.y; i++ )\n        {\n            vec4 h = map(ro+t*rd);\n            if( h.x<0.01 ) { res=vec4(t,h.yzw); break; }\n            t += 0.5*h.x;\n        }\n    }\n    \n    return res;\n}\n\nvec3 skyColor(vec3 rd) {\n    float k = (max(rd.y,0.0)*0.8+0.2)*0.8;\n    vec3 sky = vec3(pow(1.0-k,2.0), 1.0-k, 0.6+(1.0-k)*0.4) * 1.1;\n    return sky;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 render( in vec3 ro, vec3 rd )\n{ \n    vec4 res = raycast(ro, rd);\n    vec3 pos = ro + res.x*rd;\n    vec3 col = vec3(0.0);\n    vec3 normal = calcNormal(pos);\n\n    if (res.x <0.0) {\n        return skyColor(rd);\n    }\n    vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n    vec3 material = vec3(1.0);\n    float sun = clamp( dot( normal, sunDir ), 0.0, 1.0 );\n    float sky = clamp( 0.5 + 0.5*normal.y, 0.0 ,1.0 );\n    float sha = softshadow(pos, sunDir, 0.03, 100.0, 30.0);\n    return 0.4*sky + sun*vec3(1.64,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMat( in vec3 eye, in vec3 look )\n{\n    vec3 w = normalize(eye-look);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(w, u);\n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec2 mouse = iMouse.xy /iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        mouse = vec2(0.5,0.5);\n    }\n    vec2 spr = vec2(mouse.x * M_PI - M_PI/2.0, mouse.y*M_PI-M_PI)*0.8;\n    spr.x += 0.3*iTime;\n    float r = 100.0;\n    vec3 eye = vec3(-r*sin(spr.x)*sin(spr.y), -r*cos(spr.y),-r*sin(spr.y)*cos(spr.x)) + vec3(0.0, -2.0, 0.0);\n    vec3 look = vec3(0.0,0.0,0);\n    mat3 view = viewMat(eye, look);\n    dir = view * dir;\n    fragColor = vec4(render(eye, dir), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sc3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 121, 121, 287], [289, 289, 315, 315, 366], [368, 368, 404, 404, 502], [503, 503, 539, 539, 637], [638, 638, 674, 674, 772], [774, 774, 805, 805, 892], [894, 894, 924, 924, 957], [959, 959, 989, 989, 1040], [1042, 1042, 1077, 1077, 1112], [1114, 1114, 1149, 1149, 1173], [1175, 1175, 1194, 1194, 1890], [1892, 1892, 1910, 1910, 2394], [2396, 2396, 2450, 2450, 2610], [2612, 2612, 2642, 2642, 2909], [2914, 2914, 2954, 2954, 3310], [3312, 3312, 3336, 3336, 3464], [3466, 3466, 3543, 3543, 3758], [3760, 3760, 3796, 3796, 4313], [4315, 4315, 4380, 4380, 4512], [4514, 4514, 4557, 4557, 4694], [4696, 4696, 4753, 4753, 5289]]}
{"id": "Nd3GRN", "name": "dart cube", "author": "sunhokim", "description": "It's a dart cube.", "tags": ["sdf"], "likes": 4, "viewed": 225, "published": 3, "date": "1629223618", "time_retrieved": "2024-07-30T19:06:00.417120", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 mapSide(vec3 p, float displace) {\n    vec2 k = p.xz;\n    vec2 por = vec2(sqrt(k.x*k.x+k.y*k.y), atan(k.y,k.x));\n    float a = por.x/0.2;\n    float h2 = displace*0.4*a;\n    float h = displace*0.4*floor(a);\n    float b = smoothstep(0.1, 0.2, mod(por.x,0.2));\n    vec3 q = p;\n    float hh = displace*5.0*0.4;\n    q.y = 1.0*q.y-h+hh;\n    return vec4(sdBox(q, vec3(1.0,0.2, 1.0)),vec3(b, h2/hh, 0.0));\n}\n\nvec4 map(vec3 p) {\n    vec4 res = vec4(1e10, 0, 0,0);\n\n    float d = 0.7;\n    float s = 1.0;\n    if (iTime < 1.0) {\n        s = (1.0+sin(iTime*M_PI - M_PI*0.5))/2.0;\n    }\n    float dd = d*0.5*(1.0+sin(iTime - M_PI*0.5))+0.01;\n    {\n    vec3 q = p - vec3(0,0.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*1.5) - vec3(0,0.0, 1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*0.5) - vec3(0,-2.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateZ(p, M_PI*0.5) - vec3(1.0,-1.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateZ(p, M_PI*1.5) - vec3(-1.0,-1.0, -1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    {\n    vec3 q = rotateX(p, M_PI*1.0) - vec3(0.0,-2.0, 1.0);\n    q /= s;\n    res = opU(res, mapSide(q, dd)*s);\n    }\n    \n    return res;\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.05;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}   \n\nvec4 raycast( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.0);\n    vec2 tminmax = iSphere( ro, rd, 20.0 );\n\tif( tminmax.y>0.0 )\n    {\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<1024 && t<tminmax.y; i++ )\n        {\n            vec4 h = map(ro+t*rd);\n            if( h.x<0.01 ) { res=vec4(t,h.yzw); break; }\n            t += 0.1*h.x;\n        }\n    }\n    \n    return res;\n}\n\nvec3 gradient(float z) {\n    vec3 a = vec3(0.46,0.76,1);\n    vec3 b = vec3(0.11,0.98,1);\n    vec3 c = vec3(0.69,0.49,1);\n    vec3 d = vec3(1,1,1);\n    if (z < 0.3) {\n        return mix(a, b, z);\n    } else if (z < 0.99999) {\n        return mix (b, c, z);\n    } else {\n        return mix(c,d, z);\n    }\n}\n\nvec3 render( in vec3 ro, vec3 rd )\n{ \n    vec4 res = raycast(ro, rd);\n    vec3 pos = ro + res.x*rd;\n    vec3 col = vec3(0.0);\n    vec3 mat =  mix(vec3(1.0), gradient(res.z), res.y);\n    vec3 normal = calcNormal(pos);\n    if (res.x < 0.0) {\n        return vec3(0.0);\n    } \n\n    vec3 lin = vec3(0.0);\n    lin += 1.0;\n    col = lin * mat;\n\treturn vec3(clamp(col,0.0,1.0));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMat( in vec3 eye, in vec3 look )\n{\n    vec3 w = normalize(eye-look);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(w, u);\n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec2 mouse = iMouse.xy /iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        mouse = vec2(0.4,0.7);\n    }\n    vec2 spr = vec2(mouse.x * M_PI - M_PI/2.0, mouse.y*M_PI-M_PI)*0.8;\n    float r = 20.0;\n    vec3 eye = vec3(-r*sin(spr.x)*sin(spr.y), -r*cos(spr.y),-r*sin(spr.y)*cos(spr.x)) + vec3(0.0, -2.0, 0.0);\n    vec3 look = vec3(0.0,0.0,0);\n    mat3 view = viewMat(eye, look);\n    dir = view * dir;\n    vec3 col = render(eye, dir);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3GRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 84, 84, 182], [183, 183, 219, 219, 317], [318, 318, 354, 354, 452], [454, 454, 485, 485, 572], [574, 574, 604, 604, 637], [639, 639, 677, 677, 1042], [1044, 1044, 1062, 1062, 1985], [1987, 1987, 2041, 2041, 2201], [2203, 2203, 2233, 2233, 2500], [2505, 2505, 2545, 2545, 2901], [2903, 2903, 2927, 2927, 3206], [3208, 3208, 3244, 3244, 3580], [3582, 3582, 3647, 3647, 3779], [3781, 3781, 3824, 3824, 3961], [3963, 3963, 4020, 4020, 4551]]}
{"id": "flBSWd", "name": "simple fbm test ", "author": "sunhokim", "description": ".", "tags": ["fbm"], "likes": 1, "viewed": 222, "published": 3, "date": "1629223577", "time_retrieved": "2024-07-30T19:06:01.229947", "image_code": "\nvec3 hash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*13.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash3( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash3( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash3( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash3( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash3( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash3( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash3( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash3( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat fbm( in vec3 x )\n{    \n    float G = 0.5;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\nvec3 mytexture( vec3 p )\n{\n\tp += 0.1;\n\tvec3 ip = floor(p/20.0);\n\tvec3 fp = fract(0.5+p/20.0);\n\n     vec3 q = vec3( fbm( p + vec3(iTime,iTime,0.0) ),\n                   fbm( p + vec3(3.0,2.0,0.0) ) ,0.0);\n\tfloat g = 5.0*fbm(p+4.0*q);\n\t\n    vec3 col = mix(vec3(0.99,0.99,0.99), vec3(0.93,0.93,0.93), g);\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    fragColor = vec4(mytexture(vec3(uv*8.0,0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 189], [191, 191, 217, 217, 1050], [1052, 1052, 1076, 1076, 1274], [1277, 1277, 1303, 1303, 1594], [1597, 1597, 1654, 1704, 1825]]}
{"id": "sdt3Rn", "name": "A Simple Laser effect", "author": "wangxiaochen", "description": "a simple laser effect", "tags": ["3d", "laser"], "likes": 2, "viewed": 395, "published": 3, "date": "1629211367", "time_retrieved": "2024-07-30T19:06:02.075685", "image_code": "#define MAX_STEPS 32\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define Light_pos vec3(5.,5.,9.)\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.1,0.5,0.9) );\n}\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\nfloat smin(float a,float b,float h){\n    float c=clamp((b-a)/h*0.5+0.5,0.,1.);\n    //return c;\n    return mix(b,a,c)-h*c*(1.0-c);\n}\n\nmat2 rot(float a){\n   float c=sin(a);\n   float s=cos(a);\n    return mat2(c,s,-s,c);\n    \n}\nfloat GetDist(vec3 p){\n   return 1.9*(max(0.,fbm(p*.3)-.35+.05*abs(sin(iTime))));\n}\nfloat rayMarch(vec3 ro,vec3 rd){\n    float d0=0.;\n    float T=1.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*d0;\n        float ds=GetDist(p)/32.;\n        T*=(1.-ds);\n        d0+=50.*ds*T;\n        if(T<.001)break;\n        //if(d0>MAX_DIST||ds<SURF_DIST)break;\n    }\n    return d0;\n}\nvec3 getNormal(vec3 p){\n    float l= GetDist(p);\n    vec2 cau=vec2(.01,0.);\n    vec3 n=normalize(vec3(l-GetDist(p-cau.xyy),\n                          l- GetDist(p-cau.yxy),\n                          l- GetDist(p-cau.yyx)\n                           ));\n    return n;\n    \n}\nfloat  getLight(vec3 p){\n    vec3 ld=Light_pos;\n    vec3 li=normalize(ld-p);\n    vec3 sn=getNormal(p);\n    float sh=rayMarch(p+sn*SURF_DIST*2.,li);\n    float dif=clamp(dot(sn,li),0.,1.) ;\n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 r0=vec3(0.,0.,5.);\n    vec3 rd=vec3(uv.x,uv.y-.2,1.);\n    vec3 col = vec3(1.);\n    col.xyz=vec3(1.)*rayMarch(r0,rd)*.09;\n    float d= rayMarch(r0,rd);\n    vec3 p=r0+rd*d;\n    vec3 n=getNormal(p);\n    float difu=getLight(p);\n     float ndotv=max(0.,dot(normalize(rd),n));\n    vec3 halfh=normalize(normalize(-rd)+normalize(Light_pos-p));\n    float ndothalfh=max(0.,dot(halfh,n));\n     col =mix(vec3(difu),spectrum(.4+ndothalfh),0.9);\n    col+=vec3(pow(ndothalfh,25.));\n    fragColor = vec4(col*difu,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdt3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 167, 167, 210], [211, 211, 235, 235, 331], [439, 439, 462, 462, 501], [503, 503, 529, 529, 934], [936, 936, 957, 957, 1098], [1099, 1099, 1135, 1135, 1230], [1232, 1232, 1250, 1250, 1322], [1323, 1323, 1345, 1345, 1406], [1407, 1407, 1439, 1439, 1700], [1701, 1701, 1724, 1724, 1973], [1974, 1974, 1998, 1998, 2179], [2180, 2180, 2237, 2237, 2791]]}
{"id": "fs33z4", "name": "test truchet v2", "author": "jorge2017a1", "description": "test truchet v2", "tags": ["testtruchetv2"], "likes": 9, "viewed": 274, "published": 3, "date": "1629206590", "time_retrieved": "2024-07-30T19:06:03.039109", "image_code": "//por jorge2017a1-\n//referencia:\n//byt3_m3chanic,  UV Mapping Truchet Tiles \n//https://iquilezles.org/articles/distfunctions\n//https://www.youtube.com/watch?v=2R7h76GoIJM ....Art Code\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    \n    res =opU3(res, vec3(planeDist1,-1.0,10.0)); //inf\n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,-1.0,12.0)); \n    res =opU3(res, vec3(planeDist4,-1.0,12.0)); \n    res =opU3(res, vec3(planeDist5,-1.0 ,11.0)); \n    res =opU3(res, vec3(planeDist6,-1.0,11)); \n    \n    p.y=p.y-5.0;\n   float sdc1= sdCylinderXZ( p-vec3(-8.0,0.0,.0), vec2(3.0,20.0) );\n   float sdsp2= sdSphere( p-vec3(10.0,3.0,5.0), 6.0 );\n    res =opU3(res, vec3(sdc1,-1.0,14.0)); \n    res =opU3(res, vec3(sdsp2,-1.0,14.0));\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n   \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n    \n    if (id_material==10.0)\n    { vec3 col=truchet( p.xz ,iResolution.xy,true, iTime); \n    return col;\n    }\n    \n    if (id_material==11.0)\n    {  vec3 col=truchet( p.xy,iResolution.xy, true, iTime ); return col;   \n    }\n    \n    if (id_material==12.0)\n    {   vec3 col=truchet( p.zy ,iResolution.xy, true, iTime); return col; }\n    \n    \n    \n    if (id_material==13.0)\n    { \n        vec2 uv=p.xy*10.0;\n        float radius = length(uv);\n        float angle = atan(uv.y, uv.x) / 2. / PI;\n        vec2 polarUV = vec2(radius, angle);\n        return truchet( polarUV ,iResolution.xy, false, 0.0);\n    }\n    \n//referencia:  byt3_m3chanic,  UV Mapping Truchet Tiles \nif (id_material==14.0)\n    { \n        #define SCALE       0.7500\n        #define PI2         6.28318530718\n        const float size = 1./SCALE;\n        const float hlf = size/2.;\n        \n        // get closest arc\n            vec2 d3 = vec2(length(p-hlf), length(p+hlf));\n            vec3 g3 = d3.x<d3.y? vec3(p-hlf) : vec3(p+hlf);\n    \n            //angle for the tube\n            float angle = atan(g3.y,g3.x)/PI2;\n            //angle for the arc/truchet path\n            float gz =  atan( p.z,  length(g3.yx)-hlf ) / PI2;\n            //make the uv\n            vec2 uv = vec2(angle,gz)*150.0;\n            \n            vec3 col=truchet( uv ,iResolution.xy, false, 0.0);\n            \n            //l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return col;\n    }\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   //float d = RayMarch(ro, rd);\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1)*light_color1*(0.5+abs(0.5*sin(iTime*0.5)));\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2)*light_color2*sin(iTime);\n        col= result;\n    }\n\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*6.0,500.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 2.0 );\n \tlight_pos2= vec3( -5.0, 5.0, 10.0 ); light_color2 =vec3( 2.0,2.0,0.5 ); \n \n   \n   vec3 ro=vec3(0.0,7.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   ro.xz=rotatev2(ro.xz, radians(-t));\n   rd.xz=rotatev2(rd.xz, radians(t));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n   \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n///--------------------------------------------\n//referencia\n//https://www.youtube.com/watch?v=2R7h76GoIJM ....Art Code\nfloat Hash21(vec2 p)\n{\n    p=fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.23);\n    return fract(p.x*p.y);\n}\n\n\nvec3 truchet( in vec2 fragCoord, vec2 ir , bool blnt, float t)\n{\n    vec2 uv=(fragCoord-0.5*ir.xy)/ir.y;\n    uv*= 50.0;\n    if (blnt=true)\n    uv+=t;\n        vec3 col=vec3(0.0);\n\n    vec2 gv=fract(uv)-0.5;\n    vec2 id=floor(uv);\n\n    float n=Hash21(id*2.0); //rango 0.0 a 1.0\n\n    float width=0.1;\n\n    if(n<0.5) gv.x*=-1.0;\n    float d=abs( abs( gv.x+gv.y)-0.5 );\n\n    d=length(gv-sign(gv.x+gv.y-0.001)*0.5 )-0.5;\n\n    float  mask=smoothstep(0.01,-0.01, abs(d)-width);\n    col+=mask;\n    return col;\n }", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs33z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[645, 645, 681, 681, 702], [703, 703, 735, 735, 819], [820, 820, 859, 859, 954], [955, 955, 994, 994, 1089], [1090, 1090, 1129, 1129, 1224], [1226, 1270, 1317, 1317, 1344], [1345, 1345, 1388, 1388, 1415], [1416, 1416, 1464, 1464, 1492], [1532, 1557, 1591, 1591, 1687], [1688, 1688, 1722, 1722, 1813], [1814, 1814, 1848, 1848, 1939], [1940, 1980, 2014, 2014, 2109], [2110, 2150, 2175, 2175, 3159], [3161, 3212, 3236, 3236, 3398], [3400, 3400, 3449, 3449, 4116], [4118, 4205, 4241, 4241, 4486], [4487, 4542, 4569, 4569, 4586], [4588, 4588, 4624, 4624, 4716], [4717, 4717, 4763, 4763, 4888], [4890, 4890, 4964, 4964, 6563], [6564, 6619, 6668, 6668, 6911], [6912, 6946, 7026, 7026, 7149], [7150, 7239, 7267, 7267, 7455], [7456, 7507, 7554, 7554, 9304], [9306, 9358, 9451, 9451, 9663], [9666, 9666, 9697, 9697, 10332], [10334, 10383, 10409, 10409, 10519], [10521, 10521, 10579, 10579, 10631], [10633, 10682, 10739, 10739, 11363]]}
{"id": "fs33R4", "name": "xor pattern animated", "author": "hikiko", "description": "based on a xor pattern", "tags": ["xor"], "likes": 4, "viewed": 319, "published": 3, "date": "1629200859", "time_retrieved": "2024-07-30T19:06:03.791099", "image_code": "float M_PI = 3.14;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int xor = (int(fragCoord.x) ^ int(fragCoord.y));\n    \n    float r = float((xor * 2) & 0xff) / 255.0 * 0.3;\n    float g = float((xor * 4) & 0xff) / 255.0 * 0.7;\n\tfloat b = float((xor * 8) & 0xff) / 255.0 * 0.6;\n    \n    vec3 col = vec3(b * atan(r * cos(iTime + M_PI / 3.0), b * sin(iTime - M_PI / 2.0) + 0.0001), \n    g * atan(r * cos(iTime - M_PI / 4.0), g * sin(iTime + M_PI * 4.0 / 3.0) + 0.0004),\n    b * atan(b * sin(iTime + M_PI / 2.0), g * cos(iTime + M_PI / 2.0)) + 0.0004);\n    \n    fragColor = vec4(mix(col.x * atan(iTime * 0.8 + M_PI / 8.0, col.y), 1.0, cos(g * b - M_PI / r / 2.0)), col.y, col.z, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs33R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "7ddGR8", "name": "spatial-temporal video mashup", "author": "elenzil", "description": "400-frame video history.\ninspired by a circa ~2000 performance by Steina and Woody Vasulka.\nif you're able to get in front of a monitor and a webcam, this is a lot of fun.\nespecially with a kid or two around!\nclick upper-right for Shirley Jones.", "tags": ["rollingshutter", "videodelay"], "likes": 10, "viewed": 600, "published": 3, "date": "1629181320", "time_retrieved": "2024-07-30T19:06:04.554059", "image_code": "vec4 readFromHistory(in vec2 UV, int historyIndex)\n{\n    int   index   = historyIndex % CELLCOUNT;\n    ivec2 gridPos = gridPosFromIndex(index);\n    \n    vec2  uv      = UV / vec2(GRIDRES);\n    uv += vec2(gridPos) / vec2(GRIDRES);\n    \n    uv *= (iResolution.xy - vec2(EXCESS)) / iResolution.xy;\n    \n    int historyPage = historyIndex / CELLCOUNT;\n    \n    vec4 tex;\n    \n    if (historyPage == 0) {\n       tex = texture(iChannel3, uv, 0.0);\n    }\n    else if (historyPage == 1) {\n       tex = texture(iChannel2, uv, 0.0);\n    }\n    else if (historyPage == 2) {\n       tex = texture(iChannel1, uv, 0.0);\n    }\n    else  {\n       tex = texture(iChannel0, uv, 0.0);\n    }\n    \n    return tex;\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec2 UV = XY / (iResolution.xy + vec2(EXCESS));\n    \n    float d1 = 1.0 - UV.y;\n    float d2 = 1.0 - length(UV - 0.5) / length(vec2(0.5));\n\n    float t = sin(iTime * 3.14159 / 60.0);\n    float dMixer = smoothstep(0.2, -0.2, t);\n    \n    dMixer = 0.0;\n    \n    float delay = mix(d1, d2, dMixer);\n    \n    delay = clamp(delay, 0.0, 1.0);\n\n    if (iMouse.z > 0.0) {\n        if (XY.x < iResolution.x / 2.0) {\n            if (XY.y < iResolution.y / 2.0) {\n                RGBA = texture(iChannel3, UV * 2.0 - vec2(0.0, 0.0), 0.0);\n            }\n            else {\n                RGBA = texture(iChannel2, UV * 2.0 - vec2(0.0, 1.0), 0.0);\n            }\n        }\n        else {\n            if (XY.y < iResolution.y / 2.0) {\n                RGBA = texture(iChannel1, UV * 2.0 - vec2(1.0, 0.0), 0.0);\n            }\n            else {\n                RGBA = texture(iChannel0, UV * 2.0 - vec2(1.0, 1.0), 0.0);\n            }\n        }\n        \n        RGBA = mix(RGBA, vec4(sin(delay * 50.0) * 0.5 + 0.5), 0.2);\n        return;\n    }\n    \n    float indexF  = delay * float(HISTORY_COUNT);\n    int   index   = int(floor(indexF)); \n    \n    vec4 tex = readFromHistory(UV, index);\n    \n    RGBA = vec4(tex.rgb, 1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 pixelPos = ivec2(XY);\n    ivec2 gridPos  = gridPosFromPixelPos(pixelPos);\n    int   index    = indexFromGridPos(gridPos);\n    \n    if (index == 0) {\n        ivec2 ij = pixelPos + ivec2(GRIDRES - 1) * CELLSIZE;\n        RGBA = texelFetch(iChannel1, ij, 0);\n        return;\n    }\n    \n    if (gridPos.x >= GRIDRES.x || gridPos.y >= GRIDRES.y) {\n        RGBA = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    ivec2 ij = pixelPos - (gridPos * CELLSIZE);\n\n    if (iFrame < 10) {\n        index = 0;\n    }\n    else {\n        index -= 1;\n    }\n    \n    ij += gridPosFromIndex(index) * CELLSIZE;\n    \n    RGBA = texelFetch(iChannel0, ij, 0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define GRIDRES       (ivec2(10, 10))\n#define CELLSIZE      (ivec2(iResolution.xy) / GRIDRES)\n#define CELLCOUNT     (GRIDRES.x * GRIDRES.y)\n#define BUFFERS       (4)\n#define HISTORY_COUNT (CELLCOUNT * BUFFERS)\n#define EXCESS        (ivec2(iResolution.xy) - GRIDRES * CELLSIZE)\n\n#define gridPosFromPixelPos(pixelPos) (pixelPos / CELLSIZE)\n\nint indexFromGridPos(in ivec2 gridPos) {\n    return gridPos.y * GRIDRES.x + gridPos.x;\n}\n\nivec2 gridPosFromIndex(int index) {\n    return ivec2(index % GRIDRES.x, index / GRIDRES.x);\n}", "buffer_b_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 pixelPos = ivec2(XY);\n    ivec2 gridPos  = gridPosFromPixelPos(pixelPos);\n    int   index    = indexFromGridPos(gridPos);\n    \n    if (index == 0) {\n        ivec2 ij = pixelPos + ivec2(GRIDRES - 1) * CELLSIZE;\n        RGBA = texelFetch(iChannel1, ij, 0);\n        return;\n    }\n    \n    if (gridPos.x >= GRIDRES.x || gridPos.y >= GRIDRES.y) {\n        RGBA = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    ivec2 ij = pixelPos - (gridPos * CELLSIZE);\n\n    if (iFrame < 10) {\n        index = 0;\n    }\n    else {\n        index -= 1;\n    }\n    \n    ij += gridPosFromIndex(index) * CELLSIZE;\n    \n    RGBA = texelFetch(iChannel0, ij, 0);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 pixelPos = ivec2(XY);\n    ivec2 gridPos  = gridPosFromPixelPos(pixelPos);\n    int   index    = indexFromGridPos(gridPos);\n    \n    if (index == 0) {\n        ivec2 ij = pixelPos + ivec2(GRIDRES - 1) * CELLSIZE;\n        RGBA = texelFetch(iChannel1, ij, 0);\n        return;\n    }\n    \n    if (gridPos.x >= GRIDRES.x || gridPos.y >= GRIDRES.y) {\n        RGBA = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    ivec2 ij = pixelPos - (gridPos * CELLSIZE);\n\n    if (iFrame < 10) {\n        index = 0;\n    }\n    else {\n        index -= 1;\n    }\n    \n    ij += gridPosFromIndex(index) * CELLSIZE;\n    \n    RGBA = texelFetch(iChannel0, ij, 0);\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 pixelPos = ivec2(XY);\n    ivec2 gridPos  = gridPosFromPixelPos(pixelPos);\n    int   index    = indexFromGridPos(gridPos);\n    \n    if (index == 0) {\n        const bool mirrorVideo = true;\n        \n        vec2 uv = XY / iResolution.xy;\n        uv *= vec2(GRIDRES);\n        uv.x = mirrorVideo ? 1.0 - uv.x : uv.x;\n        \n        if (length(1.0 - iMouse.xy/iResolution.xy) < 0.3) {\n            RGBA = texture(iChannel2, uv, 0.0);\n        }\n        else {\n            RGBA = texture(iChannel1, uv, 0.0);\n        }\n        return;\n    }\n    \n    if (gridPos.x >= GRIDRES.x || gridPos.y >= GRIDRES.y) {\n        RGBA = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    ivec2 ij = pixelPos - (gridPos * CELLSIZE);\n    \n    if (iFrame < 10) {\n        index = 0;\n    }\n    else {\n        index -= 1;\n    }\n    \n    ij += gridPosFromIndex(index) * CELLSIZE;\n    \n    RGBA = texelFetch(iChannel0, ij, 0);\n}\n", "buffer_d_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 692], [694, 694, 739, 739, 1950]]}
{"id": "sddGR8", "name": "Wireframe Wander Cube", "author": "Tater", "description": "Use more steps to march deeper into the cube fractal\nOriginal parts:\nhttps://www.shadertoy.com/view/7sdGRr\nhttps://www.shadertoy.com/view/Nst3RH", "tags": ["3d", "raymarching", "wireframe"], "likes": 28, "viewed": 1019, "published": 3, "date": "1629168683", "time_retrieved": "2024-07-30T19:06:05.315024", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy,0.);\n\n    for(float i = 0.; i < 7.; i+=0.24){\n        fragColor += texture(iChannel0, fragCoord/iResolution.xy, i)/18.;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"cube wireframe thingy\" by Tater. https://shadertoy.com/view/sddGR8\n// 2021-08-17 03:45:12\n\n// Fork of \"Lost Wander Cube\" by Tater. https://shadertoy.com/view/Nst3RH\n// 2021-08-17 02:45:45\n\n//Add more steps to destroy your PC and make it look cooler\n#define STEPS 60.0\n\n#define MDIST 100.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p, x) (mod(p,x)-0.5*(x))\n\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\nfloat frame(vec3 p, vec3 s, float e){\n    vec2 h = vec2(e,0);\n    float a = box(p,s);\n    float b = box(p,s*1.01-h.xxy);\n    a = max(-b,a);\n    b = box(p,s*1.01-h.xyx);\n    a = max(-b,a);\n    b = box(p,s*1.01-h.yxx);\n    a = max(-b,a);\n    return a;\n}\nfloat timeRemap (float t,float s1, float s2, float c){\n    return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)+s1*t;  \n}\nvoid mo(inout vec2 p){\n  if(p.y>p.x) p = p.yx;\n}\nvec3 kifs;\nvec2 map(vec3 p){\n    vec3 po2 = p;\n    \n    p.xz*=rot(iTime*0.8);\n    p.xy*=rot(iTime*0.4);\n    vec3 po = p;\n    float t = (iTime+50.0)*0.7;\n    t = timeRemap(t*1.3, 0.0, 2.3, 0.1);\n\n    for(float i = 0.0; i< 9.0; i++){\n        p = abs(p)-2.0*i*kifs;\n        p.xz*=rot(pi/2.0);\n        mo(p.xy);\n        mo(p.zy);\n       // p.x-=sign(p.y)*sin(t);\n       \n    }\n    \n    //Inner Cubes\n    p = pmod(p,2.2);\n    vec2 a = vec2(box(p,vec3(0.5)),1.0);\n    a.x = abs(a.x)-0.2;\n    a.x = abs(a.x)-0.1;\n    vec2 b = vec2(box(p,vec3(0.45)),2.0);\n    \n    a = (a.x<b.x)?a:b;\n    \n    p = po;\n    p.xy*=rot(pi/4.0);\n    \n    //Boundry Cut Cube\n    vec3 cube = vec3(4,4,4)*vec3(1.2+0.5*sin(t),1.2+0.5*cos(t),1.2+0.5*sin(t));\n    a.x = max(box(p,cube),a.x);\n    b.x = max(box(p,cube),b.x);\n   \n    //Outer Frame\n    b= vec2(frame(p,cube+0.15,0.45),3.0);\n    a = (a.x<b.x)?a:b;\n    return a;\n}\nvec3 norm(vec3 p, float s) {\n  vec2 off=vec2(s,0);\n  return normalize(\n   vec3(map(p+off.xyy).x, map(p+off.yxy).x, map(p+off.yyx).x)\n  -vec3(map(p-off.xyy).x, map(p-off.yxy).x, map(p-off.yyx).x));\n}\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,2,-19);\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*1.0+uv.x*r+uv.y*cross(f,r);\n    float t = (iTime+50.0)*0.7;\n    t = timeRemap(t*1.3, 0.0, 2.3, 0.1);\n    kifs = abs(vec3(asin(sin(t*0.15)),0.2*asin(sin(t*0.22)),0.3*asin(sin(t*0.38))));\n     float s=1.0;\n    \n    float rayDist,shad;\n    vec3 p = ro;\n    vec2 d;\n    bool hit = false;\n    vec3 al;\n    \n    //Raymarch loop\n    for(float i =0.0; i<STEPS; i++){\n        p = ro+rd*rayDist;\n        d = map(p);\n        if(abs(d.x)<0.01){\n            float edge = 0.04*clamp(800.0/iResolution.x,1.0,2.0);\n            float edgeAmount = length(norm(p, 0.015)-norm(p, edge));\n            \n            //Adjusting line transparency based on steps\n            col += smoothstep(0.0,0.1, edgeAmount)*0.045*(128.0/min(STEPS,200.0));\n            s*=-1.0;\n            d.x = 0.01*s;\n            if(!hit){\n            if(d.y == 1.0)al = vec3(1.000,0.302,0.404);\n            if(d.y == 2.0)al = vec3(0.016,1.000,1.000);\n            if(d.y == 3.0)al = vec3(1.000,0.647,0.325);\n                shad = i/STEPS;\n                hit = true;\n            }\n        }\n        if(rayDist>MDIST) break;\n        rayDist+=d.x*s*0.85;\n       \n    }\n    vec3 wire = col;\n    wire = clamp(wire,0.0,1.0)*al;\n    shad = pow(1.0-shad,2.0);\n    if(hit)col = vec3(shad)*sqrt(al);\n    col = wire;\n    fragColor = vec4(col,1.0);\n}\n#define AA 1.0\nvoid mainImage(out vec4 O,vec2 C){\n    float px=1./AA,i,j;vec4 cl2,cl;\n    if(AA==1.){render(cl,C);O=cl;return;}\n    for(i=0.;i<AA +min(iTime,0.0);i++){for(j=0.;j<AA;j++){\n    vec2 C2 = vec2(C.x+px*i,C.y+px*j);\n    render(cl2,C2);cl+=cl2;\n    }}cl/=AA*AA;O=cl;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 243]]}
{"id": "7sdGRr", "name": "Wireframe Rendering Trick", "author": "Tater", "description": "Idea/Technique taken from @NuSan, in his \"wireframe window\" shader \t[url]https://www.shadertoy.com/view/7tjSWt[/url]\nI wanted to highlight this technique because I thought it was so cool. ", "tags": ["3d", "sdf", "wireframe"], "likes": 52, "viewed": 1493, "published": 3, "date": "1629166385", "time_retrieved": "2024-07-30T19:06:06.070006", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n\n//This technique will eat steps like nothing else if you have a complex scene, but it does\n//look nice\n#define STEPS 128.0\n\n#define MDIST 50.0\n\nfloat box( vec3 p, vec3 b ){\n  vec3 d = abs(p)-b;\n  return max(d.x,max(d.y,d.z));\n}\nfloat octa( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*-tan(5.0*pi/6.0);\n}\n\n//Standard SDF scene with material IDs\nvec2 map(vec3 p){\n    vec2 a = vec2(1),b = vec2(2);\n    float t = iTime;\n    vec3 po = p;\n    \n    //Box\n    p.x+=9.0;\n    p.xy*=rot(t);\n    p.yz*=rot(t);\n    p.zx*=rot(t);\n    a.x = box(p, vec3(1.5));\n    //Onion the box\n    a.x = abs(abs(a.x)-0.4)-0.2;\n    \n    //Octahedron Thing\n    p = po;\n    p.xy*=rot(-t);\n    p.yz*=rot(-t);\n    p.zx*=rot(t);\n    \n    b.x = octa(p,4.0);\n    b.x = max(b.x,box(p,vec3(4.0-(sin(t)*0.5+0.5)*2.0)));\n    a = (a.x<b.x)?a:b;\n    \n    //Exploding Cube\n    p = po;\n    p.x-=9.0;\n    p.xy*=rot(-t);\n    p.yz*=rot(t);\n    p.zx*=rot(-t);\n    float off = 0.8*min(2.5*(sin(t)*0.5+0.5),1.5);\n    \n    p= abs(p)-off*0.9;\n    p= abs(p)-off*1.3;\n    \n    b.x =  box(p,vec3(0.75));\n    b.y = 3.0;\n    a = (a.x<b.x)?a:b;\n    return a; \n}\n\n//Not all normal functions work the same, @totetmatt also suggested this one\n//which works as well.\n\n/*\n#define q(s) s*map(p+s).x\nvec3 norm(vec3 p,float e){vec2 nv=vec2(e,-e); return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\n*/\n\nvec3 norm(vec3 p, float s) {\n  vec2 off=vec2(s,0);\n  return normalize(\n   vec3(map(p+off.xyy).x, map(p+off.yxy).x, map(p+off.yyx).x)\n  -vec3(map(p-off.xyy).x, map(p-off.yxy).x, map(p-off.yyx).x));\n}\n\n//When I first saw NuSan's shader from the nevoke pre-jam I didn't notice\n//he was actually rendering the wireframe of objects and not just the edge.\n//I've tried to come up with a way to render SDF wireframes more than once\n//so seeing such an easy way to do it feels like a christmas present\n\n//Brief Explination based on my understanding of how this works:\n//Hit an object, calculate it's edge with FMS_Cat edge technique,\n//March through the inside of the object, then after hitting the inside \n//calculate the edge again and combine it with previous edges\n\n//Technically the rendered lines are like 90 degree corners,\n//so if they are very thick or the angles are shallow you will \n//be able to tell that they aren't a consistent width, but the \n//effect is still quite good imo.\n\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    vec3 ro = vec3(0,0,-16.5);\n    vec3 lk = vec3(0,0,0.0);\n    vec3 f = normalize(lk-ro);\n    vec3 ra = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*0.9+uv.x*ra+uv.y*cross(f,ra);\n    \n    //s (sign) variable will be used to keep track of if we are marching inside\n    //or outside an object\n    \n    //In NuSan's original shader he didn't used this, and instead added\n    //the abs() of the distance to keep marching through objects\n    //This way has the benefit of being able to converge to the surface before\n    //continuing which makes the lines a bit crisper, but costs some steps & performance\n    float s=1.0;\n    \n    float rayDist,shad;\n    vec3 p = ro;\n    vec2 d;\n    bool hit = false;\n    vec3 al;\n    \n    //Raymarch loop\n    for(float i =0.0; i<STEPS; i++){\n\n        //Set current point to based on rayDistance\n        p = ro+rd*rayDist;\n        \n        //Get scene dist and material ID\n        d = map(p);\n       \n        //Converge onto the surface (Seems large epsilon values work better)\n        if(abs(d.x)<0.01){\n        \n            //Determine wireframe/material color whenever an object is hit\n            if(d.y == 1.0)al = vec3(1.000,0.659,0.976);\n            if(d.y == 2.0)al = vec3(0.016,1.000,1.000);\n            if(d.y == 3.0)al = vec3(1.000,0.647,0.325);\n            \n            //Calculate how big the normal sample offset difference should be\n            //based on ray distance, so the wireframe is the same thickness\n            //everywhere. \n            \n            //You can remove the \"rayDist\" term and the wireframes will get thinner\n            //further away which sometimes looks better but you will need to increase\n            //the initial value considerably \n            float edge = 0.003*rayDist*clamp(800.0/iResolution.x,1.0,2.5);\n            \n            //Edge detection, not sure exactly how this works but I think FMS_Cat\n            //was the first one to use this trick. \n            \n            //You take length of the difference of two normalize vectors, the bigger \n            //the difference in offset of the normal the thicker the edge will be. \n            float edgeAmount = length(norm(p, 0.015)-norm(p, edge));\n            \n            //Add the detected edge, I use smoothstep here to make\n            //The edge a bit crisper but it's not nessecary.\n            \n            //Multiply this value by a lower number to give the wireframe\n            //a trasparent effect (helps a lot in complex scenes) \n            col += smoothstep(0.0,0.1, edgeAmount)*0.25;\n            \n            //The magic bit, after we detect an edge invert the s (sign) value,\n            //and keep marching through the object but now with an inverted\n            //distance field, so the edge detection gets run every time we hit\n            //any sufrace, effectively creating a wireframe instead of just edges\n            s*=-1.0;\n            d.x = 0.01*s;\n            \n            //Quick iteration based fake ao to get shading\n            if(!hit){\n                shad = i/STEPS;\n                hit = true;\n            }\n        }\n        //A maximum distance break is pretty required since the rays will never hit anything\n        if(rayDist>MDIST) break;\n        \n        //Add the current scene distance to the ray length, with the s (sign) value\n        //so we always march through objects, some understepping also helps remove \n        //artifacts.\n        rayDist+=d.x*s*0.825;\n        \n        //Alternatively you can remove the s (sign) term from everywhere in the shader\n        //and replace this bit with\n        //rayDist+=abs(d.x);\n       \n    }\n    //Grab the wireframe color that came out of the ray marcher\n    vec3 wire = col;\n    \n    //Color the wireframe\n    wire = clamp(wire,0.0,1.0)*al;\n    \n    //Quick iteration shading\n    shad = pow(1.0-shad,2.0);\n    if(hit)col = vec3(shad)*sqrt(al);\n    \n    //Mix between shaded and wireframe scene\n    col = mix(col,wire,clamp(1.0-pow(sin(t*0.5),3.0),0.0,1.0));\n    \n    fragColor = vec4(col,1.0);\n}\n//My quick copy paste AA\n//If you can afford the performance it looks a lot better with AA (change AA to 2.0);\n#define AA 1.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            //If the shader uses accumulation effects they need to be reset here\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n\n\n//Fabrice's magic AA\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    render(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 247, 247, 302], [303, 303, 332, 332, 391], [393, 432, 449, 449, 1191], [1433, 1433, 1461, 1461, 1631], [2420, 2420, 2474, 2474, 6610], [6765, 6765, 6822, 6822, 7317]]}
{"id": "NddGzH", "name": "UV Mapping Truchet Tiles", "author": "byt3_m3chanic", "description": "Thank you @Fabrice for helping me though this beast - wanted to share / Doing a UV map on a tile set made my head cave in but wow!! ( Kind of looking like a Lisa Frank sticker)", "tags": ["raymarching", "uv", "truchet", "tiles"], "likes": 52, "viewed": 1041, "published": 3, "date": "1629158129", "time_retrieved": "2024-07-30T19:06:06.823989", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    UV Mapping a Truchet Tile Set\n    @byt3_m3chanic 8/16/21\n\n\n    Thank you @Fabrice for the knowledge and math\n    Started as an experiment - how can I do this.\n    https://www.shadertoy.com/view/sdtGRn\n\n    And finally ended up here, it's pretty tricky as\n    you have to get the closest arc and use that in\n    the mapping formula.\n\n*/\n\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    20.00\n#define MIN_DIST    0.001\n#define SCALE       0.7500\n\n//utils\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n//globals\nvec3 hit,hitP1,sid,id;\nfloat speed,sdir,hitD,chx,checker;\nmat2 t90;\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//@iq torus sdf\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n//make tile piece\nfloat truchet(vec3 p,vec3 x, vec2 r) {\n    return min(torus(p-x,r),torus(p+x,r));\n}\n//const\nconst float size = 1./SCALE;\nconst float hlf = size/2.;\nconst float shorten = 1.26;   \n//domain rep\nvec3 drep(inout vec3 p) {\n    vec3 id=floor((p+hlf)/size);\n    p = mod(p+hlf,size)-hlf;\n    return id;\n}\nvec2 drep(inout vec2 p) {\n    vec2 id=floor((p+hlf)/size);\n    p = mod(p+hlf,size)-hlf;\n    return id;\n}\nvec2 map(vec3 q3){\n    vec2 res = vec2(100.,0.);\n\n    float k = 5.0/dot(q3,q3); \n    q3 *= k;\n\n    q3.z += speed;\n\n    vec3 qm = q3;\n    vec3 qd = q3+hlf;\n    qd.xz*=t90;\n    vec3 qid=drep(qm);\n    vec3 did=drep(qd);\n    \n    float ht = hash21(qid.xy+qid.z);\n    float hy = hash21(did.xz+did.y);\n    \n    float chk1 = mod(qid.y + qid.x,2.) * 2. - 1.;\n    float chk2 = mod(did.y + did.x,2.) * 2. - 1.;\n\n    // truchet build parts\n    float thx = .115;\n    float thz = .200;\n\n    if(ht>.5) qm.x *= -1.;\n    if(hy>.5) qd.x *= -1.;\n\n    float t = truchet(qm,vec3(hlf,hlf,.0),vec2(hlf,thx));\n    if(t<res.x) {\n        sid = qid;\n        hit = qm;\n        chx = chk1;\n        sdir = ht>.5 ? -1. : 1.;\n        res = vec2(t,2.);\n    }\n\n    float d = truchet(qd,vec3(hlf,hlf,.0),vec2(hlf,thz));\n    if(d<res.x) {\n\n        sid = did;\n        hit = qd;\n        chx = chk2;\n        sdir = hy>.5 ? -1. : 1.;\n        res = vec2(d,1.);\n    }\n\n    float mul = 1.0/k;\n    res.x = res.x * mul / shorten;\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t)\n{ \n    vec3 d = vec3(0.220,0.961,0.875);\n    return .375 + .375*cos(PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nfloat gear(vec2 p, float radius)\n{\n    //length of cog\n    float sp = floor(radius*PI2)*2.;\n    float gs = length(p.xy)-radius;\n    float at = atan(p.y,p.x);\n    //gear teeth\n    float gw = abs(sin(at*sp)*.15);\n    gs +=smoothstep(.05,.5,gw);\n\n    gs=max(gs, -(length(p.xy)-(radius*.45)) );\n    return gs;\n}\n\nvec4 FC= vec4(.001,.001,.001,0.);\nvec3 lpos = vec3(-hlf,hlf,3.85);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    \n    for(int i=0;i<150;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<64? ray.x*.35: ray.x;\n        m  = ray.y;\n    } \n    // save globals\n    hitP1 = hit;\n    id = sid;\n    hitD = sdir;\n    checker=chx;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST) {\n    \n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.05);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float bounce = clamp(dot(n,vec3(0.,-1.,0.)), 0.,1.);\n        \n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; ){\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        \n        diff += bounce;\n        diff = mix(diff,diff*shdw,.65);\n  \n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n\n        // uv mapping stuff here\n        \n        if(m==2.) {\n           vec3 hp = hitP1*hitD;\n            \n            // get closest arc\n            vec2 d3 = vec2(length(hp-hlf), length(hp+hlf));\n            vec3 g3 = d3.x<d3.y? vec3(hp-hlf) : vec3(hp+hlf);\n            \n            //angle for the tube\n            float angle = atan(g3.y,g3.x)/PI2;\n            //angle for the arc/truchet path\n            float gz =  atan( hp.z,  length(g3.yx)-hlf ) / PI2;\n            //make the uv\n            vec2 uv = vec2(angle,gz);\n\n            if(hitD<1. ^^ checker>0.) uv.y*=-1.;\n            // make truchet design down\n            float px  = .0125;\n            \n            vec2 scaler = vec2(28.,6.);\n            vec2 grid = fract(uv.xy*scaler)-.5;\n            vec2 cid   = floor(uv.xy*scaler);\n\n            if(hash21(cid)<.5) grid.x*=-1.;\n            \n            h = vec3(.6); \n\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n            float circle = length(gx)-.5;\n            float center =smoothstep(.03-px,px,abs(abs(abs(circle)-.2)-.1)-.025);\n            h = mix(vec3(0),h, center);\n           \n            ref = vec3(clamp(1.-center,0.,1.))-fresnel;\n        }\n\n        if(m==1.) {\n            vec3 hp = hitP1*hitD;\n            \n            // get closest arc\n            vec2 d3 = vec2(length(hp-hlf), length(hp+hlf));\n            vec3 g3 = d3.x<d3.y? vec3(hp-hlf) : vec3(hp+hlf);\n    \n            //angle for the tube\n            float angle = atan(g3.y,g3.x)/PI2;\n            //angle for the arc/truchet path\n            float gz =  atan( hp.z,  length(g3.yx)-hlf ) / PI2;\n            //make the uv\n            vec2 uv = vec2(angle,gz);\n\n            if(hitD<1. ^^ checker>0.) uv.y*=-1.;\n            // make truchet design down\n            float px  = .0125;\n           \n            vec2 scaler = vec2(28.,10.);\n            vec2 grid = fract(uv.xy*scaler)-.5;\n            vec2 cid   = floor(uv.xy*scaler);\n            float hs = hash21(cid);\n            if(hs<.5) grid.x*=-1.;\n\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n            float circle = length(gx)-.5;\n            float center =smoothstep(.03-px,px,abs(circle)-.15);\n            h = mix(hue(length(p.zy*.3)*3.) ,hue(length(p.zx*.5)*2.), center);\n            \n            //debug with london texture \n            //h=texture(iChannel0,uv*vec2(8.,4.)).rgb;\n            \n            // super freakout animation\n            float chk = mod(cid.y + cid.x,2.) * 2. - 1.;\n            vec2 arc = grid-sign(grid.x+grid.y+.001)*.5;\n            float angle2 = atan(arc.x, arc.y);\n            float width = .2;\n            float d = length(arc);\n            // coord checker\n            float tm = T*.25;\n            vec2 tuv = vec2(\n                fract(1.*chk*angle2/1.57+tm),\n                (d-(.5-width))/(2.*width)*2.\n            );\n            tuv.y-=.5;\n            vec2 tid = vec2(\n                floor(1.*chk*angle2/1.57+tm),\n                floor(d-(.5-width))/(2.*width)\n            );\n\n            tuv.xy*=vec2(2.,.5);\n            tuv.x=mod(tuv.x+.5,1.)-.5;\n            // float ddt = length(tuv.xy-vec2(0,.25))-.25;\n            \n            // new gear spin thing\n            // comment out to change back to dots - and use above.\n            vec2 gvec = tuv.xy-vec2(0,.25);\n            float dir = (chk>0.^^ hs>.5) ? -1.:1.;\n            gvec*= rot( (T*1.4) * dir);\n            float ddt = gear(gvec,.45);\n            // end\n            \n            ddt = smoothstep(-px,px,min(ddt,center));\n            h = mix(h,vec3(0.),ddt);\n            \n            \n            ref = vec3(clamp(1.-center,0.,1.))-fresnel;\n        }\n\n        C = diff*h+spec;\n        if(last) C = mix(FC.rgb,C,  exp(-.05*d*d*d));\n    \n        ro = p+n*.002;\n        rd = reflect(rd,n);\n    } else {\n        C = FC.rgb;\n    }\n     \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    t90 = rot(90.*PI/180.);\n    speed = T*.225;\n    //\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,3.5);\n    vec3 rd = normalize(vec3(uv,-1));\n    //mouse rotation\n    float x = -.305;\n    float y = -.750;\n    \n    if(M.z>0.){\n        x = -(M.y/R.y * .5 - .25) * PI;\n        y = -(M.x/R.x * .5 - .25) * PI;\n    }\n    \n    mat2 rx = rot(x);\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    // pre render\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    vec3 fil=vec3(1.);\n    \n    float d =0.;\n    float bounces = 2.;\n    for(float i=0.; i<bounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==bounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) FC = vec4(FC.rgb,exp(-.145*d*d*d));\n    }\n\n    //mixdown\n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddGzH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[670, 678, 699, 699, 754], [755, 755, 773, 773, 818], [897, 897, 925, 925, 1012], [1013, 1029, 1060, 1060, 1125], [1126, 1144, 1182, 1182, 1227], [1323, 1336, 1361, 1361, 1440], [1441, 1441, 1466, 1466, 1545], [1546, 1546, 1564, 1564, 2554], [2556, 2631, 2661, 2661, 2900], [2902, 2902, 2921, 2921, 3021], [3023, 3023, 3057, 3077, 3330], [8733, 8733, 8774, 8788, 9715]]}
{"id": "Nst3RH", "name": "Lost Wander Cube", "author": "Tater", "description": "I originally made this for a project with @Drayken where he did the lighting and I did the geometry, but I've come back to it a number of times so I figured I would publish my version.\n\n@Drayken's version: [url]https://www.shadertoy.com/view/7djXRm[/url]\n", "tags": ["3d", "raymarching", "fractal"], "likes": 22, "viewed": 498, "published": 3, "date": "1629152104", "time_retrieved": "2024-07-30T19:06:07.571990", "image_code": "#define STEPS 128.0\n#define MDIST 250.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p, x) (mod(p,x)-0.5*(x))\nfloat glow = 0.0;\n\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat frame(vec3 p, vec3 s, float e){\n    vec2 h = vec2(e,0);\n    float a = box(p,s);\n    float b = box(p,s*1.01-h.xxy);\n    a = max(-b,a);\n    b = box(p,s*1.01-h.xyx);\n    a = max(-b,a);\n    b = box(p,s*1.01-h.yxx);\n    a = max(-b,a);\n    return a;\n}\n\nfloat timeRemap (float t,float s1, float s2, float c){\n    return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)+s1*t;  \n}\n\nvoid mo(inout vec2 p){\n  //p = abs(p)-d;\n  if(p.y>p.x) p = p.yx;\n}\nvec3 kifs;\nvec2 map(vec3 p){\n    vec3 po2 = p;\n    \n    p.xz*=rot(iTime*0.8);\n    p.xy*=rot(iTime*0.4);\n    vec3 po = p;\n    float t = iTime*0.7;\n    t = timeRemap(t*1.3, 0.0, 2.3, 0.1);\n\n    for(float i = 0.0; i< 9.0; i++){\n        p = abs(p)-2.0*i*kifs;\n        p.xz*=rot(pi/2.0);\n        mo(p.xy);\n        mo(p.zy);\n        p.x-=sign(p.y)*sin(t);\n       \n    }\n    \n    //Inner Cubes\n    p = pmod(p,2.2);\n    vec2 a = vec2(box(p,vec3(0.5)),1.0);\n    a.x = abs(a.x)-0.2;\n    a.x = abs(a.x)-0.1;\n    vec2 b = vec2(box(p,vec3(0.45)),2.0);\n    \n    a = (a.x<b.x)?a:b;\n    \n    p = po;\n    p.xy*=rot(pi/4.0);\n    \n    //Boundry Cut Cube\n    vec3 cube = vec3(4,4,4)*vec3(1.2+0.5*sin(t),1.2+0.5*cos(t),1.2+0.5*sin(t));\n    a.x = max(box(p,cube),a.x);\n    b.x = max(box(p,cube),b.x);\n    glow+=0.01/(0.01+b.x*b.x);\n    //Outer Frame\n    b= vec2(frame(p,cube+0.15,0.45),3.0);\n    a = (a.x<b.x)?a:b;\n    \n    //Repeating Poles\n    vec3 po3 = po2;\n    po3.xy*=rot(sin(t)*0.9);\n    //po3.yz*=rot(sin(t)*0.4);\n    po3.zx*=rot(sin(t+0.5)*0.9);\n    po3+=sin(t)*3.0;\n    \n    \n    \n    po2.y-=iTime*20.0;\n    po2=mod(po2,80.0)-40.0;\n    po2.x+=sin(po3.y*0.05+iTime);\n    b.x = length(po2.xz)-2.0-clamp(sin(po3.y*0.5-iTime*10.0),-0.2,0.2);\n    b.x = min(b.x,length(po2.zy)-2.0-clamp(sin(po3.x*0.5),-0.2,0.2));\n    b.x = min(b.x,length(po2.xy)-2.0-clamp(sin(po3.z*0.5),-0.2,0.2));\n    b.y=4.0;\n    a = (a.x<b.x)?a:b;\n    \n    return a;\n}\nvec3 norm(vec3 p){\n    vec2 e= vec2(0.03,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    glow = 0.;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 al;\n    vec3 ro = vec3(0,2,-20);\n    //ro.xz*=rot(iTime*0.4);\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*1.0+uv.x*r+uv.y*cross(f,r));\n    \n    vec3 p = ro;\n    float dO;\n    float shad = 0.0;\n    vec2 d;\n    float t = iTime*0.7;\n    t = timeRemap(t*1.3, 0.0, 2.3, 0.1);\n    //Kifs Style taken from by FMS_Cat <3\n    kifs = abs(vec3(asin(sin(t*0.15)),0.2*asin(sin(t*0.22)),0.3*asin(sin(t*0.38))));\n    for(float i = 0.0; i < STEPS; i++){\n        d = map(p);\n        float dStep = d.x;\n        if(d.x>1.0) dStep = pow(d.x,1.0-d.x/MDIST);\n        dO += dStep;\n        p = ro+rd*dO;\n        if(abs(d.x)<0.001||i==STEPS-1.0 ){\n            shad = i/STEPS;\n            break;\n        }\n        if(dO>MDIST) break;\n    }\n    if(d.y==1.0) al = vec3(0.863,0.043,0.020);\n    if(d.y==2.0) al = vec3(0.529,0.000,0.722);\n    if(d.y==3.0) al = vec3(0.000,0.000,0.000);\n    if(d.y==4.0) al = vec3(0.000,0.000,0.000);\n    \n    vec3 n = norm(p);\n    float aor=dO/50.;\n    float ao=exp2(-2.*pow(max(0.,1.-map(p+n*aor).x/aor),4.));\n    al*=(.5*ao+0.5);\n    col = vec3(pow(1.0-shad,2.))*al;\n    \n\n    vec3 ld = vec3(1,1,-1);\n    vec3 h = normalize(ld-rd);\n    float spec = pow(max(dot(reflect(-rd,n),rd),0.3),5.);\n    float fres = pow(1. - max(dot(n, -rd),0.), 5.);\n    float diff = max(dot(n, ld),0.);\n    \n    vec3 light = vec3(0.910,0.800,1.000);\n    col*=clamp(diff,0.6,1.0)*light;\n    if(d.y!=4.0)col+=spec*light*0.25;\n    if(d.y!=3.0&&d.y!=4.0)col+=glow*0.105*\n    mix(vec3(0.569,0.082,1.000),vec3(0.267,0.082,1.000),sin(length(p)*2.0)*0.5+0.5);\n    col = mix(col,vec3(0.318,0.180,0.439)*(1.-length(uv)*0.6),clamp(dO/MDIST,0.0,1.0));\n    \n    col = pow(col,vec3(0.85));//Gamma correction\n    fragColor = vec4(col,1);\n}\n#define AA 1.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            glow = 0.;\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nst3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 197, 197, 256], [258, 258, 295, 295, 509], [511, 511, 565, 565, 635], [637, 637, 659, 677, 703], [715, 715, 732, 732, 2126], [2127, 2127, 2145, 2145, 2271], [2272, 2272, 2326, 2326, 4225], [4269, 4269, 4326, 4326, 4763]]}
{"id": "fdt3z8", "name": "break box", "author": "jorge2017a1", "description": "break box", "tags": ["breakbox"], "likes": 3, "viewed": 249, "published": 3, "date": "1629143471", "time_retrieved": "2024-07-30T19:06:08.317996", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\n///------------------------------------\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPolyc000 POLY(16)\nvec2 ptc000[ 16]=vec2[](  \nvec2(.139,.346),vec2(.295,.188),vec2(.498,.371),vec2(.599,.106),vec2(.828,.248),\nvec2(.924,.255),vec2(.899,.574),vec2(.793,.590),vec2(.858,.810),vec2(.638,.839),\nvec2(.569,.948),vec2(.311,.812),vec2(.207,.905),vec2(.079,.739),vec2(.202,.580),\nvec2(.139,.346) );\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    p.y=p.y-21.0;\n    \n    float sdb1= sdBox(  p-vec3(0.5,0.5,0.0), vec3(1.2,1.1,0.25) );\n    \n    float sdc000 = sdPolyc000(p.xy, ptc000);\n    float dif= differenceSDF(sdb1, sdc000);\n    res =opU3(res, vec3(dif,100.0,MATERIAL_NO)); \n    \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/2., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj;  \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n   \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\t}\n    return colobj;\n}\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.5,21.5,-1.0+0.45*sin(iTime));\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n///--------------------------------------------FIN\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 433, 465, 465, 549], [550, 594, 641, 641, 668], [669, 669, 712, 712, 739], [740, 740, 788, 788, 816], [1554, 1594, 1619, 1619, 2011], [2013, 2064, 2088, 2088, 2250], [2252, 2252, 2301, 2301, 2968], [2970, 3024, 3060, 3060, 3305], [3306, 3361, 3388, 3388, 3405], [3407, 3407, 3443, 3443, 3535], [3536, 3536, 3582, 3582, 3707], [3709, 3709, 3783, 3783, 5382], [5383, 5438, 5487, 5487, 5729], [5730, 5764, 5844, 5844, 5967], [5968, 6009, 6041, 6041, 6238], [6239, 6291, 6384, 6384, 6629], [6630, 6630, 6661, 6661, 7253], [7255, 7304, 7330, 7330, 7440], [7442, 7442, 7500, 7500, 7552], [7554, 7603, 7660, 7660, 8182]]}
{"id": "Ndd3R8", "name": "O -= O tests", "author": "elenzil", "description": "setups, top to bottom:\n1) O\n2) float(iFrame)\n3) sin(t) in [-1, 1]\n4) NaN\n5) Inf\n6) O -= O\n7 .. 9) various O -= styles which should yield 0.5\n\ntests, left to right:\nA) isnan()\nB) isinf()\nC) bits!\nD) value", "tags": ["ios"], "likes": 5, "viewed": 251, "published": 3, "date": "1629139773", "time_retrieved": "2024-07-30T19:06:09.076966", "image_code": "\nvoid mainImage( out vec4 O, in vec2 XY )\n{\n    vec2 UV = XY / iResolution.xy;\n    \n    //----------------------------------------------\n    // Setup the value\n    \n    float runtimeInf = uintBitsToFloat(uint(0x7f800000));\n    float runtimeNaN = uintBitsToFloat(uint(0x7fffffff));\n    \n    const float NumSetups = 9.0;\n    \n    float t = iTime * 3.14159265 * 2.0 / 10.0;\n\n    if (false) { /* noop */ }\n    else if (UV.y > 8.0 / NumSetups) {       // O\n        /* noop */\n    }\n    else if (UV.y > 7.0 / NumSetups) {       // iFrame\n        O = vec4(float(iFrame));\n    }\n    else if (UV.y > 6.0 / NumSetups) {       // sin(t) in [-1, 1]\n        O = vec4(sin(t));\n    }\n    else if (UV.y > 5.0 / NumSetups) {       // NaN\n        O = vec4(runtimeNaN);\n    }\n    else if (UV.y > 4.0 / NumSetups) {       // Inf\n        O = vec4(runtimeInf);\n    }\n    else if (UV.y > 3.0 / NumSetups) {       // O -= O\n        O -= O;\n    }\n    else if (UV.y > 2.0 / NumSetups) {       // O += 0.5 - O\n        O += 0.5 - O;\n    }\n    else if (UV.y > 1.0 / NumSetups) {       // O -= O - 0.5\n        O -= O - 0.5;\n    }\n    else if (UV.y > 0.0 / NumSetups) {       // O -= -0.5 + O\n        O -= -0.5 + O;\n    }\n    \n    //----------------------------------------------\n    // Examine the value\n    \n    const float NumTests = 4.0;\n    if (false) {}\n    else if (UV.x < 1.0 / NumTests) {\n        O.rgb = vec3(isnan(O.r) ? 0.5 : 0.0);\n    }\n    else if (UV.x < 2.0 / NumTests) {\n        O.rgb = vec3(isinf(O.r) ? 0.5 : 0.0);\n    }\n    else if (UV.x < 3.0 / NumTests) {\n        float testWidthPx = iResolution.x / NumTests;\n        int i = int(XY.x - testWidthPx * 2.0);\n        int bitIndex = int(float(i) * 32.0 / testWidthPx);\n        uint bitValue = (floatBitsToUint(O.r) >> (31 - bitIndex)) % uint(2);\n        O = vec4(bitValue == uint(1) ? 1.0 : 0.0);\n        O = mix(O, vec4(0.5), step(0.7, fract(float(i)  * 32.0 / testWidthPx)));\n    }\n    else { /* noop */ }\n    \n    bool isGridLine = false;\n    isGridLine = isGridLine || !bool(step(3.0, mod(XY.y, (iResolution.y - 2.0) / NumSetups)));\n    isGridLine = isGridLine || !bool(step(3.0, mod(XY.x, (iResolution.x - 2.0) / NumTests )));\n\n    if (isGridLine) {\n        O.rgb = vec3(0.7, 0.0, 0.5);\n    }\n\n    \n    O.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndd3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 43, 43, 2258]]}
{"id": "ssc3R8", "name": "Julia Set (HIRC)", "author": "hyperborean_rs_collective", "description": "HIRC Julia Set Fractal Visualizer\n\nJoin the Research Collective!\ndiscord.gg/dKEWzPxaPP", "tags": ["fractal", "research"], "likes": 2, "viewed": 274, "published": 3, "date": "1629122476", "time_retrieved": "2024-07-30T19:06:09.826960", "image_code": "void mainImage(out vec4 OutColor, in vec2 InCoord) {\n\n    // SECTION: Input generation\n    vec2 UV = InCoord.xy / iResolution.xy;\n    vec4 BufferA = texture(iChannel0, UV);\n    vec3 Color = BufferA.rgb;\n\n    // SECTION: Lighting\n    \n    // NOTE: Lighting can be created using Integration.\n    // vec2 Eps = vec2(1e-1, 0.0);\n    // Integrate the angles using UV + Eps.xy, UV + Eps.yx, etc!\n    // TODO: Poisson sampling\n\n    // SECTION: Produce colour\n    OutColor = vec4(Color, 1.0);\n        \n    \n    // SECTION: Apply image effects\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Re-Names\n#define BufferA mainImage\n#define OutColor fragColor\n#define InCoord fragCoord\n\n#define ZOOM 1.0\n#define SCALE exp(ZOOM)\n\nvoid BufferA(out vec4 OutColor, in vec2 InCoord) {\n    float AspectRatio = iResolution.x / iResolution.y;\n    vec2 AspectRatioCorrector = vec2(AspectRatio, 1.0);\n    \n    // In range [0..1]\n    vec2 UV = fragCoord / iResolution.xy;\n    \n    // In range [-1..1]\n    vec2 NDC = RemapUVtoNDC(UV);\n    \n    // In range [-AspectRatio .. AspectRatio, -1.0, 1.0]\n    vec2 NDC_AR_Corrected = NDC * AspectRatioCorrector;\n    \n    // Current Point\n    vec2 Z = SCALE * NDC_AR_Corrected;\n    \n    // Seed value\n    vec2 C = SCALE * GetC(iTime);\n   \n    // (Real, Imag, Radius Squared) \n    // These values are set in the 'Compute the Fractal' section\n    vec3 Calculation;\n    vec3 PreviousCalculation;\n\n    int IterationsRemaining = BASE_ITERATIONS;\n    \n    do { /* SECTION: Compute the fractal */\n        PreviousCalculation = Calculation;\n        Calculation = Calculate(Z, C, PreviousCalculation);\n        // Z = Z^2 + C\n        Z = Calculation.xy;\n        \n        IterationsRemaining--;\n    } while (IterationsRemaining > 0);\n\n    vec2 PreviousZ = PreviousCalculation.xy;\n    float Angle = AngleBetweenPoints2D(Z, PreviousZ); \n    \n    \n    /*\n        Angle /= Calculation.z + PreviousCalculation.z;\n    */\n    vec3 Spectrum = Colorize(Angle);\n\n    // Output to the Buffer A texture\n    OutColor = vec4(Spectrum, Angle);\n}", "buffer_a_inputs": [], "common_code": "// Common functions, constants and Compile options\n\n// Compile options:\n\n// For this Shader, the less iterations are best for visualization\n#define BASE_ITERATIONS (3)\n\n// Remaps a [0..1] point to [-1.0..1.0]\nvec2 RemapUVtoNDC(vec2 point) {\n    return -1.0 + 2.0 * point;\n}\n\nvec2 CModifier(vec2 C, float Time) {\n    return C * 1.0;\n}\n\n// Creates a value of C based on the Time parameter given\nvec2 GetC(float Time) {\n    vec2 C = vec2(cos(Time), sin(Time)) * 0.5;\n    // C = CModifier(C, Time);\n    return C;\n}\n\nvec2 ExpressionA(vec2 Z, vec3 PreviousResult) {\n    return abs(Z);\n}\n\nvec2 ExpressionModifier(vec2 Z, vec3 PreviousResult) {\n    //return abs(Z);\n    return Z;\n}\n\n// Returns: (Real, Imag, Radius Squared)\nvec3 Calculate(vec2 Z, vec2 C, vec3 PreviousResult) {\n    float Real = Z.x;\n    float RealSq = Real * Real;\n    \n    float Imag = Z.y;\n    float ImagSq = Imag * Imag;\n\n    vec2 Complex = vec2(RealSq - ImagSq, 2.0 * Real * Imag) + C;\n    Complex = ExpressionModifier(Complex, PreviousResult);\n    \n    \n    float RadiusSq = RealSq + ImagSq;\n    return vec3(Complex, RadiusSq);\n}\n\n\n// Returns: The angle between two 2D points in Radians\nfloat AngleBetweenPoints2D(vec2 A, vec2 B) {\n    vec2 Difference = A - B;\n    return atan(Difference.y, Difference.x);\n}\n\nvec3 Colorize(float AngleRads) {\n    const float PhaseDifference = radians(120.0); // 1 + 2 + 0 = 3. A key to the universe.\n    vec3 Sines = vec3(sin(AngleRads), sin(AngleRads + PhaseDifference), sin(AngleRads - PhaseDifference));   \n    vec3 Transform = 0.5 + 0.5 * Sines;\n    return Transform;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssc3R8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 86, 536]]}
{"id": "sscGR8", "name": "Black Panther Tribute", "author": "chenglou", "description": "Beat synced to [url=https://youtu.be/Iuw8Lrg0Jyg]Black Panther's ending theme[/url].\nColor scheme inspired by the movie's tunnel fight\n[b]Mouse drag[/b]. Adjust reflection passes in Buffer A\nImprovements: add t for normal & raymarch + antialias", "tags": ["raytracing", "sdf", "scene"], "likes": 5, "viewed": 617, "published": 3, "date": "1629114709", "time_retrieved": "2024-07-30T19:06:10.593910", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (fwidth(length(color)) > 0.01) { // antialiasing\n        for (int x = -1; x < 2; x++) {\n        for (int y = -1; y < 2; y++) {\n            if (x == 0 && y == 0) continue;\n            color += texelFetch(iChannel0, ivec2(fragCoord + vec2(x, y)), 0);\n        }\n        }    \n        color /= 9.;\n    }\n\n    color = pow(color, vec4(1.0/2.2)); // gamma correction\n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27995, "src": "https://soundcloud.com/falljoker/kendrick-lamar-sza-all-the-stars-instrumental", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// Beat is synced to All The Stars: https://youtu.be/Iuw8Lrg0Jyg\n\n#define MAX_DEPTH 3 // 2 reflection passes. 60fps on this machine\n\n#define PI 3.14159\n\n// utils from inigo\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opRep( in float p, in float s ) {\n    return mod(p+s*0.5,s)-s*0.5;\n}\nfloat expImpulse(float x, float k) {\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n// modified from mercury sdf\nvec3 pModPolarXY(vec3 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2. + p.z / 2.; // twist the tunnel\n\tfloat r = length(p.xy);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec3(cos(a) * r, sin(a) * r, p.z);\n}\n\nconst vec3 Killmonger = vec3(0.77, 0.62, 0.32);\nconst vec3 TChalla = vec3(0.72, 0.52, 0.99); // RIP\nconst vec3 Okoye = vec3(0.84, 0.53, 0.46);\n// All The Stars from Black Panther has a beat per minute of 97\nconst float secondPerBeat = 60. / 97.;\n// Music's beat starts slightly later\nconst float beatPhase = 1.5;\n\nstruct material { vec3 attenuation; vec3 emission; float sdf; };\n\nmaterial map(vec3 p, float beat) {\n    // polar repeat & twist field\n    vec3 rotatedP = pModPolarXY(p, 8.); // 8 rail blocks\n    rotatedP.x += beat * 0.03 - 0.3; // periodic impulse, try in graphtoy\n    rotatedP.z = opRep(p.z - iTime / 2., 0.25); // z axis move & rail block repeat\n    \n    const vec3 halfSize = vec3(.015, .077, 0.11);\n    float dRailways = sdBox(rotatedP, halfSize);\n    float dLights = sdBox(rotatedP, halfSize + vec3(-0.01, 0.01, -0.01)) - 0.004; // rounder\n    float dOrb = sdSphere(p, 0.1);\n    \n    // colors\n    vec3 attenuation, emission;\n    if (dRailways > dLights || dRailways > dOrb) {\n        vec3 color = mod(iTime + beatPhase, secondPerBeat * 2.) > secondPerBeat ? TChalla : Killmonger;\n        attenuation = color;\n        emission = color * (0.7 + beat / 2.); // tune up emission when the beat's high\n    } else {\n        attenuation = Okoye;\n        emission = vec3(0);\n    }\n\n    return material(attenuation, emission, min(dRailways, min(dLights, dOrb)));\n}\n\nvec3 calcNormal( in vec3 p, float beat, float t) {\n    float h = 1e-5 * (1. + t);\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h, beat).sdf + \n                      k.yyx*map( p + k.yyx*h, beat).sdf + \n                      k.yxy*map( p + k.yxy*h, beat).sdf + \n                      k.xxx*map( p + k.xxx*h, beat).sdf );\n}\n\nfloat maxT = 12.;\nbool rayMarch(vec3 ro, vec3 rd, float beat, out float t, out material m, out vec3 glow) {\n    t = 1e-3;\n    glow = vec3(1);\n    for(int i = 0; i < 85; i++) {\n        vec3 p = ro + t * rd;\n        m = map(p, beat);\n        float df = abs(m.sdf);\n        \n        if (df < 0.0007 * (1. + t * 0.5)) return true;\n        if (t > maxT) return false;\n        \n        // add a physically incorrect glow when near an emissive material\n        const float glowDist = .05;\n        float diff = glowDist - df;\n        glow += m.emission * step(0., diff) * diff * 5.; // adjust 5 for glow strengh\n        \n        t += m.sdf;\n    }\n    return false;\n}\n\nvec3 rayTrace(vec3 ro, vec3 rd, float beat, vec2 seed) {\n    vec3 color = vec3(0);\n    // We want the emissive lights to also keep reflecting. See usage below\n    // This should be the correct way to calculate such light. I haven't seen\n    // it anywhere else (iteratively, on GLSL) so I had to derive the calculations.\n    vec3 accumulatedAttenuation = vec3(1);\n\n    vec3 ro_ = ro;\n    vec3 rd_ = rd;\n    float f = 0.0;\n\n    const vec3 background = vec3(0.09, 0.09, .27);\n    const vec3 backgroundAttenuation = background * 0.1;\n    vec3 glow;\n\n    for (int depth = 0; depth < MAX_DEPTH; depth++) {\n        float t;\n        material m;\n        bool hit = rayMarch(ro_, rd_, beat, t, m, glow);\n        \n        f += t * dot(rd_, rd); // from Xor: add to compute total distance from camera\n        if (hit) {\n            vec3 pos = ro_ + rd_ * t;\n            // f correction (instead of using t) from Xor: https://twitter.com/XorDev/status/1758518050003755164\n            vec3 normal = calcNormal(pos, beat, f);\n            vec3 reflected = reflect(rd_, normal);\n\n            color += accumulatedAttenuation * m.emission;\n            accumulatedAttenuation *= m.attenuation;\n\n            if (dot(reflected, normal) > 0.) {\n                ro_ = pos;\n                rd_ = reflected;\n            }\n        } else {\n            float gradient = rd_.y / iResolution.y * 500. + 0.5;\n            vec3 emission = background * gradient;\n            \n            color += accumulatedAttenuation * emission;\n            accumulatedAttenuation *= backgroundAttenuation;\n            color += accumulatedAttenuation;\n            \n            break;\n        }\n    }\n    color *= glow; // this isn't physically accurate but whatever\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n    // camera\n    vec3 ro;\n    if (length(iMouse.xy) == 0.) {\n        ro = smoothstep(0., 0.9, vec3(vec2(1) - iTime / 4., 1));\n    } else {\n        ro = vec3(-(2. * iMouse.xy - iResolution.xy) / iResolution.y, 1);\n    }\n    vec3 lookat = vec3(cos(iTime) / 10., sin(iTime) / 10., 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 50.;\n\n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(ro - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n\n    vec3 horizontal = viewport_width * u;\n    vec3 vertical = viewport_height * v;\n    vec3 lower_left_corner = ro - horizontal / 2. - vertical / 2. - w;\n\n    vec3 rd = normalize(lower_left_corner + uv.x * horizontal + uv.y * vertical - ro);\n\n    float beat = expImpulse(mod(iTime + beatPhase, secondPerBeat), 14.);\n    vec3 color = rayTrace(ro, rd, beat, uv);\n\n    fragColor = vec4(color, 1.0);\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscGR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 511]]}
{"id": "Ns33RH", "name": "tone mapping / brightness adapta", "author": "FabriceNeyret2", "description": "WIP.  Normalize the render by the brightest pixel.\nMax is computed via Smart MIPmap ( see https://www.shadertoy.com/view/WdyGWd ).\nOf course, ultimate mipmap  would be far more accurate using a power-of-2 buffer ( e.g. a cubemap face ).", "tags": ["brightness", "tonemapping", "gpmipmap", "adaptation"], "likes": 2, "viewed": 381, "published": 3, "date": "1629109716", "time_retrieved": "2024-07-30T19:06:11.353878", "image_code": "\nvoid mainImage(out vec4 O, vec2 U) { \n    U /= iResolution.xy;\n    O = texture( iChannel0, U );\n    \n    float m = decodeMax( textureLod( iChannel0, U, 8. ).a ); // brightest pixel value\n  \n     O *= 3./m;  // brightness adaptation: normalize by brightest pixel\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )             // rotation                  \nvec3 M;\n\n#define TAU 6.283185\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.;\n    vec2  P,d;\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q, a;                                   // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O-=O ; O.x < 1.5 && t > .01 ; O+=.01 )\n        t=9., q = p,\n        q.yz *= rot( .5+6.*M.y),                             // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        a = abs(q),\n        t = min(t, max(a.x,max(a.y,a.z)) - 5. ),             // cube\n        p += t*D;                          // step forward = dist to obj          \n\n    if (O.x > 1.5) {                                         // background\n        D.yz *= rot( .5+6.*M.y),                             // rotations\n        D.xz *= rot( 2.-6.*M.x),\n        O = texture(iChannel0,D);                            // envmap\n        O.a = encodeMax( ( exp(5.*O.r)-1. ) /20. );          // fake lightmap\n      }\n    else { O = exp(-3.*O/2.);             // luminance (depth + pseudo-shading )\n    }\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// see https://www.shadertoy.com/view/WdyGWd\nfloat POW = 5.; // best compromize for max = 10, but here we want some smoothing too\n#define encodeMax(v) pow(v,POW)     // for max of image using MIPmap\n#define decodeMax(v) pow(v,1./POW)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns33RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 264]]}
{"id": "Ndc3RH", "name": "Arachnogenesis", "author": "dr2", "description": "Spiders have to come from somewhere...", "tags": ["spiral", "spider", "gait", "logarithm"], "likes": 24, "viewed": 394, "published": 3, "date": "1629108034", "time_retrieved": "2024-07-30T19:06:12.109857", "image_code": "// \"Arachnogenesis\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 7 in \"Spider\" series\n    \"Octopod\"                     (4tjSDc)\n    \"Moebius Strip\"               (lddSW2)\n    \"Moebius Strip 2\"             (MscXWX)\n    \"Spider Ascent\"               (4sd3WX)\n    \"Moebius, Menger, Spiders\"    (wsXyzM)\n    \"Helical Ramps with Spiders\"  (3sscWf)\n*/\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec3 footPos[8], kneePos[8], hipPos[8], ltDir, qHit;\nfloat tCur, dstFar, legLenU, legLenD, bdyHt, spdVel;\nint idObj;\nconst int idBdy = 1, idHead = 2, idEye = 3, idAnt = 4, idLegU = 5, idLegD = 6;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SpdDf (vec3 p, float dMin)\n{ // (see \"Moebius, Menger, Spiders\")\n  vec3 q;\n  float d, s, len, szFac;\n  szFac = 0.12;\n  p /= szFac;\n  dMin /= szFac; \n  p.y -= bdyHt - 0.1;\n  q = p - vec3 (0., -0.15, 0.2);\n  d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3));\n  DMINQ (idBdy);\n  q = p - vec3 (0., 0.1, 1.1);\n  d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5));\n  DMINQ (idHead);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 0.25, 1.5);\n  d = PrSphDf (q, 0.13);\n  DMINQ (idEye);\n  q -= vec3 (0., 0.15, -0.3);\n  d = PrEETapCylDf (q, 1.3 * vec3 (0.3, 1.1, 0.4), vec3 (0.), 0.07, 0.7);\n  DMINQ (idAnt);\n  p.y += bdyHt;\n  for (int j = 0; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = 0.6 * PrEETapCylDf (q, kneePos[j], hipPos[j], 0.25, 0.3);\n    DMINQ (idLegU);\n    q = p - kneePos[j];\n    d = 0.6 * PrEETapCylDf (q, footPos[j] - vec3 (0.3), kneePos[j] - vec3 (0.3), 0.2, 1.2);\n    DMINQ (idLegD);\n  }\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{ // (see \"Spiraling Out\")\n  vec3 q;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  q = p;\n  r = length (q.xz);\n  if (r > 0.01) {\n    a = atan (q.z, q.x) / pi;\n    q.xz = - (mod (vec2 (0.5 * (pi * log (r) + a) - 0.05 * tCur, 5. * a) + 0.5, 1.) - 0.5);\n    q.y *= 0.7 / sqrt (r);\n    dMin = 0.5 * r * SpdDf (q, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (h < 0.001 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SpdCol (vec3 vn)\n{\n  vec3 col, c1, c2;\n  c1 = vec3 (0.5, 1., 0.2);\n  c2 = vec3 (0.5, 0.2, 0.2);\n  if (idObj == idBdy) {\n    col = mix (c1, c2, SmoothBump (0.2, 0.7, 0.05, mod (4. * qHit.z, 1.)));\n  } else if (idObj == idHead) {\n    col = c2;\n    if (qHit.z > 0.4) col = mix (vec3 (0.2, 0.05, 0.05), col,\n       smoothstep (0.02, 0.04, abs (qHit.x)));\n  } else if (idObj == idEye) {\n    col = (vn.z < 0.6) ? vec3 (0., 1., 0.) : c1;\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (c2, c1,  SmoothBump (0.4, 1., 0.2, fract (3.5 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvoid SpdSetup (float gDisp)\n{\n  vec3 v;\n  float a, az, fz, d, ll;\n  for (int j = 0; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];\n    hipPos[j + 4].x *= -1.;\n  }\n  bdyHt = 1.5;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = 0; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) + mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = SpdCol (vn);\n    if (idObj != idEye) col = Maxv3 (col) * vec3 (1.);\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    col = mix (vec3 (0.3), col, smoothstep (0.05, 0.1, length (vec2 (ro.xz))));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    vn = vec3 (0., 1., 0.);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir, dstFar);\n    col = vec3 (0.4) * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.));\n  } else col = vec3 (0.4);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.03 * pi * tCur;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.35 * pi, -0.15 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -30.);\n  zmFac = 4.;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -1.));\n  spdVel = 1.5;\n  SpdSetup (spdVel * tCur);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf)\n{\n  vec3 v;\n  float s;\n  v = v1 - v2;\n  s = clamp (dot (p, v) / dot (v, v), 0., 1.);\n  return length (p - s * v) - r * (1. - rf * s * s);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ndc3RH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1062, 1062, 1096, 1132, 1979], [1981, 1981, 2003, 2028, 2334], [2336, 2336, 2369, 2369, 2617], [2619, 2619, 2640, 2640, 2895], [2897, 2897, 2946, 2946, 3199], [3201, 3201, 3224, 3224, 3849], [3851, 3851, 3880, 3880, 4936], [4938, 4938, 4973, 4973, 5654], [5656, 5656, 5712, 5712, 6437], [6439, 6439, 6472, 6472, 6499], [6501, 6501, 6567, 6567, 6705], [6707, 6707, 6742, 6742, 6804], [6806, 6806, 6828, 6828, 6866], [6868, 6868, 6925, 6925, 7008], [7010, 7010, 7046, 7046, 7252], [7254, 7254, 7284, 7284, 7397]]}
{"id": "fdcGRH", "name": "3D close-loop spiral - 2", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/NddGzn[/url]\nmouse control\nWIP: still connection artifacts.", "tags": ["spiral", "short"], "likes": 13, "viewed": 336, "published": 3, "date": "1629103326", "time_retrieved": "2024-07-30T19:06:12.863841", "image_code": "// variant of https://shadertoy.com/view/NddGzn\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )             // rotation                  \nvec3 M;\n\n#define TAU 6.283185\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,l,a,A,s,z=0.,S,H,h,l2,r=25.,r2=20.33; //, Z=0.;\n    vec2  P,d;\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q;                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1.5 && t > .01 ; O+=.01 )\n        t=9., q = p,\n        q.yz *= rot( .5+6.*M.y),                             // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        q.zy *= H = sign(h=q.y),           q.y -= r/2.,      // top-down symmetry\n        q.xz *= S = sign(q.x +sign(q.z)) , q.x -= TAU*3.5,   // left-right symmetry\n        l = length(q.xz), a = atan(q.z,q.x),\n        s = min( TAU*3.5, l - a),                            // spiral coord ( truncated )\n        l = round(s/TAU)*TAU + a,                            // l reset at tube center\n        l = max(0.,r-l),\n        q.y += r2 - sqrt(max(0.,r2*r2-l*l)),                 // spiral sinking\n    a = max (0., round(s/TAU)*TAU + a ),\n    a = S*H*a*a/2.-20.*iTime -H*1.4, a*=2.,                      // curvilinear coordinate\n    q.y += sin(a), s += cos(a),                              // helicoid\n        t = min(t, length(vec2( mod(s+TAU/2.,TAU)-TAU/2.,q.y)) - .5), // SDF\n        p += .25*t*D; // , Z+=t;                             // step forward = dist to obj          \n\n // O = vec4(1.6-Z/200.); return;                    // for Depth buffer\n  //O = max(1.5-3.*O,0.);\n    O = O.x > 1.5 ? vec4(0.) : 4.*exp(-3.*O/2.);             // luminance (depth + pseudo-shading )\n                           // vec4(exp(-(Z-300.)/200.));\n    O *= vec4(.5+.5*h/r2,.5-.5*h/r2,0,0);    // color\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 207, 207, 1983]]}
{"id": "ssd3Rr", "name": "Lena Soderberg", "author": "Witek", "description": "Famous Lena image compressed with SIREN neural network. Trained with Adam algorithm on CPU", "tags": ["compression", "image", "neuralnetwork", "siren"], "likes": 23, "viewed": 1005, "published": 3, "date": "1629065039", "time_retrieved": "2024-07-30T19:06:13.985841", "image_code": "vec2 grad( ivec2 z )\n{\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n    return vec2(cos(float(n)),sin(float(n)));                          \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat v_0_0 = 2.0 * fragCoord.x / iResolution.x - 1.0;\n\tfloat v_0_1 = 2.0 * fragCoord.y / iResolution.y - 1.0;\n\tfloat v_1_0 = sin(-15.749390*v_0_0+2.467443*v_0_1+0.642972);\n\tfloat v_1_1 = sin(-8.764448*v_0_0+8.972171*v_0_1-0.246504);\n\tfloat v_1_2 = sin(2.079661*v_0_0-0.565238*v_0_1+0.016377);\n\tfloat v_1_3 = sin(-4.528710*v_0_0+11.748545*v_0_1+0.074486);\n\tfloat v_1_4 = sin(9.896638*v_0_0+7.860395*v_0_1+0.926652);\n\tfloat v_1_5 = sin(-10.150239*v_0_0+10.332283*v_0_1+0.449958);\n\tfloat v_1_6 = sin(6.384732*v_0_0+0.263559*v_0_1-0.339646);\n\tfloat v_1_7 = sin(-5.242582*v_0_0-14.390223*v_0_1-0.593600);\n\tfloat v_1_8 = sin(-12.397568*v_0_0-4.610657*v_0_1-0.252255);\n\tfloat v_1_9 = sin(-10.366361*v_0_0-11.147682*v_0_1+0.190910);\n\tfloat v_1_10 = sin(14.244532*v_0_0-1.578685*v_0_1-0.219945);\n\tfloat v_1_11 = sin(-12.053640*v_0_0-13.701488*v_0_1-0.669969);\n\tfloat v_1_12 = sin(-14.218564*v_0_0-3.153181*v_0_1-0.301633);\n\tfloat v_1_13 = sin(0.828735*v_0_0+1.137885*v_0_1+0.147247);\n\tfloat v_1_14 = sin(3.314677*v_0_0+2.571989*v_0_1-0.257351);\n\tfloat v_1_15 = sin(-9.440269*v_0_0+5.666999*v_0_1+0.469530);\n\tfloat v_1_16 = sin(-1.699901*v_0_0-4.921369*v_0_1+0.061349);\n\tfloat v_1_17 = sin(-13.737357*v_0_0+3.157089*v_0_1+0.167369);\n\tfloat v_1_18 = sin(8.368551*v_0_0+8.838763*v_0_1+0.330037);\n\tfloat v_1_19 = sin(0.916331*v_0_0-6.649802*v_0_1+0.646310);\n\tfloat v_1_20 = sin(13.024671*v_0_0+5.573820*v_0_1+0.071979);\n\tfloat v_1_21 = sin(13.883341*v_0_0+12.520011*v_0_1-0.498547);\n\tfloat v_1_22 = sin(0.552199*v_0_0-11.150436*v_0_1-0.345762);\n\tfloat v_1_23 = sin(-1.491720*v_0_0-7.268486*v_0_1-0.108306);\n\tfloat v_1_24 = sin(11.672986*v_0_0-8.112849*v_0_1+0.179875);\n\tfloat v_1_25 = sin(7.334301*v_0_0+10.062238*v_0_1-0.175000);\n\tfloat v_1_26 = sin(15.619444*v_0_0+14.586774*v_0_1+0.397141);\n\tfloat v_1_27 = sin(4.485784*v_0_0-3.369560*v_0_1-0.194340);\n\tfloat v_1_28 = sin(-7.059183*v_0_0-6.053284*v_0_1+0.179697);\n\tfloat v_1_29 = sin(10.597829*v_0_0-13.960537*v_0_1-0.103465);\n\tfloat v_1_30 = sin(-4.128477*v_0_0-11.817846*v_0_1-0.054170);\n\tfloat v_1_31 = sin(6.165703*v_0_0-13.486117*v_0_1+0.186833);\n\tfloat v_1_32 = sin(-14.692471*v_0_0+12.268010*v_0_1+0.292376);\n\tfloat v_1_33 = sin(-6.251513*v_0_0-6.756928*v_0_1-0.037965);\n\tfloat v_1_34 = sin(3.518636*v_0_0+5.374871*v_0_1+0.262203);\n\tfloat v_1_35 = sin(10.684721*v_0_0+6.133939*v_0_1-0.081342);\n\tfloat v_1_36 = sin(-0.602145*v_0_0-9.013171*v_0_1+0.278911);\n\tfloat v_1_37 = sin(7.346097*v_0_0-1.136418*v_0_1+0.604018);\n\tfloat v_1_38 = sin(-2.373563*v_0_0+13.776805*v_0_1-0.056559);\n\tfloat v_1_39 = sin(7.269861*v_0_0-10.788553*v_0_1-0.034897);\n\tfloat v_1_40 = sin(3.086473*v_0_0-3.390917*v_0_1+0.614137);\n\tfloat v_1_41 = sin(7.541430*v_0_0+2.775830*v_0_1-0.482546);\n\tfloat v_1_42 = sin(2.191930*v_0_0-3.989583*v_0_1-0.454749);\n\tfloat v_1_43 = sin(-11.042057*v_0_0-8.130956*v_0_1+0.448241);\n\tfloat v_1_44 = sin(-2.719099*v_0_0+9.383417*v_0_1+0.015181);\n\tfloat v_1_45 = sin(1.175184*v_0_0+14.192170*v_0_1-0.171184);\n\tfloat v_1_46 = sin(7.084381*v_0_0-4.544268*v_0_1-0.649499);\n\tfloat v_1_47 = sin(-10.298572*v_0_0+4.544588*v_0_1-0.705458);\n\tfloat v_2_0 = sin(-0.065482*v_1_0-0.485541*v_1_1-0.282011*v_1_2-0.033789*v_1_3-0.104469*v_1_4+0.355055*v_1_5-0.108360*v_1_6+0.139673*v_1_7-0.061030*v_1_8-0.367185*v_1_9+0.289661*v_1_10+0.081991*v_1_11+1.089167*v_1_12+1.364067*v_1_13-0.083250*v_1_14+0.922163*v_1_15+0.343875*v_1_16-0.085565*v_1_17-0.468821*v_1_18+0.275525*v_1_19+0.270840*v_1_20+0.158315*v_1_21-0.037194*v_1_22-0.128225*v_1_23-0.408752*v_1_24-0.129172*v_1_25+0.066759*v_1_26+0.375691*v_1_27+0.219501*v_1_28-0.029511*v_1_29-0.038434*v_1_30-0.057808*v_1_31+0.196591*v_1_32-0.053747*v_1_33-0.090249*v_1_34+0.034427*v_1_35-0.252116*v_1_36+0.929282*v_1_37-0.118457*v_1_38+0.251970*v_1_39+0.215242*v_1_40+0.019846*v_1_41+0.236909*v_1_42-0.190732*v_1_43+0.025062*v_1_44-0.234045*v_1_45+0.047061*v_1_46-0.314656*v_1_47+0.133179);\n\tfloat v_2_1 = sin(-0.243781*v_1_0-0.485275*v_1_1+0.030238*v_1_2+0.481586*v_1_3-0.388494*v_1_4+0.711691*v_1_5-0.808955*v_1_6-0.102940*v_1_7-0.625539*v_1_8-0.005834*v_1_9+0.051530*v_1_10+0.129800*v_1_11-1.313116*v_1_12+0.424066*v_1_13-0.091396*v_1_14-0.139008*v_1_15-0.029123*v_1_16+1.065114*v_1_17+0.261688*v_1_18-0.070311*v_1_19-0.278773*v_1_20-0.303570*v_1_21+0.016473*v_1_22-0.927586*v_1_23-0.581223*v_1_24-0.284578*v_1_25-0.045697*v_1_26+0.206580*v_1_27-0.038907*v_1_28-0.634797*v_1_29+0.005725*v_1_30+0.002758*v_1_31+0.643740*v_1_32-0.567981*v_1_33+0.213010*v_1_34+0.574765*v_1_35-0.345832*v_1_36-0.705120*v_1_37-0.605076*v_1_38-0.637799*v_1_39+0.136577*v_1_40+0.496751*v_1_41+1.047688*v_1_42-0.144254*v_1_43+0.790090*v_1_44-0.024628*v_1_45+0.214587*v_1_46+0.424814*v_1_47+0.053577);\n\tfloat v_2_2 = sin(0.261282*v_1_0-0.040384*v_1_1+0.756232*v_1_2-0.233554*v_1_3+0.138241*v_1_4-0.212729*v_1_5+0.013198*v_1_6+0.252980*v_1_7-0.217172*v_1_8-0.035718*v_1_9-0.871267*v_1_10-0.101065*v_1_11+0.043691*v_1_12+0.509285*v_1_13+0.388802*v_1_14+0.136715*v_1_15+0.126780*v_1_16-0.322012*v_1_17-0.329437*v_1_18-0.228591*v_1_19-0.287443*v_1_20+0.202141*v_1_21-0.187505*v_1_22+0.341014*v_1_23-0.521987*v_1_24-0.065612*v_1_25-0.086088*v_1_26-0.237491*v_1_27+0.348716*v_1_28-0.272090*v_1_29+0.097524*v_1_30+0.021353*v_1_31-0.275169*v_1_32+0.329974*v_1_33+0.088159*v_1_34+0.141247*v_1_35+0.171108*v_1_36+0.313542*v_1_37+0.166780*v_1_38+0.618090*v_1_39+0.019327*v_1_40+0.317309*v_1_41+0.589071*v_1_42+0.262586*v_1_43-0.302786*v_1_44-0.086138*v_1_45-0.182733*v_1_46-0.038340*v_1_47+0.029004);\n\tfloat v_2_3 = sin(0.523252*v_1_0+0.107384*v_1_1+0.327781*v_1_2-0.076413*v_1_3+0.440611*v_1_4-0.785551*v_1_5+0.574956*v_1_6+0.219944*v_1_7-0.240581*v_1_8+0.286866*v_1_9-1.483904*v_1_10+0.135453*v_1_11+0.801191*v_1_12+0.314990*v_1_13+0.400898*v_1_14-0.085023*v_1_15+0.003784*v_1_16-1.142911*v_1_17-0.389492*v_1_18+0.228838*v_1_19-0.546678*v_1_20+0.045068*v_1_21+0.029305*v_1_22-0.358098*v_1_23-0.380731*v_1_24+0.197180*v_1_25-0.507613*v_1_26-0.429272*v_1_27-0.678066*v_1_28+0.073406*v_1_29-0.120085*v_1_30+0.099233*v_1_31+1.168502*v_1_32-0.078105*v_1_33-0.461475*v_1_34-0.368327*v_1_35+0.574204*v_1_36-0.569624*v_1_37+0.194489*v_1_38+0.645453*v_1_39+0.288659*v_1_40-0.552237*v_1_41+0.988756*v_1_42-0.715570*v_1_43-0.479663*v_1_44-0.219703*v_1_45+0.222237*v_1_46-0.701252*v_1_47+0.013962);\n\tfloat v_2_4 = sin(1.009539*v_1_0-0.890739*v_1_1+0.130483*v_1_2+0.392527*v_1_3+0.926352*v_1_4-0.781537*v_1_5+0.082838*v_1_6+0.205554*v_1_7+0.170102*v_1_8+0.236811*v_1_9+0.050157*v_1_10-0.306443*v_1_11-0.383757*v_1_12+0.230556*v_1_13-0.469003*v_1_14-0.107211*v_1_15+0.497177*v_1_16-0.109261*v_1_17+0.527491*v_1_18+0.020104*v_1_19-0.323089*v_1_20-0.243583*v_1_21+0.393569*v_1_22+0.585943*v_1_23+0.411503*v_1_24-0.094103*v_1_25+0.201898*v_1_26+0.115527*v_1_27-0.258112*v_1_28-0.356221*v_1_29-0.009961*v_1_30+0.309046*v_1_31+0.722463*v_1_32-0.432392*v_1_33+0.028823*v_1_34-0.203498*v_1_35-0.291320*v_1_36-0.091262*v_1_37-0.312483*v_1_38-0.561505*v_1_39+0.760351*v_1_40-0.013419*v_1_41+0.740596*v_1_42+0.034939*v_1_43+0.263984*v_1_44-0.495019*v_1_45-0.343489*v_1_46-0.516831*v_1_47+0.347113);\n\tfloat v_2_5 = sin(-0.420654*v_1_0+0.159252*v_1_1-0.404101*v_1_2-0.031743*v_1_3-0.371783*v_1_4+0.112538*v_1_5-0.204502*v_1_6+0.086386*v_1_7-0.462020*v_1_8-0.030599*v_1_9-0.591690*v_1_10-0.033343*v_1_11+0.000614*v_1_12+0.503653*v_1_13+0.250502*v_1_14+0.111668*v_1_15+1.183839*v_1_16-0.011763*v_1_17+0.056834*v_1_18-0.689230*v_1_19-0.152907*v_1_20-0.008814*v_1_21-0.183631*v_1_22-0.786173*v_1_23-0.632439*v_1_24+0.056131*v_1_25+0.311545*v_1_26-0.110195*v_1_27-0.006212*v_1_28-0.227251*v_1_29-0.075126*v_1_30+0.004017*v_1_31-0.593923*v_1_32+0.114781*v_1_33+0.445595*v_1_34-0.610677*v_1_35-0.117124*v_1_36+0.237041*v_1_37-0.107714*v_1_38+0.234535*v_1_39+0.009986*v_1_40+0.193452*v_1_41-0.116010*v_1_42+0.216591*v_1_43+0.139846*v_1_44-0.290340*v_1_45-0.257458*v_1_46+0.266675*v_1_47-0.147822);\n\tfloat v_2_6 = sin(0.228909*v_1_0-0.962752*v_1_1-0.232604*v_1_2-0.146776*v_1_3-0.458682*v_1_4+0.345960*v_1_5-0.069072*v_1_6+0.106306*v_1_7-0.150677*v_1_8+0.068976*v_1_9-0.993672*v_1_10+0.174936*v_1_11+0.579028*v_1_12-0.187122*v_1_13-0.100288*v_1_14-0.058413*v_1_15+0.004840*v_1_16+0.466656*v_1_17+0.119247*v_1_18-0.504548*v_1_19+0.097782*v_1_20-0.107179*v_1_21-0.103314*v_1_22-0.332677*v_1_23+0.775045*v_1_24-0.272679*v_1_25-0.118795*v_1_26+0.303363*v_1_27-0.100159*v_1_28-0.210916*v_1_29-0.234506*v_1_30-0.095094*v_1_31+0.093863*v_1_32-0.145171*v_1_33+0.123557*v_1_34+0.154133*v_1_35+0.146986*v_1_36+0.447134*v_1_37+0.230364*v_1_38-0.149987*v_1_39+0.568647*v_1_40+0.372384*v_1_41+0.185303*v_1_42-0.158191*v_1_43-0.450801*v_1_44+0.218564*v_1_45-0.276979*v_1_46-0.864656*v_1_47+0.130528);\n\tfloat v_2_7 = sin(0.021612*v_1_0-0.231572*v_1_1-0.536386*v_1_2+0.009402*v_1_3-0.116061*v_1_4+0.546017*v_1_5-0.527510*v_1_6+0.188509*v_1_7-0.065978*v_1_8-0.032867*v_1_9+0.301749*v_1_10+0.033793*v_1_11-0.087999*v_1_12+0.306703*v_1_13-0.193041*v_1_14+0.061533*v_1_15-0.074861*v_1_16-0.102696*v_1_17-0.006094*v_1_18-0.541364*v_1_19-0.067838*v_1_20-0.003208*v_1_21-0.069382*v_1_22+0.321490*v_1_23-0.256434*v_1_24+0.005616*v_1_25+0.056547*v_1_26+0.388649*v_1_27-0.474492*v_1_28+0.113620*v_1_29-0.209007*v_1_30+0.129837*v_1_31+0.339257*v_1_32+0.205263*v_1_33-0.245178*v_1_34+0.271884*v_1_35-0.306944*v_1_36-1.374015*v_1_37-0.038813*v_1_38-0.092031*v_1_39+0.304206*v_1_40+0.258406*v_1_41-0.019382*v_1_42-0.060594*v_1_43-0.000571*v_1_44+0.083137*v_1_45-0.238484*v_1_46+0.116943*v_1_47+0.431592);\n\tfloat v_2_8 = sin(0.396450*v_1_0+0.537073*v_1_1+0.294232*v_1_2-0.023671*v_1_3+0.510590*v_1_4-0.029868*v_1_5+0.004290*v_1_6+0.107144*v_1_7-0.234365*v_1_8+0.221091*v_1_9+0.941722*v_1_10+0.101638*v_1_11-1.126694*v_1_12+1.167606*v_1_13-0.045161*v_1_14+0.290086*v_1_15+0.225150*v_1_16-0.014848*v_1_17+0.140963*v_1_18+0.287455*v_1_19-0.326119*v_1_20-0.022743*v_1_21-0.233708*v_1_22-0.200597*v_1_23-0.756206*v_1_24-0.197502*v_1_25-0.072886*v_1_26+0.004959*v_1_27-0.190616*v_1_28+0.154404*v_1_29-0.143276*v_1_30+0.061623*v_1_31-0.084775*v_1_32+0.101350*v_1_33+0.400096*v_1_34-0.272893*v_1_35+0.082562*v_1_36+0.352673*v_1_37+0.187678*v_1_38+0.178734*v_1_39+0.171225*v_1_40-0.627018*v_1_41+0.487755*v_1_42-0.513288*v_1_43-0.148841*v_1_44-0.024473*v_1_45-0.443729*v_1_46-0.738749*v_1_47-0.291837);\n\tfloat v_2_9 = sin(0.628888*v_1_0+0.042532*v_1_1+0.451979*v_1_2+0.202601*v_1_3+0.515466*v_1_4+0.043483*v_1_5-0.451942*v_1_6-0.294645*v_1_7+0.284067*v_1_8+0.159547*v_1_9-0.251330*v_1_10+0.545351*v_1_11-0.367912*v_1_12+1.022595*v_1_13+0.102960*v_1_14+0.269959*v_1_15+0.227489*v_1_16-0.828204*v_1_17+0.598228*v_1_18+0.320837*v_1_19-0.147786*v_1_20-0.028352*v_1_21-0.488365*v_1_22+0.581397*v_1_23-0.505583*v_1_24-0.000289*v_1_25-0.107637*v_1_26-0.568084*v_1_27-0.158838*v_1_28-0.471650*v_1_29-0.191957*v_1_30-0.350344*v_1_31+0.113408*v_1_32+0.287771*v_1_33+0.178218*v_1_34-0.040935*v_1_35+0.378300*v_1_36+0.636143*v_1_37+0.187650*v_1_38-0.122078*v_1_39-0.463819*v_1_40-0.587365*v_1_41-0.093414*v_1_42+0.209803*v_1_43+0.024453*v_1_44+0.162616*v_1_45-0.163691*v_1_46-1.050220*v_1_47-0.081950);\n\tfloat v_2_10 = sin(-0.921215*v_1_0-0.486208*v_1_1+0.077377*v_1_2+0.125184*v_1_3+0.265732*v_1_4-0.252463*v_1_5-0.335388*v_1_6+0.243923*v_1_7-0.142093*v_1_8+0.178225*v_1_9-0.254689*v_1_10-0.159924*v_1_11-0.081185*v_1_12-0.876980*v_1_13-0.014954*v_1_14-0.591578*v_1_15+0.287947*v_1_16-0.598271*v_1_17-0.414463*v_1_18+0.103354*v_1_19+0.421875*v_1_20+0.159911*v_1_21-0.088968*v_1_22-0.449890*v_1_23+0.679430*v_1_24-0.104755*v_1_25+0.277422*v_1_26-0.043298*v_1_27+0.987785*v_1_28+0.336177*v_1_29+0.005546*v_1_30+0.105312*v_1_31+0.142711*v_1_32+0.006165*v_1_33+0.174699*v_1_34+0.562172*v_1_35+0.099169*v_1_36-0.413454*v_1_37+0.294608*v_1_38+0.201657*v_1_39-0.034989*v_1_40+0.283553*v_1_41-0.028059*v_1_42+0.625677*v_1_43-0.295963*v_1_44-0.223687*v_1_45+0.335361*v_1_46+0.662039*v_1_47+0.124643);\n\tfloat v_2_11 = sin(-0.792102*v_1_0-0.112863*v_1_1-0.799639*v_1_2-0.670916*v_1_3-0.244496*v_1_4+0.006166*v_1_5+0.121469*v_1_6+0.360932*v_1_7-0.743174*v_1_8-0.160950*v_1_9+0.954147*v_1_10+0.258041*v_1_11+0.410461*v_1_12+0.087804*v_1_13+0.488679*v_1_14-0.442463*v_1_15+0.235732*v_1_16+0.565931*v_1_17-0.516639*v_1_18-0.157687*v_1_19-0.463768*v_1_20+0.114950*v_1_21+0.051910*v_1_22-0.200667*v_1_23+0.120435*v_1_24+0.094475*v_1_25+0.460711*v_1_26+0.297428*v_1_27-0.159573*v_1_28+0.075658*v_1_29-0.377757*v_1_30-0.113816*v_1_31+0.386345*v_1_32+0.155144*v_1_33-0.205374*v_1_34-0.067153*v_1_35-0.006757*v_1_36-0.152862*v_1_37+0.379470*v_1_38+0.055118*v_1_39+0.044956*v_1_40+0.698693*v_1_41-0.360601*v_1_42+0.648954*v_1_43-0.181765*v_1_44+0.052130*v_1_45-0.446568*v_1_46-0.493152*v_1_47+0.228292);\n\tfloat v_2_12 = sin(0.120703*v_1_0-0.163453*v_1_1-0.102261*v_1_2+0.115391*v_1_3+0.044434*v_1_4+0.025282*v_1_5-0.073635*v_1_6-0.283883*v_1_7-0.320301*v_1_8-0.056614*v_1_9+0.032003*v_1_10+0.199567*v_1_11+0.010077*v_1_12+0.789952*v_1_13+0.016258*v_1_14-0.016895*v_1_15+0.097705*v_1_16+1.029623*v_1_17+0.118757*v_1_18-0.090904*v_1_19-0.066853*v_1_20+0.174507*v_1_21-0.429309*v_1_22+0.111212*v_1_23+0.565507*v_1_24+0.055110*v_1_25+0.185681*v_1_26-0.066495*v_1_27-1.028828*v_1_28-0.174441*v_1_29+0.023197*v_1_30-0.245048*v_1_31-0.509236*v_1_32+0.070561*v_1_33-0.362213*v_1_34+0.363135*v_1_35+0.212430*v_1_36-0.092021*v_1_37+0.289035*v_1_38-0.666146*v_1_39+0.481131*v_1_40-0.097973*v_1_41+0.258126*v_1_42-0.369518*v_1_43-0.008344*v_1_44+0.111707*v_1_45-0.319237*v_1_46-0.275398*v_1_47+0.348788);\n\tfloat v_2_13 = sin(-0.955026*v_1_0-0.051588*v_1_1-0.432949*v_1_2+0.026348*v_1_3+0.288373*v_1_4-0.272735*v_1_5+0.265116*v_1_6-0.151294*v_1_7-0.820178*v_1_8-0.224609*v_1_9+0.420041*v_1_10-0.044821*v_1_11-0.371753*v_1_12-0.735677*v_1_13+0.172698*v_1_14-0.407175*v_1_15-0.278941*v_1_16+0.328935*v_1_17-0.093539*v_1_18-0.424080*v_1_19-0.087137*v_1_20-0.231445*v_1_21+0.103437*v_1_22+0.196380*v_1_23+0.508795*v_1_24-0.096379*v_1_25+0.013457*v_1_26+0.694139*v_1_27+0.328259*v_1_28+0.273517*v_1_29+0.476734*v_1_30+0.133802*v_1_31-0.613256*v_1_32-0.065969*v_1_33-0.208927*v_1_34+0.458196*v_1_35+0.169570*v_1_36+0.596721*v_1_37+0.117368*v_1_38-0.085388*v_1_39+0.191379*v_1_40+1.000012*v_1_41+0.213054*v_1_42+0.289329*v_1_43+0.466528*v_1_44+0.178217*v_1_45+0.035715*v_1_46-0.041321*v_1_47+0.098101);\n\tfloat v_2_14 = sin(0.465661*v_1_0-0.490508*v_1_1+0.598659*v_1_2-0.435354*v_1_3-0.289527*v_1_4-0.604629*v_1_5-0.100750*v_1_6-0.269079*v_1_7+0.503227*v_1_8+0.009803*v_1_9-1.446452*v_1_10+0.062504*v_1_11-0.003302*v_1_12+0.077491*v_1_13+0.074025*v_1_14+0.403815*v_1_15-0.252024*v_1_16-0.381423*v_1_17-0.222900*v_1_18-0.287231*v_1_19+0.126465*v_1_20-0.228581*v_1_21+0.180378*v_1_22-0.057970*v_1_23-0.031085*v_1_24-0.138320*v_1_25-0.030868*v_1_26+0.113910*v_1_27-0.310370*v_1_28+0.355517*v_1_29-0.073121*v_1_30+0.354696*v_1_31-0.043630*v_1_32+0.381754*v_1_33-0.193051*v_1_34-0.055826*v_1_35-0.226129*v_1_36-0.493185*v_1_37+0.068057*v_1_38+0.496635*v_1_39-0.232153*v_1_40+0.149254*v_1_41+0.185118*v_1_42-0.786842*v_1_43-0.005589*v_1_44+0.136762*v_1_45-0.761729*v_1_46+0.053566*v_1_47+0.184695);\n\tfloat v_2_15 = sin(0.490389*v_1_0+0.643516*v_1_1+0.727528*v_1_2+0.419497*v_1_3+0.203948*v_1_4+0.595659*v_1_5-0.013993*v_1_6-0.154276*v_1_7-0.269396*v_1_8+0.128579*v_1_9-0.158593*v_1_10+0.341583*v_1_11-0.642159*v_1_12-0.430662*v_1_13+0.490592*v_1_14+0.056263*v_1_15+0.703720*v_1_16+0.166868*v_1_17-0.110995*v_1_18+0.143408*v_1_19+0.200933*v_1_20+0.398712*v_1_21+0.117195*v_1_22-0.381320*v_1_23-0.540924*v_1_24+0.083102*v_1_25+0.217456*v_1_26-0.453737*v_1_27+0.036607*v_1_28+0.210064*v_1_29-0.084107*v_1_30+0.569143*v_1_31+1.064044*v_1_32+0.113958*v_1_33+0.476422*v_1_34-0.205325*v_1_35-0.300572*v_1_36+0.463829*v_1_37-0.299308*v_1_38+0.024790*v_1_39+0.225571*v_1_40-0.466490*v_1_41+0.233098*v_1_42+0.159885*v_1_43+0.228507*v_1_44+0.213786*v_1_45-0.047344*v_1_46-0.476736*v_1_47+0.447607);\n\tfloat v_2_16 = sin(0.226065*v_1_0-0.464152*v_1_1-0.548968*v_1_2+0.183509*v_1_3-0.022675*v_1_4+0.362456*v_1_5+0.048007*v_1_6-0.056509*v_1_7-0.036773*v_1_8-0.332735*v_1_9+0.315884*v_1_10+0.024865*v_1_11+0.072350*v_1_12-0.491434*v_1_13+0.218353*v_1_14-0.378855*v_1_15-0.279496*v_1_16-0.149269*v_1_17-0.302915*v_1_18+0.315690*v_1_19+1.201468*v_1_20+0.235721*v_1_21+0.293040*v_1_22+0.194221*v_1_23+0.605394*v_1_24+0.131936*v_1_25+0.062954*v_1_26+0.173914*v_1_27-0.328001*v_1_28-0.481479*v_1_29-0.107964*v_1_30-0.092091*v_1_31+1.076622*v_1_32+1.109377*v_1_33+0.586683*v_1_34+0.197635*v_1_35+0.129032*v_1_36-0.426267*v_1_37+0.107963*v_1_38-0.411521*v_1_39+0.337163*v_1_40-0.771956*v_1_41+0.290939*v_1_42-0.021533*v_1_43-0.554348*v_1_44+0.035170*v_1_45-0.515000*v_1_46-0.036225*v_1_47+0.470617);\n\tfloat v_2_17 = sin(1.090096*v_1_0-0.581113*v_1_1+0.563149*v_1_2+0.163119*v_1_3+0.455463*v_1_4-0.003035*v_1_5-0.275970*v_1_6+0.161739*v_1_7+0.321289*v_1_8-0.302085*v_1_9-0.416098*v_1_10-0.064625*v_1_11+0.324302*v_1_12-1.471813*v_1_13-0.058245*v_1_14-0.177870*v_1_15+1.178965*v_1_16+0.539031*v_1_17-0.490255*v_1_18+0.104189*v_1_19-0.398464*v_1_20+0.113117*v_1_21-0.158756*v_1_22+0.087700*v_1_23+0.611055*v_1_24+0.637815*v_1_25-0.328814*v_1_26-0.500496*v_1_27-0.763558*v_1_28-0.148692*v_1_29+0.141707*v_1_30+0.250422*v_1_31+0.020762*v_1_32-0.276117*v_1_33+0.191493*v_1_34+0.378450*v_1_35+0.247901*v_1_36+0.311520*v_1_37-0.139010*v_1_38-0.000044*v_1_39+0.120448*v_1_40+0.398374*v_1_41+0.057271*v_1_42+0.308107*v_1_43-0.139959*v_1_44+0.218747*v_1_45+0.436301*v_1_46-1.060995*v_1_47+0.074922);\n\tfloat v_2_18 = sin(0.517105*v_1_0-0.486687*v_1_1+0.170834*v_1_2-0.070206*v_1_3+0.212347*v_1_4+0.084106*v_1_5+0.141521*v_1_6-0.072371*v_1_7-0.323366*v_1_8-0.002015*v_1_9-0.588215*v_1_10+0.045148*v_1_11-0.089888*v_1_12+0.620090*v_1_13-0.109640*v_1_14-0.388047*v_1_15-0.475723*v_1_16-0.223685*v_1_17+0.027230*v_1_18-0.176504*v_1_19-0.449999*v_1_20-0.192002*v_1_21+0.487254*v_1_22-0.237294*v_1_23-0.743998*v_1_24+0.202171*v_1_25+0.248979*v_1_26+0.216326*v_1_27+0.466506*v_1_28-0.229890*v_1_29-0.180534*v_1_30-0.127965*v_1_31+0.000491*v_1_32-0.653314*v_1_33+0.062927*v_1_34-0.500731*v_1_35-0.684068*v_1_36+0.432098*v_1_37-0.330444*v_1_38-0.197587*v_1_39+0.356932*v_1_40-0.450409*v_1_41+0.548736*v_1_42-0.093107*v_1_43+0.074989*v_1_44+0.091096*v_1_45-0.468496*v_1_46-0.860631*v_1_47+0.271375);\n\tfloat v_2_19 = sin(-0.121527*v_1_0+0.006890*v_1_1+0.430714*v_1_2+0.063642*v_1_3-0.162154*v_1_4+0.101171*v_1_5-0.308212*v_1_6-0.151646*v_1_7+0.298833*v_1_8+0.008714*v_1_9+0.126952*v_1_10+0.071216*v_1_11+0.033123*v_1_12+0.975383*v_1_13+0.592540*v_1_14+0.642680*v_1_15-0.247403*v_1_16+0.299115*v_1_17-0.315312*v_1_18+0.601131*v_1_19+0.615430*v_1_20+0.079993*v_1_21-0.047997*v_1_22+0.236585*v_1_23-0.553341*v_1_24-0.215887*v_1_25+0.243024*v_1_26-0.262716*v_1_27+0.194788*v_1_28-0.390725*v_1_29+0.198156*v_1_30+0.041805*v_1_31+0.300592*v_1_32-0.237342*v_1_33-0.466455*v_1_34+0.356856*v_1_35-0.507444*v_1_36+0.248020*v_1_37+0.281680*v_1_38+0.125214*v_1_39-0.440793*v_1_40+0.523755*v_1_41-0.253834*v_1_42+0.146252*v_1_43+0.448543*v_1_44+0.350596*v_1_45-0.048735*v_1_46+0.454477*v_1_47-0.723260);\n\tfloat v_2_20 = sin(0.299482*v_1_0-0.853992*v_1_1+0.150054*v_1_2-0.040608*v_1_3-0.355083*v_1_4-0.462150*v_1_5+0.359507*v_1_6+0.366630*v_1_7-0.783839*v_1_8+0.137833*v_1_9+0.137501*v_1_10-0.356697*v_1_11+0.568220*v_1_12+0.319016*v_1_13+0.393319*v_1_14-0.258951*v_1_15+0.362645*v_1_16+0.695950*v_1_17+0.186544*v_1_18-0.185056*v_1_19+0.061343*v_1_20+0.129717*v_1_21-0.718779*v_1_22-0.814654*v_1_23-0.248687*v_1_24+0.515177*v_1_25+0.446662*v_1_26-0.174804*v_1_27+0.301267*v_1_28+0.694308*v_1_29-0.176498*v_1_30-0.266416*v_1_31+0.180438*v_1_32+0.085197*v_1_33-0.181435*v_1_34-0.148944*v_1_35+0.019852*v_1_36-0.357469*v_1_37+0.282083*v_1_38-0.015793*v_1_39-0.039288*v_1_40-0.168655*v_1_41+0.570005*v_1_42+0.481382*v_1_43+0.817282*v_1_44-0.140358*v_1_45+0.247235*v_1_46-0.121940*v_1_47+0.281060);\n\tfloat v_2_21 = sin(-0.620298*v_1_0+0.412467*v_1_1-0.091209*v_1_2-0.644219*v_1_3-0.272220*v_1_4-0.471176*v_1_5-0.049610*v_1_6-0.195211*v_1_7+0.217563*v_1_8-0.242275*v_1_9+0.326659*v_1_10-0.278128*v_1_11+0.710358*v_1_12-0.689592*v_1_13-0.030801*v_1_14+0.645385*v_1_15+0.088973*v_1_16+0.503382*v_1_17-0.355530*v_1_18+0.015117*v_1_19+0.070629*v_1_20+0.362865*v_1_21+0.309386*v_1_22+0.101212*v_1_23+0.681897*v_1_24+0.532936*v_1_25+0.023473*v_1_26+0.072443*v_1_27-0.150128*v_1_28+0.024546*v_1_29-0.122352*v_1_30-0.283787*v_1_31-0.523425*v_1_32-0.086021*v_1_33-0.351849*v_1_34-0.058355*v_1_35-0.273237*v_1_36+1.562192*v_1_37+0.038809*v_1_38+0.102344*v_1_39-0.041836*v_1_40+0.621281*v_1_41+0.184144*v_1_42-0.093246*v_1_43+0.118714*v_1_44+0.161072*v_1_45+0.294903*v_1_46-0.135885*v_1_47+0.347060);\n\tfloat v_2_22 = sin(0.051335*v_1_0-0.326711*v_1_1-0.223439*v_1_2-0.140766*v_1_3+0.617033*v_1_4-0.007011*v_1_5-0.241739*v_1_6-0.092541*v_1_7-0.125161*v_1_8-0.083994*v_1_9+0.321904*v_1_10-0.147467*v_1_11-0.214837*v_1_12-0.712204*v_1_13+0.014395*v_1_14-0.788289*v_1_15+0.148996*v_1_16+0.914792*v_1_17-0.162338*v_1_18+0.202246*v_1_19-0.120634*v_1_20+0.272041*v_1_21+0.146400*v_1_22-0.116175*v_1_23+0.120516*v_1_24+0.285305*v_1_25+0.320731*v_1_26-0.394528*v_1_27-0.132539*v_1_28-0.141674*v_1_29+0.164027*v_1_30-0.155925*v_1_31-0.291961*v_1_32+0.324748*v_1_33-0.470695*v_1_34-0.178628*v_1_35-0.322031*v_1_36-0.621648*v_1_37-0.442719*v_1_38+0.062315*v_1_39+0.255603*v_1_40+0.290865*v_1_41+0.339261*v_1_42+0.089589*v_1_43+0.210690*v_1_44-0.032373*v_1_45+0.672377*v_1_46+0.112730*v_1_47-0.021447);\n\tfloat v_2_23 = sin(0.538883*v_1_0+0.724938*v_1_1+0.122225*v_1_2+0.000477*v_1_3+0.500296*v_1_4-0.434093*v_1_5+0.321689*v_1_6+0.331012*v_1_7+0.469767*v_1_8+0.131898*v_1_9+0.787867*v_1_10+0.047232*v_1_11-0.684513*v_1_12+0.499856*v_1_13+0.706974*v_1_14-0.079418*v_1_15-0.405981*v_1_16+0.316957*v_1_17-0.425640*v_1_18+0.365335*v_1_19-0.579610*v_1_20+0.125251*v_1_21-0.379771*v_1_22+0.063855*v_1_23-0.643638*v_1_24-0.102211*v_1_25-0.235407*v_1_26-0.409211*v_1_27+0.006760*v_1_28-0.193037*v_1_29+0.255193*v_1_30+0.150068*v_1_31+0.331068*v_1_32-0.152804*v_1_33-0.056761*v_1_34+0.089402*v_1_35-0.072200*v_1_36+0.271572*v_1_37-0.506215*v_1_38-0.085135*v_1_39-0.989326*v_1_40-0.595057*v_1_41-0.071169*v_1_42+0.123257*v_1_43+0.155037*v_1_44-0.411145*v_1_45-0.898655*v_1_46-0.689536*v_1_47-0.665092);\n\tfloat v_2_24 = sin(-0.306966*v_1_0-0.580276*v_1_1-0.576194*v_1_2+0.130195*v_1_3-0.063913*v_1_4+0.369353*v_1_5-0.879054*v_1_6+0.049832*v_1_7-0.144330*v_1_8-0.020873*v_1_9+0.041291*v_1_10-0.106893*v_1_11-0.206894*v_1_12-0.296719*v_1_13-0.522570*v_1_14-0.168097*v_1_15+0.264081*v_1_16+0.321700*v_1_17-0.013486*v_1_18+0.063613*v_1_19-0.582263*v_1_20-0.208949*v_1_21-0.106337*v_1_22-0.325397*v_1_23+0.370379*v_1_24+0.503389*v_1_25+0.232471*v_1_26+0.282138*v_1_27-0.275855*v_1_28-0.253103*v_1_29-0.124035*v_1_30-0.179523*v_1_31-0.316148*v_1_32+0.488152*v_1_33+0.233270*v_1_34-0.199017*v_1_35+0.170693*v_1_36-0.282176*v_1_37-0.128684*v_1_38-0.585734*v_1_39-0.019644*v_1_40+0.209255*v_1_41-0.016755*v_1_42-0.632787*v_1_43+0.325115*v_1_44+0.113616*v_1_45+0.913445*v_1_46+0.883279*v_1_47-0.114134);\n\tfloat v_2_25 = sin(0.955702*v_1_0+0.084390*v_1_1+0.758439*v_1_2-0.540947*v_1_3+0.224003*v_1_4-0.356072*v_1_5-0.445557*v_1_6-0.155567*v_1_7+0.030557*v_1_8-0.527375*v_1_9-0.898238*v_1_10-0.152370*v_1_11-0.433947*v_1_12+0.160359*v_1_13+0.300817*v_1_14+0.305911*v_1_15+0.617392*v_1_16-0.212488*v_1_17-0.071661*v_1_18+0.057238*v_1_19+0.058223*v_1_20+0.064825*v_1_21+0.258969*v_1_22+0.107303*v_1_23-0.181537*v_1_24-0.034716*v_1_25+0.222675*v_1_26-0.056759*v_1_27+0.648033*v_1_28+0.107814*v_1_29+0.060169*v_1_30+0.018762*v_1_31-0.101532*v_1_32-0.165030*v_1_33+0.157734*v_1_34-0.141075*v_1_35+0.362138*v_1_36+0.226996*v_1_37-0.169289*v_1_38+0.590095*v_1_39+0.105386*v_1_40-0.994318*v_1_41-0.355687*v_1_42-0.086864*v_1_43+0.218116*v_1_44-0.029160*v_1_45+0.231911*v_1_46-0.911764*v_1_47-0.183014);\n\tfloat v_2_26 = sin(0.386710*v_1_0+0.257857*v_1_1-0.060713*v_1_2-0.025225*v_1_3+0.710780*v_1_4+0.695195*v_1_5+1.295398*v_1_6-0.246703*v_1_7-0.539690*v_1_8-0.103381*v_1_9-0.507921*v_1_10+0.308868*v_1_11+0.333093*v_1_12-0.795218*v_1_13+0.173966*v_1_14-0.244464*v_1_15-0.135273*v_1_16-0.988797*v_1_17-0.983994*v_1_18-0.246565*v_1_19-0.085464*v_1_20-0.080052*v_1_21+0.073045*v_1_22+0.194410*v_1_23-0.266440*v_1_24-0.029650*v_1_25-0.526736*v_1_26-0.372449*v_1_27-0.176393*v_1_28-0.381930*v_1_29+0.480782*v_1_30-0.139868*v_1_31+0.586109*v_1_32+0.439524*v_1_33+0.445288*v_1_34-0.912100*v_1_35+0.079869*v_1_36+0.610250*v_1_37-0.008131*v_1_38+0.361915*v_1_39+0.150319*v_1_40+0.892324*v_1_41-0.771445*v_1_42+0.514634*v_1_43-0.455508*v_1_44-0.016116*v_1_45-0.819300*v_1_46-0.341983*v_1_47-0.034942);\n\tfloat v_2_27 = sin(-0.144402*v_1_0+0.111095*v_1_1+0.136385*v_1_2+0.336001*v_1_3-0.184870*v_1_4+0.034638*v_1_5-0.101059*v_1_6-0.027697*v_1_7+0.703250*v_1_8+0.246896*v_1_9-0.343426*v_1_10+0.256680*v_1_11+0.289209*v_1_12-0.348907*v_1_13+0.678041*v_1_14+0.709680*v_1_15-0.331780*v_1_16+0.225414*v_1_17-0.139691*v_1_18-0.337358*v_1_19+0.120131*v_1_20-0.213365*v_1_21-0.122891*v_1_22+0.141087*v_1_23-0.303501*v_1_24-0.340760*v_1_25-0.152856*v_1_26+0.347940*v_1_27+0.246247*v_1_28+0.211004*v_1_29-0.237408*v_1_30+0.191602*v_1_31+0.388930*v_1_32+0.148191*v_1_33+0.099678*v_1_34-0.157573*v_1_35+0.289282*v_1_36+0.746439*v_1_37-0.125660*v_1_38+0.321271*v_1_39+0.064278*v_1_40-0.248809*v_1_41+0.674499*v_1_42-0.183960*v_1_43-0.407737*v_1_44+0.240042*v_1_45+0.266400*v_1_46+0.608327*v_1_47-0.623182);\n\tfloat v_2_28 = sin(-0.711018*v_1_0+0.096232*v_1_1-0.035354*v_1_2-0.054901*v_1_3-0.323302*v_1_4-0.577577*v_1_5-0.299249*v_1_6-0.040877*v_1_7+0.449168*v_1_8+0.229947*v_1_9+0.498703*v_1_10+0.097014*v_1_11-0.533256*v_1_12+0.604337*v_1_13-0.772991*v_1_14-0.048242*v_1_15-0.013933*v_1_16+0.203827*v_1_17+0.253214*v_1_18-0.376096*v_1_19-0.156620*v_1_20+0.052997*v_1_21+0.049813*v_1_22+0.496822*v_1_23-0.442988*v_1_24+0.051792*v_1_25-0.296234*v_1_26-0.126263*v_1_27+0.086989*v_1_28+0.292037*v_1_29+0.309831*v_1_30-0.020999*v_1_31-0.376968*v_1_32+0.128325*v_1_33+0.110589*v_1_34-0.451098*v_1_35+0.308573*v_1_36+1.144194*v_1_37+0.147072*v_1_38-0.105621*v_1_39-0.398447*v_1_40-0.121707*v_1_41-0.344550*v_1_42+0.059260*v_1_43+0.407485*v_1_44-0.073341*v_1_45-0.715525*v_1_46-0.106023*v_1_47-0.194321);\n\tfloat v_2_29 = sin(-0.243367*v_1_0+1.033448*v_1_1-0.685879*v_1_2+0.356412*v_1_3-0.585216*v_1_4-0.146256*v_1_5-0.017181*v_1_6-0.115534*v_1_7+0.619376*v_1_8+0.095690*v_1_9+0.211547*v_1_10+0.363354*v_1_11+0.234344*v_1_12-0.344796*v_1_13+0.298242*v_1_14+0.187283*v_1_15+0.040262*v_1_16+0.384297*v_1_17+0.425192*v_1_18-0.224370*v_1_19+0.641980*v_1_20+0.226824*v_1_21-0.146023*v_1_22-0.416441*v_1_23-0.605028*v_1_24-0.481994*v_1_25-0.029909*v_1_26+0.637359*v_1_27-0.488586*v_1_28-0.036350*v_1_29-0.387300*v_1_30-0.318861*v_1_31-0.018250*v_1_32+0.254172*v_1_33+0.082451*v_1_34+1.087813*v_1_35-0.413226*v_1_36-0.240006*v_1_37+0.113487*v_1_38+0.546292*v_1_39+0.245160*v_1_40+0.165276*v_1_41-0.062537*v_1_42-0.461104*v_1_43+0.298382*v_1_44+0.260350*v_1_45-0.517698*v_1_46+0.165674*v_1_47+0.385663);\n\tfloat v_2_30 = sin(0.409166*v_1_0+0.511140*v_1_1+0.123470*v_1_2+0.062425*v_1_3-0.047861*v_1_4-0.756337*v_1_5-0.200242*v_1_6-0.052623*v_1_7+0.611240*v_1_8+0.000057*v_1_9-0.370010*v_1_10-0.224762*v_1_11-0.077310*v_1_12+0.649532*v_1_13+0.039648*v_1_14+0.229773*v_1_15+0.018872*v_1_16+0.157944*v_1_17-0.081548*v_1_18-0.159586*v_1_19-0.403646*v_1_20-0.241805*v_1_21-0.040583*v_1_22-0.092146*v_1_23-1.409113*v_1_24-0.137593*v_1_25-0.048837*v_1_26+0.161259*v_1_27+0.234208*v_1_28-0.453069*v_1_29+0.215137*v_1_30-0.123811*v_1_31-0.816159*v_1_32+0.098581*v_1_33-0.690694*v_1_34-0.125415*v_1_35-0.907504*v_1_36+1.088080*v_1_37-0.770761*v_1_38+0.149478*v_1_39+0.213150*v_1_40+0.560148*v_1_41+0.021494*v_1_42-0.255689*v_1_43-0.349597*v_1_44-0.114478*v_1_45-0.369980*v_1_46+0.099955*v_1_47-0.574284);\n\tfloat v_2_31 = sin(0.414860*v_1_0-0.198183*v_1_1-0.155468*v_1_2-0.365716*v_1_3+0.520077*v_1_4+0.192850*v_1_5-0.904142*v_1_6+0.189568*v_1_7-0.164386*v_1_8-0.112701*v_1_9-0.811083*v_1_10+0.085913*v_1_11+0.154734*v_1_12-0.020787*v_1_13+0.042277*v_1_14-0.138611*v_1_15-0.108552*v_1_16-0.867271*v_1_17-0.354054*v_1_18-0.277918*v_1_19+0.230211*v_1_20-0.069052*v_1_21-0.351682*v_1_22-0.163030*v_1_23+0.216979*v_1_24+0.506103*v_1_25-0.013422*v_1_26-0.057449*v_1_27-0.216637*v_1_28-0.122231*v_1_29+0.104281*v_1_30-0.151243*v_1_31+0.423485*v_1_32+0.206758*v_1_33-0.110177*v_1_34+0.044941*v_1_35+0.206876*v_1_36-0.826773*v_1_37+0.093450*v_1_38-0.285839*v_1_39+0.386410*v_1_40+0.114642*v_1_41+0.499851*v_1_42+0.101400*v_1_43+0.348960*v_1_44-0.091233*v_1_45-0.354534*v_1_46+1.143631*v_1_47+0.446650);\n\tfloat v_3_0 = sin(0.419343*v_2_0-0.180995*v_2_1-0.348860*v_2_2-0.499762*v_2_3+0.165314*v_2_4-0.581679*v_2_5+0.550976*v_2_6-0.369865*v_2_7+0.474755*v_2_8-0.173036*v_2_9-0.122767*v_2_10-0.240638*v_2_11-0.057468*v_2_12+0.088673*v_2_13-0.184934*v_2_14-0.530499*v_2_15+0.029395*v_2_16+0.294490*v_2_17-0.655315*v_2_18+0.108175*v_2_19+0.478198*v_2_20+0.269589*v_2_21+0.106838*v_2_22+0.507234*v_2_23+0.322299*v_2_24-0.105919*v_2_25+0.276028*v_2_26-0.142932*v_2_27+0.710633*v_2_28-0.159841*v_2_29-0.444504*v_2_30-0.102176*v_2_31+0.243438);\n\tfloat v_3_1 = sin(-0.284624*v_2_0+0.122204*v_2_1-0.422339*v_2_2-0.141390*v_2_3-0.045735*v_2_4-0.216401*v_2_5-0.091434*v_2_6-0.137256*v_2_7+0.733314*v_2_8+0.168031*v_2_9-0.792967*v_2_10-0.508382*v_2_11+0.582709*v_2_12-0.544917*v_2_13+0.520553*v_2_14+0.334707*v_2_15-0.206330*v_2_16-0.218564*v_2_17+0.166662*v_2_18+0.523366*v_2_19+0.123468*v_2_20-0.231390*v_2_21-0.584914*v_2_22+0.638686*v_2_23+0.097592*v_2_24+0.699331*v_2_25-0.407041*v_2_26-0.264926*v_2_27-0.054630*v_2_28-0.167902*v_2_29-0.084709*v_2_30-0.438787*v_2_31+0.047286);\n\tfloat v_3_2 = sin(-0.117856*v_2_0-0.411409*v_2_1-0.082031*v_2_2-0.111335*v_2_3+0.220065*v_2_4+0.523577*v_2_5+0.214151*v_2_6-0.284820*v_2_7+0.396782*v_2_8+0.421182*v_2_9-0.182553*v_2_10-0.157752*v_2_11+0.133821*v_2_12-0.742024*v_2_13-0.561280*v_2_14-0.238965*v_2_15-0.517743*v_2_16+0.127921*v_2_17+0.052001*v_2_18-0.092063*v_2_19+0.155208*v_2_20-0.621063*v_2_21-0.141819*v_2_22-0.105139*v_2_23+0.730201*v_2_24+0.307664*v_2_25-0.329316*v_2_26-0.767905*v_2_27+0.573497*v_2_28-0.602804*v_2_29+0.146844*v_2_30+0.575887*v_2_31-0.324195);\n\tfloat v_3_3 = sin(-0.395592*v_2_0+0.323637*v_2_1-0.019219*v_2_2-0.366807*v_2_3+0.214709*v_2_4-0.322014*v_2_5+0.111386*v_2_6-0.512860*v_2_7+1.058261*v_2_8-0.252709*v_2_9-0.032305*v_2_10-0.059746*v_2_11-0.080386*v_2_12-0.661623*v_2_13+0.353003*v_2_14-0.070178*v_2_15-0.073101*v_2_16-1.115642*v_2_17+0.805982*v_2_18-0.765041*v_2_19-1.166326*v_2_20-0.217324*v_2_21-0.136342*v_2_22-0.342845*v_2_23-0.316224*v_2_24+0.142209*v_2_25-0.142545*v_2_26+0.010292*v_2_27-0.299245*v_2_28+0.726128*v_2_29+0.502249*v_2_30+0.340246*v_2_31-0.228216);\n\tfloat v_3_4 = sin(0.004950*v_2_0-0.540136*v_2_1-0.196743*v_2_2+0.352281*v_2_3+0.174591*v_2_4-0.279408*v_2_5+0.707928*v_2_6+0.467299*v_2_7-0.447292*v_2_8-0.200458*v_2_9-0.454746*v_2_10+0.093388*v_2_11-0.227959*v_2_12-0.547105*v_2_13-0.313064*v_2_14-0.197024*v_2_15+0.337188*v_2_16+0.271806*v_2_17-0.002411*v_2_18-0.130877*v_2_19+0.132004*v_2_20-0.361912*v_2_21-0.018936*v_2_22-0.411652*v_2_23-0.088128*v_2_24-0.171949*v_2_25+0.377893*v_2_26-0.194033*v_2_27+0.266305*v_2_28-0.287929*v_2_29-0.248534*v_2_30-0.195159*v_2_31+0.657732);\n\tfloat v_3_5 = sin(-0.450874*v_2_0-0.154820*v_2_1-0.299321*v_2_2-0.226072*v_2_3+0.011347*v_2_4+0.444032*v_2_5+0.381569*v_2_6+0.847599*v_2_7-1.047123*v_2_8-0.490194*v_2_9+0.091847*v_2_10-0.258238*v_2_11-0.381851*v_2_12+0.159466*v_2_13-0.356054*v_2_14+0.183761*v_2_15+0.117626*v_2_16-0.157838*v_2_17-0.123889*v_2_18+0.223790*v_2_19-0.098572*v_2_20+0.147982*v_2_21+0.281463*v_2_22+0.434303*v_2_23+0.008671*v_2_24-0.222881*v_2_25+0.201821*v_2_26+0.140123*v_2_27-0.418945*v_2_28-0.024680*v_2_29+0.104250*v_2_30-0.018077*v_2_31+0.445635);\n\tfloat v_3_6 = sin(0.020599*v_2_0-0.255950*v_2_1-0.207563*v_2_2+0.168768*v_2_3+0.019528*v_2_4-0.233202*v_2_5-0.421950*v_2_6-0.863581*v_2_7-0.280418*v_2_8-0.297092*v_2_9+0.051802*v_2_10-0.630503*v_2_11-0.228119*v_2_12+0.114627*v_2_13-0.365159*v_2_14+0.158513*v_2_15+0.025123*v_2_16+0.289106*v_2_17+0.149643*v_2_18+0.311642*v_2_19+0.402054*v_2_20-0.168600*v_2_21+0.158613*v_2_22+0.262741*v_2_23-0.358739*v_2_24+0.018218*v_2_25-0.144341*v_2_26+0.013236*v_2_27+0.238816*v_2_28-0.064521*v_2_29+0.110528*v_2_30-0.886633*v_2_31-0.532430);\n\tfloat v_3_7 = sin(0.008253*v_2_0+0.731619*v_2_1+0.066767*v_2_2-0.371861*v_2_3+0.259314*v_2_4+0.556775*v_2_5-0.033394*v_2_6-0.694277*v_2_7+0.341844*v_2_8+0.486928*v_2_9-0.926173*v_2_10+0.263433*v_2_11+0.399322*v_2_12+0.150198*v_2_13+0.479281*v_2_14+0.342291*v_2_15-0.326876*v_2_16-0.349476*v_2_17+0.503330*v_2_18+0.447121*v_2_19-0.236050*v_2_20-0.180505*v_2_21-0.065219*v_2_22-0.201771*v_2_23-0.381377*v_2_24+0.015775*v_2_25+0.065299*v_2_26-0.313352*v_2_27+0.401061*v_2_28+0.236905*v_2_29+0.445426*v_2_30+0.039570*v_2_31+0.468252);\n\tfloat v_3_8 = sin(-0.017280*v_2_0+0.005500*v_2_1-0.754492*v_2_2-0.913154*v_2_3-0.184771*v_2_4+0.346212*v_2_5-0.090725*v_2_6+0.875362*v_2_7-0.118320*v_2_8-0.622019*v_2_9+0.289129*v_2_10+0.858533*v_2_11-0.470889*v_2_12-0.429420*v_2_13-0.751058*v_2_14-0.421350*v_2_15+0.163358*v_2_16-0.023441*v_2_17-0.733554*v_2_18+0.579344*v_2_19+0.003823*v_2_20-0.139042*v_2_21-0.409475*v_2_22-0.151988*v_2_23+0.221369*v_2_24-0.200570*v_2_25+0.338875*v_2_26-0.364492*v_2_27-0.024603*v_2_28+0.099281*v_2_29-0.390984*v_2_30+0.199058*v_2_31+0.585388);\n\tfloat v_3_9 = sin(-0.253413*v_2_0+0.440742*v_2_1-0.227451*v_2_2-0.159104*v_2_3+0.028624*v_2_4-0.292648*v_2_5+0.791640*v_2_6+0.124755*v_2_7+0.236467*v_2_8+0.619227*v_2_9-0.252266*v_2_10+0.447911*v_2_11+0.477929*v_2_12+0.302575*v_2_13-0.369925*v_2_14+0.126080*v_2_15+0.193522*v_2_16+0.044504*v_2_17+0.343685*v_2_18-0.380721*v_2_19-0.135336*v_2_20+0.178445*v_2_21+0.308897*v_2_22+0.235088*v_2_23-0.026809*v_2_24+1.216625*v_2_25+0.724433*v_2_26-0.785474*v_2_27-0.339317*v_2_28+0.338365*v_2_29-0.542174*v_2_30+0.001182*v_2_31+0.311049);\n\tfloat v_3_10 = sin(0.767128*v_2_0+0.433564*v_2_1+0.052036*v_2_2+0.041426*v_2_3+0.141328*v_2_4+0.319995*v_2_5+0.006505*v_2_6-0.665160*v_2_7+0.436020*v_2_8-0.704350*v_2_9-0.278276*v_2_10-0.601230*v_2_11+0.209847*v_2_12-0.066848*v_2_13-0.263159*v_2_14-0.144441*v_2_15-0.114737*v_2_16-0.171489*v_2_17-0.004731*v_2_18+0.683405*v_2_19+0.267067*v_2_20+0.338086*v_2_21-0.281379*v_2_22-0.482243*v_2_23+0.672144*v_2_24+0.427815*v_2_25-0.407783*v_2_26-0.064841*v_2_27+0.400627*v_2_28-0.076581*v_2_29+0.942430*v_2_30+0.490500*v_2_31-0.573303);\n\tfloat v_3_11 = sin(-0.730058*v_2_0-0.121022*v_2_1-0.291577*v_2_2-0.051080*v_2_3+0.156400*v_2_4-0.147482*v_2_5-0.237700*v_2_6+0.025328*v_2_7+0.426541*v_2_8+0.454470*v_2_9+0.461810*v_2_10-0.166397*v_2_11-0.431057*v_2_12-0.802793*v_2_13-0.446824*v_2_14+0.485705*v_2_15-0.201034*v_2_16-0.434357*v_2_17-0.610217*v_2_18+0.977376*v_2_19+0.060064*v_2_20-0.812288*v_2_21-0.230022*v_2_22-0.091011*v_2_23+0.257675*v_2_24+0.396474*v_2_25-0.489460*v_2_26-1.051303*v_2_27+0.426814*v_2_28+0.120645*v_2_29-0.081898*v_2_30+0.264349*v_2_31-0.331729);\n\tfloat v_3_12 = sin(0.045065*v_2_0-0.020796*v_2_1-0.122411*v_2_2-0.043813*v_2_3+0.314211*v_2_4-0.579685*v_2_5-0.320322*v_2_6+0.825006*v_2_7+0.411928*v_2_8+0.363976*v_2_9-0.201113*v_2_10+0.001676*v_2_11+0.367642*v_2_12-0.185221*v_2_13-0.115608*v_2_14-0.236459*v_2_15+0.121819*v_2_16+0.573184*v_2_17+0.394424*v_2_18+0.296299*v_2_19+0.398953*v_2_20+0.357116*v_2_21+0.573200*v_2_22+0.644782*v_2_23+0.389347*v_2_24-0.192336*v_2_25-0.590175*v_2_26-0.369760*v_2_27-0.195195*v_2_28+0.442650*v_2_29-0.029619*v_2_30-0.058527*v_2_31+0.472890);\n\tfloat v_3_13 = sin(0.309769*v_2_0-0.108387*v_2_1-0.247405*v_2_2+0.733535*v_2_3-0.098257*v_2_4-0.662393*v_2_5-0.686126*v_2_6-0.374786*v_2_7+0.344526*v_2_8+0.087827*v_2_9-0.654320*v_2_10-0.231422*v_2_11-0.544009*v_2_12+0.177697*v_2_13+0.434159*v_2_14+0.654131*v_2_15-0.220776*v_2_16+0.223519*v_2_17+0.050054*v_2_18+0.231892*v_2_19+0.249928*v_2_20+0.196131*v_2_21-0.924979*v_2_22-0.213621*v_2_23-0.354279*v_2_24-0.316963*v_2_25+0.366139*v_2_26-0.541294*v_2_27-0.679203*v_2_28+1.011294*v_2_29+0.346346*v_2_30+0.242406*v_2_31+0.434947);\n\tfloat v_3_14 = sin(0.485733*v_2_0+0.526913*v_2_1+0.603220*v_2_2-0.349697*v_2_3-0.042449*v_2_4+0.182035*v_2_5-0.118077*v_2_6-0.696199*v_2_7+0.428862*v_2_8-0.557133*v_2_9+0.214431*v_2_10-0.480658*v_2_11+0.071827*v_2_12-0.043954*v_2_13+0.324960*v_2_14+0.067793*v_2_15+0.792028*v_2_16+0.332001*v_2_17-0.114279*v_2_18-0.515261*v_2_19+0.283312*v_2_20+0.206503*v_2_21-0.171548*v_2_22+0.647482*v_2_23-0.183086*v_2_24+0.130745*v_2_25+0.359698*v_2_26+0.068249*v_2_27+0.292754*v_2_28+0.059203*v_2_29-0.345403*v_2_30-0.457954*v_2_31-0.259189);\n\tfloat v_3_15 = sin(0.359545*v_2_0-0.435604*v_2_1-0.397670*v_2_2+0.142738*v_2_3+0.262507*v_2_4-0.266791*v_2_5+0.213777*v_2_6+0.588001*v_2_7-0.027863*v_2_8-0.221356*v_2_9+0.188568*v_2_10-0.582455*v_2_11-0.260862*v_2_12+0.229531*v_2_13-0.761041*v_2_14-0.797490*v_2_15+0.076597*v_2_16+0.385924*v_2_17-0.079165*v_2_18-0.238093*v_2_19+0.065375*v_2_20+0.737687*v_2_21+0.476925*v_2_22-0.126271*v_2_23+0.916433*v_2_24-0.129165*v_2_25+0.172746*v_2_26+0.262414*v_2_27+0.252040*v_2_28+0.450114*v_2_29+0.012148*v_2_30-0.029092*v_2_31-0.194557);\n\tfloat v_3_16 = sin(-1.081073*v_2_0-0.008847*v_2_1-0.210760*v_2_2+0.298422*v_2_3-0.167610*v_2_4-0.291355*v_2_5+0.155649*v_2_6-0.156663*v_2_7-0.144740*v_2_8-0.548725*v_2_9+0.740967*v_2_10+0.011208*v_2_11+0.258178*v_2_12-0.026154*v_2_13-0.101719*v_2_14-0.228342*v_2_15+0.266566*v_2_16-0.393092*v_2_17-0.038808*v_2_18+0.028380*v_2_19-0.075603*v_2_20+0.395569*v_2_21+0.241320*v_2_22-0.094977*v_2_23-0.084711*v_2_24-0.469195*v_2_25-0.026164*v_2_26+0.213760*v_2_27-0.363660*v_2_28+0.194445*v_2_29-0.150736*v_2_30+0.297245*v_2_31+0.181003);\n\tfloat v_3_17 = sin(0.115413*v_2_0-0.189137*v_2_1-0.175010*v_2_2+0.085753*v_2_3+0.588341*v_2_4-0.030309*v_2_5-0.095822*v_2_6+0.535074*v_2_7-0.123544*v_2_8+0.190065*v_2_9-0.011106*v_2_10+0.016162*v_2_11-0.356060*v_2_12+0.156113*v_2_13+0.084980*v_2_14-0.616575*v_2_15-0.444279*v_2_16+0.837467*v_2_17+0.351958*v_2_18-0.353317*v_2_19+0.267236*v_2_20+0.198088*v_2_21-0.273679*v_2_22-0.433636*v_2_23-0.145892*v_2_24-0.044753*v_2_25+0.343776*v_2_26-0.004241*v_2_27-0.427393*v_2_28+0.644556*v_2_29-1.034175*v_2_30+0.816787*v_2_31+0.620701);\n\tfloat v_3_18 = sin(0.353411*v_2_0-0.489099*v_2_1-0.075717*v_2_2+0.196641*v_2_3+0.214886*v_2_4+0.660370*v_2_5-0.798508*v_2_6-0.948326*v_2_7-0.657120*v_2_8+0.102097*v_2_9+0.635018*v_2_10+0.217123*v_2_11-0.416963*v_2_12-0.029125*v_2_13-0.026258*v_2_14+0.093366*v_2_15+0.237232*v_2_16+0.357646*v_2_17-0.366788*v_2_18+0.110694*v_2_19-0.145975*v_2_20+0.086406*v_2_21-0.146264*v_2_22-0.081264*v_2_23-0.674534*v_2_24+0.176181*v_2_25+0.562959*v_2_26-0.408426*v_2_27-0.063762*v_2_28+0.129348*v_2_29-0.213856*v_2_30-0.562355*v_2_31-0.519685);\n\tfloat v_3_19 = sin(0.332107*v_2_0+0.179051*v_2_1+0.174031*v_2_2-0.073370*v_2_3-0.157280*v_2_4+0.186029*v_2_5-0.446353*v_2_6-0.078281*v_2_7+0.328914*v_2_8+0.054893*v_2_9-0.355016*v_2_10-0.397975*v_2_11+0.506994*v_2_12+0.321748*v_2_13+0.225668*v_2_14+0.214165*v_2_15-0.366780*v_2_16+0.048684*v_2_17-0.452238*v_2_18-0.036128*v_2_19+0.080990*v_2_20+0.092326*v_2_21-0.146047*v_2_22+0.370745*v_2_23-0.132701*v_2_24+0.190835*v_2_25-0.247913*v_2_26-0.159316*v_2_27+0.324172*v_2_28-0.192757*v_2_29-0.118149*v_2_30-0.133869*v_2_31-0.077717);\n\tfloat v_3_20 = sin(0.959353*v_2_0+0.012101*v_2_1-0.006413*v_2_2-0.081394*v_2_3+0.657641*v_2_4-0.571903*v_2_5-0.000075*v_2_6+1.256809*v_2_7+0.161313*v_2_8+0.335496*v_2_9-0.461744*v_2_10-0.198302*v_2_11+0.078227*v_2_12-0.524459*v_2_13-0.180726*v_2_14+0.043400*v_2_15-0.907210*v_2_16+0.149120*v_2_17+0.582920*v_2_18+0.382157*v_2_19+0.102969*v_2_20+0.111453*v_2_21+0.545552*v_2_22-0.099340*v_2_23+1.002356*v_2_24+0.295599*v_2_25-0.019641*v_2_26-0.395541*v_2_27+0.167210*v_2_28+0.669861*v_2_29+0.693004*v_2_30+0.475783*v_2_31+0.091554);\n\tfloat v_3_21 = sin(0.344685*v_2_0+0.055276*v_2_1+0.346127*v_2_2-0.341521*v_2_3+0.055072*v_2_4+0.326164*v_2_5+0.162627*v_2_6-0.770449*v_2_7+0.643234*v_2_8+0.017378*v_2_9-0.380880*v_2_10-0.458067*v_2_11-0.211399*v_2_12-0.130619*v_2_13+0.283551*v_2_14-0.146782*v_2_15-0.200334*v_2_16+0.110239*v_2_17+0.318451*v_2_18+0.161081*v_2_19+0.319882*v_2_20+0.471908*v_2_21-0.378874*v_2_22+0.351466*v_2_23-0.466186*v_2_24-0.068455*v_2_25-0.296654*v_2_26+0.393144*v_2_27+0.603238*v_2_28+0.266878*v_2_29+0.424633*v_2_30-0.234124*v_2_31-0.844988);\n\tfloat v_3_22 = sin(0.491009*v_2_0+0.326662*v_2_1-0.032446*v_2_2+0.194322*v_2_3+0.367914*v_2_4-0.018149*v_2_5-0.010972*v_2_6+0.950345*v_2_7-0.335783*v_2_8-0.246394*v_2_9+0.047342*v_2_10+0.104142*v_2_11+0.325227*v_2_12-0.266331*v_2_13+0.229278*v_2_14-0.427173*v_2_15-0.022016*v_2_16+0.451048*v_2_17-0.021538*v_2_18-0.462361*v_2_19+0.103743*v_2_20+0.135996*v_2_21-0.625942*v_2_22+0.160017*v_2_23-0.475692*v_2_24-0.588250*v_2_25+0.026736*v_2_26+0.471211*v_2_27-0.260672*v_2_28+0.284947*v_2_29+0.149391*v_2_30+0.681991*v_2_31-0.083768);\n\tfloat v_3_23 = sin(-0.016097*v_2_0+0.153236*v_2_1-0.041591*v_2_2-0.056026*v_2_3-0.079883*v_2_4+0.541057*v_2_5+0.379674*v_2_6+0.159008*v_2_7-0.621189*v_2_8+0.415271*v_2_9+0.054196*v_2_10-0.340073*v_2_11-0.426246*v_2_12+0.049746*v_2_13-0.064359*v_2_14-0.086460*v_2_15-0.400663*v_2_16-0.436214*v_2_17-0.625837*v_2_18-0.498444*v_2_19+0.435685*v_2_20-0.363980*v_2_21+0.405971*v_2_22-0.161583*v_2_23-0.129228*v_2_24+0.174188*v_2_25+0.246531*v_2_26-0.050831*v_2_27-0.071423*v_2_28-0.096554*v_2_29-0.163815*v_2_30+0.779553*v_2_31+0.401157);\n\tfloat v_3_24 = sin(-0.293514*v_2_0-0.071204*v_2_1+0.029916*v_2_2+0.046141*v_2_3-0.034564*v_2_4-0.611550*v_2_5+0.034492*v_2_6+0.038967*v_2_7+0.184676*v_2_8+0.113116*v_2_9+0.464309*v_2_10-0.322090*v_2_11-0.632420*v_2_12-0.346284*v_2_13+0.020796*v_2_14-0.345139*v_2_15+0.135106*v_2_16+0.026149*v_2_17-0.604673*v_2_18-0.316005*v_2_19-0.288835*v_2_20-0.082304*v_2_21-0.110014*v_2_22-0.128268*v_2_23+0.342484*v_2_24+0.218775*v_2_25-0.581967*v_2_26+0.411731*v_2_27+0.224042*v_2_28-0.182070*v_2_29-0.528590*v_2_30+0.571348*v_2_31+0.443694);\n\tfloat v_3_25 = sin(0.189458*v_2_0+0.715274*v_2_1+1.203278*v_2_2-0.493068*v_2_3-0.277635*v_2_4-0.049482*v_2_5+0.186091*v_2_6+0.329293*v_2_7-0.240028*v_2_8+0.340134*v_2_9-0.732178*v_2_10+0.562000*v_2_11+0.667762*v_2_12+0.655981*v_2_13+0.527413*v_2_14+0.278350*v_2_15-0.259432*v_2_16-1.488787*v_2_17-0.252514*v_2_18-0.214842*v_2_19+0.411441*v_2_20-0.563427*v_2_21+0.444388*v_2_22-0.261793*v_2_23+0.400852*v_2_24+0.039202*v_2_25-0.204906*v_2_26+0.712622*v_2_27+0.202029*v_2_28+0.434688*v_2_29+0.570608*v_2_30+0.112112*v_2_31-0.639982);\n\tfloat v_3_26 = sin(0.008812*v_2_0+0.029619*v_2_1-0.622071*v_2_2-0.406010*v_2_3-0.012552*v_2_4-0.028311*v_2_5+0.392390*v_2_6+0.342387*v_2_7-0.242289*v_2_8+0.160915*v_2_9-0.053841*v_2_10+0.049378*v_2_11+0.279768*v_2_12-0.065506*v_2_13-0.518243*v_2_14-0.316819*v_2_15+0.302592*v_2_16-0.282615*v_2_17-0.151630*v_2_18-0.316109*v_2_19-0.035885*v_2_20+0.086050*v_2_21+0.141030*v_2_22-0.038889*v_2_23+0.728289*v_2_24-0.275307*v_2_25+0.174463*v_2_26+0.153918*v_2_27+0.364272*v_2_28+0.252798*v_2_29+0.115096*v_2_30+0.106738*v_2_31+0.127241);\n\tfloat v_3_27 = sin(0.076088*v_2_0+0.294681*v_2_1+0.328046*v_2_2+0.195533*v_2_3+0.256984*v_2_4-0.189316*v_2_5+0.171346*v_2_6-0.103438*v_2_7+0.179138*v_2_8+0.243704*v_2_9+0.092888*v_2_10-0.051311*v_2_11-0.468287*v_2_12-0.220529*v_2_13+0.284789*v_2_14+0.246905*v_2_15-0.125867*v_2_16-0.064687*v_2_17+0.484673*v_2_18-0.599960*v_2_19+0.088950*v_2_20-0.294324*v_2_21+0.544087*v_2_22-0.074213*v_2_23-0.314365*v_2_24+0.187174*v_2_25+0.212219*v_2_26-0.082628*v_2_27-0.052740*v_2_28+0.328641*v_2_29+0.292163*v_2_30-0.355812*v_2_31-0.353487);\n\tfloat v_3_28 = sin(-0.489775*v_2_0-0.398814*v_2_1-0.119874*v_2_2-0.090835*v_2_3-0.505519*v_2_4+0.376232*v_2_5-0.047998*v_2_6+0.367208*v_2_7+0.304198*v_2_8-0.057283*v_2_9-0.322326*v_2_10-0.928035*v_2_11-0.155113*v_2_12-0.167566*v_2_13-0.857800*v_2_14-0.313413*v_2_15-0.030761*v_2_16-0.687045*v_2_17+0.055104*v_2_18-0.643601*v_2_19+0.481330*v_2_20-0.197407*v_2_21-0.071916*v_2_22+0.326651*v_2_23+0.075814*v_2_24-0.528350*v_2_25+0.444045*v_2_26-0.443900*v_2_27-0.790172*v_2_28-0.413364*v_2_29+0.243782*v_2_30-0.495727*v_2_31+0.847387);\n\tfloat v_3_29 = sin(-0.284037*v_2_0-0.023716*v_2_1-0.073744*v_2_2+0.180590*v_2_3+0.174055*v_2_4-0.120701*v_2_5-0.178039*v_2_6+0.222386*v_2_7+0.283655*v_2_8+0.383545*v_2_9+0.263992*v_2_10+0.664803*v_2_11+0.269605*v_2_12-0.249750*v_2_13-0.609173*v_2_14+0.341684*v_2_15+0.121396*v_2_16+0.245409*v_2_17-0.376882*v_2_18-0.199446*v_2_19-0.174183*v_2_20-0.984504*v_2_21+0.524973*v_2_22-0.012277*v_2_23+0.104796*v_2_24+0.101973*v_2_25+0.134980*v_2_26-0.664452*v_2_27-0.185056*v_2_28-0.144188*v_2_29-0.469455*v_2_30+0.189815*v_2_31-0.177494);\n\tfloat v_3_30 = sin(-0.330014*v_2_0-0.076416*v_2_1-0.129070*v_2_2-0.073350*v_2_3-0.418322*v_2_4-0.177679*v_2_5-0.543658*v_2_6-0.203862*v_2_7+0.734689*v_2_8+0.265883*v_2_9-0.001993*v_2_10-0.229017*v_2_11+0.200967*v_2_12-0.257070*v_2_13-0.393270*v_2_14+0.099930*v_2_15-0.007156*v_2_16+0.998782*v_2_17+0.254218*v_2_18+0.104614*v_2_19+0.038283*v_2_20-0.078632*v_2_21-0.514710*v_2_22+0.731456*v_2_23-0.335306*v_2_24+0.123916*v_2_25-0.002212*v_2_26-0.202271*v_2_27+0.395220*v_2_28-0.246860*v_2_29+0.490098*v_2_30-0.244505*v_2_31-0.171263);\n\tfloat v_3_31 = sin(0.433097*v_2_0-0.293113*v_2_1-0.859577*v_2_2-0.529148*v_2_3-0.369412*v_2_4+0.596329*v_2_5-1.065272*v_2_6-0.304605*v_2_7-0.263359*v_2_8+0.647525*v_2_9-0.098290*v_2_10+0.550445*v_2_11+0.198533*v_2_12-0.246900*v_2_13-0.595325*v_2_14+0.363841*v_2_15-0.044602*v_2_16-0.442697*v_2_17-0.464413*v_2_18+0.256305*v_2_19+0.111913*v_2_20+0.150100*v_2_21+0.445190*v_2_22+0.425881*v_2_23+0.424995*v_2_24-0.546803*v_2_25+0.245830*v_2_26-0.977408*v_2_27+0.384089*v_2_28-0.025427*v_2_29+0.104480*v_2_30-0.388798*v_2_31-0.079658);\n\tfloat v_4_0 = sin(-0.571559*v_3_0+0.438705*v_3_1+0.201319*v_3_2+0.182028*v_3_3-0.326090*v_3_4-0.289834*v_3_5-0.689473*v_3_6-0.023884*v_3_7-0.304672*v_3_8+0.064191*v_3_9-0.059193*v_3_10-0.215294*v_3_11-0.425356*v_3_12-0.277658*v_3_13+0.107983*v_3_14-0.340506*v_3_15-0.473571*v_3_16-0.675798*v_3_17+0.169263*v_3_18+0.202183*v_3_19+0.252566*v_3_20-0.011543*v_3_21-0.180984*v_3_22+0.596653*v_3_23+0.433529*v_3_24+0.365671*v_3_25-0.067586*v_3_26-0.444359*v_3_27-0.428177*v_3_28-0.385350*v_3_29+0.527211*v_3_30-0.142961*v_3_31-0.920099);\n\tfloat v_4_1 = sin(0.504748*v_3_0+0.600211*v_3_1-0.107590*v_3_2+0.598666*v_3_3-0.580578*v_3_4-0.604105*v_3_5+1.151244*v_3_6-0.171267*v_3_7-0.153127*v_3_8+0.237632*v_3_9+0.285394*v_3_10+0.512471*v_3_11+0.372023*v_3_12+0.502538*v_3_13-0.400125*v_3_14-0.418891*v_3_15-0.931063*v_3_16+0.574050*v_3_17+0.623133*v_3_18+0.530161*v_3_19-0.679785*v_3_20-0.419067*v_3_21-0.355224*v_3_22+0.211547*v_3_23+0.137363*v_3_24+0.496762*v_3_25+0.657111*v_3_26+0.332835*v_3_27+1.018951*v_3_28-0.617343*v_3_29+0.034239*v_3_30-0.283576*v_3_31-0.757003);\n\tfloat v_4_2 = sin(0.209210*v_3_0+0.449388*v_3_1-0.121556*v_3_2-0.587074*v_3_3+0.104780*v_3_4+0.279055*v_3_5+0.255239*v_3_6-0.451114*v_3_7-0.478503*v_3_8-0.180637*v_3_9-0.358958*v_3_10+0.147932*v_3_11-0.550317*v_3_12+0.189672*v_3_13-0.280666*v_3_14-0.291301*v_3_15+0.193975*v_3_16-0.487790*v_3_17-0.188258*v_3_18+0.010668*v_3_19-0.330111*v_3_20+0.373443*v_3_21-0.127072*v_3_22+0.475300*v_3_23+0.379519*v_3_24-0.127539*v_3_25+0.146511*v_3_26-0.394626*v_3_27-0.039623*v_3_28-0.082480*v_3_29+0.356680*v_3_30+0.152106*v_3_31-0.288698);\n\tfloat v_4_3 = sin(0.212159*v_3_0+0.920140*v_3_1-0.106153*v_3_2+0.161865*v_3_3+0.124029*v_3_4-0.378030*v_3_5-0.067245*v_3_6+0.772615*v_3_7+0.222764*v_3_8+0.107594*v_3_9-0.020384*v_3_10+0.058801*v_3_11+0.222531*v_3_12-0.068318*v_3_13-0.394535*v_3_14-0.243419*v_3_15-0.498067*v_3_16+0.159490*v_3_17+0.292033*v_3_18+0.166433*v_3_19-0.281807*v_3_20-0.055960*v_3_21-0.313426*v_3_22-0.392064*v_3_23-0.121620*v_3_24+0.068165*v_3_25+0.038994*v_3_26-0.792122*v_3_27+0.210265*v_3_28+0.080172*v_3_29+0.613385*v_3_30+0.495597*v_3_31+0.690557);\n\tfloat v_4_4 = sin(0.148461*v_3_0-0.053021*v_3_1-0.171784*v_3_2-0.296679*v_3_3+0.510220*v_3_4+0.261201*v_3_5+0.223564*v_3_6+0.151484*v_3_7-0.249597*v_3_8-0.125892*v_3_9-0.406923*v_3_10-0.570722*v_3_11-0.354528*v_3_12+0.063088*v_3_13-0.185473*v_3_14-0.100045*v_3_15-0.255652*v_3_16+0.074934*v_3_17-0.205202*v_3_18-0.494289*v_3_19+0.227579*v_3_20+0.340112*v_3_21+0.498984*v_3_22-0.256114*v_3_23+0.383282*v_3_24+0.071325*v_3_25+0.302448*v_3_26+0.125058*v_3_27+0.054919*v_3_28+0.005857*v_3_29-0.064915*v_3_30+0.458026*v_3_31+0.218469);\n\tfloat v_4_5 = sin(-0.192201*v_3_0-0.162720*v_3_1-0.298839*v_3_2-0.240853*v_3_3-0.615982*v_3_4+0.252664*v_3_5+0.717264*v_3_6-0.622722*v_3_7+0.192816*v_3_8+0.182861*v_3_9+0.263106*v_3_10+0.722620*v_3_11-0.297324*v_3_12+0.814273*v_3_13-0.446477*v_3_14-0.371527*v_3_15-0.503547*v_3_16-0.366889*v_3_17+0.575426*v_3_18+0.089696*v_3_19-0.241695*v_3_20-0.258914*v_3_21-0.169852*v_3_22+0.450792*v_3_23-0.590060*v_3_24-0.482152*v_3_25-0.181071*v_3_26+0.124941*v_3_27+0.356991*v_3_28-0.123360*v_3_29+0.099160*v_3_30+0.499566*v_3_31-0.464222);\n\tfloat v_4_6 = sin(0.309157*v_3_0+0.139336*v_3_1-0.314888*v_3_2-0.482597*v_3_3+0.365415*v_3_4+0.385920*v_3_5+0.422050*v_3_6-0.146188*v_3_7-0.195839*v_3_8+0.773806*v_3_9-0.434886*v_3_10+0.242350*v_3_11+0.176203*v_3_12-0.507147*v_3_13-0.112639*v_3_14+0.263051*v_3_15-0.048526*v_3_16+0.373561*v_3_17-0.065187*v_3_18+0.273526*v_3_19-0.043822*v_3_20+0.008951*v_3_21+0.498202*v_3_22-0.717591*v_3_23-0.153244*v_3_24+0.141669*v_3_25-0.110608*v_3_26-0.248324*v_3_27+0.584430*v_3_28-0.005545*v_3_29-0.114135*v_3_30-0.386154*v_3_31+1.043961);\n\tfloat v_4_7 = sin(-0.147622*v_3_0-0.045143*v_3_1-0.224859*v_3_2+0.081554*v_3_3-0.083712*v_3_4+0.039065*v_3_5-0.095214*v_3_6+0.229177*v_3_7-0.122612*v_3_8-0.476197*v_3_9+0.018940*v_3_10-0.422144*v_3_11-0.180901*v_3_12-0.232807*v_3_13+0.395347*v_3_14+0.246314*v_3_15+0.126383*v_3_16-0.040592*v_3_17-0.057904*v_3_18-0.106125*v_3_19-0.144584*v_3_20+0.093944*v_3_21-0.007298*v_3_22+0.425719*v_3_23+0.473104*v_3_24-0.091039*v_3_25+0.262894*v_3_26-0.288551*v_3_27-0.135959*v_3_28+0.133988*v_3_29-0.470873*v_3_30+0.198942*v_3_31+0.111274);\n\tfloat v_4_8 = sin(-0.035907*v_3_0-0.022631*v_3_1+0.320658*v_3_2+0.078848*v_3_3-0.047437*v_3_4+0.465427*v_3_5+0.218618*v_3_6-0.122955*v_3_7+0.269572*v_3_8+0.273800*v_3_9-0.113631*v_3_10-0.366341*v_3_11-0.283310*v_3_12-0.649311*v_3_13-0.153890*v_3_14+0.035289*v_3_15+0.311799*v_3_16+0.154693*v_3_17+0.161857*v_3_18-1.066773*v_3_19-0.047771*v_3_20-0.279985*v_3_21-0.079120*v_3_22+0.461113*v_3_23-0.325444*v_3_24+0.126811*v_3_25+0.905368*v_3_26-0.164007*v_3_27+0.127585*v_3_28-0.854088*v_3_29-0.005991*v_3_30-0.387432*v_3_31+0.418954);\n\tfloat v_4_9 = sin(0.025052*v_3_0+0.020046*v_3_1-0.118952*v_3_2-0.057197*v_3_3-0.144287*v_3_4+0.043362*v_3_5-0.312380*v_3_6+0.576088*v_3_7+0.155534*v_3_8+0.270481*v_3_9+0.482518*v_3_10+0.344074*v_3_11+0.214129*v_3_12-0.035947*v_3_13+0.407248*v_3_14-0.299223*v_3_15-0.279018*v_3_16+0.151557*v_3_17-0.126810*v_3_18+1.200036*v_3_19+0.154704*v_3_20+0.205483*v_3_21-0.123290*v_3_22+0.013166*v_3_23-0.105587*v_3_24+0.205316*v_3_25+0.640263*v_3_26+0.516810*v_3_27-0.341987*v_3_28-0.280724*v_3_29+0.369534*v_3_30+0.110382*v_3_31-0.092301);\n\tfloat v_4_10 = sin(0.100023*v_3_0-0.207599*v_3_1+0.224011*v_3_2+0.325382*v_3_3+0.407927*v_3_4+0.199761*v_3_5-0.417823*v_3_6-0.113724*v_3_7-0.313526*v_3_8+0.098825*v_3_9-0.341005*v_3_10-0.140144*v_3_11+0.258624*v_3_12-0.031038*v_3_13+0.209418*v_3_14-0.153442*v_3_15+0.164237*v_3_16+0.123341*v_3_17+0.111275*v_3_18-0.847223*v_3_19-0.101539*v_3_20-0.579190*v_3_21-0.064835*v_3_22+0.564083*v_3_23-0.462698*v_3_24+0.039677*v_3_25+0.479771*v_3_26+0.131403*v_3_27-0.220762*v_3_28-0.163964*v_3_29+0.007474*v_3_30-0.049667*v_3_31+0.007561);\n\tfloat v_4_11 = sin(-0.359387*v_3_0-0.004362*v_3_1-0.354085*v_3_2+0.005643*v_3_3-0.333431*v_3_4+0.450914*v_3_5-0.377434*v_3_6-0.157894*v_3_7+0.174011*v_3_8+0.312377*v_3_9-0.347326*v_3_10+0.101516*v_3_11+0.459110*v_3_12+0.205816*v_3_13-0.653735*v_3_14-0.210405*v_3_15+0.353158*v_3_16+0.371624*v_3_17-0.058637*v_3_18+0.275034*v_3_19+0.134476*v_3_20-0.318975*v_3_21+0.005510*v_3_22+0.351913*v_3_23-0.145062*v_3_24-0.089319*v_3_25-0.156092*v_3_26-0.146287*v_3_27+0.165169*v_3_28+0.300594*v_3_29+0.448372*v_3_30+0.045698*v_3_31+0.599127);\n\tfloat v_4_12 = sin(0.560890*v_3_0+0.075929*v_3_1-0.284791*v_3_2+0.030839*v_3_3-0.080624*v_3_4-0.592824*v_3_5-0.005560*v_3_6-0.377925*v_3_7+0.564202*v_3_8+0.027557*v_3_9-0.325202*v_3_10+0.227100*v_3_11-0.283476*v_3_12-0.319328*v_3_13-0.134453*v_3_14+0.129015*v_3_15-0.428441*v_3_16-0.476458*v_3_17+0.042555*v_3_18-0.547843*v_3_19-0.021984*v_3_20-0.693560*v_3_21-0.438945*v_3_22+1.002811*v_3_23-0.591893*v_3_24+0.258194*v_3_25+0.627184*v_3_26-0.089790*v_3_27-0.155225*v_3_28-0.481961*v_3_29+0.338686*v_3_30-0.178528*v_3_31-0.143822);\n\tfloat v_4_13 = sin(-0.293634*v_3_0-0.108487*v_3_1+0.054760*v_3_2-0.070331*v_3_3+0.116593*v_3_4-0.215483*v_3_5-0.568310*v_3_6-0.035095*v_3_7+0.002681*v_3_8+0.008811*v_3_9-0.025891*v_3_10+0.246342*v_3_11+0.237997*v_3_12-0.307893*v_3_13+0.040921*v_3_14-0.373119*v_3_15+0.426803*v_3_16-0.324373*v_3_17-0.246117*v_3_18-0.299904*v_3_19+0.379273*v_3_20+0.197878*v_3_21-0.092858*v_3_22+0.541551*v_3_23-0.078169*v_3_24+0.012087*v_3_25-0.414955*v_3_26+0.068126*v_3_27-0.022755*v_3_28+0.426296*v_3_29+0.144307*v_3_30+0.037047*v_3_31+0.128824);\n\tfloat v_4_14 = sin(0.443908*v_3_0-0.187016*v_3_1-0.094228*v_3_2+0.208479*v_3_3+0.319578*v_3_4+0.002576*v_3_5-0.462441*v_3_6+0.602768*v_3_7-0.144256*v_3_8-0.073779*v_3_9-0.435826*v_3_10-0.277268*v_3_11+0.428604*v_3_12-0.442688*v_3_13-0.310432*v_3_14-0.624205*v_3_15-0.359954*v_3_16+0.096184*v_3_17+0.324806*v_3_18-0.308828*v_3_19-0.589673*v_3_20+0.782076*v_3_21-0.000670*v_3_22-0.336700*v_3_23+0.001329*v_3_24-0.387991*v_3_25+0.672694*v_3_26+0.223986*v_3_27+0.582568*v_3_28+0.904341*v_3_29+0.080328*v_3_30+0.046495*v_3_31+0.710578);\n\tfloat v_4_15 = sin(0.775349*v_3_0+0.352723*v_3_1-0.267100*v_3_2-0.452086*v_3_3-0.626324*v_3_4+0.463027*v_3_5+0.609164*v_3_6+0.727686*v_3_7+0.435902*v_3_8+0.004419*v_3_9-0.074347*v_3_10+0.410679*v_3_11-0.756364*v_3_12-0.110440*v_3_13-0.102495*v_3_14+0.306805*v_3_15+0.210614*v_3_16+0.375536*v_3_17+0.200279*v_3_18-0.024681*v_3_19-0.016930*v_3_20+0.182688*v_3_21-0.805691*v_3_22+0.288708*v_3_23-0.087068*v_3_24-0.164841*v_3_25-1.327335*v_3_26+0.127764*v_3_27+0.184330*v_3_28-0.308814*v_3_29+0.010807*v_3_30-0.692230*v_3_31-0.772767);\n\tfloat v_4_16 = sin(-0.352713*v_3_0+0.387909*v_3_1+0.504083*v_3_2+0.041123*v_3_3+0.438998*v_3_4+0.848681*v_3_5-0.451698*v_3_6+0.259511*v_3_7-0.483189*v_3_8+0.611967*v_3_9-0.341352*v_3_10-0.576080*v_3_11+0.217961*v_3_12+0.225514*v_3_13+0.310329*v_3_14+0.453927*v_3_15+0.685696*v_3_16+0.027456*v_3_17-0.258119*v_3_18-0.702323*v_3_19+0.088730*v_3_20-0.121434*v_3_21+0.320523*v_3_22-0.370833*v_3_23+0.628063*v_3_24-0.439456*v_3_25-0.732444*v_3_26-0.130912*v_3_27+0.184162*v_3_28+1.092367*v_3_29+0.407462*v_3_30-0.276049*v_3_31+0.594396);\n\tfloat v_4_17 = sin(0.301151*v_3_0+0.324008*v_3_1+0.157596*v_3_2-0.642753*v_3_3-0.080591*v_3_4+0.902693*v_3_5-0.386508*v_3_6-0.101455*v_3_7+0.042863*v_3_8-0.026121*v_3_9-0.112485*v_3_10+0.643474*v_3_11+0.311381*v_3_12-0.137681*v_3_13-0.395680*v_3_14-0.039078*v_3_15+0.200625*v_3_16-0.079026*v_3_17-0.303301*v_3_18+0.553255*v_3_19-0.146351*v_3_20+0.519484*v_3_21+0.371622*v_3_22+0.036179*v_3_23-0.478186*v_3_24+0.435510*v_3_25-0.349775*v_3_26-0.845436*v_3_27-0.054527*v_3_28-0.639064*v_3_29+0.661410*v_3_30-0.076823*v_3_31+0.136226);\n\tfloat v_4_18 = sin(-0.852354*v_3_0-0.412441*v_3_1+0.404658*v_3_2-0.106473*v_3_3+0.828316*v_3_4-0.531861*v_3_5-0.013306*v_3_6-0.529181*v_3_7-0.366080*v_3_8-0.990129*v_3_9+0.572143*v_3_10-0.791271*v_3_11-1.231474*v_3_12-0.330439*v_3_13+1.068714*v_3_14+0.443148*v_3_15-0.034137*v_3_16+0.104787*v_3_17+0.258372*v_3_18+0.190831*v_3_19-0.018284*v_3_20-0.428549*v_3_21-0.164926*v_3_22-0.356911*v_3_23+1.108481*v_3_24-0.547443*v_3_25+0.036236*v_3_26+0.181041*v_3_27+0.139128*v_3_28-0.095384*v_3_29-0.125639*v_3_30+0.290048*v_3_31-0.213286);\n\tfloat v_4_19 = sin(0.271632*v_3_0-0.063822*v_3_1+0.530696*v_3_2-0.616548*v_3_3+0.139064*v_3_4-0.280258*v_3_5+0.595592*v_3_6-0.331834*v_3_7-0.020354*v_3_8-0.508807*v_3_9-0.046492*v_3_10+0.214053*v_3_11+0.730174*v_3_12-0.462571*v_3_13-0.635753*v_3_14-0.348360*v_3_15+0.454239*v_3_16-0.397661*v_3_17-0.816497*v_3_18-0.008603*v_3_19+0.450900*v_3_20-0.019060*v_3_21-0.702483*v_3_22-0.402472*v_3_23+0.360832*v_3_24-0.411889*v_3_25+0.770772*v_3_26+0.001035*v_3_27-0.221365*v_3_28+0.715157*v_3_29-0.212585*v_3_30-0.050727*v_3_31-1.555241);\n\tfloat v_4_20 = sin(0.003071*v_3_0+0.267394*v_3_1+0.771288*v_3_2+0.022946*v_3_3+0.060090*v_3_4-0.000086*v_3_5+0.344559*v_3_6-0.259225*v_3_7-0.384924*v_3_8+0.147319*v_3_9+0.181250*v_3_10-0.030808*v_3_11+0.248828*v_3_12-0.056787*v_3_13+0.104683*v_3_14+0.000080*v_3_15-0.468884*v_3_16+0.066750*v_3_17+0.358944*v_3_18-0.079281*v_3_19-0.270633*v_3_20+0.266167*v_3_21-0.241617*v_3_22-0.353313*v_3_23+0.059945*v_3_24+0.513527*v_3_25-0.431180*v_3_26+0.505815*v_3_27-0.104030*v_3_28+0.075062*v_3_29+0.005112*v_3_30-0.509342*v_3_31-0.481930);\n\tfloat v_4_21 = sin(-0.216535*v_3_0-0.273451*v_3_1+0.280766*v_3_2+0.164264*v_3_3-0.011042*v_3_4-0.277657*v_3_5-0.361387*v_3_6-0.001802*v_3_7-0.084543*v_3_8-0.207899*v_3_9-0.071821*v_3_10+0.649000*v_3_11+0.378407*v_3_12-0.261831*v_3_13+0.391114*v_3_14-0.577726*v_3_15-0.233140*v_3_16-0.076271*v_3_17-0.155296*v_3_18+0.314925*v_3_19+0.292984*v_3_20+0.440882*v_3_21-0.148816*v_3_22+0.172176*v_3_23+0.189721*v_3_24-0.225051*v_3_25+1.092200*v_3_26-0.998896*v_3_27-0.150850*v_3_28+0.435754*v_3_29+0.401281*v_3_30+0.063959*v_3_31-0.737140);\n\tfloat v_4_22 = sin(-0.372299*v_3_0+0.097449*v_3_1-0.113378*v_3_2-0.308545*v_3_3-0.386453*v_3_4-0.017519*v_3_5-0.292922*v_3_6-0.224718*v_3_7+0.089356*v_3_8-0.399307*v_3_9+0.028265*v_3_10-0.213229*v_3_11+0.281252*v_3_12+0.071371*v_3_13-0.325254*v_3_14-0.124281*v_3_15+0.138921*v_3_16+0.301592*v_3_17-0.230671*v_3_18-0.832860*v_3_19-0.111055*v_3_20+0.002461*v_3_21+0.133179*v_3_22+0.100718*v_3_23+0.396903*v_3_24-0.101362*v_3_25-0.266263*v_3_26+0.437671*v_3_27-0.032698*v_3_28+0.299342*v_3_29-0.172018*v_3_30-0.167813*v_3_31+0.369952);\n\tfloat v_4_23 = sin(0.230180*v_3_0-0.340178*v_3_1-0.308790*v_3_2-0.036140*v_3_3+0.817300*v_3_4-0.685719*v_3_5-0.561541*v_3_6+0.125072*v_3_7+0.549687*v_3_8+0.244505*v_3_9-0.617030*v_3_10-0.079645*v_3_11+0.033465*v_3_12-0.286174*v_3_13+0.083305*v_3_14+0.220316*v_3_15+0.625870*v_3_16+0.325054*v_3_17-0.732909*v_3_18-0.015962*v_3_19+0.080845*v_3_20-0.648980*v_3_21+0.961395*v_3_22-0.119591*v_3_23-0.410073*v_3_24-0.064623*v_3_25-0.252714*v_3_26+0.146440*v_3_27-0.020246*v_3_28-0.132280*v_3_29+0.146662*v_3_30-0.079297*v_3_31+0.637144);\n\tfloat v_5_0 = sin(0.549875*v_4_0-0.140348*v_4_1-0.196942*v_4_2+0.429229*v_4_3-0.337985*v_4_4-0.099592*v_4_5+0.194323*v_4_6-0.690726*v_4_7-0.292019*v_4_8+0.873068*v_4_9-0.026534*v_4_10+0.487437*v_4_11-0.283585*v_4_12+0.153546*v_4_13-0.019734*v_4_14-0.151849*v_4_15+0.181243*v_4_16+0.048763*v_4_17-0.146648*v_4_18-0.136170*v_4_19-0.230742*v_4_20+0.113008*v_4_21-0.116004*v_4_22+0.059970*v_4_23+0.032420);\n\tfloat v_5_1 = sin(0.566636*v_4_0-0.539992*v_4_1+0.171416*v_4_2+0.162311*v_4_3-1.089966*v_4_4+0.224320*v_4_5-0.273488*v_4_6+0.180602*v_4_7-0.120958*v_4_8-0.278350*v_4_9-0.417433*v_4_10+0.268729*v_4_11+0.188335*v_4_12-0.205185*v_4_13+0.086405*v_4_14-0.354127*v_4_15-0.328805*v_4_16-0.171805*v_4_17-0.078426*v_4_18-0.393350*v_4_19+0.531168*v_4_20+0.170612*v_4_21+0.212440*v_4_22-0.300232*v_4_23+0.073984);\n\tfloat v_5_2 = sin(-0.193289*v_4_0-0.368781*v_4_1-0.343266*v_4_2+0.172442*v_4_3-0.807722*v_4_4-0.263345*v_4_5+0.390984*v_4_6+0.352392*v_4_7-0.681360*v_4_8+0.090634*v_4_9+0.608460*v_4_10+0.209887*v_4_11-0.967029*v_4_12+0.156044*v_4_13-0.277708*v_4_14+0.049351*v_4_15+0.127598*v_4_16-0.194637*v_4_17-0.390528*v_4_18+0.100272*v_4_19+0.179240*v_4_20-0.205631*v_4_21+0.140386*v_4_22+0.525021*v_4_23+0.814595);\n\tfloat v_5_3 = sin(0.556753*v_4_0+0.086924*v_4_1-0.418854*v_4_2+0.026509*v_4_3+0.327401*v_4_4+0.074943*v_4_5-0.535276*v_4_6-0.174954*v_4_7+0.232611*v_4_8+0.193135*v_4_9-0.031852*v_4_10-0.549535*v_4_11+0.045022*v_4_12-0.243306*v_4_13+0.163552*v_4_14+0.117086*v_4_15-0.399583*v_4_16+0.522662*v_4_17+0.266244*v_4_18+0.032837*v_4_19+0.445903*v_4_20+0.197549*v_4_21+0.289618*v_4_22-0.026379*v_4_23-0.497240);\n\tfloat v_5_4 = sin(-0.285926*v_4_0+0.182659*v_4_1-0.560705*v_4_2-0.023633*v_4_3+0.042300*v_4_4-0.361925*v_4_5-0.038607*v_4_6+0.174578*v_4_7+0.484496*v_4_8+0.551196*v_4_9-0.525952*v_4_10+0.240062*v_4_11-0.185572*v_4_12+1.181642*v_4_13-0.231475*v_4_14+0.123761*v_4_15+0.017643*v_4_16+0.585665*v_4_17-0.092486*v_4_18+0.437144*v_4_19+0.331187*v_4_20+0.486897*v_4_21-0.955769*v_4_22+0.537915*v_4_23+0.186993);\n\tfloat v_5_5 = sin(0.208218*v_4_0-0.142253*v_4_1-0.446791*v_4_2+0.102349*v_4_3+0.143475*v_4_4-0.332830*v_4_5+0.164841*v_4_6-0.128953*v_4_7+0.142046*v_4_8+0.280122*v_4_9+0.113214*v_4_10+0.639263*v_4_11-0.100701*v_4_12+0.245500*v_4_13+0.316454*v_4_14-0.131605*v_4_15+0.487086*v_4_16+0.141977*v_4_17-0.199768*v_4_18-0.032760*v_4_19-0.157363*v_4_20-0.113420*v_4_21+0.634704*v_4_22-0.150535*v_4_23+0.521799);\n\tfloat v_5_6 = sin(-0.423742*v_4_0-0.524954*v_4_1-0.925064*v_4_2+0.152475*v_4_3+0.575329*v_4_4-0.469397*v_4_5+0.064019*v_4_6+0.659530*v_4_7+0.158570*v_4_8+0.060260*v_4_9+0.164322*v_4_10+0.170212*v_4_11+0.147246*v_4_12+0.111810*v_4_13+0.068580*v_4_14-0.436919*v_4_15-0.208029*v_4_16+0.234146*v_4_17-0.121219*v_4_18-0.055657*v_4_19+0.098372*v_4_20+0.418185*v_4_21+0.107728*v_4_22+0.517681*v_4_23+0.059065);\n\tfloat v_5_7 = sin(0.124332*v_4_0+0.007902*v_4_1-0.078393*v_4_2-0.413229*v_4_3-0.020928*v_4_4+0.359961*v_4_5-0.721530*v_4_6-0.223597*v_4_7+0.040305*v_4_8-0.162146*v_4_9-0.934388*v_4_10+0.553820*v_4_11-0.434025*v_4_12+0.698819*v_4_13-0.309185*v_4_14-0.274982*v_4_15-0.458637*v_4_16-0.286257*v_4_17+0.026852*v_4_18+0.498259*v_4_19-0.085958*v_4_20+0.315931*v_4_21+0.911219*v_4_22+0.268918*v_4_23+0.956378);\n\tfloat v_5_8 = sin(0.669952*v_4_0-0.353317*v_4_1-0.231480*v_4_2+0.055407*v_4_3-0.521107*v_4_4-0.065777*v_4_5-0.120712*v_4_6+0.867789*v_4_7+0.298618*v_4_8-0.078688*v_4_9-0.244543*v_4_10-0.314191*v_4_11+0.879704*v_4_12+0.844619*v_4_13-0.642415*v_4_14+0.026264*v_4_15-0.539276*v_4_16+0.446598*v_4_17+0.388116*v_4_18+0.087696*v_4_19-0.063569*v_4_20+0.449695*v_4_21-0.115034*v_4_22-0.422239*v_4_23-1.551086);\n\tfloat v_5_9 = sin(-0.400464*v_4_0-0.097822*v_4_1+0.159505*v_4_2+0.485839*v_4_3-0.122942*v_4_4-0.262259*v_4_5+0.299447*v_4_6-0.001073*v_4_7+0.310423*v_4_8-0.270933*v_4_9+0.012910*v_4_10+0.089524*v_4_11+0.182323*v_4_12+0.259360*v_4_13+0.230278*v_4_14-0.391449*v_4_15+0.385416*v_4_16+0.257430*v_4_17+0.532602*v_4_18+0.404767*v_4_19+0.140718*v_4_20+0.019511*v_4_21+0.499167*v_4_22+0.593705*v_4_23+0.331548);\n\tfloat v_5_10 = sin(-0.647545*v_4_0+0.280986*v_4_1+0.143665*v_4_2+0.723811*v_4_3-0.660766*v_4_4+0.263426*v_4_5-0.023747*v_4_6+0.377754*v_4_7+0.489540*v_4_8+0.470520*v_4_9-0.350906*v_4_10+0.359063*v_4_11+0.017764*v_4_12+0.046126*v_4_13-0.520797*v_4_14+0.136845*v_4_15-0.113337*v_4_16+0.036906*v_4_17+0.166717*v_4_18-0.466966*v_4_19+0.274036*v_4_20+0.424980*v_4_21-0.018774*v_4_22-0.227427*v_4_23-0.861850);\n\tfloat v_5_11 = sin(-0.172001*v_4_0+0.017935*v_4_1+0.094448*v_4_2-0.584456*v_4_3+0.394043*v_4_4-0.410398*v_4_5+0.161138*v_4_6-0.184249*v_4_7+0.208574*v_4_8-0.486918*v_4_9+0.170267*v_4_10+0.418752*v_4_11+0.729323*v_4_12+0.008940*v_4_13-0.357256*v_4_14-0.182652*v_4_15-0.271981*v_4_16-0.345371*v_4_17+0.193327*v_4_18+0.216240*v_4_19-0.494330*v_4_20+0.680495*v_4_21-0.221019*v_4_22+0.177594*v_4_23-0.329187);\n\tfloat v_5_12 = sin(-0.668715*v_4_0+0.381641*v_4_1+0.340600*v_4_2-0.448269*v_4_3-0.572357*v_4_4-0.265598*v_4_5+0.030747*v_4_6+0.385711*v_4_7+0.219372*v_4_8-0.253492*v_4_9+0.271556*v_4_10+1.172294*v_4_11-0.228060*v_4_12+0.584268*v_4_13-0.377725*v_4_14+0.127909*v_4_15-0.258753*v_4_16-0.101764*v_4_17+0.019037*v_4_18+0.110701*v_4_19+0.268016*v_4_20+0.032762*v_4_21+0.217474*v_4_22-0.174669*v_4_23-0.408489);\n\tfloat v_5_13 = sin(-0.111889*v_4_0-0.396159*v_4_1-0.084957*v_4_2+0.420377*v_4_3-0.077202*v_4_4+0.062626*v_4_5+0.264598*v_4_6+0.241241*v_4_7-0.607922*v_4_8+0.479132*v_4_9+0.445743*v_4_10-0.119163*v_4_11+0.679398*v_4_12+0.103163*v_4_13+0.521198*v_4_14+0.068613*v_4_15-0.152857*v_4_16+0.120004*v_4_17-0.028197*v_4_18-0.385399*v_4_19+0.163577*v_4_20-0.563562*v_4_21-1.094819*v_4_22+0.528318*v_4_23+0.363983);\n\tfloat v_5_14 = sin(-0.161046*v_4_0+0.214544*v_4_1-0.056052*v_4_2+0.361705*v_4_3-0.247744*v_4_4-0.015336*v_4_5-0.287180*v_4_6-0.598205*v_4_7-0.067697*v_4_8-0.010427*v_4_9-0.897574*v_4_10+0.115635*v_4_11-0.265180*v_4_12-0.949500*v_4_13+0.081761*v_4_14-0.172782*v_4_15+0.046635*v_4_16+0.203557*v_4_17+0.111819*v_4_18+0.161629*v_4_19+0.840430*v_4_20+0.273948*v_4_21+0.035463*v_4_22-0.018570*v_4_23+0.343111);\n\tfloat v_5_15 = sin(-0.043873*v_4_0+0.304696*v_4_1+0.238971*v_4_2+0.047390*v_4_3-0.313457*v_4_4+0.129291*v_4_5+0.050922*v_4_6-0.116201*v_4_7-0.206470*v_4_8+0.227885*v_4_9-0.126115*v_4_10-0.597892*v_4_11-0.272811*v_4_12+1.199262*v_4_13-0.093775*v_4_14-0.147444*v_4_15-0.114427*v_4_16-0.135636*v_4_17-0.272815*v_4_18+0.148468*v_4_19+1.040073*v_4_20+0.304727*v_4_21-0.640896*v_4_22+0.059150*v_4_23-0.145530);\n\tfloat v_6_0 = 0.5 + (0.048904*v_5_0+0.028878*v_5_1-0.033498*v_5_2+0.040516*v_5_3-0.024041*v_5_4-0.067716*v_5_5-0.045497*v_5_6-0.027565*v_5_7+0.021977*v_5_8-0.029499*v_5_9+0.034521*v_5_10-0.051241*v_5_11-0.029079*v_5_12+0.031881*v_5_13+0.039989*v_5_14+0.029940*v_5_15-0.020651);\n\tv_6_0 += 0.05 * noise(200.0 * fragCoord.xy / iResolution.x);\n    v_6_0 += 0.05 * noise(400.0 * fragCoord.xy / iResolution.x);\n    fragColor = vec4(v_6_0, v_6_0, v_6_0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssd3Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 189], [191, 191, 217, 217, 592], [594, 594, 649, 649, 65771]]}
{"id": "sst3zn", "name": "Potion Seller", "author": "neur0sys", "description": "My potions are too strong for you, traveler!", "tags": ["warp"], "likes": 3, "viewed": 499, "published": 3, "date": "1629053804", "time_retrieved": "2024-07-30T19:06:14.745809", "image_code": "vec2 Distort(vec2 p)\n{\n    float theta  = atan(p.y, p.x);\n    float radius = length(p);\n    radius = pow(radius, 0.7);\n    p.x = radius * cos(theta);\n    p.y = radius * sin(theta);\n    return 0.5 * (p + 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = st * 2.0 - 1.0;\n    \n    float d = length(uv);\n    \n    if (d < 1.0) {\n        uv = Distort(uv);\n    } else {\n        uv = st;\n    }\n  \n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sst3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 210], [212, 212, 269, 319, 553]]}
{"id": "fsd3zr", "name": "time Tunnel", "author": "jorge2017a1", "description": "time Tunnel", "tags": ["timetunnel"], "likes": 9, "viewed": 275, "published": 3, "date": "1629040514", "time_retrieved": "2024-07-30T19:06:15.672332", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n#define opU(d1, d2) ( d1 < d2 ? d1 : d2 )\n#define opI(d1, d2) ( d1 > d2 ? d1 : d2 )\n#define opS(d1, d2) ( -d1 > d2 ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n///-----------------------------------------------------\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 Engrane1(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 p1= rotate_z(p-vec3(0.0,0.0,0.0), radians(iTime*10.0));\n    vec3 p2= rotate_z(p-vec3(0.0,0.0,0.0), radians(30.0+iTime*10.0));\n    \n    float numItem=16.0;\n    float tau = atan(1.0) * 8.0;\n    vec3 rep2a = opAngRep(p1, tau / numItem);\n    vec3 rep2b = opAngRep(p2, tau / numItem);\n   \n    rep2a= rotate_x( rep2a, radians(90.0));\n    rep2b= rotate_x( rep2b, radians(90.0));\n    \n    float sdb1= sdBox( rep2a-vec3(16.0,0.0,0.0), vec3(2.0,1.0,2.0) );\n    float sdb2= sdBox( rep2b-vec3(15.0,0.0,0.0), vec3(2.0,1.0,2.0) );\n    res =opU3(res, vec3(sdb1,101.0,MATERIAL_NO)); \n    res =opU3(res, vec3(sdb2,101.0,MATERIAL_NO)); \n    \n    //res =opU3(res, vec3(sdb1,-1.0,7.0)); \n    return res;\n}\n\n\n\nvec3 Engrane2(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 p1= rotate_z(p-vec3(0.0,0.0,0.0), radians(-iTime*10.0));\n    vec3 p2= rotate_z(p-vec3(0.0,0.0,0.0), radians(30.0-iTime*10.0));\n    float numItem=16.0;\n    float tau = atan(1.0) * 8.0;\n    vec3 rep2a = opAngRep(p1, tau / numItem);\n    vec3 rep2b = opAngRep(p2, tau / numItem);\n    rep2a= rotate_x( rep2a, radians(90.0));\n    rep2b= rotate_x( rep2b, radians(90.0));\n    \n    float sdb1= sdBox( rep2a-vec3(16.0,0.0,0.0), vec3(2.0,1.0,2.0) );\n    float sdb2= sdBox( rep2b-vec3(15.0,0.0,0.0), vec3(2.0,1.0,2.0) );\n    res =opU3(res, vec3(sdb1,101.0,-1.0)); \n    res =opU3(res, vec3(sdb2,100.0,MATERIAL_NO)); \n    return res;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tp.y=p.y-15.0;\n    vec3 p1=p;\n    vec3 p2=p;\n    mObj.AngRot=  radians(-iTime*10.0);\n    \n    p1.z= opRep1D( p1.z, 20.0 );\n    \n    vec3 v1=Engrane1(p1-vec3(0.0,0.0,0.0));\n    vec3 v2=Engrane2(p1-vec3(0.0,0.0,5.0));\n    \n    res =opU3(res, v1); \n    res =opU3(res, v2); \n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { \n        vec3 p1= rotate_z(p-vec3(0.0,0.0,0.0), mObj.AngRot);\n        p1.xy   = vec2(atan(p1.z,p1.x)/PI,p1.y);\n        vec3 col=tex3D(iChannel0, p1/32., nor); return col*2.0; \n    }\n\tif (i==101 )\n    {\n        vec3 p1= rotate_z(p-vec3(0.0,0.0,0.0), -mObj.AngRot);\n        p1.yz   = vec2(atan(p1.x,p1.y)/PI,p1.z);\n        return tex3D(iChannel1, p1/32., nor);\n    }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   //float d = RayMarch(ro, rd);\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n   light_pos1= vec3( 5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n   light_pos2= vec3(-10.0, 5.0, -10.0 ); light_color2 =vec3( 1.0 ); \n   \n \n   \n   vec3 ro=vec3(0.0,5.0+abs(9.0*sin(t*0.125)),-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n    float AngRot;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsd3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[561, 561, 593, 593, 677], [679, 717, 753, 753, 798], [841, 866, 900, 900, 996], [997, 997, 1031, 1031, 1122], [1123, 1123, 1157, 1157, 1248], [1249, 1346, 1380, 1380, 1553], [1555, 1555, 1578, 1578, 2312], [2316, 2316, 2339, 2339, 3009], [3011, 3051, 3076, 3076, 3510], [3512, 3563, 3587, 3587, 3749], [3751, 3751, 3800, 3800, 4431], [4433, 4487, 4523, 4523, 4768], [4769, 4824, 4851, 4851, 4868], [4870, 4870, 4906, 4906, 4998], [4999, 4999, 5045, 5045, 5170], [5172, 5172, 5246, 5246, 6840], [6841, 6896, 6945, 6945, 7441], [7442, 7476, 7556, 7556, 7679], [7722, 7774, 7867, 7867, 8122], [8125, 8125, 8156, 8156, 8723], [8725, 8774, 8800, 8800, 8910], [8912, 8912, 8970, 8970, 9022], [9024, 9073, 9130, 9130, 9748]]}
{"id": "slSSzt", "name": "Raymarching wavefront", "author": "pyBlob", "description": "The original shader interactively shows raymarching iterations for a *single* ray.\nThis shader simultaneously shows raymarching iterations for *all* rays starting from a single point.", "tags": ["raymarching", "visualization"], "likes": 21, "viewed": 482, "published": 3, "date": "1629027301", "time_retrieved": "2024-07-30T19:06:16.424321", "image_code": "/*\nThe original shader interactively shows raymarching for a single ray.\nThis shader simultaneously shows raymarching for ALL rays starting from a single point.\nEvery red point is the endpoint of some ray for some raymarching iteration.\nI think, this is one of the first visualizations that shows the individual raymarching steps all at once.\n\nWavefront mode:\n    - Move raymarching source with your mouse.\n    - Uncomment original sdf in scene(vec2) function.\n\nRay mode (original):\n    - Pick raymarching source by pressing mouse.\n    - Move raymarchign target.\n    - R: toggle original ray visualization.\n*/\n\nconst int AA = 16;\nconst int iterations = 20;\nconst int substep = 1;\n\n#define T (iTime * 1.)\nconst float _precision = 1e-4;\nconst float maxSteps = float(iterations);\nconst float maxDistance = 5.;\n\nconst int y_press = 0;\nconst int y_delta = 1;\nconst int y_toggle = 2;\n\nconst int key_R = 0x52;\nbool visualizeRay()\n{\n    return texelFetch(iChannel3, ivec2(key_R, y_toggle), 0).x > .5;\n}\n\nvec2 _p; float _d = 1e10;\n\nfloat sdBox(vec2 p,vec2 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    sca = normalize(sca);\n    scb = normalize(scb);\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x > scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(max(0., dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nfloat side(float r, float h)\n{\n    return sqrt(r*r - h*h);\n}\n\nfloat sdArcTo(in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 m = a + b;\n    float tb = dot(m, b) / length(m);\n    float arc = sdArc(p, vec2(m.y, -m.x), vec2(side(r, tb), tb), r, 0.);\n    //return min(min(length(p-a), length(p-b)), min(length(p-m), min(arc, length(p)))) -.01;\n    return arc;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat scene(vec2 p)\n{\n    p.x += .5;\n    float ball = length(p - vec2(1, 0)) - .3;\n    float lens = length(p - vec2(.8, 0)) - .15;\n    float wire = abs(p.y) - .05;\n    vec2 q = p; q.y = abs(q.y);\n    float eye = max(max(ball,-lens),-wire);\n    float bx = (pow(.3,2.)-pow(.15,2.)+pow(.2,2.))/(2.*.2);\n    float bh = side(.3, bx);\n    float ballArc = sdArcTo(q - vec2(1, 0), vec2(-bx,bh), vec2(side(.3,.05), .05), .3);\n    float lensArc = sdArcTo(q - vec2(.8, 0), vec2(.2-bx,bh), vec2(side(.15,.05), .05), .15);\n    float wireLine = sdLine(q, vec2(.8+side(.15,.05), .05), vec2(1.+side(.3,.05), .05));\n    float eye1 = min(min(ballArc, lensArc), wireLine) * sign(eye);\n    float socket = min(\n        sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),\n        sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))\n    );\n    //if (false)\n        return min(eye1, socket); // proper sdf\n    return min(eye, socket); // original sdf\n}\n\nvec2 getNormal(vec2 p)\n{    \n\tvec2 e = vec2(_precision, 0);\n    return normalize(vec2(scene(p+e.xy)-scene(p-e.xy),scene(p+e.yx)-scene(p-e.yx)));\n}\n\nvoid visualize(vec2 ro, vec2 rd, float t, float d, float i)\n{\n    vec2 n = getNormal(ro+rd*t);\n    \n    float x  = clamp(floor(T)-i,0.,1.);\n    float f1 = x + (1.-x) * fract(T);\n    float f2 = clamp((f1-.75)*16.,0.,1.);\n    float f3 = floor(abs(cos(min(f1*8.,1.)*6.283))+.5);\n    float a  = mix(atan(-n.y,-n.x),atan(rd.y,rd.x),f2);\n\n    // ray line\n    _d = min(_d,sdLine(_p,ro+rd*t,ro+rd*t+vec2(cos(a),sin(a))*d*floor(f3)));\n\n    // step indicator\n    _d = min(_d,length(_p-ro-rd*t)-.015);\n\n    if (i == floor(T))\n    {\n        // circle\n        _d = min(_d,abs(length(_p-ro-rd*t)-clamp(d*f3,0.,1e4)));\n    }\n}\n\nvec4 march(vec2 ro, vec2 rd)\n{\n    float t = 0., s = float(maxSteps), d;\n\n    for(float i = 0.; i < maxSteps; i++)\n    {\n        d = scene(ro+rd*t);\n\n        if (d < _precision || t > maxDistance || i > floor(T))\n        {\n            s = float(i);\n            break;\n        }\n\n\t\tvisualize(ro,rd,t,d,i);\n        \n        t += d;\n    }\n    \n    return vec4(ro+rd*t,d,s);\n}\n\nvoid swap(inout vec2 a, inout vec2 b)\n{\n    vec2 z = a;\n    a = b;\n    b = z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zero = min(0., iTime);\n\n    _p = (2.*fragCoord.xy-iResolution.xy)/iResolution.yy;\n\tvec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.yy;\n    vec2 c = (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.yy;\n    bool demo = iMouse.z == 0.;\n    \n    if (demo)\n    {\n        float a = .3 * iTime;\n        c = vec2(.5, 0.) + .5 * vec2(cos(a), sin(a));\n        m = c;\n    }\n    else if (visualizeRay())\n    {\n        //swap(m, c);\n    }\n    else\n    {\n        c = m;\n    }\n    \n    vec2 ro = c;//vec2(-1,0);\n    vec2 rd = normalize(m-ro);\n    vec4 h  = march(ro,rd);\n    \n    // camera & scene\n    _d = min(_d,min(min(abs(length(_p-ro)-.01),sdLine(_p,ro,ro+rd*.05)),scene(_p)));\n        \n    // normal arrow\n    if (h.z < _precision)\n    {\n        vec2 n = getNormal(h.xy);\n        vec2 t = vec2(-n.y,n.x);\n\n        _d = min(_d,sdLine(_p,h.xy,h.xy+n*.1));\n        _d = min(_d,sdLine(_p,h.xy+n*.1,h.xy+n*.1+t*.025));\n        _d = min(_d,sdLine(_p,h.xy+n*.1,h.xy+n*.1-t*.025));\n        _d = min(_d,sdLine(_p,h.xy+n*.1+t*.025,h.xy+n*.125));\n        _d = min(_d,sdLine(_p,h.xy+n*.1-t*.025,h.xy+n*.125));\n    }\n    \n    _d = abs(_d)-1./iResolution.y;\n    \n\tfragColor = vec4(vec3(smoothstep(_d,_d+.005,.005)),1.0);\n\n    vec4 col = vec4(0);\n    for (int i=1 ; i<2*AA ; i+=2)\n    for (int j=1 ; j<2*AA ; j+=2)\n    {\n        vec2 jitter = (vec2(i, j) / float(AA) - .5) / iResolution.yy;\n        vec2 ro1 = ro;// + jitter;\n        vec2 _p1 = _p + jitter;\n        vec2 rd1 = normalize(_p1 - ro1);\n        float r = length(_p1 - ro1);\n        float t1 = 0.;\n        for (int i=0 ; i<iterations*substep ; ++i)\n        {\n            t1 += scene(ro1 + rd1 * t1) / float(substep);\n            //col += vec4(1,0,0,1) * max(0., 1. - abs(t1 - r) * iResolution.y / 1.);\n            col += vec4(1,0,0,1) * step(abs(t1 - r) * iResolution.y, 1.);\n        }\n    }\n    col /= float(AA * AA);\n    fragColor = col + fragColor * (1. - col.w);\n    fragColor.xyz = pow(fragColor.xyz, vec3(.45));\n    //fragColor = vec4(visualizeRay());\n    \n    //fragColor = vec4(sin(scene(_p) * iResolution.y));\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[903, 903, 924, 924, 994], [1023, 1023, 1051, 1051, 1113], [1115, 1115, 1151, 1151, 1215], [1217, 1217, 1292, 1292, 1531], [1533, 1533, 1563, 1563, 1593], [1595, 1595, 1652, 1652, 1894], [1896, 1896, 1948, 1948, 2225], [2227, 2227, 2279, 2279, 2398], [2400, 2400, 2421, 2421, 3330], [3332, 3332, 3356, 3356, 3478], [3480, 3480, 3541, 3541, 4091], [4093, 4093, 4123, 4123, 4465], [4467, 4467, 4506, 4506, 4546], [4548, 4548, 4605, 4605, 6674]]}
{"id": "NddGzn", "name": "3D close-loop spiral", "author": "FabriceNeyret2", "description": "WIP\nmouse control\n", "tags": ["spiral", "short"], "likes": 26, "viewed": 367, "published": 3, "date": "1629026481", "time_retrieved": "2024-07-30T19:06:17.182295", "image_code": "\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )             // rotation                  \nvec3 M;\n\n#define TAU 6.283185\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,l,a,A,s,z=0.,S,H,h,l2,r=25.,r2=20.33; //, Z=0.;\n    vec2  P,d;\n    vec3  R = iResolution,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q;                                      // marching point along ray \n       // M =  iMouse.xyz/R -.5;\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O=vec4(0) ; O.x < 1.5 && t > .01 ; O+=.01 )\n        t=9., q = p,\n        q.yz *= rot( .5+6.*M.y),                             // rotations\n        q.xz *= rot( 2.-6.*M.x),\n        q.zy *= H = sign(h=q.y),           q.y -= r/2.,      // top-down symmetry\n        q.xz *= S = sign(q.x +sign(q.z)) , q.x -= TAU*3.5,   // left-right symmetry\n        l = length(q.xz), a = atan(q.z,q.x),\n        s = min( TAU*3.5, l - a),                            // spiral coord ( truncated )\n        l = round(s/TAU)*TAU + a,                            // l reset at tube center\n        l = max(0.,r-l),\n        q.y += r2 - sqrt(max(0.,r2*r2-l*l)),                 // spiral sinking\n        t = min(t, length(vec2( mod(s+TAU/2.,TAU)-TAU/2.,q.y)) - 1.), // SDF\n        p += .25*t*D; // , Z+=t;                             // step forward = dist to obj          \n\n // O = vec4(1.6-Z/200.); return;                    // for Depth buffer\n    a = max (0., round(s/TAU)*TAU + a );\n    a = S*H*a*a/2.-20.*iTime -H;                             // curvilinear coordinate\n  //O = max(1.5-3.*O,0.);\n    O = O.x > 1.5 ? vec4(0.) : 4.*exp(-3.*O/2.);             // luminance (depth + pseudo-shading )\n                           // vec4(exp(-(Z-300.)/200.));\n    O *= (.6+.4*sin(a)) *vec4(.5+.5*h/r2,.5-.5*h/r2,0,0);    // color\n      // (.6+.4*clamp(sin(a)/fwidth(a),-1.,1.))\n // O *= .5+.5* vec4(cos(a),sin(a),min(2.,4.*h/r),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 159, 159, 1976]]}
{"id": "fddGzn", "name": "BoxLine3D test", "author": "yasuo", "description": "BoxLine3D test", "tags": ["line"], "likes": 2, "viewed": 239, "published": 3, "date": "1629018745", "time_retrieved": "2024-07-30T19:06:17.939270", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 80.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2){\n    vec4 res1 = val1;\n    vec4 res2 = val2;\n    res1.w = min(val2.w,val1.w);\n    res2.w = min(val1.w,val2.w);\n    return (val1.w < val2.w)?res1:res2;\n}\n\nfloat B3D(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\n\n// TODO:ATM, we can not make the slope of line based on x rotation.\n// The following set up won't work:\n// A = vec3(0.7,0.0,1.15); B = vec3(-0.1,0.5,-0.6);\n// For now, B of the Y value should be as same as the A of the Y value.\nfloat dBoxLine(vec3 p, vec3 a, vec3 b, vec2 size){\n    vec3 v = normalize(b-a);\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 right = normalize(cross(v,up));\n    vec3 newRightVec = right*(size.x*0.5);\n    vec3 newUpVec = up*(size.y*0.5); \n\n    // left, right\n    vec3 a1 = a+newRightVec, a2 = a-newRightVec, b1 = b+newRightVec, b2 = b-newRightVec;\n    vec3 mida = vec3((a1.x + b1.x) * 0.5, (a1.y + b1.y) * 0.5, (a1.z + b1.z) * 0.5);\n    vec3 midb = vec3((a2.x + b2.x) * 0.5, (a2.y + b2.y) * 0.5, (a2.z + b2.z) * 0.5);\n\n    // up, bottom\n    vec3 c1 = a+newUpVec, c2 = a-newUpVec, d1 = b+newUpVec, d2 = b-newUpVec;\n    vec3 midc = vec3((c1.x + d1.x) * 0.5, (c1.y + d1.y) * 0.5, (c1.z + d1.z) * 0.5);\n    vec3 midd = vec3((c2.x + d2.x) * 0.5, (c2.y + d2.y) * 0.5, (c2.z + d2.z) * 0.5);\n\n    float rad1 = -atan(b1.x-a1.x,b1.z-a1.z);\n    //float rad2 = -atan(d1.y-c1.y,d1.z-c1.z);\n    float rad3 = -atan(a2.x-a1.x,a2.z-a1.z);\n\n    float mad = dot(p-mida,vec3(cos(rad1),0.0,sin(rad1)));// side\n    float mbd = dot(p-midb,vec3(cos(rad1),0.0,sin(rad1)));// side\n    \n    float mcd = (p-midc).y;// top\n    float mdd = (p-midd).y;// bottom\n    \n    float ad = dot(p-a,vec3(cos(rad3),0.0,sin(rad3)));\n    float bd = dot(p-b,vec3(cos(rad3),0.0,sin(rad3)));\n    \n    float d = max(max(max(-mad,mbd),max(mcd,-mdd)),max(ad,-bd));\n    return d;\n}\n\nfloat dBoxAnimatedLine(vec3 p, vec3 a, vec3 b, vec2 size, float t){\n    t*=2.0;\n    size.x=0.1+sin(t)*0.05;\n    size.y=0.2+sin(t)*0.1;\n    return dBoxLine(p,a,b,size);\n}\n\nvec4 GetDist(vec3 p) {\n    p*=matRotateX(radians(90.0));\n    float scale = 5.0;\n    vec3 p0 = vec3(-0.285,0.0,-0.075)*scale;\n    vec3 p1 = vec3(-0.2541,0.0,-0.0185)*scale;\n    vec3 p2 = vec3(0.0797,0.0,0.1185)*scale;\n    vec3 p3 = vec3(0.199,0.0,0.0492)*scale;\n    vec3 p4 = vec3(0.2826,0.0,0.0492)*scale;\n    vec3 p5 = vec3(0.3609,0.0,0.1101)*scale;\n    vec3 p6 = vec3(0.395,0.0,0.006)*scale;\n    vec3 p7 = vec3(0.393,0.0,-0.081)*scale;\n    \n    vec3 p8 = vec3(-0.3868,0.0,-0.0452)*scale;\n    vec3 p9 = vec3(-0.322,0.0,0.01)*scale;\n    vec3 p10 = vec3(0.1159,0.0,0.183)*scale;\n    vec3 p11 = vec3(0.1717,0.0,0.108)*scale;\n    vec3 p12 = vec3(0.1559,0.0,0.0739)*scale;\n\n    vec3 p13 = vec3(-0.1,0.0,-0.081)*scale;\n    vec3 p14 = vec3(-0.043,0.0,-0.025)*scale;\n    vec3 p15 = vec3(0.038,0.0,0.005)*scale;\n    vec3 p16 = vec3(0.189,0.0,0.005)*scale;\n    vec3 p17 = vec3(0.357,0.0,0.032)*scale;\n    vec3 p18 = vec3(0.369,0.0,0.001)*scale;\n    vec3 p19 = vec3(0.143,0.0,-0.044)*scale;\n    vec3 p20 = vec3(0.063,0.0,-0.081)*scale;\n    \n    vec3 p21 = vec3(0.38,0.0,-0.162)*scale;\n    vec3 p22 = vec3(-0.159,0.0,-0.159)*scale;\n    vec3 p23 = vec3(-0.387,0.0,-0.103)*scale;\n    \n    vec3 p24 = vec3(-0.1904,0.0,-0.012)*scale;\n    vec3 p25 = vec3(-0.22,0.0,0.062)*scale;\n\n    vec3 p26 = vec3(-0.125,0.0,0.013)*scale;\n    vec3 p27 = vec3(-0.168,0.0,0.088)*scale;\n    \n    vec3 p28 = vec3(-0.065,0.0,0.039)*scale;\n    vec3 p29 = vec3(-0.108,0.0,0.114)*scale;\n    \n    vec3 p30 = vec3(-0.002,0.0,0.065)*scale;\n    vec3 p31 = vec3(-0.045,0.0,0.135)*scale;\n\n    float t = iTime;\n    float d = dBoxAnimatedLine(p,p0,p1,vec2(0.05,0.3),t*2.0);\n    float d2 = dBoxAnimatedLine(p,p1,p2,vec2(0.05,0.3),t*1.2);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p2,p3,vec2(0.05,0.3),t*1.1);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p3,p4,vec2(0.05,0.3),t*0.8);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p4,p5,vec2(0.05,0.3),t*1.3);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p5,p6,vec2(0.05,0.3),t*2.0);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p6,p7,vec2(0.05,0.3),t*1.7);\n    d = min(d,d2);\n  \n    d2 = dBoxAnimatedLine(p,p8,p9,vec2(0.05,0.3),t*1.5);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p9,p10,vec2(0.05,0.3),t*0.9);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p10,p11,vec2(0.05,0.3),t*0.96);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p11,p12,vec2(0.05,0.3),t*1.4);\n    d = min(d,d2);\n    \n    d2 = dBoxAnimatedLine(p,p0,p8,vec2(0.05,0.3),t*1.6);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p0,p7,vec2(0.05,0.3),t*1.5);\n    d = min(d,d2);\n    \n    d2 = dBoxAnimatedLine(p,p13,p14,vec2(0.05,0.3),t*1.7);\n    d = min(d,d2);    \n    d2 = dBoxAnimatedLine(p,p14,p15,vec2(0.05,0.3),t*1.9);\n    d = min(d,d2);  \n    d2 = dBoxAnimatedLine(p,p15,p16,vec2(0.05,0.3),t*2.5);\n    d = min(d,d2);  \n    d2 = dBoxAnimatedLine(p,p16,p17,vec2(0.05,0.3),t*1.2);\n    d = min(d,d2);  \n    d2 = dBoxAnimatedLine(p,p17,p18,vec2(0.05,0.3),t*1.3);\n    d = min(d,d2);  \n    d2 = dBoxAnimatedLine(p,p18,p19,vec2(0.05,0.3),t*1.5);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p19,p20,vec2(0.05,0.3),t*1.9);\n    d = min(d,d2);\n    \n    d2 = dBoxAnimatedLine(p,p21,p22,vec2(0.05,0.3),t*1.8);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p22,p23,vec2(0.05,0.3),t*1.7);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p7,p21,vec2(0.05,0.3),t*1.1);\n    d = min(d,d2);\n    d2 = dBoxAnimatedLine(p,p8,p23,vec2(0.05,0.3),t*2.1);\n    d = min(d,d2);\n    \n    d2 = dBoxAnimatedLine(p,p24,p25,vec2(0.05,0.3),t*1.5);\n    d = min(d,d2);    \n    \n    d2 = dBoxAnimatedLine(p,p26,p27,vec2(0.05,0.3),t*1.8);\n    d = min(d,d2);    \n    \n    d2 = dBoxAnimatedLine(p,p28,p29,vec2(0.05,0.3),t*1.3);\n    d = min(d,d2);    \n    \n    d2 = dBoxAnimatedLine(p,p30,p31,vec2(0.05,0.3),t*1.6);\n    d = min(d,d2);    \n    \n    vec4 model = vec4(vec3(1.0,0.0,0.0),d);\n    \n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(3,5,0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.2;\n    \n\n    \n    return vec2((lambert+dif),0.9) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0.0, -3.1);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(15.0));\n    ro.xz *= Rot(radians(t*20.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 0.6);\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n        vec3 n = GetNormal(p);\n        vec2 dif = GetLight(p);\n        //col = vec3(dif.x)*r.rgb;\n        //col *= dif.y;\n        \n        float IOR = 1.5; //IOR:index of reflection\n        vec3 rdIn = refract(rd,n,1.0/IOR); \n        vec3 refTex = texture(iChannel0,rdIn).rgb;      \n        col=refTex;\n        \n    } else {\n        // background\n        col =.3*max(mix(vec3(0.3)-(.1-length(uv.xy)/3.),vec3(0.2),.1),0.);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[513, 513, 538, 538, 557], [559, 559, 600, 600, 691], [693, 693, 728, 728, 880], [882, 882, 909, 909, 963], [965, 1193, 1243, 1243, 2520], [2522, 2522, 2589, 2589, 2691], [2693, 2693, 2715, 2715, 6552], [6554, 6554, 6587, 6587, 6894], [6896, 6896, 6920, 6920, 7121], [7123, 7123, 7146, 7146, 7442], [7444, 7444, 7486, 7486, 7681], [7683, 7683, 7740, 7740, 8731]]}
{"id": "fsd3Rn", "name": "Fragments [nvoke]", "author": "tdhooper", "description": "Relax and unwind in the distance fields\n    \na 4k executable graphics entry for Nvoke 2021", "tags": ["dispersion", "zen", "crystal", "nevoke"], "likes": 74, "viewed": 2087, "published": 3, "date": "1629016724", "time_retrieved": "2024-07-30T19:06:18.889729", "image_code": "/*\n\n    Fragments\n    ---------\n\n    Relax and unwind in the distance fields\n    \n    a 4k executable graphics entry for Nvoke 2021\n\n*/\n\n\n// colour grading from tropical trevor's scripts\n// https://github.com/trevorvanhoof/ColorGrading\n\n#define sat(x) clamp(x,0.,1.)\n\n// from http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/\nvec3 colorFromKelvin(float temperature) // photographic temperature values are between 15 to 150\n{\n    float r, g, b;\n    if(temperature <= 66.0)\n    {\n        r = 1.0;\n        g = sat((99.4708025861 * log(temperature) - 161.1195681661) / 255.0);\n        if(temperature < 19.0)\n            b = 0.0;\n        else\n            b = sat((138.5177312231 * log(temperature - 10.0) - 305.0447927307) / 255.0);\n    }\n    else\n    {\n        r = sat((329.698727446 / 255.0) * pow(temperature - 60.0, -0.1332047592));\n        g = sat((288.1221695283  / 255.0) * pow(temperature - 60.0, -0.0755148492));\n        b = 1.0;\n    }\n    return vec3(r, g, b);\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nfloat Luma(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\tvec3 col = tex.rgb / tex.a;\n\n    //fragColor = vec4(col, 1); return;\n\n    // saturation\n\tfloat luma = Luma(col);\n\tcol = mix(vec3(luma), col, 1.25);\n\n    // temperature\n    col *= 1. / colorFromKelvin(100.);\n\n    vec3 uGain = vec3(1.333);\n    vec3 uLift = vec3(.0015,.00,.005) * 1.25;\n    vec3 uOffset = vec3(.00,.00,.00);\n    vec3 uGamma = vec3(.0666);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    fragColor = vec4(col, 1);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.1415926\n\n\n// Spectrum palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n//========================================================\n// Noise\n//========================================================\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nconst uint k = 1103515245U;  // GLIB C\n\n// https://www.shadertoy.com/view/XlXcW4\nvec3 hash33( vec3 xs )\n{\n    uvec3 x = uvec3(xs);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat hash13(vec3 p3)\n{\n\treturn hash33(p3).x;\n}\n\n\n//========================================================\n// Utils\n//========================================================\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmin(vec3 v) {\n    return min(min(v.x, v.y), v.z);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmax2(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax2(min(d, vec2(0)));\n}\n\nmat3 lookUp(vec3 up, vec3 forward) {\n    vec3 ww = normalize(up);\n    vec3 uu = normalize(cross(ww,forward));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, ww, vv);\n}\n\nvec3 pLookUp(vec3 p, vec3 up, vec3 forward) {\n    return p * lookUp(up, forward);\n}\n\nvec2 rndcircle(vec2 seed) {\n    float a = seed.x * 2. * PI;\n    float r = sqrt(seed.y);\n    return vec2(r * cos(a), r * sin(a));\n}\n\nfloat unlerp(float minv, float maxv, float value) {\n  return (value - minv) / (maxv - minv);\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nfloat invert;\n\nstruct Model {\n    float d;\n    int id;\n};\n\nfloat sdCrystalOne(vec3 size, vec3 p) {\n    float d = fBox(p, size);\n    d = max(d, -abs(p.x));\n    d = max(d, -(d + vmin(size) * .333));\n    return d;\n}\n\nfloat sdCrystalLoop(vec3 size, vec3 l, vec3 p, float seed) {\n\n    p.y = max(p.y, .5 * size.y / l.y);\n    \n    p.y -= size.y * .5;\n    size.y *= .5;\n\n    float bs = 1.;\n    float bound = fBox(p, size * vec3(1.5,1.4,1.5));\n    if (bound > bs) {\n        return bound;\n    }\n   \n    vec3 pp = p;\n    float d = 1e12;\n    \n    for (int x = 0; x < int(l.x); x++)\n    for (int y = 0; y < int(l.y); y++)\n    for (int z = 0; z < int(l.z); z++) {\n        p = pp;\n        vec3 c = vec3(x, y, z);\n        p -= ((c + .5) / l - .5) * size * 2.;\n        vec3 sz = size / l;\n        vec3 h3 = hash33(c + 11. + seed);\n        p -= (h3 * 2. - 1.) * sz * .5;\n        float m = hash13(c * 10. + 27. + seed);\n        sz *= mix(.6, 1.5, m);\n        sz.xz *= mix(1.8, .45, pow(float(y) / (l.y - 1.), .5));\n        float d2 = fBox(p, sz);\n        d2 = max(d2, -abs(p.x));\n        if (h3.z > .5 && c.y > 0.) {\n            d2 = max(d2, -abs(p.y - (m * 2. - 1.) * sz.y * .5));\n        }\n        d = min(d, d2);\n    }\n    \n    d = max(d, -(d + vmin(size / l) * .5));\n    \n    d = mix(d, bound, smoothstep(bs * .8, bs, bound));\n\n    return d;\n}\n\n\nfloat sdCrystalLoop2(vec3 size, vec3 l, vec3 p) {\n\n    size *= .9;\n    \n    p.y -= size.y * .5;\n    size.y *= .5;\n    \n    float bs = 1.;\n    float bound = fBox(p, size * vec3(1.2,1.8,1.2));\n    if (bound > bs) {\n        return bound;\n    }\n\n    vec3 pp = p;\n    float d = 1e12;\n    \n    for (int x = 0; x < int(l.x); x++)\n    for (int y = 0; y < int(l.y); y++)\n    for (int z = 0; z < int(l.z); z++) {\n        p = pp;\n        vec3 c = vec3(x, y, z);\n        p -= ((c + .5) / l - .5) * size * 2.;\n        vec3 sz = size / l;\n        float m = hash13(c+15.);\n        sz *= mix(1.1, 1.75, m);\n        float d2 = fBox(p, sz) + .01;\n        if (c == vec3(0)) {\n            d2 = max(d2, -abs(p.x));\n        }\n        d2 = max(d2, -d);\n        d = min(d, d2);\n    }\n    \n    d = max(d, -(d + vmin(size / l) * .5));\n    \n    d = mix(d, bound, smoothstep(bs * .8, bs, bound));\n    \n    return d;\n}\n\nfloat sdCrystalField(vec3 p) {\n    float d = 1e12;\n    float s = .2;\n    d = sdCrystalLoop(vec3(.35, 1.6, .35), vec3(2,3,2), pLookUp(p - vec3(.8,0,-.8), vec3(.2,1,-.5), vec3(1,0,1)), 0.);\n    d = smin(d, sdCrystalOne(vec3(.13), pLookUp(p - vec3(1.8,-.15,-.3), vec3(0,1,0), vec3(1,0,-.25))), s);\n    d = smin(d, sdCrystalLoop2(vec3(.3, .35, .3), vec3(2,1,2), pLookUp(p - vec3(-.3,0,.5), vec3(-.0,1,.2), vec3(.0,0,1)) - vec3(0,-.2,0)), s);\n    d = smin(d, sdCrystalLoop(vec3(.15,1.,.15), vec3(1,3,1), pLookUp(p - vec3(-1.8,-.15,-2.3), vec3(-1,2,-.5), vec3(-1,0,-2)), 11.), s);\n    return d;\n}\n\n\nModel map(vec3 p) {\n    //vec2 im = iMouse.xy / iResolution.xy;     \n    vec2 im = vec2(.43,.43);\n    pR(p.yz, (.5 - im.y) * PI);\n    pR(p.xz, (.5 - im.x) * PI * 2.5);\n    \n    p.y += .6;\n    p.xz -= vec2(-1,1) * .4;\n    \n    float d = p.y + .25;    \n    d = smin(d, length(p - vec3(.6,-2.5,-.7)) - 2.5, .6);\n    d = smin(d, length(p - vec3(-.3,-.5,.5)) - .5, .4);\n\n    float d2 = sdCrystalField(p);\n\n    float df = pow(d2 + .333, .5) * 1.5;\n    float ripple = 7.;    \n    d += cos(max(df, 0.) * ripple * PI * 2.) * .015;\n\n    Model m = Model(d, 2);\n    Model m2 = Model(d2 * invert, 1);\n    \n    if (m2.d < m.d) {\n        m = m2;\n    }\n\n    return m;\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nconst float sqrt3 = 1.7320508075688772;\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).d;\n    }\n    return normalize(n);\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n    float len;\n};\n\nHit march(vec3 origin, vec3 rayDir, float maxDist) {\n    vec3 p;\n    float len = 0.;\n    float dist = 0.;\n    Model model;\n\n    for (float i = 0.; i < 100.; i++) {\n        len += dist;\n        p = origin + len * rayDir;\n        model = map(p);\n        dist = model.d;\n        if (abs(model.d) / len < .0002) {\n            break;\n        }\n        if (len >= maxDist) {\n            len = maxDist;\n            model.id = 0;\n            break;\n        }\n    }   \n\n    return Hit(model, p, len);\n}\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nfloat intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {\n    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);\n  \tvec3 point = rOrigin + d * rayDir;\n\tvec3 tangent = cross(normal, up);\n\tvec3 bitangent = cross(normal, tangent);\n    point -= origin;\n    uv = vec2(dot(tangent, point), dot(bitangent, point));\n    return max(sign(d), 0.);\n}\n\nmat3 sphericalMatrix(vec2 tp) {\n    float theta = tp.x;\n    float phi = tp.y;\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 envOrientation;\n\nvec3 light(vec3 origin, vec3 rayDir) {\n\n    origin = -origin;\n    rayDir = -rayDir;\n\n    origin *= envOrientation;\n    rayDir *= envOrientation;\n\n    vec2 uv;\n    vec3 pos = vec3(-6);\n    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);\n    float l = smoothstep(.75, .0, fBox2(uv, vec2(.5,2)) - 1.);\n    l *= smoothstep(6., 0., length(uv));\n\treturn vec3(l) * hit * 2.;\n}\n\nvec4 draw(vec2 fragCoord) {\n\n    vec2 seed = hash22(fragCoord + (float(iFrame)) * sqrt3);\n\n    invert = 1.;\n    \n    envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    float focalLength = 3.;\n    vec3 camPos = vec3(0, 0, 1.5) * focalLength;\n    vec3 camTar = vec3(0, 0, 0);\n    \n    // DOF\n    camPos.xy += rndcircle(seed) * .05;\n    seed = hash22(seed);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n\n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n    \n    Hit hit = march(origin, rayDir, 4. * focalLength);\n\n    float firstHitLen = hit.len;\n    bool isFloor = hit.model.id == 2;\n    \n    vec3 nor, ref, raf; \n    float ior, offset;\n    \n    float wavelength = seed.y;\n    vec3 col = vec3(0);    \n\n    for (int bounce = 0; bounce < 10; bounce++) {\n   \n        if (bounce > 0) {\n           seed = hash22(seed);\n           hit = march(origin, rayDir, 6.);\n        }\n        \n        if (hit.model.id == 0) {\n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        \n        if (hit.model.id == 1) {\n            \n            // Reflective bounce\n            \n            ref = reflect(rayDir, nor);\n            \n            // shade\n            col += light(hit.pos, ref) * .5;\n            col += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;\n            col *= vec3(.85,.85,.98);\n\n            // refract\n            ior = mix(1.2, 1.8, wavelength);\n            ior = invert < 0. ? ior : 1. / ior;\n            raf = refract(rayDir, nor, ior);\n            bool tif = raf == vec3(0); // total internal reflection\n            rayDir = tif ? ref : raf;\n            invert *= -1.; // not correct but gives more interesting results\n            //invert = tif ? 1. : -1.; // 'correct' refraction\n            \n        } else {\n            \n            // Diffuse bounce\n            \n            seed = hash22(seed);\n            rayDir = getSampleBiased(nor, 1., seed);            \n \n        }\n        \n        offset = .01 / abs(dot(rayDir, nor));\n        origin = hit.pos + offset * rayDir;\n    }    \n    \n    if (isFloor) {\n        col *= 2.;\n    }\n\n    vec3 fogcol = vec3(.0);\n    col = mix(col, fogcol, saturate(1.0 - exp2(-.0006 * pow(firstHitLen - length(camPos*.666), 5.))));\n\n    // Dispersion\n    col *= spectrum(-wavelength+.30);\n\n    return vec4(col, 1);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec4 col = draw(fragCoord);\n    \n    if (iFrame > 0) {\n        vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n        col += lastCol;\n    }\n    \n    fragColor = col;\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsd3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 352, 450, 450, 993], [995, 995, 1014, 1014, 1205], [1207, 1207, 1231, 1231, 1282], [1284, 1284, 1339, 1339, 1954]]}
{"id": "fdt3Rn", "name": "Double Spiral", "author": "dr2", "description": "Even more logarithmic spiraling", "tags": ["spiral", "logarithm", "project"], "likes": 13, "viewed": 287, "published": 3, "date": "1629012218", "time_retrieved": "2024-07-30T19:06:19.637729", "image_code": "// \"Double Spiraling\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (see \"Spiraling Out\" and \"Spiraling In and Out\")\n\n#define AA  1   // =0/1 - optional antialiasing\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec3 ltDir;\nfloat tCur, dstFar, wSep;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a, dc;\n  dMin = dstFar;\n  for (float k = -1.; k <= 1.; k += 2.) {\n    q = p;\n    q.x -= k * wSep;\n    r = length (q.xz);\n    if (r > 0.01) {\n      q.xz *= k;\n      dc = max (r - wSep - 0.45, min (r - wSep + 0.55, - q.z));\n      a = atan (q.z, q.x) / pi;\n      q.xz = fract (vec2 (pi * log (r) - 0.5 * a, -5. * a) + 0.5) - 0.5;\n      if (r < 1.) q.y /= sqrt (r);\n      d = max (r * PrRoundBox2Df (vec2 (q.x, q.y - 0.12), vec2 (0.18, 0.1), 0.02), dc);\n      DMIN (1);\n      d = max (r * PrRoundCylDf (vec3 (q.x, q.y - 0.44, fract (2. * q.z - 0.7 * k * tCur +\n         0.5) - 0.5).xzy, 0.13, 0.04, 0.2), dc);\n      DMIN (2);\n    }\n  }\n  return 0.1 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 300; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, nDotL;\n  wSep = 5.77;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj >= dstFar && rd.y < 0.) {\n    dstObj = - ro.y / rd.y;\n    idObj = 3;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = (idObj != 3) ? ObjNf (ro) : vec3 (0., 1., 0.);\n    if (idObj == 1) col4 = vec4 (0.1, 0.3, 0.8, 0.1);\n    else if (idObj == 2) col4 = vec4 (0.9, 0.8, 0.8, 0.3);\n    else if (idObj == 3) col4 = vec4 (0.2, 0.5, 0.2, 0.05);\n    if (idObj <= 2) col4 = mix (vec4 (0.2, 0.5, 0.2, 0.05), col4,\n       smoothstep (0.05, 0.1, length (vec2 (abs (ro.x) - wSep, ro.z))));\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj == 2) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.8 * nDotL) + col4.a * pow (max (dot (ltDir,\n       reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0.5);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.35 * pi, -0.15 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -30.);\n  zmFac = 4.;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdt3Rn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[606, 606, 628, 628, 1313], [1315, 1315, 1348, 1348, 1596], [1598, 1598, 1619, 1619, 1874], [1876, 1876, 1911, 1911, 2763], [2765, 2765, 2821, 2821, 3834], [3836, 3836, 3883, 3883, 3930], [3932, 3932, 3989, 3989, 4064], [4066, 4066, 4102, 4102, 4308], [4310, 4310, 4340, 4340, 4453]]}
{"id": "7dc3zr", "name": "function visual", "author": "DBBH", "description": "function visual easy framework", "tags": ["functionvisual"], "likes": 1, "viewed": 205, "published": 3, "date": "1629003198", "time_retrieved": "2024-07-30T19:06:20.384732", "image_code": "#define lineWidth 0.05\n#define Range 10.\n\n#define f1 x\n#define f2 exp(x)\n#define f3 0.0\n\nfloat outputResult(float y,vec2 uv)\n{\n    float w = lineWidth; // * fwidth(length(uv));;\n    float neg = smoothstep(y- w, y ,uv.y);\n    float positive = smoothstep(y, y + w ,uv.y);\n    return neg - positive;\n}\nfloat get_function_visual_1(float x, vec2 uv)\n{\n    return outputResult(f1, uv);\n}\nfloat get_function_visual_2(float x, vec2 uv)\n{\n    return outputResult(f2, uv);\n}\nfloat get_function_visual_3(float x, vec2 uv)\n{\n    return outputResult(f3, uv);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) and center changes to 0.5\n    vec2 uv = Range*(fragCoord/iResolution.xy - vec2(0.5));\n    float x =uv.x;\n\n    float y=get_function_visual_1(x, uv);\n    float y2=get_function_visual_2(x, uv);\n    float y3=get_function_visual_3(x, uv);\n    \n    float res = max(max(y,y2),y3);\n    \n    vec3 col = vec3(res); // max(....all functions)\n    // or use only one\n    col = vec3(outputResult(f1, uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dc3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 126, 126, 298], [299, 299, 346, 346, 381], [382, 382, 429, 429, 464], [465, 465, 512, 512, 547], [548, 548, 605, 681, 1105]]}
{"id": "7ljXWt", "name": "Abstract Truchet Inversion ", "author": "byt3_m3chanic", "description": "Just taking a play day and pushing out some i've been kicking around - concept from older shader. Two woven truchet tile patterns, with some glow effects. Using buffer tab to feed in color for Fog to get trail effect.", "tags": ["raymarching", "glow", "truchet", "inversion", "design"], "likes": 26, "viewed": 550, "published": 3, "date": "1628985587", "time_retrieved": "2024-07-30T19:06:21.147693", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Abstract Truchet Inversion \n    8/14/21 @byt3_m3chanic\n\n    (mouseable)\n    \n    suggest music to play (since soundcloud isnt working in shader)\n    https://soundcloud.com/relapserecords/07-survive-low-fog\n*/\nfloat offset[3] = float[]( 0.01, 1.75, 4.95 );\nfloat weight[3] = float[]( 0.2, 0.35, 0.075 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 C = texture(iChannel0, uv).rgb;\n    vec3 R = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n      R += texture(iChannel0, uv + vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n      R += texture(iChannel0, uv - vec2(offset[i])/iResolution.xy, 0.0).rgb * weight[i];\n    }\n    \n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*.32;\n    dt = smoothstep(0.82,.965,1.-dt);\n    vec3 Color = mix(R,C,dt);\n    \n    // output\n    Color=pow(Color, vec3(.4545));\n    fragColor = vec4(Color,1.);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Playing with some abstract forms and shapes\n    Standard truchet patten in 3d (grid) and\n    then warped nothing too exciting\n    \n    8/14/21 @byt3_m3chanic\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    20.00\n#define MIN_DIST    0.001\n#define SCALE       0.6500\n\n//utils\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//globals\nvec3 hit,hitP1,sid,id;\nfloat glow,speed;\nmat2 t90;\n\n//@iq torus sdf\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n//make tile piece\nfloat truchet(vec3 p,vec3 x, vec2 r) {\n    return min(torus(p-x,r),torus(p+x,r));\n}\n\n//const\nconst float size = 1./SCALE;\nconst float hlf = size/2.;\nconst float dbl = 1./size;\nconst float shorten = 1.26;  \n\n//domain rep\nvec3 drep(inout vec3 p) {\n    vec3 id=floor((p+hlf)/size);\n    p = mod(p+hlf,size)-hlf;\n    return id;\n}\n\nvec2 map(vec3 q3, float gw){\n    vec2 res = vec2(100.,0.);\n\n    float k = 5.0/dot(q3,q3); \n    q3 *= k;\n\n    q3.z += speed*.4;\n\n    vec3 qm = q3;\n    vec3 qd = q3+hlf;\n    qd.zy*=t90;\n    vec3 qid=drep(qm);\n    vec3 did=drep(qd);\n    \n    float ht = hash21(qid.xy+qid.z);\n    float hy = hash21(did.xz+did.y);\n    \n    // truchet build parts\n    float thx = (.0750+.0475*sin(T+(q3.x+qid.z)*5.25) ) *size;\n    float thz = (.0115+.0325*sin(T*3.+(q3.x+did.z)*6.5) ) *size;\n    float thd = (.0515+.0325*sin(T*3.+(q3.x+did.z)*6.5) ) *size;\n    if(ht>.5) qm.x *= -1.;\n    if(hy>.5) qd.x *= -1.;\n    \n    // ring movement\n    float dir = mod(did.x+did.y,2.)<.5? -1. : 1.;\n    if(mod(did.z,2.)<1.)dir*=-1.;\n    vec2 d2 = vec2(length(qd-hlf), length(qd+hlf));  \n    \n    vec2 pp = d2.x<d2.y? vec2(qd - hlf) : vec2(qd + hlf);\n    pp *= rot(speed*dir);\n    \n    float a = atan(pp.y, pp.x);\n    float amt = 6.;\n    a = (floor(a/PI2*amt) + .5)/amt;\n\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= hlf;\n    vec3 npos = vec3(qr.x,qr.y,qd.z);\n\n    //truchets1\n    float t = truchet(qm,vec3(hlf,hlf,.0),vec2(hlf,thx));\n    if(t<res.x) {\n        sid = qid;\n        hit = qm;\n        res = vec2(t,2.);\n    }\n    //truchets2\n    float d = truchet(qd,vec3(hlf,hlf,.0),vec2(hlf,thz));\n    if(d<res.x) {\n        sid = did;\n        hit = qd;\n        res = vec2(d,1.);\n    }\n    //rings\n    float f = truchet(npos.xzy,vec3(.0,0,0),vec2(thd,.025));\n    f=max(f,-(d-.01));\n    if(f<res.x) {\n        sid = did;\n        hit = qd;\n        res = vec2(f,3.);\n    }\n    //glows\n    if (gw==1.) glow += smoothstep(.1,.25,.002/(.0165+f*f)); \n\n    float mul = 1.0/k;\n    res.x = res.x * mul / shorten;\n    \n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec3 FC= vec3(.001,.001,.001);\nvec3 gcolor = vec3(0.145,0.659,0.914);\nvec3 lpos = vec3(.0,.001,3.85);\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, inout float d) {\n    vec3 C = vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    \n    for(int i=0;i<120;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p,1.);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.35: ray.x*.95;\n        m  = ray.y;\n    } \n    hitP1 = hit;\n    id = sid;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST) {\n    \n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 12.);\n        fresnel = mix(.01, 1., fresnel);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 12.; ){\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 24.);\n\n        if(m==1.) {\n            vec3 hp = hitP1/(1./SCALE);\n            float dir = mod(id.x + id.y,2.) * 2. - 1.;  \n            vec2 uv = hp.xy-sign(hp.x+hp.y+.001)*.5;\n            float angle = atan(uv.x, uv.y);\n            float a = sin(dir*angle*4.+T*1.25);\n            a = abs(abs(abs(a)-.5)-.24)-.124;\n            h = mix(gcolor, gcolor*.2, smoothstep(.01, .02, a));   \n            ref = h-fresnel;\n        }\n\n        if(m==2.) {\n            vec3 hp = hitP1/(1./SCALE);\n            float dir = mod(id.x + id.y,2.) * 2. - 1.;  \n            if(mod(id.z,2.)<1.)dir*=-1.;\n            vec2 uv = hp.xy-sign(hp.x+hp.y+.001)*.5;\n            float angle = atan(uv.x, uv.y);\n            float a = sin(dir*angle*8.+T*0.5);\n            a = abs(abs(abs(abs(a)-.75)-.5)-.25)-.06;\n            h = mix( vec3(.01), vec3(0.400,0.761,0.941) , smoothstep(.02, .01, a)); //vec3(0.400,0.761,0.941)\n            ref = h-fresnel;\n        }\n        if(m==3.) {\n            h = vec3(0.906,0.757,0.894); \n            ref = vec3(.0);\n        }\n        \n        C = diff*h+spec;\n        C = mix(FC.rgb,C,  exp(-.375*d*d*d));\n    \n        ro = p+n*.002;\n        rd = reflect(rd,n);\n        \n    } else {\n        C = FC.rgb;\n    }\n     \n    return vec3(C);\n}\n\nvoid topLayer(inout vec3 C, vec2 uv, float alpha) \n{\n    float px = fwidth(uv.x);\n    float md = mod(T*.1,2.);\n    float zw = md<1.? 2.: 1.25*sin(fract(T*.1));\n    float d = length(uv)-zw;\n    d=abs(d)-.002;\n    d=smoothstep(px,-px,d);\n    C =mix(C,gcolor,d);   \n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    t90 = rot(90.*PI/180.);\n    speed = T*.35;\n    FC = (texture(iChannel0,F.xy/R.xy).rgb)*.9;\n    gcolor = vec3(0.145,0.659,0.914);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,3.25);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? -.005 : -(M.y/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ? 0.015 : -(M.x/R.x * .25 - .125) * PI;\n    \n    mat2 rx = rot(x);\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0);\n    \n    float glowMask =0.;\n    float d =0.;\n\n    C = render(ro, rd, ref, d).rgb;\n\n\n    vec3 gcolor = vec3(0.145,0.659,0.914);\n\n    glowMask = clamp(glow,.0,1.);\n    C = mix(C,gcolor*glow,glowMask);\n    \n    float vw = .5+.5*sin(uv.x*.075+T*.3);\n    float fade = clamp((d*.045)+vw,0.,1.);\n    fade=abs(abs(fade)-.005)-.001;\n    C = mix(C,gcolor,smoothstep(.11,.1,fade)); \n    \n    topLayer(C,uv,d);\n    C = clamp(C,vec3(0),vec3(1));\n    O = vec4(C,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljXWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[405, 405, 462, 462, 1056]]}
{"id": "7t2XDd", "name": "3D Barycentric Interpolation", "author": "Sambi", "description": "Uses barycentric coords to map the coordinates of a 2x2 unit cube onto an arbitrary convex irregular cube. The values of this regular unit cube are then used to colour the irregular cube. Could be seen as inverse trilinear interpolation.", "tags": ["raymarch", "sdf", "barycentric", "lerp", "trilinear", "interpolation"], "likes": 0, "viewed": 468, "published": 3, "date": "1628972889", "time_retrieved": "2024-07-30T19:06:21.896690", "image_code": "#define ROT rotationMatrix(vec3(1.0, 0.0, 0.0), iTime * 0.5)\n\n// define the unit 2x2 cube centred on the origin by 8 corners.\n#define uT0 vec3(-1.0, 1.0, -1.0)\n#define uT1 vec3(1.0, 1.0, -1.0)\n#define uT2 vec3(1.0, 1.0, 1.0)\n#define uT3 vec3(-1.0, 1.0, 1.0)\n#define uB0 vec3(-1.0, -1.0, -1.0)\n#define uB1 vec3(1.0, -1.0, -1.0)\n#define uB2 vec3(1.0, -1.0, 1.0)\n#define uB3 vec3(-1.0, -1.0, 1.0)\n\n// deform the unit cube. this is what we'll raymarch, and we'll map positions back onto the\n// unit cube to determine colour using barycentric coordinates.\n#define T0 (ROT * vec4(uT0, 1.0) + vec4(sin(iTime), 0.0, cos(iTime), 0.0) * 0.5).xyz\n#define T1 (ROT * vec4(uT1, 1.0) + vec4(0.0, sin(iTime), cos(iTime), 0.0) * 0.5).xyz\n#define T2 (ROT * vec4(uT2, 1.0) + vec4(cos(iTime), sin(iTime), 0.0, 0.0) * 0.5).xyz\n#define T3 (ROT * vec4(uT3, 1.0) + vec4(0.0, 0.0, 0.0, 0.0) * 0.5).xyz\n#define B0 (ROT * vec4(uB0, 1.0) + vec4(cos(iTime), sin(iTime), 0.0, 0.0) * 0.5).xyz\n#define B1 (ROT * vec4(uB1, 1.0) + vec4(0.0, 0.0, 0.0, 0.0) * 0.5).xyz\n#define B2 (ROT * vec4(uB2, 1.0) + vec4(sin(iTime), 0.0, cos(iTime), 0.0) * 0.5).xyz\n#define B3 (ROT * vec4(uB3, 1.0) + vec4(0.0, sin(iTime), cos(iTime), 0.0) * 0.5).xyz\n\nstruct Tetrahedra\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n};\n\nTetrahedra uTet[5];\nTetrahedra tet[5];\nint numTet = 5;\n\n// Utils ------------------------------------------------------------------\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// SDF ------------------------------------------------------------------\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdTri( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 sdf(in vec3 pos)\n{\n    vec4 res = vec4(1e10, 0.0, 0.0, 0.0);\n    for (int i = 0; i < numTet; i++)\n    {\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p1, tet[i].p2), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p2, tet[i].p3), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p0, tet[i].p3, tet[i].p1), 0.0, 0.0, 0.0));\n        res = opU(res, vec4(sdTri(pos, tet[i].p1, tet[i].p3, tet[i].p2), 0.0, 0.0, 0.0));\n    }    \n    return res;\n}\n\n// Interpolation ------------------------------------------------------------------\n\n// calculate barycentric coordinates from the 4 tetrahedron verts.\nvec4 bary(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 vap = p - a;\n    vec3 vbp = p - b;\n    vec3 vab = b - a;\n    vec3 vac = c - a;\n    vec3 vad = d - a;\n    vec3 vbc = c - b;\n    vec3 vbd = d - b;    \n    float v6 = 1.0 / dot(vab, cross(vac, vad));\n    float va6 = dot(vbp, cross(vbd, vbc)) * v6;\n    float vb6 = dot(vap, cross(vac, vad)) * v6;\n    float vc6 = dot(vap, cross(vad, vab)) * v6;\n    return vec4(va6, vb6, vc6, 1.0 - va6 - vb6 - vc6);\n}\n\n// calculate cartesian from barycentric coordinates using 4 tetrahedron verts. \nvec3 invBary(vec4 bary, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    vec3 ret = vec3(0.0);\n    ret.x = bary.x * a.x + bary.y * b.x + bary.z * c.x + bary.w * d.x;\n    ret.y = bary.x * a.y + bary.y * b.y + bary.z * c.y + bary.w * d.y;\n    ret.z = bary.x * a.z + bary.y * b.z + bary.z * c.z + bary.w * d.z;\n    return ret;\n}\n\n// map cartesian coordinate onto unit cube using barycentric coordinates.\nvec3 mapToUnitCube(vec3 pos)\n{\n    float highest = -999.9;\n    vec4 b = vec4(0.0);\n    int iT = -1;\n    \n    // determine which tetrahedron the point is closest to (if not inside)\n    // by finding the barycentric coords of each tetrahedron with the largest\n    // minimum.\n    for (int i = 0; i < tet.length(); i++)\n    {\n        vec4 bTest = bary(pos, tet[i].p0, tet[i].p1, tet[i].p2, tet[i].p3);\n        float low = min(min(min(bTest.x, bTest.y), bTest.z), bTest.w);\n        if (low >= 0.0)\n        {\n            // if all barycentric coords are positive, point is definitely within\n            // that tetrahedra.\n            b = bTest;\n            iT = i;\n            break;\n        }\n        else if (low > highest)\n        {\n            b = bTest;\n            highest = low;\n            iT = i;\n        }\n    }\n    // take the barycentric coords of point on the nearest tetrahedron, and\n    // convert back into cartesian coords using the corresponding unit tetrahedron.\n    return invBary(b, uTet[iT].p0, uTet[iT].p1, uTet[iT].p2, uTet[iT].p3);\n}\n\n// Rendering ------------------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    // background\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    \n    // raycast scene\n    float t = 0.0;\n    for(int i = 0; i < 90; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec4 h = sdf(p);        \n        if(h.x < (0.001 * t))\n        {\n            col = mapToUnitCube(p);\n            break;\n        }\n        t += h.x;\n        if (t > 7.0)\n            break;\n    }\n\treturn col;\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll)\n{\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,vec3(sin(roll),cos(roll),0.0)));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    // drag along x to show/hide tetrahedrons\n    vec2 m = iMouse.xy / iResolution.xy;\n    numTet = 5 - int(m.x * 6.0);\n    \n    // break the cube down into 5 tetrahedra\n    tet[0] = Tetrahedra(T1, B2, T3, B0); // centre\n    tet[1] = Tetrahedra(T0, T1, T3, B0); // t0\n    tet[2] = Tetrahedra(T2, T3, T1, B2); // t2\n    tet[3] = Tetrahedra(B1, B0, B2, T1); // b1\n    tet[4] = Tetrahedra(B3, B2, B0, T3); // b3\n    \n    // this is our unit tetrahedra we're mapping onto\n    uTet[0] = Tetrahedra(uT1, uB2, uT3, uB0); // centre\n    uTet[1] = Tetrahedra(uT0, uT1, uT3, uB0); // t0\n    uTet[2] = Tetrahedra(uT2, uT3, uT1, uB2); // t2\n    uTet[3] = Tetrahedra(uB1, uB0, uB2, uT1); // b1\n    uTet[4] = Tetrahedra(uB3, uB2, uB0, uT3); // b3\n\n    // camera\n    vec3 ro = vec3(5.0 * sin(iTime * 0.5), 2.0, 5.0 * cos(iTime * 0.5));\n    mat3 camMat = calcLookAtMatrix(ro, vec3(0.0, 0.0, 0.0), 0.0);\n    \n\t// view ray\n\tvec3 rd = normalize(camMat * vec3(p.xy, 2.0));\n\n    // render\n    fragColor = vec4(render(ro, rd), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2XDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1413, 1413, 1458, 1458, 2081], [2158, 2158, 2183, 2183, 2202], [2203, 2203, 2250, 2250, 2747], [2749, 2749, 2777, 2777, 2812], [2814, 2814, 2837, 2837, 3310], [3397, 3464, 3515, 3515, 3922], [3924, 4004, 4061, 4061, 4318], [4320, 4394, 4424, 4424, 5448], [5531, 5531, 5568, 5586, 5952], [5954, 5954, 6016, 6016, 6186], [6188, 6188, 6245, 6245, 7327]]}
{"id": "fs33Rr", "name": "[Nvoke 2021]  Ouate Zeu Feuque", "author": "totetmatt", "description": "Entry from Nvoke 2021.\nNo particular point, just wanted to step ahead and participate to something :)\nCompletly crapy code, not optimized or not correct use of fct, but yolo.\n", "tags": ["4k", "evoke", "nvoke"], "likes": 11, "viewed": 447, "published": 3, "date": "1628957736", "time_retrieved": "2024-07-30T19:06:22.647682", "image_code": "/*\n\nThanks the Shader Showdown Scene folks for all the fun ! \n*_ flopine, evvvvil, ps, wrighter, NuSan, yx, rimina, alien, anticore, monsieursoleil, cosamentale, aldroid, deancoderand and all other I forgot T_T _*\n\nThanks yx for the blossom !  \n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n  vec4 pframe = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    // Output to screen\n    fragColor = vec4(pframe.xyz/pframe.a,1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat box(vec3 p,vec3 b){\n    vec3 q=abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat diam(vec3 p,float s){\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*sqrt(1./3.33333);\n}\nvec3 op;\nfloat gidz;\nfloat gg;\n\nvec2 sdf(vec3 p){\n \n    vec3 opp=p;\n    p.z +=1.;\n    gidz= floor(p.z);\n    p.z = fract(p.z);\n    float l=1.;\n    p.xy*=rot(.785*gidz*.5);\n    p.x +=sin(gidz)*.5;\n    float g = 1.;\n    for(float i=0.;i<=4.;i++){\n        p =abs(p)-1.5;\n        p*=1.1;\n        p.xy*=rot(.785);\n        l*=1.1;\n        g = min(g,clamp(tan(p.x*10.2)*asin(sin(p.z*50.9)*.5)*sin(p.y*7.95),-.0,.6)/l);\n    }\n    vec3 ppp =p;\n    float ll = l;\n    float g2 = 1.;\n    float g3 = g;\n    for(float i=0.;i<=10.;i++){\n        ppp = abs(ppp)-vec3(.1,.2,.3);\n        ppp -= vec3(.1,10.,.4);\n        ppp.xyz = ppp.xzy;\n        ppp*=1.3;\n        ll*=1.3;\n        ppp.xy*=rot(-.3785*i);\n        ppp.xy = ppp.x < ppp.y ? ppp.yx:ppp.xy;\n        g2 = min(g2,sin(ppp.x)*sin(ppp.y)+cos(ppp.z)/ll);\n        g = min(g,g2+clamp(sin(ppp.x*10.2)*asin(sin(ppp.z*50.9)*.5)*tan(ppp.x*5.55-ppp.y*7.95),-.1,.6)/ll);\n        g3 = min(g3,clamp(sin(ppp.x*10.2)*asin(sin(ppp.z*50.9)*.5)*tan(ppp.x*5.55-ppp.y*7.95),-.05,.6)/ll);\n    \n    }\n    gg=g;\n    vec2 h;\n    h.x = max(box(p,vec3(1.,1.,1.+g*.1)),box(p,vec3(1.,1.,.97)));\n    h.x = abs(h.x)-.01;\n    h.y = 1.+g3;\n    op =p;\n    vec4 pp = vec4(p,1.);\n    for(float i=0.;i<=4.;i++){\n        pp.xyz =abs(pp.xyz)-.5;\n        h.x = max(h.x,-box(pp.xyz,vec3(.3)));\n        float li = .45*pp.a;\n        if(abs(pp.x)>li && abs(pp.y)>li) h.y = 2.;\n        if(abs(pp.y)>li && abs(pp.z)>li) h.y = 2.;\n        if(abs(pp.x)>li && abs(pp.z)>li) h.y=   2.;\n    }\n    h.x /=l;\n\n    vec2 t;\n    t.x = abs(length(opp.xy-vec2(-.25,.25))-.1)-.01;\n    t.y = 3.;\n    h=  t.x < h.x ? t:h;\n    return h;\n  \n}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(0.,.1,.2)));}\n\nvec2 nv=vec2(.00035,-.00035);\nvec3 norm(vec3 p){return normalize(\n                        nv.xyy*sdf(nv.xyy+p).x+\n                        nv.yxy*sdf(nv.yxy+p).x+\n                        nv.yyx*sdf(nv.yyx+p).x+\n                        nv.xxx*sdf(nv.xxx+p).x\n);}\n\nfloat focusDistance = .55;\nfloat blurAmount = 0.0050;\n\nvec2 hash22(vec2 p) {\n\tp = fract(p * vec2(6.159, 7.853));\n    p += dot(p.yx, p.xy +  vec2(35.511, 7.584));\n\treturn fract(vec2(p.x * p.y * 195.714, p.x * p.y * 174.78));\n}\nfloat ao(vec3 rp, vec3 n, float q){\n     return (sdf(rp+n*q).x/q);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    uv= (-iResolution.xy + 2.0*(gl_FragCoord.xy +  normalize(tan(hash22(uv+iTime))))) / iResolution.y;\n\n    vec3 col =vec3(.1);\n    vec3 ro = blurAmount*vec3(vec2(-0.1,-.2)-1.0 + 2.0*normalize(tan(hash22(vec2(iFrame)))) ,-0.2);\n    vec3 rt = vec3(0.,.5,10.0);\n    vec3 z = normalize(rt-ro);\n    vec3 x = cross(z,vec3(0.,-1.,0.));\n    vec3 y = cross(z,x);\n  \n    vec3 rd = normalize(mat3(x,y,z)*normalize(vec3(uv,1.1)*focusDistance - ro));\n    vec3 rp= ro;\n    vec3 light =vec3(3.,-3,-5.);\n\n    vec3 acc =vec3(0.);\n\n    float i;\n  for(i=0.;i<=128.;i++){\n      vec3 zcol = pal(gidz*.3);\n      vec2 d = sdf(rp);\n\n       if(d.y >=2. ){\n        if (d.y == 3.) {\n            acc += (1.-i/256.)*pal(gidz*.3)*max(0.001,exp(10.*-abs(d.x))/(100.-step(.9,sin(rp.z*100.))*95.));\n        } else {\n             acc += pal(gidz*.3)*max(0.001,exp(5.*-abs(d.x))/(15.+sin(rp.x*500.)*10.));\n        }\n            d.x = max(0.0005,abs(d.x));\n        }    \n\n        rp +=d.x *rd;\n        if(d.x <=0.0001){\n\n        vec3 n = norm(rp);\n\n        if(d.y < 1.01-fract(sin(length(rp)*100.+sin(atan(uv.x,uv.y))))*.05) zcol= vec3(.1);\n        col = zcol*max(dot(normalize(light-rp),n+fract(d.y)*.1),-0.1)+(1.-zcol)*.9*pow(max(dot(normalize(ro-rp),reflect(-normalize(light),n)),0.),8.);\n\n\n\n        float aot = ao(rp,n,.1)+ao(rp,n,5.5)+ao(rp,n,10.5);\n        col *= aot/i ;\n\n        break;\n     }\n  }\n  vec4 pframe = vec4(texture(iChannel0,fragCoord.xy/iResolution.xy));\n  col +=acc;\n\tcol +=pframe.xyz;\n   \n    \n\tfragColor = vec4(col,pframe.a+1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs33Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 248, 305, 355, 532]]}
{"id": "NdcGRr", "name": "ghost color on gradients (+dithe", "author": "FabriceNeyret2", "description": "A large grey gradient show steps because of the color channels quantization. \nhere, 1 (bottom) to 8 bits (top).\nIn addition, a luminance gradient on a color five ghost colors because steps are not at the same place.\nClick for dithering (with blue noise).", "tags": ["color", "quantization", "dithering", "artifacts", "8bits"], "likes": 9, "viewed": 365, "published": 3, "date": "1628953178", "time_retrieved": "2024-07-30T19:06:23.394684", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/iResolution.xy;\n    O  = vec4(.96,.98,1, 1);         // base color\n    O *= mix(.0,1., U.x );           // luminance gradient\n    \n    float n = ceil(exp2(8.*U.y));    // emulates 0-8bits with height\n    vec4  d = iMouse.z<=0. ? vec4(0) // click \n              : texelFetch(iChannel0,ivec2(u),0) - .5; // dithering\n    O = floor( O*n + d )/ n;         // quantized color\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 426]]}
{"id": "fd33zn", "name": "Saturday Torus", "author": "mrange", "description": "License CC0: Saturday Torus\nInspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n", "tags": ["torus", "bw"], "likes": 99, "viewed": 4281, "published": 3, "date": "1628948950", "time_retrieved": "2024-07-30T19:06:24.240423", "image_code": "// License CC0: Saturday Torus\n//  Inspired by: https://www.istockphoto.com/photo/black-and-white-stripes-projection-on-torus-gm488221403-39181884\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nfloat rayTorus(vec3 ro, vec3 rd, vec2 tor) {\n  float po = 1.0;\n\n  float Ra2 = tor.x*tor.x;\n  float ra2 = tor.y*tor.y;\n\n  float m = dot(ro,ro);\n  float n = dot(ro,rd);\n\n  // bounding sphere\n  {\n    float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n    if(h<0.0) return -1.0;\n    //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n  }\n\n  // find quartic equation\n  float k = (m - ra2 - Ra2)/2.0;\n  float k3 = n;\n  float k2 = n*n + Ra2*rd.z*rd.z + k;\n  float k1 = k*n + Ra2*ro.z*rd.z;\n  float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\n  #ifndef TORUS_REDUCE_PRECISION\n  // prevent |c1| from being too close to zero\n  if(abs(k3*(k3*k3 - k2) + k1) < 0.01)\n  {\n    po = -1.0;\n    float tmp=k1; k1=k3; k3=tmp;\n    k0 = 1.0/k0;\n    k1 = k1*k0;\n    k2 = k2*k0;\n    k3 = k3*k0;\n  }\n  #endif\n\n  float c2 = 2.0*k2 - 3.0*k3*k3;\n  float c1 = k3*(k3*k3 - k2) + k1;\n  float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n\n  c2 /= 3.0;\n  c1 *= 2.0;\n  c0 /= 3.0;\n\n  float Q = c2*c2 + c0;\n  float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n\n  float h = R*R - Q*Q*Q;\n  float z = 0.0;\n  if(h < 0.0) {\n    // 4 intersections\n    float sQ = sqrt(Q);\n    z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n  } else {\n    // 2 intersections\n    float sQ = pow(sqrt(h) + abs(R), 1.0/3.0);\n    z = sign(R)*abs(sQ + Q/sQ);\n  }\n  z = c2 - z;\n\n  float d1 = z   - 3.0*c2;\n  float d2 = z*z - 3.0*c0;\n  if(abs(d1) < 1.0e-4) {\n    if(d2 < 0.0) return -1.0;\n    d2 = sqrt(d2);\n  } else {\n    if(d1 < 0.0) return -1.0;\n    d1 = sqrt(d1/2.0);\n    d2 = c1/d1;\n  }\n\n  //----------------------------------\n\n  float result = 1e20;\n\n  h = d1*d1 - z + d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=t1;\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  h = d1*d1 - z - d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=min(result,t1);\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  return result;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nvec3 torusNormal(vec3 pos, vec2 tor) {\n  return normalize(pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nvec3 color(vec2 p, vec2 q) {\n  const float rdd = 2.0;\n  vec3 ro  = 1.*vec3(0., 0.75, -0.2);\n  vec3 la  = vec3(0.0, 0.0, 0.2);\n  vec3 up  = vec3(0.3, 0.0, 1.0);\n  vec3 lp1 = ro;\n  lp1.xy  *= ROT(0.85);\n  lp1.xz  *= ROT(-0.5);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  const vec2 tor = 0.55*vec2(1.0, 0.75);\n  float td    = rayTorus(ro, rd, tor);\n  vec3  tpos  = ro + rd*td;\n  vec3  tnor  = -torusNormal(tpos, tor);\n  vec3  tref  = reflect(rd, tnor);\n\n  vec3  ldif1 = lp1 - tpos;\n  float ldd1  = dot(ldif1, ldif1);\n  float ldl1  = sqrt(ldd1);\n  vec3  ld1   = ldif1/ldl1;\n  vec3  sro   = tpos+0.05*tnor;\n  float sd    = rayTorus(sro, ld1, tor);\n  vec3  spos  = sro+ld1*sd;\n  vec3  snor  = -torusNormal(spos, tor);\n\n  float dif1  = max(dot(tnor, ld1), 0.0);\n  float spe1  = pow(max(dot(tref, ld1), 0.0), 10.0);\n  float r     = length(tpos.xy);\n  float a     = atan(tpos.y, tpos.x)-PI*tpos.z/(r+0.5*abs(tpos.z))-TTIME/45.0;\n  float s     = mix(0.05, 0.5, tanh_approx(2.0*abs(td-0.75)));\n  vec3  bcol0 = vec3(0.3);  \n  vec3  bcol1 = vec3(0.025);  \n  vec3  tcol  = mix(bcol0, bcol1, smoothstep(-s, s, sin(9.0*a)));\n\n  vec3 col = vec3(0.0);\n\n  if (td > -1.0) {\n    col += tcol*mix(0.2, 1.0, dif1/ldd1)+0.25*spe1;\n    col *= sqrt(abs(dot(rd, tnor)));\n  }\n  \n  if (sd < ldl1) {\n    col *= mix(1.0, 0.0, pow(abs(dot(ld1, snor)), 3.0*tanh_approx(sd)));\n  }\n\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p, q);\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd33zn.jpg", "access": "api", "license": "cc0-1.0", "functions": [[394, 485, 529, 529, 2587], [2589, 2680, 2718, 2718, 2806], [2808, 2868, 2896, 2962, 3038], [3040, 3040, 3068, 3068, 4519], [4521, 4604, 4640, 4640, 4873], [4875, 4875, 4932, 4932, 5117]]}
{"id": "Nsc3Rn", "name": "Hyperbolic checkerboard", "author": "kaihagseth", "description": "Checkerpattern in hyperbolic space", "tags": ["hyperbolicgeometry"], "likes": 4, "viewed": 303, "published": 3, "date": "1628945701", "time_retrieved": "2024-07-30T19:06:24.990418", "image_code": "float checker(in vec2 st)\n{\n  const float checkSize = 3.0;\n  vec2 tile = abs( mod(checkSize * st, 2.) - 1.);\n  tile = smoothstep( checkSize*length(fwidth(st)),0.,tile-.5);\n  tile = tile*2.-1.;\n  return tile.x*tile.y *.5 + .5;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set coordinate system from -1.5 to 1.5 on y-axis\n    // dist 1.0 is where distance will go to infinite in hyperbolic space.\n    vec2 uv = 1. * ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    uv = rotate2d(iTime/5.) * uv;\n    \n    //Transfrom to hyperbolic space.\n    if (length(uv) > .5) {\n        fragColor = vec4(vec3(1),1.);\n        return;\n    }\n    uv /=  (1. / (length(uv) + .5) ) - 1.;\n    uv += vec2(iTime, 2.*sin(iTime/3.));\n    fragColor = vec4(vec3(checker(uv)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsc3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 227], [229, 229, 257, 257, 343], [346, 346, 403, 534, 897]]}
{"id": "ft2SWt", "name": "Zeno's dominoes", "author": "xjorma", "description": "Doing this shader reminded me the Zeno's paradox.\nhttps://en.wikipedia.org/wiki/Zeno%27s_paradoxes", "tags": ["reflection", "zoom", "spiral", "loop", "infinite", "dominoes", "cineshader", "domino", "dominos", "zeno"], "likes": 25, "viewed": 5974, "published": 3, "date": "1628908579", "time_retrieved": "2024-07-30T19:06:25.741410", "image_code": "// Created by David Gallardo - xjorma/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define NO_UNROLL min(iFrame, 0)\n\nconst int nbPoints = 150;\nconst int pointsPerTurn = 30;\nconst float turnDuration = 3.0;\nconst float finalAngle = 1.19;\n\nconst float PI = radians(180.0);\n\nconst float maxDist = 10000.0;\n\nconst vec3 lightDir = normalize(vec3(0.4, 1.f, 0.7)); \nconst vec3 dominoSize = vec3(0.075, 0.4, 0.2);\n\nfloat smoothsteplin(in float edge0, in float edge1, in float x)\n{\n    return clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n}\n\nvec3 dominoColor(float v)\n{\n    vec3 col = vec3(sin(v * 0.43 + 2.85), sin(v * 0.63 + 1.28), sin(v * 0.81 + 4.71)) * 0.5 + 0.5;\n    return col / max(col.x, max(col.y, col.z));\n}\n\nfloat floorIntersect(in vec3 ro, in vec3 rd)\n{\n    if (rd.y < -0.01)\n    {\n        return ro.y / -rd.y;\n    }\n    return maxDist;\n}\n\n// Hash from Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nint dotsMask( in float v )\n{\n    int mask[6] = int[](16, 68, 84, 325, 341, 455);\n    return mask[int(hash11(v) * 6.0)];\n}\n\n\n// Box intersection by IQ https://iquilezles.org/articles/boxfunctions\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nvec3 getSkyColor(in vec3 rd)\n{\n    vec3 blue = smoothstep(.2, 1., rd.y) * vec3(0, 0, .5);\n    float nDotL = clamp(dot(rd, lightDir), 0., 1.);\n    vec3 highlight = vec3(pow(nDotL, 100.) * 2.0);\n    return vec3(blue + highlight);\n}\n\nfloat rayTrace(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color)\n{\n    float t = iTime;\n    float fltime = floor(t / turnDuration);\n    float frtime = fract(t / turnDuration);\n    float globalscale = 1.0 / (pow(0.5, 1.0 + frtime) * 2.0);\n    int domino = int(floor(float(pointsPerTurn) * frtime));\n    \n    float dist = floorIntersect(ro, rd);\n    if(dist < maxDist)\n    {\n        normal = vec3(0,1,0);\n        color = vec3(0.5);\n    }\n    \n    int hitDominoIte = -1;\n    vec3 hitDominoNormal;\n    mat4 hitDominoMatrix;\n    float hitDominoScale;\n\n    for(int i = domino + NO_UNROLL; i < nbPoints + domino; i++)\n    {\n        float turn = float(i) / float(pointsPerTurn);\n        float theta = 2.0 * PI * turn;\n        float phi = smoothsteplin((float(i) - 3.6) / float(pointsPerTurn), (float(i) + 1.0 + 0.5) / float(pointsPerTurn), frtime + 2.0) * finalAngle;\n        float fadeScale = smoothsteplin(float(i) - 4.0, float(i) + 1.0, frtime * float(pointsPerTurn) + (float(nbPoints) - 5.0));\n        float scale = pow(0.5, 1.0 + turn) * 2.0 * globalscale;\n        vec3 pos = vec3(cos(theta), 0, sin(theta)) * scale;\n        vec3 dir = vec3(-sin(theta) * cos(phi), -sin(phi), cos(theta) * cos(phi));\n        vec3 up = vec3(-sin(theta) * sin(phi), cos(phi), cos(theta) * sin(phi));\n        \n        vec3 size = dominoSize * scale * fadeScale * 0.5;\n        \n        \n        vec3 x = dir;\n        vec3 y = up;\n        vec3 z = cross(x, y);\n        mat4 r = mat4(\n        x.x,\t\ty.x,\t\tz.x,         0,\n        x.y,\t\ty.y,\t\tz.y,         0,\n        x.z,\t\ty.z,\t\tz.z,         0,\n        size.x,\t    -size.y,\t0,           1.0 );\n\n        mat4 t = mat4(\n        1.0,\t\t0.0,\t\t0.0,         0.0,\n        0.0,\t\t1.0,\t\t0.0,         0.0,\n        0.0,\t\t0.0,\t\t1.0,         0.0,\n        -pos.x,\t-pos.y,\t-pos.z,     1.0 );\n        \n        mat4 tr = r * t;\n        \n        vec3 n;\n        vec2 bi = boxIntersection( (tr * vec4(ro, 1)).xyz , (tr * vec4(rd, 0)).xyz, size, n);\n        if(bi.x > 0.0 && bi.x < dist)\n        {\n            dist = bi.x;\n            hitDominoIte = i;\n            hitDominoNormal = n;\n            hitDominoMatrix = tr;\n            hitDominoScale = scale;\n        }\n    }\n    if(hitDominoIte >= 0)\n    {\n        float dominoId = float(hitDominoIte) + fltime * float(pointsPerTurn);\n        color =  dominoColor(dominoId);\n        normal = (inverse(hitDominoMatrix) * vec4(hitDominoNormal, 0)).xyz;\n        // Dots\n        int msk;\n        vec2 p = (hitDominoMatrix * vec4((ro + dist * rd), 1)).zy / hitDominoScale;\n        if(p.y < 0.0)\n        {\n            msk = dotsMask(dominoId);\n            p.y += dominoSize.y * 0.25;\n        }\n        else\n        {\n            msk = dotsMask(dominoId + 1.0);\n            p.y -= dominoSize.y * 0.25;\n        }\n        for(int k = 0; k < 3; k++)\n        {\n            for(int l = 0; l < 3; l++)\n            {\n                float m = float(msk & (1 << (k * 3 + l)));\n                color *= max(1.0 - m, smoothstep(0.015, 0.016, distance(p, vec2(float(k - 1) * 0.050, float(l - 1) * 0.050))));\n            }\n        }\n    }\n    return dist;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 n, c;\n    float d = rayTrace(ro, rd, n, c);\n    \n    if(d < maxDist)\n    {\n        vec3 pos = ro + d * rd;\n        // Shadow\n        vec3 sc, sn;\n        float sd = rayTrace(pos + lightDir * 0.00001, lightDir, sn, sc);\n        float sh = 1.0;\n        if(sd < maxDist)\n        {\n            sh = 0.0;\n        }\n        // Reflection\n        vec3 refdir = reflect(rd, n);\n        vec3 rc, rn;\n        float rd = rayTrace(pos + refdir * 0.00001, refdir, rn, rc);\n        vec3 refcol = getSkyColor(refdir);\n        if(rd < maxDist)\n        {\n            refcol = rc * (max(0.0, dot(rn, lightDir)));\n        }\n        return c * (max(0.0, dot(n, lightDir)) * sh + 0.5) + refcol * 0.5;\n    }\n    return vec3(0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera        \n    float theta\t= radians(0.0); //radians(360.) * (iMouse.x/iResolution.x-0.5); // + iTime*.2;\n    float phi\t= radians(-20.0); //radians(70.) * (iMouse.y/iResolution.y-0.5) - radians(60.);\n    vec3 ro = 0.45 * vec3( sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n    vec3 ta = vec3( 0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta );\n    vec3 rd =  ca*normalize(vec3(p,1.5));        \n    vec3 col = render(ro ,rd);  \n    col = pow(col, vec3(1. / 2.2));\n    col = vignette(col, fragCoord / iResolution.xy, 0.6);\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2SWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[436, 436, 501, 501, 564], [566, 566, 593, 593, 742], [744, 744, 790, 790, 875], [877, 941, 964, 964, 1049], [1175, 1246, 1321, 1321, 1699], [1701, 1701, 1731, 1731, 1930], [5027, 5027, 5064, 5064, 5781], [5783, 5783, 5825, 5825, 5989], [5992, 5992, 6036, 6036, 6135], [6137, 6137, 6194, 6194, 6859]]}
{"id": "stjSDt", "name": "Fire Using Noise", "author": "Peace", "description": "Simple fire shader", "tags": ["fire"], "likes": 6, "viewed": 392, "published": 3, "date": "1628908079", "time_retrieved": "2024-07-30T19:06:26.576178", "image_code": "float hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 n) {\n    vec2 b = floor(n), f = smoothstep(vec2(0), vec2(1), fract(n));\n    return mix(mix(hash12(b), hash12(b + vec2(1, 0)), f.x), mix(hash12(b + vec2(0, 1)), hash12(b + vec2(1)), f.x), f.y);\n}\n\nfloat fbm(vec2 p, int octaves) {\n\tfloat s = 0.0, m = 0.0, a = 1.0;\n\tfor(int i = 0; i < octaves; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= 0.5;\n\t\tp *= mat2(1.6, 1.2, -1.2, 1.6);\n\t}\n\treturn s / m;\n}\n\nvec3 get_fire_color(float v) {\n    return vec3(smoothstep(0.0, 0.6, v), smoothstep(0.0, 1.0, v), smoothstep(0.65, 0.9, v) * .8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mr = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / mr;\n    float b = fbm(uv * 16.0 + vec2(uv.y * sin(iTime * 1.5) * 1.25, -iTime * 3.0), 4);\n    b += max(1.0 - uv.y * 2.5, -1.0);\n    b *= 0.6;\n    fragColor = vec4(get_fire_color(b), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 139], [141, 141, 162, 162, 352], [354, 354, 386, 386, 553], [555, 555, 585, 585, 685], [687, 687, 744, 744, 1010]]}
{"id": "fl2XDd", "name": "Tater @ Nevoke pre-jam", "author": "Tater", "description": "Shader I made during the Novoke pre-party shader jam. ", "tags": ["3d", "raymarching", "audioreactive", "jam", "livecode"], "likes": 12, "viewed": 538, "published": 3, "date": "1628896055", "time_retrieved": "2024-07-30T19:06:27.441864", "image_code": "#define STEPS 128.0\n#define MDIST 250.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\n#define lr 90.0\nvec3 gl = vec3(0);\nvec3 gl2 = vec3(0);\nvec2 path(float t){\n  return vec2(sin(t),cos(t));\n}\n\n\nvec2 map(vec3 p){\n  vec2 a = vec2(9999);\n  vec2 b = vec2(9999);\n  float t = mod(iTime,1000.0);\n  vec3 po = p;\n  \n  float ffti = pow(fract(t*2.0),2.0)+floor(t*2.0)+t*0.5;\n  ffti/=2.8;\n  float fft = texelFetch( iChannel0, ivec2(10,0), 0 ).x*0.008;\n  float fft2 = texelFetch( iChannel0, ivec2(200,0), 0 ).x*0.003;\n  \n  p.yz*=rot(-ffti*0.35);\n  float th = atan(p.y,p.z);\n  th*=80.0;\n  float r = length(p.yz)-lr;\n  p.y = r;\n  p.z = th;\n  \n  \n  //INNER SPIRAL\n  p.xy-=path(p.z*0.2)*4.0;\n  vec3 p2 = p;\n  p.xy*=rot(-p.z);\n  p.x = abs(p.x)-1.0;\n  b.x = length(p.xy)-0.5;\n  \n  b.y = 1.0;\n  a=(a.x<b.x)?a:b;\n  p = p2;\n  \n  \n  //MIDDLE SPIRAL\n  p.xy-=path(p.z*0.2)*min(3.0+fft*250.0,6.0);\n  vec3 p3 = p;\n  p.xy*=rot(sin(p.z));\n  p.xy = abs(p.xy)-1.4;\n  vec2 d2 = abs(p.xy)-1.0;\n  float cut = max(d2.x,d2.y);\n  p = p3;\n  b.x = length(p.xy)-1.0;\n  b.x = max(-cut,b.x);\n  \n  b.y = 2.0;\n  a=(a.x<b.x)?a:b;\n  \n  \n  //OUTER SPIRAL\n  p.xy-=path(p.z*0.2)*min(3.0+fft*250.0,6.0);\n  b.x = length(p.xy)-1.0;\n  gl2 +=0.1/(0.01+b.x*b.x)*vec3(0,0.1,1.0);\n  \n  b.y = 3.0;\n  a=(a.x<b.x)?a:b;\n  \n  \n  //OUTER BOXS TUBES\n  p = po; p.y = r;p.z = th;\n  p.xy*=rot(sin(p.z*0.0035)+sin(t));\n  p.xy = abs(p.xy)-20.0;\n  \n  for(float i = 0.0; i<4.0; i++){\n    p.xy = abs(p.xy)-1.5;\n    p.xy*=rot(p.z*0.1-t*2.0);\n  }\n  vec2 d = abs(p.xy)-1.0;\n  b.x = max(d.x,d.y);\n \n  b.y = 4.0;\n  a=(a.x<b.x)?a:b;\n  \n  \n  //LASERS\n  p = po; p.y = r;p.z = th;\n  p.xy = abs(p.xy)-20.0;\n  p.xy*=rot(pi/4.0);\n  p.xy = abs(p.xy)-5.0;;\n  b.x = length(p.xy);\n  gl+=0.1/(0.01+b.x*b.x)*vec3(0.0,1.0,0.5)*max(sin(p.z*0.05+t*10.0)*0.5+0.4,0.0);\n  \n  b.y = 0.0;\n  a=(a.x<b.x)?a:b;\n  \n  \n  //MIDDLE BALL THINGS\n  p = po;p.y = r;p.z = th;\n  p.xy*=rot(-t*5.0);\n  p.z = pmod(p.z,20.0);\n  p.yz*=rot(t*4.0);\n  p.yx*=rot(t*4.0);\n  p.xy = abs(p.xy)-1.5-fft2*300.0;\n  b.x = length(p)-0.5-fft*60.0;\n  gl+=(0.0004/(0.01+b.x*b.x))*vec3(0,1,1);\n  \n  b.y = 7.0;\n  a=(a.x<b.x)?a:b;\n  \n  \n  //BOX THINGYS\n  p = po;\n  p.y = r;\n  p.z-=5.0;\n  p.xy*=rot(-t*0.75);\n  p.xy*=rot(ffti);\n  p.xy = abs(p.xy)-6.0-fft2*1200.0;\n  //p.xy*=rot(pi/4.0);\n  \n  //p.xy = abs(p.xy);\n  p.xy*=rot(pi/4.0);\n  vec3 d3 = abs(p)-vec3(4.0,0.75,0.75);\n  b.x = max(d3.x,max(d3.y,d3.z));\n  \n  b.y = 9.0;\n  a=(a.x<b.x)?a:b;\n  return a;\n}\n//Anti-unroll normals (not live coded) \n#define ZERO (min(iFrame,0))\nvec3 norm(vec3 p){\n    \n   \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  float t = mod(iTime,1000.0);\n  uv*=rot(t*0.75);\n  vec3 col = vec3(0);\n  \n  vec3 ro = vec3(0,lr,0);\n  vec3 rd = normalize(vec3(uv,0.6));\n  \n  float shad, dO;\n  vec2 d;\n  vec3 p = ro;\n  bool hit = false;\n  float bnc = 0.0;\n  for(float i = 0.0; i<STEPS; i++){\n    p = ro+rd*dO;\n    d = map(p);\n    if(d.x>1.0)d.x = sqrt(d.x);\n    \n    \n    if(d.x<0.01){\n      if(d.y==7.0&&bnc==0.0){\n        vec3 n = norm(p);\n        ro = p+n*0.5;\n        rd = n;\n        dO = 0.0;\n        bnc = 1.0;\n      }\n      else{\n        if(d.y == 3.0){\n          d.x = 0.1;\n        }\n        else{\n          shad = i/STEPS;\n          hit = true;\n          break;\n        }\n    }\n    }\n    if(dO>MDIST){\n      p = ro+rd*MDIST;\n      break;\n    }\n    dO+=d.x*0.6;\n  }\n  vec3 al;\n  if(hit){\n    \n    vec3 n = norm(p);\n    vec3 ld = normalize(vec3(0.25,0.25,-1.0));\n    vec3 h = normalize(ld-rd);\n    float spec = pow(max(dot(n,h),0.0),20.0);\n    \n    shad = 1.0-shad;\n    shad = pow(shad,1.2);\n    col = vec3(shad);\n    if(d.y ==4.0) d.y = floor(mod(p.z*0.3,3.0))+1.0;\n    \n    if(d.y==1.0) al = mix(vec3(0.0,0.2,1.0),vec3(0,1.0,0.2),0.0);\n    if(d.y==2.0) al = vec3(0,0.5,0.5)*1.5;\n    if(d.y==3.0) al = mix(vec3(0.0,0.2,1.0),vec3(0,1.0,0.4),1.0);\n    if(d.y==7.0) al = vec3(0,1.0,1.0);\n    if(d.y==9.0) al = vec3(0.5,0.9,0);\n    col*=al;\n    col+=spec*0.3;\n  }\n  col = mix(col,vec3(0.05,0,0.15),dO/MDIST);\n  col+=gl*0.6;\n  col+=gl2*0.05;\n  col = pow(col,vec3(0.75));\n\tfragColor = vec4(col,0);\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[206, 206, 225, 225, 257], [260, 260, 277, 277, 2485], [2555, 2555, 2573, 2680, 2883], [2884, 2884, 2940, 2940, 4543]]}
{"id": "Nl2XDd", "name": "Nevoke ShaderJam", "author": "Alien01", "description": "Nevoke ShaderJam", "tags": ["shaderjam", "nevoke"], "likes": 6, "viewed": 299, "published": 3, "date": "1628894074", "time_retrieved": "2024-07-30T19:06:28.297576", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tfragColor = texture(iChannel0, uv);\n}\n\n//Hello, Nvoke!!!\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define one_bpm (60./117.)\n#define beat(a) tick(iTime / (one_bpm*a))\n#define cumbeat(a) iTime+beat(a)\n\nfloat tick(float t) {\n  return fract(t);\n}\n\nmat2 rot(float a) {return mat2( cos(a), sin(a), -sin(a), cos(a) ) ; }\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat box2(vec2 p, vec2 b){\n  vec2 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat torus(vec3 p, vec2 t){\n  float a = length(p.xz ) - t.x;\n  p.x += 2.*cumbeat(8.);\n  a += sin(p.z);\n  \n  vec2 q = vec2(a , p.y );\n  return length(q) - t.y;\n}\n\nfloat map(vec3 p) {\n  float final = 0.;\n  vec3 pp = p;\n  \n  if(beat(8.) < 0.5)\n    p.xy *= rot(0.1*cumbeat(16.));\n  if(beat(16.) < 0.5)\n    p.xy *= rot(-0.1*cumbeat(16.));\n  \n  float y = p.y - cumbeat(32.);\n  p.z -= 10.;\n  p.x *= atan(p.y, p.z);\n  \n  p.z -= 10.0;\n  p.xz *= vec2(0.1, 0.5);\n  \n  for(int i = 0; i < 4; i++){\n    final += box2(p.xz, vec2(5*i));\n    p.z -= 10. + beat(4.);\n    p.x *= 2.;\n    p.xz *= rot(0.2*float(i)*y);\n    p.z = cos(p.x * 2.0 +sin(p.z*2.0));\n    \n    if(beat(16.) < 0.8)\n      p.xz *= rot(0.8 - p.y);\n  }\n  \n  float denum = 22.;\n  if(beat(8.) < 0.5)\n    denum = 15.+beat(8.);\n  final = final / denum;\n  \n  pp.z += 15.;\n  \n  float sp = sphere(pp, 15. + beat(4.)) ;\n  final = min(final, sp);\n  \n  pp.xz *= rot(iTime*0.5);\n  pp.xz *= rot(2.6);\n  pp.xy *= rot(0.4);\n  \n  float tor = torus(pp, vec2(24., 2. + beat(8.)));;\n  \n  final = min(final, tor);\n  \n  return final;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n  float t = 0.;\n  float a;\n  int steps = 64;\n  if(beat(8.) < 0.2) steps = 32;\n  for(int i = 0; i < steps; i++){\n    a = map(ro+rd*t);\n    if(a < 0.01) break;\n    if(t > 100.) break;\n    t+=a;\n  }\n  \n  float ret = a;\n  if(beat(16.) < 0.1)\n    ret *= t/8.;\n  \n  return vec3(ret);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 uv1 = uv;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.);\n  \n  vec3 ro = vec3(0, 5, -55);\n  if(beat(16.) < 0.5) \n    ro.z = -75.;\n  vec3 rd = normalize(vec3(uv, 1));\n  \n  if(beat(32.) < 0.1)\n    rd.xy *= rot(0.2);\n \n  vec3 color = march(ro, rd);\n  color *= 1.75;\n \n if(beat(16.) < 0.5)\n    color *= vec3(0.8, 0.2, 0.3);\n  \n  if(beat(32.) < 0.5)\n    color = 1.-color;\n  \n  \n  bool mask;\n  float b = beat(64.);\n  if(b< 0.1)\n    mask =  uv1.x < 0.5;\n  else if(b < 0.2)\n    mask =  false;\n  else if(b < 0.3)\n    mask =  uv1.y < 0.5;\n  else if(b < 0.4)\n    mask = true;\n  else if(b < 0.5)\n  mask = length(uv) < 0.2 + beat(8.);  \n  else if(b < 0.6)\n    mask = false;\n  else if(b < 0.8)\n    mask = fract(uv.x * 10.*beat(8.)) < 0.5;\n  else if(b < 1.){\n    \n    uv *= rot(iTime);\n    uv = fract(uv*100.*beat(16.));\n    mask = uv.x < 0.5 && uv.y < 0.5; \n  }\n \n  \n  if(mask)\n    color = 1.-color;\n  \n  color = mix(color, texture(iChannel0, uv1).rgb, 0.9);\n  \n  fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 174]]}
{"id": "ftjXDd", "name": "Disco noise test", "author": "dimutch833", "description": "Test of noise", "tags": ["trash"], "likes": 1, "viewed": 198, "published": 3, "date": "1628889248", "time_retrieved": "2024-07-30T19:06:29.151293", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    // Time varying pixel color\n    vec3 col =vec3(noise(fragCoord),rand(vec2(iTime,2)),1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjXDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 87], [88, 88, 109, 109, 307], [310, 310, 367, 454, 572]]}
{"id": "7lSSWm", "name": "Non-Euclidean Shock Wave II", "author": "spr", "description": "Follows a geodesic path of rational points on a horocycle (turn on/off with space bar)\nIf laggy decrease N.\nYou can offset the path with the following controls.\na/z expand x-direction & contract y-direction\ns/x & f/v shear\nd/c rotate\n\n\n", "tags": ["lattice", "hyperbolic", "horocycle", "geodesicflow"], "likes": 5, "viewed": 427, "published": 3, "date": "1628861078", "time_retrieved": "2024-07-30T19:06:30.094770", "image_code": "/*\nNon-Euclidean shockwave (see also https://www.shadertoy.com/view/NtfSRr )\n\n\nN = 53 in \"Common\" can be decreased to increase performance.\n\nFun fact:\nTry rotating (\"d\") a bit periodically after 3 or so seconds to get an approximative closed orbit, that is, the vectors trace out a clear path.\n\n\nInitial points are are on a horocycle of height 1 with placement 0, 1/N, 2/N, ... looking downwards.\nIn hyperbolic coordinates the k-th point is at z = k/N + i (i = imaginary unit).\n\nEach point represents a two dimensional lattice in R^2 with covolume one (\"unimodular lattice\").\nIn this space, each point corresponds to the lattice with basis (column vectors) (1,0) (k/n,1).\n\nRight animation shows z-point together with the Voronoi cell associated to the lattice.\n\n\nAt each frame, we flow by multiplying (in \"Buffer A\") the lattice by the diagonal matrix with coefficients 1.005, 1/1.005.\nThis corresponds to pressing \"a\" every second frame.\n\nAfter a lattice reduction procedure (see https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm )\nthe basis of the lattice can be chosen such that (up to a rotation), the first basis vector is (1,0)\nand the second one is of length >=1 and has x-coord between -0.5 and 0.5.\nThis domain is represented by the hyperbolic triangle pictured in the shader.\n\n\nThe left and middle animation show the same simulation but follow a different numerical strategy.\nOn the left, at each frame the lattice reduction is applied \nand its result are saved to be used in the next frame (Buffer A). \nIn particular, the flow and user modification is applied to the reduced basis vectors.\nIn the middle, we save the (non-reduced) basis vectors in every frame and apply to it\nthe flow / user controls. Only then the lattice reduction is applied (\"Buffer B\") and hence \nthe whole calculation is redone in each frame.\n\n\nDepending on the user input, either left or the middle side will show the first floating point inaccuracy (presumably).\n(The first will \"diverge\" if we go forward and backwards a lot, keeping the initial basis vectors roughly unmodified but having many lattice reduction steps inbetween).\n(The second will diverge if we flow a long time so that the initial basis vectors get distorted a lot. Example: Rotate (\"d\") a bit in the beginning and waiting for a few seconds (platform dependent, 20sec deskop, 8sec mobile)).\n\n\n\n\n\n\nThe MIT License\nCopyright  2021 Ren Rhr\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\nconst int sample_range = 5; \nconst float point_size = 0.1;\nconst float line_thickness = 0.01;\nconst float infty = 10000.;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord-0.5*iResolution.xy)/pixel_per_unit;\n    fragColor = vec4(vec3(0),1);\n    float cusp_zoom = 1.; \n    vec2 resolution = vec2(iResolution.x, iResolution.y);\n    float scale = 10. / resolution.x;\n    vec2 uv = scale * fragCoord; \n    vec3 color = vec3(0);\n\nuv.x -=  1.;\nif(uv.x < 1. && uv.x > -1.){\nfor(int i = 0; i < N; ++i){\n\n    vec2 z = texelFetch( iChannel1, ivec2(0,i), 0 ).zw; // Height from Buffer B\n    float cusp_zoom = 1.;       // Used to zoom out in upper half plane, increase copies in the disk model, \n\n     vec2 dir = texelFetch( iChannel1, ivec2(0,i), 0 ).xy;    \n        \n        if(length(z-uv) < 0.3){\n            if(length(z-uv) < 0.02)\n                color = vec3(1);\n            else{\n                float arrow = sdArrow( uv*40., z*40., z*40.-.3*dir*40., 0.1, 1. );\n                arrow = arrow <= 0.1 ? 1. : 0.;\n                color +=vec3(arrow);     \n            }\n        }\n\n} \n    float line_width = max(0.01, cusp_zoom*0.01);\n    int num_translates = 0;\n    for(int j = -num_translates; j<=num_translates; ++j){\n        vec2 st = uv + vec2(j,0);\n            if( abs(abs(st.x)-0.5) < line_width && length(st) >= 1.) \n                color = vec3(1);\n            else if(abs(length(st)-1.) < line_width) \n                color = vec3(1);\n    }\n    fragColor = vec4(color,1.0);\n }\n    \n\nuv.x -=  2.;\nif(uv.x < 1. && uv.x > -1.){\nfor(int i = 0; i < N; ++i){\n\n    vec2 z = texelFetch( iChannel1, ivec2(1,i), 0 ).zw; // Height from Buffer B\n    float cusp_zoom = 1.;   \n    \n    vec2 dir = texelFetch( iChannel1, ivec2(1,i), 0 ).xy;    \n\n    if(length(z-uv) < 0.3){\n        if(length(z-uv) < 0.02)\n            color = vec3(1);\n        else{\n            float arrow = sdArrow( uv*40., z*40., z*40.-.3*dir*40., 0.1, 1. );\n            arrow = arrow <= 0.1 ? 1. : 0.;\n            color +=vec3(arrow);     \n        }\n    }\n\n} \n    float line_width = max(0.01, cusp_zoom*0.01);\n    int num_translates = 0;\n    for(int j = -num_translates; j<=num_translates; ++j){\n        vec2 st = uv + vec2(j,0);\n            if( abs(abs(st.x)-0.5) < line_width && length(st) >= 1.) \n                color = vec3(1);\n            else if(abs(length(st)-1.) < line_width) \n                color = vec3(1);\n    }\n    fragColor = vec4(color,1);\n}\n\n\ncolor = vec3(0);\nuv -=  vec2(4.5,-2.8);\n\nuv *= 0.3;\nif(uv.x < 1. && uv.x > -1.){\n    int count = 0; \nfor(int i = 0; i < N; ++i){\n    int range = 1; float cusp_zoom = 1.; float size = 0.1; \n    vec2 p1,p2;\n    float d1 = infty;\n    float d2 = infty;\n    mat2 lattice;\n    lattice[0] = texelFetch( iChannel0, ivec2(0,i), 0 ).xy; // Lattice after Reduction from Buffer A\n    lattice[1] = texelFetch( iChannel0, ivec2(0,i), 0 ).zw; // \n    vec2 z = texelFetch( iChannel1, ivec2(0,i), 0 ).zw; // Height from Buffer B\n    vec2 dir = texelFetch( iChannel1, ivec2(0,i), 0 ).xy;  \n        \n   \n    if(length(z-uv) < 0.5){\n        for(int x = -range; x<=range; ++x){\n        for(int y = -range; y<=range; ++y){              \n            vec2 point = size * ( lattice[0]*float(x) + lattice[1]*float(y) ) + z;\n            ClosestPoints(p1, p2, d1, d2, uv, point);\n        }}\n        if(length(uv-z)<=d1) { color +=vec3(float(i)*N_inv,1.-float(i)*N_inv,0); count++; }\n    }\n\n} \n    \n    fragColor = vec4(color,1);\n    \n    float line_width = 0.003;\n    int num_translates = 0;\n    for(int j = -num_translates; j<=num_translates; ++j){\n        vec2 st = uv + vec2(j,0);\n            if( abs(abs(st.x)-0.5) < line_width && length(st) >= 1.) \n                fragColor = vec4(1.0);\n            else if(abs(length(st)-1.) < line_width) \n                fragColor = vec4(1.0);\n    }\n    \n}\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int N = 53;\nconst float y_start = 5.;\nconst float y_end = 10.;\nfloat time_reset = 2. * log2(float(N)) + log2(y_start) + log2(y_end);\nconst float N_inv = 1. / float(N);\n\n\nconst float pixel_per_unit = 100.;\n\n\n\n\n\n//Transformations\nmat2 e(){\n    return mat2(1,0,0,1);\n}\n\nvoid Rotate(inout mat2 A, in float theta){\n    mat2 k = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    A = k*A;\n}\n\nvoid Shear(inout mat2 A, in float s){\n    mat2 u = mat2(1,s,0,1);\n    A= u*A;\n}\nvoid ShearOpposite(inout mat2 A, in float s){\n    mat2 u = mat2(1,0,s,1);\n    A= u*A;\n}\n\nvoid Dilate(inout mat2 A, in float t){\n    mat2 a = mat2(t,0,0,1./t);\n    A= a*A;\n}\n\n\nvoid kan(inout mat2 k, inout mat2 A, inout mat2 n, in mat2 g)\n{\n    float a=g[0][0], b=g[1][0], c=g[0][1], d=g[1][1];\n    float t= sqrt(a*a+c*c);\n   \n    k[0] = vec2(a,c); k[1] = vec2(-c,a); k = k / t;\n    A=mat2(t,0,0,1./t);\n    n=mat2(1,(a*b+c*d)/(t*t),0,1);\n}\n\n\nvoid sl2inverse(inout mat2 g){\n    mat2 h = g;\n    g[0][0] = h[1][1];\n    g[1][1] = h[0][0];\n    g[1][0] = -h[1][0];\n    g[0][1] = -h[0][1];\n}\n\nvoid MoebiusAti(in mat2 g, inout vec2 z){//z=i -> di-b / -ci+a\n    sl2inverse(g);\n    float a=g[0][0], b=g[1][0], c=g[0][1], d=g[1][1];\n    z = vec2(a*c+b*d,1) / (c*c+d*d);\n}\n\nvoid Moebius(in mat2 g, inout vec2 z){// z -> az+b / cz+d  for a,b,c,d real\n    float a=g[0][0], b=g[1][0], c=g[0][1], d=g[1][1];\n    float x = a*c*dot(z,z)+b*d + (a*d+b*c)*z.x;\n    float y = z.y;\n    float denom = (c*c*dot(z,z)+d*d+2.*d*c*z.x);\n    z = vec2(x,y) / denom;\n    }\n    \n\nvoid ToHalfplane(inout vec2 z){// z -> -iz-i / z-1\n    float x=z[0], y=z[1];\n    float denom = x*x + y*y + 1. - 2.*x;\n    z = vec2(-2.*y, -x*x-y*y+1.) / denom;\n}\n\nvoid CircleInversion(inout vec2 z)\n{\n\tz.x = -z.x;\n\tz /= dot(z,z);\n}\n\nvoid HorizontalTranslation(inout vec2 z)\n{\n\tz.x = mod(z.x+0.5, 1.)-0.5;\n}\n\n\n\n\n//Lattice Reduction\n\nvoid WeakReduce(inout mat2 A, inout mat2 gamma){\n    float mu = round( dot(A[0], A[1]) / dot(A[0],A[0]) );\n    A[1] -= mu * A[0];\n    mat2 u = mat2(1,-mu,0,1);\n    gamma = gamma*u;\n}\n\nvoid GramSchmidt(inout mat2 A){\n    float mu = dot(A[0], A[1]) / dot(A[0],A[0]);\n    A[1] -= mu * A[0];\n}\n\nvoid SwapColumns(inout mat2 A, inout mat2 gamma){\n     mat2 B = A;\n     A[0] = -B[1]; A[1] = B[0];\n     mat2 w = mat2(0,-1,1,0);\n     gamma = gamma*w;\n}\n\nbool IsReduced(in mat2 A){\n    GramSchmidt(A);\n    return dot(A[0],A[0]) <=  4./3. * dot(A[1],A[1]);\n}\n\n\nvoid LLL(inout mat2 A, inout mat2 gamma){ //Lattice Reduction Algorithm\n    WeakReduce(A, gamma);\n    while(!IsReduced(A)){\n        SwapColumns(A, gamma);\n        WeakReduce(A, gamma);\n    }   \n}\n\n#define bug_fix 0.00001\nvoid MakeShorter(inout mat2 A, inout mat2 gamma){ // Tries to find a shorter basis using at most one step.\n    if(dot(A[0],A[0]) > dot(A[1],A[1])+bug_fix) {\n        SwapColumns(A, gamma); \n        return;}    \n    mat2 B = A, C = A;\n    B[1] -=  B[0];\n    if(dot(A[1],A[1]) > dot(B[1],B[1])){ \n        A = B; \n        gamma = gamma*mat2(1,-1,0,1);\n        return;}\n    C[1] +=  C[0];\n    if(dot(A[1],A[1]) > dot(C[1],C[1])){\n        A = C;\n        gamma = gamma*mat2(1,1,0,1);\n        return;}\n}\n\n\n\n\nfloat DrawCircle(in vec2 uv, float radius){\n    return abs(length(uv)-radius) < 0.01 ? 1. : 0.;\n}\n\n\n\n\n\n\n\n\n\nvoid DrawPoint(inout vec3 color_out, in vec3 color_in, in vec2 pixel, in vec2 center, in float radius){\n    vec2 point = pixel-center;\n    if( dot(point, point) <= radius*radius){\n        color_out = color_in;\n    }\n}\n\n//Checks if \"point\" is closer to \"pixel\" compared to the currently closest points p1,p2.\nvoid ClosestPoints(inout vec2 p1, inout vec2 p2, inout float d1, inout float d2, in vec2 pixel, in vec2 point){\n    float d = distance(pixel, point);\n    if(d < d2){\n        if(d<d1){\n            d1 = d;\n            p1 = point;\n        }else{\n            d2 = d;\n            p2 = point;\n        }\n    }\n}\n\n\nbool ClosestPointsCount(inout vec2 p1, inout vec2 p2, inout float d1, inout float d2, in vec2 pixel, in vec2 point){\n    float d = distance(pixel, point);\n    if(d < d2){\n        if(d<d1){\n            d1 = d;\n            p1 = point;\n        }else{\n            d2 = d;\n            p2 = point;\n        }\n        return true;\n    }\n    return false;\n}\n\n\n\n\n// https://www.shadertoy.com/view/slj3Dd\n// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Distance to an arrow\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat sdArrow( in vec2 p, vec2 a, vec2 b, float w1, float w2 )\n{\n    const float k = 3.0;   // arrow head ratio\n\tvec2  ba = b - a;\n    float l2 = dot(ba,ba);\n    float l = sqrt(l2);\n\n    // pixel setup\n    p = p-a;\n    p = mat2(ba.x,-ba.y,ba.y,ba.x)*p/l;\n    p.y = abs(p.y);\n    vec2 pz = p-vec2(l-w2*k,w2);\n\n    // === distance (four segments) === \n\n    vec2 q = p;\n    q.x -= clamp( q.x, 0.0, l-w2*k );\n    q.y -= w1;\n    float di = dot(q,q);\n    //----\n    q = pz;\n    q.y -= clamp( q.y, w1-w2, 0.0 );\n    di = min( di, dot(q,q) );\n    //----\n    if( p.x<w1 ) // conditional is optional\n    {\n    q = p;\n    q.y -= clamp( q.y, 0.0, w1 );\n    di = min( di, dot(q,q) );\n    }\n    //----\n    if( pz.x>0.0 ) // conditional is optional\n    {\n    q = pz;\n    q -= vec2(k,-1.0)*clamp( (q.x*k-q.y)/(k*k+1.0), 0.0, w2 );\n    di = min( di, dot(q,q) );\n    }\n    \n    // === sign === \n    \n    float si = 1.0;\n    float z = l - p.x;\n    if( min(p.x,z)>0.0 ) //if( p.x>0.0 && z>0.0 )\n    {\n      float h = (pz.x<0.0) ? w1 : z/k;\n      if( p.y<h ) si = -1.0;\n    }\n    return si*sqrt(di);\n}\n\n", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0,0.0,0.0,1.0);\n    \n    \n    ivec2 st = ivec2(fragCoord);\n    if( (st.s == 0 || st.s == 1 )  && st.t < N  ){\n        mat2 current = e();\n        \n        if(iFrame < 1){\n            //Dilate(lattice, 0.6);\n            ShearOpposite(current, float(st.t) * N_inv);\n        }\n        else{\n            current[0] = texelFetch( iChannel0, st, 0 ).xy;\n            current[1] = texelFetch( iChannel0, st, 0 ).zw;\n            \n            if( texelFetch(iChannel1,ivec2(32,2),0).x <= 0. )\n                Dilate(current, 1.005);\n        }\n    \n        \n        if( texelFetch(iChannel1,ivec2(65,0),0).x > 0.){            \n            Dilate(current, 1.01);\n        } \n        else if( texelFetch(iChannel1,ivec2(90,0),0).x > 0.){           \n            Dilate(current, 1./1.01);\n        }\n        else if( texelFetch(iChannel1,ivec2(83,0),0).x > 0.){            \n            Shear(current, 0.02);\n        } \n        else if( texelFetch(iChannel1,ivec2(88,0),0).x > 0.){            \n            Shear(current, -0.02);\n        }\n        else if( texelFetch(iChannel1,ivec2(68,0),0).x > 0.){            \n            Rotate(current, 0.05);\n        } \n        else if( texelFetch(iChannel1,ivec2(67,0),0).x > 0.){            \n            Rotate(current, -0.05); \n        }\n        else if( texelFetch(iChannel1,ivec2(70,0),0).x > 0.){            \n            ShearOpposite(current, 0.02);\n        } \n        else if( texelFetch(iChannel1,ivec2(86,0),0).x > 0.){            \n            ShearOpposite(current, -0.02);\n        }\n        \n        if(st.s == 0){\n            mat2 gamma = e();\n            LLL(current, gamma);\n            MakeShorter(current, gamma);\n        }\n        fragColor = vec4(current[0], current[1]);\n \n    }\n     \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,1,1);\n    ivec2 st = ivec2(fragCoord);\n\n    if(st.s == 0 && st.t < N){\n        mat2 lattice;\n        lattice[0] = texelFetch( iChannel0, st, 0 ).xy;\n        lattice[1] = texelFetch( iChannel0, st, 0 ).zw;\n        \n    \n        mat2 K,a,n;\n        kan(K,a,n,lattice);\n        \n        vec2 z;\n        MoebiusAti(lattice,z);\n           \n        fragColor = vec4((K*K)[1], z);\n\n    }\n    else if(st.s == 1 && st.t < N){\n        mat2 current;\n        current[0] = texelFetch( iChannel0, st, 0 ).xy;\n        current[1] = texelFetch( iChannel0, st, 0 ).zw;\n        \n        mat2 gamma = e();\n        LLL(current, gamma);\n        MakeShorter(current, gamma);\n\n        mat2 K,a,n;\n        kan(K,a,n,current);\n        \n        vec2 z;\n        MoebiusAti(current,z);\n           \n        fragColor = vec4((K*K)[1], z);\n\n    }\n              \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSSWm.jpg", "access": "api", "license": "mit", "functions": [[3607, 3607, 3664, 3727, 7316]]}
{"id": "slSXWd", "name": "particle test 111", "author": "lasoy", "description": "particle", "tags": ["particle"], "likes": 3, "viewed": 295, "published": 3, "date": "1628859413", "time_retrieved": "2024-07-30T19:06:30.984392", "image_code": "#define NUM 20.0\n#define PI 3.1415926\nvec3 color(float t) {\n    // from IQ's color pattern\n    return .3 + .7 * cos(6.283 * (vec3(1., .5, .0) * (1. - t) + vec3(.7, .75, .3)));\n}\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y += .4;\n    vec3 col = vec3(0, 0, 0);\n    for(float i = 0.;i < NUM; i ++) {\n        float id = i;\n        float h0 = hash11(id);\n        float h1 = hash11(h0);\n        float h2 = hash11(h1);\n        float h3 = hash11(h2);\n        vec2 pos = uv;\n        pos.x += cos(iTime * 3. * h0 + h0 * PI * 2.) * .2 * (.5 + h0 * 2.) * (.2 + pow(pos.y, .8));\n        pos.y -= fract(iTime * .3 + h1) * .8 * (.5 + h1);\n        vec3 c =  color(h3);\n        col += 0.012 * h2 /length(pos) * c;\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 59, 90, 177], [178, 178, 201, 201, 286], [288, 288, 345, 345, 966]]}
{"id": "ftBSWd", "name": "firebug particles", "author": "jcyuan", "description": "flying firebug particles.\nI don't know why CloudSound does not work now so I did not add a bgm for it...\n", "tags": ["hash", "particle"], "likes": 21, "viewed": 1128, "published": 3, "date": "1628852459", "time_retrieved": "2024-07-30T19:06:31.827139", "image_code": "// hash functions from https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n// ------------------------------------------------------------------------\n\nvec3 color(float t) {\n    // from IQ's color pattern formula\n    return .3 + .7 * cos(6.283 * (vec3(1., .5, .0) * (1. - t) + vec3(.7, .75, .3)));\n}\n// ------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    uv.y += .9;\n\t\n    vec3 col = vec3(0.);\n    float time = iTime * .5;\n\n    for (int i = 0; i < 30; i++) {\n        float sd = time + float(i) * 3303.1031;\n        float id = floor(sd);\n        float t = sd - id;\n        \n        float rnd = hash11(id);\n        vec2 p = hash21(id);\n        \n        p.y *= -t * (rnd + .5) - .5;\n        p.x *= rnd > .5 ? -1. : 1.;\n        \n        float size = rnd * .0075 + .00025;\n        float flicker = hash11(t * .5) * .0015;\n        \n        float cycle = rnd * 8.;\n        float w = p.x * .3 - p.x * p.y * .45;\n        float d = (size + flicker) / length(uv + vec2(cos(sd * cycle - abs(t) * 2.) * w, p.y));\n\n        col += color(rnd) * d;\n    }\n    \n    col = pow(col, vec3(1.9)); // bloom reduction\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 83, 83, 211], [213, 213, 236, 236, 321], [399, 399, 420, 459, 546], [624, 624, 679, 679, 1526]]}
{"id": "7lBSD3", "name": "loading circle tutorial", "author": "jcyuan", "description": "basic tutorial", "tags": ["tutorial"], "likes": 3, "viewed": 157, "published": 3, "date": "1628822898", "time_retrieved": "2024-07-30T19:06:32.576136", "image_code": "vec3 rainbowColor(float t) {\n    return .5 + .5 * cos(6.283 * (t + vec3(0., .33, .67)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // uv\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // sdf\n    float l = length(uv);\n    \n    // \n    float w = fwidth(l);\n    \n    // \n    // float d = step(abs(l - .45), .05);\n    \n    // \n    // float d = smoothstep(w, -w, max(.4 - l, l - .5));\n    \n    // \n    float d = smoothstep(w, -w, abs(l - .45) - .05);\n\n    // uv01\n    float a = fract(atan(uv.y, uv.x) / 6.283 - iTime * .5);\n    \n    // pow01a\n    a = pow(a, 1.5);\n    \n    // \n    vec3 col = d   // \n               *\n               // a0-1\n               rainbowColor(a)\n               *\n               // amask\n               a;\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 90], [92, 92, 147, 169, 1104]]}
{"id": "NlBSWR", "name": "mouse ate my house", "author": "mare", "description": " - 1-4-7 based prog with equal temperment.\n - 7/4 meter with emphasising the missing beat. It'd be almost house music if it weren't for that.\n - more advanced visuals than last time ( still a bit lazy on the artefacts )", "tags": ["3d", "audio", "funny"], "likes": 19, "viewed": 564, "published": 3, "date": "1628804775", "time_retrieved": "2024-07-30T19:06:33.516621", "image_code": "\n#define lenSq(x) dot(x,x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord / iResolution.xy;\n    float colorScale = 6.0 / iResolution.y;\n    \n    vec2 pixelStep = 3.0 / iResolution.xy;\n    \n    vec3 center = texture( iChannel0, coord ).xyz;\n    vec3 top = texture( iChannel0, coord + vec2( .0, pixelStep.y ) ).xyz;\n    vec3 right = texture( iChannel0, coord + vec2( pixelStep.x, .0 ) ).xyz;\n    \n    float sobelThreshold = .25;\n    \n    float tvVignette = 1.0 - 1.5 * lenSq( coord - vec2( .5, .5 ) );\n    tvVignette *=  .9 + .1 * sin( 2.0 * fragCoord.y );\n    \n    fragColor = vec4(\n        tvVignette * texture( iChannel0, coord * ( 1.0 - colorScale )).r,\n        tvVignette * texture( iChannel0, coord ).g, \n        tvVignette * texture( iChannel0, coord * ( 1.0 + colorScale )).b,\n        1.0 );\n    if( lenSq( center - top ) > sobelThreshold || lenSq( center - right ) > sobelThreshold)\n    {\n        fragColor *= vec4( .25, .25, .25, 1.0 );\n\n    }\n    \n    \n    return;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define TONE(f,i) sin((f)*float(i)*1.424759e-4)\n#define FADE_OUT_LIN(l,i) clamp(float(l-(i))/float(l), .0, 1.0)\n#define FADE_IN_LIN(l,i) clamp(float(i)/float(l), .0, 1.0)\n\n#define LP(f) clamp((lp-f)*.01-.05,.0,1.)\n#define PAN(f) vec2(sin(f),cos(f))\n#define CENTER *vec2(1.)\n\n\nint primes[ 16 ] = int[ 16 ]\n(\n0, 5, 7, 7,\n2, 7, 9, 9,\n3, 8, 10, 10,\n2, 7, 0, 0\n);\n\nint thirds[ 16 ] = int[ 16 ]\n(\n16, 21, 23, 23,\n17, 23, 24, 24,\n19, 24, 14, 13,\n17, 23, 16, 16\n);\n\nint sevenths[ 16 ] = int[ 16 ]\n(\n11, 14, 18, 18,\n12, 16, 17, 17,\n14, 19, 21, 20,\n12, 19, 21, 21\n);\n\nlowp float chord[5] = float[5](.0, .0, .0, .0, .0);\n\n// equal temperment\nfloat ratios[ 26 ] = float[26]\n(\n    1.0, 1.059463, 1.122462, 1.189207, 1.259921, 1.334840,\n    1.414213, 1.498307, 1.587401, 1.681793, 1.781797, 1.887749,\n    2.0, 2.118126, 2.244924, 2.378414, 2.519842, 1.669680, \n    2.828426, 2.996614, 3.174802, 3.363586, 3.563594, 3.775498,\n    4.0, .0\n);\n#define N 25\n\nfloat kick( int samp )\n{\n    float fout = FADE_OUT_LIN(12000,samp);\n    return 0.5 * TONE(220.0-.015 * float(samp), samp)\n        * FADE_IN_LIN(50, samp)\n        * fout * fout * fout;\n}\n\nfloat hat( int samp )\n{\n    float fm = float( max( 200, 3000 - 2 * samp ) );\n    float fadeOut = FADE_OUT_LIN(20000,samp);\n    fadeOut *= fadeOut * fadeOut;\n    fadeOut *= fadeOut * fadeOut;\n    return .3 * TONE(5000.0 +  fm * TONE(500.0, samp), samp)\n        * FADE_IN_LIN(50, samp)\n        * fadeOut;\n}\n\nvec2 glass( float f, int samp, int len )\n{\n    float fadeOutAtt = FADE_OUT_LIN(min(len, 6000),samp);\n    fadeOutAtt *=fadeOutAtt;\n    fadeOutAtt *=fadeOutAtt;\n    \n    return  TONE(min( f, f-300. +  .8 *float(samp) ), samp)*PAN(f)\n        * FADE_IN_LIN(300, samp)\n        * fadeOutAtt\\\n        * min(f, 1.0 );\n}\n\nfloat bass( float f, int samp, int len )\n{\n    return \n        ( max( TONE( f, samp ), .1 ) - .45 ) * .5\n\n        * FADE_IN_LIN(200, samp)\n        * FADE_OUT_LIN(200, samp - len + 200 )\n        * FADE_OUT_LIN(len*2, samp )\n        * min(f, 1.0 ); \n}\n\n\nvec2 pianoLP( float f, int samp, int len, float lp )\n{\n    float fadeOut = FADE_OUT_LIN(len, samp);\n    fadeOut *= fadeOut * fadeOut;\n    float fadeOutO1 = FADE_OUT_LIN(len, samp);\n    fadeOutO1 *= fadeOutO1 * fadeOutO1 * ( .7 + .3 * TONE( 6.0, samp ) );\n    float fadeOutO2 = FADE_OUT_LIN(len/6, samp);\n    fadeOutO2 *= fadeOutO2 * fadeOutO2 * ( .7 + .3 * TONE( 5.0, samp ) );\n    float fadeOutO3 = FADE_OUT_LIN(len/2, samp);\n    fadeOutO3 *= fadeOutO3 * fadeOutO3 * ( .7 + .3 * TONE( 4.0, samp ) );\n    \n    vec2 tone = TONE(f, samp )*LP(f) * PAN(f );\n    vec2 overtones1 = \n            .1 * TONE( 2. * f, samp )*LP(2.*f)*PAN(2.*f) +\n            .5 * TONE( 3. * f, samp )*LP(3.*f)*PAN(3.*f) +\n\n            .15 * TONE( 4. * f, samp )*LP(4.*f)*PAN(4.*f);\n    vec2 overtones2 = \n            .1 * TONE( 5. * f, samp )*LP(5.*f)*PAN(5.*f) +\n            .27 * TONE( 6. * f, samp )*LP(6.*f)*PAN(6.*f)+\n            .17 * TONE( 7. * f, samp )*LP(7.*f)*PAN(7.*f);\n    vec2 overtones3 = \n            .015 * TONE( 8. * f, samp )*LP(8.*f)*PAN(8.*f)+\n            .005 * TONE( 9. * f, samp )*LP(9.*f)*PAN(9.*f)+\n            .001 * TONE( 10. * f, samp )*LP(10.*f)*PAN(10.*f);\n   \n    \n    return FADE_IN_LIN(500, samp) * min( f, 1.0 ) * (\n        tone * fadeOut + \n        overtones1 * fadeOutO1 + \n        overtones2 * fadeOutO2 + \n        overtones3 * fadeOutO3\n        );\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    int barLength = 160000;\n    int beatLength = barLength / 7;\n    int subBeat1 = 5 * beatLength / 10;\n    int subBeat2 = 7 * beatLength / 10;\n    \n    int barSamp = samp % barLength;\n    int beatSamp = samp % beatLength;\n    int localBeatIndex = ( samp / beatLength ) % 7;\n    int beatIndex = samp / beatLength;\n    \n    int barIndex = samp / barLength;\n    int index = ( ( barIndex & 3 )<<1 ) + ( barIndex & 8 );\n      \n    if( barIndex >= 16 && barIndex < 24 )\n    {\n        index= 0;\n        barIndex = 16;\n    }\n    \n    float prime1 = 120.0 * ratios[ primes[ index ] ];\n    float prime2 = 120.0 * ratios[ primes[ index + 1 ] ];\n    float third1 = 120.0 * ratios[ thirds[ index ] ];\n    float third2 = 120.0 * ratios[ thirds[ index + 1 ] ];\n    float seventh1 = 240.0 * ratios[ sevenths[ index ] ];\n    float seventh2 = 240.0 * ratios[ sevenths[ index + 1 ] ];\n    \n    vec2 stereo = vec2( .0 );\n    float mono = .0;\n    if( barIndex >= 8 && !( barIndex >= 24 && barIndex < 32 ) )\n    {\n        if( barIndex >= 32 && barIndex < 48 )\n        {\n            mono += kick( barSamp );\n            mono += hat( barSamp - beatLength * 2 );\n            mono += kick( barSamp - beatLength * 3);\n            mono += hat( barSamp - beatLength * 5 );\n            \n            if( ( barIndex & 8 ) == 8)\n            {\n                mono += kick( beatSamp - subBeat1) * ( 1. - .5 * float( localBeatIndex & 2 ) );\n            }\n            \n            mono += .1 * hat(( beatSamp ) * 1 ) * ( 1. - float( localBeatIndex & 1 ) );\n            mono += .1 * hat(( beatLength /2 - beatSamp - 6000) * 3 ) * ( 1. - float( localBeatIndex & 1 ) );\n        }\n        else\n        {\n            mono += kick( beatSamp ) * ( 1. - float( localBeatIndex & 1 ) );\n            mono += hat(beatSamp ) * float( localBeatIndex & 1 );\n            \n            mono += .1 * hat(( beatLength /2 - beatSamp - 6000) * 3 );\n            mono += .1 * hat(( beatSamp - beatLength /2 ) * 1 );\n        }\n       \n        mono += kick(-barSamp + beatLength * 13/2);\n        if( barIndex < 48 )\n        {\n            stereo += .3 * glass( prime1 * 1.5, beatSamp - subBeat1, 6000);\n            stereo += .3 * glass( prime1 * 2.0, beatSamp - subBeat2, 6000);\n        }\n    }\n\n    if( barIndex >= 6)\n    {    \n        mono += bass(.5 * prime1, barSamp, subBeat1 );\n        mono += bass(.5 * prime1, barSamp - beatLength - subBeat1, subBeat1 );\n        mono += bass(.75 * prime1, barSamp - 3 * beatLength - subBeat1, subBeat1 );\n        mono += bass(.375 * prime2, barSamp - 5 * beatLength - subBeat2, 6000 );\n    }\n    \n    int offset2 = ( 3 + ((barIndex >>1)& 1 ) ) * beatLength;\n    \n    float fade4th = float( 1 - (barIndex & 1) );\n    fade4th = max( fade4th, 1.0 - abs( float( (barIndex>>1) - 2)  ) );\n    float weight2nd = smoothstep( -20000.0, 20000.0, float( barSamp - offset2 ) );\n    float prime = weight2nd * (prime2 - prime1) + prime1;\n    float third = weight2nd * (third2 - third1) + third1;\n    float seventh = weight2nd * (seventh2 - seventh1) + seventh1;\n    \n    chord[ 0 ] = prime;\n    chord[ 1 ] = third;\n    chord[ 2 ] = prime * 1.489;\n    chord[ 3 ] = seventh;\n    chord[ 4 ] = third * 2.0;\n    \n    int microBeatLength = beatLength / 24;\n    int microBeatSamp = barSamp % microBeatLength;\n    int microBeatIndex = barSamp / microBeatLength;\n    if( barIndex >= 16 ) \n    {\n        float f = 2. * chord[ microBeatIndex % 5 ];\n        stereo += 0.02 * TONE( f, microBeatSamp ) * PAN(f)\n            * FADE_IN_LIN( 100, microBeatSamp)\n            * FADE_OUT_LIN( 100, microBeatSamp - microBeatLength + 200 ) \n            * sin( float(microBeatIndex ) * .05 );\n    }\n    stereo += 0.02 * ( \n        TONE( 1. * prime, barSamp ) +     \n        TONE( 1.01 * prime, barSamp )  \n        ) * PAN( prime )\n        \n    * FADE_IN_LIN( 100, barSamp)\n    * FADE_OUT_LIN( 100, barSamp - barLength + 200 );\n    \n    stereo += .125 * glass(chord[ beatIndex % 5 ] * 2., beatSamp - subBeat1 , subBeat1 );\n    stereo += .03125 * glass(chord[ ( beatIndex + 3 ) % 5 ] * 2., beatSamp - subBeat2 , subBeat2 );\n    stereo += .0625 * glass(chord[ ( beatIndex + 3 ) % 5 ] * 2., beatSamp - subBeat1/2 , subBeat2 );\n    \n    float painoLp = exp( 3.5 * clamp( float(samp) * .125 / float( barLength ), .0, 1.0 ) + 6.5);\n    if(barIndex == 16)\n    {\n        painoLp = exp( 3.5 * clamp( TONE( .04, samp) * .5 + .5, .0, 1.0 ) + 6.5);\n    }\n    else if ( barIndex >= 24 && barIndex < 40 )\n    {\n        painoLp = exp( 7.5 );\n    }\n    \n    stereo += .2 * pianoLP( prime1, barSamp, beatLength * 4 , painoLp);\n    stereo += .2 * pianoLP( prime2, barSamp - offset2, beatLength * 3, painoLp ) * fade4th;\n    stereo += .2 * pianoLP( third2, barSamp - offset2, beatLength * 2, painoLp ) * fade4th;\n    stereo += .05 * pianoLP( seventh1, barSamp - 2000, beatLength * 4, painoLp );\n    \n    return ( .6 * mono CENTER + stereo ) * clamp( .1 * ( 180. - time ), .0, 1.0 );\n}", "sound_inputs": [], "buffer_a_code": "#define INV_MUL(a,b) a=(1.0-(1.0-(a))*(1.0-(b)))\n\nfloat cylinderXY( vec3 pos, vec3 center,float radius, float width )\n{\n\n    vec3 diff = pos - center;\n    float val = 1.0 - (smoothstep( radius -.05, radius + .05, length( vec2(diff) ) ) );\n    float zDiff =  pos.z - center.z; \n    val *= 1.0 - (smoothstep( width -.05, width + .05, abs( diff.z ) ) );\n    return val;\n}\n\nfloat cylinderXY2( vec3 pos, vec3 center,float radius, float width )\n{\n\n    vec3 diff = pos - center;\n    float val = (smoothstep( radius -.05, radius + .05, length( vec2(diff) ) ) );\n    float zDiff =  pos.z - center.z; \n    val *= (smoothstep( width -.05, width + .05, abs( diff.z ) ) );\n    return val;\n}\n\nfloat sphere( vec3 pos, vec3 center,float radius )\n{\n    return 1.0 - (smoothstep( radius -.09, radius + .09, length( pos - center ) ) );\n}\nfloat sphere2( vec3 pos, vec3 center,float radius )\n{\n    return (smoothstep( radius -.09, radius + .09, length( pos - center ) ) );\n}\n\n\nvec3 centerHead;\nvec3 leftHeadphone;\nvec3 rightHeadphone;\nvec3 leftEarCenter;\nvec3 rightEarCenter;\nfloat headRadius;\nfloat headPhoneSize;\nfloat cylinderWidth;\nfloat cylinderRadius;\nfloat eyeSize;\nvec3 leftEye;\nvec3 rightEye;\nfloat faceFade;\nvec3 headScale;\nfloat frogify;\n\n\nfloat blob( vec3 pos )\n{\n    float outVal = 1.0;\n    pos = clamp( pos, vec3( -1.6 ), vec3( 1.6) );\n    vec3 frogHeadphoesPos = vec3(.0, .1, -.1 );//, -.2 * frogify, -.2 * frogify);\n    float cyl = cylinderXY( pos, frogHeadphoesPos, cylinderRadius, cylinderWidth );\n    cyl *= step( .1, pos.y);\n    outVal *= 1.0 - cyl;\n    outVal *= sphere2( pos, leftHeadphone + frogHeadphoesPos, headPhoneSize );\n    outVal *= sphere2( pos, rightHeadphone + frogHeadphoesPos, headPhoneSize );\n      \n    outVal += 10.0 * faceFade * sphere( pos, centerHead + frogify * vec3(.0, .2, .0) + frogHeadphoesPos, headRadius);\n    outVal = clamp( outVal, .0, 1.0 );\n    \n    \n    outVal *= sphere2( pos, leftEarCenter, .3 );\n    outVal *= sphere2( pos, rightEarCenter, .3 );\n    outVal *= sphere2( pos * headScale, centerHead, headRadius );\n    \n    outVal *= sphere2( pos * headScale, vec3( .0, .0, -.5 ), .2 );\n    \n    outVal += sphere( pos, rightEye - vec3(.0,.0,.09), eyeSize * faceFade );\n    outVal += sphere( pos, leftEye - vec3(.0,.0,.09), eyeSize * faceFade);\n    \n    outVal *= sphere2( pos, rightEye, eyeSize );\n    outVal *= sphere2( pos, leftEye, eyeSize );\n    return 1.0 - outVal;\n}\n\nvec3 color( vec3 pos )\n{\n    vec3 outVal = vec3( 1.0 - .9 * frogify, .1, .1 + .9 * frogify);\n    pos = clamp( pos, vec3( -1.0 ), vec3( 1.0) );\n    float bodyColMask = sphere( pos, centerHead,  headRadius );\n    INV_MUL(bodyColMask, sphere( pos, vec3( .0, .0, -.5 ), .2 ));\n    outVal += bodyColMask * vec3( .0 + .3 * frogify, .8 + .2 * frogify, .45 - 1.6 * frogify);\n    outVal += vec3( 1.0 ) * sphere( pos, rightEye, eyeSize );\n    outVal += vec3( 1.0 ) * sphere( pos, leftEye, eyeSize );\n    outVal -= vec3( 6.0, 2.5, .0 ) * sphere( pos, rightEye - vec3(.0,.02,.09), .05 * faceFade );\n    outVal -= vec3( 6.0, 2.5, .0 ) * sphere( pos, leftEye - vec3(.0,.02,.09), .05 * faceFade );\n    \n    \n    outVal -= vec3( 10.0 ) * sphere( pos, rightEye - vec3(.0,.02,.09), .01 * faceFade);\n    outVal -= vec3( 10.0 ) * sphere( pos, leftEye - vec3(.0,.02,.09),  .01 * faceFade);\n    \n    outVal = clamp( outVal, vec3( .0 ) , vec3( 1.0 ) );\n    return outVal;\n}\n\n#define GRAD_WIDTH .0001\nvec3 blobNormal( vec3 pos )\n{\n    float blobCenter = blob( pos );\n    float blobX = blob( pos + vec3( GRAD_WIDTH, .0, .0 ) );\n    float blobY = blob( pos + vec3( .0, GRAD_WIDTH, .0 ) );\n    float blobZ = blob( pos + vec3( .0, .0, GRAD_WIDTH ) );\n    vec3 grad = vec3( \n        blobCenter - blobX, \n        blobCenter - blobY, \n        blobCenter - blobZ );\n    return normalize( grad );\n    \n    \n}\n\nfloat noise21(vec2 inVal )\n{\n    return fract( \n    12312.0 * sin( inVal.x * 6549874.0 + iTime) + \n    12132.0 * sin( inVal.y * 6299874.0 - iTime ) );\n}\n\n\n#define STEP .05\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time  = iTime;// + 90.0;\n\n    float barLength = 160000. / 44100.;\n    float tBeat = fract( time / barLength )  * 7.;\n    float bob = fract( tBeat );\n    \n    bob = max( min( 40.0 * bob, 1.0 - 100. * bob * bob * bob), .0 );\n    if( time < 28.0 || ( time > 86.0 ) && time < 114.0 )\n    {\n        bob = .0;\n    }\n    float beat7th = max( .0, ( tBeat - 6.0 ) * ( 7.0 - tBeat ) );\n\n\n    float peacesFade = clamp( 4.0 - time / 7.5, .0, 1.) + .05 * sin( time );\n    float phase = time * min( .3, time / 100.0 );\n    peacesFade = max( peacesFade, ( 10.0 * sin( time * .3 ) - 9.0 ) * .6 );\n    peacesFade = max( peacesFade, beat7th );\n    \n    \n    \n    frogify = clamp( ( time - 60.0f ) * .05,.0, 1.0 );\n    peacesFade += ( frogify * ( 1.0 - frogify ) );\n    \n    headScale = vec3( 1.0, 1.0 + frogify, 1.0 + frogify * .3 );\n    centerHead = vec3( .0, -.2 * frogify, -.2 * frogify ) + peacesFade * vec3( \n        .5 * sin( phase * 1.234 + 12.),\n        .5 * sin( phase * 3.234 + 15.),\n        .5 * sin( phase * 2.234 + 14.)\n        );\n    leftHeadphone = vec3( .4, .0, .0 )  + peacesFade * vec3( \n        .5 * sin( phase * 1.432 + 61.),\n        .5 * sin( phase * 2.234 + 82.),\n        .3 * sin( phase * 5.234 + 65.)\n        );\n    rightHeadphone = vec3( -.4, .0, .0 )  + peacesFade * vec3( \n        .5 * sin( phase * 2.1 + 21.),\n        .2 * sin( phase * 2.9 + 3.5),\n        .5 * sin( phase * 4.8 + 69.)\n        );\n    leftEarCenter = vec3( .4 - frogify * .3, .0, .0 )  + peacesFade * vec3( \n        .3 * sin( phase * 2.432 + 11.),\n        .5 * sin( phase * 3.234 + 92.),\n        .5 * sin( phase * 5.234 + 15.)\n        );     \n    rightEarCenter = vec3( -.4 + frogify * .3, .0, .0 )  + peacesFade * vec3( \n        .5 * sin( phase * 2.432 + 61.),\n        .2 * sin( phase * 3.234 + 82.),\n        .5 * sin( phase * 1.234 + 65.)\n        );    \n    leftEye = vec3( .2, .2 + .1 * frogify, -.41 + .3 * frogify )  + peacesFade * vec3( \n        .5 * sin( phase * 1.832 + 61.),\n        .6 * sin( phase * 5.134 + 81.),\n        .4 * sin( phase * 1.634 + 63.)\n        );\n    rightEye = vec3( -.2, .2 + .1 * frogify, -.41 + .3 * frogify )  + peacesFade * vec3( \n        .4 * sin( phase * 6.832 + 11.),\n        .3 * sin( phase * 1.134 + 21.),\n        .2 * sin( phase * 2.634 - 63.)\n        );        \n    headRadius = .6 - .4 * peacesFade;\n    headPhoneSize = .4 - .2 * peacesFade + bob * .03;\n    cylinderWidth = .1 - .3 * peacesFade;\n    cylinderRadius = .75 - .75 * peacesFade;\n    eyeSize = .1 + .1 * peacesFade + .05 *frogify;\n    faceFade = 1.0 - peacesFade;\n\n    float rotTime = 2.* time + 1.5 * sin( time * .5 );\n    vec2 uv = ( fragCoord - vec2( (iResolution.x - iResolution.y) * .5, 0 ) )/iResolution.y - vec2( .5 );\n    float ang = .9 * sin( time * .5 ) + 1.5;\n    vec3 center = vec3( -2.0 * cos( ang ), .0, -2.0 * sin( ang ) );\n    vec3 top = vec3( .0, 1., .0 );\n    center += top * .3;\n    vec3 front = -.5 * center;\n    vec3 side = vec3( front.z, .0, -front.x );\n    \n    vec3 ray = normalize( uv.x * side + uv.y * top + front );\n    vec3 lightPos = center + side + 2.0 * top;\n    \n    float foundDist = -2.0;\n    float dist = 1.2 + noise21( uv ) * STEP;\n    float accum = .0;\n    \n    while( dist < 2.6)\n    {\n    \n        vec3 probe = center + ray * dist;\n        float val = blob( probe );\n        if( val > .5)\n        {\n            foundDist = dist;\n            break;\n        }\n        accum += val;\n        if( accum > 6.0 )\n        {\n            fragColor = vec4(.0f, .0f, .0f,1.0);\n            return;\n        }\n        dist += STEP;\n    }\n    if( foundDist > .0 )\n    {\n        float step = STEP * .5 * (1.0 + .1 * noise21(uv * .3));\n        vec3 probe;\n        for( int i = 0; i < 4; ++i )\n        {\n            float newDist = foundDist - step;\n            probe = center + ray * newDist;\n            if( blob( probe) > .5 )\n            {\n                foundDist = newDist;\n            }\n            step *= .5;\n        \n        }\n        vec3 lightDir = normalize(lightPos - probe);\n        \n      \n        vec3 normal = blobNormal( probe );\n        float diffuse = clamp( dot( normal, lightDir ), .1, 1.0 );\n        diffuse = .25 + .5 * smoothstep( .2, .3, diffuse ) + + .25 * smoothstep( .8, .9, diffuse ) ;\n        \n        vec3 shadowStep = lightDir * .01;\n        vec3 shadowProbe = probe;\n        for( int i = 0; i < 30; ++i )\n        {\n            shadowProbe += shadowStep;\n            if( blob( shadowProbe ) > .5 )\n            {\n                diffuse = .25;\n                break;\n            }\n           \n        }\n       \n        fragColor = vec4( color( probe ) *  diffuse, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(vec3(1.0 - vec3( .4, .6, .5) * frogify),1.0);\n    }\n}", "buffer_a_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 28, 85, 85, 1014]]}
{"id": "fljXW3", "name": "rainbow loading", "author": "lasoy", "description": "rainbow loading", "tags": ["rainbow"], "likes": 6, "viewed": 323, "published": 3, "date": "1628772648", "time_retrieved": "2024-07-30T19:06:34.344408", "image_code": "#define PI 3.1415926\nvec3 rainbowColor(float t) {\n    return .5 + .5 * cos(6.283 * (t + vec3(0., .33, .67)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float pix = 2./iResolution.y;\n    float len = length(uv);\n    float angle = atan(uv.x, uv.y)/PI*.5 + iTime*.4;\n\n    vec3 col = rainbowColor(angle);\n    col *= smoothstep(pix, -pix, abs(len-.55) -.05 );\n    col *= smoothstep(0., .9, fract(angle));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 49, 49, 111], [113, 113, 170, 220, 594]]}
{"id": "Nt2XDG", "name": "lighting02", "author": "wangxiaochen", "description": "this is a simple lighting", "tags": ["3d"], "likes": 3, "viewed": 255, "published": 3, "date": "1628771765", "time_retrieved": "2024-07-30T19:06:35.096397", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define Light_pos vec3(5.,5.,9.)\n#define selfcol vec3(.9,.9,.9)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.1,0.5,0.9) );\n}\nfloat smin(float a,float b,float h){\n    float c=clamp((b-a)/h*0.5+0.5,0.,1.);\n    //return c;\n    return mix(b,a,c)-h*c*(1.0-c);\n}\n\nmat2 rot(float a){\n   float c=sin(a);\n   float s=cos(a);\n    return mat2(c,s,-s,c);\n    \n}\nfloat GetDist(vec3 p){\n    vec4 s=vec4(0.,1.,6.,2.);\n    float spheredist=length(p-s.xyz)-s.w;\n    float planedist=p.y;\n    float d=smin(spheredist,planedist,.9);\n    return d;\n}\nfloat rayMarch(vec3 ro,vec3 rd){\n    float d0=0.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*d0;\n        float ds=GetDist(p);\n        d0+=ds;\n        if(d0>MAX_DIST||ds<SURF_DIST)break;\n    }\n    return d0;\n}\nvec3 getNormal(vec3 p){\n    float l= GetDist(p);\n    vec2 cau=vec2(.01,0.);\n    vec3 n=normalize(vec3(l-GetDist(p-cau.xyy),\n                          l- GetDist(p-cau.yxy),\n                          l- GetDist(p-cau.yyx)\n                           ));\n    return n;\n    \n}\nfloat  getLight(vec3 p){\n    vec3 ld=Light_pos;\n    //shadow\n    ld.xz*=rot(iTime);\n    vec3 li=normalize(ld-p);\n    vec3 sn=getNormal(p);\n    float sh=rayMarch(p+sn*SURF_DIST*2.,li);\n    float dif=clamp(dot(sn,li),0.,1.) ;\n        if(sh<length(ld-p)) {\n            dif*=.5;\n        }\n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     vec3 ld=Light_pos;\n    ld.xz*=rot(iTime);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0.,3.,-3);\n    vec3 rd=normalize(vec3(uv.x,uv.y-.2,1));\n    float d= rayMarch(ro,rd);\n    vec3 p=ro+rd*d;\n    vec3 n=getNormal(p);\n    float difu=getLight(p);\n    float ndotv=max(0.,dot(normalize(rd),n));\n    vec3 halfh=normalize(normalize(-rd)+normalize(ld-p));\n    float ndothalfh=max(0.,dot(halfh,n));\n    vec3 col =mix(vec3(difu)*selfcol,spectrum(ndothalfh),0.1);\n    col+=vec3(pow(ndothalfh,25.));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 199, 199, 242], [243, 243, 267, 267, 363], [364, 364, 400, 400, 495], [497, 497, 515, 515, 587], [588, 588, 610, 610, 766], [767, 767, 799, 799, 987], [988, 988, 1011, 1011, 1260], [1261, 1261, 1285, 1285, 1563], [1564, 1564, 1621, 1671, 2254]]}
{"id": "NtjSW3", "name": "Spiraling In and Out", "author": "dr2", "description": "More logarithmic spiraling (based on \"Spiraling Out\")", "tags": ["spiral", "projection", "logarithm"], "likes": 16, "viewed": 337, "published": 3, "date": "1628770907", "time_retrieved": "2024-07-30T19:06:35.900248", "image_code": "// \"Spiraling In and Out\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // 0/1 - optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec3 ltDir, qHit;\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, a, s;\n  dMin = dstFar;\n  q = p;\n  r = length (q.xz);\n  if (r > 0.01) {\n    a = atan (q.z, q.x) / pi;\n    q.xz = mod (vec2 (0.5 * (pi * log (r) - a) - 0.4 * tCur, -5. * a) + 0.5, 1.) - 0.5;\n    q.y /= sqrt (r);\n    q.y -= 0.15 - 0.01 / r;\n    s = 0.25 * r;\n    d = s * min (PrRoundBoxDf (q, vec3 (0.16, 0.12, 0.2), 0.02), \n       PrRoundCylDf (vec3 (q.x, q.y - 0.24, abs (q.z) - 0.1).xzy, 0.05, 0.01, 0.12));\n    DMINQ (1);\n    d = s * max (abs (abs (q.x) - 0.3) - 0.1, q.y + 0.06);\n    DMINQ (2);\n    d = s * min (PrRoundCylDf (vec3 (q.x - 0.3, q.y, mod (q.z - 0.3 * tCur + 0.25, 0.5) - 0.25).xzy,\n       0.07, 0.01, 0.12),\n       PrRoundCylDf (vec3 (q.x + 0.3, q.y, mod (q.z + 0.3 * tCur + 0.25, 0.5) - 0.25).xzy,\n       0.07, 0.01, 0.12));\n    DMINQ (3);\n  }\n  q = p;\n  d = max (0., q.y);\n  DMINQ (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh, nDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.2, 0.5, 1., 0.2) * (0.93 + 0.07 * cos (60. * pi * qHit.y));\n    else if (idObj == 2) col4 = vec4 (0.5, 0.2, 0.1, 0.2);\n    else if (idObj == 3) col4 = vec4 (1., 0.9, 0.9, 0.3) * (0.93 + 0.07 * cos (60. * pi * qHit.y));\n    else if (idObj == 4) col4 = vec4 (0.3, 0.6, 0.3, 0.2);\n    sh = ObjSShadow (ro + 0.01 * vn, ltDir);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.03 * pi * tCur;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += pi * mPtr.x;\n    el += 0.25 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.3 * pi, -0.17 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1., -20.);\n  zmFac = 2.5;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjSW3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[567, 567, 589, 589, 1440], [1442, 1442, 1475, 1475, 1659], [1661, 1661, 1682, 1682, 1937], [1939, 1939, 1976, 1976, 2205], [2207, 2207, 2242, 2242, 3003], [3005, 3005, 3061, 3061, 4182], [4184, 4184, 4230, 4230, 4277], [4279, 4279, 4336, 4336, 4411], [4413, 4413, 4449, 4449, 4655], [4657, 4657, 4687, 4687, 4800]]}
{"id": "slBXWc", "name": "Procedural Swords", "author": "SnoopethDuckDuck", "description": "This code forks from this: https://www.shadertoy.com/view/NlSSRV\n\nRough explanation: https://medium.com/@snoopethduckduck/procedural-sword-generation-69b8b7bc197\n\nInteractive version: https://snoopethduckduck.itch.io/sword-maker", "tags": ["procedural", "generative", "sword", "pixelart", "cool", "weapon", "dawnbringer"], "likes": 113, "viewed": 3178, "published": 3, "date": "1628764197", "time_retrieved": "2024-07-30T19:06:36.833752", "image_code": "\n// gem interior colors\nvec3 darkMap( int index,  float v ) {\n    vec3[5] arr;\n    \n    if (index == 0)      // blue \n        arr = vec3[] ( vec3(95,205,228), vec3(99,155,255), vec3(91,110,225), vec3(48,96,130),vec3(63,63,116));\n    else if (index == 1) // red \n        arr = vec3[] ( vec3(238,195,154),vec3(215,123,186),vec3(217,87,99),  vec3(172,50,50),vec3(69,40,60));\n    else if (index == 2) // green \n        arr = vec3[] ( vec3(153,229,80), vec3(106,190,48), vec3(55,148,110), vec3(48,96,130),vec3(63,63,116));\n    else if (index == 3) // brown\n        arr = vec3[] ( vec3(217,160,102),vec3(180,123,80), vec3(143,86.,59), vec3(102,57,49),vec3(69,40,60));\n    else if (index == 4) // grey\n        arr = vec3[] ( vec3(155,173,183),vec3(132,126,135),vec3(105,106,106),vec3(89,86,82), vec3(50,60,57));\n    else if (index == 5) // pink\n        arr = vec3[] ( vec3(215,123,186),vec3(217,87,99),  vec3(118,66,138), vec3(63,63,116),vec3(50,60,57));\n   \n   return arr[ min(5, int(v)) ] / 255.;\n}\n\n// gem interior outline colors\nvec3 lightMap( int index, float v ) {\n    vec3[5] arr;\n    \n    if (index == 0)      // blue\n        arr = vec3[] ( vec3(255),vec3(203,219,252),vec3(95,205,228), vec3(99,155,255), vec3(91,110,225));\n    else if (index == 1) // gold \n        arr = vec3[] ( vec3(255),vec3(251,242,54), vec3(255,182,45), vec3(223,113,38), vec3(172,50,50));\n    else if (index == 2) // green\n        arr = vec3[] ( vec3(255),vec3(203,219,252),vec3(153,229,80), vec3(106,190,48), vec3(55,148,110));\n    else if (index == 3) // brown \n        arr = vec3[] ( vec3(255),vec3(238,195,154),vec3(217,160,102),vec3(180,123,80), vec3(143,86,59));\n    else if (index == 4) // grey\n        arr = vec3[] ( vec3(255),vec3(203,219,252),vec3(155,173,183),vec3(132,126,135),vec3(105,106,106));\n    else if (index == 5) // pink\n        arr = vec3[] ( vec3(255),vec3(238,195,154),vec3(215,123,186),vec3(217,87,99),  vec3(118,66,138));\n    \n    return arr[ min(5, int(v)) ] / 255.;\n}\n\n// handle colors\nvec3 handleMap ( int index, float v) {\n    vec3[6] arr;\n    if (index == 0)      // blue\n        arr = vec3[] ( vec3(63,63,116),vec3(48,96,130),vec3(91,110,225),vec3(95,205,228),vec3(203,219,252),vec3(255));\n    else if (index == 1) // gold\n        arr = vec3[] ( vec3(69,40,60),vec3(172,50,50),vec3(223,113,38),vec3(255,182,45),vec3(251,242,54),vec3(255));\n    else if (index == 2) // green\n        arr = vec3[] ( vec3(63,63,116),vec3(48,96,130),vec3(55,148,110),vec3(106,190,48),vec3(153,229,80),vec3(203,219,252));\n    else if (index == 3) // brown\n        arr = vec3[] ( vec3(69,40,60),vec3(102,57,49),vec3(143,86,59),vec3(180,123,80),vec3(217,160,102),vec3(238,195,154));\n    else if (index == 4) // grey\n        arr = vec3[] ( vec3(50,60,57),vec3(118,66,138),vec3(105,106,106),vec3(155,173,183),vec3(203,219,252),vec3(255));\n    else if (index == 5) // pink\n        arr = vec3[] ( vec3(50,60,57),vec3(63,63,116),vec3(118,66,138),vec3(217,87,99),vec3(215,123,186),vec3(238,195,154));\n   return arr[ min(5, int(5. * v)) ] / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setDimGem(iFrame);\n    setDimHandle(iFrame);\n    \n    float h = dimGem.y + 0.5 * dimHandle.y;\n        \n    float sf = 1.2 * (2. * dimGem.y + dimHandle.y) / iResolution.y; //2.\n    vec2 osc = vec2(0., sf * (24. * cos(iTime) + 8.));\n    \n    // gem coord\n    vec2 coord = ceil(sf * fragCoord + osc + vec2(dimGem.x, -dimHandle.y)\n               - sf * 0.5 * iResolution.xy\n               + vec2(0.,h)  );\n\n    // handle coord\n    vec2 coord2 = ceil( sf * fragCoord + osc + 0.5 * vec2(dimHandle.x, -4.)\n                - sf * 0.5 * iResolution.xy       \n                + vec2(0.,h) );\n                \n    // gem color\n    vec3 col = texelFetch(iChannel0, ivec2(coord), 0).rgb;\n    // handle shape\n    float B = texelFetch(iChannel1, ivec2(coord2), 0).x;\n    // handle noise\n    float C = texelFetch(iChannel2, ivec2(coord2), 0).x;\n    \n    // index for handle, gem interior outline\n    int index = randIndex(iFrame, 5. + 1., 0.);\n    \n    // index for gem interior\n    int index2 = randIndex(iFrame, 5. + 1., floor(iDate[3] / float(reset)) - 100.);\n   \n    // color gem\n    if ( col.r == 1. )\n        col = vec3(34,32,52) / 255.;\n    else if ( col.r == 0. )\n        col = vec3(0.);\n    else if (col.g > 0.)\n        col = lightMap(index, col.g - 1.); \n    else if (col.b > 0.)\n        col = darkMap(index2, col.b - 1.); \n        \n    vec3 col2;\n    float t = 100. * C;\n    \n    // color handle\n    if (B == 1.) {\n    \n        // cos with high frequency t generates linework\n        float v = 0.5 * (1. - cos(pi * t));  \n    \n        // shade top lighter, bottom darker\n        v = min(1., v * (0.6 + 0.9 * coord2.y / dimHandle.y));\n\n        // shade left side darker\n        if (coord2.x <= 0.5 * dimHandle.x - 1.)\n            v = max(0., v - 2. / 6.);\n        \n        col2 = handleMap(index, v);\n    }\n    \n    // background\n    else if (B == 0.) {\n        vec2 uv = fragCoord / iResolution.y; \n        uv = mod(1.5 * uv + vec2(0.05 * iTime), 1.);\n        if ((uv.x > 0.5 && uv.y > 0.5) || (uv.x < 0.5 && uv.y < 0.5))\n            col2 = vec3(143,86,59) / 255.;\n        else\n            col2 = vec3(102,57,49) / 255.;\n    } \n    \n    // outline of handle\n    else\n        col2 = vec3(34, 32, 52) / 255.;\n        \n    if (col.x == 0.)\n        fragColor = vec4(col2,1.);\n    else \n        fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// top variants for the gem\nfloat hexTop (int index, vec2 uv) {\n    if (index == 0) // pointy\n        return abs(uv.x) + abs(uv.y);\n    if (index == 1) // right diag / \n        return abs(uv.x - (dimGem.x - 2.)) + abs(uv.y);\n    if (index == 2) // left diag\n        return abs(uv.x + (dimGem.x - 2.)) + abs(uv.y);\n    if (index == 3) // square\n        return uv.x; \n    if (index == 4) // square -> diag\n        return uv.x + uv.y;\n    if (index == 5) // diag -> square\n        return -uv.x + uv.y;       \n}\n\n\nfloat hexagon (int index, vec2 uv, vec2 dim) {\n    // rectangle shape\n    float d = max(dim.y/dim.x * abs(uv.x), abs(uv.y));\n\n    // (modified) diamond shape\n    float d2 = uv.y > 0. ? hexTop(index, uv) \n                         : abs(uv.x) + abs(uv.y);\n\n    // intersect both shapes\n    return step(d, dim.y) * step(d2, dim.y);\n}\n\n// forms ---_-_ shape to color with\nfloat stepHole (float v, float h) {\n    return step(h,v ) + (step(h, v + 2.) - step(h, v + 1.));\n}\n\n// choose length of each ---_-_ segment, depending on gem height \nfloat chooseN(vec2 dimGem) {\n    float h = 2. * dimGem.y;\n    if (h <= 14.)\n        return 2.;\n    if (h <= 21.)\n        return 3.;\n    if (h <= 28.)\n        return 4.;\n    return 5.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    // I think it goes off last value for some reason (maybe update order)\n    vec2 dimgem = setDimGem(iFrame); \n    \n    vec2 uv = coord - dimGem;\n    \n    int index = randIndex(iFrame, 5. + 1., -31.5);\n    \n    // split channels by parts\n    // r: outline, b: interior outline, g: interior\n    vec3 col = vec3(hexagon(index, uv, dimGem) - 0.5 * hexagon(index, uv, dimGem - 1.),\n                    hexagon(index, uv, dimGem - 1.) -  hexagon(index, uv, dimGem - 2.),\n                    hexagon(index, uv, dimGem - 2.));\n    \n    // remove bottom outline so handle and gem don't overlap\n    if (coord.y < 1.)\n        col.r = 0.;\n    \n    // apply shades to interior outline + interior\n    // ( repeatedly run stepHole to get ---_-_ pattern, overlay higher indexes\n    //   min index is 1., and -step(dim.x, fragCoord.x) makes left side darker )\n    vec2 shade = vec2(1.);\n    float n = chooseN(dimGem);\n    for (float i = 1.; i < n; i++) { \n        shade = max(shade, \n                    1. + (n-i) * stepHole(ceil(2. * dimGem.y / n) * i, coord.y)\n                       - step(dimGem.x, coord.x));                  \n    }\n    \n    // make the top bright (white outline wraps around to the left)\n    if (coord.y > 2. * dimGem.y - 2.)\n        shade = vec2(1.);\n        \n    // split the top interior to two shades (left and right)\n    else if (coord.y > 2. * dimGem.y - 4.)\n        shade = vec2(2.- step(dimGem.x, coord.x),1.);\n    \n    col.bg *= shade;\n\n    fragColor = vec4(col, 1.);   \n}", "buffer_a_inputs": [], "common_code": "// change randStart to generate new \"seed\"\nconst float randStart = 123.;\n\n// number of frames each sprite lasts for\nconst int reset = 120;\n\nconst float pi = 3.14519;\n\n\n// ( resetting dims is buggy - seems fine if new value < old value though,\n//   arbitrarily large 500 works fine )\n\n// half gem dimensions \nvec2 dimGem = vec2(500);\n\n// handle dimensions (not half)\nvec2 dimHandle = vec2(500);\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n// get an index for arrays (not optimal at all)\nint randIndex ( int frame, float maxIndex, float offset ) {\n    return int(maxIndex * hash1(randStart + offset +  floor(float(frame) / float(reset))));\n}\n\n// if you want custom width/height, change the values below\nvec2 setDimGem(int frame) {    \n    float gen = randStart + floor(float(frame) / float(reset));\n    float width = round(3. + 3. * hash1(gen));\n    float height = max(2. * width, round(40. * hash1(100. + gen)));\n    return dimGem = vec2(width, height);\n}\n\nvec2 setDimHandle(int frame) {    \n    float gen = randStart + floor(float(frame) / float(reset));\n    float width = 2. * round(10. + 8. * hash1(50. + gen));\n    float height = 2. * round(14. + 12. * hash1(150. + gen));\n    return dimHandle = vec2(width, height);\n}\n\n/*\n\nRough explanation of how this works:\n\nBuffer A: \nGenerates hexagon gem in bottom left of screen.\nWidth, height, top shape and shading are chosen here. (but not color)\n\nBuffer B:\nGenerates shape of handle in bottom left of screen.\nInitial state with noise is generated, then various cellular automata are run on it\nto get an appropriate shape.\nWidth, height of handle are chosen here (sort of).\n\nBuffer C:\nGenerates mirrored noise to color the handle with.\n\nImage:\nTransforms the gem and handle so they are together.\nPicks color schemes for the gem outline, gem interior, and handle.\nOverlays noise from buffer C onto the handle shape.\nDraws a background.\n\n*/", "buffer_b_code": "float random ( vec2 st ) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat Cell( in vec2 p )\n{\n    if (p.x <= dimHandle.x && p.y <= dimHandle.y)\n        return texelFetch(iChannel0, ivec2(p), 0 ).x;    \n    return 0.;\n}\n\nfloat CA ( vec2 px, float e ) {\n    float k = Cell(px+vec2(-1,-1)) + 1.5 * Cell(px+vec2(0,-1)) + Cell(px+vec2(1,-1))\n      + 1.5 * Cell(px+vec2(-1, 0))                       + 1.5 * Cell(px+vec2(1, 0))\n            + Cell(px+vec2(-1, 1)) + 1.5 * Cell(px+vec2(0, 1)) + Cell(px+vec2(1, 1));\n    \n    if ( e == 1. && k < 4.5 )\n        e = 0.;\n    else if ( e == 0. && k > 6. )\n        e = 1.;      \n        \n    return e;\n}\n\nfloat sumNeighbours ( vec2 px ) {\n    return Cell(px+vec2(0, -1)) + Cell(px+vec2(-1, 0)) +\n           Cell(px+vec2(0, 1))  + Cell(px+vec2(1, 0));\n}\n\nfloat prodNeighbours ( vec2 px ) {\n    return (Cell(px+vec2(0, -1)) + Cell(px+vec2(0, 1))) * \n           (Cell(px+vec2(-1, 0)) + Cell(px+vec2(1, 0)));\n}\n\nbool hasWhiteNeighbour ( vec2 px ) {   \n    return sumNeighbours(px) > 0.;\n}\n\nbool isInteriorCorner ( vec2 px, float e ) {\n    return e == 0.5 && prodNeighbours(px) >= 2.25;     \n}\n\nbool isExteriorCorner ( vec2 px, float e ) {\n    return e == 0.5 && sumNeighbours(px) == 1.;\n}\n\nbool isBlackOutlined( vec2 px, float e ) {\n    return e == 0. && sumNeighbours(px) == 2.;\n}\n\nbool wasInDiagCorner( vec2 px, float e ) {\n    // this shouldn't work but somehow it does\n    return e == 1. && prodNeighbours(px) < 2.; \n}\n\nbool isIsolated ( vec2 px ) {\n    return sumNeighbours(px) == 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    setDimHandle(iFrame);\n    \n    vec2 px = coord;    \n    float e = Cell(px);\n    \n    // reset staff after a number of frames\n    int frame = iFrame % reset;\n      \n    // initial state - generate noise\n    if ( frame == 0 && coord.x <= dimHandle.x && coord.y <= dimHandle.y ) {\n      \n        // get symmetric rand value (random works best with low iTime values)\n        float d = abs(0.5 * dimHandle.x - coord.x);    \n        float rand = random(vec2(d , coord.y) + mod(iTime,201.315));\n        \n        // likely horizontal at top\n        if ( coord.y > dimHandle.y - 4.)\n            e = step(0.18, rand);\n            \n        // guarantee exposed \"pole\"\n        else if ( coord.y > 6. && coord.y < 12.)\n            e = 0.;\n            \n        // 50% rand noise in other regions   \n        else\n            e = step(0.5, rand);\n                                \n        // centre cells are 1. ( insert a \"pole\" ) \n        // ( maybe cut out the side values? )\n        e = max(e, step(d, 1.));\n        \n        // cut off edges, so outline will work\n        e *= step(coord.x, dimHandle.x - 2.) * step(2., coord.x) * \n             step(coord.y, dimHandle.y - 2.) * step(2., coord.y);          \n    }\n    \n    // run cellular automata on noise\n    else if ( frame < 5 ) {\n        e = CA(px, e);                 \n    }\n    \n    // reinsert noise at top, so horizontal bit is more likely\n    else if ( frame < 6 && coord.y > dimHandle.y - 4. \n              && coord.x <= dimHandle.x && coord.y <= dimHandle.y) {\n              \n        float d = abs(0.5 * dimHandle.x - coord.x);    \n        float rand = random(vec2(d , coord.y) + mod(iTime,201.315));\n        \n        e = step(0.18, rand);\n        \n        // cut off edges, so outline will work\n        e *= step(coord.x, dimHandle.x - 2.) * step(2., coord.x) * \n             step(coord.y, dimHandle.y - 2.) * step(2., coord.y);    \n    }\n    \n    // run cellular automata on noise again\n    else if ( frame < 10 ) {\n        e = CA(px, e);                 \n    }\n        \n    // re-insert centre cells so a \"pole\" definitely exists\n    else if ( frame < 11 ) {\n        e = min(1., \n            e + step(coord.y, dimHandle.y) \n            * step(2., coord.y) \n            * max(e, step(abs(0.5 * dimHandle.x - coord.x), 1.)));\n    } \n    \n    // generate outline\n    else if ( frame < 12 )\n        e = (e == 0. && hasWhiteNeighbour(px)) ? .5 : e;\n    \n    // remove interior outlines + interior (axis-aligned) corners\n    else if ( frame < 17 )\n        e = (isInteriorCorner(px, e) || isBlackOutlined(px, e)) ? 1. : e;\n    \n    // remove exterior (diagonal) corner outlines\n    else if ( frame < 18 )\n        e = isExteriorCorner(px, e) ? 0. : e;\n    \n    // turn newly exposed bits into outlines\n    else if ( frame < 19)\n        e = wasInDiagCorner(px, e) ? 0.5 : e;\n    \n    // remove any corners formed from deleting diagonal corners\n    else if ( frame < 20 ) \n        e = isExteriorCorner(px, e) ? 0. : e;\n    \n    // one more for good luck ( remove pixels without any neighbours )\n    else if ( frame < 21 ) \n        e = isIsolated(px) ? 0. : e;\n    \n    // remove artifacts ( sloppy )\n    else if ( frame == reset - 1 )\n        e = 0.;\n        \n  fragColor = vec4(e);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Most of this code was stolen from iq:\n// https://www.shadertoy.com/view/Msf3WH\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// generate mirrored noise\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    setDimHandle(iFrame);\n\n    // uncomment iTime for a cool look\n    vec2 uv = vec2(abs(coord.x - 0.5 * dimHandle.x), coord.y)\n            + 20. * floor(float(iFrame) / float(reset));// + iTime;\n \n\tfloat f = 0.0;\n\t\n\tuv *= 0.01;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf =  0.5000 * noise( uv ); uv = m*uv;\n    f += 0.2500 * noise( uv ); uv = m*uv;\n\tf += 0.1250 * noise( uv ); uv = m*uv;\n\tf += 0.0625 * noise( uv ); uv = m*uv;\n\t\n\tf = 0.5 + 0.5 * f;\n\n    fragColor = vec4(f);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3026, 3026, 3083, 3083, 5401]]}
{"id": "7lSSD3", "name": "Pixels to circles", "author": "radiator", "description": "Avg pool -> birgtness -> circle radius", "tags": ["shader"], "likes": 1, "viewed": 336, "published": 3, "date": "1628755309", "time_retrieved": "2024-07-30T19:06:37.593721", "image_code": "#define t iTime\n#define r iResolution.xy\n\n\n\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    int pool_size = 10;\n    vec2 fragCoodStep = vec2(float(int(fragCoord.x/float(pool_size)))*float(pool_size), float(int(fragCoord.y/float(pool_size)))*float(pool_size));\n    \n    // don't overindex\n    if ( (fragCoord.x < (iResolution.x-float(pool_size))) && (fragCoord.y < (iResolution.y-float(pool_size))) ){\n    \n        // average pooling\n        vec4 b = vec4(0);\n        for(int i=0;i<pool_size;i++) {\n            for(int k=0;k<pool_size;k++) {\n                b = b + (texture(iChannel0, vec2(fragCoodStep.x+float(i), fragCoodStep.y+float(k))/iResolution.xy));\n            }\n        }\n        b /= float(pool_size*pool_size);\n        \n        // current circle size\n        float s = (b.x + b.y + b.z)/3.0;\n\n        // Background layer\n        vec4 layer1 = vec4(0.0, 0.0, 0.0, 1.0);\n        // Circle\n        vec3 cicrle_color = vec3(b.x, b.y, b.z);\n        vec4 layer2 = circle(fragCoord.xy, fragCoodStep+float(pool_size)/2., float(pool_size)/2.0*s, cicrle_color);\n        \n        // Blend the two\n        fragColor = mix(layer1, layer2, layer2.a);\n   }\n}\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 99, 99, 197], [199, 199, 255, 255, 1323]]}
{"id": "ftBSDc", "name": "Blending Experiment", "author": "iY0Yi", "description": "When I watched iq's tutorial, I find that he passed a dynamic value for a blend value of smoothmin().\nThat seemed very interesting, so I did an experiment.\nIt is very powerful!\n\nthe tut:\nhttps://www.youtube.com/watch?v=8--5LwHRhjk", "tags": ["blending", "smoothminimum"], "likes": 16, "viewed": 517, "published": 3, "date": "1628743198", "time_retrieved": "2024-07-30T19:06:38.594046", "image_code": "vec4 sd001(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\td = sdSphere(p+vec3(2.397, -5.01+(cos(iTime*.05)*.5+.5), -6.63), .944);\n\td = fOpUnionSmooth(sdSphere(p+vec3(-2.956*(sin(iTime*.05)*.5+.5), -11.227, 4.618), .944), d, .66);\n\tres = v4OpUnion(vec4(d, MAT_COL0_COL), res);\n\n    R(p.xz, iTime*.1);\n\td = sdBox(rot(p+vec3(-3.052, -3.359+(sin(iTime*.03)*.5+.5)*2., 5.2), vec3(0., -.24, 0.)), vec3(3.31, 3.31, .496)-0.)-0.;\n            \n\n    float cupsule0_blend;{\n\t\tvec3 q = rot(p+vec3(-3.395, -3.831, -.618), vec3(-.09, .1, -.448));\n\t\tcupsule0_blend = 5.5;\n\t\tfloat k = 12.;\n\t\tcupsule0_blend *= pow(sin(clamp(q.y*k, 2.*k, 8.*k))*.5+.5, .05)*.5+.5;\n\t}\n\td = fOpUnionSmooth(sdCapsule(rot(p+vec3(-3.395, -3.831, -.618), vec3(-.09, .1, -.448)), 0., 2.759), d, cupsule0_blend);\n\n    float cupsule1_blend;{\n\t\tvec3 q = rot(p+vec3(-.787, -3.237, -4.655), vec3(-.09, .1, -.448));\n\t\tcupsule1_blend = 5.5;\n\t\tfloat k = 12.*(cos(iTime*.05)*.5+.5);\n\t\tcupsule1_blend *= pow(sin(clamp(q.y*k+(sin(iTime*.05)*.5+.5), 2.*k, 8.*k))*.5+.5, .1)*.5+.5;\n\t}\n\td = fOpUnionSmooth(sdCapsule(rot(p+vec3(-.787, -3.237, -4.655), vec3(-.09, .1, -.448)), .278, 1.283), d, cupsule1_blend);\n\n\tres = v4OpUnionSmooth(vec4(d, MAT_COL1_COL), res, cupsule1_blend);\n\n\td = sdPlane(p);\n\tres = v4OpUnion(vec4(d, MAT_COL2_COL), res);\n\treturn res;\n}\n\nvec4 sd000(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\td = sdTorus(p+vec3(-1.11, -10.441*(cos(iTime*.05)*.5+.5), .846), vec2(4.47+sin(iTime*.08), .02));\n\tres = v4OpUnion(vec4(d, MAT_COL0_COL), res);\n\treturn res;\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp = p;\n\tcp.xyz += vec3(1.93, -5.478, -.161);\n\tcp.xyz = rot(cp, vec3(2.965, 1.047, -.356));\n\n\td = sdSphere(p+vec3(2.302, -5.301, -3.858), 1.25);\n\td = fOpUnion(sdSphere(p+vec3(-5.972, -10.991, 7.07), 1.25), d);\n\td = fOpUnion(sdSphere(p+vec3(2.733, -8.5, -5.388), 1.127*(sin(iTime*.05)*.5+.5)), d);\n\tres = v4OpUnion(vec4(d, MAT_COL4_COL), res);\n\n    float sd001_blend;{\n\t\tvec3 q = p;\n\t\tsd001_blend = 5.5+(cos(iTime*.03)*.5+.5);\n\t\tfloat k = 12.;\n\t\tsd001_blend *= pow(sin(clamp(q.y*k*(cos(iTime*.025)*.5+.5), 2.*k, 8.*k))*.5+.5, .05)*.5+.5;\n\t}\n\tres = v4OpUnionSink(sd001(p), res, 1.107, 0.);\n\n    float box0_blend;{\n\t\tvec3 q = rot(cp+vec3(1.418, 3.407, -3.595), vec3(-.251, -.01, -.133));\n\t\tbox0_blend = 5.5;\n\t\tfloat k = 12.;\n\t\tbox0_blend *= pow(sin(clamp(q.y*k*(sin(iTime*.1)*.5+.5), 2.*k, 8.*k))*.5+.5, .05)*.5+.5;\n\t}\n\td = sdBox(rot(cp+vec3(1.418, 3.407, -3.595), vec3(-.251, -.01, -.133)), vec3(2.821, 2.821, 2.821)-0.)-0.;\n\tres = v4OpUnionSmooth(vec4(d, MAT_COL3_COL), res, box0_blend);\n\n\td = sdSphere(p+vec3(.229, -11.379, -2.071), 1.25);\n\td = fOpUnion(sdSphere(p+vec3(-4.138, -4.61, 5.165), 1.25), d);\n\tres = v4OpUnion(vec4(d, MAT_COL4_COL), res);\n\n\tres = v4OpUnionSmooth(sd000(rot(p+vec3(3.86, -6.739, -7.648), vec3(1.11, .278, .386))), res, 4.17);\n    \n    res+=texture(iChannel0, p*8.)*min(.001, distance(res.yzw, MAT_COL4_COL));\n\treturn res;\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p){\n\tfloat c=sdScene(p).x;\n\tfloat e=MIN_DIST*.1;\n\treturn normalize(vec3(\n\t\tsdScene(p+vec3(e,0.,0.)).x-c,\n\t\tsdScene(p+vec3(0.,e,0.)).x-c,\n\t\tsdScene(p+vec3(0.,0.,e)).x-c)\n\t);\n}\n\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n\t\tres = min( res, k*h/t);\n\t\tt += h;\n\t\tif( res<0.001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 12;\n\tconst float nbIteInv = 1./float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n\n\tfloat ao = 0.0;\n\n\tfor( int i=0; i<nbIte; i++ ){\n\t\tfloat l = hash11(float(i))*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal// for self occlusion problems!\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvoid render(vec2 uv){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n        R(uv, -PI*.125);\n\t\trenDat.result = mix(FOG_COL, FOG_COL*.025, uv.y);\n\t}\n\telse{\n\t\trenDat.albedo = res.yzw;\n\n\t\tvec3 n = normal(p);\n\n        float lamb1 = sat(dot(n, lit0.direction))*(1./PI);\n        \n\t\tfloat lamb2 = sat(dot(n, lit1.direction))*(1./PI);\n        if(distance(res.yzw, MAT_COL4_COL)<.01){\n            lamb1 = (dot(n, lit0.direction)*.5+.5)*(1./PI);\n            renDat.shadow = 1.;\n        }else{\n            renDat.shadow = shadow(p+n*.0001, n);\n        }\n\n\t\trenDat.ao =  ambientOcclusion(p+n*.0001, n, .1, 2.5);\n\t\trenDat.ao += ambientOcclusion(p+n*.0001, n, .5, 5.);\n\t\trenDat.ao += ambientOcclusion(p+n*.0001, n, 2., 3.);\n\t\trenDat.ao += ambientOcclusion(p+n*.0001, n, 4., 2.);\n\t\trenDat.ao = smoothstep(0., 4., renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\t\n\n\t\tfloat shininess = .6;\n\t\tfloat shininessRef = .5;\n\t\tfloat intensity = .2;\n\t\tif(distance(MAT_COL0_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL0_SPEC.y;\n\t\t\tintensity = MAT_COL0_SPEC.x;\n\t\t}\n\t\tif(distance(MAT_COL1_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL1_SPEC.y;\n\t\t\tintensity = MAT_COL1_SPEC.x;\n\t\t}\n\t\tif(distance(MAT_COL2_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL2_SPEC.y;\n\t\t\tintensity = MAT_COL2_SPEC.x;\n\t\t}\n\t\tif(distance(MAT_COL3_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL3_SPEC.y;\n\t\t\tintensity = MAT_COL3_SPEC.x;\n\t\t}\n\t\tif(distance(MAT_COL4_COL,renDat.albedo)<.01)\n\t\t{\n\t\t\tshininess = MAT_COL4_SPEC.y;\n\t\t\tintensity = MAT_COL4_SPEC.x;\n\t\t}\n        \n        #define ggx(roughness, N, V, L) ggx(N, -V, L, roughness, .6)\n\t\tfloat ref = BlinnPhongRef(shininessRef*.9, n, ray.direction, lit0.direction);\n\t\tfloat spec = ggx(shininess, n, ray.direction, lit0.direction);\n        renDat.diffuse *= sms(-.1, .25, pow(ref, 1.25));\n        renDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\t\trenDat.specular = spec*intensity;\n        renDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao*.25);\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH*.5);\n\t\trenDat.result*= renDat.albedo;\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow);\n\t\trenDat.depth = distance(ray.origin, p)/MAX_DIST;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\nvoid init(){\n    cam0.position = vec3(50.053, 3.884, 33.315);\n\tcam0.quaternion = vec4(.342, .646, .603, .319);\n\tcam0.fov = .135;\n\tcam0.orthoDist = 0.;\n\tcam0.orthoScale = 0.;\n\n\tlit0.direction = normalize(vec3(.363, .765, .532));\n\tlit0.color = vec3(1., 1., 1.);\n\tlit0.shadowStart = .05;\n\tlit0.shadowEnd = 30.;\n\tlit0.shadowSoft = 50.;\n\tlit1.direction = normalize(vec3(-.363, -.765, -.532));\n\tlit1.color = vec3(.3, .3, .3);\n\tlit1.shadowStart = .05;\n\tlit1.shadowEnd = 30.;\n\tlit1.shadowSoft = 50.;\n}\n\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}\nvoid camera(vec2 uv){\n\tvec3 dir = quat_rotate(cam0.quaternion, vec3(0,0,-1)).xzy;\n\tvec3 up = quat_rotate(cam0.quaternion, vec3(0,1,0)).xzy;\n\tvec3 pos = cam0.position;\n\tfloat fov = cam0.fov;\n    \n    if(mod(floor(iTime/3.),2.)==0.){\n        fov=.02;\n        float i = floor(iTime/4.);\n        pos.xy += (vec2(hash11(i+1.),hash11(i*i+2.))*.5-.5)*8.;\n    }\n    if(iTime<2.){\n        fov = cam0.fov;\n        pos = cam0.position;\n    }\n\tvec3 target = pos-dir;\n\n\tvec3 cw = normalize(target - pos);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tcam0.up = up;\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender(uv);\n    fragColor = vec4(pow(renDat.result*1.25,vec3(.4545)), 1.) * smoothstep(0., 3., iTime);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31271, "src": "https://soundcloud.com/absorb-label/e1-con-pani", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define PI acos(-1.)\n#define MIN_DIST .001\n#define MAX_DIST 500.0\n#define ITERATION 200\n\n#define sat(x) clamp(x, 0., 1.)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\nstruct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n\tvec3 up;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\n\n#define MAT_VOID vec3(-1)\n#define MAT_COL1_COL vec3(.8, .601, .365)\n#define MAT_COL1_SPEC vec3(.728, .242, 0.)\n#define MAT_COL4_COL vec3(0.835,0.773,0.584)\n#define MAT_COL4_SPEC vec3(.026, .295, 0.)\n#define MAT_COL3_COL vec3(.598, .855, .393)\n#define MAT_COL3_SPEC vec3(.57, .391, 0.)\n#define MAT_COL0_COL vec3(.711, .221, .017)\n#define MAT_COL0_SPEC vec3(.14, .119, 0.)\n#define MAT_COL2_COL vec3(.115, .093, .064)\n#define MAT_COL2_SPEC vec3(0., .172, 0.)\n\n#define AMB_COL vec3(.615, .615, .615)\n#define AMB_STRENGTH .14\n#define FOG_COL vec3(.22, .178, .081)\n#define FOG_START .0\n#define FOG_POW 1.0\n\n// \"hash11()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n\nfloat vmax(vec3 v){\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r){\n\tfloat k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(vec3 p, float r, float c){\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sdBox(vec3 p,vec3 b){\n\tvec3 d=abs(p)-b;\n\treturn length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tr*=1.35;\n\tfloat h = max( r-abs(a-b), 0.0 )/r;\n    return min( a, b ) - h*h*h*r*(1.0/6.0);\n}\n\nvec4 v4OpUnionSmooth(vec4 a,vec4 b,float r){\n\tfloat h=clamp(0.5+0.5*(b.x-a.x)/r,0.0,1.0);\n\tfloat res = mix(b.x,a.x,h)-r*h*(1.0-h);\n\treturn vec4(res, mix(b.yzw,a.yzw,h));\n}\n\n// Custom Boolean Example: UnionSink\nfloat fOpUnionSink(float a, float b, float r, float n) {\n\tvec2 p = vec2(a, b);\n\tfloat rad = r*sqrt(2.)/(2.+sqrt(2.));\n\tp.x -= sqrt(2.)/2.*r;\n\tp.x += rad*sqrt(2.0);\n\tp.y -= rad;\n\tfloat d = length(p+vec2(0,n)) - rad;\n\td = fOpUnionSmooth(d, b, p.x);\n\td = min(d, a);\n\treturn d;\n}\n\nvec4 v4OpUnionSink(vec4 a, vec4 b, float r, float n) {\n\tvec2 p = vec2(a.x, b.x);\n\tfloat rad = r*sqrt(2.)/(2.+sqrt(2.));\n\tp.x -= sqrt(2.)/2.*r;\n\tp.x += rad*sqrt(2.0);\n\tp.y -= rad;\n\tfloat d = length(p+vec2(0,n)) - rad;\n\td = fOpUnionSmooth(d, b.x, p.x);\n\td = min(d, a.x);\n\treturn vec4(d, (d==a.x)?a.yzw:b.yzw);\n}\n\n// Phong specular\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 reflect_light = normalize(reflect(ld, n));\n\treturn pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\treturn 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tfloat norm_factor = (shininess+1.) / (2.*PI);\n\tvec3 h  = normalize(-vd+ld);\n\treturn pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n\tvec3 h  = normalize(-vd+ld);\n\treturn 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n// https://www.shadertoy.com/view/wljSz1\n// http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0){\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n// \"Hemispherical SDF AO\" by XT95:\n// https://www.shadertoy.com/view/4sdGWN\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBSDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 1323], [1325, 1325, 1344, 1344, 1563], [1565, 1565, 1586, 1586, 3005], [3007, 3007, 3024, 3024, 3319], [3321, 3321, 3341, 3341, 3512], [3514, 3514, 3543, 3543, 3836], [3838, 3838, 3921, 3921, 4395], [4397, 4397, 4418, 4418, 6950], [6952, 6952, 6964, 6964, 7445], [7447, 7447, 7485, 7485, 7561], [7562, 7562, 7583, 7583, 8298], [8300, 8300, 8354, 8354, 8682]]}
{"id": "stjSWV", "name": "polar coord tutorial", "author": "jcyuan", "description": "polar coord tutorial", "tags": ["tutorial", "polar"], "likes": 0, "viewed": 114, "published": 3, "date": "1628735235", "time_retrieved": "2024-07-30T19:06:39.457736", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // -11\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // uvla\n    float l = length(uv);\n    \n    // atan2PI2N\n    float a = atan(uv.y, uv.x) / 6.28318 * 2.\n              +\n              // ()\n              l * 2.\n              -\n              // \n              iTime;\n              \n    a = fract(a);   // 01\n    \n    // \n    vec3 col = vec3(mix(vec3(1., 0., 0.), vec3(0., 1., 0.), a));\n\n    fragColor = vec4(col, 1.);\n}\n\n// \n// fract(uv * Nuv / N)uv\n// N\n// \n// 1310\n// \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 102, 897]]}
{"id": "ftSSWc", "name": "Stepped Spiral", "author": "kroltan", "description": "Move the mouse around to change the threshold", "tags": ["mask"], "likes": 1, "viewed": 243, "published": 3, "date": "1628728855", "time_retrieved": "2024-07-30T19:06:40.301480", "image_code": "const float RADIUS = 60.0;\nconst float TAU = 6.283;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy / 2.0;\n    vec2 relative = fragCoord - center;\n    \n    float dist = length(relative);\n    float angle = atan(relative.y, relative.x) + TAU / 2.0;\n    \n    float threshold = iMouse.x / iResolution.x * 20.0;\n    \n    fragColor = vec4(angle - (threshold - floor(dist / RADIUS) * TAU));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 110, 110, 429]]}
{"id": "NtSSD3", "name": "Simple function plotter gadget", "author": "qwzy", "description": "Use it for graphing functions to see if they do what you think they're gonna do.", "tags": ["math", "graphing"], "likes": 3, "viewed": 257, "published": 3, "date": "1628718196", "time_retrieved": "2024-07-30T19:06:41.130265", "image_code": "float f(float x) {\n    return sin(5.0 * x) * cos(3.0 * x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x = 5.0 * uv.x - 2.5;\n    uv.y = 4.0 * uv.y - 1.5;\n    \n    fragColor = vec4(1.0);\n    \n    fragColor = (fract(uv.x) < 0.01) ? vec4(0.9) : fragColor;\n    fragColor = (fract(uv.y) < 0.01) ? vec4(0.9) : fragColor;\n\n    fragColor = (abs(uv.x) < 0.01) ? vec4(0.0) : fragColor;\n    fragColor = (abs(uv.y) < 0.01) ? vec4(0.0) : fragColor;\n    \n    fragColor = (abs(f(uv.x) - uv.y) < 0.02) ? vec4(1.0, 0.0, 0.0, 1.0) : fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSSD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 60], [62, 62, 119, 119, 593]]}
{"id": "NlSXW3", "name": "Glacial moraines", "author": "jarble", "description": "A flowing glacial landscape.\nThis is based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "mountain", "glacier", "moraine"], "likes": 2, "viewed": 255, "published": 3, "date": "1628714483", "time_retrieved": "2024-07-30T19:06:42.062771", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 4\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = -3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += vec2(sin(uv.x*factor)/factor,cos(uv.y/factor)*factor).yx;\n        value = 1.+max(value+value*sin(uv.x/factor)/factor,value+cos((uv.y/factor)/factor)/factor);\n        uv += max(uv,uv.yx);\n        uv /= factor/1.5;\n        if(i%2 == 0){\n           uv = -uv.yx;\n        }\n        \n        //factor /= 1.5;\n        \n    }\n    \n    return value;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 1.5;\n    return fbm(uv/factor);\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*(iTime+11.));\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSXW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 511, 560, 1025], [1099, 1099, 1137, 1137, 1190], [1192, 1192, 1225, 1225, 1445], [1447, 1447, 1485, 1485, 1712], [1714, 1714, 1752, 1752, 1976], [1978, 1978, 2007, 2007, 2102], [2104, 2104, 2141, 2141, 2200], [2203, 2271, 2290, 2290, 2329], [2331, 2331, 2351, 2351, 2427], [2429, 2429, 2448, 2448, 2487], [2489, 2489, 2546, 2546, 2781], [2783, 2783, 2818, 2818, 3212], [3214, 3214, 3268, 3268, 3934], [3937, 3937, 3989, 3989, 4424], [4426, 4426, 4483, 4483, 5674]]}
{"id": "stjXWV", "name": "short infinite maze", "author": "FabriceNeyret2", "description": "WIP.\nTrying to mimick infinite zoom of https://www.shadertoy.com/view/fl2SDV\nwith the 65 chars procedural base of https://shadertoy.com/view/lt2cRR\nOf course I miss LOD connections + auto-solve", "tags": ["maze", "short", "golf"], "likes": 10, "viewed": 348, "published": 3, "date": "1628699905", "time_retrieved": "2024-07-30T19:06:42.924467", "image_code": "// Trying to mimick infinite zoom of https://www.shadertoy.com/view/fl2SDV\n// with the procedural base of \"shortest maze 5 (65 chars)\" https://shadertoy.com/view/lt2cRR\n\nvoid mainImage(out vec4 O, vec2 u) {\n\n    float s = .33 + .67* exp2( mod(iTime,2.) ), k = 1., z = 0.;\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y / s, I,V;\n          \n    for ( O-=O; z < 5.; U*=3., k*=3., z++ )         // fractal levels\n       I = floor(abs(U/1.5)+.5),\n       max(I.x,I.y) == 1.?                          // draw maze tile\n            V = ( U+z+floor(iTime/2.) ) *16. + 4.,  // offset level seed\n            O += mod( V [ int( 1e4*length(ceil(V/8.)) ) % 2 ] , 8. ) *s/k *R.y/72. :O;\n}               // heart of base golfed maze                         // 1 pixel width", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 206, 206, 689]]}
{"id": "stjSDK", "name": "Rectangle-Circle Intersection", "author": "rexim", "description": "Supplementary Shader for a Tsoding Session: https://www.youtube.com/watch?v=5r-8JCOsJwA", "tags": ["education", "geometry", "tsoding"], "likes": 4, "viewed": 387, "published": 3, "date": "1628686218", "time_retrieved": "2024-07-30T19:06:43.814089", "image_code": "bool rect_contains_point(vec2 p1, vec2 p2, vec2 p) {\n    return p1.x <= p.x && p.x <= p2.x &&\n           p1.y <= p.y && p.y <= p2.y;\n}\n\nbool circle_contains_point(vec2 c, float r, vec2 p) {\n    return length(c - p) <= r;\n}\n\nvec2 closest_point(vec2 p1, vec2 p2, vec2 c) {\n    float x = max(p1.x, min(p2.x, c.x));\n    float y = max(p1.y, min(p2.y, c.y));\n    return vec2(x, y);\n}\n\n#define WIDTH 1600.0\n#define HEIGHT 900.0\n\nvec2 remap(vec2 p)\n{\n    return p/iResolution.xy*vec2(WIDTH, HEIGHT);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = remap(fragCoord.xy);\n\n    vec2 size = vec2(150.0*3.0, 100.0*3.0);\n    vec2 p1 = vec2(WIDTH*0.5-size.x*0.5, HEIGHT*0.5-size.y*0.5);\n    vec2 p2 = p1 + size;\n\n    vec2 c = remap(iMouse.xy);\n    float r = 100.0;\n\n    vec2 cp = closest_point(p1, p2, c);\n\n    fragColor = vec4(0.0);\n    \n    if (rect_contains_point(p1, p2, p)) {\n        fragColor += vec4(.0, .0, 1.0, 0.0);\n    }\n    \n    if (circle_contains_point(c, r, p)) {\n        if (length(c - cp) <= r) {\n            fragColor += vec4(1.0, 0.0, 0.0, 0.0);\n        } else {\n            fragColor += vec4(.0, 1.0, 0.0, 0.0);\n        }\n    }\n    \n    if (circle_contains_point(cp, 10.0, p)) {\n        fragColor += vec4(1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 134], [136, 136, 189, 189, 222], [224, 224, 270, 270, 377], [422, 422, 442, 442, 493], [495, 495, 552, 552, 1248]]}
{"id": "fl2SDV", "name": "infinite maze", "author": "FabriceNeyret2", "description": "porting Own_Army5576's https://www.desmos.com/calculator/hnsjwwp02s\n\n( of course it would be cooler with a procedural maze + trajectory :-D \n  Sketched here: https://www.shadertoy.com/view/stjXWV \n)", "tags": ["infinite", "maze"], "likes": 43, "viewed": 577, "published": 3, "date": "1628679625", "time_retrieved": "2024-07-30T19:06:44.703710", "image_code": "// porting Own_Army5576's  https://www.desmos.com/calculator/hnsjwwp02s\n// see https://old.reddit.com/r/desmos/comments/ovpnyg/desmos_challenge_12_mazes/h7k89oz/\n\n// draw line segment https://www.shadertoy.com/view/llySRh\nfloat D(vec2 p, vec2 a, vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    p -= b * h;\n    return dot(p,p);\n}\n#define S(v) smoothstep( 9./R.y, 0., v )    \n\n// draw poly-line.  NB: GLSL func can't have vec2[] parameter  macro\n#define L( U, L, n, s )                                          \\\n    for( a = L[i=0] ; i < n ; a=b, i++ ) {                       \\\n        b = L[i];                                                \\\n        if (b.x==99.) a = L[++i], b = L[++i];                    \\\n        m = min(m, D(U,a*s,b*s) );                               \\\n    } \n\n// maze tile\nvec2 L[] = vec2[] (\n    vec2(5,-5),vec2(3,-5),vec2(3,-7),vec2(  1,-7),vec2(1,-9),vec2(9,-9),vec2(9,9),vec2(-9,9),vec2(-9,-9),vec2(-1,-9),vec2(-1,-5),vec2(1,-5),vec2(1,-3),vec2(99),\n    vec2(3,-3),vec2(7,-3),vec2(7,-7),vec2(7,7),vec2(99),\n    vec2(5,-9),vec2(5,-7),vec2(99),\n    vec2(5,9),vec2(5,3),vec2(99),\n    vec2(5,-1),vec2(5,1),vec2(3,1),vec2(3,7),vec2(99),\n    vec2(1,9),vec2(1,5),vec2(99),\n    vec2(-1,3),vec2(-1,7),vec2(99),\n    vec2(-3,9),vec2(-3,5),vec2(-5,5),vec2(-5,1),vec2(-5,5),vec2(-7,5),vec2(-7,7),vec2(-5,7),vec2(99),\n    vec2(-3,-1),vec2(-7,-1),vec2(-7,3),vec2(-7,-3),vec2(-5,-3),vec2(99),\n    vec2(-7,-5),vec2(-3,-5),vec2(-3,-3),vec2(-3,-7),vec2(-7,-7),vec2(99),\n    vec2(1,-3),vec2(3,-3),vec2(3,3),vec2(-3,3),vec2(-3,-3),vec2(-1,-3)\n  );\n// solved trajectory  \nvec2 T[] = vec2[] ( \n   vec2(0,-9),vec2(0,-6),vec2(2,-6),vec2(2,-4),vec2(4,-4),vec2(6,-4),vec2(6,-6),vec2(6,-8),vec2(8,-8),vec2(8,-6),vec2(8,-4),vec2(8,-2),vec2(8,0),\n   vec2(8,2),vec2(8,4),vec2(8,6),vec2(8,8),vec2(6,8),vec2(6,6),vec2(6,4),vec2(6,2),vec2(4,2),vec2(4,4),vec2(4,6),vec2(4,8),vec2(2,8),vec2(2,6),\n   vec2(2,4),vec2(0,4),vec2(0,6),vec2(0,8),vec2(-2,8),vec2(-2,6),vec2(-2,4),vec2(-4,4),vec2(-4,2),vec2(-4,0),vec2(-6,0),vec2(-6,2),vec2(-6,4),\n   vec2(-8,4),vec2(-8,2),vec2(-8,0),vec2(-8,-2),vec2(-8,-4),vec2(-8,-6),vec2(-8,-8),vec2(-6,-8),vec2(-4,-8),vec2(-2,-8),vec2(-2,-6),vec2(-2,-4),vec2(0,-4),vec2(0,-3) \n  );\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 3.*( 2.*u - R ) / R.y, a,b;\n\n    float s = .33+.67*exp2( mod(iTime,2.) ), // original: 1. + mod(iTime,2.);\n          m =  99., l;\n    \n    int i,z,p = T.length(), n = int(26.5*(s-1.)+1.);\n    for ( z=0; z < 3; s/=3., z++ ) {                    // fractal levels\n        if (z==2) p = n;                                // full L0,L1, evol L2\n        L( U, T, p, s);                                 // draw trajectory tile\n    }\n    l = m; s*=27.;\n    \n    for ( z=0; z < 6; s/=3., z++ )                      // fractal levels\n        L( U, L, L.length(), s );                       // draw maze tile\n\n    O = vec4(1);                                        // paint\n    O -= m==l ? S( sqrt(m) - 20./R.y ) * vec4(0,1,1,0)\n              : vec4( S( sqrt(m)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2SDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 222, 255, 255, 367], [2250, 2250, 2288, 2288, 3090]]}
{"id": "Nt2SDV", "name": "animated lines", "author": "jcyuan", "description": "practice on line drawing and the ways to smooth them, for curved lines i used the tech from IQ's article:\nhttps://iquilezles.org/articles/distance/\nThe origin idea is from one picture on https://thebookofshaders.com/05", "tags": ["line", "sin", "cos", "animation"], "likes": 16, "viewed": 617, "published": 3, "date": "1628674629", "time_retrieved": "2024-07-30T19:06:45.730964", "image_code": "#define PI 3.141592653589793\n\nconst float CYCLE = 2.;\nconst float R = .35;\nconst float CenterX = .65;\nconst float PadRight = .15;\nconst vec3 GreyColor = vec3(.8);\n\nfloat circle(in vec2 p, in float r, bool solid) {\n     float d = length(p) - r;\n     return solid ? d : abs(d);\n}\nfloat circle(in vec2 p, in float r) {\n    return circle(p, r, false);\n}\n\nfloat line(in vec2 p, in vec2 p0, in vec2 p1, bool solid) {\n    vec2 pa = p - p0, ba = p1 - p0;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float d = length(pa - ba * h);\n    return solid ? d : abs(d);\n}\nfloat line(in vec2 p, in vec2 p0, in vec2 p1) {\n    return line(p, p0, p1, false);\n}\n\nfloat box(in vec2 p, in vec2 b, bool solid) {\n    vec2 d = abs(p) - b;\n    float s = length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n    return solid ? s : abs(s);\n}\nfloat box(in vec2 p, in vec2 b) {\n    return box(p, b, false);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n    float fw = length(fwidth(uv));\n    float DotSize = fw * 1.5;\n    \n    float CS = cos(iTime * CYCLE);\n    float SS = sin(iTime * CYCLE);\n    \n    float rightArea = step(uv.x, CenterX);\n    vec3 col = vec3(0.);\n    \n    float d = 0.;\n    \n    float axis = min(line(uv, vec2(-5., 0.), vec2(5., 0.)), line(uv, vec2(CenterX, -5.), vec2(CenterX, 5.)));\n    d = axis;\n    \n    vec2 offset = (vec2(CenterX, 0.) + PadRight + R) * vec2(-1., 1.);\n    vec2 circlePos = uv + offset;\n    float mainCircle = circle(circlePos, R);\n    d = min(mainCircle, d);\n    \n    vec2 posOnCircle = vec2(CS, SS) * R - offset;\n    \n    float circleDot = circle(circlePos, DotSize, true);\n    float circleDot2 = circle(posOnCircle - uv, DotSize, true);\n    d = min(circleDot, d);\n    d = min(circleDot2, d);\n    \n    float pointerLine = line(uv, -offset, posOnCircle);\n    d = min(pointerLine, d);\n    \n    float xLine = line(uv, posOnCircle, vec2(posOnCircle.x, 0.));\n    float yLine = line(uv, posOnCircle, vec2(CenterX, posOnCircle.y));\n    d = min(xLine, d);\n    d = min(yLine, d);\n    float xLineDot = circle(uv - vec2(posOnCircle.x, 0.), DotSize, true);\n    float yLineDot = circle(uv - vec2(CenterX, posOnCircle.y), DotSize, true);\n    d = min(xLineDot, d);\n    d = min(yLineDot, d);\n    \n    col = vec3(smoothstep(-fw, fw, d));\n    \n    float maskBox = box(uv - vec2(CenterX - 2., .5), vec2(2., .5), true);\n    maskBox = min(maskBox, box(uv - vec2(-2., -.5), vec2(4., .5), true));\n    vec2 centerPos = uv - vec2(CenterX, 0.);\n    float quatCircle1 = circle(centerPos, PadRight);\n    float quatCircle2 = circle(centerPos, PadRight + R);\n    float quatCircle3 = circle(centerPos, PadRight + R * 2.);\n    float qd = max(quatCircle1, -maskBox);\n    qd = min(max(quatCircle2, -maskBox), qd);\n    qd = min(max(quatCircle3, -maskBox), qd);\n    \n    col = mix(GreyColor, col, smoothstep(-fw, fw, qd));\n    \n    float cs01 = CS * .5 + .5;\n    float csY = cs01 * R * 2.;\n    float animCircle = circle(centerPos, PadRight + csY);\n    float qd2 = max(animCircle, -maskBox);\n    float yLineDot2 = circle(uv - vec2(CenterX, PadRight + csY), DotSize, true);\n    qd2 = min(yLineDot2, qd2);\n    \n    col *= smoothstep(-fw, fw, qd2);\n    \n    vec2 wave = vec2(\n        sin((uv.x - CenterX) / R + iTime * CYCLE) * R,\n        cos((uv.x - CenterX) / R + iTime * CYCLE) * R\n    );\n    vec2 dWave = wave.yx / R;\n    vec2 baseY = vec2(uv.y + R + PadRight, uv.y - R - PadRight);\n    // https://iquilezles.org/articles/distance\n    vec2 waveLines = 1. - smoothstep(fw, -fw, abs(wave - baseY) / sqrt(1. + dWave * dWave)) * rightArea;\n    vec3 waveColor = vec3(waveLines.x * waveLines.y);\n    \n    col *= waveColor;\n    \n    float maskBar = box(vec2(-5., uv.y - PadRight - R), vec2(5. + CenterX, R), true);\n    maskBar = min(maskBar, box(vec2(-5., uv.y + PadRight + R), vec2(5. + CenterX, R), true));\n    maskBar = min(maskBar, box(vec2(uv.x - CenterX * 2., uv.y), vec2(CenterX, PadRight), true));\n    float timeCycle = iTime * CYCLE * R;\n    float gridMoveTime = rightArea * timeCycle;\n    vec2 grid = 1. - smoothstep(fw, 0., vec2(\n            mod(uv.x - CenterX - PadRight * (1. - rightArea) + gridMoveTime, mix(R, R * PI * .5, rightArea)),\n            mod(abs(uv.y) - PadRight, R)\n        )\n    ) * smoothstep(fw, -fw, maskBar) * smoothstep(fw, -fw, maskBox);\n    \n    col *= mix(GreyColor, col, grid.x * grid.y);\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2SDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 164, 213, 213, 277], [278, 278, 315, 315, 349], [351, 351, 410, 410, 570], [571, 571, 618, 618, 655], [657, 657, 702, 702, 819], [820, 820, 853, 853, 884], [886, 886, 941, 941, 4435]]}
{"id": "NljXDK", "name": "Mountains and plains", "author": "jarble", "description": "Another realistic-looking mountain terrain.\nThis is based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "terrain", "lake", "mountain"], "likes": 3, "viewed": 264, "published": 3, "date": "1628653443", "time_retrieved": "2024-07-30T19:06:46.604628", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 4\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = -3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += max(sin(uv*factor)/factor,cos(uv/factor)*factor).yx;\n        value = 3.+max(value+value*sin(uv.x)/factor,value+cos((uv.y/value)/factor)/factor);\n        uv = uv.yx*1.5/factor;\n        //factor /= 1.5;\n        \n    }\n    \n    return value;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 1.;\n    return fbm(uv/factor)*factor/2.;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljXDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 511, 560, 923], [997, 997, 1035, 1035, 1097], [1099, 1099, 1132, 1132, 1352], [1354, 1354, 1392, 1392, 1619], [1621, 1621, 1659, 1659, 1883], [1885, 1885, 1914, 1914, 2009], [2011, 2011, 2048, 2048, 2107], [2110, 2178, 2197, 2197, 2236], [2238, 2238, 2258, 2258, 2334], [2336, 2336, 2355, 2355, 2394], [2396, 2396, 2453, 2453, 2688], [2690, 2690, 2725, 2725, 3119], [3121, 3121, 3175, 3175, 3841], [3844, 3844, 3896, 3896, 4331], [4333, 4333, 4390, 4390, 5575]]}
{"id": "Nl2XWK", "name": "prime number screen saver", "author": "ArmandB", "description": "a simple shader that uses primes to make a cool pattern", "tags": ["simple", "primes"], "likes": 5, "viewed": 305, "published": 3, "date": "1628642050", "time_retrieved": "2024-07-30T19:06:47.728622", "image_code": "bool is_prime(float x){\n    x = round(abs(x));//round to remove decimals, abs to remove negatives\n    for(float i = 2.0; i < x/2.0; i++){//divide by (low 2, high x/2)\n        if (mod(x,i) == 0.0){\n            return false;//if divisible exit\n        }\n    }\n    return true;//if not divisible by anything draw\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = 45.0;\n    float size = 100.0;\n    vec2 uv = fragCoord/iResolution.xy*size;//set uv units\n    uv.x *= iResolution.x/iResolution.y;//scale so contents are square\n    uv *= mat2(cos(angle),-sin(angle),sin(angle),cos(angle));//rotation matrix\n    vec3 col = vec3(0);//set bg\n    \n    //changes num to check based on mousepos, sin(time, uv)\n    if(is_prime(uv.x + iMouse.x + sin(iTime+uv.x)) == true \n    && is_prime(uv.y + iMouse.y + cos(iTime+uv.y)) == true){\n        //sets color to change based on uv offset by mousepos\n        col = vec3(0,normalize((uv.yx+iMouse.xy)/size));\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 311], [313, 313, 370, 370, 1037]]}
{"id": "NljXWK", "name": "Mountain lakes v2", "author": "jarble", "description": "A fractal mountain terrain with some lakes.\nThis is based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "terrain", "lake", "mountain"], "likes": 5, "viewed": 280, "published": 3, "date": "1628639284", "time_retrieved": "2024-07-30T19:06:48.487594", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 16\n\nvec2 triwave(vec2 uv){\n    return\n        abs(fract(uv)-.5)\n        //max(abs(fract(uv)-.5),abs(fract(uv.yx+.5)-.5))\n    ;\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat fbm(in vec2 uv,int octaves)\n{\n    //this function generates the terrain height\n    float value = 0.,\n    value1=value,\n    amplitude = 1.5;\n    uv /= 16.;\n    vec2 t1 = vec2(0.);\n    vec2 warp = vec2(0.);\n    \n    mat2 r = rotate2D(13.);\n    vec2 uv1 = uv;\n    for (int i = 0; i < octaves; i++)\n    {\n        t1 *= rotate2D(abs(t1.x+t1.y));\n        t1= triwave(uv-triwave(uv1*r/2.15))-t1.yx;\n        value1=sqrt(value1*value1+value*value);\n        value = (abs(t1.x-t1.y) * amplitude-value);\n        amplitude /= 2.15;\n        uv1 = uv;\n        uv = (uv.yx*2.15 + t1)*r;\n    }\n    \n    return value1-.9;\n}\n\nfloat fbm(in vec2 uv){\n    return fbm(uv,OCTAVES);\n}\n\nfloat f(in vec3 p,int iters)\n{   \n    float h = fbm(p.xz,iters);\n    return h;\n}\n\nfloat f(in vec3 p)\n{   \n    float h = fbm(p.xz,12);\n    return h;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 1.;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 511, 511, 613], [615, 615, 639, 639, 691], [693, 693, 728, 777, 1304], [1306, 1306, 1328, 1328, 1358], [1360, 1360, 1390, 1390, 1440], [1442, 1442, 1462, 1462, 1509], [1583, 1583, 1621, 1621, 1680], [1682, 1682, 1715, 1715, 1935], [1937, 1937, 1975, 1975, 2202], [2204, 2204, 2242, 2242, 2466], [2468, 2468, 2497, 2497, 2592], [2594, 2594, 2631, 2631, 2690], [2693, 2761, 2780, 2780, 2819], [2821, 2821, 2841, 2841, 2917], [2919, 2919, 2938, 2938, 2977], [2979, 2979, 3036, 3036, 3271], [3273, 3273, 3308, 3308, 3702], [3704, 3704, 3758, 3758, 4424], [4427, 4427, 4479, 4479, 4914], [4916, 4916, 4973, 4973, 6158]]}
{"id": "stBSDV", "name": "2 cast refraction", "author": "intrakits", "description": "This is my first attempt at doing refraction. really have no idea what i am doing here, but it looks kind of refractiony. :)", "tags": ["refraction"], "likes": 0, "viewed": 215, "published": 3, "date": "1628628244", "time_retrieved": "2024-07-30T19:06:49.299423", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 GetDist(vec3 p){\n    vec2 res = vec2(p.y,1);\n    vec2 box = vec2(dBox(p-vec3(sin(iTime),1.,-4),vec3(1)),2);\n    res = colMin(res,box);\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec2 GetDist2(vec3 p){\n    vec2 res = vec2(length(p-vec3(0,0,-3))-sin(p.y+iTime)-1.5,3);\n    res = smin(res, vec2(p.y+1.,4),2.);\n    if(res.y!=4.&&res.y!=3.){\n        res.y=3.;\n    }\n    if(p.y<(0.)){\n        res.y=4.;\n    }\n    return res;\n}\nvec2 RayMarch2(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist2(p);\n        //move origin to new point\n        dO+=ds.x;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(4,5.,10);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nvec3 A (vec2 uv){\n    vec3 base =vec3(1)*DrawSquare (uv-vec2(0,0), .1-uv.y*.2, .2, 0., 0., .01);\n    vec3 mask =vec3(1)*DrawSquare (uv-vec2(0,.1), .05-uv.y*.2, .07, 0., 0., .01);\n    vec3 mask2 =vec3(1)*DrawSquare (uv-vec2(0,-.1), .05-uv.y*.2, .1, 0., 0., .01);\n    return base - mask - mask2;\n}\nvec3 X (vec2 uv){\n    vec3 slashR = vec3(1)*DrawSquare (uv-vec2(uv.y*.5,0), .04, .2, 0., 0., .01);\n    vec3 slashL = vec3(1)*DrawSquare (uv-vec2(-uv.y*.5,0), .04, .2, 0., 0., .01);\n    return slashR+slashL;\n}\nvec3 coneText(vec2 uv){\n    vec3 col = A(uv-vec2(-.3,0))+X(uv-vec2(0,0));\n    return col;\n}\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal, float trans, inout vec3 p){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n    if(trans!=1.){\n        d = RayMarch2(ro,rd);\n    }\n    \n     \n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    vec3 refl = texture(iChannel0, r).rgb;\n    refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    \n    if(d.y == 1.){\n        col *= vec3(1.);\n        //col*=refl;\n        reflVal = .0;\n    }\n    else if(d.y==2.){\n       col *= vec3(1,0,0);\n       reflVal = 0.1;\n    }\n    else if(d.y==3.){\n        float off = pow(sin(iTime*2.),2.)*.5+1.;\n        vec2 uv = vec2(atan(p.x,p.z)/(3.14159),p.y-off);\n        uv.x-=.4;\n        uv.y-=.3;\n        col*=vec3(1,0,0);\n        col-= coneText(uv).rgb;\n        reflVal = 0.1;\n    }\n    else if(d.y==4.){\n      col*=vec3(1.);\n      reflVal=0.9;\n    }\n    else if(d.y==5.){\n      col*=vec3(1.);\n      reflVal=0.9;\n    }\n    else if(d.y==6.){\n      col=vec3(1.,1,0);\n      col.xy*=sin(iTime*3.)*.5+.5;\n      reflVal=0.9;\n    }\n    else{\n        //col=texture(iChannel0, rd).rgb*.3;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, 3, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    \n    float reflVal = 1.;\n    vec3 p = vec3(0);\n    \n    vec3 front = Render(ro,rd,reflVal,0.,p);\n    vec3 n=GetNormal(p);\n   \n    \n    vec3 refr = refract(rd,n,1./1.4);\n    \n    vec3 backR = Render(ro,refr,reflVal,1.,p);\n   // ro = ta + vec3( 4.5, 4.3, 4.5);\n   // rd = ca * normalize( vec3(pt,2.5) );\n    reflVal = 1.;\n    vec3 col=front;\n    if(col.z <=0.){\n        col = backR+vec3(0,.4,0);\n   }\n   else{\n       ro = ta + vec3( 4.5, 4.3, 4.5);\n        rd = ca * normalize( vec3(pt,2.5) );\n        reflVal = 1.;\n\n        vec3 back = Render(ro,rd,reflVal,1.,p);\n        col = back;\n   }\n    \n   // vec3 bounce = reflVal*Render(ro,rd,reflVal,1.,p);\n    //col += bounce;\n\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 112, 112, 140], [142, 142, 162, 162, 269], [271, 271, 291, 291, 354], [356, 356, 419, 419, 1469], [1471, 1471, 1490, 1490, 1552], [1553, 1553, 1604, 1604, 1888], [1890, 1890, 1939, 1962, 2395], [2397, 2397, 2427, 2427, 2498], [2500, 2500, 2527, 2527, 2566], [2567, 2567, 2631, 2631, 2882], [2883, 2883, 2915, 2915, 3016], [3017, 3057, 3095, 3095, 3192], [3194, 3234, 3275, 3275, 3347], [3348, 3348, 3406, 3406, 3507], [3508, 3508, 3531, 3531, 3726], [3727, 3727, 3774, 3774, 3807], [3808, 3808, 3829, 3829, 3965], [3966, 3966, 3998, 4026, 4536], [4537, 4537, 4559, 4559, 4779], [4780, 4780, 4813, 4841, 5352], [5353, 5353, 5376, 5415, 5786], [5787, 5787, 5810, 5845, 6785], [6786, 6786, 6838, 6838, 7015], [7016, 7016, 7106, 7106, 7291], [7292, 7292, 7309, 7309, 7587], [7588, 7588, 7605, 7605, 7796], [7797, 7797, 7820, 7820, 7888], [7889, 7889, 7980, 8001, 9258]]}
{"id": "slBSDV", "name": "Trip - 1", "author": "birdbird", "description": "Using log polar-tiling (as described here https://www.osar.fr/notes/logspherical/) to create an infinitely zooming shader.", "tags": ["infinitezoom", "logtiling"], "likes": 6, "viewed": 320, "published": 3, "date": "1628627748", "time_retrieved": "2024-07-30T19:06:50.128207", "image_code": "const float pi = acos(-1.);\n\n//https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\nfloat map_range(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n//https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nfloat map(vec2 uv) {\n    int iterations = 2;\n    vec2 ouv = uv;\n    \n    uv.y += iTime/10.;\n    uv = abs(mod(uv, 1.)*4. - 2.);\n    \n    for(int i = 0; i < iterations; i ++) {\n        float fi = float(i);\n        float fit = float(iterations);\n        \n        uv = abs(uv - (vec2(0.5 + (fi/fit)*0.6 )));\n        \n        uv *= 1.16;\n        \n        uv = rotateUV(uv, map_range(ouv.x,-1.,1., 0.2, 5.) );\n    }\n    \n    return sin(length(uv)*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv_o = uv;\n    \n    //Barrel distortion\n    vec2 w_uv = uv * dot(uv,uv);\n    uv = mix(uv, w_uv, 0.4);\n    \n    //Log polar-tiling -> https://www.osar.fr/notes/logspherical/\n    vec2 pos = vec2(log(length(uv)), atan(uv.y, uv.x));\n    pos *= 6./pi;\n    pos = fract(pos) - 0.5;   \n    uv = pos;\n    uv.x -= iTime/(2.8) + 5700.;\n    \n    //RGB offset\n    float offset_range = 0.04;\n    float offset = map_range(sin(iTime),-1.,1.,0.2,1.) * offset_range;\n    float offset_y = cos(iTime) * offset_range * 0.2;\n    \n    float cr = map(uv + vec2(offset, 0.));\n    float cg = map(uv + vec2(offset*2., offset_y*2.));\n    float cb = map(uv + vec2(offset*3., offset_y*3.));\n    vec3 color = vec3(cr, cg, cb)*3.;\n    \n    //Fade to black towards center to hide aliasing\n    float mask = (1. - pow(length(uv_o),0.96) )*3.;\n    color -= mask;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 97, 175, 175, 241], [243, 311, 351, 351, 547], [549, 549, 569, 569, 997], [999, 999, 1056, 1056, 1991]]}
{"id": "7lSSWK", "name": "Liquid Planet with Ducks", "author": "xjorma", "description": "Shader are always cuter with ducks.\nUse the mouse to turn around.\nDuck model from Jimmi:\nhttps://www.shadertoy.com/view/4lsSDl", "tags": ["simulation", "water", "planet", "cubemap", "drop", "feedback", "physics", "ducks"], "likes": 33, "viewed": 871, "published": 3, "date": "1628627533", "time_retrieved": "2024-07-30T19:06:51.155461", "image_code": "// Created by David Gallardo - xjorma/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n\nconst vec3 lightPosition = vec3(0.,10.,2.);\n\nconst vec3 backgroundColor = vec3(0.4);\nconst vec3 waterColor = vec3(0,0,0.4);\nconst vec3 duckColor = vec3(1, 1, 0);\n\nconst float cref = 0.8;\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\nfloat mapWater(in vec3 p)\n{\n    float d = sdSphere(p, 1.0 + texture(iChannel0, p).x * 0.05);\n    return d;\n}\n\n\n#define NORMALFUNC(NAME, MAPFUNC, EPS)\t\t\t\t\t\t\t\t\\\nvec3 NAME(in vec3 p)\t\t\t\t\t\t\t\t    \t\t\t\\\n{                                                                   \\\n    const vec2 k = vec2(EPS,-EPS);\t\t\t\t                    \\\n    return normalize( k.xyy * MAPFUNC(p + k.xyy) + \t\t\t    \t\\\n                      k.yyx * MAPFUNC(p + k.yyx) + \t\t\t\t    \\\n                      k.yxy * MAPFUNC(p + k.yxy) + \t\t\t\t    \\\n                      k.xxx * MAPFUNC(p + k.xxx) );\t\t\t\t    \\\n}\n\n#define RAYMARCHFUNC(NAME, MAPFUNC, ITER, EPS)\t\t\t\t\t\t\\\nfloat NAME(in vec3 ro, in vec3 rd, in float dist)                   \\\n{                                                                   \\\n    float t = 0.0;                                                  \\\n    for( int i = 0; i < ITER; i++ )                                 \\\n    {                                                               \\\n        vec3\tp = ro + t*rd;                                      \\\n        float\th = MAPFUNC(p);                                     \\\n        if( abs(h) < 0.0001 || t > dist )                          \\\n            break;                                                  \\\n        t += h;                                                     \\\n    }                                                               \\\n    return t;                                                       \\\n}\n\nNORMALFUNC(calcNormalWater,mapWater, 0.02)\nRAYMARCHFUNC(raymarchWater,mapWater, 100, 0.00001)\n\nfloat mapSolidImp(vec3 p)\n{\n    return mapSolid(p, iChannel2);\n}\n\nNORMALFUNC(calcNormalSolid,mapSolidImp, 0.0001)\nRAYMARCHFUNC(raymarchSolid,mapSolidImp, 100, 0.001)\t\n\nNORMALFUNC(calcNormalDuck,duckMap, 0.0001)\n\nfloat rayTraceDucks(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color, in float maxDist)\n{\n    float d = infinity;\n    bool collide = false;\n    for(int i = 0; i < DuckNum; i++)\n    {\n        vec3 pos = Load(i, CompPosition, iChannel2).xyz;\n        vec2 inter = sphIntersect( ro, rd, pos, 0.1);\n        if(inter.x > 0.0 && inter.x < maxDist)\n        {\n            vec3 dir = Load(i, CompDirection, iChannel2).xyz;\n            \n            vec3 y = pos;\n            vec3 z = dir;\n            vec3 x = cross(z, y);\n            \n            mat4 mr = mat4(\n\t\t\tx.x,\t\ty.x,\t\tz.x,         0,\n\t\t\tx.y,\t\ty.y,\t\tz.y,         0,\n\t\t\tx.z,\t\ty.z,\t\tz.z,         0,\n\t\t\t0,\t        0,\t        0,           1.0 );\n\n            mat4 mt = mat4(\n\t\t\t1.0,\t\t0.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t1.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0,         0.0,\n\t\t\t-pos.x,\t-pos.y,\t-pos.z,     1.0 );\n            \n            mat4 tr= mr * mt;\n            \n            float t = inter.x;\n            vec3 tp;\n            for( int j = 0; j < 16; j++ )\n            {\n                vec3\tp = ro + t*rd;\n                tp = vec3(tr * vec4(p, 1.0));\n                float\th = duckMap(tp);\n                if( abs(h) < 0.0001 || t > inter.y )\n                    break;\n                t += h;\n            }\n            if(t < inter.y)\n            {\n                if(t < d)\n                {\n                    d = t;\n                    collide = true;\n                    normal = (inverse(tr) * vec4(calcNormalDuck(tp), 0)).xyz;\n                    color = duckMapColor(tp).yzw;\n                }\n            }\n        }\n\n    }\n    return d; \n}\n\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float tWater = raymarchWater(ro, rd, dist);\n    \n    vec3 dn, dc;\n    float tSolid = rayTraceDucks(ro, rd, dn, dc, tWater);\n    \n    vec3 col = backgroundColor;\n\n    if( min(tWater, tSolid) < dist )\n    {\n        if(tSolid < tWater)\n        {\n            // Solid first\n            vec3 p = ro + tSolid * rd;\n            vec3 n = dn;\n            vec3 v = normalize(ro-p);\n            vec3 l = normalize(lightPosition-p);\n            vec3 h = normalize(l+v);\n            col = dc * saturate(max(0.0, dot(n,l) * 0.7) + 0.3);\n        }\n        else\n        {\n            // Water first\n            vec3 p = ro + tWater * rd;\n            vec3 n = calcNormalWater(p);\n            vec3 rdn, rdc;\n            vec3 rdir = reflect(rd, n);\n            float tref = rayTraceDucks(p - 0.15 * rdir, rdir, rdn, rdc, 0.25);\n            if(tref < 0.5)\n            {\n                vec3 p = p - 0.15 * rdir + tref * rdir;\n                vec3 v = normalize(ro-p);\n                vec3 l = normalize(lightPosition-p);\n                vec3 h = normalize(l+v);\n                col = rdc * saturate(max(0.0, dot(rdn,l) * 0.7) + 0.3);\n                return mix(waterColor, col, 0.65);\n            }\n            col = waterColor;\n            float spec = length(texture(iChannel1, reflect(ro, n) * vec3(1,-1,1)).rgb);\n            col += 0.15 * spec * smoothstep(0.0, 0.1, dist);\n        }\n    }\n    \n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2], 4.0);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "vec3 minComponent(in vec3 v)\n{\n    v = abs(v);\n    if(v.x < v.y)\n    {\n        if(v.x < v.z)\n        {\n            return vec3(1, 0, 0);\n        }\n    }\n    else\n    {\n        if(v.y < v.z)\n        {\n            return vec3(0, 1, 0);\n        }\n    }\n    return vec3(0, 0, 1);\n}\n\n\nmat3 rotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    \n    vec3 up = minComponent(rayDir);\n    vec3 right = normalize(cross(rayDir, up)) ;\n    right /= (iResolution.x * 0.5);\n   \n\n    mat3 rot = rotationMatrix(rayDir, radians( 360.0 / float(nbSample)));\n\n    vec2 center = texture(iChannel0, rayDir).xy;\n    \n    float sum = 0.0;   \n    for(int i = 0; i < nbSample; i++)\n    {\n        sum += texture(iChannel0, rayDir + right).x;\n        right = rot * right;\n    }\n    \n    float new = (sum * (2.0 / float(nbSample)) - center.y) * dampening; \n    \n    // Random point\n    if((iFrame % 6) == 0)\n    {\n        float d = dot(rayDir, randomPointOnSphere(float(iFrame)));\n        new -= d * smoothstep(0.999, 1.0, d) * 0.1; \n    }\n\n    // solid\n    float ds = mapSolid(rayDir, iChannel2);\n    new -= smoothstep(0.0, -0.01, ds) * 0.007;   \n\n    fragColor = vec4(vec2(new, center.x), 0 , 1);\n    \n    //fragColor = vec4(0);\n    \n}", "cube_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Duck Simulation\nconst int DuckNum\t\t= 48;\nconst int MaxCompPerRow\t= 256;\nconst int CompPosition\t= 0;\nconst int CompDirection\t= 1;\nconst int CompNum\t\t= 3;\n\nconst float duckSpeed = 0.005;\nconst float duckScale = 0.1;\n\n// Physics simulation parameters\nconst int nbSample = 6;\nconst float dampening = 0.98;\n\n\nconst float infinity = 100000.0;\n\n// Hash by Dave Hoskins from https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Box SDF by IQ https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Fog by IQ https://iquilezles.org/articles/fog\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}\n\n// Sphere intersect form IQ https://iquilezles.org/articles/intersectors\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec4 Load(in int id, in int comp, in sampler2D sampler)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(sampler, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nfloat duckBody(vec3 p) {\n    float k = 6.0;\n    float a = 0.;\n    \n    //p.x = abs(p.x);\n    \n    a += exp(-k * sdSphere(p + vec3(0.11, 0, 0.1), 0.06));\n    a += exp(-k * sdSphere(p + vec3(-0.11, 0, 0.1), 0.06));\n    a += exp(-k * sdSphere(p + vec3(0.2, 0, 0.3), 0.1));\n    a += exp(-k * sdSphere(p + vec3(-0.2, 0, 0.3), 0.1));\n    a += exp(-k * sdSphere(p + vec3(0.2, 0, 0.55), 0.07));\n    a += exp(-k * sdSphere(p + vec3(-0.2, 0, 0.55), 0.07));\n    a += exp(-k * sdSphere(p + vec3(-0.00, 0, 0.72), 0.1));\n    \n    a += exp(-k * sdSphere(p + vec3(0, -0.39, 0.8), 0.01));\n\n    a += exp(-k * sdSphere(p + vec3(0, -0.7, 0.1), 0.15));\n    a += exp(-k * sdSphere(p + vec3(0, -0.65, -0.05), 0.07));\n\n    return -log(a) / k;\n}\n\nfloat beak(vec3 p, float s)\n{\n    float k = max(length(p)-s, -(length(p+vec3(-0.15,-0.2,-0.1))-0.25));\n    k = max(k, -(length(p+vec3(0.12,-0.2,-0.1))-0.25));\n    return k < 0.0 ? 0.0 : k;\n}\n\nfloat duckBeak(vec3 p)\n{\n    float k = 12.0;\n    float a = 0.;\n    \n    a += exp(-k * beak(p + vec3(0, -0.55, -0.1), 0.15));\n\n    return -log(a) / k;\n}\n\nfloat duckMap(in vec3 p)\n{\n    p /= duckScale;\n    return min(duckBody(p), duckBeak(p)) * duckScale;\n}\n\n\nvec4 nearest(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec4 duckMapColor(vec3 p)\n{\n    p /= duckScale;\n    p.x = abs(p.x);\n    vec4 res = vec4(duckBody(p), vec3(1, 1, 0));\n    res = nearest(res, vec4(duckBeak(p), vec3(1, 0, 0)));\n    res = nearest(res, vec4(sdSphere(p-vec3(0.09, 0.62, 0.14), 0.06), vec3(0.0, 0, 0.3)));\n    res.x *= duckScale;\n    return res;\n}\n\n\nfloat mapSolid(vec3 p, sampler2D sampler)\n{\n    float d = infinity;\n    for(int i = 0; i < DuckNum; i++)\n    {\n        vec3 pos = Load(i, CompPosition, sampler).xyz;\n        float dbs = sdSphere( p - pos, 0.1);\n        if(dbs > 0.1)\n        {\n            d = min(d , dbs);\n        }\n        else\n        {\n        \n            vec3 dir = Load(i, CompDirection, sampler).xyz;\n                        \n            vec3 y = pos;\n            vec3 z = dir;\n            vec3 x = cross(z, y);\n            \n            mat4 r = mat4(\n\t\t\tx.x,\t\ty.x,\t\tz.x,         0,\n\t\t\tx.y,\t\ty.y,\t\tz.y,         0,\n\t\t\tx.z,\t\ty.z,\t\tz.z,         0,\n\t\t\t0,\t        0,\t        0,           1.0 );\n\n            mat4 t = mat4(\n\t\t\t1.0,\t\t0.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t1.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0,         0.0,\n\t\t\t-pos.x,\t-pos.y,\t-pos.z,     1.0 );\n            \n            mat4 tr= r * t;\n            \n            d = min(d , duckMap( (tr * vec4(p, 1)).xyz));\n        }\n    }\n    return d;\n}\n\nvec3 randomPointOnSphere(float key)\n{\n    vec2 rand = hash21(key);\n    float theta = radians(360.0) * rand.x;\n    float phi = acos(2.0 * rand.y - 1.0);\n    return vec3 (cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi));    \n}", "buffer_a_code": "vec4 Load(in int id, in int comp)\n{\n    int off = id * CompNum + comp;\n\treturn texelFetch(iChannel0, ivec2(off % MaxCompPerRow, off / MaxCompPerRow), 0);\n}\n\nvoid Store(in vec4 v, in int comp, in int curComp, inout vec4 o)\n{\n    if(comp == curComp)\n    {\n        o = v;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    int\tpixId = int(fragCoord.x + float(MaxCompPerRow) * fragCoord.y);\n    int curComp = pixId % CompNum;\n    pixId /= CompNum;\n    if( fragCoord.x >= float(MaxCompPerRow) || pixId >= DuckNum * CompNum)\n    {\n        discard;\n    }\n    vec3\tpos;\n    vec3\tdir;\n    if(iFrame == 0)\n    {\n        pos = randomPointOnSphere(float(pixId + 1) * 7.0);\n        dir = randomPointOnSphere(float(pixId + 4) * 3.0);\n    }\n     else\n    {\n        pos = Load(pixId, CompPosition).xyz;\n        dir = Load(pixId, CompDirection).xyz;\n    }\n    \n    //vec3 right = normalize(cross(dir, pos));\n    \n\n    \n    vec3 npos = pos + dir * duckSpeed;\n    \n    for(int i = 0; i < DuckNum; i++)\n    {\n        if(i != pixId)\n        {\n            vec3 opos = Load(i, CompPosition).xyz;\n            float d = distance(pos, opos);\n            npos -= normalize(opos - npos) * smoothstep(0.4, 0.0, d) * 0.0005;\n        }\n    }\n    \n    npos = normalize(npos);\n    \n    vec3 ndir = normalize(npos - pos);\n    \n    Store(vec4(npos, 0), CompPosition, curComp, fragColor);\n    Store(vec4(ndir, 0), CompDirection, curComp, fragColor);   \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSSWK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[314, 314, 339, 339, 368], [370, 370, 397, 397, 478], [1929, 1929, 1956, 1956, 1993], [2141, 2141, 2237, 2237, 3750], [3753, 3753, 3802, 3802, 5203], [5205, 5205, 5283, 5283, 5355], [5357, 5357, 5399, 5399, 5563]]}
{"id": "slBSWV", "name": "Color blending exp-smooth-min", "author": "iq", "description": "Shows one possible way to blend materials when using exponential-smooth-blend to merge SDF primitives together.", "tags": ["2d", "sdf", "smooth", "smin", "smoothmin", "exponential"], "likes": 64, "viewed": 1901, "published": 3, "date": "1628622832", "time_retrieved": "2024-07-30T19:06:51.929391", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows one possible way to blend materials when using\n// exponential-smooth-blend to merge SDF primitives together.\n\n\n// https://iquilezles.org/articles/smin\nvec2 smin( in float a, in float b, in float k )\n{\n    float f1 = exp2( -k*a );\n    float f2 = exp2( -k*b );\n    return vec2(-log2(f1+f2)/k,f2);\n}\n\n// iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p)-b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // background color\n    vec3 col = vec3( 0.1+0.05*mod(floor(p.x*4.0)+floor(p.y*4.0),2.0) );\n\n    // compute SDF and its color\n    float dmin = 1e20;\n    vec4  dcol = vec4(0.0,0.0,0.0,0.0);\n    for( int i=0; i<10; i++ ) // 10 boxes\n    {\n        float h = float(i);\n        \n        // new box position and color\n        vec2 ce = vec2(1.5,1.0)*cos(0.1*iTime*vec2(1.3+0.1*h,1.7+(7.0-h)*h*0.3)+h*vec2(11.1,28.7)+vec2(0.0,2.0));\n        vec3 co = 0.5 + 0.5*cos(h*1.0+vec3(0.0,2.0,4.0)); co = co*co;\n        \n        // distance to box\n        float dis = sdBox(p-ce,vec2(0.4,0.2));\n\n        // smoothly blend SDFs\n        vec2 db = smin( dmin, dis, 10.0 );\n        dmin = db.x;\n\n        // smoothly blend colors\n        float w = db.y;\n        dcol += vec4(co*w,w);\n    }\n    // resolve color\n    dcol.xyz /= dcol.w;\n    \n    // draw SDF on top\n    col = mix( col, dcol.xyz, 1.0-smoothstep(0.0,0.01,dmin) );\n    \n    // gamma\n    col = sqrt(col);\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBSWV.jpg", "access": "api", "license": "mit", "functions": [[1198, 1238, 1287, 1287, 1383], [1385, 1428, 1466, 1466, 1546], [1548, 1548, 1605, 1630, 2700]]}
{"id": "Nt2Szm", "name": "Bright cubes", "author": "morimea", "description": "Simple scene. I hope it does not look too bad.", "tags": ["3d", "voxels", "art"], "likes": 17, "viewed": 616, "published": 3, "date": "1628616911", "time_retrieved": "2024-07-30T19:06:53.426389", "image_code": "\n// Created by Danil (2021+) https://cohost.org/arugl\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/Nt2Szm\n\n\n#define AA 2\n\n// does not speedup compiling but slowdown performance, comp time 2 sec without this\n//#define iZero min(iFrame,0)\n\n#define iZero 0\n\n#define PI 3.141592653589793\n#define TAU (2.*PI)\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\n\nconst vec3 white=vec3(0xf1,0xe8,0xf2)/float(0xff);\nconst vec3 blue=vec3(0x0a,0x1f,0x73)/float(0xff);\n\nconst vec2 voxbox = vec2(6.5,9.5);\nconst float voxmax_h = 1.918;\nconst vec3 voxposl = vec3(0.,-3.5,-8.5);\n\n\n// --------Common moved to have al in one shader\n\nfloat fresnel(vec3 d, vec3 n)\n{\n    float a = clamp(1.0-dot(n,-d), 0.0, 1.0);\n    return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n}\n\n// ANGLE bug https://bugs.chromium.org/p/chromium/issues/detail?id=1238461\n// ANGLE compile time slowdown 20x times because of single call of (0.5 * t * t * t) below\n\nfloat easeInOutCubic(float t) {\n    if ((t *= 2.0) < 1.0) {\n        //return 0.5 * t * t * t; // uncomment for bug\n        return 0.5 * pow(abs(t),3.); //fix\n    } else {\n        return 0.5 * ((t -= 2.0) * t * t + 2.0);\n    }\n}\n\nuint uhash(uint x) {\n    x = ((x >> uint(16)) ^ x) * uint(73244475);\n    x = ((x >> uint(16)) ^ x) * uint(73244475);\n    x = (x >> uint(16)) ^ x;\n    return x;\n}\n\nfloat rand_from_seed(inout uint seed) {\n    int k;\n    int s = int(seed);\n    if (s == 0)\n    s = 305420679;\n    k = s / 127773;\n    s = 16807 * (s - k * 127773) - 2836 * k;\n    if (s < 0)\n        s += 2147483647;\n    seed = uint(s);\n    return float(seed % uint(65536)) / 65535.0;\n}\n\nfloat hash11(float v){\n    uint hs = uhash(floatBitsToUint(v * 12.9898));\n    return rand_from_seed(hs);\n}\n\nfloat hash21(vec2 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898));\n    return rand_from_seed(hs);\n}\n\nfloat hash31(vec3 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898 + v.z * 25.831));\n    return rand_from_seed(hs);\n}\n\nvec3 hash33(vec3 v){\n    uint hs = uhash(floatBitsToUint(v.y + v.x * 12.9898 + v.z * 25.831));\n    float a = rand_from_seed(hs);\n    float b = rand_from_seed(hs);\n    float c = rand_from_seed(hs);\n    return vec3(a,b,c);\n}\n\nfloat get_rand(vec2 pos,vec2 box){\n    float tps = hash21(pos);\n    tps = tps*0.1+0.9*smoothstep(0.2,.9,tps);\n    tps *= min((abs(pos.x-box.x-3.)/box.x)*((pos.y+3.)/(box.y*2.)),1.);\n    return 0.05+0.95*tps;\n}\n\n\n// https://www.shadertoy.com/view/XsX3zB\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;r.z = fract(512.0*j);j *= .125;r.x = fract(512.0*j);j *= .125;r.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t vec4 w, d;\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t w = max(0.6 - w, 0.0);\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t return dot(d, vec4(52.0));\n}\n\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n#define MAX_DIST 1000.\n#define MIN_DIST .001\n\n// ffix float precision fix, cy height shift animation, stimer shift timer 0-1\n// ffix also used in reflections to control voxel size to remove white borders on glow reflections\nbool VoxelsIntersect(int steps, vec2 box, float max_h, float ffix, in vec3 ro, in vec3 rd,\n                        out vec3 normal , out float tnew, out vec2 idx, inout float cy, float stimer) {\n    vec2 pos = floor(ro.xz);\n    \n    vec3 rdi = 1./rd;\n\n    vec3 rda = abs(rdi);\n    vec3 rds = sign(rd);\n    vec2 dis = (pos - ro.xz + .5 + rds.xz*.5) * rdi.xz;\n    \n    vec3 roi = rdi*(ro-vec3(.5,0.,.5));\n\n    vec2 mm = vec2(0.0);\n    for( int i=0; i<steps; i++ ) {    \n        float tps = get_rand(pos, box);\n        float tm=1.;\n        if (any(greaterThan(pos,box*2.))||any(lessThan(pos,vec2(1.))))tm=0.;\n        cy = mix(-(tm*max_h*tps-1.)+max_h*2.-2.,tm*max_h*tps-1.,stimer);\n        vec3 n = roi - rdi * vec3(pos.x, cy, pos.y);\n        vec3 k = rda*vec3(.5, -0.00099+tm*max_h*tps, .5);\n\n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n\n        float tN = max( max( t1.x, t1.y ), t1.z )-ffix;\n        float tF = min( min( t2.x, t2.y ), t2.z );\n\n        if ( tN < tF && tN>MIN_DIST && tN<MAX_DIST ) {\n            normal = -rds*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            tnew = tN;\n            idx = pos;\n            return true;\n        }\n\n    mm = step( dis.xy, dis.yx ); \n    dis += mm*rda.xz;\n    pos += mm*rds.xz;\n    }\n\n    return false;\n}\n\n\n// using iq's intersectors: https://iquilezles.org/articles/intersectors\n\nbool SphereIntersectInv(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    ro -= SpPos;\n\n    float A = dot(rd, rd);\n    float B = 2.0*dot(ro, rd);\n    float C = dot(ro, ro)-SpRad*SpRad;\n    float D = B*B-4.0*A*C;\n    t=-1.;\n    norm=vec3(0.,1.,0.);\n    if (D < 0.0) return false;\n\n    D = sqrt(D);\n    A *= 2.0;\n    float t1 = (-B+D)/A;\n    float t2 = (-B-D)/A;\n    if (t1 < 0.0) t1 = t2;\n    if (t2 < 0.0) t2 = t1;\n    t1 = max(t1, t2);\n    //t1 = min(t1, t2);\n    if (t1 < 0.0) return false;\n    norm = ro+t1*rd;\n    t = t1;\n    norm = normalize(norm);\n    return true;\n}\n// --- Common end\n\n\nvec2 lUV(vec3 p) {\n    float x = dot(p, vec3(-1,0.,0.));\n    float y = dot(p, vec3(0.,1.,0.));\n    float td = dot(p, vec3(0.,0.,1.));\n    td += 0.0001 * (1.0 - abs(sign(td)));\n    float d = -1. / td;\n    float u = d * x + 0.5;\n    float v = d * y + 0.5;\n    return vec2(u, v);\n}\n\nvec3 color_spiral(vec3 p, float d) {\n    p.z+=-1.;\n    vec2 uv=((lUV(p))-0.5)*.75;\n    uv *=MD(-0.5/max(length(uv),0.0001));\n    float td=(1.-smoothstep(-2.0,-.815,p.z))*(smoothstep(-2.,-1.95,p.z))*(1.-smoothstep(-1.5,2.35,length(uv)));\n    float c = d / max(abs(5.0/uv.x),0.0001);\n    return clamp(.85-c,0.,1.)*((blue+vec3(0.4,0.8,1.5)))*td;\n}\n\nvec3 blurred_background(vec3 rd)\n{\n    return vec3(0.7, 0.8, 1.6)*max((rd.y*0.49 + 0.51),0.001)*0.8+color_spiral(-rd,10.)*1.5;\n}\n\nvec3 background_sky(vec3 rd)\n{\n    return vec3(0.7, 0.8, 1.4)*max((rd.y*0.6 + 0.3),0.001)+color_spiral(-rd,15.)*2.;\n}\n\n\n#define OBJ_SKY 0\n#define OBJ_FLOOR 1\n#define OBJ_REFLOOR 2\n#define OBJ_BOX 3\n#define OBJ_BALL 4\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    int obj_type;\n    vec2 exdata;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat atimer=1.; //global timer 0-1\n\nconst vec3 anim_camera[]=vec3[](\n    vec3(-1.,5.,-3.),vec3(2.,3.5,-1.5),\n    vec3(3.,3.05,11.5),vec3(0.5,4.5,18.5),vec3(6.5,3.5,19.5),\n    vec3(6.5,5.15,20.5),vec3(0.5,4.5,10.5),vec3(0.5,4.5,-2.5),\n    vec3(-2.5,8.5,-2.5)\n);\n\nconst float timers[]=float[](\n    4.0,6.0,11.,\n    16.,21.,26.,\n    31.,36.5,40.,\n    42.\n);\n\nvec3 camera_anim(float gt){\n    vec3 dx[3];\n    for(int a=0;a<3+iZero;a++){\n        float timer=mod(gt+1.25*float(a-1),timers[timers.length()-1]);\n        timer+=timers[0];\n        dx[a]=anim_camera[0];\n        for(int i=1;i<anim_camera.length()+iZero;i++){\n            float t=smoothstep(timers[i-1],timers[i],timer);\n            dx[a]=mix(dx[a],anim_camera[i],t);\n        }\n        float t=smoothstep(timers[timers.length()-1],timers[timers.length()-1]+timers[0],timer);\n        dx[a]=mix(dx[a],anim_camera[0],t);\n    }\n    float timer=mod(gt,timers[timers.length()-1]);\n    timer+=timers[0];\n    atimer=1.-smoothstep(timers[4]+4.,timers[4]+6.5,timer);\n    atimer=max(atimer,smoothstep(timers[8]+0.,timers[9]+1.5,timer));\n    return mix(dx[1],mix(dx[0],dx[2],0.5),0.5);\n}\n\nvec2 get_look(float gt){\n    float timer=mod(gt,timers[timers.length()-1]);\n    timer=smoothstep(0.,timers[timers.length()-1],timer);\n    float et=easeInOutCubic(timer);\n    float ot=((1.-smoothstep(0.,0.5,timer))-1.5*smoothstep(0.5,0.6,timer)*(1.-smoothstep(0.75,0.9,timer)))+smoothstep(0.9,1.,timer);\n    timer=(timer*(1.-et))-0.5;\n    return vec2(0.2-3.*sin((0.5+timer)*PI),-0.25*sin(0.5*ot*PI));\n}\n\nRay SetCamera(vec2 uv, vec3 ro, vec2 m)\n{\n    if(iMouse.z>0.)\n        m+=(iMouse.xy/iResolution.y-0.5*iResolution.xy/iResolution.y)*2.5;\n    m.y = -m.y;\n    float fov=70.;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    vec3 rd = normalize(vec3(uv*screenSize, 1./aspect));\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n\n    rd = (rotY * rotX) * rd;\n    return Ray(ro,rd);\n}\n\nbool boxAABB(in vec3 dims, vec3 ro, vec3 rd) {\n    vec3 n = ro / rd;\n    vec3 k = dims / abs(rd);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nvoid VoxelsIntersectMin_ref(vec2 box, float max_h , vec3 posl,vec3 ro, vec3 rd,\n                            inout HitInfo hit, float rfnl, float sky_pow, float col_pow, inout float refc) {\n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    float cy;\n    \n    if(VoxelsIntersect(6, box, max_h, -0.001, ro, rd, normnew, tnew, idx, cy, atimer)){\n        bool in_box=(idx.x<=box.x*2.)&&(idx.y<=box.y*2.);\n        in_box=in_box&&all(greaterThan(idx,vec2(0.)));\n        float fnl = fresnel(rd,normnew);\n        if(in_box){\n            float alb = hash21(idx+1.);\n            float trnd = get_rand(idx+20., box*0.7);\n            float emi = step(0.65,trnd-0.75*trnd*hash21(idx+5.));\n            alb*=0.25;\n            alb *= rfnl * (1.-fnl) \n                * (.8 + .2 * dot(normnew, vec3(-.25916,.8639,-.4319)));\n            \n            emi *= col_pow;\n            vec3 tuv = fract(ro+tnew*rd) * 2.0 - 1.0;\n            float vig=max(tuv.x*tuv.x, tuv.z*tuv.z)*0.5;\n            vec3 tc = white+blue;\n            tc=mix(tc,tc*.65,vig);\n            vec3 col=max(alb*white,emi*1.175*tc);\n            hit.color.rgb += col;\n            hit.color.a += emi*0.25;\n            refc*=0.12;\n        }\n        else {\n            vec3 bg=clamp(vec3(.5,.8,1)*0.+1.*blurred_background(rd),0.,1.);\n            hit.color.rgb  += sky_pow*clamp(bg * (rfnl*(5.-2.5*rd.y)),vec3(0.),bg);\n        }\n    }\n    else {\n        vec3 bg=clamp(vec3(.5,.8,1)*0.+1.*blurred_background(rd),0.,1.);\n        hit.color.rgb += sky_pow*clamp(bg * (rfnl*(5.-2.5*rd.y)),vec3(0.),bg);\n    }\n}\n\nvoid VoxelsIntersectMin(vec2 box, float max_h , vec3 posl,vec3 ro, vec3 rd,\n                        inout bool result, inout HitInfo hit, vec3 sky) {\n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    \n    posl.xz+=1.;\n    ro+=posl;\n    \n    if(!boxAABB(vec3(box.x,max_h,box.y), ro+vec3(-1.,-max_h+1.,-1.), rd))return;\n    ro.xz+=box;\n    float vros = length(ro.xz-(box+1.));\n    if(VoxelsIntersect(min(int(vros*1.5)+18,40), box, max_h, 0.0001, ro, rd, normnew, tnew, idx, hit.exdata.y, atimer)){\n        bool in_box=(idx.x<=box.x*2.)&&(idx.y<=box.y*2.);\n        in_box=in_box&&all(greaterThan(idx,vec2(0.)));\n        if (in_box&&(tnew>0.)) {\n            float tmx = 0.;\n            if((hit.obj_type==OBJ_BALL)&&(tnew>hit.t))tmx=clamp(dot(hit.color.rgb,vec3(1.))*0.25,0.,1.);\n            hit.color = vec4(0.,0.,0.,0.);\n            float fnl = fresnel(rd,normnew);\n            \n            float alb = hash21(idx+1.);\n            float trnd = get_rand(idx+20., box*0.7);\n            float emi = step(0.65,trnd-0.75*trnd*hash21(idx+5.));\n            vec3 col = vec3(0.);\n            alb*=0.1*alb;\n\n            alb *= (1.-fnl) \n                * (.8 + .2 * dot(normnew, vec3(-.25916,.8639,-.4319)));\n            \n            vec3 tuv = fract(ro+tnew*rd) * 2.0 - 1.0;\n            float vig=max(tuv.x*tuv.x, tuv.z*tuv.z)*0.5;\n            vec3 tc = white+blue;\n            tc=mix(tc,tc*.85,vig);\n            col=max(alb*white,emi*2.35*(tc));\n            vec3 skyo = background_sky(rd);\n            hit.color.rgb += mix(col,skyo,fnl*fnl);\n            hit.color.a += emi;\n\n            hit.obj_type = OBJ_FLOOR;\n            result = true;\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            float vrds = length(tnew * rd.xz);\n            if((emi<0.5)&&(fnl > .001)){\n                hit.obj_type = OBJ_REFLOOR;\n                hit.norm = normnew;\n                hit.exdata.x = fnl;\n            }\n            \n            hit.color.rgb = mix(hit.color.rgb,sky,smoothstep(24.,27.5,vrds));\n            hit.color.rgb = mix(hit.color.rgb,sky,tmx);\n        }\n    }\n}\n\n\nfloat glow_sphere(vec3 rd, vec3 n){\n    float a = pow(0.7122 + max(dot(n, reflect(rd,n)),0.), 10.85);\n    float b = pow(0.7122 + max(1.-dot(n, reflect(rd,n)),0.), 3.85);\n    \n    return clamp(min(a,b),0.,10.);\n}\n\nvoid SphereIntersectMin(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, bool refl, bool sph2, float ot) {\n    float tnew;\n    vec3 normnew;\n    if (SphereIntersectInv(SpPos, SpRad, ro, rd, tnew, normnew)) {\n        if(!refl){\n        if (tnew < hit.t||sph2&&(tnew < ot)) \n        {\n            hit.t = min(tnew,hit.t);\n            hit.norm = normnew;\n            if(sph2){\n                vec3 spotLightOrigin \t= (SpPos - vec3(0.,0.,1.)*22.9);\n                vec3 Ln = normalize(spotLightOrigin-(ro+rd*tnew));\n                hit.color.rgb += color_spiral(Ln,20.)*4.;\n            }\n            else\n            hit.color.rgb += glow_sphere(rd,-normnew)*(sqrt(blue))*3.;\n            hit.obj_type = OBJ_BALL;\n            result = true;\n        }\n        }else{\n            if(sph2)\n            {\n                vec3 spotLightOrigin \t= (SpPos - vec3(0.,0.,1.)*19.9);\n                vec3 Ln = normalize(spotLightOrigin-(ro+rd*tnew));\n                hit.color.a += color_spiral(Ln,10.).b*.85;\n            }\n            else\n            hit.color.a = glow_sphere(rd,-normnew);\n            hit.obj_type = OBJ_BALL;\n            result = true;\n        }\n    }\n}\n\n\nHitInfo render(Ray r, inout vec3 sky)\n{\n    HitInfo hit;\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.color = vec4(sky,0.);\n    hit.norm = vec3(0.,1.,0.);\n    hit.exdata = vec2(0.);\n    \n    vec4 col = vec4(0.);\n\n    vec3 ro = r.pos; vec3 rd = r.dir;\n    \n    bool result = false;\n    float angle=0.;\n\n    vec3 spherex=vec3(0.,8.15,8.5+voxbox.y+15.);\n    vec3 spherex2=vec3(0.,8.15,8.5+voxbox.y+15.-22.25);\n    \n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    \n    float ot=hit.t;\n    SphereIntersectMin(spherex, 13.5, ro, rd, result, hit, false, false,0.);\n    SphereIntersectMin(spherex2, 23.5, ro, rd, result, hit, false, true,ot);\n    sky=hit.color.rgb;\n    \n    VoxelsIntersectMin(voxbox, voxmax_h , voxposl,ro, rd, result, hit, sky);\n    \n    return hit;\n}\n\n// reflections\nHitInfo render_refl(Ray r, HitInfo hit, float fbmx, inout vec3 sky)\n{\n    vec3 skyo = background_sky(r.dir);\n    \n    if(hit.obj_type == OBJ_REFLOOR){\n        vec3 ro = r.pos;\n        ro = ro+r.dir*hit.t;\n        float vrds = length(hit.t * r.dir.xz);\n        fbmx*=1.-smoothstep(10.,14.5,vrds);\n        float gfnl = fresnel((r.dir),hit.norm);\n        fbmx*=max(1.-gfnl*2.,0.);\n        vec3 ord = reflect(r.dir-(.0295*fbmx*hit.norm), hit.norm);\n        vec3 rd = reflect(r.dir-(.295*fbmx*hit.norm), hit.norm);\n        rd += 0.0001 * (1.0 - abs(sign(rd)));\n        \n        bool result = false;\n        float angle=0.1;\n\n        vec3 spherex=vec3(0.,10.15,8.5+voxbox.y+15.);\n        vec3 spherex2=vec3(0.,10.15-2.,8.5+voxbox.y+15.-22.25);\n        float oemi=hit.color.a;\n        float ot=hit.t;\n        SphereIntersectMin(spherex, 13.5, ro, rd, result, hit, true, false,0.);\n        SphereIntersectMin(spherex2, 23.5, ro, ord, result, hit, true, true,ot);\n        float refc=0.;\n        float fnl = 0.; \n        if(hit.obj_type == OBJ_BALL){\n            fnl=1.;refc=hit.color.a;hit.color.a=oemi;\n        }\n        ro+=voxposl;ro.xz+=voxbox+1.;\n\n        rd = reflect(r.dir+(.695*fbmx*hit.norm), hit.norm);\n        rd += 0.0001 * (1.0 - abs(sign(rd)));\n        \n        VoxelsIntersectMin_ref(voxbox, voxmax_h , voxposl+1.,ro, rd, hit, hit.exdata.x, 01.5, 01.+0.25*fbmx,refc);\n        hit.color.rgb = 0.985*hit.color.rgb+0.015*hit.color.rgb*fbmx;\n        \n        fnl = max(fresnel(rd,hit.norm),fnl);\n        hit.color.rgb = mix(hit.color.rgb,skyo,1.-sqrt(fnl))+refc*(sqrt(blue))*3.;\n        \n        hit.color.rgb = mix(hit.color.rgb,sky,smoothstep(24.,27.5,vrds));\n    }\n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 ret_col = vec3(0.0);\n    float emi = 0.;\n    vec3 tro = camera_anim(iTime);\n    vec2 m=get_look(iTime);\n#if AA>1\n    const int ta=AA*AA;\n#else\n    const int ta = 1;\n#endif\n\n    HitInfo hit[ta];\n    Ray cam[ta];\n    vec3 sky[ta];\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n    vec2 o = vec2(float(mx),float(nx)) / float(AA) - 0.5;\n    vec2 uv = (fragCoord+o)/iResolution.xy * 2.0 - 1.0;\n#else\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n#endif\n    uv.y *= iResolution.y/iResolution.x;\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    cam[idx] = SetCamera(uv,tro,m);\n    sky[idx] = background_sky(cam[idx].dir);\n    hit[idx] = render(cam[idx],sky[idx]);\n#if AA>1\n    }\n#endif\n}\n\n    vec3 ro = cam[0].pos;\n    ro+=voxposl;ro.xz+=voxbox+1.;ro = ro+cam[0].dir*hit[0].t;\n    float fbmx = (simplex3d_fractal(5.*(ro-vec3(0.,hit[0].exdata.y,0.))+vec3(0.,.5,1.)*iTime));\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n#endif\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    hit[idx] = render_refl(cam[idx],hit[idx],fbmx,sky[idx]);\n#if AA>1\n    }\n#endif\n}\n\n{\n#if AA>1\n    for( int mx=0; mx<AA+iZero; mx++ )\n    for( int nx=0; nx<AA+iZero; nx++ )\n    {\n#endif\n#if AA>1\n    int idx=mx*AA+nx;\n#else\n    int idx=0;\n#endif\n    ret_col += hit[idx].color.rgb;\n    emi += hit[idx].color.a;\n#if AA>1\n    }\n    ret_col /= float(AA*AA);\n    emi /= float(AA*AA);\n#endif\n}\n    \n\n    vec3 glow = vec3(0.7, 0.8, 1.6)*max((cam[0].dir.y*0.49 + 0.51),0.001)*0.8;\n    ret_col += glow*glow*glow / 4.0;\n\n    ret_col *= 0.425;\n    ret_col = clamp(ret_col,0.,1.);\n    ret_col = sqrt(ret_col);\n    \n    vec2 vig = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    ret_col = mix(ret_col, ret_col*ret_col, dot(vig, vig)*0.5);\n    ret_col = mix(ret_col, ret_col*ret_col, 0.5);\n    \n    ret_col = clamp(ret_col,0.,1.);\n    ret_col = pow(ret_col, vec3(01.4545));\n    \n    ret_col=mix(ret_col,ret_col.bgr,atimer);\n    fragColor = vec4(ret_col,clamp(emi,0.,1.));\n    fragColor.a=1.; //bloom not used\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2Szm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[387, 387, 404, 404, 480], [742, 742, 773, 773, 867], [1036, 1036, 1067, 1067, 1263], [1265, 1265, 1285, 1285, 1426], [1428, 1428, 1467, 1467, 1711], [1713, 1713, 1735, 1735, 1819], [1821, 1821, 1842, 1842, 1934], [1936, 1936, 1957, 1957, 2064], [2066, 2066, 2086, 2086, 2288], [2290, 2290, 2324, 2324, 2499], [2502, 2543, 2565, 2565, 2731], [2792, 2815, 2840, 2840, 3416], [3649, 3649, 3682, 3682, 3829], [3877, 4055, 4249, 4249, 5315], [5392, 5392, 5488, 5488, 5991], [6012, 6012, 6030, 6030, 6290], [6292, 6292, 6328, 6328, 6636], [6638, 6638, 6672, 6672, 6766], [6768, 6768, 6798, 6798, 6885], [7488, 7488, 7515, 7515, 8261], [8263, 8263, 8287, 8287, 8664], [8666, 8666, 8707, 8707, 9254], [9256, 9256, 9302, 9302, 9507], [9509, 9509, 9697, 9697, 11055], [11057, 11057, 11206, 11206, 13141], [13144, 13144, 13179, 13179, 13355], [13357, 13357, 13495, 13495, 14546], [14549, 14549, 14588, 14588, 15322], [15324, 15339, 15408, 15408, 17026]]}
{"id": "Nl2SzG", "name": "Hex Truchet Visualiser [Sound]", "author": "Pelegefen", "description": "\nA Visualiser manipulating a hexagonaly tiled truchet pattern's width and color values.\ncode is a bit obfuscated, might do the refactoring when have some spare time.\n\nFeel free to change the song!", "tags": ["nyan", "interactive", "hexagon", "truchet", "cat", "hexagonal", "tilling", "traditional"], "likes": 4, "viewed": 332, "published": 3, "date": "1628615104", "time_retrieved": "2024-07-30T19:06:54.303044", "image_code": "\n\n//Made with love by Peleg Gefen <3\n\n///let's you see the tilling and rotations to each tile marked with color from black 0 - to whitish gray 2\n//#define Debug \n\n\n//Let's you toggle between constant and variable width - on by default\n#define Shrink\n\n#define ZOOM 15.\n\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rot120   = MROT(TAU/3.0);\n\nfloat freqs[4];\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) \n  * 13758.5453);\n}\n\n\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    //distance to the diagonal line\n    float c = dot(p, normalize(vec2(1., 1.73)));\n\n    // distance to the vertical line\n    c = max(c, p.x);\n    //c += sin(iTime + 4000.) *5. +5.;\n    return c;\n  }\n\nvec4 hexCoords(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n    if(length(a) < length(b))\n      gv = a;\n    else\n      gv = b;\n\n    float y = .5 - hexDist(gv);\n    float x = atan(gv.x, gv.y);\n    vec2 id = uv - gv;\n    return vec4(x, y, id.x, id.y);\n\n}\n\nvec4 hexCoordsOffs(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n    if(length(a) < length(b))\n      gv = a;\n    else\n      gv = b;\n\n    float y = .5 - hexDist((gv - vec2(0., .5)));\n    y = abs(y + .25);\n    //y += .5 - hexDist((gv + vec2(0., .5)));\n    float x = atan(gv.x,gv.y);\n    \n    vec2 id = uv - gv;\n    return vec4(gv, id.x, id.y);\n\n}\n\nvec3 Truchet(vec2 uv, vec2 id, float width,vec2 seed, out float rotations){ //xy are UV, z is mask\n\n    \n    \n    // float checker = mod(id.x , 2.5);\n     \n     //Random Rotation\n     float h = hash(id + seed);\n     h *= 3.;\n     h = floor(h);\n     uv = rot(uv, (h *  (TAU / 3.)) );\n     \n     \n     \n     \n     \n     vec2 offs = vec2(.400,.7);\n     float a = length(uv + offs  );\n     float b = length(uv - offs );\n     vec2 cUv = uv + offs;\n        float aa = atan(cUv.x,cUv.y);\n        cUv = uv + offs;\n         float bb = atan(cUv.x,cUv.y);\n    \n      float c = smoothstep(.70001 + width,.7 + width, a); \n      c -= smoothstep(.70001 - width,.7- width, a); \n     \n     float d = smoothstep(.70001 + width,.7+ width, b); \n     d -= smoothstep(.70001 - width,.7- width, b); \n     \n     float l1 = length(uv.x - uv.y * .585 );//line gradiant\n     float w = width *1.25;\n     float l = smoothstep(w,w - .01,l1 );//line mask\n\n      float mask = (c + d + l );\n      \n       float s = length((uv.x +( width* .585)) - (uv.y + (width* .585)) * .585 );\n\n       //float x = ((aa * c) + (bb * d) + (((uv.x + uv.y)) * l));\n       \n       \n       float subMask = clamp( l-(c)-(d),0.0,1.);\n     //  mask = max(mask, subMask);\n              float x = (c+d+subMask) * length(uv);\n\n       float y = ((((1. - abs((a-(.705 - (w/2.)))/(w) -.5))) * c)// bottom \n      \n       + (((1. - abs((b-(.705- (w /2.)))/(w) -.5)))* d)// top\n        \n       \n       +clamp(min(l,subMask + w) * (1.- (s / (w))),0.0,1.));// stright line\n       \n             float m = min(mask,(subMask + c + d));\n\n      if(mod(id.x,2.) == 0.)x = .5-x /m;\n      \n      \n       rotations = h;\n       vec3 tUv = vec3(x,y,m);\n    tUv = clamp(tUv,0.,1.);\n    return tUv;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    freqs[0] = texture( iChannel2, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel2, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel2, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel2, vec2( 0.30, 0.25 ) ).x;\n    float avgFreq = (freqs[0] +freqs[1] +freqs[2] +freqs[3])/4.;\n\tfloat iTime = iTime * .25;\n\tiTime += 800.;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)\n\t/iResolution.y;\n    uv = rot(uv,sin((iTime+(1.- freqs[0])*.1)*TAU)*.5+.5);\n    \n     vec4 col = vec4(0.);\n     vec2 uv1 = uv;\n     uv *= max(ZOOM,1.1) + sin(iTime) * 5.;\n     //uv += 10.;\n     //uv *= (sin(iTime * .75)*1.5+1.5) + 3.;\n     uv += vec2(iTime * 7. +( freqs[1]));\n\n   \n     uv -= (iMouse.xy / iResolution.xy) * 15. ;\n     \n\n      vec4 uvid = hexCoords(uv);\n     vec4 uvidOf = hexCoordsOffs(uv);\n     vec4 uvidOf1 = hexCoordsOffs(uv - .25);\n\n    vec2 id = uvidOf.zw;\n        vec2 id1 = uvidOf1.zw;\n\n     vec2 huv = uvidOf.xy;\n     vec2 huv1 = uvidOf1.xy;\n\n       #ifdef Shrink\n       \n       \n       \n       float f = (avgFreq- freqs[0])*freqs[1];\n       float l =  length((((fragCoord.xy / iResolution.y) - vec2(.9,.5)) / (freqs[1]  ) ));\n       vec2 res = ((fragCoord.xy / iResolution.y) - vec2(.5,.5)) * (f )  ;\n       res = rot(res, (f+iTime) * PI);\n       float atanUv = atan(res.x + l,res.y + l) ;\n       \n       \n       float width = 1. -l / atanUv  ; \n        width = clamp(fract(width + sin(\n        (mix((uv1.x / freqs[1]) + (uv1.y* freqs[2]),uv1.y * uv1.x\n        , cos(iTime * .1)*1.5+1.5)))*1.5 * freqs[1]) * \n        length((1.-uv1)*.1 ),\n        0.3 - freqs[1],//mix\n        0.1)  ;\n       \n      \n      \n     \n       \n       \n       #else\n        float width = .07;\n       #endif\n       float r1,r2,r3;\n       vec3 tUv = Truchet(huv,id,width,vec2(.1,.7),r1);\n       \n       vec4 htUv = hexCoordsOffs(fract(tUv.xy * 0.1));\n\n       vec3 tUv1 = Truchet(huv1 ,id1,width * .75,vec2(.4,.2) ,r2);\n       //col = vec4(tUv.z) * .3;\n       \n       \n       float mask = tUv.z;\n       \n       \n       \n       vec3 hUv = Truchet(htUv.xy ,htUv.zw,width,vec2(1.1,4.2) ,r3);\n       \n       vec4 hTruchet = texture(iChannel0,(hUv.xy ));\n\n       vec4 truchet1 = texture(iChannel0,(tUv.xy )+ vec2(-iTime,0.)) * mask * tUv.y;\n       \n       \n       vec4 truchet2 = texture(iChannel1, tUv1.xy+ vec2(-iTime,0.)) * tUv1.z* tUv1.y;\n       \n       \n       col += mix(truchet1  , truchet2 , (tUv.x + (tUv1.y - (tUv.x) ))*.5);\n       col = mix(col * hTruchet,col,sin(freqs[1] )*.5+.5);\n       col /= vec4(hUv * freqs[0],1.);\n       vec4 randCol = vec4(\n       sin(iTime*.25)*.5+.5,\n       sin(iTime*.5)*.5+.5,\n       sin(iTime)*.5+.5,\n       1.);\n       col /= randCol;\n       col -= randCol;\n       // col = vec4(0.);\n       // col.x = tUv.z;\n        \n      \n         #ifdef Debug\n \t float grid =( smoothstep(.01,.011,smoothstep(.0071,.007,uvid.y)));\n     col.r += grid * .3;\n        col += vec4(((r1 + 1.5) / 3.) * 1. - mask) * .3;\n     #endif\n     col = clamp(col,0.,1.);\n     \n\tfragColor = vec4( col);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28007, "src": "https://m.soundcloud.com/cheshire/all-i-wanna-do", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[523, 523, 547, 547, 620], [623, 623, 650, 650, 725], [729, 729, 752, 752, 969], [971, 971, 996, 996, 1316], [1318, 1318, 1347, 1347, 1754], [1756, 1756, 1831, 1934, 3477], [3479, 3479, 3536, 3536, 6525]]}
{"id": "ftSXDV", "name": "Maze Ball Solved 2", "author": "dr2", "description": "Upgraded visuals - control widgets now in world space (see source)", "tags": ["game", "interactive", "dynamics", "physics", "puzzle"], "likes": 29, "viewed": 501, "published": 3, "date": "1628593608", "time_retrieved": "2024-07-30T19:06:55.398117", "image_code": "// \"Maze Ball Solved 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Roll the ball through the solved maze.\n  Drag knob to control tilt angles (vary automatically until first click);\n  click button for new random maze before timer expires; otherwise mouse\n  controls view angle.\n*/\n\n#define AA  0   // optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nmat3 StdVuMat (float el, float az);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvec3 wgObj[2], ltDir, qHit, bSize, vnBall;\nvec2 aTilt, ballPos, cEn, cEx;\nfloat dstFar, tCur, gSize, autoRot, nStep, growLim, pathLen, frameUp, tFrac;\nint idObj;\nconst int idMaz = 1, idFrm = 2, idAx = 3, idTimer = 4, idCon = 5, idBut = 6;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p :\n     vec2 (- p.y, p.x)) : ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat ValMaze (vec2 q)\n{\n  vec2 ut, e;\n  float dw, s;\n  ut = q * gSize;\n  s = Loadv4 (floor (ut)).x;\n  dw = WallDst (ut, s);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (ut) - e).x == ai) dw = min (dw, WallDst (ut, mod (ai + 2., 4.)));\n  }\n  return dw;\n}\n\nfloat HtMaze (vec2 q)\n{\n  return 1. - smoothstep (0.15, 0.4, ValMaze (q));\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h, frmLen, frmWid, frmGap;\n  dMin = dstFar;\n  frmWid = 1.3 * bSize.y;\n  frmLen = bSize.x * (1. - 0.9 / gSize) + 1.1 * frmWid;\n  frmGap = 0.1;\n  p.y -= frameUp;\n  q = p;\n  q.xy = Rot2D (q.xy, aTilt.x);\n  q.zy = Rot2D (q.zy, aTilt.y);\n  h = 0.5 * bSize.y * HtMaze (0.5 * q.xz / bSize.xz + 0.5 + 0.001);\n  q.y -= h;\n  d = 0.6 * PrRoundBoxDf (q, vec3 (bSize.xz * (1. - 0.9 / gSize), bSize.y + h).xzy - 0.02, 0.02);\n  DMINQ (idMaz);\n  q.y -= - h;\n  q.xz = (abs (q.x) < abs (q.z)) ? q.xz : q.zx;\n  q.z = abs (q.z) - frmLen;\n  d = PrRoundBoxDf (q, vec3 (frmLen + frmWid, frmWid, frmWid) - 0.1, 0.1);\n  DMINQ (idFrm);\n  frmLen += 2. * frmWid + frmGap;\n  q = p;\n  q.xy = Rot2D (q.xy, aTilt.x);\n  q.xz = (abs (q.x) < abs (q.z)) ? q.xz : q.zx;\n  q.z = abs (q.z) - frmLen;\n  d = PrRoundBoxDf (q, vec3 (frmLen + frmWid, frmWid, frmWid) - 0.1, 0.1);\n  DMINQ (idFrm);\n  frmLen += 2. * frmWid + frmGap;\n  q = p;\n  q.xz = (abs (q.x) < abs (q.z)) ? q.xz : q.zx;\n  q.z = abs (q.z) - frmLen;\n  d = PrRoundBoxDf (q, vec3 (frmLen + frmWid, frmWid, frmWid) - 0.1, 0.1);\n  DMINQ (idFrm);\n  q.x = abs (q.x) - frmLen;\n  q.y -= -0.5 * frameUp - frmWid;\n  d = PrRoundBoxDf (q, vec3 (frmWid, 0.5 * frameUp + frmWid, frmWid) - 0.1, 0.1);\n  DMINQ (idFrm);\n  frmLen = bSize.x * (1. - 0.9 / gSize) + frmWid;\n  frmLen += 2. * frmWid + frmGap;\n  q = p;\n  q.xy = Rot2D (q.xy, aTilt.x);\n  q.x = abs (q.x) - frmLen + 0.3 * frmWid + frmGap;\n  d = PrCapsDf (q.zyx, 0.6 * frmWid, frmWid + frmGap);\n  DMINQ (idAx);\n  frmLen += 2. * frmWid + frmGap;\n  q = p;\n  q.z = abs (q.z) - frmLen + 0.3 * frmWid + frmGap;\n  d = PrCapsDf (q, 0.6 * frmWid, frmWid + frmGap);\n  DMINQ (idAx);\n  p.y += frameUp;\n  q = p;\n  q.xz -= wgObj[0].xy;\n  d = PrRoundBoxDf (q, vec3 (wgObj[0].z, 0.2, wgObj[0].z) - 0.1, 0.1);\n  DMINQ (idCon);\n  q -= vec3 (aTilt / 0.2, 0.2).xzy;\n  d = PrRoundCylDf (q.xzy, 0.3, 0.1, 0.1);\n  DMINQ (idAx);\n  q = p;\n  q.xz -= wgObj[1].xy;\n  d = PrRoundCylDf (q.xzy, wgObj[1].z, 0.1, 0.1);\n  DMINQ (idBut);\n  q = p;\n  q -= vec3 (-0.9 * gSize, 0.1, 0.);\n  d = PrRoundBoxDf (q, vec3 (1., 0.2, 1.) - 0.1, 0.1);\n  DMINQ (idTimer);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;vec4 (0.9, 0.9, 0.95, 0.2);\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallRay (vec3 ro, vec3 rd)\n{\n  vec3 u;\n  float b, d, w, dMin, rad;\n  ro.y -= frameUp;\n  ro.xy = Rot2D (ro.xy, aTilt.x);\n  ro.zy = Rot2D (ro.zy, aTilt.y);\n  rd.xy = Rot2D (rd.xy, aTilt.x);\n  rd.zy = Rot2D (rd.zy, aTilt.y);\n  dMin = dstFar;\n  rad = 0.25;\n  u = ro - vec3 (ballPos.x, rad + 0.6 * bSize.y, ballPos.y);\n  b = dot (rd, u);\n  w = b * b - dot (u, u) + rad * rad;\n  if (w >= 0.) {\n    d = - b - sqrt (w);\n    if (d > 0. && d < dMin) {\n      dMin = d;\n      vnBall = (u + d * rd) / rad;\n    }\n  }\n  return dMin;\n}\n\nfloat BallChqr (vec3 vn)\n{\n  vec3 u;\n  vec2 a;\n  u = QtToRMat (vec4 (Loadv4 (vec2 (6., 0.)).zw, Loadv4 (vec2 (7., 0.)).zw)) * vn;\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return step (0., sign (a.x) * sign (a.y));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 ut, utb, h;\n  float dstObj, dstBall, nw, nDotL, sh, s;\n  bool isBg, isMet;\n  dstBall = BallRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  isBg = false;\n  isMet = false;\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idMaz) {\n        if (qHit.y > 0.) {\n          ut = qHit.xz / bSize.xz;\n          col4 = mix (vec4 (0.6, 0.8, 0.6, 0.2), vec4 (0.4, 0.5, 0.8, 0.05) *\n             (0.8 + 0.2 * Fbm2 (64. * qHit.xz)), smoothstep (0.3, 0.35, ValMaze (0.5 * ut + 0.5)));\n          utb = 0.5 * gSize * (ut + 1.);\n          h = cEn + vec2 (0.6, 1.);\n          col4.rgb = mix (((length (ballPos + 0.5 * gSize - h) < 0.5) ?\n             vec3 (1., 0., 0.) : vec3 (0., 1., 0.)), col4.rgb,\n             smoothstep (0.15, 0.18, length (utb - h)));\n          h = cEx + vec2 (1.4, 1.);\n          col4 = mix (((length (ballPos + 0.5 * gSize - h) < 0.5) ?\n             vec4 (1., 0., 0., -1.) : vec4 (0., 1., 0., -1.)), col4,\n             smoothstep (0.15, 0.18, length (utb - h)));\n          if (nStep > 5. * growLim || pathLen > 0.) {\n            nw = floor (Loadv4 (floor (mod (utb - 0.5, gSize))).y / 32.);\n            if (nw > 0.) col4 = mix ((mod (nw / max (pathLen, 1.) - 0.2 * tCur, 1.) < 0.1) ?\n               vec4 (1., 0.8, 0., -1.) : ((dot (abs (aTilt), vec2 (1.)) < 0.01 || autoRot == 1.) ?\n               vec4 (1., 0.8, 0., -1.) : col4), col4, smoothstep (0.12, 0.15,\n               length (abs (fract (utb + 0.5) - 0.5))));\n          }\n          col4.rgb *= 0.8 + 0.2 * smoothstep (0.25, 0.3, length (0.5 * gSize * ut - ballPos));\n        } else col4 = vec4 (0.4, 0.3, 0.3, 0.);\n      } else if (idObj == idFrm) {\n        col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      } else if (idObj == idAx) {\n        col4 = vec4 (0.9, 0.8, 0.2, 0.2);\n      } else if (idObj == idBut) {\n        col4 = mix (vec4 (0.9, 0.8, 0.2, 0.2), vec4 (0.9, 0.9, 0.95, 0.2), step (0.35, length (qHit.xz)));\n      } else if (idObj == idCon) {\n        col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      } else if (idObj == idTimer) {\n        if (abs (length (qHit.xz) - 3. * bSize.y) < bSize.y) {\n          qHit.xz = Rot2D (qHit.xz, -0.5 * pi);\n          col4 = vec4 (mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),\n             step (0.5 * (atan (qHit.z, - qHit.x) / pi + 1.), tFrac)), -1.);\n        } else col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      }\n      isMet = (idObj != idMaz);\n    } else if (dstBall < dstFar) {\n      vn = vnBall;\n      col4 = vec4 (mix (vec3 (1., 0.3, 1.), vec3 (0.8, 1., 0.3), BallChqr (vn)), 0.3);\n      vn.zy = Rot2D (vn.zy, - aTilt.y);\n      vn.xy = Rot2D (vn.xy, - aTilt.x);\n      isMet = true;\n    }\n  } else isBg = true;\n  if (isBg) {\n    if (rd.y < 0.) {\n      ro += (- ro.y / rd.y) * rd;\n      col4 = mix (vec4 (0.7, 0.3, 0.1, 0.1), vec4 (0.4, 0.2, 0.1, 0.1),\n         Fbm2 (ro.xz * vec2 (0.5, 4.)));\n      vn = vec3 (0., 1., 0.);\n      isMet = false;\n    } else col = vec3 (0.1);\n  }\n  if (! isBg || isBg && rd.y < 0.) {\n    sh = (! isBg && dstObj < min (dstBall, dstFar) && col4.a >= 0. || isBg && rd.y < 0.) ? \n       sh = ObjSShadow (ro, ltDir) : 1.;\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, ltDir), 0.);\n      if (isMet) nDotL *= nDotL;\n      col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) *  pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.);\n      if (isBg) col *= 0.2 + 0.8 * smoothstep (0.93, 0.97, dot (normalize (64. * ltDir - ro), ltDir));\n    } else col = col4.rgb * (0.3 + 0.7 * sh) * (0.7 - 0.3 * dot (rd, vn));\n  }\n  if (! isBg && isMet && col4.a >= 0. || isBg && rd.y < 0.) {\n    rd = reflect (rd, vn);\n    h = mod (8. * vec2 (atan (rd.z, rd.x), 2. * asin (rd.y)) + 0.5, 1.) - 0.5;\n    col = mix (col, vec3 (1.), (isMet ? 0.05 : 0.01) * step (0.1, min (h.x, h.y)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, asp, sr, zmFac, oDist;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  gSize = Loadv4 (vec2 (0., 0.)).z;\n  nStep = Loadv4 (vec2 (1., 0.)).z;\n  stDat = Loadv4 (vec2 (3., 0.));\n  aTilt = clamp (stDat.zw, -0.25, 0.25);\n  cEn = Loadv4 (vec2 (3., 1.)).zw;\n  cEx = Loadv4 (vec2 (4., 1.)).zw;\n  stDat.zw = Loadv4 (vec2 (5., 1.)).zw;\n  growLim = stDat.z;\n  pathLen = stDat.w;\n  bSize = vec3 (0.5 * gSize, 0.15, 0.5 * gSize);\n  frameUp = 18. * bSize.y;\n  ballPos = Loadv4 (vec2 (4., 0.)).zw;\n  autoRot = Loadv4 (vec2 (2., 1.)).w;\n  tFrac = Loadv4 (vec2 (2., 0.)).z;\n  stDat = Loadv4 (vec2 (0., 1.));\n  el = stDat.z;\n  az = stDat.w;\n  vuMat = StdVuMat (el, az);\n  stDat = Loadv4 (vec2 (6., 1.));\n  zmFac = stDat.z;\n  oDist = stDat.w;\n  ro = vuMat * vec3 (0., 0., - oDist * gSize);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  wgObj[0] = vec3 (0.9 * gSize, 0., 1.6);\n  wgObj[1] = vec3 (0.9 * gSize, 0.5 * gSize, 0.4);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Maze Ball Solved 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvec4 ballQt;\nvec3 wgObj[2];\nvec2 aTilt, ballPos, ballVel;\nfloat gSize;\nconst float pi = 3.1415927;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p :\n     vec2 (- p.y, p.x)) : ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat HtMaze (vec2 p)\n{\n  vec2 e;\n  float dw, s;\n  p += 0.5 * gSize;\n  s = Loadv4 (floor (p)).x;\n  dw = WallDst (p, (s >= 0.) ? s : -1.);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (p) - e).x == ai) dw = min (dw, WallDst (p, mod (ai + 2., 4.)));\n  }\n  return max (1. - 4. * dw, 0.);\n}\n\nvoid Step ()\n{\n  float s, v;\n  s = 0.25;\n  ballVel -= 0.2 * sign (ballVel) *\n      vec2 (HtMaze (ballPos + vec2 (s * sign (ballVel.x), 0.)),\n            HtMaze (ballPos + vec2 (0., s * sign (ballVel.y))));\n  ballVel += 0.005 * aTilt - 0.03 * ballVel;\n  if (length (ballVel) > 0.1) ballVel *= 0.1 / length (ballVel);\n  ballPos += ballVel;\n  if (abs (ballPos.x) > 0.5 * gSize - 0.7) {\n    ballPos.x = (0.5 * gSize - 0.71) * sign (ballPos.x);\n    ballVel = vec2 (0.);\n  }\n  v = length (ballVel);\n  if (v > 0.) ballQt = normalize (QtMul (ballQt,\n     RotToQt (normalize (vec3 (- ballVel.y, 0., ballVel.x)), v / 0.25)));\n}\n         \nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, mPtrP, stDat, fVal, cb, cbi, cbf;\n  vec3 vCon, ro;\n  vec2 canvas, iFrag, ud, us, ev[4], cEn, cEx;\n  float tCur, nStep, growLim, autoRot, tGame, tBgn, ai, ar, nw, nwn, nb, dir,\n     az, el, asp, pathLen, zmFac, oDist;\n  int wgSel, wgReg, kIn;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = 10.;\n  if (Maxv2 (fragCoord) >= gSize) discard;\n  wgSel = -1;\n  wgReg = -2;\n  aTilt = vec2 (0.);\n  az = 0.;\n  el = -0.3 * pi;\n  asp = canvas.x / canvas.y;\n  init = (iFrame <= 5);\n  tGame = 60.;\n  zmFac = 8.;\n  oDist = 5.7;\n  if (! init) {\n    stDat = Loadv4 (vec2 (0., 1.));\n    el = stDat.z;\n    az = stDat.w;\n    autoRot = Loadv4 (vec2 (2., 1.)).w;\n    aTilt = Loadv4 (vec2 (3., 0.)).zw;\n    mPtrP = vec4 (Loadv4 (vec2 (1., 1.)).zw, Loadv4 (vec2 (2., 1.)).z, 0.);\n    wgSel = int (Loadv4 (vec2 (1., 0.)).w);\n    if (mPtr.z > 0.) {\n      vuMat = StdVuMat (el, az);\n      ro = vuMat * vec3 (0., 0., - oDist * gSize);\n      vCon = vuMat * normalize (vec3 (2. * mPtr.xy * vec2 (asp, 1.), zmFac));\n      ud = (ro.xz + (- (ro.y - 0.2) / vCon.y) * vCon.xz);\n      wgObj[0] = vec3 (0.9 * gSize, 0., 1.6);\n      wgObj[1] = vec3 (0.9 * gSize, 0.5 * gSize, 0.4);\n      us = ud - wgObj[0].xy;\n      if (Maxv2 (abs (us)) < wgObj[0].z - 0.1 || wgSel == 0) {\n        if (wgSel == 0 && Maxv2 (abs (us)) < wgObj[0].z + 0.3) {\n          aTilt = 0.2 * us;\n          autoRot = 0.;\n        }\n        wgReg = 0;\n      } else if (length (ud - wgObj[1].xy) < wgObj[1].z || wgSel == 1) {\n        if (mPtrP.z <= 0.) init = true;\n        wgReg = 1;\n      } else if (wgReg < 0) {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.25 * pi + pi * mPtr.y, -0.4 * pi, -0.1 * pi);\n      }\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else {\n      aTilt *= 0.9;\n      wgSel = -1;\n      wgReg = -2;\n    }\n  }\n  iFrag = floor (fragCoord);\n  fVal = Loadv4 (iFrag);\n  if (! init) {\n    tBgn = Loadv4 (vec2 (2., 0.)).w;\n    init = (tCur - tBgn > tGame + 10.);\n  }\n  if (init) {\n    mPtrP = mPtr;\n    autoRot = 1.;\n    nStep = 0.;\n    pathLen = 0.;\n    growLim = 2. * gSize;\n    tBgn = floor (tCur);\n    ar = -1.;\n    cEn = vec2 (0., 1.);\n    cEx = gSize - vec2 (2., 3.);\n    if (iFrag.y == 0. && iFrag.x < gSize - 1.) ar = 1.;\n    else if (iFrag.x == gSize - 1. && iFrag.y < gSize - 1.) ar = 0.;\n    else if (iFrag.y == gSize - 1. && iFrag.x > 0.) ar = 3.;\n    else if (iFrag.x == 0. && iFrag.y > 0.) ar = 2.;\n    if (iFrag.x == cEn.x && iFrag.y > cEn.y) ar = 0.;\n    else if (iFrag.x > cEx.x && iFrag.y <= cEx.y) ar = 2.;\n    if (iFrag.y > 0. && iFrag.y < gSize - 1.) {\n      if (Hashff (tCur + 111.1) > 0.5 && iFrag.x == floor (gSize / 4.)) ar = 2.;\n      if (Hashff (tCur + 211.1) > 0.5 && iFrag.x == floor (3. * gSize / 4.)) ar = 0.;\n    }\n    ballPos = cEn + vec2 (-0.5 * gSize + 0.8, -0.5 * gSize + 1.);\n    ballVel = vec2 (0.);\n    ballQt = vec4 (0., 0., 0., 1.);\n    fVal.x = ar;\n  } else {\n    nStep = Loadv4 (vec2 (1., 0.)).z;\n    cEn = Loadv4 (vec2 (3., 1.)).zw;\n    cEx = Loadv4 (vec2 (4., 1.)).zw;\n    stDat.zw = Loadv4 (vec2 (5., 1.)).zw;\n    growLim = stDat.z;\n    pathLen = stDat.w;\n    ++ nStep;\n    ar = fVal.x;\n    ev[0] = vec2 (0., 1.);\n    ev[1] = vec2 (1., 0.);\n    ev[2] = vec2 (0., -1.);\n    ev[3] = vec2 (-1., 0.);\n    cbf = vec4 (1., 2., 4., 8.);\n    if (nStep < growLim && ar < 0.) {\n      ai = floor (4. * Hashfv2 (iFrag + tCur));\n      if (Hashfv2 (iFrag + tCur + 11.1) > 0.3) {\n        if (iFrag.y == 1.) {\n          if (ai == 2.) ai = 0.;\n        } else if (iFrag.y == gSize - 2.) {\n          if (ai == 0.) ai = 2.;\n        } else if (iFrag.x == 1.) {\n          if (ai == 3.) ai = 1.;\n        } else if (iFrag.x == gSize - 2.) {\n          if (ai == 1.) ai = 3.;\n        }\n      }\n      if (Loadv4 (iFrag + ((ai < 2.) ? ((ai == 0.) ? ev[0] : ev[1]) :\n         ((ai == 2.) ? ev[2] : ev[3]))).x >= 0.) ar = ai;\n    }\n    fVal.x = ar;\n    if (nStep < growLim) fVal.y = (Maxv2 (iFrag) <= gSize - 2.) ? -1. : 0.;\n    if (nStep > 2. * growLim) pathLen = floor (Loadv4 (cEx).y / 32.);\n    if (Maxv2 (iFrag) <= gSize - 2.) {\n      cb = vec4 (0.);\n      ar = Loadv4 (iFrag).x;\n      cb.wz += vec2 ((ar == 0.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[0]).x;\n      cb.wx += vec2 ((ar == 2.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + vec2 (1., 1.)).x;\n      cb.yx += vec2 ((ar == 2.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[1]).x;\n      cb.yz += vec2 ((ar == 0.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      nw = fVal.y;\n      if (nStep == growLim) {\n        nw = dot (cb, vec4 (1.));\n      } else if (nStep > growLim && nStep < 2. * growLim) {\n        if (nw < 3.) {\n          nb = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y >= 3.) ++ nb;\n          if (nw + nb == 3.) nw = 4.;\n        } else nw = 4.;\n      } else if (nStep == 2. * growLim) {\n        if (nw < 3.) {\n          nw = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y < 3.) nw += cbf[k];\n        } else nw = 0.;\n      } else if (nStep > 2. * growLim && nStep < 5. * growLim && pathLen == 0.) {\n        if (nw > 0. && nw < 32.) {\n          dir = 0.;\n          cbi = 1. / cbf;\n          cb = mod (floor (nw * cbi), 2.);\n          if (iFrag == cEn) {\n            if (cb[2] > 0.) dir = 1.;\n            nw += 32. * 1.;\n          } else {\n            cbi = cbi.zwxy;\n            for (int k = 0; k < 4; k ++) {\n              if (nw < 32. && cb[k] > 0.) {\n                nwn = Loadv4 (mod (iFrag + ev[k], gSize)).y;\n                if ((nwn - 32.) * mod (floor (nwn * cbi[k]), 2.) > 0.) {\n                  nw += 32. * (floor (nwn / 32.) + 1.);\n                  kIn = k;\n                  break;\n                }\n              }\n            }\n            if (kIn == 0) {\n              if (cb[2] > 0. || cb[3] > 0.) dir = 1.;\n            } else if (kIn == 1) {\n              if (cb[3] > 0. || cb[0] > 0.) dir = 1.;\n            } else if (kIn == 2) {\n              if (cb[1] > 0.) dir = 1.;\n            } else if (kIn == 3) {\n              if (cb[2] > 0.) dir = 1.;\n            }\n          }\n          nw += 16. * (dir - mod (floor (nw / 16.), 2.));\n        }\n      }\n      fVal.y = nw;\n    }\n  }\n  if (! init && iFrag.y == 0. && iFrag.x <= 7.) {\n    ballPos = Loadv4 (vec2 (4., 0.)).zw;\n    ballVel = Loadv4 (vec2 (5., 0.)).zw;\n    ballQt = vec4 (Loadv4 (vec2 (6., 0.)).zw, Loadv4 (vec2 (7., 0.)).zw);\n    if (autoRot > 0.) aTilt = 0.15 * sin (0.1 * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n    if (nStep > growLim) Step ();\n  }\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (gSize, 0.);\n    else if (iFrag.x == 1.) fVal.zw = vec2 (nStep, float (wgSel));\n    else if (iFrag.x == 2.) fVal.zw = vec2 ((tCur - tBgn) / tGame, tBgn);\n    else if (iFrag.x == 3.) fVal.zw = aTilt;\n    else if (iFrag.x == 4.) fVal.zw = ballPos;\n    else if (iFrag.x == 5.) fVal.zw = ballVel;\n    else if (iFrag.x == 6.) fVal.zw = ballQt.xy;\n    else if (iFrag.x == 7.) fVal.zw = ballQt.zw;\n  } else if (iFrag.y == 1.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (el, az);\n    else if (iFrag.x == 1.) fVal.zw = mPtr.xy;\n    else if (iFrag.x == 2.) fVal.zw = vec2 (mPtr.z, autoRot);\n    else if (iFrag.x == 3.) fVal.zw = cEn;\n    else if (iFrag.x == 4.) fVal.zw = cEx;\n    else if (iFrag.x == 5.) fVal.zw = vec2 (growLim, pathLen);\n    else if (iFrag.x == 6.) fVal.zw = vec2 (zmFac, oDist);\n  }\n  fragColor = fVal;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Maze Ball Solved 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RotToQt (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\nvec4 ballQt;\nvec3 wgObj[2];\nvec2 aTilt, ballPos, ballVel;\nfloat gSize;\nconst float pi = 3.1415927;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p :\n     vec2 (- p.y, p.x)) : ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat HtMaze (vec2 p)\n{\n  vec2 e;\n  float dw, s;\n  p += 0.5 * gSize;\n  s = Loadv4 (floor (p)).x;\n  dw = WallDst (p, (s >= 0.) ? s : -1.);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (p) - e).x == ai) dw = min (dw, WallDst (p, mod (ai + 2., 4.)));\n  }\n  return max (1. - 4. * dw, 0.);\n}\n\nvoid Step ()\n{\n  float s, v;\n  s = 0.25;\n  ballVel -= 0.2 * sign (ballVel) *\n      vec2 (HtMaze (ballPos + vec2 (s * sign (ballVel.x), 0.)),\n            HtMaze (ballPos + vec2 (0., s * sign (ballVel.y))));\n  ballVel += 0.005 * aTilt - 0.03 * ballVel;\n  if (length (ballVel) > 0.1) ballVel *= 0.1 / length (ballVel);\n  ballPos += ballVel;\n  if (abs (ballPos.x) > 0.5 * gSize - 0.7) {\n    ballPos.x = (0.5 * gSize - 0.71) * sign (ballPos.x);\n    ballVel = vec2 (0.);\n  }\n  v = length (ballVel);\n  if (v > 0.) ballQt = normalize (QtMul (ballQt,\n     RotToQt (normalize (vec3 (- ballVel.y, 0., ballVel.x)), v / 0.25)));\n}\n         \nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, mPtrP, stDat, fVal, cb, cbi, cbf;\n  vec3 vCon, ro;\n  vec2 canvas, iFrag, ud, us, ev[4], cEn, cEx;\n  float tCur, nStep, growLim, autoRot, tGame, tBgn, ai, ar, nw, nwn, nb, dir,\n     az, el, asp, pathLen, zmFac, oDist;\n  int wgSel, wgReg, kIn;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = 10.;\n  if (Maxv2 (fragCoord) >= gSize) discard;\n  wgSel = -1;\n  wgReg = -2;\n  aTilt = vec2 (0.);\n  az = 0.;\n  el = -0.3 * pi;\n  asp = canvas.x / canvas.y;\n  init = (iFrame <= 5);\n  tGame = 60.;\n  zmFac = 8.;\n  oDist = 5.7;\n  if (! init) {\n    stDat = Loadv4 (vec2 (0., 1.));\n    el = stDat.z;\n    az = stDat.w;\n    autoRot = Loadv4 (vec2 (2., 1.)).w;\n    aTilt = Loadv4 (vec2 (3., 0.)).zw;\n    mPtrP = vec4 (Loadv4 (vec2 (1., 1.)).zw, Loadv4 (vec2 (2., 1.)).z, 0.);\n    wgSel = int (Loadv4 (vec2 (1., 0.)).w);\n    if (mPtr.z > 0.) {\n      vuMat = StdVuMat (el, az);\n      ro = vuMat * vec3 (0., 0., - oDist * gSize);\n      vCon = vuMat * normalize (vec3 (2. * mPtr.xy * vec2 (asp, 1.), zmFac));\n      ud = (ro.xz + (- (ro.y - 0.2) / vCon.y) * vCon.xz);\n      wgObj[0] = vec3 (0.9 * gSize, 0., 1.6);\n      wgObj[1] = vec3 (0.9 * gSize, 0.5 * gSize, 0.4);\n      us = ud - wgObj[0].xy;\n      if (Maxv2 (abs (us)) < wgObj[0].z - 0.1 || wgSel == 0) {\n        if (wgSel == 0 && Maxv2 (abs (us)) < wgObj[0].z + 0.3) {\n          aTilt = 0.2 * us;\n          autoRot = 0.;\n        }\n        wgReg = 0;\n      } else if (length (ud - wgObj[1].xy) < wgObj[1].z || wgSel == 1) {\n        if (mPtrP.z <= 0.) init = true;\n        wgReg = 1;\n      } else if (wgReg < 0) {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.25 * pi + pi * mPtr.y, -0.4 * pi, -0.1 * pi);\n      }\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else {\n      aTilt *= 0.9;\n      wgSel = -1;\n      wgReg = -2;\n    }\n  }\n  iFrag = floor (fragCoord);\n  fVal = Loadv4 (iFrag);\n  if (! init) {\n    tBgn = Loadv4 (vec2 (2., 0.)).w;\n    init = (tCur - tBgn > tGame + 10.);\n  }\n  if (init) {\n    mPtrP = mPtr;\n    autoRot = 1.;\n    nStep = 0.;\n    pathLen = 0.;\n    growLim = 2. * gSize;\n    tBgn = floor (tCur);\n    ar = -1.;\n    cEn = vec2 (0., 1.);\n    cEx = gSize - vec2 (2., 3.);\n    if (iFrag.y == 0. && iFrag.x < gSize - 1.) ar = 1.;\n    else if (iFrag.x == gSize - 1. && iFrag.y < gSize - 1.) ar = 0.;\n    else if (iFrag.y == gSize - 1. && iFrag.x > 0.) ar = 3.;\n    else if (iFrag.x == 0. && iFrag.y > 0.) ar = 2.;\n    if (iFrag.x == cEn.x && iFrag.y > cEn.y) ar = 0.;\n    else if (iFrag.x > cEx.x && iFrag.y <= cEx.y) ar = 2.;\n    if (iFrag.y > 0. && iFrag.y < gSize - 1.) {\n      if (Hashff (tCur + 111.1) > 0.5 && iFrag.x == floor (gSize / 4.)) ar = 2.;\n      if (Hashff (tCur + 211.1) > 0.5 && iFrag.x == floor (3. * gSize / 4.)) ar = 0.;\n    }\n    ballPos = cEn + vec2 (-0.5 * gSize + 0.8, -0.5 * gSize + 1.);\n    ballVel = vec2 (0.);\n    ballQt = vec4 (0., 0., 0., 1.);\n    fVal.x = ar;\n  } else {\n    nStep = Loadv4 (vec2 (1., 0.)).z;\n    cEn = Loadv4 (vec2 (3., 1.)).zw;\n    cEx = Loadv4 (vec2 (4., 1.)).zw;\n    stDat.zw = Loadv4 (vec2 (5., 1.)).zw;\n    growLim = stDat.z;\n    pathLen = stDat.w;\n    ++ nStep;\n    ar = fVal.x;\n    ev[0] = vec2 (0., 1.);\n    ev[1] = vec2 (1., 0.);\n    ev[2] = vec2 (0., -1.);\n    ev[3] = vec2 (-1., 0.);\n    cbf = vec4 (1., 2., 4., 8.);\n    if (nStep < growLim && ar < 0.) {\n      ai = floor (4. * Hashfv2 (iFrag + tCur));\n      if (Hashfv2 (iFrag + tCur + 11.1) > 0.3) {\n        if (iFrag.y == 1.) {\n          if (ai == 2.) ai = 0.;\n        } else if (iFrag.y == gSize - 2.) {\n          if (ai == 0.) ai = 2.;\n        } else if (iFrag.x == 1.) {\n          if (ai == 3.) ai = 1.;\n        } else if (iFrag.x == gSize - 2.) {\n          if (ai == 1.) ai = 3.;\n        }\n      }\n      if (Loadv4 (iFrag + ((ai < 2.) ? ((ai == 0.) ? ev[0] : ev[1]) :\n         ((ai == 2.) ? ev[2] : ev[3]))).x >= 0.) ar = ai;\n    }\n    fVal.x = ar;\n    if (nStep < growLim) fVal.y = (Maxv2 (iFrag) <= gSize - 2.) ? -1. : 0.;\n    if (nStep > 2. * growLim) pathLen = floor (Loadv4 (cEx).y / 32.);\n    if (Maxv2 (iFrag) <= gSize - 2.) {\n      cb = vec4 (0.);\n      ar = Loadv4 (iFrag).x;\n      cb.wz += vec2 ((ar == 0.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[0]).x;\n      cb.wx += vec2 ((ar == 2.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + vec2 (1., 1.)).x;\n      cb.yx += vec2 ((ar == 2.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      ar = Loadv4 (iFrag + ev[1]).x;\n      cb.yz += vec2 ((ar == 0.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n      nw = fVal.y;\n      if (nStep == growLim) {\n        nw = dot (cb, vec4 (1.));\n      } else if (nStep > growLim && nStep < 2. * growLim) {\n        if (nw < 3.) {\n          nb = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y >= 3.) ++ nb;\n          if (nw + nb == 3.) nw = 4.;\n        } else nw = 4.;\n      } else if (nStep == 2. * growLim) {\n        if (nw < 3.) {\n          nw = 0.;\n          for (int k = 0; k < 4; k ++)\n             if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y < 3.) nw += cbf[k];\n        } else nw = 0.;\n      } else if (nStep > 2. * growLim && nStep < 5. * growLim && pathLen == 0.) {\n        if (nw > 0. && nw < 32.) {\n          dir = 0.;\n          cbi = 1. / cbf;\n          cb = mod (floor (nw * cbi), 2.);\n          if (iFrag == cEn) {\n            if (cb[2] > 0.) dir = 1.;\n            nw += 32. * 1.;\n          } else {\n            cbi = cbi.zwxy;\n            for (int k = 0; k < 4; k ++) {\n              if (nw < 32. && cb[k] > 0.) {\n                nwn = Loadv4 (mod (iFrag + ev[k], gSize)).y;\n                if ((nwn - 32.) * mod (floor (nwn * cbi[k]), 2.) > 0.) {\n                  nw += 32. * (floor (nwn / 32.) + 1.);\n                  kIn = k;\n                  break;\n                }\n              }\n            }\n            if (kIn == 0) {\n              if (cb[2] > 0. || cb[3] > 0.) dir = 1.;\n            } else if (kIn == 1) {\n              if (cb[3] > 0. || cb[0] > 0.) dir = 1.;\n            } else if (kIn == 2) {\n              if (cb[1] > 0.) dir = 1.;\n            } else if (kIn == 3) {\n              if (cb[2] > 0.) dir = 1.;\n            }\n          }\n          nw += 16. * (dir - mod (floor (nw / 16.), 2.));\n        }\n      }\n      fVal.y = nw;\n    }\n  }\n  if (! init && iFrag.y == 0. && iFrag.x <= 7.) {\n    ballPos = Loadv4 (vec2 (4., 0.)).zw;\n    ballVel = Loadv4 (vec2 (5., 0.)).zw;\n    ballQt = vec4 (Loadv4 (vec2 (6., 0.)).zw, Loadv4 (vec2 (7., 0.)).zw);\n    if (autoRot > 0.) aTilt = 0.15 * sin (0.1 * 2. * pi * tCur + vec2 (0., 0.5 * pi));\n    if (nStep > growLim) Step ();\n  }\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (gSize, 0.);\n    else if (iFrag.x == 1.) fVal.zw = vec2 (nStep, float (wgSel));\n    else if (iFrag.x == 2.) fVal.zw = vec2 ((tCur - tBgn) / tGame, tBgn);\n    else if (iFrag.x == 3.) fVal.zw = aTilt;\n    else if (iFrag.x == 4.) fVal.zw = ballPos;\n    else if (iFrag.x == 5.) fVal.zw = ballVel;\n    else if (iFrag.x == 6.) fVal.zw = ballQt.xy;\n    else if (iFrag.x == 7.) fVal.zw = ballQt.zw;\n  } else if (iFrag.y == 1.) {\n    if      (iFrag.x == 0.) fVal.zw = vec2 (el, az);\n    else if (iFrag.x == 1.) fVal.zw = mPtr.xy;\n    else if (iFrag.x == 2.) fVal.zw = vec2 (mPtr.z, autoRot);\n    else if (iFrag.x == 3.) fVal.zw = cEn;\n    else if (iFrag.x == 4.) fVal.zw = cEx;\n    else if (iFrag.x == 5.) fVal.zw = vec2 (growLim, pathLen);\n    else if (iFrag.x == 6.) fVal.zw = vec2 (zmFac, oDist);\n  }\n  fragColor = fVal;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RotToQt (vec3 v, float a)\n{\n  vec4 q;\n  float c, s;\n  const float tol = 1e-6;\n  c = cos (a);  s = sin (a);\n  q.w = 0.5 * sqrt (max (1. + (1. - c) * dot (v, v) + 3. * c, 0.));\n  if (q.w > tol) q.xyz = s * v.xyz / (2. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + (1. - c) * v.x * v.x + c), 0.));\n    if (q.x > tol) q.yz = ((1. - c) * v.xz * v.yx + s * v.zy) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + (1. - c) * v.y * v.y + c), 0.));\n      q.z = (q.y > tol) ? ((1. - c) * v.y * v.z + s * v.x) / q.y : 1.;\n    }\n  }\n  return q;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXDV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[971, 971, 1004, 1004, 1192], [1194, 1194, 1218, 1218, 1564], [1566, 1566, 1589, 1589, 1642], [1715, 1715, 1737, 1737, 3868], [3870, 3870, 3903, 3903, 4151], [4153, 4153, 4174, 4174, 4456], [4458, 4458, 4492, 4492, 4983], [4985, 4985, 5011, 5011, 5237], [5239, 5239, 5276, 5276, 5505], [5507, 5507, 5542, 5542, 9404], [9406, 9406, 9462, 9462, 11021], [11023, 11023, 11069, 11069, 11116], [11118, 11118, 11161, 11161, 11225], [11227, 11227, 11284, 11284, 11360], [11362, 11362, 11387, 11387, 11703], [11705, 11705, 11741, 11741, 11947], [11949, 11949, 11979, 11979, 12092], [12126, 12126, 12150, 12150, 12262], [12264, 12264, 12289, 12289, 12475], [12477, 12477, 12498, 12498, 12653], [12720, 12720, 12744, 12744, 12794]]}
{"id": "NtBXWV", "name": "Magic Portal", "author": "Delincoter", "description": "My first shadertoy XD", "tags": ["2d"], "likes": 13, "viewed": 895, "published": 3, "date": "1628589976", "time_retrieved": "2024-07-30T19:06:56.226901", "image_code": "//noise funtion abstract from https://www.shadertoy.com/view/4sc3z2\nvec3 hash33(vec3 p3)\n{\n\tvec3 MOD3 = vec3(.1031, .11369, .13787);\n\tp3 = fract(p3* MOD3);\n\tp3 += dot(p3, p3.yxz + 19.19);\n\treturn -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x + p3.z)*p3.y, (p3.y + p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n\tconst float K1 = 0.333333333;\n\tconst float K2 = 0.166666667;\n\n\tvec3 i = floor(p + (p.x + p.y + p.z) * K1);\n\tvec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n\tvec3 e = step(vec3(0, 0, 0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n\tvec3 d1 = d0 - (i1 - 1.0 * K2);\n\tvec3 d2 = d0 - (i2 - 2.0 * K2);\n\tvec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n\tvec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n\tvec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n\treturn dot(vec4(31.316, 31.316, 31.316, 31.316), n);\n}\n\n\n\nfloat render(vec2 uv)\n{\n    float side = smoothstep(0.5, 0.3, length(uv));\n    float center = smoothstep(0.1, 0.0, length(uv));\n    vec3 rd = vec3(uv, 0.);\n\n    float t = pow(iTime+0.5,5.)*0.001;\n\n    float n2 = simplex_noise((rd*t+t) * (1. / length(rd*t+rd)));\n    \n    if(iTime>1.5)\n    {\n        n2 = simplex_noise((rd*t+t) * (1. / length(rd*t+rd))+(iTime-1.5));\n    }\n    \n    \n    float flare = smoothstep(0.,1.,0.002 / length(rd*length(rd)*n2))*side;\n    \n    flare = flare-center*clamp((iTime-1.5)*10.,0.,5.);\n    \n    return flare;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    vec3 col = vec3(0.102,0.5,1.)*2.;\n    col *= render(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 68, 90, 90, 283], [285, 285, 314, 314, 949], [953, 953, 976, 976, 1494], [1496, 1496, 1553, 1553, 1753]]}
{"id": "ftjSWy", "name": "Quadtree Octahedrons", "author": "byt3_m3chanic", "description": "Quadtrees - how do they work? Obviously not the way I'm doing it - but looking for some golfing help. Is this Brute Force? Is there a better way? ", "tags": ["raymarching", "quadtree", "branching"], "likes": 17, "viewed": 431, "published": 3, "date": "1628580687", "time_retrieved": "2024-07-30T19:06:57.035739", "image_code": "/**\n    Quadtree Octahedrons\n    @byt3_m3chanic | 08/09/21\n    \n    I dont know how to break space down and do the\n    quad tree thing - so doing some brute force \n    attempts.\n\n*/\n\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n//@iq\nfloat octa( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 r45,r22;\nvec3 hit,hitPoint;\nvec2 gid,sid;\nfloat time,srnd,grnd;\nvec2 sc = vec2(.0),ssc,gsc;\n\nvec2 map(vec3 p) {\n    p.y+=5.;\n    p.x+=time;\n    vec2 res = vec2(1e5,0);\n    \n    sc = vec2(.25);\n    vec2 bsize = vec2(1.);\n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/(sc);\n    vec3 q = vec3(r.x,p.y,r.y);\n\n    float rnd = hash21(id);\n    float tn=-1.;\n    if(rnd>.5){\n       sc*=2.;\n       id = floor(q.xz*(sc)) + .5;    \n       r = q.xz - id/(sc);\n       q = vec3(r.x,p.y,r.y);\n       rnd = hash21(id+rnd);\n       tn=0.;\n       if(rnd>.5){\n           sc*=2.;\n           id = floor(q.xz*(sc)) + .5;    \n           r = q.xz - id/(sc);\n           q = vec3(r.x,p.y,r.y);\n           rnd = hash21(id+rnd);\n           if(rnd>.5){\n               sc*=2.;\n               id = floor(q.xz*(sc)) + .5;    \n               r = q.xz - id/(sc);\n               q = vec3(r.x,p.y,r.y);\n               rnd = hash21(id+rnd);\n               if(rnd>.5){\n                   sc*=2.;\n                   id = floor(q.xz*(sc)) + .5;    \n                   r = q.xz - id/(sc);\n                   q = vec3(r.x,p.y,r.y);\n                   rnd = hash21(id+rnd);\n                   tn=1.;\n               }\n           }\n       }\n    }\n    vec3 qs=q;\n    q.xz*=rot(rnd*T*1.5);\n\n    bsize = .375/sc.xx;\n    float b1 = octa(q-vec3(0,bsize.y,0),bsize.x);\n    \n    if(tn==0.){\n        q.xz*=r45;\n        b1 = min(octa(q-vec3(0,bsize.y,0),bsize.x),b1);\n    }\n    if(tn==-1.){\n        q.xz*=r22;\n        b1 = min(octa(q-vec3(0,bsize.y,0),bsize.x),b1);\n        q.xz*=r22;\n        b1 = min(octa(q-vec3(0,bsize.y,0),bsize.x),b1);\n    }\n    \n    if(b1<res.x) {\n        res = vec2(b1,2.);\n    \thit=q;\n        gid=id;\n        grnd=rnd;\n        gsc=sc;\n    }\n\n    float d9 = p.y;\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=qs;\n        gid=id;\n        grnd=rnd;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec3 hue(float t)\n{ \n    vec3 d = vec3(0.220,0.961,0.875);\n    return .375 + .375*cos(PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel)\n{\n    n = normal(p,d,1.01);\n    vec3 lpos =  vec3(5,4,1);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 3.);\n    fresnel = mix(.01, .7, fresnel);\n        \n    float shdw = 1.;\n    float t=.0;\n    for(float i=.0;i<24.;i++)\n    {\n        float h = map(p + l*t).x;\n        if( h<1e-4 ) { shdw = 0.; break; }\n        shdw = min(shdw, 18.*h/t);\n        t += h;\n        if( shdw<.01 || t>64. ) break;\n    }\n    diff = mix(diff,diff*shdw,.4);\n\n    vec3 h = vec3(0.914,0.984,0.973);\n    if(m==1.) {\n        float cir = length(hitPoint.xz)-(.15/ssc.x);\n        float of =(.045/ssc.x);\n        float ox =(.015/ssc.x);\n        cir=abs(abs(abs(cir)-of)-of)-ox;\n        cir = smoothstep(.001,.0011,cir);\n        h=mix(vec3(0.561,0.639,0.627),h,1.-cir);\n    }\n\n    if(m==2.) {\n        h=hue(((srnd+fresnel)+hitPoint.z*.05)*3.);\n    }\n    return diff*h;//mix(h,h*shdw,.6);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    time = T*.35;\n    r45=rot(45.*PI/180.);\n    r22=rot(30.*PI/180.);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    float zoom = 3.;\n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n\n    mat2 rx = rot(-0.58539816339);\n    mat2 ry = rot(-0.78539816339);\n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = 1.;\n    float k = 1.;\n    float d = 0.;\n    for(int i=0;i<125;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = ray.x*.5;\n        p += rd * d *k;\n        \n        if (d*d < 1e-6) {\n            hitPoint = hit;\n            sid = gid;\n            ssc = gsc;\n            srnd=grnd;\n            float fresnel=0.;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n            if(m==1.)break;\n            \n            atten *= .65;\n            p += rd*.025;\n            k = sign(map(p).x);\n            \n            vec3 rr = vec3(0);\n            if(int(F.x)%3 != int(F.y)%3) {\n                rr = refract(rd,n,.45);\n                rd=mix(rr,rd,.9-fresnel);\n            }else{\n                vec3 rr=reflect(-rd,n);\n                rd=mix(rr,rd, vec3(.8)-fresnel);\n                p+=n*.05;\n            }\n  \n        } \n       \n        if(distance(p,rd)>75.) { break; }\n    }\n\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[293, 293, 313, 313, 358], [359, 359, 383, 383, 441], [442, 448, 478, 478, 531], [631, 631, 649, 649, 2407], [2409, 2409, 2454, 2454, 2669], [2671, 2671, 2690, 2690, 2790], [2792, 2792, 2884, 2884, 3822], [3824, 3824, 3865, 3879, 5297]]}
{"id": "NlBXWK", "name": "glow mirror", "author": "mds2", "description": "just a little lighting fun.", "tags": ["video", "sdf", "noodle"], "likes": 7, "viewed": 572, "published": 3, "date": "1628570831", "time_retrieved": "2024-07-30T19:06:57.857541", "image_code": "\nfloat boxDist(in vec2 p, in vec2 corner) {\n  p = abs(p);\n  p = max(p - corner, vec2(0.0));\n  return length(p);\n}\n\nvec2 onEdge(in vec2 p, in vec2 corner, in float rad) {\n  if (abs(p.x) < corner.x) {\n    return vec2(p.x, sign(p.y) * (corner.y + rad));\n  }\n  if (abs(p.y) < corner.y) {\n    return vec2( sign(p.x) * (corner.x + rad), p.y);\n  }\n  vec2 anchor = sign(p) * corner;\n  vec2 dir = p - anchor;\n  dir = dir * rad / max(0.1, length(dir));\n  return anchor + dir;\n}\n\nfloat alongEdge(in vec2 p, in vec2 corner, in float rad) {\n  float result = 0.0;\n  if (p.y < 0.0) {\n    p = -p;\n    result += 2.0 * corner.x + 2.0 * corner.y + 3.141592654 * rad;\n  }\n\n  float along2 = 0.0;\n  \n  float quarterLength = corner.x + corner.y + 0.5 * 3.141592654 * rad;\n  \n  if (abs(p.x) < corner.x) {\n    along2 = abs(p.x);\n  } else if (abs(p.y) < corner.y) {\n    along2 = quarterLength - abs(p.y);\n  } else {\n    along2 = corner.x + atan(abs(p.x) - corner.x, abs(p.y) - corner.y) * rad;\n  }\n  \n  if (p.x < 0.0) {\n    along2 = quarterLength - along2;\n  } else {\n    along2 = quarterLength + along2;\n  }\n  return result + along2;\n}\n\nfloat normAlongEdge(in vec2 p, in vec2 corner, in float rad) {\n  return alongEdge(p, corner, rad) / (dot(corner, vec2(4.0)) + 2.0 * rad * 3.141592654);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 corner = 0.5 * iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float sdf = boxDist(uv, corner) - 0.25;\n\n    // Time varying pixel color\n    vec3 col = 5.0 * vec3(0.1, 0.2, 0.3) / (1.0 + 5.0 * sdf);\n    \n    float along = normAlongEdge(uv, corner, 0.25);\n    \n    float tex_along = mod(along + 0.0625 * iTime, 1.0);\n    \n    col *= 1.0 + 0.125 * (1.0 + tex_along) * smoothstep(0.0, 1.0, texture(iChannel1, vec2(tex_along, 0.5)).r);\n    \n    if (sdf < 0.0) {\n      uv = 0.5 + 1.0 * (fragCoord - 0.5 * iResolution.xy) / iResolution.xy;\n      col = texture(iChannel0, uv).rgb;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 43, 43, 113], [115, 115, 169, 169, 467], [469, 469, 527, 527, 1110], [1112, 1112, 1174, 1174, 1265], [1269, 1269, 1326, 1376, 2131]]}
{"id": "ftSXWK", "name": "Wavy dunes", "author": "jarble", "description": "This is a fairly realistic-looking desert landscape, based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "terrain", "desert", "dune"], "likes": 4, "viewed": 331, "published": 3, "date": "1628563980", "time_retrieved": "2024-07-30T19:06:58.612523", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 2\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = -3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += max(sin(uv*factor)/factor,cos(uv/factor)*factor).yx;\n        value = -min(value+sin(uv.x)/factor,value+cos((uv.y)/factor)/factor);\n        \n        uv = uv/1.5/factor;\n        //factor /= 1.5;\n        \n    }\n    \n    return value/2.+1.5;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 2.;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 511, 560, 922], [996, 996, 1034, 1034, 1093], [1095, 1095, 1128, 1128, 1348], [1350, 1350, 1388, 1388, 1615], [1617, 1617, 1655, 1655, 1879], [1881, 1881, 1910, 1910, 2005], [2007, 2007, 2044, 2044, 2103], [2106, 2174, 2193, 2193, 2232], [2234, 2234, 2254, 2254, 2330], [2332, 2332, 2351, 2351, 2390], [2392, 2392, 2449, 2449, 2684], [2686, 2686, 2721, 2721, 3115], [3117, 3117, 3171, 3171, 3837], [3840, 3840, 3892, 3892, 4327], [4329, 4329, 4386, 4386, 5571]]}
{"id": "NtjSzd", "name": "Spherical Erosion", "author": "davidar", "description": "Best viewed in Fullscreen.\n\nSimilar to my other hydraulic erosion shaders, but using a cubemap to avoid distortion at the poles.", "tags": ["terrain", "landscape", "cubemap", "erosion"], "likes": 32, "viewed": 731, "published": 3, "date": "1628557191", "time_retrieved": "2024-07-30T19:06:59.643765", "image_code": "#define SCALE 0.95\n#define GAMMA 2.2\n#define rgba(r,g,b,a) vec4(pow(vec3(r,g,b),vec3(GAMMA)),a)\n#define map(p) texture(iChannel0,p).x\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(1,0)/1e3;\n    p += 0.01 * vec3(\n        map(p - e.xyy) - map(p + e.xyy),\n        map(p - e.yxy) - map(p + e.yxy),\n        map(p - e.yyx) - map(p + e.yyx))/ (2. * length(e));\n\treturn normalize(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float lat = 45. * sin(0.2 * iTime);\n    float lon = 7.5 * iTime + 100.;\n    if (iMouse.z > 0.) {\n        lat = 90.  - 180. * iMouse.y/iResolution.y;\n        lon = 180. - 360. * iMouse.x/iResolution.x;\n    }\n    vec3 camPos = 10. * vec3(sin(lon*PI/180.) * cos(lat*PI/180.), sin(lat*PI/180.), cos(lon*PI/180.) * cos(lat*PI/180.));\n    vec3 lightPos = normalize(vec3(-4,1,2));\n    lightPos = rotY(PI/3.) * vec3(sin(lon*PI/180.), 0, cos(lon*PI/180.));\n    vec3 w = normalize(-camPos);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = normalize(cross(u, w));\n    mat3 camera = mat3(u, v, w);\n    \n    vec3 dir = normalize(camera * vec3(p / SCALE, length(camPos)));\n    float dist = iSphere(camPos, dir, vec4(0,0,0,1));\n    fragColor = vec4(0);\n    if (dist > 0.) {\n        vec3 q = camPos + dir * dist;\n        float y = map(q);\n        vec3 n = normal(q);\n        float light = clamp(dot(n, lightPos), 0.05, 1.);\n        vec3 hue = .6 + .6 * cos(6.3 * y + vec3(0,23,21));\n        fragColor = vec4(hue * light, 1);\n#ifdef DEBUG\n        vec3 fragRayDir = q;\n        if (abs(fragRayDir.x) > max(abs(fragRayDir.y), abs(fragRayDir.z))) fragRayDir /= abs(fragRayDir.x);\n        if (abs(fragRayDir.y) > max(abs(fragRayDir.x), abs(fragRayDir.z))) fragRayDir /= abs(fragRayDir.y);\n        if (abs(fragRayDir.z) > max(abs(fragRayDir.y), abs(fragRayDir.x))) fragRayDir /= abs(fragRayDir.z);\n        if ((abs(fragRayDir.x) >= 0.97 ? 1 : 0) +\n            (abs(fragRayDir.y) >= 0.97 ? 1 : 0) +\n            (abs(fragRayDir.z) >= 0.97 ? 1 : 0) >= 2) {\n            fragColor.rgb += 0.01;\n        }\n#endif\n    }\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), smoothstep(SCALE - 4./iResolution.y, SCALE + 1./iResolution.y, length(p)));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./GAMMA));\n}\n\t\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n\n#define N  vec2( 0, 1)\n#define NE vec2( 1, 1)\n#define E  vec2( 1, 0)\n#define SE vec2( 1,-1)\n#define S  vec2( 0,-1)\n#define SW vec2(-1,-1)\n#define W  vec2(-1, 0)\n#define NW vec2(-1, 1)\n\nmat3 rotX(float q) {\n\treturn mat3(\n\t\t1,       0,      0,\n\t\t0,  cos(q), sin(q),\n\t\t0, -sin(q), cos(q)\n\t);\n}\n\nmat3 rotY(float q) {\n\treturn mat3(\n\t\tcos(q), 0, -sin(q),\n             0, 1,       0,\n\t\tsin(q), 0,  cos(q)\n\t);\n}\n\n// https://www.shadertoy.com/view/XdBGzd\n// The MIT License\n// Copyright  2014 Inigo Quilez\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n// By David Hoskins, May 2014. @ https://www.shadertoy.com/view/4dsXWn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n    return mix(\n                mix(mix(hash13(i + vec3(0.,0.,0.)), hash13(i + vec3(1.,0.,0.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,0.)), hash13(i + vec3(1.,1.,0.)),f.x),\n                        f.y),\n                mix(mix(hash13(i + vec3(0.,0.,1.)), hash13(i + vec3(1.,0.,1.)),f.x),\n                        mix(hash13(i + vec3(0.,1.,1.)), hash13(i + vec3(1.,1.,1.)),f.x),\n                        f.y),\n                f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 ) * 1.7;\n\nfloat FBM( vec3 p )\n{\n    float f;\n\n        f = 0.5000 * Noise(p); p = m*p;\n        f += 0.2500 * Noise(p); p = m*p;\n        f += 0.1250 * Noise(p); p = m*p;\n        f += 0.0625   * Noise(p); p = m*p;\n        f += 0.03125  * Noise(p); p = m*p;\n        f += 0.015625 * Noise(p);\n    return f;\n}", "cube_a_code": "// 2018-2021 David A Roberts <https://davidar.io>\n\nfloat craters(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    float va = 0.;\n    float wt = 0.;\n    for (int i = -2; i <= 2; i++) for (int j = -2; j <= 2; j++) for (int k = -2; k <= 2; k++) {\n        vec3 g = vec3(i,j,k);\n        vec3 o = 0.8 * hash33(p + g);\n        float d = distance(f - g, o);\n        float w = exp(-4. * d);\n        va += w * sin(2.*PI * sqrt(d));\n        wt += w;\n\t}\n    return abs(va / wt);\n}\n\nvec3 wrap(vec2 p, mat3 face) { // project 2D coord onto cube face\n    float u = p.x / 512. - 1.;\n    float v = 1. - p.y / 512.;\n    return face * vec3(u, v, 1);\n}\n\n#define buf(p) buff(p, face)\n\nvec4 buff(vec2 p, mat3 face) {\n    return texture(iChannel0, wrap(p, face));\n}\n\n#define slope(p,q) slopef(p,q,face)\n\nfloat slopef(vec2 p, vec2 q, mat3 face) {\n    vec3 p3 = normalize(wrap(p, face));\n    vec3 q3 = normalize(wrap(q, face));\n    return (texture(iChannel0, q3).r - texture(iChannel0, p3).r) / (512. * distance(q3, p3));\n}\n\nvec2 recf(vec2 p, mat3 face) { // direction of water flow at point\n    vec2 d = N;\n    if (slope(p + NE, p) > slope(p + d, p)) d = NE;\n    if (slope(p + E,  p) > slope(p + d, p)) d = E;\n    if (slope(p + SE, p) > slope(p + d, p)) d = SE;\n    if (slope(p + S,  p) > slope(p + d, p)) d = S;\n    if (slope(p + SW, p) > slope(p + d, p)) d = SW;\n    if (slope(p + W,  p) > slope(p + d, p)) d = W;\n    if (slope(p + NW, p) > slope(p + d, p)) d = NW;\n    return d;\n}\n\n#define rec(p,d) recbuf(p,d,face)\n\nbool recbuf(vec2 p, vec2 d, mat3 face) { // is water flowing into p from direction d?\n    vec4 c = buf(p + d);\n    vec3 dir = vec3(cos(c.a) * sin(c.b), sin(c.a) * sin(c.b), cos(c.b));\n    vec3 pd = normalize(wrap(p + d, face));\n    vec3 p3 = normalize(wrap(p, face));\n    vec3 dir2 = normalize(p3 - pd);\n    return distance(dir, dir2) < 0.5;\n}\n\nvoid mainImage( out vec4 r, in vec2 p, in mat3 face ) { // erosion per face\n    r = buf(p);\n    \n    // flow accumulation\n    r.g = 10.;\n    if (rec(p,N))  r.g += buf(p + N).g;\n    if (rec(p,NE)) r.g += buf(p + NE).g;\n    if (rec(p,E))  r.g += buf(p + E).g;\n    if (rec(p,SE)) r.g += buf(p + SE).g;\n    if (rec(p,S))  r.g += buf(p + S).g;\n    if (rec(p,SW)) r.g += buf(p + SW).g;\n    if (rec(p,W))  r.g += buf(p + W).g;\n    if (rec(p,NW)) r.g += buf(p + NW).g;\n    \n    // direction water is flowing out of this cell\n    // as 3D vector tangent to sphere\n    // encoded in spherical coords\n    vec2 recp = recf(p, face);\n    vec3 p3 = normalize(wrap(p, face));\n    vec3 q = normalize(wrap(p + recp, face));\n    vec3 pq = normalize(q - p3);\n    r.b = atan(length(pq.xy), pq.z);\n    r.a = atan(pq.y, pq.x);\n    \n    // stream power\n    vec4 receiver = buf(p + recp);\n    float pslope = (r.r - receiver.r) / length(recp);\n    r.r = max(r.r - 0.1 * pow(r.g, 0.8) * pow(pslope, 2.), receiver.r);\n    \n    // tectonic uplift\n    //r.r += 0.0001;\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {\n    if (iFrame <= 5) { // initial terrain\n        vec3 p = 1.5 * rayDir;\n        fragColor.x = 0.;\n        for (float i = 0.; i < 5.; i++) {\n            float c = craters(0.4 * pow(2.2, i) * p);\n            float noise = 0.4 * exp(-3. * c) * FBM(10. * p);\n            float w = clamp(3. * pow(0.4, i), 0., 1.);\n            fragColor.x += w * (c + noise);\n        }\n        fragColor.x = pow(fragColor.x, 3.);\n        fragColor.x = (5. - fragColor.x) / 15.;\n        return;\n    }\n    \n    // which cube face are we on?\n    vec3 rayAbs = abs(rayDir);\n    int face = rayAbs.x > rayAbs.y ? rayAbs.x > rayAbs.z ? 0 : 2 : rayAbs.y > rayAbs.z ? 1 : 2; // faceID\n    if (rayDir[face] < 0.) face += 3;\n    \n    /* rotation matrix for projecting 2D coords onto the 3D cube\n       the face IDs on the unrolled cube look like:\n         1\n       3 2 0 5\n         4\n    */\n    mat3 faceMat;\n    switch (face) {\n    case 0: faceMat = rotY(PI/2.); break;\n    case 1: faceMat = rotX(-PI/2.); break;\n    case 2: faceMat = rotY(0.); break;\n    case 3: faceMat = rotY(-PI/2.); break;\n    case 4: faceMat = rotX(PI/2.); break;\n    case 5: faceMat = rotY(PI); break;\n    }\n    \n    mainImage(fragColor, fragCoord, faceMat);\n    \n    // seed extra river basins\n    vec3 h = hash33(vec3(fragCoord, iFrame));\n    if (h.x < 1e-5 && h.y < 1e-5) fragColor.x -= 0.2;\n}\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 156, 156, 369], [371, 371, 428, 428, 2282]]}
{"id": "sl2SDG", "name": " - Terrain I ", "author": "totetmatt", "description": "Testing some idea function. pretty sure it's not optimized and / or heavy but yolo I like the rendering :) ", "tags": ["terrain"], "likes": 9, "viewed": 323, "published": 3, "date": "1628541862", "time_retrieved": "2024-07-30T19:07:00.518426", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat _tx(float t){\n  return clamp(abs(sin(t))-.5,0.,.35)*2.;\n  }\nfloat tx(vec2 t){\n  float q = 4.0;\n  for(float i=1.;i<=8.;i++){\n       \n       q =q + sign(mod(i,1.)-.5)* _tx(t.y+t.x*i*3.1415+i*2.)/(i*4.);\n       t*=rot(-.785);\n    }\n    return q;\n  \n  }\nvec2 sdf(vec3 p){\n  vec3 op = p;\n  p.z +=fGlobalTime*.1;\n\n    vec2 h;\n  h.x = dot(p,vec3(0.,1.,.0))-tx(p.xz*.8+tx(p.zx*.8)/8.)/4.;\n  h.x = max(length( op+vec3(0.,-1.5,0.) )-1.2,h.x);\n  h.x*=.9;\n  h.y = 1.;\n  return h;\n}\n\n#define q(s) s*sdf(p+s).x\nvec2 e= vec2(-.0005,.0005);\nvec3 norm(vec3 p){return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,10.)+ao(rp,n,100.))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col =vec3(.1);\n  vec3 ro = vec3(sin(fGlobalTime*.1)*1.,1.2,cos(fGlobalTime*.2)*1.);\n  vec3 rt = vec3(0.,0.5,0);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  vec3 rd =mat3(x,y,z)*normalize(vec3(uv,1.));\n  vec3 light =mat3(x,y,z)*vec3(0.,1.,-0.5);\n  vec3 rp = ro;\n \n  for(float i=0.;i<=128.;i++){\n      vec2 d = sdf(rp);\n      if(length(rp) > 100.)break;\n      if(d.x <=.001){\n          vec3 n= norm(rp);\n        \n          float diff = max(0.,dot(normalize(light-rp),n));\n          float spec = pow(max(0.,dot(normalize(ro-rp),reflect(-normalize(light),n))),32.);\n        float  fr=pow(1.+dot(n,rd),8.);\n          col = vec3(.1)*diff+spec+2.*vec3(1.,.7,0.5)*fr;\n          col = mix(vec3(.1),col,fr+AO(rp,n)/3.);\n        \n          break;\n       }\n       rp+=rd*d.x;\n  }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2SDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 91], [92, 92, 111, 111, 157], [158, 158, 175, 175, 347], [348, 348, 365, 365, 567], [623, 623, 641, 641, 696], [792, 792, 849, 849, 1792]]}
{"id": "ft2XDG", "name": "LookingGlass: Liquid Planet", "author": "xjorma", "description": "Proof of concept, It's possible to make a physics simulation in a cube map. Works better than expected. :)\nUse the mouse to turn around.", "tags": ["simulation", "water", "planet", "cubemap", "drop", "feedback", "physics"], "likes": 0, "viewed": 118, "published": 3, "date": "1628523805", "time_retrieved": "2024-07-30T19:07:01.270416", "image_code": "// Created by David Gallardo - xjorma/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n\nconst vec3 lightPosition = vec3(0.,10.,2.);\n\nconst vec3 backgroundColor = vec3(0.4);\nconst vec3 waterColor = vec3(0,0,0.4);\nconst vec3 solidColor = vec3(1, 1, 0);\n\nconst float cref = 0.8;\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat mapWater(in vec3 p)\n{\n    float d = sdSphere(p, 1.0 + texture(iChannel0, p).x * 0.05);\n    return d;\n}\n\n\n#define NORMALFUNC(NAME, MAPFUNC, EPS)\t\t\t\t\t\t\t\t\\\nvec3 NAME(in vec3 p)\t\t\t\t\t\t\t\t    \t\t\t\\\n{                                                                   \\\n    const vec2 k = vec2(EPS,-EPS);\t\t\t\t                    \\\n    return normalize( k.xyy * MAPFUNC(p + k.xyy) + \t\t\t    \t\\\n                      k.yyx * MAPFUNC(p + k.yyx) + \t\t\t\t    \\\n                      k.yxy * MAPFUNC(p + k.yxy) + \t\t\t\t    \\\n                      k.xxx * MAPFUNC(p + k.xxx) );\t\t\t\t    \\\n}\n\n#define RAYMARCHFUNC(NAME, MAPFUNC, ITER, EPS)\t\t\t\t\t\t\\\nfloat NAME(in vec3 ro, in vec3 rd, in float dist)                   \\\n{                                                                   \\\n    float t = 0.0;                                                  \\\n    for( int i = 0; i < ITER; i++ )                                 \\\n    {                                                               \\\n        vec3\tp = ro + t*rd;                                      \\\n        float\th = MAPFUNC(p);                                     \\\n        if( abs(h) < 0.00001 || t > dist )                          \\\n            break;                                                  \\\n        t += h;                                                     \\\n    }                                                               \\\n    return t;                                                       \\\n}\n\nNORMALFUNC(calcNormalWater,mapWater, 0.02)\nRAYMARCHFUNC(raymarchWater,mapWater, 100, 0.00001)\n\nNORMALFUNC(calcNormalSolid,mapSolid, 0.0001)\nRAYMARCHFUNC(raymarchSolid,mapSolid, 100, 0.001)\t\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float tSolid = raymarchSolid(ro, rd, dist);\n    float tWater = raymarchWater(ro, rd, tSolid);\n    \n    vec3 col = backgroundColor;\n\n    if( min(tWater, tSolid) < dist )\n    {\n        if(tSolid < tWater)\n        {\n            // Solid first\n            vec3 p = ro + tSolid * rd;\n            vec3 n = calcNormalSolid(p);\n            vec3 v = normalize(ro-p);\n            vec3 l = normalize(lightPosition-p);\n            vec3 h = normalize(l+v);\n            col = solidColor * saturate(max(0.0, dot(n,l) * 0.7) + 0.3);\n        }\n        else\n        {\n            // Water first\n            vec3 p = ro + tWater * rd;\n            vec3 n = calcNormalWater(p);\n            vec3 refr = refract(rd, n, cref);\n            const float secondDist = 2.5;\n            float tWaterOut = raymarchWater(p + 1.5 * refr, -refr, secondDist);\n            float tSolidRefract = raymarchSolid(p, refr, secondDist);\n            float d = max(0.0, secondDist - tWaterOut);\n            if(tSolidRefract < secondDist)\n            {\n                vec3 p = p + tSolidRefract * refr;\n                vec3 n = calcNormalSolid(p);\n                vec3 v = normalize(ro-p);\n                vec3 l = normalize(lightPosition-p);\n                vec3 h = normalize(l+v);\n                col = solidColor * saturate(max(0.0, dot(n,l) * 0.7) + 0.3);\n                d = tSolidRefract;\n            }\n            \n            vec3 l = normalize(lightPosition-p);                  \n            col = applyFog( col, waterColor, d * 3.0);\n            float spec = length(texture(iChannel1, reflect(ro, n) * vec3(1,-1,1)).rgb);\n            col += 0.15 * spec * smoothstep(0.0, 0.1, dist);\n        }\n    }\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd)\n{\n    initSolidTransfrom(iTime);\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(_ro ,_rd ,ca[2], 4.0);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}\n\n#define QAA\t2                                     \n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 3.0;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 2.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4\taccColor = vec4(0.);\n    for( int m = 0; m < QAA; m++ )\n    for( int n = 0; n < QAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m), float(n)) / float(QAA) - 0.5) / iResolution.xy                                                                                 ;\n\t\t\n\t\tvec2\tcoord = (fragCoord / iResolution.xy  + o) * vec2(quiltColumns,quiltRows);\n\t\tvec2\tfract = fract(coord);\n\t\tvec2\tfloor = floor(coord);\n\t\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\t\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\t\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\t\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\t\n\t\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\t\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\t\tvec3\tdirRay = normalize(screenPos - camPos);\n\t\tvec4\tcolor;\n\t\tmainImage(color, fract*(iResolution.xy), screenPos - nearClip * dirRay, dirRay);\n\t\taccColor += clamp(color, 0.0, 1.0);\n\t}\n\tfragColor = accColor / float(QAA*QAA);\n}\n\n", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "vec3 minComponent(in vec3 v)\n{\n    v = abs(v);\n    if(v.x < v.y)\n    {\n        if(v.x < v.z)\n        {\n            return vec3(1, 0, 0);\n        }\n    }\n    else\n    {\n        if(v.y < v.z)\n        {\n            return vec3(0, 1, 0);\n        }\n    }\n    return vec3(0, 0, 1);\n}\n\n\nmat3 rotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    initSolidTransfrom(iTime);\n    \n    vec3 up = minComponent(rayDir);\n    vec3 right = cross(rayDir, up);\n    up = normalize(cross(right, rayDir));\n    up *= 1.0 / (iResolution.x * 0.5);\n   \n\n    mat3 rot = rotationMatrix(rayDir, radians( 360.0 / float(nbSample)));\n\n    vec2 center = texture(iChannel0, rayDir).xy;\n    \n    float sum = 0.0;   \n    for(int i = 0; i < nbSample; i++)\n    {\n        sum += texture(iChannel0, rayDir + up).x;\n        up = rot * up;\n    }\n    \n    float new = (sum * (2.0 / float(nbSample)) - center.y) * dampening; \n    \n    // Random point\n    if((iFrame % 6) == 0)\n    {\n        float d = dot(rayDir, randomPointOnSphere(float(iFrame)));\n        new -= d * smoothstep(0.998, 1.0, d) * 0.10; \n    }\n    // solid\n    float ds = mapSolid(rayDir);\n    new -= smoothstep(0.0, -0.05, ds) * 0.02;   \n\n    fragColor = vec4(vec2(new, center.x), 0 , 1);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n// Physics simulation parameters\nconst int nbSample = 6;\nconst float dampening = 0.985;\n\n\n\n// Hash by Dave Hoskins from https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Box SDF by IQ https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Fog by IQ https://iquilezles.org/articles/fog\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n \nmat4 solidTransform;\n\nvoid initSolidTransfrom(float t)\n{\n    vec3 ang = vec3(sin(t * 1.2) * radians(20.), -0.2 * t, sin(t * 1.3) * radians(20.));\n    vec3 trans = vec3(sin(t * 0.23), sin(t * 0.25), sin(t * 0.24)) * vec3(0.1, 0.5, 0.2);\n    \n    mat4 mt = mat4(\n\t\t\t1.0,\t\t0.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t1.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0,         0.0,\n\t\t\ttrans.x,\ttrans.y,\ttrans.z,     1.0 );\n        \n    mat4 mx = mat4(\n\t\t\t1.0,\t\t0.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x), 0.0,\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x) , 0.0,\n\t\t\t0.0,\t\t0.0,\t\t0.0,         1.0 );\n    mat4 my = mat4(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),  0.0,\n\t\t\t0.0,\t\t1.0,\t\t0.0,         0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y), 0.0, \n\t\t\t0.0,\t\t0.0,\t\t0.0,         1.0 );\n    mat4 mz = mat4(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,         0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t0.0,         1.0 );\n        \n    solidTransform = mt * mx * my * mz;\n}\n\nfloat mapSolid(vec3 p)\n{\n    float width = 0.2;\n    float length = 1.2;\n    p = vec3(solidTransform * vec4(p, 1));\n    return min(min(sdBox( p, vec3(length, width, width)), sdBox( p, vec3(0.2, length, width))) , sdBox( p, vec3(width, width, length)));\n}\n\nvec3 randomPointOnSphere(float key)\n{\n    vec2 rand = hash21(key);\n    float theta = radians(360.0) * rand.x;\n    float phi = acos(2.0 * rand.y - 1.0);\n    return vec3 (cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi));    \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2XDG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[315, 315, 340, 340, 369], [371, 420, 455, 455, 479], [482, 482, 509, 509, 590], [2138, 2138, 2187, 2187, 3875], [3877, 3877, 3955, 3955, 4027], [4029, 4029, 4071, 4071, 4235]]}
{"id": "flBSDy", "name": "Dunes and ridges", "author": "jarble", "description": "A desert fractal landscape.\nThis is based on dyla's [url=https://www.shadertoy.com/view/WdcfDn]\"Fyords\"[/url] shader.", "tags": ["procedural", "fractal", "terrain", "dune"], "likes": 4, "viewed": 325, "published": 3, "date": "1628475448", "time_retrieved": "2024-07-30T19:07:02.087232", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of detail\n#define OCTAVES 2\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = 3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += min(sin(uv*factor)/factor,cos(uv/factor)*factor).yx;\n        value = -min(value+cos(uv.x-uv.y)/factor,-value+sin((uv.x-uv.y))/factor);\n        uv /= factor;\n    }\n    \n    return value+1.5;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[488, 488, 511, 560, 873], [947, 947, 985, 985, 1045], [1047, 1047, 1080, 1080, 1300], [1302, 1302, 1340, 1340, 1567], [1569, 1569, 1607, 1607, 1831], [1833, 1833, 1862, 1862, 1957], [1959, 1959, 1996, 1996, 2055], [2058, 2126, 2145, 2145, 2184], [2186, 2186, 2206, 2206, 2282], [2284, 2284, 2303, 2303, 2342], [2344, 2344, 2401, 2401, 2636], [2638, 2638, 2673, 2673, 3067], [3069, 3069, 3123, 3123, 3789], [3792, 3792, 3844, 3844, 4279], [4281, 4281, 4338, 4338, 5523]]}
{"id": "flSSDy", "name": "Tunnel - distance", "author": "iq", "description": "Distance to a tunnel shape", "tags": ["2d", "distancefield", "tunnel", "sdf", "distance"], "likes": 20, "viewed": 1368, "published": 3, "date": "1628471259", "time_retrieved": "2024-07-30T19:07:02.972864", "image_code": "// The MIT License\n// Copyright  2021 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Signed distance to a 2D tunnel shape\n\n// List of some other 2D distances:\n//    https://www.shadertoy.com/playlist/MXdSRf\n// and\n//    iquilezles.org/articles/distfunctions2d\n\nfloat dot2( vec2 v ) { return dot(v,v); }\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n// alternative formulation\nfloat sdTunnel2( in vec2 p, in vec2 wh )\n{\n    vec2 q = abs(p);\n    q.x -= wh.x;\n\n    if( p.y>=0.0 )\n    {\n    q.x = max(q.x,0.0);\n    q.y += wh.y;\n    return -min( wh.x-length(p), length(q) );\n    }\n    else\n    {\n    q.y -= wh.y;\n    float f = max(q.x,q.y);\n    return (f<0.0) ? f : length(max(q,0.0));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec2 wh = 0.4 + 0.4*sin(iTime*vec2(1.1,1.2)+vec2(3.0,1.0));\n\n\tfloat d = sdTunnel( p, wh );\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdTunnel( m, wh );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSSDy.jpg", "access": "api", "license": "mit", "functions": [[1257, 1257, 1279, 1279, 1298], [1300, 1300, 1341, 1341, 1610], [1612, 1639, 1681, 1681, 1951], [1953, 1953, 2010, 2010, 2696]]}
{"id": "7l2Xzd", "name": "[CrzClm] sdTunnel", "author": "iY0Yi", "description": "This is a part of my piece \"Crazy Climbers\".\n[url]https://iy0yi.me/work/crazy-climbers/[/url]\nOther parts playlist:\n[url]https://www.shadertoy.com/playlist/3X3BRB[/url]", "tags": ["2d", "distancefield", "tunnel", "sdf", "distance", "crazyclimbers"], "likes": 3, "viewed": 162, "published": 3, "date": "1628470200", "time_retrieved": "2024-07-30T19:07:03.808630", "image_code": "// Tunnel sdf. \nfloat sdTunnel( in vec2 p, in vec2 s )\n{\n    return max(-p.y, length(p-vec2(0,clamp(p.y, -s.y-s.x, s.y)))-s.x );\n}\n\n// Based on iq's 2d sdf shader.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y+1.;\n\n    vec2 s = vec2(max(0.,sin(iTime))*0.5+.25, max(0.,-sin(iTime))*.5+.5);\n    if( iMouse.z>0.001 )\n    {\n        s=m;\n    }\n\tfloat d = sdTunnel(p+vec2(0,.5), s);\n    \n\t// coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2Xzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 16, 56, 56, 130], [132, 164, 221, 221, 735]]}
{"id": "NlBSWy", "name": " - Quicky #058", "author": "totetmatt", "description": "Inspiration from https://imgur.com/e9IMX", "tags": ["quicky"], "likes": 9, "viewed": 412, "published": 3, "date": "1628462377", "time_retrieved": "2024-07-30T19:07:05.007424", "image_code": "#define fGlobalTime iTime\nfloat diam(vec3 p,float s){\n   p=  abs(p);\n   return (p.x+p.z+p.y-s)*inversesqrt(3.);  \n }\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n }\n float sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nfloat smin( float a, float b, float k )\n{\nfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat bbox(vec3 p,float q){\n    float h = sdBoxFrame(p,vec3(1.),.1);\n    return smin(h, diam(abs(p)-.9,.3),q);\n  \n }\nvec3 extp,intp;\n vec2 struc(vec3 p,float q){\n      \n     vec2 h,t;\n     vec3 pp = p;\n     p.xy*=rot(fGlobalTime);\n     p.xz*=rot(fGlobalTime);\n     extp=p;\n     h.x = box(p,vec3(2.55));\n     h.y = 1.;\n     p = abs(p)-.9;\n     p = abs(p)-.9;\n     h.x = max(-h.x,bbox(p,q));\n     \n     \n     pp.xy*=rot(-fGlobalTime);\n     pp.xz*=rot(-fGlobalTime);\n     t.x = bbox(pp,q);\n     t.y = 1.5;\n     h= t.x < h.x ? t:h;\n     intp=pp;\n   return h;\n   \n }\n\nvec2 sdf(vec3 p){\n\n     p.yz*=rot(atan(inversesqrt(1./2.)));\n     p.xz*=rot(3.141592/4.);\n      p.xz/=4.;\n     p.xz = asin(sin(p.xz)*(.925-texture(iChannel0,p.xz*.1).r*.075));\n     p.xz*=4.;\n    vec2 h;\n\n     h= struc(p*.92,-.01);\n     vec2 t = struc(p,.0);\n     t.y += 1.;\n     h= t.x < h.x ? t:h;\n    return h;\n}\n#define q(s) s*sdf(p+s).x\nvec2 e=vec2(-.003,.003);\nvec3 norm(vec3 p){return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n#define ao(rp,n,k) (sdf(rp+n*k).x/k)\n#define AO(rp,n) (ao(rp,n,.1)+ao(rp,n,.5)+ao(rp,n,1.1))\nvec3 pal(float t){\n  \n  return .5+.5*cos(6.28*(.1*t+vec3(1.,.4,.3)));\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\nvec3  col = vec3(.1);\n  vec3 ro = vec3((uv)*10.,-30.);\n  vec3 rd = vec3(0.,0.,1.);\n  vec3 light = vec3(7.,5.,-5.);\n  vec3 rp = ro;\n  vec3 acc = vec3(.0);\n  for(float i=0.;i<=128.;i++){\n      vec2 d = sdf(rp);\n    if(d.y >= 2.){\n         vec3 off = d.y == 2.5 ? intp:extp;\n         acc +=sqrt(pal(length(off)+iTime*2.))*exp(2.*-abs(d.x))/(29.+sin(atan(off.x,off.y)*10.)*20.);\n       d.x = max(.002+sin(off.y*20.+off.x*20.)*.01,abs(d.x));\n     }\n    if(length(rp)>50.) break;\n     if(d.x <=.001){\n         if(d.y==1.){\n          vec3 n = norm(rp);\n          float diff = max(0.,dot(normalize(light-rp),n));\n          float sp = max(0.,dot(normalize(ro-rp),reflect(-normalize(light),n)));\n            col = vec3(.5)*diff+vec3(5.,0.,0.)*pow( sp,32.);\n            col *=AO(rp,n)/1.7;\n           }\n        break;\n      }\n      rp+=d.x*rd;\n  }\n  col +=acc;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBSWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 53, 53, 116], [117, 117, 143, 143, 235], [237, 237, 282, 282, 564], [565, 565, 583, 583, 630], [631, 631, 672, 672, 761], [762, 762, 789, 789, 878], [896, 896, 923, 923, 1323], [1325, 1325, 1342, 1342, 1639], [1691, 1691, 1709, 1709, 1764], [1858, 1858, 1876, 1876, 1931], [1933, 1933, 1990, 2040, 2983]]}
{"id": "NlBXDG", "name": "my first shaderrrrrr", "author": "hiPeeps124816", "description": "shader example from https://en.wikipedia.org/wiki/Shadertoy becuase I'm so bad at this", "tags": ["example", "wikipedia", "isuck"], "likes": 7, "viewed": 309, "published": 3, "date": "1628458230", "time_retrieved": "2024-07-30T19:07:05.955888", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // input: pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    float a = atan(p.y,p.x);\n    \n    // modified distance metric\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\n    \n    // index texture by (animated inverse) radius and angle\n    vec2 uv = vec2( 1.0/r + 0.2*iTime, a );\n\n    // pattern: cosines\n    float f = cos(12.0*uv.x)*cos(6.0*uv.y);\n\n    // color fetch: palette\n    vec3 col = 0.5 + 0.5*sin( 3.141592653589793238462643383*f + vec3(0.0,0.5,1.0) );\n    \n    // lighting: darken at the center    \n    col = col*r;\n    \n    // output: pixel color\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 89, 764]]}
{"id": "NlSSDG", "name": "DragonEye II", "author": "mrange", "description": "License CC0: DragonEye II\nA year or so ago I played with quasi crystals and I found they looked like \"dragon eyes\" with certain parameters\nThis is an evolution of that idea.\n", "tags": ["2d", "fbm"], "likes": 52, "viewed": 942, "published": 3, "date": "1628452763", "time_retrieved": "2024-07-30T19:07:07.079883", "image_code": "// License CC0: DragonEye II\n// A year or so ago I played with quasi crystals and I found they looked like \"dragon eyes\" with certain parameters\n// This is an evolution of that idea.\n\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define LAYERS      6\n#define FBM         3\n#define DISTORT     1.4\n#define PCOS(x)     (0.5+0.5*cos(x))\n\n// https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float eyeAngle = 0.8;\nconst mat2  eyeRot = ROT(eyeAngle);\nconst vec2  eyeRef = vec2(cos(eyeAngle), sin(eyeAngle));\n\nfloat g_psy_th = 0.0;\nfloat g_psy_hf = 0.0;\n\nvec2 g_psy_vx = vec2(0.0);\nvec2 g_psy_vy = vec2(0.0);\n\nvec2 g_psy_wx = vec2(0.0);\nvec2 g_psy_wy = vec2(0.0);\n\nconst vec3 lightPos1 = 100.0*vec3(-1.3, 1.9, 2.0);\nconst vec3 lightPos2 = 100.0*vec3(9.0,  3.2, 1.0);\nconst vec3 lightDir1 = normalize(lightPos1);\nconst vec3 lightDir2 = normalize(lightPos2);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\nconst vec3 skinCol1  = vec3(0.6, 0.2, 0.2);\nconst vec3 skinCol2  = vec3(0.6);\n\nvec3 saturate(in vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// IQ's smooth min: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\n// https://iquilezles.org/articles/spherefunctions\nfloat raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nfloat outer(vec2 p) {\n  p *= eyeRot;\n  return vesica(p, 1.0*vec2(0.5, 0.25))-0.15;\n}\n\nfloat inner(vec2 p) {\n  p *= eyeRot;\n  return vesica(p, 1.0*vec2(0.125, 0.35));\n}\n\n\nfloat qc_wave(float theta, vec2 p) {\n  return (cos(dot(p,vec2(cos(theta),sin(theta)))));\n}\n\nfloat qc_noise(vec2 p) {\n  float sum = 0.;\n  float a = 1.0;\n  for(int i = 0; i < LAYERS; ++i)  {\n    float theta = float(i)*PI/float(LAYERS);\n    sum += qc_wave(theta, p)*a;\n    a*=DISTORT;\n  }\n\n  return abs(tanh_approx(sum));\n}\n\nfloat qc_fbm(vec2 p, float time) {\n  float sum = 0.;\n  float a = 1.0;\n  float f = 1.0;\n  for(int i = 0; i < FBM; ++i)  {\n    sum += a*qc_noise(p*f);\n    a *= 2.0/3.0;\n    f *= 2.31;\n  }\n\n  return 0.45*(sum);\n}\n\nfloat qc_height(vec2 p) {\n  float od = outer(p);\n  float l = length(p);\n  const float s = 5.0;\n  p *= s;\n//  return -5.0*pmin(fbm(p), 0.75, 2.5)*exp(-5.0*l);\n  float sm = 0.05;\n  float oh = smoothstep(0.0, sm, od); \n  \n  float h =  -5.0*qc_fbm(p, TIME)*exp(-4.0*l)*oh;\n  return h;\n}\n\nvec3 qc_normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = qc_height(p + e.xy) - qc_height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = qc_height(p + e.yx) - qc_height(p - e.yx);\n  \n  return normalize(n);\n}\n\nfloat psy_noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat psy_fbm(vec2 p, float aa) {\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*psy_noise(p); \n    p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= aa;\n  }\n  return f/s;\n}\n\nfloat psy_warp(vec2 p, out vec2 v, out vec2 w) {\n  float id = inner(p); \n  \n  const float r  = 0.5;\n  const float rr = 0.25;\n  float l2 = length(p);\n  float f  = 1.0;\n\n  p   -= eyeRef*pmax(0.0, dot(p, eyeRef), 0.25)*2.0;\n  p   -= 0.25*eyeRef;\n\n  f = smoothstep(-0.1, 0.15, id);\n  const float rep = 50.0;\n  const float sm = 0.125*0.5*60.0/rep;\n  float  n = smoothKaleidoscope(p, sm, rep);\n  p.y += TIME*0.125+1.5*g_psy_th;\n\n  g_psy_hf = f;\n  vec2 pp = p;\n\n  vec2 vx = g_psy_vx;\n  vec2 vy = g_psy_vy;\n\n  vec2 wx = g_psy_wx;\n  vec2 wy = g_psy_wy;\n\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\n  float aa = 0.5;\n\n  v = vec2(psy_fbm(p + vx, aa), psy_fbm(p + vy, aa))*f;\n  w = vec2(psy_fbm(p + 3.0*v + wx, aa), psy_fbm(p + 3.0*v + wy, aa))*f;\n  \n  return -tanh_approx(psy_fbm(p + 2.25*w, aa)*f);\n}\n\nvec3 psy_normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = psy_warp(p + e.xy, v, w) - psy_warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = psy_warp(p + e.yx, v, w) - psy_warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvec3 psy_weird(vec2 p) {\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec2 v;\n  vec2 w;\n \n  float h  = psy_warp(p, v, w);\n  float hf = g_psy_hf;\n  vec3  n  = psy_normal(p);\n\n  vec3 lcol1 = lightCol1;\n  vec3 lcol2 = lightCol2;\n  vec3 po  = vec3(p.x, 0.0, p.y);\n  vec3 rd  = normalize(po - ro);\n  \n  float diff1 = max(dot(n, lightDir1), 0.0);\n  float diff2 = max(dot(n, lightDir2), 0.0);\n\n  vec3  ref   = reflect(rd, n);\n  float ref1  = max(dot(ref, lightDir1), 0.0);\n  float ref2  = max(dot(ref, lightDir2), 0.0);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\n  \n  float a = length(p);\n  vec3 col = vec3(0.0);\n//  col -= 0.5*hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\n//  col -= 0.5*hsv2rgb(vec3(fract(sqrt(0.5)*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\n  col -= 0.5*(length(v)*col1 + length(w)*col2*1.0);\n   /*\n  col += 0.25*diff1;\n  col += 0.25*diff2;\n  */\n  col += 0.5*lcol1*pow(ref1, 20.0);\n  col += 0.5*lcol2*pow(ref2, 10.0);\n  col *= hf;\n\n  return max(col, 0.0);\n}\n\nfloat vmax(vec2 v) {\n  return max(v.x, v.y);\n}\n\nfloat corner(vec2 p) {\n  return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  float ld1      = max(dot(lightDir1, rd), 0.0);\n  float ld2      = max(dot(lightDir2, rd), 0.0);\n  vec3 final     = vec3(0.0);\n\n  rd.xy *= ROT(-1.);\n  vec2 bp = rd.xz/max(0.0,rd.y);\n  float bd = corner(-bp);\n  final += 0.3*exp(-5.0*max(bd, 0.0)); \n  final += 0.20*smoothstep(0.025, 0.0, bd); \n  \n  final += 8.0*lightCol1*pow(ld1, 100.0);\n  final += 8.0*lightCol2*pow(ld2, 100.0);\n  \n  return final;\n}\n\nvec3 eyeColor(vec2 p, vec3 ro, vec3 rd, vec3 po, float od) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 sc    = vec3(0.0);\n  float sd   = raySphere(ro, rd, vec4(sc, 0.75));\n  vec3 spos  = ro + sd*rd;\n  vec3 snor  = normalize(spos - sc);\n  vec3 refl  = reflect(rd, snor);\n  vec3 scol  = skyColor(spos, refl);\n  float dif1 = max(dot(snor, lightDir1), 0.0);\n  float dif2 = max(dot(snor, lightDir2), 0.0);\n\n\n  vec3 pcol = psy_weird(p);\n  vec3 col1 = vec3(0.0);\n  col1 += pcol;\n  col1 += scol;\n  col1 += 0.025*(dif1*dif1+dif2*dif2);\n\n  vec3 col2 = 0.125*(skinCol1)*(dif1 + dif2)+0.125*sqrt(scol);\n \n  snor.xz *= ROT(-0.5*eyeAngle);\n  snor.xy *= ROT(-2.4*smoothstep(0.99, 1.0, sin(TTIME/12.0)));\n  float a = atan(snor.y, snor.x);\n\n  vec3 col = mix(col1, col2, step(a, 0.0));\n\n  col *= smoothstep(0.0, -0.1, od);\n  \n  return col;\n}\n\nvec3 skinColor(vec2 p, vec3 ro, vec3 rd, vec3 po, float od) {\n  float lp = length(p);\n  float aa = 2.0/RESOLUTION.y;\n\n  float qch = qc_height(p);\n  vec3  qcn = qc_normal(p);\n\n  float diff1 = max(dot(qcn, lightDir1), 0.0);\n  float diff2 = max(dot(qcn, lightDir2), 0.0);\n\n  vec3  ref   = reflect(rd, qcn);\n  vec3  scol  = skyColor(po, ref);\n\n  vec3 lcol1 = lightCol1;\n  vec3 lcol2 = lightCol2;\n  vec3 lpow1 = 0.25*lcol1;\n  vec3 lpow2 = 0.5*lcol2;\n  vec3 dm = mix(1.0*skinCol1, skinCol2, 1.0+tanh_approx(2.0*qch))*tanh_approx(-qch*10.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*sqrt(diff1)*lpow1;\n  col += dm*sqrt(diff2)*lpow2;\n\n  const float ff = 0.6;\n  float f = ff*exp(-2.0*od);\n\n  col *= f;\n  col += 0.5*ff*sqrt(scol);\n  col -= (1.0-tanh_approx(10.0*-qch))*f;\n  col *= smoothstep(0.0, 0.025, od);\n  return col;\n}\n\nvoid compute_globals() {\n\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vx *= ROT(TTIME/1000.0);\n  vy *= ROT(TTIME/900.0);\n\n  wx *= ROT(TTIME/800.0);\n  wy *= ROT(TTIME/700.0);\n  \n  g_psy_vx = vx;\n  g_psy_vy = vy;\n  \n  g_psy_wx = wx;\n  g_psy_wy = wy;\n}\n\nvec3 color(vec2 p) {\n  compute_globals();\n  \n  float aa = 2.0/RESOLUTION.y;\n  float od = outer(p);\n\n\n  vec3 ro = vec3(0.0, 10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, 0.0, p.y);\n  vec3 rd = normalize(po-ro);\n\n\n  vec3 col = od > 0.0 ? skinColor(p, ro, rd, po, od) : eyeColor(p, ro, rd, po, od); \n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float a = PCOS(TTIME/60.0);\n  p *= mix(0.8, 1.2, 1.0-a);\n  vec3 col = color(p);\n\n  col = postProcess(col, q);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSSDG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[606, 606, 628, 628, 774], [1633, 1633, 1659, 1659, 1688], [1689, 1689, 1715, 1715, 1744], [1745, 1745, 1773, 1773, 1802], [1804, 1804, 1832, 1852, 1928], [1930, 1987, 2026, 2026, 2111], [2113, 2113, 2152, 2152, 2181], [2183, 2183, 2213, 2213, 2240], [2242, 2242, 2264, 2264, 2308], [2310, 2310, 2331, 2331, 2376], [2378, 2410, 2455, 2455, 2609], [2611, 2611, 2672, 2672, 2885], [2887, 2887, 2918, 2918, 3216], [3218, 3269, 3314, 3314, 3506], [3508, 3508, 3529, 3529, 3592], [3594, 3594, 3615, 3615, 3675], [3678, 3678, 3714, 3714, 3768], [3770, 3770, 3794, 3794, 3998], [4000, 4000, 4034, 4034, 4209], [4211, 4211, 4236, 4236, 4493], [4495, 4495, 4519, 4519, 4737], [4739, 4739, 4764, 4764, 4886], [4888, 4888, 4921, 4921, 5177], [5179, 5179, 5227, 5227, 5976], [5978, 5978, 6003, 6003, 6241], [6243, 6243, 6267, 6267, 7458], [7460, 7460, 7480, 7480, 7506], [7508, 7508, 7530, 7530, 7590], [7592, 7592, 7625, 7625, 8027], [8029, 8029, 8089, 8089, 8848], [8850, 8850, 8911, 8911, 9665], [9667, 9667, 9691, 9691, 9988], [9990, 9990, 10010, 10010, 10327], [10329, 10329, 10365, 10365, 10598], [10600, 10600, 10655, 10655, 10896]]}
{"id": "sljSzd", "name": "city x", "author": "jorge2017a1", "description": "city x", "tags": ["cityx"], "likes": 7, "viewed": 267, "published": 3, "date": "1628439431", "time_retrieved": "2024-07-30T19:07:08.094171", "image_code": "//por jorge2017a1-\n///referencia iQ\n//https://iquilezles.org/articles/distfunctions\n\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nvec3 opAngRep( vec3 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n\nvec3 planeta(vec3 p)\n{   vec3 res= vec3(9999.0, -1.0,-1.0);\n    float sds1 =sdSphere(p- vec3(0.0,0.0,0.0), 15.0 );\n    float sdc1 =sdCylinder(p- vec3(0.0,0.0,0.0) , vec2(30.0,0.5) );\n\t  \n    float sdu1 =unionSDF(sds1,sdc1);\n    res=opU(res, vec3(sdu1,-1.0,1.0));\n    return res;\n}    \n\nvec3 Piramidepicos(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float sdt1= sdTriPrism( p-vec3(12.5,-1.0,30.0), vec2(8.0,5.0));\n    float sdc1= sdCylinderXY(p-vec3(12.0,0.0,30.0), vec2(2.0,7.0) );\n    \n    vec3 p3=p-vec3(0.0,25.0,65.0);\n    p3=rotate_x( p3, radians(45.0));\n    \n    \n    res =opU3(res, vec3(sdt1,3.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdc1,5.0,MATERIAL_NO)); \n    float tau = atan(1.0) * 8.0;\n    float numitem=8.0;\n   \n    float r1,  r2,  h;\n    r1=1.0;\n    r2=0.1;\n    h=15.0;\n    vec3 p4=p-vec3(13.0,5.0,35.0);\n    vec3 rep4 = opAngRep(p4, tau / numitem);\n    rep4.zy=  rotatev2(rep4.zy, radians( 90.0));\n    rep4.xy=  rotatev2(rep4.xy, radians( 90.0));\n    \n    float sdrc1= sdRoundCone(rep4-vec3(5.0,0.0,0.0), r1,r2,h );\n    res =opU3(res, vec3(sdrc1,19.0,MATERIAL_NO));\n       \nreturn  res;\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n      p.y=p.y-5.0;\n    vec3 p3=p-vec3(0.0,25.0,65.0);\n    vec3 p5=p;\n    p3=rotate_x( p3, radians(45.0));\n    \n    p3.x= opRep1D(p3.x, 140.0 );\n    vec3 pl1= planeta(p3);\n    res =opU3(res, pl1);\n    \n    p5.x= opRep1D(p5.x, 50.0 );\n    vec3 pip1= Piramidepicos(p5);\n    res =opU3(res, pip1);\n    \n    \n    vec3 p1=p;vec3 p2=p;\n    \n    p1=p1-vec3(0.0,22.0,40.0);\n    p2=p2-vec3(30.0,22.0,40.0);\n    \n    p1.x= opRep1D(p1.x, 65.0 );\n    p2.x= opRep1D(p2.x, 65.0 );\n    \n    p1=rotate_z( p1, radians(25.0));\n    p2=rotate_z( p2, radians(335.0));\n    \n    float sdb1= sdBox( p1, vec3(2.0,60.0,2.0) );\n    float sdb2= sdBox( p2, vec3(2.0,60.0,2.0) );\n    \n    res =opU3(res, vec3(sdb1,1.0,MATERIAL_NO));\n    res =opU3(res, vec3(sdb2,2.0,MATERIAL_NO));\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n    return lin;\n}\n//----------------------------------------------------\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    vec3 col2=mix(vec3(1.0), vec3(0.0),random()+rd.x*0.5);\n    sky*=col2*rd.z*1.5;\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n\n     if(id_material==1.0)\n    {\n     float i0, i1, i2, i4;\n     i0 = 1.0, i1 = 1.0, i2 = 1.0, i4 = 0.0;\n     vec2 uv=p.xy*0.5;\n     \n        for (int s = 0; s < 7; s++) \n        {\n        vec2 r;\n        r = vec2(cos(uv.y * i0 - i4 + iTime / i1), sin(uv.x * i0 - i4 + iTime / i1)) / i2;\n        r += vec2(-r.y, r.x) * 0.3;\n        uv.xy += r;\n        i0 *= 1.93;\n        i1 *= 1.15;\n        i2 *= 1.7;\n        i4 += 0.05 + 0.1 * iTime * i1;\n  \t   }\n        \n        float rc = sin(uv.x ) * 0.25 + 0.5;\n  \t\tfloat bc = sin(uv.y ) * 0.5 + 0.5;\n  \t\tfloat gc = sin((uv.x + uv.y + sin(1.0 * 0.5)) * 0.5) * 0.5 + 0.5;\n        vec3 col= vec3(rc,gc,bc);\n        return col;\n\t}      \n    \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n    float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        //col *= 1.0 - pow(mObj.dist /(MAX_DIST) , 3.5);    \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0+t,5.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(340.0)) ;\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[545, 545, 581, 581, 602], [603, 603, 635, 635, 719], [720, 720, 757, 757, 852], [853, 853, 892, 892, 987], [988, 988, 1027, 1027, 1122], [1123, 1123, 1162, 1162, 1257], [1259, 1303, 1350, 1350, 1377], [1378, 1378, 1421, 1421, 1448], [1449, 1449, 1497, 1497, 1525], [1526, 1564, 1600, 1600, 1645], [1647, 1712, 1746, 1746, 1842], [1843, 1843, 1877, 1877, 1968], [1969, 1969, 2003, 2003, 2094], [2095, 2135, 2169, 2169, 2264], [2268, 2268, 2302, 2302, 2475], [2477, 2477, 2513, 2513, 2596], [2598, 2598, 2656, 2656, 2920], [2923, 2923, 2945, 2945, 3203], [3209, 3209, 3237, 3237, 4036], [4038, 4078, 4103, 4103, 5109], [5111, 5162, 5186, 5186, 5348], [5350, 5350, 5399, 5399, 6066], [6068, 6155, 6191, 6191, 6436], [6437, 6492, 6519, 6519, 6536], [6538, 6538, 6574, 6574, 6666], [6667, 6667, 6713, 6713, 6838], [6840, 6840, 6914, 6914, 8447], [8448, 8537, 8617, 8617, 8740], [8741, 8782, 8814, 8814, 9094], [9096, 9144, 9172, 9172, 9360], [9362, 9413, 9460, 9460, 10374], [10376, 10428, 10521, 10521, 10858], [10861, 10861, 10892, 10892, 11547], [11549, 11598, 11624, 11624, 11734], [11736, 11736, 11794, 11794, 11846], [11848, 11897, 11954, 11954, 12533]]}
{"id": "7tBXzd", "name": "More Apollonians", "author": "mla", "description": "Parameterized Apollonians. Use mouse to set inversion circle dihedral. See code for further controls.", "tags": ["inversion", "apollonian"], "likes": 26, "viewed": 492, "published": 3, "date": "1628436574", "time_retrieved": "2024-07-30T19:07:08.848155", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Apollonian circles. Iterated inversion in a ring of circles.\n//\n// Construct K circles in a ring, as well as a central circle. The circles have\n// dihedral angles phi and psi, set with the mouse. Press 'c' to see the circles.\n// The dihedral angles can be varied continously, though for exact alignment of\n// the pattern they should be integral fractions of pi.\n//\n// For each point in the plane, if it is inside any of the circles, invert the\n// point in that circle. Repeat. The pattern converges on a set of complementary\n// circles, orthogonal to the original circles.\n//\n// Limits of dihedral angles depends on K, eg. for K = 3, phi should be in\n// range 0 <= phi <= PI/7 for sensible results.\n// \n// Controls:\n// mouse: set phi and psi angles from x & y coordinates\n// left/right: change K, the number of circles in the ring\n// up/down: zoom\n// a: antialiasing\n// b: outlines of circles\n// c: show inversion circles\n// f: central reflection when inverting in centre circle\n// g: gyrate\n// h: transform to halfplane\n// i: invert unit circle to exterior\n// l: show inversion circle lines\n// s: color according to inversion steps taken\n// t: alternative colouring\n//\n// This can all be better understood in terms of limits of hyperbolic\n// honeycombs (the fundamental tetrahedron of the honeycomb corresponds\n// a set of four circles on the Poincare ball boundary, which can be\n// stereographically mapped to the plane. See eg.\n// https://www.shadertoy.com/view/WtXcWs for more).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint maxsteps = 200;\n\nconst int MAXK = 20;\nvec3 circles0[MAXK+1];\nvec3 circles1[MAXK+1];\n\nvoid initcircles(int K, float phi, float psi) {\n  float theta = PI/float(K); // half angle between circle centres\n  // radius of ring circles, centred on unit circle\n  float r = sin(theta);\n  r /= cos(0.5*phi); // Get correct dihedral between ring circles\n  float r2 = r*r;\n\n  // s2 is the radius for the inner circle that gives\n  // the right dihedral angle with the outer circles.\n  // cosine formula + quadratic equation\n  float B = -r*cos(psi);\n  float C = r2-1.0;\n  float s = B + sqrt(B*B-C);\n  float s2 = s*s;\n\n  // Scale factor to make disc be 1 unit radius\n  float scale2 = 1.0/(1.0-r2);\n  float scale = sqrt(scale2);\n  circles0[0] = vec3(0,0,scale2*s2);\n  // The complementary/dual set of circles\n  //circles1[0] = vec3(0,0,1);\n  circles1[0] = vec3(0,0,sqr(scale2*s2)); // Unit circle inverted in midcircle\n  // Centre & radius for orthogonal circles\n  float k = 0.5*(1.0+s2-r2)/cos(theta);\n  for (int i = 0; i < K; i++) {\n    float t = float(2*i)*theta;\n    circles0[i+1] = vec3(scale*vec2(sin(t+theta),cos(t+theta)),scale2*r2);\n    circles1[i+1] = vec3(scale*k*vec2(sin(t),cos(t)),scale2*(k*k-s2));\n  }\n}\n\nbool inside(vec2 p, vec3 c) {\n  float r2 = length2(p-c.xy);\n  return r2 <= c.z;\n}\n\n// Invert p in circle c, keeping track of conformal scale factor.\nvec2 invert(vec2 p, vec3 c, inout float scale) {\n  p -= c.xy;\n  float k = c.z/dot(p,p);\n  scale *= k;\n  p *= k;\n  p += c.xy;\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  int K = 3+max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  int N = K+1;\n  // Same rules as hyperbolic Schwarz triangles\n  float pmax = float((3*K-2)/(K-2));\n  float phi = PI/round(pmax*iResolution.x/iMouse.x);\n  float psi = PI/round(3.0*iResolution.y/iMouse.y);\n\n  initcircles(K,phi,psi);\n\n  float zoom = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  if (key(CHAR_Z)) zoom *= 0.5;\n\n  vec3 aacol = vec3(0);\n  bool dohalfplane = key(CHAR_H);\n  int AA = 1;\n  if (key(CHAR_A)) AA = 2;\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n      float pwidth = fwidth(z.x);\n      if (dohalfplane) z.y += 1.0;\n      z *= zoom;\n      float scale = zoom;\n      float scale0 = scale;\n      if (dohalfplane) z = invert(z,vec3(0,-1,2),scale);\n      vec2 z0 = z; // Remember original for scaling\n      int step;\n      for (step = 0; step < maxsteps; step++) {\n        bool found = false;\n        if (key(CHAR_I) && dot(z,z) > 1.0) {\n          z = invert(z,vec3(0,0,1),scale);\n        }\n        for (int i = 0; i < N; i++) {\n          vec3 c = circles0[i];\n          if (inside(z,c)) {\n            z = invert(z,c,scale);\n            if (key(CHAR_F) && i == 0) z = -z;\n            if (key(CHAR_G) && i == 0) z = rotate(z,0.2*PI*iTime); //-z;\n            found = true;\n            break;\n          }\n        }\n        if (!found) break;\n      }\n      vec3 col = vec3(1);\n      float dmin = 1e10;\n      int imin = 0;\n      if (dot(z,z) > 1.0) {\n        dmin = length(z)-1.0;\n      } else {\n        for (int i = 1; i < N; i++) {\n          vec3 c = circles1[i];\n          float d = abs(length(z-c.xy) - sqrt(abs(c.z)));\n          if (inside(z,c)) {\n            dmin = d;\n            imin = i;\n            break;\n          }\n        }\n      }\n      if (key(CHAR_S)) {\n        col = hsv2rgb(vec3(float(step)/20.0,0.8,0.8));\n      } else {\n        col = hsv2rgb(vec3(float(imin)/float(N+1),0.8,0.8));\n      }\n      if (!key(CHAR_B)) col *= smoothstep(0.0,0.002,dmin/scale);\n\n      if (!key(CHAR_L)) {\n        float dmin = 1e10;\n        int imin = -1;\n\n        for (int i = 0; i < N; i++) {\n          vec3 c = circles0[i];\n          float d = abs(length(z-c.xy) - sqrt(c.z));\n          if (d < dmin) {\n            dmin = d;\n            imin = i;\n          }\n        }\n        if (key(CHAR_T)) {\n          col *= (1.0-0.5*smoothstep(0.0,0.02,dmin));\n        } else {\n          col = mix(col,vec3(0),0.3*smoothstep(0.0,pwidth,dmin/scale));\n        }\n      }\n      bool showcircles = key(CHAR_C);\n      if (showcircles) {\n        float d = 1e8;\n        for (int i = 0; i < N; i++) {\n          d = min(d,abs(length(z0-circles0[i].xy) - sqrt(circles0[i].z)));\n          //d = min(d,abs(length(z0-circles1[i].xy) - sqrt(circles1[i].z)));\n        }\n        d /= scale0;\n        col = mix(vec3(0),col,smoothstep(0.005,0.01,d));\n      }\n      aacol += col;\n      }\n  }\n  aacol /= float(AA*AA);\n  aacol = pow(aacol,vec3(0.4545));\n  if (alert) aacol.x = 1.0;\n  fragColor = vec4(aacol,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  } else if (i == 1) {\n    if (j == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (j == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#if !defined key\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#endif\n#define keycount(key) (int(store(0,(key)).x))\n\nconst float PI = 3.14159265;\nconst float TWOPI = 2.0*PI;\nconst int AA = 2;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66; // black outlines\nconst int CHAR_C = 67; // show circles\nconst int CHAR_D = 68;\nconst int CHAR_F = 70; // Flip centre circle\nconst int CHAR_G = 71; // gyrate\nconst int CHAR_H = 72; // halfplane\nconst int CHAR_I = 73; // invert in unit circle\nconst int CHAR_J = 74;\nconst int CHAR_L = 76; // show circle lines\nconst int CHAR_S = 83; // show steps\nconst int CHAR_T = 84; // alternative display\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90; // zoom\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nfloat length2(vec2 p) {\n  return dot(p,p);\n}\n\nfloat sqr(float x) {\n  return x*x;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1744, 1744, 1791, 1791, 2861], [2863, 2863, 2892, 2892, 2944], [2946, 3012, 3060, 3060, 3150], [3152, 3152, 3208, 3208, 6278]]}
{"id": "fl2Xzd", "name": "stupid SH test", "author": "WingStone", "description": "renference: http://www.ppsloan.org/publications/StupidSH36.pdf", "tags": ["3d", "sh", "raymatching"], "likes": 4, "viewed": 230, "published": 3, "date": "1628436242", "time_retrieved": "2024-07-30T19:07:09.625078", "image_code": "#define EPSLON 0.001\n#define SPEED 0.1\n\n#define UP_COLOR vec3(1.0, 0.0, 0.0)\n#define BOTTOM_COLOR vec3(0.0, 1.0, 0.0)\n#define RIGHT_COLOR vec3(0.0,0.0,1.0)\n#define LEFT_COLOR vec3(1.0, 0.0, 1.0)\n#define FRONT_COLOR vec3(1.0,1.0,0.0)\n#define BACK_COLOR vec3(0.0,1.0,1.0)\n\n\n//---------------------------------------------------------------------------------\n\n// Constants, see here: http://en.wikipedia.org/wiki/Table_of_spherical_harmonics\n#define k01 0.2820947918 // sqrt(  1/PI)/2\n#define k02 0.4886025119 // sqrt(  3/PI)/2\n#define k03 1.0925484306 // sqrt( 15/PI)/2\n#define k04 0.3153915652 // sqrt(  5/PI)/4\n#define k05 0.5462742153 // sqrt( 15/PI)/4\n#define k06 0.5900435860 // sqrt( 70/PI)/8\n#define k07 2.8906114210 // sqrt(105/PI)/2\n#define k08 0.4570214810 // sqrt( 42/PI)/8\n#define k09 0.3731763300 // sqrt(  7/PI)/4\n#define k10 1.4453057110 // sqrt(105/PI)/4\n\n// unrolled version of the above\nfloat SH_0_0( in vec3 n ) { return  k01; }\nfloat SH_1_0( in vec3 n ) { return -k02*n.y; }\nfloat SH_1_1( in vec3 n ) { return  k02*n.z; }\nfloat SH_1_2( in vec3 n ) { return -k02*n.x; }\nfloat SH_2_0( in vec3 n ) { return  k03*n.x*n.y; }\nfloat SH_2_1( in vec3 n ) { return -k03*n.y*n.z; }\nfloat SH_2_2( in vec3 n ) { return  k04*(3.0*n.z*n.z-1.0); }\nfloat SH_2_3( in vec3 n ) { return -k03*n.x*n.z; }\nfloat SH_2_4( in vec3 n ) { return  k05*(n.x*n.x-n.y*n.y); }\nfloat SH_3_0( in vec3 n ) { return -k06*n.y*(3.0*n.x*n.x-n.y*n.y); }\nfloat SH_3_1( in vec3 n ) { return  k07*n.z*n.y*n.x; }\nfloat SH_3_2( in vec3 n ) { return -k08*n.y*(5.0*n.z*n.z-1.0); }\nfloat SH_3_3( in vec3 n ) { return  k09*n.z*(5.0*n.z*n.z-3.0); }\nfloat SH_3_4( in vec3 n ) { return -k08*n.x*(5.0*n.z*n.z-1.0); }\nfloat SH_3_5( in vec3 n ) { return  k10*n.z*(n.x*n.x-n.y*n.y); }\nfloat SH_3_6( in vec3 n ) { return -k06*n.x*(n.x*n.x-3.0*n.y*n.y); }\n\n\n//===========================Primitive==================================\n\n//default is signed\nfloat GetDistSphere(vec3 po, float r)\n{\n    return length(po) - r;\n}\n\n\nfloat GetDistPlane(vec3 po, vec3 nor, float len)\n{\n    return dot(po, nor) + len;\n}\n\n//====================Operation===================================\n\nvec2 OperateUnion(vec2 dist1, vec2 dist2)\n{\n    return dist1.x < dist2.x ? dist1 : dist2;\n}\n\n\n//==============================sh\nstruct SH\n{\n    vec3 sh0,sh1,sh2,sh3,sh4,sh5,sh6,sh7,sh8;\n};\n\nvoid EvalSHBasis(vec3 dir, vec3 col, inout SH sh)\n{\n    sh.sh0 += SH_0_0(dir)*col;\n    sh.sh1 += SH_1_0(dir)*col;\n    sh.sh2 += SH_1_1(dir)*col;\n    sh.sh3 += SH_1_2(dir)*col;\n    sh.sh4 += SH_2_0(dir)*col;\n    sh.sh5 += SH_2_1(dir)*col;\n    sh.sh6 += SH_2_2(dir)*col;\n    sh.sh7 += SH_2_3(dir)*col;\n    sh.sh8 += SH_2_4(dir)*col;\n}\nvoid SHMultiply(float t, inout SH sh)\n{\n    sh.sh0 *= t;\n    sh.sh1 *= t;\n    sh.sh2 *= t;\n    sh.sh3 *= t;\n    sh.sh4 *= t;\n    sh.sh5 *= t;\n    sh.sh6 *= t;\n    sh.sh7 *= t;\n    sh.sh8 *= t;\n}\n\nvec3 ShadeIrad(\n    vec4 vNormal,\n    vec4 cAr,\n    vec4 cAg,\n    vec4 cAb, \n    vec4 cBr,\n    vec4 cBg,\n    vec4 cBb,\n    vec4 cC)\n{ \n    vec3 x1, x2, x3;\n    \n    // Linear + constant polynomial terms\n    x1.r = dot(cAr,vNormal); \n    x1.g = dot(cAg,vNormal); \n    x1.b = dot(cAb,vNormal);              \n    \n    // 4 of the quadratic polynomials  \n    vec4 vB = vNormal.xyzz * vNormal.yzzx;  \n    x2.r = dot(cBr,vB);  \n    x2.g = dot(cBg,vB);     \n    x2.b = dot(cBb,vB);             \n    \n    // Final quadratic polynomial  \n    float vC = vNormal.x*vNormal.x - vNormal.y*vNormal.y;  \n    x3 = cC.rgb * vC; \n    return x1+x2+x3;  \n}\n\n//======================================================================\n\nvec2 GetDistAll(vec3 po)\n{\n    vec2 u = vec2(GetDistSphere(po, 1.0), 1.0);\n    \n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(0.0,-1.0, 0.0), 10.0), 2.0));//+y\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(0.0,1.0, 0.0), 10.0), 3.0));//-y\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(-1.0,0.0, 0.0), 10.0), 4.0));//+x\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(1.0,0.0, 0.0), 10.0), 5.0));//-x\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(0.0,0.0, -1.0), 10.0), 6.0));//+z\n    u = OperateUnion(u, vec2(GetDistPlane(po, vec3(0.0,0.0, 1.0), 10.0), 7.0));//-z\n    \n    return u;\n\n}\n\nvec3 GetNormal(vec3 po)\n{\n    vec2 e = vec2(1.0, -1.0) * EPSLON * 0.1;\n    return normalize(e.xxx * GetDistAll(po + e.xxx).x\n                     + e.xyy * GetDistAll(po + e.xyy).x\n                     + e.yxy * GetDistAll(po + e.yxy).x\n                     + e.yyx * GetDistAll(po + e.yyx).x);\n}\n\nvec4 RayMatch(vec3 po, vec3 rayDr)\n{\n    float l = 0.0;\n    vec4 edgePo = vec4(0.0);\n    for(int i = 0; i < 64; i++)\n    {\n        vec2 dist = GetDistAll(po + l * rayDr);\n        if(dist.x < EPSLON)\n        {\n            edgePo.w = dist.y;\n            break;\n        }\n        if(l > 64.0)\n        {\n            edgePo.w = 0.0;\n            break;\n        }\n        l += dist.x;\n    }\n    edgePo += vec4(po + l * rayDr, 0.0);\n    return edgePo;\n}\n\nvec3 Render(vec4 edgePo, vec3 viewDir,\n    vec4 cAr,\n    vec4 cAg,\n    vec4 cAb, \n    vec4 cBr,\n    vec4 cBg,\n    vec4 cBb,\n    vec4 cC)\n{\n    if(edgePo.w < 1.5)\n    {\n        vec3 nor = GetNormal(edgePo.xyz);\n        vec3 col = ShadeIrad(vec4(nor,1.0),cAr,cAg,cAb,cBr,cBg,cBb,cC);\n        return clamp(col, 0.0, 1.0);\n    }\n    else if(edgePo.w < 2.5)\n    {    \n        return UP_COLOR;\n    }\n    else if(edgePo.w < 3.5)\n    {    \n        return BOTTOM_COLOR;\n    }\n    else if(edgePo.w < 4.5)\n    {    \n        return RIGHT_COLOR;\n    }\n    else if(edgePo.w < 5.5)\n    {    \n        return LEFT_COLOR;\n    }\n    else if(edgePo.w < 6.5)\n    {    \n        return FRONT_COLOR;\n    }\n    else if(edgePo.w < 7.5)\n    {    \n        return BACK_COLOR;\n    }\n}\n\n//==========================image\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\n//===================================Main===================================\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 inv_Reso = 1.0 / iResolution.xy;\n    \n    // SH\n    SH sh = SH(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n    EvalSHBasis(vec3(0.0, 1.0, 0.0), UP_COLOR, sh);\n    EvalSHBasis(vec3(0.0, -1.0, 0.0), BOTTOM_COLOR, sh);\n    EvalSHBasis(vec3(1.0, 0.0, 0.0), RIGHT_COLOR, sh);\n    EvalSHBasis(vec3(-1.0, .0, 0.0), LEFT_COLOR, sh);\n    EvalSHBasis(vec3(0.0, 0.0, 1.0), FRONT_COLOR, sh);\n    EvalSHBasis(vec3(0.0, 0.0, -1.0), BACK_COLOR, sh);\n    SHMultiply(4.0*3.1415926/6.0, sh);\n    \n    const float s_fSqrtPI = sqrt(3.1415926); \n    const float fC0 = 1.0f/(2.0f*s_fSqrtPI);\n    const float fC1 = sqrt(3.0f)/(3.0f*s_fSqrtPI); \n    const float fC2 = sqrt(15.0f)/(8.0f*s_fSqrtPI); \n    const float fC3 = sqrt(5.0f)/(16.0f*s_fSqrtPI); \n    const float fC4 = 0.5f*fC2; \n    \n    vec4 cAr = vec4(0.0);\n    vec4 cAg = vec4(0.0); \n    vec4 cAb = vec4(0.0); \n    vec4 cBr = vec4(0.0); \n    vec4 cBg = vec4(0.0); \n    vec4 cBb = vec4(0.0); \n    vec4 cC = vec4(0.0);\n    \n    cAr.x = -fC1*sh.sh3.x;\n    cAr.y = -fC1*sh.sh1.x;\n    cAr.z = fC1*sh.sh2.x;\n    cAr.w = fC0*sh.sh0.x - fC3*sh.sh6.x;\n    \n    cAg.x = -fC1*sh.sh3.y;\n    cAg.y = -fC1*sh.sh1.y;\n    cAg.z = fC1*sh.sh2.y;\n    cAg.w = fC0*sh.sh0.y - fC3*sh.sh6.y;  \n    \n    cAb.x = -fC1*sh.sh3.z;\n    cAb.y = -fC1*sh.sh1.z;\n    cAb.z = fC1*sh.sh2.z;\n    cAb.w = fC0*sh.sh0.z - fC3*sh.sh6.z;\n      \n    cBr.x = fC2*sh.sh4.x;\n    cBr.y = -fC2*sh.sh5.x;\n    cBr.z = 3.0*fC3*sh.sh6.x;\n    cBr.w = -fC2*sh.sh7.x;\n    \n    cBg.x = fC2*sh.sh4.y;\n    cBg.y = -fC2*sh.sh5.y;\n    cBg.z = 3.0*fC3*sh.sh6.y;\n    cBg.w = -fC2*sh.sh7.y;\n        \n    cBb.x = fC2*sh.sh4.z;\n    cBb.y = -fC2*sh.sh5.z;\n    cBb.z = 3.0*fC3*sh.sh6.z;\n    cBb.w = -fC2*sh.sh7.z;\n        \n    cC.x = fC4*sh.sh8.x;\n    cC.y = fC4*sh.sh8.y;\n    cC.z = fC4*sh.sh8.z;\n    cC.w = 1.0;\n    \n    // rendering\n    vec2 uv = (fragCoord.xy*2.0 - iResolution.xy) * inv_Reso.y;\n    vec3 screenPo = vec3(uv, 1.5);\n    vec3 cameraPo = vec3(0.0, 0.0, 0.0);\n    cameraPo.z -= 9.0;\n    screenPo.z -= 9.0;\n    float s = sin(iTime);\n    float c = cos(iTime);\n    cameraPo.xz = mat2(c,-s,s,c)*cameraPo.xz;\n    screenPo.xz = mat2(c,-s,s,c)*screenPo.xz;\n    vec3 ray = normalize(screenPo - cameraPo);\n\n    vec4 objPo = RayMatch(cameraPo, ray);\n    vec3 col = Render(objPo, normalize(cameraPo - screenPo),cAr,cAg,cAb,cBr,cBg,cBb,cC);\n        \n    // image\n    col += InterleavedGradientNoise(uv)/225.0;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2Xzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[870, 903, 930, 930, 945], [946, 946, 973, 973, 992], [993, 993, 1020, 1020, 1039], [1040, 1040, 1067, 1067, 1086], [1087, 1087, 1114, 1114, 1137], [1138, 1138, 1165, 1165, 1188], [1189, 1189, 1216, 1216, 1249], [1250, 1250, 1277, 1277, 1300], [1301, 1301, 1328, 1328, 1361], [1362, 1362, 1389, 1389, 1430], [1431, 1431, 1458, 1458, 1485], [1486, 1486, 1513, 1513, 1550], [1551, 1551, 1578, 1578, 1615], [1616, 1616, 1643, 1643, 1680], [1681, 1681, 1708, 1708, 1745], [1746, 1746, 1773, 1773, 1814], [1891, 1911, 1950, 1950, 1979], [1982, 1982, 2032, 2032, 2065], [2135, 2135, 2178, 2178, 2226], [2326, 2326, 2377, 2377, 2658], [2659, 2659, 2698, 2698, 2853], [2855, 2855, 2988, 2988, 3491], [3567, 3567, 3593, 3593, 4175], [4177, 4177, 4202, 4202, 4473], [4475, 4475, 4511, 4511, 4920], [4922, 4922, 5060, 5060, 5676], [5678, 5712, 5755, 5755, 5884], [5972, 5972, 6029, 6029, 8549]]}
{"id": "7tjXRt", "name": "Black Panther Tribute (Old)", "author": "chenglou", "description": "[b]New one at [url]https://www.shadertoy.com/view/sscGR8[/url][/b]\nBeat synced up to [url=https://youtu.be/Iuw8Lrg0Jyg]Black Panther's ending theme[/url]. Try that song!\nColor scheme inspired by the movie's tunnel fight\nMouse drag.", "tags": ["raytracing", "sdf", "scene"], "likes": 1, "viewed": 257, "published": 3, "date": "1628421082", "time_retrieved": "2024-07-30T19:07:10.560577", "image_code": "// Beat is synced to All The Stars: https://youtu.be/Iuw8Lrg0Jyg\n// New one at https://www.shadertoy.com/view/sscGR8\n\n#define MAX_DEPTH 3 // 2 reflection passes. 60fps on this machine\n\n#define PI 3.14159\n\n// utils from inigo\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opRep( in float p, in float s ) {\n    return mod(p+s*0.5,s)-s*0.5;\n}\nfloat expImpulse(float x, float k) {\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n// modified from mercury sdf\nvec3 pModPolarXY(vec3 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2. + p.z / 2.; // twist the tunnel\n\tfloat r = length(p.xy);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec3(cos(a) * r, sin(a) * r, p.z);\n}\n\nconst vec3 Killmonger = vec3(0.77, 0.62, 0.32);\nconst vec3 TChalla = vec3(0.72, 0.52, 0.99); // RIP\nconst vec3 Okoye = vec3(0.84, 0.53, 0.46);\n// All The Stars from Black Panther has a beat per minute of 97\nconst float secondPerBeat = 60. / 97.;\n// Beat's peak doesn't happen at time 0. Shift it to be so\n// This eases manually syncing with the music's beat if you press restart\nconst float beatOffset = 0.075;\n\nstruct material { vec3 attenuation; vec3 emission; float sdf; };\n\nmaterial map(vec3 p, float beat) {\n    // polar repeat & twist field\n    vec3 rotatedP = pModPolarXY(p, 8.); // 8 rail blocks\n    rotatedP.x += beat * 0.03 - 0.3; // periodic impulse, try in graphtoy\n    rotatedP.z = opRep(p.z - iTime / 2., 0.25); // z axis move & rail block repeat\n    \n    const vec3 halfSize = vec3(.015, .077, 0.11);\n    float dRailways = sdBox(rotatedP, halfSize);\n    float dLights = sdBox(rotatedP, halfSize + vec3(-0.01, 0.01, -0.01)) - 0.004; // rounder\n    float dOrb = sdSphere(p, 0.1);\n    \n    // colors\n    vec3 attenuation, emission;\n    if (dRailways > dLights || dRailways > dOrb) {\n        vec3 color = mod(iTime + beatOffset, secondPerBeat * 2.) > secondPerBeat ? TChalla : Killmonger;\n        attenuation = color;\n        emission = color * (0.7 + beat / 2.); // tune up emission when the beat's high\n    } else {\n        attenuation = Okoye;\n        emission = vec3(0);\n    }\n\n    return material(attenuation, emission, min(dRailways, min(dLights, dOrb)));\n}\n\nvec3 calcNormal( in vec3 p, float beat) {\n    float h = 1e-5;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h, beat).sdf + \n                      k.yyx*map( p + k.yyx*h, beat).sdf + \n                      k.yxy*map( p + k.yxy*h, beat).sdf + \n                      k.xxx*map( p + k.xxx*h, beat).sdf );\n}\n\nfloat maxT = 12.;\nbool rayMarch(vec3 ro, vec3 rd, float beat, out float t, out material m, out vec3 glow) {\n    t = 1e-3;\n    glow = vec3(1);\n    for(int i = 0; i < 85; i++) {\n        vec3 p = ro + t * rd;\n        m = map(p, beat);\n        float df = abs(m.sdf);\n        \n        if (df < 0.0007) return true;\n        if (t > maxT) return false;\n        \n        // add a physically incorrect glow when near an emissive material\n        const float glowDist = .05;\n        float diff = glowDist - df;\n        glow += m.emission * step(0., diff) * diff * 5.; // adjust 5 for glow strengh\n        \n        t += max(0.001, m.sdf);\n    }\n    return false;\n}\n\nvec3 rayTrace(vec3 ro, vec3 rd, float beat, vec2 seed) {\n    vec3 color = vec3(0);\n    // We want the emissive lights to also keep reflecting. See usage below\n    // This should be the correct way to calculate such light. I haven't seen\n    // it anywhere else (iteratively, on GLSL) so I had to derive the calculations.\n    vec3 accumulatedAttenuation = vec3(1);\n\n    vec3 ro_ = ro;\n    vec3 rd_ = rd;\n\n    const vec3 background = vec3(0.09, 0.09, .27);\n    const vec3 backgroundAttenuation = background * 0.1;\n    vec3 glow;\n\n    for (int depth = 0; depth < MAX_DEPTH; depth++) {\n        float t;\n        material m;\n        bool hit = rayMarch(ro_, rd_, beat, t, m, glow);\n\n        if (hit) {\n            vec3 pos = ro_ + rd_ * t;\n            vec3 normal = calcNormal(pos, beat);\n            vec3 reflected = reflect(rd_, normal);\n\n            color += accumulatedAttenuation * m.emission;\n            accumulatedAttenuation *= m.attenuation;\n\n            if (dot(reflected, normal) > 0.) {\n                ro_ = pos;\n                rd_ = reflected;\n            }\n        } else {\n            float gradient = rd_.y / iResolution.y * 500. + 0.5;\n            vec3 emission = background * gradient;\n            \n            color += accumulatedAttenuation * emission;\n            accumulatedAttenuation *= backgroundAttenuation;\n            color += accumulatedAttenuation;\n            \n            break;\n        }\n    }\n    color *= glow; // this isn't physically accurate but whatever\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (1. * fragCoord) / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n    // camera\n    vec3 ro;\n    if (length(iMouse.xy) == 0.) {\n        ro = smoothstep(0., 0.9, vec3(vec2(1) - iTime / 4., 1));\n    } else {\n        ro = vec3(-(2. * iMouse.xy - iResolution.xy) / iResolution.y, 1);\n    }\n    vec3 lookat = vec3(cos(iTime) / 10., sin(iTime) / 10., 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 50.;\n\n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(ro - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n\n    vec3 horizontal = viewport_width * u;\n    vec3 vertical = viewport_height * v;\n    vec3 lower_left_corner = ro - horizontal / 2. - vertical / 2. - w;\n\n    vec3 rd = normalize(lower_left_corner + uv.x * horizontal + uv.y * vertical - ro);\n\n    float beat = expImpulse(mod(iTime + beatOffset, secondPerBeat), 14.);\n    vec3 color = rayTrace(ro, rd, beat, uv);\n    \n    color = pow(color, vec3(1.0/2.2)); // gamma correction\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 225, 258, 258, 284], [285, 285, 314, 314, 401], [402, 402, 441, 441, 476], [477, 477, 513, 513, 559], [560, 589, 634, 634, 864], [1344, 1344, 1378, 1412, 2340], [2342, 2342, 2383, 2383, 2672], [2692, 2692, 2781, 2781, 3327], [3329, 3329, 3385, 3385, 4843], [4845, 4845, 4902, 4902, 6071]]}
{"id": "sljXDz", "name": "Cards & Mirrors", "author": "byt3_m3chanic", "description": "Was playing around with this over the past week but had some late night inspiration - Animated isometric truchet tile pattern, procedurally generated.", "tags": ["raymarching", "crt", "truchet", "isometric", "cards"], "likes": 42, "viewed": 897, "published": 3, "date": "1628410034", "time_retrieved": "2024-07-30T19:07:11.650662", "image_code": "/**                           _                                  \n                   _        _| |_          _                     \n     ___ ___ ___ _| |___   |   __|   _____|_|___ ___ ___ ___ ___ \n    |  _| .'|  _| . |_ -|  |   __|  |     | |  _|  _| . |  _|_ -|\n    |___|__,|_| |___|___|  |_   _|  |_|_|_|_|_| |_| |___|_| |___|\n                             |_|                                 \n                                                              \n    Cards and Mirrors \n    @byt3_m3chanic | 08/07/21\n\n    having some Isometric fun still and working with\n    a simple truchet tile pattern.\n\n    Shader in buffer tab/CRT effect in image tab\n\n    // thanks to //\n    \n    SDF shapes @iq\n    truchet and tile tricks @Shane\n    text @Fabrice\n    \n*/\n\n#define PI  3.14159265359\n\n// CRT effect adapted from online blog post. \n// https://babylonjs.medium.com/retro-crt-shader-a-post-processing-effect-study-1cb3f783afbc\n\nvec2 curvature = vec2(3.5,4.);\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.15);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.9, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.9, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n\n    // looks better when gamma is in buffer to me..\n    // but saved just in case\n    //baseColor.rgb=pow(baseColor.rgb, vec3(.4545));\n    //baseColor=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    \n    fragColor = baseColor;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .0001\n#define MAX_DIST 90.\n\n////////////////////////////////////////////////////////\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\n// text and font stuff\nint CAPS=0;\n#define spc  U.x-=.44;\n#define CR(c) spc O+= char(U,c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n// end text and font stuff\n////////////////////////////////////////////////////////\n\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234); }\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//@iq\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n//@iq\nfloat sdRBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n//@iq\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time=0.,tmod=0.,ga1,ga2,ga3,ga4;\n\nconst vec2 sc = vec2(.2), hsc = .5/sc; \nconst float amt = 6.;\nconst float dbl = amt*2.;\n\nvec2 map(vec3 p) {\n    p.xy+=vec2(time,3.5);\n    vec2 res = vec2(1e5,0);\n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/sc;\n    vec3 q = vec3(r.x,p.y,r.y);\n\n    float rnd = hash21(id);\n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n    if(rnd<.5) r.y *= -1.;\n    \n    vec2 d2 = vec2(length(r-hsc), length(r+hsc));  \n    float crv = abs(min(d2.x,d2.y)-hsc.x);\n\n    vec2 pp = d2.x<d2.y? vec2(r - hsc) : vec2(r + hsc);\n    pp *= rot(time*dir);\n    \n    float a = atan(pp.y, pp.x);\n    float ai = floor(dir*a/PI*dbl);\n    a = (floor(a/PI2*dbl) + .5)/dbl;\n    float ws = mod(ai,dbl);\n\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= hsc.x;\n\n    //moving blocks\n    vec3 npos = vec3(qr.x, p.y-1.5, qr.y);\n    float blox = box(npos,vec3(.65,.75,.01));\n    float blok = box(dir>0.?npos+vec3(0,0,.001):npos-vec3(0,0,.001),vec3(.65,.75,.01));\n    if(blox<res.x) {\n        res = vec2(blox,2.);\n        if(rnd<.5^^dir>0.) npos.x*=-1.;\n    \thit=npos;\n        gid=id;\n        gto=vec3(crv,ws,rnd);\n    }\n    if(blok<res.x) {\n        res = vec2(blok,5.);\n        //if(rnd<.5^^dir>0.) npos.x*=-1.;\n    \thit=npos;\n        gid=id;\n        gto=vec3(crv,ws,rnd);\n    }\n    //truchet track\n    vec3 tp = vec3(abs(crv)-.9,p.y,crv);\n    float bx = box(tp+vec3(0,.25,0), vec3(.2, .75,1.));\n    if(bx<res.x) {\n        res = vec2(bx, 3.);\n        hit=tp;\n        gid=id;\n        gto=vec3(crv,dir,rnd);\n    }\n    // floor\n    float d9 = p.y + .25;\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=p;\n        gid=id;\n        gto=vec3(crv,dir,rnd);\n    }\n\n    return res;\n}\n/**\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n*/\n// Tetrahedron technique @Shane\nvec3 normal(vec3 p, float t)\n{\n    const vec2 h = vec2(1.,-1.)*.5773;\n    vec3 n = vec3(0);\n    vec3[4] e4 = vec3[4](h.xyy, h.yyx, h.yxy, h.xxx);\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\t    n += e4[i]*map(p + e4[i]*t*MIN_DIST).x;\n        if(n.x>1e8) break; // Fake non-existing conditional break.\n    }\n    return normalize(n);\n}\n\nvec4 FC = vec4(0.961,0.718,0.718,0.);\n\nvec3 makeCard(vec3 p, float cardId)\n{\n    vec4 O;\n    vec3 h = vec3(1.);\n    float hs = hash21(vec2(cardId,8.));\n    \n    vec2 uv = p.xy+vec2(0,0);\n    \n    if(hs<.5){\n        float ht = sdHeart((uv*2.)+vec2(0,.65));\n        ht=smoothstep(.012,.01,ht);\n        h = mix(h,vec3(1,0,0),ht);\n    } else {\n        float ht = sdRhombus((uv*2.),vec2(.5,.75));\n        ht=smoothstep(.012,.01,ht);\n        h = mix(h,vec3(0,0,0),ht);\n    }\n    cardId=mod(cardId,9.);\n    float FontSize = .25;\n    vec2 U = p.xy/FontSize;\n    int ofs = 49;\n    U.xy-=vec2(.725,1.5);\n    CR(ofs+int(cardId));\n    U*=-1.;\n    U.xy-=vec2(1.925,3.);\n    CR(ofs+int(cardId));\n\n    float ck=smoothstep(.1,.7,O.x);\n    h = mix(h,(hs<.5)?vec3(1,0,0):vec3(0),ck);\n    \n    float cf = sdRBox(uv.xy,vec2(.575,.675),vec4(.01));\n    cf=abs(abs(cf)-.025)-.005;\n    vec2 pt = vec2(.415,.5);\n    float dts = min(length(uv.xy-pt)-.275,length(uv.xy+pt)-.275 ) ;\n    float pts = min(length(uv.xy-pt)-.175,length(uv.xy+pt)-.175 ) ;\n    pts=abs(abs(pts)-.025)-.005;\n    cf=max(cf,-dts);\n    \n    cf=min(cf,pts);\n    cf=smoothstep(.011,.01,cf);\n    h = mix(h,vec3(.1),cf);\n    \n    return h;\n}\nvec3 makeBack(vec3 p)\n{\n    vec3 h;\n    vec3 c = vec3(.59,0,0);\n    vec2 uv = p.xy*vec2(.55,.7);\n    float px = fwidth(R.x/PI);    \n    float cf = sdRBox(uv.xy,vec2(.3,.45),vec4(.01));\n    float pf=smoothstep(.01,.012,cf);\n    uv*=10.;\n    vec2 tuv = fract(uv)-.5;\n    vec2 tid = floor(uv);\n    float hs = hash21(tid);\n    if(hs>.5) tuv.x*=-1.;\n\n    vec2 d2 = vec2(length(tuv-.5), length(tuv+.5));\n    vec2 gx = d2.x<d2.y? vec2(tuv-.5) : vec2(tuv+.5);\n\n    float circle = length(gx)-.5;\n    circle=abs(circle)-.05;\n    circle=smoothstep(.03-px,px,circle);\n    \n    h = mix(h,vec3(1),circle);\n    h = mix(h,vec3(1),pf);\n    \n    cf=abs(abs(cf)-.001)-.005;\n    cf=smoothstep(.015,.012,cf);\n    h = mix(h,c,cf);\n    \n    return h;\n}\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    for(int i=0;i<175;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += ray.x * .75;\n        m  = ray.y;\n    } \n    hitPoint = hit;\n    sid = gid;\n    sto = gto;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(0,4,0);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.05; t < 16.; )\n        {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h * .95;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        vec3 h = vec3(.5);\n        \n        if(m==1.) {\n            hitPoint*=sc.xxx;\n\n            vec3 h = vec3(0.3);\n            vec2 y = fract(hitPoint.xz*12.)-.5;\n            vec2 yy = fract(hitPoint.xz*6.)-.5;\n            \n            if(yy.x*yy.y>0.)h=vec3(0.969,0.969,0.969);\n            \n            float curve2 = smoothstep(.011,.01,abs(abs(abs(sto.x-1.25)-.075)-.075)-.025);\n            float curve = smoothstep(.011,.01,abs(sto.x-1.25)-.3);\n            float ht = (yy.x*yy.y>0.) ? \n                sdHeart((y*2.)+vec2(.0,.5)) : sdRhombus((y*2.),vec2(.5,.75));\n    \n            ht=smoothstep(.012,.01,ht);\n            h = mix(h,(yy.x*yy.y>0.)?vec3(.05):vec3(.7,0,0),ht);\n     \n            float path = smoothstep(.011,.01,sto.x-1.);\n            h=mix(h,vec3(.73),path);\n            \n            \n            h=mix(h,vec3(.9),curve);\n            h=mix(h,vec3(.5,.0,.0),curve2);\n            \n            C+=diff*h;\n            ref = vec3(path*.35)-fresnel;\n        }\n        \n        if(m==2.) {\n            h=makeCard(hitPoint,sto.y);\n            C+=h*diff+spec;\n            ref = h-fresnel;\n        }\n        if(m==5.) {\n            h=makeBack(hitPoint);\n            C+=h*diff+spec;\n            ref = h-fresnel;\n        }\n        if(m==3.) {\n            h=vec3(.03);\n            C+=h*diff+spec;\n            ref = vec3(.075)-fresnel;\n        }\n\n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    \n    }\n    \n    C = mix(FC.rgb,C,  exp(-(1e-6)*d*d*d)); \n    return vec4(C,alpha);\n}\n\nfloat zoom = 9.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T*.25;\n    tmod = mod(time, 10.);\n    float t1 = lsp(4.0, 5.0, tmod);\n    float t2 = lsp(9.0, 10.0, tmod);\n    float t3 = lsp(1.0, 2.0, tmod);\n    float t4 = lsp(6.0, 7.0, tmod);\n    ga1 = ((t1-t2)*2.1)-1.1;\n    ga2 = (t3-t4)*45.;\n    //\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    if(uv.x>ga1) zoom *= .65;\n    \n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.xy == vec2(0) ? -45. : (M.x/R.x * 2. - 1.) * PI;\n    mat2 rx = rot(-0.78539816339);\n    mat2 ry = rot( (ga2*PI/180.));\n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0); \n    vec3 fil=vec3(1);\n    \n    float d =0.;\n    float numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce get fog distance as alpha\n        if(i==0.) FC = vec4(FC.rgb,exp(-(1e-5)*d*d*d));\n    }\n    \n    C = mix(C,FC.rgb,1.-FC.w);\n    if(uv.x+.002>ga1 && uv.x<ga1)C=vec3(1);\n    C = clamp(C,vec3(.02),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[956, 956, 979, 979, 1140], [1142, 1142, 1200, 1200, 1362], [1364, 1364, 1420, 1420, 1575], [1612, 1612, 1669, 1669, 2366]]}
{"id": "ftjSzd", "name": "bg removal experiment", "author": "elenzil", "description": "just capturing greyscale min/max to determine FG or BG.\ndoesn't work very well.\n\nclick anywhere, then you have one second to get out of the scene, then wait two seconds, then move back into the scene.\n\nI'll try again keying on Hue or Hue + Sat.", "tags": ["video"], "likes": 3, "viewed": 585, "published": 3, "date": "1628404624", "time_retrieved": "2024-07-30T19:07:12.412625", "image_code": "float sdCircle(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdAnnulis(in vec2 p, in float r1, in float r2) {\n    float P = length(p);\n    \n    return max(P - r2, r1 - P);\n}\n\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2 UV = XY / RES.xy;\n    \n    float zoom            = 0.95;\n    float worldFromScreen = 2.0 / min(RES.x, RES.y) / zoom;\n    vec2  p               = worldFromScreen * (XY - RES.xy * 0.5);\n    float smoothEps       = worldFromScreen * 1.5;\n\n    RGBA = texture(iChannel1, vec2(1.0 - UV.x, UV.y), 0.0);\n    \n    vec4 control = texelFetch(iChannel0, ivec2(0), 0);\n        \n    float secondsSinceMouseWasReleased = iTime - control.x;\n    float t = secondsSinceMouseWasReleased / clickDelaySeconds;\n    \n    if (t < 3.0) {\n        float theta = atan(p.y, p.x) / (2.0 * pi) + 0.5;\n        \n        float m = smoothstep(smoothEps, -smoothEps, sdAnnulis(p, 0.9, 1.0));\n        \n        if (t > 0.0) {\n            RGBA.r  = mix(RGBA.r , 1.0, smoothstep(-smoothEps, smoothEps, t - theta) * m);\n        }\n        if (t > 1.0) {\n            RGBA.rb = mix(RGBA.rb, vec2(1.0), smoothstep(-smoothEps, smoothEps, t - 1.0 - theta) * m);\n        }\n        if (t > 2.0) {\n            RGBA.rgb = mix(RGBA.rgb, vec3(1.0), smoothstep(-smoothEps, smoothEps, t - 2.0 - theta) * m);\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 RGBA, in vec2 XY)\n{\n    ivec2 IJ = ivec2(XY);\n\n    RGBA = texelFetch(iChannel0, IJ, 0);\n    \n    if (IJ == ivec2(0)) {\n        // x = iTime when released\n\n        bool isPressed = iMouse.z > 2.0;\n    \n        if (isPressed) {\n            RGBA.x = iTime;\n        }\n    }    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float clickDelaySeconds = 2.0;\nconst float pi                = 3.14159265359;\nconst float LOD               = 20.0;\n\n#define RES iResolution", "buffer_b_code": "// buffer B accumulates min and max values\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    vec4 me  = texture(iChannel1, XY/RES.xy, 0.0);\n    vec4 vid = texture(iChannel2, XY/RES.xy, 0.0);\n    float v = (vid.r + vid.g + vid.b) / 3.0;\n    \n    vec4 control = texelFetch(iChannel0, ivec2(0), 0);        \n    float secondsSinceMouseWasReleased = iTime - control.x;\n    float t = secondsSinceMouseWasReleased / clickDelaySeconds;\n    \n    if (t < 1.0) {\n        RGBA = vec4(1.0) * v;\n    }\n    else if (t < 3.0) {\n        RGBA.r = min(me.r, v);\n        RGBA.g = max(me.g, v);\n    }\n    else {\n        RGBA = me;\n    }\n    \n\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// buffer C threshholds incoming value against captured min/max\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    vec4 ref = texture(iChannel1, XY/RES.xy, LOD);\n    vec4 vid = texture(iChannel2, XY/RES.xy, LOD);\n    vec4 bg  = texture(iChannel3, XY/RES.xy, 0.0);\n    float v = (vid.r + vid.g + vid.b) / 3.0;\n\n    vec4 control = texelFetch(iChannel0, ivec2(0), 0);\n    float secondsSinceMouseWasReleased = iTime - control.x;\n    float t = secondsSinceMouseWasReleased / clickDelaySeconds;\n\n    if (t < 3.0) {\n        RGBA = vid;\n    }\n    else {\n    \n        float expandRangeFactor = 2.0;\n    \n        float refMid = (ref.y + ref.x) / 2.0;\n        vec2  refXpd = (ref.xy - refMid) * expandRangeFactor + refMid;\n    \n        bool withinRange = v >= refXpd.x && v <= refXpd.y;\n\n        if (withinRange) {\n            RGBA = bg;\n        }\n        else {\n            RGBA = texture(iChannel2, XY/RES.xy, 0.0);\n\n        }\n    }\n}", "buffer_c_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 67], [69, 69, 123, 123, 187], [191, 191, 234, 234, 1314]]}
{"id": "fljSzd", "name": "UI Test 3", "author": "yasuo", "description": "Mercedes MAPM", "tags": ["ui"], "likes": 15, "viewed": 351, "published": 3, "date": "1628400374", "time_retrieved": "2024-07-30T19:07:13.162620", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define S(p,d,b) smoothstep(fwidth(p.y),0.0,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define Slice(p,a) dot(p,vec2(cos(a),sin(a)))\n#define PURPLE vec3(0.8,0.6,0.9)\n#define GREEN vec3(0.1,0.8,0.6)\n\nfloat dLine(vec2 p, vec2 a, vec2 b, float w){\n    vec2 v = normalize(b-a);\n    vec2 right = normalize(cross(vec3(v,0.0),vec3(0.0,0.0,1.0)).xy);\n    vec2 newRightVec = right*(w*0.5);\n    vec2 a1 = a+newRightVec, a2 = a-newRightVec, b1 = b+newRightVec, b2 = b-newRightVec;\n    vec2 mida = vec2((a1.x + b1.x) * 0.5, (a1.y + b1.y) * 0.5);\n    vec2 midb = vec2((a2.x + b2.x) * 0.5, (a2.y + b2.y) * 0.5);\n    \n    float rad1 = -atan(b1.x-a1.x,b1.y-a1.y);\n    float rad2 = -atan(a2.x-a1.x,a2.y-a1.y);\n    \n    float mad = Slice(p-mida,rad1);\n    float mbd = Slice(p-midb,rad1);\n    \n    float ad = Slice(p-a,rad2);\n    float bd = Slice(p-b,rad2);\n    float d = max(max(mad,-mbd),max(-ad,bd));\n    return d;\n}\n\n// distance 2d digital alarm font\nconst float cDefault[7] = float[](0.,0.,0.,0.,0.,0.,0.);\nconst float c1[7] = float[](10.,0.,0.,10.,10.,10.,10.);\nconst float c2[7] = float[](0.,0.,10.,0.,0.,10.,0.);\nconst float c3[7] = float[](0.,0.,0.,0.,10.,10.,0.);\nconst float c4[7] = float[](10.,0.,0.,10.,10.,0.,0.);\nconst float c5[7] = float[](0.,10.,0.,0.,10.,0.,0.);\nconst float c6[7] = float[](0.,10.,0.,0.,0.,0.,0.);\nconst float c7[7] = float[](0.,0.,0.,10.,10.,10.,10.);\nconst float c8[7] = float[](0.,0.,0.,0.,0.,0.,0.);\nconst float c9[7] = float[](0.,0.,0.,0.,10.,0.,0.);\nconst float c0[7] = float[](0.,0.,0.,0.,0.,0.,10.);\nconst float cTBase[7] = float[](0.,10.,10.,10.,10.,10.,10.);\nconst float cKBase[7] = float[](10.,10.,0.,10.,0.,0.,0.);\nconst float cYBase[7] = float[](10.,0.,0.,0.,10.,0.,0.);\n\nconst vec2 digitVPos = vec2(0.08,0.073);\nconst vec2 digitHPos = vec2(0.0,0.15);\n\nfloat dDigitV(vec2 p){\n    float d = B(p,vec2(0.02,0.1));\n    p = abs(p);\n    p-=vec2(0.02,0.05);\n    d = max(Slice(p,44.775),d);\n    return d;\n}\n\nfloat dDigitH(vec2 p){\n    p*=Rot(radians(90.0));\n    float d = dDigitV(p);\n    return d;\n}\n\nfloat dDigitBase(vec2 p, float[7] char){\n    vec2 prevP = p;\n    float d = 10.0;\n    float d2 = 10.0;\n    // 1\n    d = (char[0])+dDigitH(p-digitHPos);\n    // 2\n    d2 = (char[1])+dDigitV(p-digitVPos);\n    d = min(d,d2);\n    // 3\n    d2 = (char[2])+dDigitV(p+vec2(-digitVPos.x,digitVPos.y));\n    d = min(d,d2);\n    // 4\n    d2 = (char[3])+dDigitH(p+digitHPos);\n    d = min(d,d2);\n    // 5\n    d2 = (char[4])+dDigitV(p+digitVPos);\n    d = min(d,d2);\n    // 6\n    d2 = (char[5])+dDigitV(p+vec2(digitVPos.x,-digitVPos.y));\n    d = min(d,d2);\n    // 7\n    d2 = (char[6])+dDigitH(p);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat dDigitNumber(vec2 p, int num){\n    float d = 100.0;\n    if(num == 0){\n        d = dDigitBase(p,c0);\n    } else if(num == 1){\n        d = dDigitBase(p,c1);\n    } else if(num == 2){\n        d = dDigitBase(p,c2);\n    } else if(num == 3){\n        d = dDigitBase(p,c3);\n    } else if(num == 4){\n        d = dDigitBase(p,c4);\n    } else if(num == 5){\n        d = dDigitBase(p,c5);\n    } else if(num == 6){\n        d = dDigitBase(p,c6);\n    } else if(num == 7){\n        d = dDigitBase(p,c7);\n    } else if(num == 8){\n        d = dDigitBase(p,c8);\n    } else if(num == 9){\n        d = dDigitBase(p,c9);\n    }\n    \n    return d;\n}\n\nfloat dDrawNumbers(vec2 p){\n    float t = iTime*7.0;\n\n    float d = dDigitNumber(p,int(mod(t*2.0,10.0)));\n    float d2 = dDigitNumber(p+vec2(0.22,0.0),int(mod(t*0.5,10.0)));\n    d = min(d,d2);\n    d2 = dDigitNumber(p+vec2(-0.22,0.0),int(mod(t,10.0)));\n    d = min(d,d2);\n    return d;\n}\n\n// noise function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nvec3 UIItem1(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p.x+=sin(3.0*p.y+iTime*0.5)*1.2*cos(-2.0*p.x+iTime*0.7)*0.3;\n    vec2 gv = fract(p*25.0);\n    \n    float thick = 0.1;\n    float d = B(gv,vec2(2.0,thick));\n    d = min(d,B(gv,vec2(thick,2.0)));\n    \n    p = prevP;\n    d = max((length(p)-0.38),d);\n    \n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    \n    float r = 5.0;\n    int index = 0;\n    for(float i = 0.02; i<=0.08; i+= 0.01){\n        vec2 pos = p-vec2(-0.35,-0.35);\n        pos *= Rot(radians(-iTime*r*10.0));\n        d = abs(length(pos)-(0.05+i))-0.001;\n        float a = radians(-15.*(i*100.0));\n        d = max(min(dot(pos,vec2(cos(a),sin(a))),dot(pos,vec2(cos(-a),sin(-a)))),d);\n        \n        vec3 lcol = (index%2 == 0)?PURPLE:GREEN;\n        col = mix(col,lcol,S(p,d,0.0));\n        r+=2.0;\n        index++;\n    }\n    \n    p = prevP;\n    \n    vec2 pos = p-vec2(-0.35,-0.35);\n    pos.y = abs(pos.y);\n    d = dLine(pos,vec2(-0.04,0.04),vec2(0.05,0.0),0.001);\n    float d2 = dLine(pos,vec2(-0.01,0.00),vec2(0.05,0.0),0.001);\n    d = min(d,d2);\n    d2 = dLine(pos,vec2(-0.04,0.04),vec2(-0.03,0.0),0.001);\n    d = min(d,d2);\n    d2 = dLine(pos,vec2(-0.04,0.04),vec2(-0.03,0.0),0.001);\n    d = min(d,d2);\n    d2 = dLine(pos,vec2(-0.04,0.04),vec2(-0.01,0.0),0.001);\n    d = min(d,d2);\n    \n    p = prevP;\n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    \n    d = abs(length(p-vec2(-0.42,0.3))-0.07)-0.01;\n    p = prevP;\n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    d = abs(length(p-vec2(-0.42,0.3))-0.07)-0.01;\n    \n    p-=vec2(-0.42,0.3);\n    p*=Rot(radians(iTime*30.0));\n    d = max(p.y,d);    \n    \n    p = prevP;\n    col = mix(col,GREEN,S(p,d,0.0)); \n    \n    d = abs(length(p-vec2(0.35,-0.4))-0.05)-0.01;\n    p = prevP;\n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    d = abs(length(p-vec2(0.35,-0.4))-0.05)-0.01;\n    \n    p-=vec2(0.35,-0.4);\n    p*=Rot(radians(-iTime*50.0));\n    d = max(p.y,d);    \n    \n    p = prevP;\n    col = mix(col,PURPLE,S(p,d,0.0));     \n    \n    return col;\n}\n\nvec3 UIItem2(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(-60.0));\n    float d = abs(length(p)-0.283)-0.02;\n    \n    float a = radians(30.0);\n    float a2 = radians(abs(sin(iTime*0.5)*150.0));\n    d = max(-min(dot(p,vec2(cos(a),sin(a))),-dot(p,vec2(cos(-a2),sin(-a2)))),d);    \n    \n    p = prevP;\n    col = mix(col,PURPLE,S(p,d,0.0));\n    \n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.2);\n    d = B(p*Rot(radians(45.0)),vec2(0.002,0.025));\n    \n    p = prevP;\n    p = DF(p,8.0);\n    p = abs(p);\n    p -= vec2(0.2);\n    float d2 = B(p*Rot(radians(45.0)),vec2(0.001,0.017));\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    a = radians(-50.0);\n    d = max(min(dot(p,vec2(cos(a),sin(a))),-dot(p,vec2(cos(-a),sin(-a)))),d);\n    d2 = abs(length(p)-0.283)-0.001;\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    \n    \n    d = abs(length(p)-0.169)-0.001;\n    d = max(-p.y-0.002,d);\n    col = mix(col,GREEN,S(p,d,0.0));\n    \n    \n    p = DF(p,4.0);\n    p = abs(p);\n    p -= vec2(0.13);\n    d = B(p*Rot(radians(45.0)),vec2(0.002,0.015));\n    \n    p = prevP;\n    p = DF(p,8.0);\n    p = abs(p);\n    p -= vec2(0.128);\n    d2 = B(p*Rot(radians(45.0)),vec2(0.001,0.012));\n    d = min(d,d2);\n    \n    p = prevP;\n    d = max(-p.y-0.002,d);\n    \n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.14);\n    d = B(p*Rot(radians(45.0)),vec2(0.005,0.002));\n    \n    p = prevP;\n    a = radians(-48.0);\n    d = max(-min(dot(p,vec2(cos(a),sin(a))),-dot(p,vec2(cos(-a),sin(-a)))),d);\n    \n    p = prevP;\n    col = mix(col,PURPLE,S(p,d,0.0));    \n    \n    p = prevP;\n    p = DF(p,16.0);\n    p = abs(p);\n    p -= vec2(0.14);\n    d = B(p*Rot(radians(45.0)),vec2(0.005,0.005));\n    \n    p = prevP;\n    a = radians(-48.0);\n    a2 = radians(2.0);\n    d = max(-min(dot(p,vec2(cos(a),sin(a))),-dot(p,vec2(cos(a2),sin(a2)))),d);\n    \n    p = prevP;\n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    \n    d = abs(length(p)-0.17)-0.002;\n    d = max(p.y+0.13,d);\n    col = mix(col,PURPLE,S(p,d,0.0));\n    \n    d = dDrawNumbers(p*3.5);\n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    \n    d = dDigitNumber((p-vec2(0.0,-0.13))*8.0,9);\n    col = mix(col,vec3(0.0),S(p,d,0.0));\n    \n    return col;\n}\n\nvec3 UIItem3(vec2 p, vec3 col){\n    vec2 prevP = p;\n    float d = length(p-vec2(0.15,0.0))-0.2;\n    p.x += iTime*0.1;\n    \n    float n = noise2d(p*73.0)*3.0;\n    \n    p = prevP;\n    col = mix(col,PURPLE*0.9,S(p,d,0.0));\n    col = mix(col,GREEN,S(p,max(d,d*n),0.0));\n    \n    d = length(p-vec2(-0.15,0.0))-0.2;\n    \n    p.x += iTime*0.12;\n    n = noise2d(p*75.0)*2.0;\n    p = prevP;\n    col = mix(col,GREEN*0.9,S(p,d,0.0));\n    col = mix(col,PURPLE,S(p,max(d,d*n),0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*=1.1;\n    vec3 col = vec3(1.0);\n    col = UIItem1(uv-vec2(0.4,0.05),col);    \n    col = UIItem2((uv-vec2(-0.52,-0.2))*1.1,col); \n    col = UIItem3((uv-vec2(-0.52,0.3))*1.3,col); \n    \n    // frame\n    float d = abs(B(uv,vec2(0.88,0.49)))-0.01;\n    float d2 = B(uv-vec2(-0.16,0.),vec2(0.01,1.0));\n    d = min(d,d2);\n    d2 = B(uv-vec2(-0.6,0.11),vec2(0.45,0.01));\n    d = min(d,d2);\n    col = mix(col,vec3(0.0),S(uv,d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljSzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 376, 421, 421, 1077], [1959, 1959, 1981, 1981, 2104], [2106, 2106, 2128, 2128, 2197], [2818, 2818, 2854, 2854, 3445], [3447, 3447, 3474, 3474, 3733], [3735, 3876, 3896, 3896, 4030], [4031, 4031, 4058, 4058, 4561], [4563, 4563, 4594, 4594, 6560], [6562, 6562, 6593, 6593, 8819], [8821, 8821, 8852, 8852, 9313], [9315, 9315, 9372, 9372, 9901]]}
{"id": "NlSXRd", "name": "practice on mutiplepass", "author": "jcyuan", "description": "simulate particle movement with a vectorfield", "tags": ["vectorfield", "mutiplepass"], "likes": 5, "viewed": 217, "published": 3, "date": "1628396174", "time_retrieved": "2024-07-30T19:07:13.934556", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 p = texture(iChannel0, uv);\n    float s = length(p.gb / SPEED * .5 + .5);\n    vec3 col = clamp(mix(vec3(5., 1., 0.), vec3(1., 1., 0.), s) * p.x, vec3(0), vec3(1));\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SPEED 2.6\n\n// hash functions author: https://www.shadertoy.com/view/4djSRW\n\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n", "buffer_a_code": "#define _TIME (iTime + 2000.)\n\nvec2 map_11(vec2 p) {\n    return p * 2. - 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 pos = texture(iChannel0, uv).rg;\n    vec2 vec = map_11(texture(iChannel1, uv * .13 * sin(_TIME * .03) + cos(-_TIME * .07) * .1).rg) * SPEED;\n    float pb = step(hash13(vec3(uv, iFrame)), .0001);\n    vec2 op = step(pos, vec2(0.));\n    \n    fragColor = vec4(mix(\n        pos + vec,\n        (fragCoord + map_11(hash21(_TIME))) * pb,\n        op)\n    , vec);\n}\n", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = vec4(0.);\n    \n    for (int i = -3; i <= 3; i++) {\n        for (int j = -3; j <= 3; j++) {\n            vec2 off = vec2(i, j) / iResolution.xy;\n            vec4 p = texture(iChannel0, uv + off);\n            vec2 v = step(abs(p.rg - fragCoord), vec2(.72));\n            if (v.x * v.y == 1.) {\n                fragColor = p;\n                break;\n            }\n        }\n    }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 v = texture(iChannel0, uv);\n    fragColor = vec4(mix(1., .96 * texture(iChannel1, uv).x, step(v.x, 0.)), v.ba, 1.);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 303]]}
{"id": "fl2SRd", "name": "Simple Wiggly Gradient", "author": "AngryKnees", "description": "It's a gradient that wiggles and shadertoy wants a description", "tags": ["colorgradient"], "likes": 1, "viewed": 209, "published": 3, "date": "1628394581", "time_retrieved": "2024-07-30T19:07:14.910945", "image_code": "const float TAU = 6.28318530718;\n\nconst vec3 color1 = vec3(0.035, 0.011, 0.149);\nconst vec3 color2 = vec3(0.141, 0.019, 0.137);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = mix(color1, color2, uv.x \n        + sin(uv.y * TAU + iTime) * 0.1\n        + sin(uv.y * TAU * 1.734 - iTime * 1.743) * 0.1\n        + sin(uv.y * TAU * 0.823 + iTime * 1.324) * 0.1\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2SRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 186, 236, 535]]}
{"id": "ftjSRd", "name": "Glowey Cubic Flower", "author": "scry", "description": "Same code as the previous cubes shader, playing with domain repetition and glow effects", "tags": ["3d"], "likes": 7, "viewed": 312, "published": 3, "date": "1628390511", "time_retrieved": "2024-07-30T19:07:15.808545", "image_code": "#define time iTime*0.6\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//from iqs sdf functions page\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n    //return primitive( q );\n}\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\n\nvec4 map(vec3 p) {\n    float pd = 1.;\n    //p.z += time*2.1;\n    vec3 o = p;\n    float c = length(p);\n    //p.xy *= r2d(sin(time*1.)+time);\n    //p.xz *= r2d(sin(time*1.+c*13.));\n    p.xy *= r2d(sin(c*50.+time)*0.2);\n    //p = (fract(p*pd)-0.5)/pd;\n    //float ramnt = clamp((sin(time*1.)),0.,1.);\n    float rt = time*0.5;\n    float ramnt = sin((3.14159/2.)*cos(rt)+rt);\n    ramnt -= 1.;\n    p.xz *= r2d(sin(c*0.5+time*0.3)*4.*ramnt);\n    p.yz *= r2d(cos(c*0.5+time*0.3)*4.*ramnt);\n    p.xy = vec2(length(p.xy),atan(p.x,p.y));\n    //p.y = abs(p.y);\n    //p.y *= 8./3.14159;\n    p.y *= 1./3.1415;\n    p.y *= (sin(time*0.13-2.)*0.5+0.5)*10.;\n    p.y *= 0.5;\n    p.y += p.z*sin(time);\n    p.y = (fract(p.y)-0.5);\n    p.y = abs(p.y);\n    p.xy = vec2(p.x*sin(p.y),p.x*cos(p.y));\n    p = opRepLim(p,0.21,vec3(1.));\n    p.xz *= r2d(sin(time*1.+c*13.));\n    p = opRepLim(p,0.018,vec3(2.));\n    p.xy *= r2d(sin(time*1.)+time);\n    p = opRepLim(p,mix(0.01,0.003,(sin(time*0.35+15.)*0.5+0.5)),vec3((0.5-c)*10.));\n\n    float d = length(p)+0.005*sin(time*0.1+c*5.);\n    return vec4(p,d);\n}\n\n\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    \n    for (int i=0;i<200;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS*0.5;\n        ii += 0.1;\n        if (dS < 0.001 || dO > 1000.) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1. + 2.* fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    float c = length(uv*0.9);\n    //uv *= r2d(c*4.+time);\n    //uv *= r2d(uv.y*time*.1-time*4.3);\n    vec3 ro = vec3(0.,0.,-0.5);\n    //ro.z += time*0.2;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    \n    //col = sin(uv.xyy*39.);\n    col = vec3((d.y*2.15)-0.3);\n    col = sin(d.yyy*0.1);\n    //col -= d.y*0.3;\n    vec3 hsv = vec3(\n    sin(sin(d.x)*40.)*0.3+time*0.1,\n    sin(d.x*300.)*0.5+0.5,\n    (d.y*0.1)\n    );\n    if (d.x > 100.) {\n        hsv.y *= 0.2;\n    }\n    col = hsv2rgb(hsv);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjSRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 42, 42, 91], [93, 123, 173, 173, 259], [260, 319, 341, 341, 672], [676, 735, 757, 757, 926], [998, 998, 1016, 1016, 2074], [2078, 2078, 2105, 2105, 2354], [2356, 2356, 2413, 2463, 3291]]}
{"id": "7lBSRK", "name": "Liquid planet", "author": "xjorma", "description": "Proof of concept, It's possible to make a physics simulation in a cube map. Works better than expected. :)\nUse the mouse to turn around.", "tags": ["simulation", "water", "planet", "cubemap", "drop", "feedback", "physics"], "likes": 24, "viewed": 772, "published": 3, "date": "1628376579", "time_retrieved": "2024-07-30T19:07:16.838791", "image_code": "// Created by David Gallardo - xjorma/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n\nconst vec3 lightPosition = vec3(0.,10.,2.);\n\nconst vec3 backgroundColor = vec3(0.4);\nconst vec3 waterColor = vec3(0,0,0.4);\nconst vec3 solidColor = vec3(1, 1, 0);\n\nconst float cref = 0.8;\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat mapWater(in vec3 p)\n{\n    float d = sdSphere(p, 1.0 + texture(iChannel0, p).x * 0.05);\n    return d;\n}\n\n\n#define NORMALFUNC(NAME, MAPFUNC, EPS)\t\t\t\t\t\t\t\t\\\nvec3 NAME(in vec3 p)\t\t\t\t\t\t\t\t    \t\t\t\\\n{                                                                   \\\n    const vec2 k = vec2(EPS,-EPS);\t\t\t\t                    \\\n    return normalize( k.xyy * MAPFUNC(p + k.xyy) + \t\t\t    \t\\\n                      k.yyx * MAPFUNC(p + k.yyx) + \t\t\t\t    \\\n                      k.yxy * MAPFUNC(p + k.yxy) + \t\t\t\t    \\\n                      k.xxx * MAPFUNC(p + k.xxx) );\t\t\t\t    \\\n}\n\n#define RAYMARCHFUNC(NAME, MAPFUNC, ITER, EPS)\t\t\t\t\t\t\\\nfloat NAME(in vec3 ro, in vec3 rd, in float dist)                   \\\n{                                                                   \\\n    float t = 0.0;                                                  \\\n    for( int i = 0; i < ITER; i++ )                                 \\\n    {                                                               \\\n        vec3\tp = ro + t*rd;                                      \\\n        float\th = MAPFUNC(p);                                     \\\n        if( abs(h) < 0.00001 || t > dist )                          \\\n            break;                                                  \\\n        t += h;                                                     \\\n    }                                                               \\\n    return t;                                                       \\\n}\n\nNORMALFUNC(calcNormalWater,mapWater, 0.02)\nRAYMARCHFUNC(raymarchWater,mapWater, 100, 0.00001)\n\nNORMALFUNC(calcNormalSolid,mapSolid, 0.0001)\nRAYMARCHFUNC(raymarchSolid,mapSolid, 100, 0.001)\t\n\nvec3 Render(vec3 ro,vec3 rd,vec3 cd,float dist)\n{\n    float tSolid = raymarchSolid(ro, rd, dist);\n    float tWater = raymarchWater(ro, rd, tSolid);\n    \n    vec3 col = backgroundColor;\n\n    if( min(tWater, tSolid) < dist )\n    {\n        if(tSolid < tWater)\n        {\n            // Solid first\n            vec3 p = ro + tSolid * rd;\n            vec3 n = calcNormalSolid(p);\n            vec3 v = normalize(ro-p);\n            vec3 l = normalize(lightPosition-p);\n            vec3 h = normalize(l+v);\n            col = solidColor * saturate(max(0.0, dot(n,l) * 0.7) + 0.3);\n        }\n        else\n        {\n            // Water first\n            vec3 p = ro + tWater * rd;\n            vec3 n = calcNormalWater(p);\n            vec3 refr = refract(rd, n, cref);\n            const float secondDist = 2.5;\n            float tWaterOut = raymarchWater(p + 1.5 * refr, -refr, secondDist);\n            float tSolidRefract = raymarchSolid(p, refr, secondDist);\n            float d = max(0.0, secondDist - tWaterOut);\n            if(tSolidRefract < secondDist)\n            {\n                vec3 p = p + tSolidRefract * refr;\n                vec3 n = calcNormalSolid(p);\n                vec3 v = normalize(ro-p);\n                vec3 l = normalize(lightPosition-p);\n                vec3 h = normalize(l+v);\n                col = solidColor * saturate(max(0.0, dot(n,l) * 0.7) + 0.3);\n                d = tSolidRefract;\n            }\n            \n            vec3 l = normalize(lightPosition-p);                  \n            col = applyFog( col, waterColor, d * 3.0);\n            float spec = length(texture(iChannel1, reflect(ro, n) * vec3(1,-1,1)).rgb);\n            col += 0.15 * spec * smoothstep(0.0, 0.1, dist);\n        }\n    }\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(Render(ro/3. + vec3(0.0,.0,4.0),rd ,rd,14.) ,1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initSolidTransfrom(iTime);\n\tvec3 tot = vec3(0.0);\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.*vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro ,rd ,ca[2], 4.0);\n\n\t    tot += col;\n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n\n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n\n\tfragColor = vec4( sqrt(tot), 1.0 );\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "vec3 minComponent(in vec3 v)\n{\n    v = abs(v);\n    if(v.x < v.y)\n    {\n        if(v.x < v.z)\n        {\n            return vec3(1, 0, 0);\n        }\n    }\n    else\n    {\n        if(v.y < v.z)\n        {\n            return vec3(0, 1, 0);\n        }\n    }\n    return vec3(0, 0, 1);\n}\n\n\nmat3 rotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    initSolidTransfrom(iTime);\n    \n    vec3 up = minComponent(rayDir);\n    vec3 right = normalize(cross(rayDir, up)) ;\n    right /= (iResolution.x * 0.5);\n   \n\n    mat3 rot = rotationMatrix(rayDir, radians( 360.0 / float(nbSample)));\n\n    vec2 center = texture(iChannel0, rayDir).xy;\n    \n    float sum = 0.0;   \n    for(int i = 0; i < nbSample; i++)\n    {\n        sum += texture(iChannel0, rayDir + right).x;\n        right = rot * right;\n    }\n    \n    float new = (sum * (2.0 / float(nbSample)) - center.y) * dampening; \n    \n    // Random point\n    if((iFrame % 3) == 0)\n    {\n        float d = dot(rayDir, randomPointOnSphere(float(iFrame)));\n        new -= d * smoothstep(0.998, 1.0, d) * 0.10; \n    }\n    // solid\n    float ds = mapSolid(rayDir);\n    new -= smoothstep(0.0, -0.05, ds) * 0.02;   \n\n    fragColor = vec4(vec2(new, center.x), 0 , 1);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n// Physics simulation parameters\nconst int nbSample = 6;\nconst float dampening = 0.985;\n\n\n\n// Hash by Dave Hoskins from https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Box SDF by IQ https://iquilezles.org/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Fog by IQ https://iquilezles.org/articles/fog\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n \nmat4 solidTransform;\n\nvoid initSolidTransfrom(float t)\n{\n    vec3 ang = vec3(sin(t * 1.2) * radians(20.), -0.2 * t, sin(t * 1.3) * radians(20.));\n    vec3 trans = vec3(sin(t * 0.23), sin(t * 0.25), sin(t * 0.24)) * 0.4;\n    \n    mat4 mt = mat4(\n\t\t\t1.0,\t\t0.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t1.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0,         0.0,\n\t\t\ttrans.x,\ttrans.y,\ttrans.z,     1.0 );\n        \n    mat4 mx = mat4(\n\t\t\t1.0,\t\t0.0,\t\t0.0,         0.0,\n\t\t\t0.0,\t\tcos(ang.x),\t-sin(ang.x), 0.0,\n\t\t\t0.0,\t\tsin(ang.x),\tcos(ang.x) , 0.0,\n\t\t\t0.0,\t\t0.0,\t\t0.0,         1.0 );\n    mat4 my = mat4(\n\t\t\tcos(ang.y), 0.0,\t\tsin(ang.y),  0.0,\n\t\t\t0.0,\t\t1.0,\t\t0.0,         0.0,\n\t\t\t-sin(ang.y),0.0,\t\tcos(ang.y), 0.0, \n\t\t\t0.0,\t\t0.0,\t\t0.0,         1.0 );\n    mat4 mz = mat4(\n\t\t\tcos(ang.z), -sin(ang.z),0.0,         0.0,\n\t\t\tsin(ang.z),\tcos(ang.z),\t0.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t1.0,         0.0,\n\t\t\t0.0,\t\t0.0,\t\t0.0,         1.0 );\n        \n    solidTransform = mt * mx * my * mz;\n}\n\nfloat mapSolid(vec3 p)\n{\n    float width = 0.2;\n    float length = 1.2;\n    p = vec3(solidTransform * vec4(p, 1));\n    return min(min(sdBox( p, vec3(length, width, width)), sdBox( p, vec3(0.2, length, width))) , sdBox( p, vec3(width, width, length)));\n}\n\nvec3 randomPointOnSphere(float key)\n{\n    vec2 rand = hash21(key);\n    float theta = radians(360.0) * rand.x;\n    float phi = acos(2.0 * rand.y - 1.0);\n    return vec3 (cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi));    \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBSRK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[315, 315, 340, 340, 369], [371, 420, 455, 455, 479], [482, 482, 509, 509, 590], [2138, 2138, 2187, 2187, 3875], [3877, 3877, 3955, 3955, 4027], [4029, 4029, 4071, 4071, 4235]]}
{"id": "stSXRd", "name": "Exponential", "author": "zxcvm", "description": "Exponential", "tags": ["exponential"], "likes": 2, "viewed": 306, "published": 3, "date": "1628357466", "time_retrieved": "2024-07-30T19:07:17.611724", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\tfloat coord = pow(uv.y * uv.y + uv.x, iTime);\n\t \n\tfragColor = vec4(tan(coord), sin(coord), cos(coord), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 203]]}
{"id": "flBXzd", "name": "Wave path tracing", "author": "michael0884", "description": "Basically computing the path integral for waves", "tags": ["waves", "green"], "likes": 39, "viewed": 924, "published": 3, "date": "1628339788", "time_retrieved": "2024-07-30T19:07:18.380668", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); \t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec4 res = texture(iChannel0, fragCoord/iResolution.xy);\n    vec2 wave = rot(-8.0*iTime)*res.xy/res.w;\n    \n    float ang = atan(wave.y, wave.x);\n    vec3 col = hsv2rgb(vec3(ang/TWO_PI, 0.9, 4.0*length(wave)));\n    fragColor = vec4(tanh(pow(2.0*col,vec3(0.75))),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float MAX_D = 8.0;\nconst int Diffraction_Order = 2;\n\nvec2 pix2world(vec2 p)\n{\n    return 10.0*(p - iResolution.xy*0.5)/iResolution.y;\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat scene(vec2 p)\n{\n    float de = 1e10;\n    //de = min(de, length(p) - 1.0);\n    de = min(de, sdHexagram(p + vec2(2.0, 0.0), 1.0));\n    de = min(de, sdMoon(p - vec2(3.0, 0.0), 1.0, 1.0, 0.8 ));\n    return de;\n}\n\nvec2 normal(vec2 p)\n{\n    vec2 dx = vec2(0,1)*1e-3;\n    return normalize(vec2(scene(p + dx.yx) - scene(p - dx.yx), scene(p + dx.xy) - scene(p - dx.xy))); \n}\n\nfloat trace(vec2 ro, vec2 rd, float maxd)\n{\n    float td = 0.0;\n    for(int i = 0; i < 256; i++)\n    {\n        float sd = scene(ro + rd*td);\n        \n        if(sd < 0.0) break;\n        \n        if(sd < td*0.001) \n        {\n            td -= sd*2.0;\n            break;\n        }\n        \n        td += sd;\n        if(td > maxd) break;\n    }\n    return td;\n}\n\n\nfloat importanceSampleD()\n{\n    float c = asinh(MAX_D);\n    return sinh(rand()*c);\n}\n\nfloat freq = 6.0;\n\nvec2 NEE_wave(vec2 p, float totd, float phi)\n{\n    vec2 ls = pix2world(iMouse.xy);\n    vec2 rd = normalize(ls - p);\n    float d0 =distance(ls,p);\n    float td = trace(p, rd, d0);\n    \n    return step(d0, td)*dir(phi + d0*freq)/(0.1 + totd+d0);\n}\n\nvec2 wavetrace(vec2 ro)\n{\n    vec2 rd = udir();\n    vec2 A = vec2(0.0);\n    float d = 0.0;\n    float phi = 0.0;\n    float prob = 1.0;\n    //A += NEE_wave(ro, d, phi);\n    for(int i = 0; i < Diffraction_Order; i++)\n    {\n        //diffraction\n        float td_diff = importanceSampleD();\n        //reflection\n        float td_refl = trace(ro, rd, MAX_D);\n        \n        float td;\n        if(td_diff < td_refl) //diffract\n        {\n            td = td_diff;\n            phi += freq*td; //we are already importance sampling by distance so add only phase\n            ro += rd*td;\n            prob /= PI;\n            rd = udir();  \n        }\n        else //reflect\n        {\n            td = td_refl;\n            \n            phi += freq*td + PI;\n            d += td;\n            \n            ro += rd*td;\n            vec2 N = normal(ro);\n            ro += N*0.002;\n            prob /= PI;\n            rd = normalize(udir() + N);  \n        }    \n        \n        if(td > MAX_D) break;\n    }\n    \n    A += NEE_wave(ro, d, phi)/prob;\n    \n    return A;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = pix2world(fragCoord + rand());\n\n    float sd = scene(p);\n    //freq = (rand()>0.5)?2.0:10.0;\n    \n    vec4 wave = vec4(0.0);\n    for(int i = 0; i < 10; i++)\n        wave += vec4(wavetrace(p).xyx,1.0);\n    \n    vec4 prev = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    if(iMouse.z > 0.0)\n        prev*= 0.9;\n    \n    // Output to screen\n    fragColor = prev + wave;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 nrand3(float sigma, vec3 mean)\n{\n\tvec4 Z = rand4();\n    return mean + sigma * sqrt(-2.0 * log(Z.xxy)) * \n           vec3(cos(TWO_PI * Z.z),sin(TWO_PI * Z.z),cos(TWO_PI * Z.w));\n}\n\n//uniformly spherically distributed\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\n\nvec2 dir(float a)\n{\n    return vec2(cos(a), sin(a));\n}\n\nmat2 rot(float a)\n{\n    vec2 d = dir(a);\n    return mat2(d.x, d.y, -d.y, d.x);\n}\n\nvec2 udir()\n{\n    float a = TWO_PI*rand();\n    return dir(a);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 185], [187, 187, 244, 268, 542]]}
{"id": "flSSRt", "name": "Cube patterns", "author": "scry", "description": "Just practicing\nThe title is a lie, there are no cubes here, just clever spheres", "tags": ["3d"], "likes": 7, "viewed": 428, "published": 3, "date": "1628295266", "time_retrieved": "2024-07-30T19:07:19.178536", "image_code": "#define time iTime\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n    //return primitive( q );\n}\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\n\nvec4 map(vec3 p) {\n    float pd = 9.;\n    //p.z += time*2.1;\n    p.z += 0.5;\n    float cs = length(p)-0.1;\n    p.z -= 0.5;\n    p.x += sin(time*0.3)*0.3;\n    p.z += sin(time*0.3)*0.4;\n    \n    p.xz *= r2d(sin(time*.05)*0.5);\n    p.yz *= r2d(cos(time*.07)*0.5);\n    //vec3 m = p;\n    vec3 o = p;\n    float c = length(p);\n    p = (fract(p*pd)-0.5)/pd;\n    p = abs(p);\n    \n    p.xz *= r2d(sin(time*.05)*20.5);\n    \n    p.yz *= r2d(cos(time*.07)*0.5);\n    \n    //float cs = length(p);\n    //p.xz *= r2d(sin(time*1.+c*13.));\n    //p.xy *= r2d(sin(c*20+time)*0.2);\n    //p = (fract(p*pd)-0.5)/pd;\n    //p.xz *= r2d(sin(log(c*3.)-time*0.3)*4.);\n    p.xy = vec2(length(p.xy),atan(p.x,p.y));\n    \n    //p.y = abs(p.y);\n    //p.y *= 8./3.14159;\n    //vec3 m = p;\n    p.y *= 4./(3.14159*2.);\n    p.y = (fract(p.y)-0.5);\n    p.y = abs(p.y)-sin(o.z*0.2);\n    \n    p.xy = vec2(p.x*sin(p.y),p.x*cos(p.y));\n    \n    p = opRepLim(p,0.21,vec3(1.));\n    p.xz *= r2d(sin(time*1.+c*13.));\n    p = opRepLim(p,0.06,vec3(2.));\n    p.xy *= r2d(sin(time*1.)+time);\n    vec3 m = p;\n    p = opRepLim(p,0.005,vec3((0.5-sin(c*5.5+time)*0.5)*10.));\n\n    float d = length(p)-0.001;\n    d = max(d,-(length(o.xy)-0.3+o.z*02.1));\n    d = max(d,-(cs));\n    return vec4(vec3(m.x,o.z,m.z),d);\n}\n\n\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    \n    for (int i=0;i<220;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS*0.5;\n        ii += 0.1;\n        if (dS < 0.001 || dO > 1000.) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.- 2.*fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    float c = length(uv*0.9);\n    //uv *= r2d(c*4.+time);\n    //uv *= r2d(uv.y*time*.1-time*4.3);\n    vec3 ro = vec3(0.,0.,-0.5);\n    //ro.z += time*0.2;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 pm = map(p).xyz;\n    //col = sin(uv.xyy*39.);\n    col = vec3((d.y*0.15)-0.3);\n    col = (1.-d.yyy*0.1);\n    //col -= d.y*0.3;\n    vec3 hsv = vec3(\n    sin(sin(pm.x*0.04+time*0.03)*4.)*2.+sin(pm.y*9.+pm.z*150.)*0.31,\n    sin(pm.z*300.)*0.5+0.5,\n    1.-d.y*0.1-d.x*0.4\n    );\n    if (d.x > 100.) {\n        //hsv.y *= 0.2;\n    }\n    col = hsv2rgb(hsv);\n    \n    fragColor = vec4(col,1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 38, 38, 87], [89, 89, 139, 139, 225], [226, 285, 307, 307, 638], [642, 701, 723, 723, 892], [964, 964, 982, 982, 2220], [2224, 2224, 2251, 2251, 2500], [2502, 2502, 2559, 2609, 3583]]}
{"id": "sl2XR3", "name": "Sharp Paper Cut", "author": "pyBlob", "description": "Definitely longer than the golf code, with better edges.", "tags": ["sharp", "ungolf"], "likes": 8, "viewed": 307, "published": 3, "date": "1628285363", "time_retrieved": "2024-07-30T19:07:19.929528", "image_code": "const float pi = acos(0.00000000);\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sign1(float x)\n{\n    return x < 0. ? -1. : 1.;\n}\n\nfloat smoothramp(float x, float size)\n{\n    return x < size ? .5 / size * x * x : x - .5 * size;\n}\n\nfloat wave(vec2 q)\n{\n    float r = length(q) / 8.;\n\n    float a = 0.;\n    //a += r;\n    a += smoothramp(r, 3.);\n    //a += (q.x + q.y) / 8.;\n    a += iTime;\n\n    return .6 * sin(a);\n}\n\nfloat exclude(float x, float w)\n{\n    return sign1(x) * max(w, abs(x));\n}\n\nvec3 paper(vec2 q)\n{\n    float height = 0.;\n\n    float w = 3.;\n    if (abs(q.y) < abs(q.x))\n        q.x = exclude(q.x, w);\n    else\n        q.y = exclude(q.y, w);\n\n    return vec3(q.x, height, q.y);\n}\n\nvec3 flap(vec2 q, vec2 Q)\n{\n    float qs = mod(Q.x + 4., 16.) < 8. ? q.x : -q.x;\n\n    float s;\n    //s = 12. * smoothstep(-3., 9., q.x);\n    //s = 12. * smoothstep(-3., 9., qs);\n    s = qs + 3.;\n\n    float height = wave(Q) * s;\n\n    float w = 3.;\n    q.x = clamp(q.x, -w, w);\n    q.y = clamp(q.y, -w, w);\n\n    return vec3(q.x, height, q.y);\n}\n\nvec3 M;\n\nfloat map(vec3 q)\n{\n    q.yz *= rot(.5 + 6. * M.y);\n    q.xz *= rot(2. - 6. * M.x);\n\n    // Also distorts wave sampling position. Only distorting\n    // cut position requires some more thoughts, As the closest-point\n    // queries have to be adapted to give a good enough sdf.\n    q.xz += .5*sin(q.zx/2.) + 2.*cos(q.zx/8.);\n\n    vec3 qq = q;\n    qq.xz = mod(qq.xz+4., 8.) - 4.;\n    \n    vec3 x_paper = paper(qq.xz);\n    float t_paper = length(x_paper - qq);\n\n    vec3 x_flap1 = flap(qq.xz, q.xz);\n    float t_flap1 = length(x_flap1 - qq);\n\n    float t = 9.;\n    t = min(t, t_flap1);\n    t = min(t, t_paper);\n    t -= .05;\n\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{    \n    vec3 R = iResolution;\n    vec3 D = normalize(vec3(2. * U, -3.5 * R.y) - R);\n    vec3 p = 90. / R;\n\n    //M =  iMouse.xyz/R -.5;\n    M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n\n    float tsum = 0.;\n    for (int i=0 ; i<100 ; ++i)\n    {\n        vec3 q = p + tsum * D;\n        float t = 9.;\n        t = min(t, map(q));\n        t = min(t, map(q + .5*t*D));\n\n        tsum += t;\n        //p += t * D;\n    }\n\n    vec3 q = p + tsum * D;\n    float eps = 2e-2;\n    float dx = map(q + vec3(eps, 0, 0)) - map(q);\n    float dy = map(q + vec3(0, eps, 0)) - map(q);\n    float dz = map(q + vec3(0, 0, eps)) - map(q);\n    vec3 normal = normalize(vec3(dx, dy, dz));\n    float light = dot(normal, -D);\n    float fog = smoothstep(300., 0., tsum - 50.);\n    O = vec4(1.5 * light * fog);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2XR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 55, 55, 131], [133, 133, 155, 155, 187], [189, 189, 228, 228, 287], [289, 289, 309, 309, 472], [474, 474, 507, 507, 547], [549, 549, 569, 569, 749], [751, 751, 778, 778, 1093], [1104, 1104, 1123, 1123, 1742], [1744, 1744, 1780, 1780, 2592]]}
{"id": "7t2Szc", "name": "Orange Glow", "author": "user_name", "description": "I don't like my code. :)", "tags": ["procedural", "2d", "noise"], "likes": 8, "viewed": 336, "published": 3, "date": "1628284169", "time_retrieved": "2024-07-30T19:07:20.684508", "image_code": "float n(vec2 v) {\nreturn fract(cos(dot(v, vec2(3.12394978, 6.24381234))) * 203489.1234);\n}\nfloat snap(float a, float b){\n    return floor(a / b) * b;\n}\nfloat n2(vec2 v){\nv.y=snap(v.y,1.0);\nfloat a=n(vec2(v.x,v.y));\nfloat b=n(vec2(v.x,v.y+1.0));\nreturn mix(a,b,v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = fragCoord/iResolution.x;\n    vec2 uv3 = fragCoord/iResolution.x;\n    uv3.y += iTime * 0.1 * (n(vec2(snap(uv2.x, 0.02), 0.0)) * 0.5 + 0.5);\n    uv3.y+=n2(vec2(snap(uv3.x,0.02),uv3.y/0.015))*0.04;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    float dith = length(vec2(snap(uv.x, 0.02), snap(uv.y, 0.04 * iResolution.x / iResolution.y)) - 0.5);\n    float mid = n(vec2(snap(uv2.x, 0.02), snap(uv2.y, 0.02)))*0.2+0.4;\n    mid -= 2.0;\n    mid += dith * 3.0;\n    mid += length(uv - 0.5) * 1.0 - 0.2;\n    uv3.y += n(vec2(snap(uv3.x, 0.02), 0.0));\n    float mad = n(vec2(snap(uv3.x, 0.02), snap(uv3.y, 0.06)));\n    float fac=fract(uv.x/0.02);\n    fac=smoothstep(0.0,0.1,fac)*smoothstep(1.0,0.9,fac);\n    float fac2=fract(uv3.y/0.06);\n    fac*=smoothstep(0.0,0.05,fac2)*smoothstep(1.0,0.95,fac2);\n    float gry=smoothstep(mid+0.01,mid,mad)*fac + pow(length(uv - 0.5),2.0);\n    fragColor = vec4(vec3(gry)*vec3(1.2,0.55,0.2),1.0);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2Szc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 90], [91, 91, 120, 120, 151], [152, 152, 169, 169, 267], [269, 269, 326, 376, 1425]]}
{"id": "7tjSR3", "name": "Mondrian pong (314 ch)", "author": "FabriceNeyret2", "description": " golfing 548 chars https://shadertoy.com/view/Xdy3Wh\nreproducing http://33.media.tumblr.com/tumblr_mafojfoHoJ1rvbw2yo1_400.gif \n", "tags": ["pong", "gif", "mondrian", "short", "golf", "reproduction"], "likes": 17, "viewed": 333, "published": 3, "date": "1628257737", "time_retrieved": "2024-07-30T19:07:21.444476", "image_code": "// golfing  548 chars  https://shadertoy.com/view/Xdy3Wh\n// reproducing http://33.media.tumblr.com/tumblr_mafojfoHoJ1rvbw2yo1_400.gif\n\n// coyote : -22 chars Fab -3 ( more readable version below :-) )\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy, L, B, P;\n    U = 1e2*( U+U - R ) / R.y;\n    \n    B = mod(iTime/vec2(1,2),2.); B = .5-min(B,2.-B); // ball trajectory\n    P = vec2(80, 70.*B.y);                           // pad trajectory\n\n#define A  min(L=abs(P-U//\n#define M  ,L.y ).x > 1. ? O : O//\n//     reading hint: A[...]M\n#define D  ; P = -P; A +R) M --; \\\n                     A -R) M --; \\\n                max(A )/(R-1.),L) M = C\n\n    vec4 C = vec4(9,0,0,1);\n    O -= O-1.;                              // background ( O = 1.-O bugs on old Macs )\n    R = vec2(16,46)\n    D                                       // left pad\n    D.zzxw;                                 // right pad\n    R.y = 13.; P = 1e2*B\n    D.xxzw;                                 // ball\n}\n\n\n\n\n\n/* // --- 339 chars\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    vec2 R = iResolution.xy, L, B, P;\n\tU = 1e2* ( U+U - R ) / R.y;\n    \n    B = mod(iTime/vec2(1,2),2.); B = min(B,2.-B)-.5; // ball trajectory\n    P = vec2(-80, 70.*B.y);                          // pad trajectory\n    \n#define L(P)    L = abs(P-U);   min(L.x,L.y) > 1. ? O : O--;   //\n#define D(P,h)  R = vec2(15,h),                                 \\\n                L( P+R+1. ) L( P-R-1. )                         \\\n                L = abs(P-U)/R; max(L.x,L.y) > 1. ? O : O =\n                \n    vec4 C = vec4(9,0,0,1);          \n    O -= O-1.;                                       // background ( O = 1.-O bugs on old Macs )\n    D(   P  , 45 ) C;                                // left pad\n    D(  -P  , 45 ) C.zzxw;                           // right pad\n    D( 1e2*B, 12 ) C.xxzw;                           // ball\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "Nl2Xz3", "name": "cheese_circle2", "author": "lokichen", "description": "circle", "tags": ["circle"], "likes": 0, "viewed": 218, "published": 3, "date": "1628239314", "time_retrieved": "2024-07-30T19:07:22.256306", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float d = length(uv);\n    \n    fragColor = vec4(vec3(d), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2Xz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 170]]}
{"id": "fl2Sz3", "name": "Desert Postcard 2", "author": "dr2", "description": "Updated: wobbly blob in a (pseudo-)Nabatean treasury, with some dynamic trompe-l'oeil (mousing recommended)", "tags": ["reflection", "illusion", "archaeology", "petra"], "likes": 15, "viewed": 310, "published": 3, "date": "1628237659", "time_retrieved": "2024-07-30T19:07:23.311484", "image_code": "// \"Desert Postcard 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 bSize, sunDir, vnBlk;\nvec2 blbRad;\nfloat tCur, dstFar, pcUp;\nint idObj;\nbool isSh;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nvec3 SMap (vec3 p, float t)\n{\n  float f;\n  f = 2.;\n  for (int k = 0; k < 5; k ++) {\n    p += 0.4 * sin (1.7 * p.yzx / f + f * t);\n    f *= 0.8;\n  }\n  return p;\n}\n\nfloat BlobDf (vec3 p)\n{\n  vec3 q;\n  float d, t;\n  t = tCur + 1.31;\n  q = p;\n  q.xz = Rot2D (q.xz, 0.2 * t);\n  d = SmoothMin (PrBoxDf (SMap (q - vec3 (0.7, 0., 0.), t + 2.), vec3 (blbRad.x)),\n     PrBoxDf (SMap (q - vec3 (-0.7, 0., 0.), 1.3 * t), vec3 (blbRad.y)), 0.2);\n  return d * (isSh ? 1. : 0.25);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 cs, b, s;\n  float dMin, d, g, w;\n  dMin = dstFar;\n  cs = sin (pi / 16. + vec2 (0., 0.5 * pi));\n  w = 0.06;\n  p.y -= pcUp;\n  q = p;\n  q.y -= 7.5;\n  g = dot (vec2 (abs (q.x), q.y), cs);\n  d = min (max (min (abs (g) - w, 0.), - q.y - 0.7),\n     max (min (abs (q.y + 0.725) - w, 0.), g - w));\n  q.y -= -0.25;\n  g = dot (vec2 (abs (q.x), q.y), cs);\n  b = vec2 (4., 3);\n  q = p;\n  q.y -= 3.5;\n  s = abs (q.xy) - b;\n  d = min (d, min (max  (min (s.y - w, 0.), min (abs (s.x) - w, 0.)),\n     max  (min (s.x - w, 0.), min (abs (s.y) - w, 0.))));\n  q = p;\n  q.yz -= vec2 (4., bSize.z);\n  d = max (PrBoxDf (q - vec3 (0., 0., -0.2), bSize), - d);\n  q.y -= -0.5;\n  d = max (d, - PrBox2Df (q.xy, b - 3. * w));\n  q.y -= -2.7;\n  d = max (d, - PrCylDf (q.xzy, 3., 0.3));\n  DMIN (1);\n  q = p;\n  q.y -= 4.;\n  d = PrBoxDf (q, vec3 (bSize.xy, 0.1));\n  q.y -= -0.5;\n  d = max (d, - PrBox2Df (q.xy, b - 3. * w + 0.05));\n  DMIN (2);\n  q = p;\n  q.y -= 3.5;\n  g = abs (q.x) - b.x;\n  q.xz = vec2 (mod (q.x + 0.75, 1.5) - 0.75, abs (q.z - bSize.z) - bSize.z + 0.3);\n  d = PrCylDf (q.xzy, 0.2, b.y - 4. * w);\n  q.y = abs (q.y) - b.y + 4. * w;\n  d = max (min (d, PrCylDf (q.xzy, 0.275, w)), g);\n  DMIN (3);  \n  q = p;\n  q.yz -= vec2 (3., bSize.z);\n  if (! isSh) d = PrBoxDf (q, vec3 (b - 3. * w, bSize.z)) + 0.1;\n  if (isSh || d < dMin) {\n    d = BlobDf (q);\n    DMIN (4);\n    q.y -= -2.75;\n    d = PrCylDf (q.xzy, 3., 0.3);\n    DMIN (5);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 180; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.01, -0.01);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float d;\n  p.y -= bSize.y + pcUp;\n  p.z -= -0.1;\n  q = p;\n  d = PrBoxDf (q, vec3 (bSize.xy, 0.1));\n  q.xy -= bSize.xy * vec2 (-0.8, 0.6);\n  d = max (d, - PrBox2Df (q.xy, vec2 (1.)));\n  return d;\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BlkHit (vec3 ro, vec3 rd, vec3 sz)\n{\n  vec3 v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = sz / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi) * vec2 (0.5, 1.);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi) * vec2 (0.5, 1.);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return 1.2 * mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec3 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  e = vec2 (0.002, 0.);\n  h = RippleHt (p);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vn;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.4, 0.5, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col * vec3 (1., 0.8, 0.8);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, rob, roo;\n  vec2 vf, s;\n  float dstObj, dstGrnd, db, sh, f, y, sb;\n  bool isBg;\n  isBg = true;\n  sh = 1.;\n  roo = ro;\n  db = BlkHit (ro + vec3 (0., - bSize.y - pcUp, 0.1), rd, vec3 (bSize.xy, 0.05));\n  if (db < dstFar) {\n    rob = ro + db * rd;\n    vf = vec2 (0.);\n    sb = Maxv2 (abs (vec2 (rob.x, rob.y - bSize.y - pcUp)) - bSize.xy);\n    if (rob.z < -0.1 && sb < -0.2) {\n      blbRad = vec2 (1.1 + 0.31 * sin (tCur + 1.31), 1. + 0.41 * sin (1.7 * (tCur + 1.31)));\n      isSh = false;\n      dstObj = ObjRay (ro, rd);\n      if (dstObj < dstFar && idObj == 5) {\n        ro += dstObj * rd;\n        rd = reflect (rd, vec3 (0., 1., 0.));\n        ro += 0.01 * rd;\n        dstObj = ObjRay (ro, rd);\n      }\n      if (dstObj < dstFar) {\n        ro += dstObj * rd;\n        if (idObj != 4) vn = ObjNf (ro);\n        else {\n          vn4 = ObjNfL (ro);\n          vn = vn4.xyz;\n        }\n        y = ro.y - pcUp;\n        if (idObj == 1) {\n          if (vn.y > 0.99 && length (ro.xz - vec2 (0., bSize.z)) < 3.) {\n            col4 = vec4 (0.95, 0.95, 1., 0.3);\n          } else {\n            col4 = vec4 (0.6, 0.4, 0.3, 0.05) * (0.7 + 0.3 * Fbm2 (vec2 (ro.x, y) * vec2 (1., 32.)));\n            if (vn.z < -0.99) vf = vec2 (8., 1.);\n            else vf = vec2 (16., 1.);\n          }\n        } else if (idObj == 2) {\n          col4 = vec4 (0.5, 0.4, 0.3, 0.1);\n        } else if (idObj == 3) {\n          col4 = vec4 (0.6, 0.4, 0.2, 0.2) * (1. -\n             0.5 * smoothstep (0.45, 0.5, abs (mod (3. * y + 0.5, 1.) - 0.5)));\n          s = vec2 (mod (ro.x + 0.75, 1.5) - 0.75, abs (ro.z - bSize.z) - bSize.z + 0.3);\n          vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * (0.5 -\n             mod (12. * (atan (s.x, s.y) / (2. * pi) + 0.5), 1.))));\n        } else if (idObj == 4) {\n          col4 = vec4 (vec3 (0.95, 0.95, 1.) * (1. - step (8., vn4.w)), 0.3);\n        }\n        if (vf.x > 0.) vn = VaryNf (vf.x * vec3 (ro.x, y, ro.z), vn, vf.y);\n        isSh = true;\n        isBg = false;\n      } else if (rd.y < 0.) {\n        dstGrnd = - ro.y / rd.y;\n        ro += dstGrnd * rd;\n        isSh = true;\n      }\n      sh = isSh ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      if (! isBg) col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      else if (isSh) ro -= dstGrnd * rd;\n    } else {\n      ro = rob;\n      vn = vnBlk;\n      col4 = vec4 (0.85, 0.85, 0.8, 0.1);\n      vf = vec2 (64., 0.5);\n      if (rob.z < -0.1) {\n        if (sb < -0.2) col4 *= 0.5;\n        isBg = false;\n      } else {\n        vn.z *= -1.;\n        f = 0.;\n        rob.y -= bSize.y + pcUp;\n        if (abs (rob.y) < bSize.y - 0.5) f = abs (rob.x);\n        if (abs (rob.x + 0.5 * bSize.x) < 0.5 * bSize.x - 1.) \n           f = abs (abs (rob.y + 0.3 * bSize.y) - 0.5);\n        s = abs (vec2 (rob.xy) - bSize.xy * vec2 (-0.8, 0.6)) - 0.8;\n        if (Maxv2 (s) < 0.02) f = Minv2 (abs (s));\n        if (f > 0.) col4 *= 0.5 + 0.5 * smoothstep (0.02, 0.04, f);\n        isBg = false;\n        if (max (s.x, s.y) < -0.02) {\n          isBg = true;\n          ro = roo;\n        }\n      }\n      if (! isBg) {\n        vn = VaryNf (vf.x * ro, vn, vf.y);\n        col = col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n           col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      }\n    }\n    col *= vec3 (1., 0.9, 0.9);\n  }\n  if (isBg) {\n    ro = roo;\n    if (rd.y < 0.) {\n      dstGrnd = - ro.y / rd.y;\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      f = 1. - smoothstep (0.3, 0.6, dstGrnd / dstFar);\n      if (f > 0.) vn = VaryNf (4. * ro, RippleNorm (ro.xz, vn, 4. * f), f);\n      if (sh == 1.) sh = ExObjSShadow (ro + 0.01 * vn, sunDir);\n      col = mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.5), 0.2 +\n         0.6 * smoothstep (0.7, 1.1, 2. * Fbm2 (2. * ro.xz)));\n      col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n      col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.)) * vec3 (1., 0.8, 0.8);\n    } else col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.015 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= pi * mPtr.y;\n  } else {\n    az = 0.8 * pi * (2. * mod (floor (0.05 * tCur), 2.) - 1.) *\n       SmoothBump (0.3, 0.7, 0.15, mod (0.05 * tCur, 1.));\n  }\n  el = clamp (el, -0.4 * pi, 0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  bSize = vec3 (7., 4., 3.75);\n  pcUp = 0.3 * bSize.y * SmoothBump (0.25, 0.75, 0.2, mod (0.1 * tCur, 1.));\n  ro = vuMat * vec3 (0., 4.5, -27.);\n  zmFac = 4.5;\n  dstFar = 100.;\n  sunDir = normalize (vec3 (0., 0., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.2 * pi * sin (0.05 * 2. * pi * tCur));\n  sunDir.yz = Rot2D (sunDir.yz, pi * (0.17 + 0.07 * sin (0.03 * 2. * pi * tCur)));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2Sz3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[823, 823, 852, 852, 984], [986, 986, 1009, 1009, 1290], [1292, 1292, 1314, 1314, 2788], [2790, 2790, 2823, 2823, 3007], [3009, 3009, 3030, 3030, 3285], [3287, 3287, 3309, 3309, 3636], [3638, 3638, 3675, 3675, 3904], [3906, 3906, 3930, 3930, 4139], [4141, 4141, 4180, 4180, 4411], [4413, 4413, 4455, 4455, 4742], [4744, 4744, 4769, 4769, 5188], [5190, 5190, 5234, 5234, 5423], [5425, 5425, 5459, 5459, 6055], [6057, 6057, 6092, 6092, 10209], [10211, 10211, 10267, 10267, 11662], [11664, 11664, 11696, 11696, 11796], [11798, 11798, 11831, 11831, 11920], [11922, 11922, 11964, 11964, 12015], [12017, 12017, 12039, 12039, 12066], [12068, 12068, 12090, 12090, 12117], [12119, 12119, 12141, 12141, 12179], [12181, 12181, 12203, 12203, 12241], [12243, 12243, 12288, 12288, 12380], [12382, 12382, 12439, 12439, 12522], [12524, 12524, 12560, 12560, 12766], [12768, 12768, 12798, 12798, 12911], [12945, 12945, 12969, 12969, 13022], [13024, 13024, 13048, 13048, 13178], [13180, 13180, 13205, 13205, 13351], [13353, 13353, 13378, 13378, 13564], [13566, 13566, 13588, 13588, 13742], [13744, 13744, 13765, 13765, 13920], [13922, 13922, 13951, 13951, 14163], [14165, 14165, 14204, 14204, 14461]]}
{"id": "Nl2SRK", "name": "venetian blinds", "author": "NakedBowman", "description": "Venetian Blinds Effect, this is a working ground for something else, I thought it  might be useful for someone else...", "tags": ["lines", "venetian", "blinds"], "likes": 2, "viewed": 268, "published": 3, "date": "1628235732", "time_retrieved": "2024-07-30T19:07:24.219058", "image_code": "mat2 rot(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n         \n    vec2 uv = fragCoord/iResolution.xy;\n       vec2 st = uv;\n     uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 center = vec2(0.5+.47,0.5);\n    uv-=center;            \n    uv *= rot(iTime*0.5);\n    \n    vec4 text = texture(iChannel0, st);\n   \n    //Get controls\n    float r = iMouse.y/iResolution.y;\n    float v = iMouse.x/iResolution.x;\n    r = clamp(r, 0.,0.249);\n    v = clamp(v, 0.249,1.);\n    uv*=20.; //Change count here\n    uv = fract(uv);\n \n    float blind = smoothstep(v+r,v+0.5-r,uv.x) - 1. + smoothstep(1.-r-v,.5+r-v,uv.x);  \n    text = text -1. *-blind;\n \n\n\n    fragColor = vec4(text);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2SRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 100], [103, 103, 160, 160, 781]]}
{"id": "7tSXzc", "name": "Spiral RGB shift", "author": "python273", "description": "---", "tags": ["spiral"], "likes": 11, "viewed": 428, "published": 3, "date": "1628226092", "time_retrieved": "2024-07-30T19:07:24.969053", "image_code": "#define PI 3.1415926535897932384626433832795\n#define half_PI 1.570796326794896619231321692\n\nfloat max_dist = length(vec2(.5));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    float l = length(uv) / max_dist;\n\n    float a = (1.0 + atan(uv.y, uv.x) / PI) / 2.0;\n\n    //a = fract(a + cos(l) / 5.0 + iTime / 60.0);\n    a = fract(a + l / 1.0 - iTime / 30.0);\n    \n    float val;\n    //val = smoothstep(0.0, 1.0, abs(2.*fract(a * 5.0)-1.));\n    //val = smoothstep(1., abs(2.*fract(a * 5.0)-1.), l * 1.5);\n    val = smoothstep(1.0, sin(a * PI * 10.0) / PI, l * 1.4);\n\n    //fragColor = vec4(vec3(val), 1.0);\n    \n    float val1 = smoothstep(1.0, sin(a * PI * 10.0 + 1.1) / PI, l * 1.5);\n    float val2 = smoothstep(1.0, sin(a * PI * 10.0 + 2.2) / PI, l * 1.5);\n\n    fragColor = vec4(val, val1, val2, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 185, 185, 895]]}
{"id": "NtjSzG", "name": "Stone Heaven", "author": "Plento", "description": "Where stones and pebbles alike go when they die. A variation of my last shader.", "tags": ["3d", "mouse", "mouse", "raymarch", "beach"], "likes": 26, "viewed": 630, "published": 3, "date": "1628221635", "time_retrieved": "2024-07-30T19:07:25.729021", "image_code": "\n// By Cole Peterson\n\n// Where stones and pebbles alike go when they die.\n\n// ....I guess rock really is dead. :(\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\nmat2 rot(float a) {return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nfloat map(vec3 rp){\n    float h = 0.5 - texture(iChannel1, rp.xz*.8).x * .065;\n    return min(rp.y + .49, rp.y + h);\n}\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv, 0.8)), ro = vec3(0., 0., iTime*.1);\n    vec3 rp = ro;\n    \n    rd.zy *= rot(-.32);\n    \n    if(iMouse.z > 0.){\n        rd.zy *= rot(m.y*3.);\n        rd.zx *= rot(m.x*3.);\n    }\n    \n    rd.yz *= rot(-cos(iTime*3.)*.01);\n    ro.y += cos(iTime*3.)*.01;\n    \n    float d = 0.0, t = 0.0;\n    for(int i = 0; i < 60; i++){\n        d = map(ro+rd*t);\n        if(d < 0.002 || t > 40.) break;\n        t += d * .7;\n    }\n    \n    vec3 p = ro + rd*t;\n    \n    vec3 n = normal(p);\n    vec3 ref = reflect(n, rd);\n    vec3 lp = ro + vec3(.6, 0.5, 2.4);\n    vec3 ld = normalize(lp-p);\n    \n    float dd = length(p - lp);\n    float dif = max(dot(n, ld), .0);\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 26.);\n    \n    vec3 objCol = vec3(0);\n    \n    vec3 rock = vec3(.8, .7, .6) * .9 * max(texture(iChannel1, p.xz*1.4).x, .4);\n    vec3 water = vec3(.7, .8, .9) * .8;\n    vec3 sky = vec3(.9, .97, .99);\n    float clouds = octnse(rd.xy, 3.27, 5) * .8;\n    \n    water += texture(iChannel0, ref).xyz;\n    water *= 0.5;\n    \n    vec2 auv = p.xz;\n    auv.x += cos(iTime + auv.y*32.)*.01;\n    auv.y += sin(iTime + auv.x*32.)*.01;\n    auv += iTime*.01;\n    \n    water *= max(texture(iChannel2, auv*0.98).x, .2);\n    \n    float nt = .08, nt2 = -.45;\n    float blend = ss(-.4 - nt, -.405 - nt, p.y);\n    vec3 col = mix(rock, water, blend);\n    col = dif * mix(vec3(1), col, ss(nt2 + .03, nt2, p.y));\n    col += vec3(.9, .8, .7)*spec*.5;\n    col = mix(vec3(.99, .97, .9) * clouds, col,  exp(-t*t*t*.08));\n    \n    f = vec4(col, 1.0);\n\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec2 hash22( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\nfloat gdns(vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = smoothstep(0., 1., f);\n    \n    vec2 a = hash22(i);\n    vec2 b = hash22( i + vec2(1.,0.));\n    vec2 c = hash22( i + vec2(.0,1.));\n    vec2 d = hash22( i + vec2(1));\n    \n    //rotAll(a, b, c, d);\n    \n    float nse = mix( mix( dot( a, f - vec2(0.0,0.0) ), \n                     dot( b, f - vec2(1.0,0.0) ), u.x),\n                mix( dot( c, f - vec2(0.0,1.0) ), \n                     dot( d, f - vec2(1) ), u.x), u.y);\n    return nse + 0.5;\n}\n\nfloat octnse(vec2 p, float t, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n        p.x+=t;\n     \tn += gdns(p) * a;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 257, 257, 303], [305, 305, 324, 324, 423], [425, 425, 452, 452, 653], [654, 654, 694, 694, 2291]]}
{"id": "sdfGWX", "name": "Rover", "author": "oneshade", "description": "Very old shader I was working on. Also my slowest one yet (~8fps on my computer) :(", "tags": ["3d", "raymarching", "terrain", "ik", "robot"], "likes": 9, "viewed": 214, "published": 3, "date": "1628217826", "time_retrieved": "2024-07-30T19:07:26.491981", "image_code": "// Constants\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n// Compiler trick to avoid loop unrolling (the compiler doesn't know about iFrame\n// so it can't make this a constant which would allow it to unroll loops depending on it)\n#define ZERO min(iFrame, 0)\n\n// SDFs\nfloat sdLine(in vec3 p, in vec3 a, in vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdDisc(in vec3 p, in float r) {\n    p.x = length(p.xz);\n    return length(p - vec3(min(p.x, r), 0.0, p.z));\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 q = vec2(length(p.xz) - r, abs(p.y) - h);\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nfloat sdSphere(in vec3 p, in vec3 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 o, in vec3 b) {\n    vec3 q = abs(p - o) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\n// 3D version of Inigo Quilez's horseshoe SDF\n// I haven't put much thought into optimizing :P\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdHorseshoe(in vec3 p, in float a, in vec3 w, in float r) {\n    p.x = abs(p.x);\n\n    float t = min(atan(p.y, p.x), a);\n    vec2 aq = abs(vec2(length(p.xy - vec2(cos(t), sin(t)) * r), p.z)) - w.xz;\n    float arc = length(max(aq, 0.0)) + min(0.0, max(aq.x, aq.y));\n\n    float c = cos(a), s = sin(a);\n    vec3 tq = abs(vec3(p.x * c + p.y * s - r, p.x * s - p.y * c + w.y, p.z)) - w;\n    float prong = length(max(tq, 0.0)) + min(0.0, max(tq.x, max(tq.y, tq.z)));\n\n    return min(arc, prong);\n}\n\nfloat sdBezier(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3) {\n    vec3 c1 = p - v1;\n    vec3 c2 = 2.0 * v2 - v3 - v1;\n    vec3 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        vec3 p1 = p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x);\n        vec3 p2 = p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\n// Hash from \"Hash without Sine\" by Dav_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in vec2 p) {\n\t//vec3 p3  = fract(vec3(p.xyx) * .1031);\n    //p3 += dot(p3, p3.yzx + 33.33);\n    //return fract((p3.x + p3.y) * p3.z);\n    return texture(iChannel0, p * 0.1).r; // Attempt to lower complexity\n}\n\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 cell = floor(p);\n    vec2 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float bl = Hash11(cell);\n    float br = Hash11(cell + vec2(1.0, 0.0));\n    float tl = Hash11(cell + vec2(0.0, 1.0));\n    float tr = Hash11(cell + 1.0);\n\n    return mix(mix(bl, br, local.x), mix(tl, tr, local.x), local.y);\n}\n\nfloat getTerrain(in vec2 p, in float t) {\n    p *= 0.25;\n\n    float height = 0.0;\n    float noiseScale = 1.0;\n    float totalScale = 0.0;\n\n    for (int oct=ZERO; oct < 7; oct++) {\n        height += snoise(p) * noiseScale;\n        totalScale += noiseScale;\n        noiseScale *= 0.5;\n        p *= 2.0;\n    }\n\n    height /= totalScale;\n    float height2 = height * height; // To reduce multiplications\n    return height2 * height2 * height * 5.0;\n}\n\n// SDF Operators\nvec2 pModPolar2(in vec2 p, in float n) { // 2D polar repetition\n    float rep = 6.28 / n, hRep = 0.5 * rep;\n    p = sin(mod(atan(p.y, p.x) + hRep, rep) - hRep + vec2(1.57, 0.0)) * length(p);\n    return p;\n}\n\n// 2 link IK solver (positions only)\n// https://www.shadertoy.com/view/NsfGRf\n// config sets the handedness, -1 for left, 1 for right\nvec2 solveJoint2D(in vec2 a, in vec2 b, in float ra, in float rb, in float config) {\n    vec2 ba = b - a;\n    float d = dot(ba, ba), l = sqrt(d);\n    float q = (d + ra * ra - rb * rb) / (2.0 * ra * l);\n    return a + (ba * q + vec2(-ba.y, ba.x) * sqrt(1.0 - q * q) * config) * ra / l;\n}\n\nvec3 solveJoint3D(in vec3 a, in vec3 b, in float ra, in float rb, in float config) {\n    b -= a;\n    float u = length(b.xz);\n    vec3 j = vec3(solveJoint2D(vec2(0.0), vec2(u, b.y), ra, rb, config), 0.0);\n    return a + vec3(b.xz / u * j.x, j.y).xzy;\n}\n\n// Quadratic bezier\nvec3 bezierArc(in vec3 a, in vec3 b, in vec3 c, in float t) {\n    float tInv = 1.0 - t;\n    return a * tInv * tInv + b * 2.0 * t * tInv + c * t * t;\n}\n\n// Computes a coordinate system \"looking\" at a target along the z axis\n// I think it is actually inverted\n// https://www.shadertoy.com/view/WlKBDw\nmat3 lookAt(in vec3 pos, in vec3 target) {\n    vec3 f = normalize(target - pos);         // Forward\n    vec3 r = normalize(vec3(-f.z, 0.0, f.x)); // Right\n    vec3 u = cross(r, f);                     // Up\n    return mat3(r, u, f);\n}\n\nvoid addShape(in float dist, in int id, inout vec2 scene) {\n    if (dist < scene.x) scene = vec2(dist, id);\n}\n\nvoid subShape(in float dist, in int id, inout vec2 scene) {\n    dist = -dist;\n    if (dist > scene.x) scene = vec2(dist, id);\n}\n\nvec2 mapScene(in vec3 p, in float t) {\n    vec2 scene = vec2(p.y, 1);\n    float time = iTime;\n\n    vec2 robotPos = vec2(0.0, iTime);\n\n    // Terrain\n    scene.x -= getTerrain(p.xz + robotPos, t) - 2.25;\n    scene.x *= 0.8; // Improve raymarching accuracy\n\n    // Tilt to match terrain\n    vec3 w1 = vec3(-1.5, getTerrain(vec2(-1.5, -2.5) + robotPos, t), -2.5);\n    vec3 w2 = vec3( 1.5, getTerrain(vec2( 1.5, -2.5) + robotPos, t), -2.5);\n    vec3 w3 = vec3( 1.5, getTerrain(vec2( 1.5,  2.5) + robotPos, t),  2.5);\n    vec3 w4 = vec3(-1.5, getTerrain(vec2(-1.5,  2.5) + robotPos, t),  2.5);\n\n    vec3 up = normalize(normalize(cross(w2 - w1, w1 - w3)) +\n                        normalize(cross(w3 - w2, w2 - w4)) +\n                        normalize(cross(w4 - w3, w3 - w1)) +\n                        normalize(cross(w1 - w4, w4 - w2)));\n\n    vec3 forward = normalize(cross(up, vec3(-1.0, 0.0, 0.0)));\n    vec3 right = cross(up, forward);\n\n    // Debug coordinate system\n    //addShape(sdLine(p, vec3(0.0), up * 3.0) - 0.1, 1, scene);\n    //addShape(sdLine(p, vec3(0.0), right * 3.0) - 0.1, 1, scene);\n    //addShape(sdLine(p, vec3(0.0), forward * 3.0) - 0.1, 1, scene);\n\n    vec3 op = p; // Keep untransformed copy\n    p.y -= 0.25 * (w1.y + w2.y + w3.y + w4.y);\n    p *= mat3(right, up, forward);\n\n    // TODO: add movement\n\n    float bodyAngle = 0.0;\n    float wheelAngle = time;\n\n    vec3 arcV1 = vec3(-1.0, 1.0, 4.0);\n    vec3 arcV2 = vec3(0.0, 4.0, 4.0);\n    vec3 arcV3 = vec3(1.0, 1.0, 4.0);\n\n    // Visualize arm path\n    //addShape(sdSphere(p, arcV1, 0.3), 7, scene);\n    //addShape(sdSphere(p, arcV2, 0.3), 7, scene);\n    //addShape(sdSphere(p, arcV3, 0.3), 7, scene);\n    //addShape(sdBezier(p, arcV1, arcV2, arcV3) - 0.1, 7, scene);\n\n    vec3 base = vec3(0.0, 0.0, 1.5);\n    vec3 end = bezierArc(arcV1, arcV2, arcV3, 0.5 + 0.5 * cos(iTime));//vec3(cos(iTime), 2.0 + sin(iTime), 3.0);\n    vec3 middle = solveJoint3D(base, end, 3.0, 2.0, 1.0);\n\n    float c = cos(bodyAngle), s = sin(bodyAngle);\n    p.xz *= mat2(c, s, -s, c);\n\n    // Body\n    addShape(sdBox(p, vec3(0.0, -0.5, 0.0), vec3(1.5, 0.5, 2.5)), 2, scene);\n\n    // Bolts\n    vec3 wp = vec3(abs(p.xz) - vec2(1.9, 1.6), p.y + 1.1).xzy;\n    addShape(sdBox(wp, vec3(-1.25, -0.1, 0.05), vec3(0.2, 0.1, 0.15)) - 0.1, 3, scene);\n\n    // Wheels\n    wheelAngle *= -sign(p.z);\n    c = cos(wheelAngle), s = sin(wheelAngle);\n    wp.yz *= mat2(c, -s, s, c);\n\n    vec2 wheels = vec2(sdDisc(wp.yxz, 0.6) - 0.35, 4);\n    addShape(sdCylinder(vec3(p.y + 1.15, p.x, abs(p.z) - 1.65), 2.0, 0.15), 5, wheels);\n\n    // Hubcaps\n    addShape(sdDisc(wp.yxz - vec3(0.0, 0.35, 0.0), 0.25) - 0.1, 5, scene);\n\n    // Treads\n    float turn = wp.x * sign(p.x * p.z);\n    c = cos(turn), s = sin(turn);\n    wp.yz *= mat2(c, -s, s, c);\n    wp.yz = pModPolar2(wp.yz, 24.0);\n    subShape(sdLine(wp, vec3(-0.25, 1.0, 0.0), vec3(1.0, 1.0, 0.0)) - 0.1, 4, wheels);\n    addShape(wheels.x, int(wheels.y), scene);\n\n    // Links\n    addShape(min(sdLine(p, base, middle), sdLine(p, middle, end)) - 0.25, 6, scene);\n\n    // Joints\n    addShape(sdSphere(p, base, 0.35), 7, scene);\n    addShape(sdSphere(p, middle, 0.35), 7, scene);\n\n    // Gripper\n    vec3 gp = (p - end) * lookAt(end, middle);\n    gp = vec3(gp.x, -gp.z - 0.5, gp.y);\n    addShape(sdHorseshoe(gp, mix(-0.2, 0.5, 0.5 + 0.5 * cos(iTime * 2.0)), vec3(0.1, 0.175, 0.2), 0.35), 8, scene);\n\n    return scene;\n}\n\n// Tetrahedral central differences method (2 less mapScene() evaluations) plus a\n// compiler trick: https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(in vec3 p, in float t) {\n    float h = 0.005 * t;\n    vec3 n = vec3(0.0);\n    for (int i=ZERO; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * mapScene(p + e * h, t).x;\n    }\n\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.6, -0.1) * 3.14;\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Raymarch\n    bool hit = false;\n    float t = 0.0;\n\n    vec3 p;\n    int id;\n\n    //float iters = 0.0;\n    for (int i=ZERO; i < 100; i++) {\n        p = ro + rd * t;\n        vec2 d = mapScene(p, t);\n        if (d.x < 0.001 * t) {\n            id = int(d.y);\n            hit = true;\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d.x;\n        //iters++;\n    }\n\n    if (hit) {\n        vec3 n = getNormal(p, t);\n        float diff = sqrt(max(0.0, dot(-rd, n)));\n\n        vec3 mat = vec3(1.0);\n        if (id == 1) mat = vec3(0.8, 0.6, 0.4); // Terrain\n        if (id == 2) mat = vec3(0.5); // Body\n        if (id == 3) mat = vec3(0.5); // Bolts\n        if (id == 4) mat = vec3(0.25); // Wheels\n        if (id == 5) mat = vec3(0.75); // Shaft and hubcaps\n        if (id == 6) mat = vec3(0.75); // Arm\n\n        fragColor.rgb = mat * diff;\n    }\n\n    // Iteration heatmap\n    //fragColor.rgb = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), iters / 100.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdfGWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 274, 321, 321, 429], [431, 431, 468, 468, 546], [548, 548, 601, 601, 712], [714, 714, 764, 764, 796], [798, 798, 844, 844, 943], [945, 1091, 1156, 1156, 1586], [1588, 1588, 1651, 1651, 2864], [2866, 2954, 2979, 3100, 3175], [3177, 3177, 3201, 3201, 3336], [3338, 3338, 3363, 3363, 3687], [3689, 3689, 3730, 3730, 4135], [4137, 4154, 4194, 4217, 4360], [4362, 4496, 4580, 4580, 4782], [4784, 4784, 4868, 4868, 5035], [5037, 5057, 5118, 5118, 5207], [5209, 5356, 5398, 5398, 5590], [5592, 5592, 5651, 5651, 5701], [5703, 5703, 5762, 5762, 5830], [5832, 5832, 5870, 5870, 9221], [9223, 9366, 9405, 9405, 9659], [9661, 9661, 9716, 9716, 11334]]}
{"id": "stSXRc", "name": "Sonic Hedgehog", "author": "zxcvm", "description": "Sonic the Hedgehog", "tags": ["sonic"], "likes": 2, "viewed": 267, "published": 3, "date": "1628217182", "time_retrieved": "2024-07-30T19:07:27.348690", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = vec4(abs(uv.y-1.),abs(uv.y-1.),1.,1.);\n\n    float offset = mod(uv.x - iTime, 1.);\n\n    if ((offset <= 0.45 && offset >= 0.4 && uv.y >= 0.2 && uv.y <= 0.3))\n        fragColor = vec4(0.34,0.36,190./255.,1.);\n    if ((uv.x <= 1. && uv.x >= 0.0 && uv.y >= 0.0 && uv.y <= 0.2))\n        fragColor = vec4(0.9,0.5,19/255,1.);\n    if ((uv.x <= 1. && uv.x >= 0.0 && uv.y >= 0.15 && uv.y <= 0.2))\n        fragColor = vec4(0.0,0.9,19/255,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSXRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 545]]}
{"id": "slSSz3", "name": "lost City", "author": "jorge2017a1", "description": "lost City", "tags": ["lostcity"], "likes": 11, "viewed": 280, "published": 3, "date": "1628203040", "time_retrieved": "2024-07-30T19:07:28.370957", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n\nvec3 ColumnaCaidaI(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);  \n     p= rotate_x( p, radians(45.0));\n   \n   vec3 p1a=p-vec3(0.0,2.0,0.0);\n   vec3 p1b=p-vec3(5.0,2.0,0.0);\n   p1a=rotate_z(p1a, radians(10.0));\n   p1b=rotate_z(p1b, radians(350.0));\n   \n   float sdb1a= sdBox( p1a, vec3(3.0,10.0,5.0) );\n   float sdb1b= sdBox( p1b, vec3(3.0,10.0,5.0) );\n   res =opU3(res, vec3(sdb1a,5.0,MATERIAL_NO));\n   res =opU3(res, vec3(sdb1b,5.0,MATERIAL_NO));\n   \n   float sdcy1=sdCylinderXZ( p-vec3(2.5,17.0,0.0), vec2(2.5,5.0) );\n   res =opU3(res, vec3(sdcy1,1.0,MATERIAL_NO));\n   return res;    \n}\n\nvec3 ColumnaCaidaII(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    p= rotate_x( p, radians(45.0));\n   vec3 p1a=p-vec3(0.0,3.0,0.0);\n   vec3 p1b=p-vec3(5.0,3.0,0.0);\n   p1a=rotate_z(p1a, radians(10.0));\n   p1b=rotate_z(p1b, radians(350.0));\n   \n   float sdb1a= sdBox( p1a, vec3(3.0,10.0,10.0) );\n   float sdb1b= sdBox( p1b, vec3(3.0,10.0,10.0) );\n   res =opU3(res, vec3(sdb1a,2.0,MATERIAL_NO));\n   res =opU3(res, vec3(sdb1b,2.0,MATERIAL_NO));\n   \n   float sdcy1=sdCylinderXZ( p-vec3(2.5,17.0, 3.0), vec2(2.5,5.0) );\n   float sdcy2=sdCylinderXZ( p-vec3(2.5,17.0,-6.0), vec2(2.5,5.0) );\n   \n   res =opU3(res, vec3(sdcy1,1.0,MATERIAL_NO));\n   res =opU3(res, vec3(sdcy2,1.0,MATERIAL_NO));\n   return res;    \n}   \n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    //res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    res =opU3(res, vec3(planeDist1,100.0,-1.0)); //inf\n\n   p.y=p.y-5.0;\n   \n   vec3 p0=p;vec3 p1=p;vec3 p2=p;\n   \n   p0.z= opRep1D(p1.z, 30.0 );\n   p1.z= opRep1D(p1.z, 76.0 );\n   p2.z= opRep1D(p2.z, 50.0 );\n   \n   vec3 cci= ColumnaCaidaI(p1-vec3(-20.0,0.0,-5.0));\n   res =opU3(res, cci);\n   \n   vec3 ccii= ColumnaCaidaII( p2-vec3(15.0,0.0,10.0));\n   res =opU3(res, ccii);\n   \n   \n   float le=6.0;\n   float r1=4.5;\n   float r2=0.5;\n   float sdl1= sdLink( p0-vec3(0.0,1.0,0.0),  le,  r1,  r2 );\n   res =opU3(res, vec3(sdl1,1.0,MATERIAL_NO));\n   \n   \n   \n   float le2=15.0;\n   float r12=25.0;\n   float r22=2.5;\n   float sdl2= sdLink( p0-vec3(0.0,1.0,0.0),  le2,  r12,  r22 );\n   res =opU3(res, vec3(sdl2,1.0,MATERIAL_NO));\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{ vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{   vec4 mPtr = iMouse;\n    mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n     float tCur = iTime;\n     float az = 0.;\n     float el = -0.15 * PI;\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n     mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n    return lin;\n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 getSkyColA(vec3 rd) \n{ float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 SmoothXOR( vec2 puv )\n{\n    //vec2 p = 256.0 * fragCoord.xy/iResolution.x + iTime;\n    vec2 p=10.0*puv;\n    float an = smoothstep( -0.5, 0.5, cos(3.14159*iTime) );\n    float x = 0.0;\n    for( int i=0; i<7; i++ ) \n    {   vec2 a = floor(p);\n        vec2 b = fract(p);\n        x += mod( a.x + a.y, 2.0 ) * \n            // the following line implements the smooth xor\n         mix( 1.0, 1.5*pow(4.0*(1.0-b.x)*b.x*(1.0-b.y)*b.y,0.25), an );\n        p /= 2.0;\n        x /= 2.0;\n    }\n    \n    return  vec3( x, x, x);\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n    if (id_material==10.0)\n    {return  SmoothXOR(p.xz );}\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        \n        col *= 1.0 - pow(d /(MAX_DIST) , 3.5);  \n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 20.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   vec3 ro=vec3(0.0,7.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    //return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n    \n    //referencia de un shader Colorful star\n    vec2 uv0 = vec2(sin(400.0*mod(time,10.0)),sin(405.5*mod(time,5.0)));\n    float phi = atan(uv0.y, uv0.x) + sin(mod(time*0.1,3.0));\n    float d0 = length(5.0+uv0);\n    float d = -0.3 + d0 * 0.43*sin(cos(1.5*phi)+d0) ;\n    float d2 = -0.3 + d0 * 0.83*sin(0.25*phi);\n     \n    return vec2((d*d2*0.25)/10.0);\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSSz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 449, 449, 533], [534, 534, 573, 573, 668], [669, 669, 708, 708, 803], [804, 804, 843, 843, 938], [940, 984, 1031, 1031, 1058], [1059, 1059, 1102, 1102, 1129], [1130, 1130, 1178, 1178, 1206], [1207, 1245, 1281, 1281, 1326], [1328, 1393, 1427, 1427, 1523], [1524, 1524, 1558, 1558, 1649], [1650, 1650, 1684, 1684, 1775], [1776, 1816, 1850, 1850, 1945], [1948, 1948, 2002, 2002, 2104], [2107, 2107, 2135, 2135, 2699], [2701, 2701, 2730, 2730, 3411], [3418, 3458, 3483, 3483, 4462], [4464, 4515, 4539, 4539, 4701], [4703, 4703, 4752, 4752, 5419], [5421, 5525, 5561, 5561, 5764], [5765, 5836, 5860, 5860, 6109], [6110, 6164, 6200, 6200, 6445], [6446, 6501, 6528, 6528, 6545], [6547, 6547, 6583, 6583, 6675], [6676, 6676, 6722, 6722, 6847], [6849, 6849, 6923, 6923, 8481], [8482, 8537, 8586, 8586, 8825], [8826, 8860, 8940, 8940, 9063], [9064, 9105, 9132, 9132, 9238], [9240, 9240, 9272, 9272, 9469], [9471, 9519, 9547, 9547, 9735], [9737, 9737, 9765, 9824, 10255], [10257, 10308, 10355, 10355, 10648], [10650, 10702, 10795, 10795, 11283], [11286, 11286, 11317, 11317, 11969], [11971, 12020, 12046, 12046, 12156], [12158, 12158, 12216, 12216, 12268], [12270, 12319, 12376, 12376, 12921]]}
{"id": "stSSR3", "name": "Helix Cubes", "author": "lambmeow", "description": "Messing around with some more sdf.\n8-5-2021- Added some specular", "tags": ["sdf", "cube", "helix"], "likes": 5, "viewed": 323, "published": 3, "date": "1628193315", "time_retrieved": "2024-07-30T19:07:29.176802", "image_code": "mat2 rot(float a)\n{\n\tfloat s = sin(a), c = cos(a);\n\treturn mat2(c, -s ,s, c);\n}\n\n//https://www.shadertoy.com/view/Xds3zN\nfloat cube (vec3 p, vec3 s)\n{\n\tvec3 d = abs(p) - s;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat scene(vec3 p)\n{\n\t\n\tfloat z = p.z;\n\t\n\t//p.z += time;\n\t\n\tp.z = mod(p.z - 2., 4.) -2.;\n\tp.x = mod(p.x - 3., 6.) -3.;\n\tp.xy /= 12.;\n\tp.xy *= rot(iTime + p.x * .3 * sin(iTime + z));\n\tp.xy *= 12.;\n\tp.y = abs(p.y);\n\t//return cube( p, vec3(1));\n\treturn cube(p , vec3(abs(sin(iTime - p.z * 0.44 + z)), 0., 1.)) - .5;\n}\n\nmat3 cam(vec3 E, vec3 l)\n{\n\tvec3 ww = normalize(l - E);\n\tvec3 uu = normalize(cross(ww, vec3(0,1,0)));\n\tvec3 vv = cross(uu,ww);\n\t\n\treturn mat3(uu,vv, ww);\n}\n\n\n//https://www.shadertoy.com/view/Xds3zN\nvec3 norm(vec3 value)\n{\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * scene(value+0.0005*e);\n    }\n    return normalize(n);\n}\n\n\nvec4 rc(vec3 ro, vec3 rd)\n{\n\tfloat len = 0.;\n\tfloat closest = 50.;\n\tfor(int i = 0; i < 255; i ++)\n\t{\n\t\tvec3 pos = ro + rd * len;\n\t\tfloat dist = scene(pos);\n\t\t\t\tclosest = min(closest, dist);\n\t\tif(dist < .001)\n\t\t\treturn vec4(ro + rd * len, closest);\n\t\t\t\n\n\t\tlen += dist;\n\t\t\n\t\tif(len > 50.)\n\t\treturn vec4(0,0,0, closest);\n\t\t\n\t}\n\treturn vec4(0,0,0, closest);\n}\n\nvec3 color(vec4 pos, vec3 cam, vec2 uv)\n{\n\tvec3 n = norm(pos.xyz);\n\tvec3 amb = vec3(1.-uv.y) * 0.2 * vec3( .4, .4, .7);\n\tvec3 dis = normalize(cam - pos.xyz);\n\tvec3 diff = (dot(n ,dis)) * vec3(0.1, .6, .7);\n\tvec3 glow =  1./(1.+clamp(pos.w, 0.,1.) * 10.) * 0.6* vec3(.4,.4,.7);\n\tvec3 ref = 2.*dot(n, dis) * n  - dis;\n\tvec3 spec = pow(dot(dis, ref), 3.0) * vec3(0.1,.6,.7);\n\tspec = clamp ( spec , 0.,1.);\n\tif(dot (pos,pos) == 0.)\n\t\treturn amb + vec3(1.,1.,1.) ;\n\t\n\treturn diff * pos.x + amb + glow +spec;\n}\n\n\nvoid mainImage( out vec4 fc, in vec2 uv )\n{\n\tvec2 r = iResolution.xy, u = (uv * 2. - r)/r.y;\n\t\n\tvec3 ro = vec3(0.,10.,0.);\n\n\t//ro.xz *= rot(time);\n\t\n\tvec3 rd = cam(ro, vec3(1)) * normalize(vec3(u, 2.));\n\t\n\tvec4 pos = rc(ro,rd);\n\t\n\tfc = vec4(color(pos, ro, u), 1.) ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSSR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 79], [81, 121, 150, 150, 237], [239, 239, 260, 260, 554], [556, 556, 582, 582, 711], [714, 754, 777, 777, 982], [985, 985, 1012, 1012, 1340], [1342, 1342, 1383, 1383, 1846], [1849, 1849, 1892, 1892, 2116]]}
{"id": "NlBXzc", "name": "paper cut 3", "author": "FabriceNeyret2", "description": "mouse control\n", "tags": ["moebiustransform"], "likes": 13, "viewed": 289, "published": 3, "date": "1628193276", "time_retrieved": "2024-07-30T19:07:30.001598", "image_code": "// variant of https://shadertoy.com/view/7ljSzV\n\n#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )     // rotation                  \nvec3 M;\n\nvec2 transform( vec2 P ) {           // --- mapping distortion on the plane ---\n // P += .5*sin(P.yx/2.) + 2.*cos(P.yx/8.),          // sinwave disto\n    P /= 50.;\n    vec2 z = P - vec2(-1,0);  P.x -= .5;             // Moebius transform\n    P *= mat2(z,-z.y,z.x) / dot(P,P);    \n                     // offset   spiral, zoom             phase     spiraling\n    P =   log(length(P+=.5))*vec2(.5, -1)  + atan(P.y, P.x)/6.3 * vec2(5, 1);        \n\treturn P * 50.; \n}\n\nfloat scene( vec3 q ) {              // --- scene SDF -------------\n    q.yz *= rot( .5+6.*M.y),                         // rotations\n    q.xz *= rot( 2.-6.*M.x);\n    float t = 9.,s, a,j; vec2 e = vec2(.1,0);\n    vec2 P = transform(q.xz), Q;\n    j = length( P.x - vec2(transform(q.xz+e).x,transform(q.xz+e.yx).x) ),\n    a = P.x/8. + iTime;\n    Q = mod(P+4.,8.)-4., \n    P = floor((P+4.)/8.),\n    s = Q.y-3., \n // s = mod(P.x,2.) < 1. ? Q.y-3. : Q.y+3., // try mod(P.x+P.y // flip direction. -3. for border continuity\n    P = abs(Q),\n    s /= sqrt(j)*3.,                                           // scale amplitude with cell size\n    q.y -= max(P.x,P.y)<3. ? .6*s*sin(a) : 0., // variant: .5*s*(-1.+.3*sin(a)) \n // max(P.x,P.y)<3. && P.x > 3.*abs(cos(a)) ? t=1. :           // WIP: preserve flip length\n                   t = min(t,  abs(q.y)-.05 );\n    return t;\n}\n//  abs(q.y) < dy+.05 && max(P.x,P.y)<3. && P.x > 3.*abs(cos(a)) ? t = 1. : // WIP: preserve flip length \n//                 t = min(t,  abs(q.y - (max(P.x,P.y)<3. ? dy : 0.) )-.05  );\n\n\nvoid mainImage(out vec4 O, vec2 U) { // --- ray-marching ------------\n    float t=9.;\n    vec2  P;\n    vec3  R = iResolution, // e = vec3(1,-1,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q;                                      // marching point along ray \n      //  M =  iMouse.xyz/R -.5,\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )              // march ray\n        t = min(9., scene(p)),\n        t = min(t, scene(p+.5*t*D)),                         // to handle discontinuities\n        p += .5*t*D;                                         // step forward = dist to obj          \n\n    O = 1.5*(1.-O);\n // O = 2.*exp(-2.*O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBXzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 167, 290, 604], [606, 606, 629, 673, 1471], [1659, 1659, 1695, 1728, 2470]]}
{"id": "NlSSRc", "name": "strange churn", "author": "xenn", "description": "Yeah, another reiteration.\nCheck mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 4, "viewed": 268, "published": 3, "date": "1628182663", "time_retrieved": "2024-07-30T19:07:30.974995", "image_code": "// Fork of \"Mutagen Container\" by xenn. https://shadertoy.com/view/7l2XWm\n// 2021-08-05 15:50:24\n\n// Fork of \"Mutagen Containment Malfunction\" by xenn. https://shadertoy.com/view/7tSXDm\n// 2021-08-02 03:13:08\n\n// Fork of \"Mind wax\" by xenn. https://shadertoy.com/view/stSXDh\n// 2021-08-01 09:51:39\n\n\n// Fork of \"soft Colour\" by xenn. https://shadertoy.com/view/NtfXD7\n// 2021-07-14 22:39:31\n\n// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *(0.92 - (.01*sin(iTime))) + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel2, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n    vec3 sha = texture( iChannel1, vec2(q.x,q.y) ).xyz;\n   \n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel2,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel2,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel2,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s) * ( col + (oricol * (sha - oricol)));\n\n    col *= 1.0+0.035*sin(110.0*(iTime / .50));\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, cos(iTime) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n    //line thickness\n    float th = 0.0025;\n    \n    //gradient detection for r,g and b separatly\n    //not sure why I did this actually\n    \n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).r\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).r ;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).r\n    - texture(iChannel0, uv.xy-vec2(0., th)).r;\n    \n    float gxg = texture(iChannel0, uv.xy+vec2(th, 0.)).g\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).g ;\n    \n    float gyg = texture(iChannel0, uv.xy+vec2(0., th)).g\n    - texture(iChannel0, uv.xy-vec2(0., th)).g;\n    \n    float gxb = texture(iChannel0, uv.xy+vec2(th, 0.)).b\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).b;\n    \n    float gyb = texture(iChannel0, uv.xy+vec2(0., th)).b\n    - texture(iChannel0, uv.xy-vec2(0., th)).b;\n    \n    //hack to concea noise from: https://www.shadertoy.com/view/Mdf3zr\n    float gr = gxr*gxr + gyr*gyr;\n    float gg = gxg*gxg + gyg*gyg;\n    float gb = gxb*gxb + gyb*gyb;\n    \n    //more noise control\n    float g = pow((gr+gg+gb)/1.,1.9);\n    \n    \n    vec3 col = texture(iChannel1, p / iResolution.xy).xyz;\n    col = mix(col,  0.5 + 0.5*cos(iTime*4.+uv.y*6.+vec3(0,2,4)),g*100.);\n    \n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n//#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n// --- MATLAB Jet Colour Scheme ----------------------------------------\nvec3 spectral_jet(float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tvec3 c;\n\n\tif (x < 0.25)\n\t\tc = vec3(0.0, 4.0 * x, 1.0);\n\telse if (x < 0.5)\n\t\tc = vec3(0.0, 1.0, 1.0 + 4.0 * (0.25 - x));\n\telse if (x < 0.75)\n\t\tc = vec3(4.0 * (x - 0.5), 1.0, 0.0);\n\telse\n\t\tc = vec3(1.0, 1.0 + 4.0 * (0.75 - x), 0.0);\n\n\t// Clamp colour components in [0,1]\n\treturn saturate(c);\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = -.998;\nconst float iFeedbackColorShiftZoom   = -0.1;\nconst float iFeedbackColorShiftImpact = 0.0192571;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .5;\nconst float iBlobEdgeSmoothing        = .09;\nconst float iBlob1Radius              = .61;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .0111;\nconst float iBlob2Radius              = .6;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = 0.012;\nconst float iBlob2ColorPulseShift     = 1.;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6 (\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gb - .5) * iFeedbackColorShiftImpact  * (0.1*abs(cos(iTime*0.1231))) ;\n    stShift += iFeedbackShiftVector ;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   vec3 extraColor = repeatedTexture(iChannel3, uv - stShift).rgb;\n    extraColor *= iFeedbackFadeRate;\n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * (iBlob1Radius + (0.2*abs(sin(iTime*0.1)))) , iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * (iBlob2Radius +  (0.2*abs(sin(iTime*0.1)))), iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n    color *  (extraColor * extraColor);\n\n    color -   clamp(color, 0., 2.5 );\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.1*sin(iTime/3.4));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*(0.1+(0.1*cos(iTime/2.))), 01.0);\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"spirit aura\" by xenn. https://shadertoy.com/view/7lSGzR\n// 2021-06-21 18:20:40\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n     vec4 colour = texture(iChannel2, uv.xy)*0.5;\n    vec4 col = texture(iChannel0, uv.xy)*0.75 * colour;\n   \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel1, uv) * weight;\n        col += texture(iChannel1, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSSRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 518, 518, 727], [729, 729, 786, 786, 2104]]}
{"id": "NlSSRV", "name": "Procedural Staffs", "author": "SnoopethDuckDuck", "description": "Staff generator using noise and cellular automata, in the DawnBringer32 color palette.\n\nThe code is sloppy in places so if you have any improvements, I'd love to hear them.\n\nYou can see more staffs here:\nhttps://snoopethduckduck.itch.io/staff-maker\n", "tags": ["generative"], "likes": 37, "viewed": 821, "published": 3, "date": "1628169465", "time_retrieved": "2024-07-30T19:07:31.733965", "image_code": "\n// very messy!\nvec3 colorMap( int index, float v ) {\n    vec3[14] arr;\n    if (index == 0)\n        arr = vec3[] ( \n                // brown\n                vec3(69, 40, 60),\n                vec3(102, 57, 49),\n                vec3(102, 57, 49),\n                vec3(102, 57, 49),\n                vec3(143, 86, 59),\n                vec3(143, 86, 59),\n                vec3(143, 86, 59),\n                vec3(180, 123, 80),\n                vec3(180, 123, 80),\n                vec3(180, 123, 80),\n                // orange\n                vec3(223, 113, 38),\n                vec3(255, 182, 45),\n                vec3(255, 182, 45),\n                vec3(251, 242, 54)\n                );\n    else\n        arr = vec3[] ( \n                // dark blue\n                vec3(50,60,57),\n                vec3(63,63,116),\n                vec3(63,63,116),\n                vec3(63,63,116),\n                vec3(48,96,130),\n                vec3(48,96,130),\n                vec3(48,96,130),\n                vec3(91,110,225),\n                vec3(91,110,225),\n                vec3(91,110,225),\n                // light blue\n                vec3(99,155,255),\n                vec3(95,205,228),\n                vec3(213,219,252),\n                vec3(255)\n                );\n                \n    return arr[ min(14, int(14. * v)) ] / 255.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale factor to enlarge image by\n    float sf = dim.y / (iResolution.y - 64.);\n\n    // scale and centre image to screen\n    vec2 coord = ceil( sf * fragCoord + vec2(0., sf * (32. * cos(iTime)-4.)) ) ;\n    coord -= ceil(sf * 0.5 * iResolution.xy - 0.5 * dim);\n\n    float A = texelFetch( iChannel0,  ivec2(coord) , 0 ).x;\n    float B = texelFetch( iChannel1,  ivec2(coord) , 0 ).x;\n     \n    float t = 100. * B;\n\n    // fill white bits with color\n    if ( A == 1. ) {\n\n        // cos with high frequency t generates linework\n        float v = 0.5 * (1. + cos(pi * (t + 1.)));  \n    \n        // shade top lighter, bottom darker\n        v = min(1., v * (0.6 + 0.9 * coord.y / dim.y));\n\n        // shade left side darker\n        v = (coord.x <= 0.5 * dim.x - 1.) ? max(0., v - 3. / 14.) : v;\n        \n        int index = int(floor(float(iFrame) / float(reset))) % 2;\n        fragColor = vec4(colorMap(index, v), 1.);\n    }\n\n    // fill background\n    else if ( A == 0. ) {\n        vec2 uv = fragCoord / iResolution.y; \n        uv = mod(1.5 * uv + vec2(0.05 * iTime), 1.);\n        if ((uv.x > 0.5 && uv.y > 0.5) || (uv.x < 0.5 && uv.y < 0.5))\n            fragColor = vec4(48., 96., 130., 255.) / 255.;\n        else\n            fragColor = vec4(91., 110., 225., 255.) / 255.;\n        // float d = length(fragCoord / iResolution.xy - 0.5);\n        // fragColor *= 0.8 + 0.4 * (1. - d);\n    }\n    \n    // re-color outline\n    else \n        fragColor = vec4(34., 32., 52., 255.) / 255.;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// IDEA:\n// instead of doing things frame by frame, use 2 buffers that read off each other,\n// each has a counter, so you can go A -> B -> A -> B etc. a fixed number of times\n// should be able to instantly generate sprites this way (hopefully)\n\nfloat random ( vec2 st ) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat Cell( in vec2 p )\n{\n    if (p.x <= dim.x && p.y <= dim.y)\n        return texelFetch(iChannel0, ivec2(p), 0 ).x;    \n    return 0.;\n}\n\nfloat CA ( vec2 px, float e ) {\n    float k = Cell(px+vec2(-1,-1)) + 1.5 * Cell(px+vec2(0,-1)) + Cell(px+vec2(1,-1))\n            + 1.5 * Cell(px+vec2(-1, 0))                 + 1.5 * Cell(px+vec2(1, 0))\n            + Cell(px+vec2(-1, 1)) + 1.5 * Cell(px+vec2(0, 1)) + Cell(px+vec2(1, 1));\n    \n    if ( e == 1. && k < 4.5 )\n        e = 0.;\n    else if ( e == 0. && k > 6. )\n        e = 1.;      \n        \n    return e;\n}\n\nfloat sumNeighbours ( vec2 px ) {\n    return Cell(px+vec2(0, -1)) + Cell(px+vec2(-1, 0)) +\n           Cell(px+vec2(0, 1))  + Cell(px+vec2(1, 0));\n}\n\nfloat prodNeighbours ( vec2 px ) {\n    return (Cell(px+vec2(0, -1)) + Cell(px+vec2(0, 1))) * \n           (Cell(px+vec2(-1, 0)) + Cell(px+vec2(1, 0)));\n}\n\nbool hasWhiteNeighbour ( vec2 px ) {   \n    return sumNeighbours(px) > 0.;\n}\n\nbool isInteriorCorner ( vec2 px, float e ) {\n    return e == 0.5 && prodNeighbours(px) >= 2.25;     \n}\n\nbool isExteriorCorner ( vec2 px, float e ) {\n    return e == 0.5 && sumNeighbours(px) == 1.;\n}\n\nbool isBlackOutlined( vec2 px, float e ) {\n    return e == 0. && sumNeighbours(px) == 2.;\n}\n\nbool wasInDiagCorner( vec2 px, float e ) {\n    // this shouldn't work but somehow it does\n    return e == 1. && prodNeighbours(px) < 2.; \n}\n\nbool isIsolated ( vec2 px ) {\n    return sumNeighbours(px) == 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n   // ivec2 px = ivec2( fragCoord );\n    vec2 px = coord;\n   \n    float e = Cell(px);\n    \n    // reset staff after a number of frames\n    int frame = iFrame % reset;\n      \n    // initial state - generate noise\n    if ( frame == 0 && coord.x <= dim.x && coord.y <= dim.y ) {\n        \n        float f = coord.y / dim.y;\n       \n        // distance from centre\n        float d = abs(0.5 * dim.x - coord.x);\n                \n        // generate noise ( more 1's at the top )\n        e = step(0.5 - (0.1 + 0.1 * random(vec2(iTime))) * (2. * f - 1.),\n                 random(vec2(d , coord.y) + iTime));\n                 \n        // centre cells are 1. ( insert a \"pole\" ) \n        // ( maybe cut out the side values? )\n        e = max(e, step(d, 1.));\n        \n        // cut off edges, so outline will work\n        e *= step(coord.x, dim.x - 2.) * step(2., coord.x) * \n             step(coord.y, dim.y - 2.) * step(2., coord.y);        \n    }\n    \n    // run cellular automata on noise\n    else if ( frame < 10 )\n        e = CA(px, e);    \n    \n    // re-insert centre cells so a \"pole\" definitely exists (lower half only)\n    else if ( frame < 11 ) {\n        e = min(1., \n            e + step(coord.y, 0.5 * dim.y) \n            * step(2., coord.y) \n            * max(e, step(abs(0.5 * dim.x - coord.x), 1.)));\n    } \n    \n    // generate outline\n    else if ( frame < 12 )\n        e = (e == 0. && hasWhiteNeighbour(px)) ? .5 : e;\n    \n    // remove interior outlines + interior (axis-aligned) corners\n    else if ( frame < 17 )\n        e = (isInteriorCorner(px, e) || isBlackOutlined(px, e)) ? 1. : e;\n    \n    // remove exterior (diagonal) corner outlines\n    else if ( frame < 18 )\n        e = isExteriorCorner(px, e) ? 0. : e;\n    \n    // turn newly exposed bits into outlines\n    else if ( frame < 19)\n        e = wasInDiagCorner(px, e) ? 0.5 : e;\n    \n    // remove any corners formed from deleting diagonal corners\n    else if ( frame < 20 ) \n        e = isExteriorCorner(px, e) ? 0. : e;\n    \n    // one more for good luck ( remove pixels without any neighbours )\n    else if ( frame < 21 ) \n        e = isIsolated(px) ? 0. : e;\n        \n  fragColor = vec4(e);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ( Most of this code was stolen from iq somewhere )\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// generate mirrored noise\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    // uncomment iTime for a cool look\n    vec2 uv = vec2(abs(coord.x - 0.5 * dim.x), coord.y)\n            + 20. * floor(float(iFrame) / float(reset));// + iTime;\n \n\tfloat f = 0.0;\n\t\n\tuv *= 0.01;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf =  0.5000 * noise( uv ); uv = m*uv;\n    f += 0.2500 * noise( uv ); uv = m*uv;\n\tf += 0.1250 * noise( uv ); uv = m*uv;\n\tf += 0.0625 * noise( uv ); uv = m*uv;\n\t\n\tf = 0.5 + 0.5 * f;\n\n    fragColor = vec4(f);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// dimensions of sprite - has to be less than screen dimensions\nconst vec2 dim = vec2(24, 80);\n\n// number of frames each sprite lasts for\nconst int reset = 120;\n\n// pie, the food we all know and love\nconst float pi = 3.14159;\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1322, 1322, 1379, 1419, 2865]]}
{"id": "ttccRS", "name": "Rhombus pattern", "author": "z0rg", "description": "Description", "tags": ["rhombus", "pshych"], "likes": 9, "viewed": 358, "published": 3, "date": "1628163979", "time_retrieved": "2024-07-30T19:07:32.608627", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\n\nfloat loz(vec2 p,float r)\n{\n  return lenny(p)-r;\n}\n\nfloat sub(float a, float b)\n{\n  return max(a,-b);\n}\nfloat star(vec2 uv,float r)\n{\n  return mix(lenny(uv),length(uv),-2.)-r;\n}\n\n\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n  float th = .005;\n  float lz = abs(loz(uv*vec2(1.5,1.),.5))-th;\n  col += vec3(.7,0.5,0.3)*pow(1.-sat(lz*2.),3.);\n  col += vec3(1.,0.52,0.7)*(1.-sat(lz*200.));\n col += vec3(.7,0.52,0.56)*(1.-sat((lenny(uv*vec2(.8,2.))-.3)*1.));\n  return col;\n}\n\nfloat ti;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  ti = iTime*0.3;\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy) / iResolution.xx;\n    // uv*=2.2*(sin(iTime)*.2+.5);\n // uv*= 1.+(sin(iTime)*.5+.5)*.1*(mod(iTime,.1)/.1)*(abs(uv.x+sin(iTime))+.5);\nvec2 ouv = uv;\nuv*= r2d(-ti);\nuv*= r2d(float(int(ti+uv.y*10.*uv.x)));\n uv*=1.;\n uv= (mod(uv*(sin(ti)*.3+1.)*5.,vec2(2.))-vec2(1.))*r2d(ti);\n\n  vec3 col = rdr(.7*uv*r2d(5.*lenny(uv)-ti*3.))\n  +rdr(uv)\n  +rdr(-uv*5.);\n  col *= .5+vec3(uv, .25+.5*sin(ti));\ncol = mix(col,col.zxy,float(mod(lenny(ouv)-ti,.5)<.2));\ncol *= 1.-sat((lenny(ouv)-.5)*2.);\nif (ouv.x<0.)\ncol = col.yxz;\ncol += .5*vec3(ouv*.5,sin(ti)*.2+.8)*pow(1.-sat((lenny(ouv)-.5)*1.),2.);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttccRS.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 415, 415, 490], [492, 492, 512, 512, 539], [540, 540, 561, 561, 591], [593, 593, 620, 620, 643], [645, 645, 674, 674, 696], [697, 697, 726, 726, 770], [773, 773, 792, 792, 1048], [1060, 1060, 1117, 1117, 1792]]}
{"id": "NlSSR3", "name": "Slope field", "author": "NinjaKoala", "description": "Solving a differential equation by marching over a slope field.\nSee: https://en.wikipedia.org/wiki/Slope_field", "tags": ["2d", "slopefield", "differentialequation"], "likes": 8, "viewed": 287, "published": 3, "date": "1628159607", "time_retrieved": "2024-07-30T19:07:33.357624", "image_code": "const float pi = 3.1415925;\n\nconst int num_segments1 = 128; //number of segments moving forward\nconst int num_segments2 = 64; //number of segments moving backward\nconst float step_size = .05; //segment size\n\nconst float raster_size = .1;\nconst float zoom = 3.;\n\nconst float random_offset_factor=.2;\n\nconst float line_width = .004;\nconst float dot_size = .02;\n\nconst vec3 bg_col = vec3(1);\nconst vec3 raster_col = vec3(0);\nconst vec3 traj_col = vec3(0,1,0);\nconst vec3 perp_col = vec3(1,0,0);\nconst vec3 dot_col = vec3(0);\n\n//slope field functions\nfloat func(vec2 uv){\n\t//return uv.x*uv.x + uv.y*uv.y;\n\t//return uv.x*uv.x - uv.y*uv.y;\n\t//return sin(2.*uv.x)*sin(2.*uv.y);\n\t//return uv.x*uv.y*uv.y;\n\t//return uv.y*uv.y - uv.x;\n\treturn uv.x*(uv.x*uv.x+uv.y*uv.y)-(2.*uv.x*uv.x-uv.y*uv.y);\n\t//return uv.y*uv.y*uv.y+uv.x*uv.x;\n\t//return uv.x*uv.y;\n\t//return uv.x*uv.x*uv.y;\n\t//return sqrt(uv.x*uv.x*abs(uv.y));\n\t//return -sqrt(uv.x*uv.x*abs(uv.y));\n\t//return sin(uv.x+uv.y)+cos(uv.x+uv.y);\n\t//return 1./(2.*uv.y);\n}\n\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nfloat trajectory_segments_dis_sq(vec2 uv, vec2 p, bool perp){\n    float d0 = 1e38;\n    vec2 a = p;\n    for( int i=1; i<num_segments1; i++ )\n    {\n\t\tvec2 b = a;\n        if(perp){\n            b +=step_size*vec2(-func(a),1);\n        }\n        else{\n            b += step_size*vec2(1,func(a));\n        }\n        d0 = min(d0,segment_dis_sq(uv, a, b ));\n        a = b;\n    }\n\n\ta = p;\n\n    for( int i=1; i<num_segments2; i++ )\n    {\n\t\tvec2 b = a;\n        if(perp){\n            b -= step_size*vec2(-func(a),1);\n        }\n        else{\n            b -= step_size*vec2(1,func(a));\n        }\n        d0 = min(d0,segment_dis_sq(uv, a, b ));\n        a = b;\n    }\n    \n    return d0;\n}\n\n// dave hoskins hash without sine\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n\tmouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 1./iResolution.y;\n\n\tfloat dis = 1e38;\n\n\tuv *= zoom;\n\tborder *= zoom;\n\tmouse *= zoom;\n\n\tvec2 duv = floor(uv/raster_size+.5)*raster_size;\n    duv += hash22(duv)*random_offset_factor*raster_size;\n\n\tfloat cur_slope = func(duv);\n\n\tvec2 tang = normalize(vec2(1.,cur_slope));\n\tvec2 nor = vec2(-tang.y,tang.x);\n\n\tfloat len = raster_size/2.;\n    \n    vec3 col = bg_col;\n\n\tdis = sqrt(segment_dis_sq(uv,duv-len/2.*tang,duv+len/2.*tang))-line_width;\n    col = mix(raster_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n\tdis = sqrt(trajectory_segments_dis_sq(uv,mouse,false))-line_width;\n    col = mix(traj_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n    dis = sqrt(trajectory_segments_dis_sq(uv,mouse,true))-line_width;\n    col = mix(perp_col,col,clamp(sqrt(dis/border),0.,1.));\n    \n    dis = distance(uv,mouse)-dot_size;\n    col = mix(dot_col,col,clamp(sqrt(dis/border),0.,1.));\n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSSR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[523, 547, 567, 724, 1010], [1012, 1012, 1037, 1037, 1056], [1058, 1058, 1105, 1105, 1216], [1218, 1218, 1279, 1279, 1889], [1891, 1925, 1946, 1946, 2080], [2082, 2082, 2139, 2139, 3246]]}
{"id": "7ljSzV", "name": "paper cut 2", "author": "FabriceNeyret2", "description": "mouse control\n", "tags": ["short", "golf"], "likes": 17, "viewed": 364, "published": 3, "date": "1628154568", "time_retrieved": "2024-07-30T19:07:34.118590", "image_code": "#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )             // rotation                  \nvec3 M;\n\nfloat map( vec3 q ) {\n    q.yz *= rot( .5+6.*M.y),                                 // rotations\n    q.xz *= rot( 2.-6.*M.x);\n    float t = 9.,s, a;\n // t = min(t,  abs(q.y)-.1 ),                               // floor alone\n    vec2 P = q.xz, Q;\n    P += .5*sin(P.yx/2.) + 2.*cos(P.yx/8.),                  // surface map\n    Q = mod(P+4.,8.)-4., \n    P = floor((P+4.)/8.),\n    s = mod(P.x,2.) < 1. ? Q.x-3. : Q.x+3., // try mod(P.x+P.y // flip direction. -3. for border continuity\n    P = abs(Q),\n // t = max(t, 3.-max(P.x,P.y) ),                            // square hole alone\n    a = length(q)/8.+iTime,\n    q.y -= max(P.x,P.y)<3. ? .6*s*sin(a) : 0.,\n // max(P.x,P.y)<3. && P.x > 3.*abs(cos(a)) ? t=1. : // preserve flip length\n                   t = min(t,  abs(q.y)-.05 );\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s,a; //, Z=0.;\n    vec2  P;\n    vec3  R = iResolution, // e = vec3(1,-1,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q;                                      // marching point along ray \n      //  M =  iMouse.xyz/R -.5,\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        t=9.,\n        t = min(t, map(p)),\n        t = min(t, map(p+.5*t*D)),                           // to handle discontinuities\n        p += .5*t*D; // , Z+=t;                              // step forward = dist to obj          \n\n // O = vec4(1.6-Z/200.); return;                   // depth buffer\n    O = 1.5*(1.-O);\n // O = 2.*exp(-2.*O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 121, 121, 894], [896, 896, 932, 932, 1745]]}
{"id": "7t2SzV", "name": "Ancient Archetype", "author": "xenn", "description": "Check mouse! \n\nhttps://xemantic.github.io/shader-web-background/\n \nGoal: shadertoy-style shaders in regular web development\n", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 2, "viewed": 285, "published": 3, "date": "1628153093", "time_retrieved": "2024-07-30T19:07:35.051096", "image_code": "// Fork of \"Aurora Yonic\" by xenn. https://shadertoy.com/view/stfSWX\n// 2021-08-05 08:43:29\n\n// Postprocess copied with some small modifications from Mattias: https://www.shadertoy.com/view/Ms23DR\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 3.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 3.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = curve( q );\n    vec3 oricol = texture( iChannel0, vec2(q.x,q.y) ).xyz;\n    vec3 col;\n    vec3 sha = texture( iChannel2, vec2(q.x,q.y) ).xyz;\n    vec3 shaz = texture( iChannel3, vec2(q.x,q.y) ).xyz;\n   \n\tfloat x =  sin(0.3*iTime+uv.y*21.0)*sin(0.7*iTime+uv.y*29.0)*sin(0.3+0.33*iTime+uv.y*31.0)*0.0005 ;\n\n    col.r = texture(iChannel0,vec2(x+uv.x+0.001,uv.y+0.001)).x+0.05;\n    col.g = texture(iChannel0,vec2(x+uv.x+0.000,uv.y-0.002)).y+0.05;\n    col.b = texture(iChannel0,vec2(x+uv.x-0.002,uv.y+0.000)).z+0.05;\n    col.r += 0.08*texture(iChannel0,0.75*vec2(x+0.025, -0.027)+vec2(uv.x+0.001,uv.y+0.001)).x;\n    col.g += 0.05*texture(iChannel0,0.75*vec2(x+-0.022, -0.02)+vec2(uv.x+0.000,uv.y-0.002)).y;\n    col.b += 0.08*texture(iChannel0,0.75*vec2(x+-0.02, -0.018)+vec2(uv.x-0.002,uv.y+0.000)).z;\n    \n    float vig = (0.0 + 1.0*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n\tcol *= vec3(pow(vig,0.15));\n\n    col *= vec3(0.9,1.1,0.9);\n    \n\tfloat scans = clamp( 0.35+0.05*sin(3.5*iTime+uv.y*iResolution.y*1.5), 0.0, 1.0);\n\t\n\tfloat s = pow(scans,0.75);\n\tcol = col *vec3(0.4+0.7*s) + (sha * col);\n\n    col *= (sha * oricol) + (shaz * oricol) + 1.0+0.035*sin(110.0*(iTime / 4.0));\n\n\tcol*=1.0-0.75*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*1.0,0.0,1.0));\n\t\n    float comp = smoothstep( 0.1, 0.9, sin(iTime) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.141592653 \n#define countX 17.\n#define petalWidth .4\n#define AA 2.\n\nvec3 colMap(float v) {\n\n\tv=mod(v, PI+1.3)-.8;\t\n    return vec3(\n\t\tsin(sin(v-.6)),\n\t\tsin(sin(v)),\n\t\tsin(sin(v+.8))\n\t);\n\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for(float aa=0.; aa<AA; aa++){\n        for(float bb=0.; bb<AA; bb++){\n\n            // Normalized pixel coordinates (from 0 to 1)\n            vec2 uv = (fragCoord + vec2(aa,bb)*1./AA)/iResolution.xy;\n\n            // Time varying pixel color\n\n            uv-=.5;\n            uv.y*=iResolution.y/iResolution.x;\n            uv*=2.;\n\n            float tim=-iTime*.1;\n            float posintim=sin(tim)*.5+.5;\n            float dst=length(uv);\n            vec2 tuv = vec2(0.,dst);\n            vec2 id = vec2(0.);\n            float zoomSpeed=tim*.4;\n            float angle1=(atan(uv.x,uv.y)/PI*.5+.5)+zoomSpeed;\n            float angle2=angle1-2.*zoomSpeed;\n            float add=pow(dst, posintim*.7+.1)*countX*petalWidth;\n          tuv.x=mod(angle1*countX+add, 1.);\n            tuv.y=mod(angle2*countX-add, 1.);\n            id.x=ceil(angle1*countX+add);\n            id.y=floor(angle2*countX-add);\n            float edgeDist = max(max(tuv.x, tuv.y), max(1.-tuv.x, 1.-tuv.y));\n            tuv-=.5;\n            tuv*=dst*3.;\n            float t=log(dst+1.6);\n            float v=abs(tuv.x+tuv.y)+pow(tuv.y-tuv.x, 2.);\n            v+=pow(edgeDist,25.);\n            vec3 col=vec3(smoothstep(t+.1,t,v) );\n            col*=colMap(abs(id.x-id.y)*.4);\n\n\n            // Output to screen\n            fragColor += vec4(col/(AA*AA),1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n//#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .001;\nconst float iFeedbackFadeRate         = .9993;\nconst float iFeedbackColorShiftZoom   = 0.1;\nconst float iFeedbackColorShiftImpact = .0023;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .35;\nconst float iBlobEdgeSmoothing        = .03;\nconst float iBlob1Radius              = .33;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = .082;\nconst float iBlob2Radius              = .75;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     = .1234;\nconst float iBlob2ColorPulseShift     = 2.75;\nconst float iColorShiftOfRadius       = 1.5;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.bg/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915+(0.1*sin(iTime/3.4));\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base * overlay*(0.1+(0.1*cos(iTime/2.))), 01.0);\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"spirit aura\" by xenn. https://shadertoy.com/view/7lSGzR\n// 2021-06-21 18:20:40\n\n/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.97; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel1, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2SzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 219, 219, 407], [409, 409, 466, 466, 1853]]}
{"id": "st2SzK", "name": "Maxnorm Distance to Tanglesquare", "author": "oneshade", "description": "Proof of concept (no quartics either, just quadratics!).", "tags": ["2d", "sdf", "distance", "quartic", "maxnorm", "goursat", "tanglesquare", "linf"], "likes": 19, "viewed": 280, "published": 3, "date": "1628135137", "time_retrieved": "2024-07-30T19:07:35.903817", "image_code": "// Almost forgot to link a desmos graph :D\n// https://www.desmos.com/calculator/xybvp7nzpg\n\n// Implicit definition (my own modification of the tanglecube formula here:\n// https://mathworld.wolfram.com/Tanglecube.html):\n// (x^4 + y^4)a + (x^2 + y^2)b + c\nfloat sdTanglesquare(in vec2 p, in float a, in float b, in float c) {\n    p = abs(p); // Quadrant symmetry\n    if (p.y > p.x) p = p.yx; // Diagonal symmetry\n\n    // Upper-right critical point in the top right quadrant \n    vec2 crit = p - vec2(sqrt((-b + sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)), sqrt(-b / (2.0 * a)));\n    float d = max(abs(crit.x), abs(crit.y));\n\n    // Lower critical point in the top right quadrant\n    if (abs((b * b) / (a * c) - 3.0) < 1.0) {\n        crit = p - vec2(sqrt(-b / (2.0 * a)), sqrt((-b - sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)));\n        d = min(d, max(abs(crit.x), abs(crit.y)));\n    }\n\n    else {\n        crit = p - vec2(sqrt((-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a)), 0.0); // Rightmost middle critical point\n        d = min(d, max(abs(crit.x), abs(crit.y)));\n\n        float h = b * b - 4.0 * a * c;\n        if (h > 0.0) {\n            float x = (-b - sqrt(h)) / (2.0 * a);\n            if (x > 0.0) {\n                crit = p - vec2(sqrt(x), 0.0); // Next critical point to the left\n                d = min(d, max(abs(crit.x), abs(crit.y)));\n            }\n        }\n    }\n\n    // Diagonal ray intersection\n    vec2 p2 = p * p, p4 = p2 * p2;\n    float sum1 = p.x + p.y, diff1 = p.x - p.y;\n    float sum2 = p2.x + p2.y, sum4 = p4.x + p4.y;\n\n    // (ux^2 + vx + w)^2 + t = 0 ---> ux^2 + vx + w = (+/-)sqrt(-t)\n    float u = sqrt(2.0 * a);\n    float v = sum1 * u;\n    float w = ((3.0 * sum2 - sum1 * sum1) * a + b) / u;\n    float t = sqrt(w * w - sum4 * a - sum2 * b - c);\n\n    // ux^2 + vx + w = +sqrt(-t)\n    float h = v * v - 4.0 * u * (w - t);\n    float k = 2.0 * u;\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // ux^2 + vx + w = -sqrt(-t)\n    h = v * v - 4.0 * u * (w + t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // Other diagonal ray intersection\n    v = diff1 * u;\n    w = ((3.0 * sum2 - diff1 * diff1) * a + b) / u;\n    t = sqrt(w * w - sum4 * a - sum2 * b - c);\n\n    // ux^2 + vx + w = +sqrt(-t)\n    h = v * v - 4.0 * u * (w - t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // ux^2 + vx + w = -sqrt(-t)\n    h = v * v - 4.0 * u * (w + t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    return d * sign(sum4 * a + sum2 * b + c);\n}\n\n// Critical points visualization SDF\nfloat sdCritical(in vec2 p, in float a, in float b, in float c) {\n    p = abs(p);\n    if (p.y > p.x) p = p.yx;\n\n    float d = length(p - vec2(sqrt((-b + sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)), sqrt(-b / (2.0 * a))));\n    vec2 crit;\n\n    if (abs((b * b) / (a * c) - 3.0) < 1.0) {\n        crit = vec2(sqrt(-b / (2.0 * a)), sqrt((-b - sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)));\n        d = min(d, length(p - crit));\n    }\n\n    else {\n        crit = vec2(sqrt((-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a)), 0.0);\n        d = min(d, length(p - crit));\n\n        float h = b * b - 4.0 * a * c;\n        if (h > 0.0) {\n            float x = (-b - sqrt(h)) / (2.0 * a);\n            if (x > 0.0) {\n                crit = vec2(sqrt(x), 0.0);\n                d = min(d, length(p - crit));\n            }\n        }\n    }\n\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float time = iTime * 0.5;\n\n    // Default before user interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.5, 0.5 * sin(time)) * cos(time) * 4.0;\n\n    float a = 16.0;\n    float b = -25.0;\n    float c = mix(-1.0, 12.0, 0.5 + 0.5 * cos(iTime));\n    float dist = sdTanglesquare(uv, a, b, c);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(dist) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-2.0 * abs(dist));\n\tcolor *= 0.8 + 0.2 * cos(100.0 * dist);\n\tcolor = mix(color, vec3(1.0), smoothstep(unit, 0.0, abs(dist * 1.25)));\n\n    // Critical points\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, sdCritical(uv, a, b, c) - 0.05));\n\n    // Visualize mouse distance\n    float mDist = abs(sdTanglesquare(mouse, a, b, c));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - mouse) - 0.025));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(max(abs(uv.x - mouse.x), abs(uv.y - mouse.y)) - mDist) - 0.001));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2SzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 254, 323, 323, 2682], [2684, 2721, 2786, 2786, 3555], [3557, 3557, 3612, 3631, 4852]]}
{"id": "stjXRK", "name": "Looping Rings", "author": "nbardy", "description": "Twisted tourii", "tags": ["torus", "twisted"], "likes": 1, "viewed": 178, "published": 3, "date": "1628123102", "time_retrieved": "2024-07-30T19:07:36.650819", "image_code": "// Author: Nicholas Bardy\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This shader is forked from:\n// \"Torus Knot Tutorial\" \n// Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// https://youtu.be/2dzJZx0yngg\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox2d(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    float r1 = 2.9, r2=.4;\n    vec2 cp = vec2(length(p.xz)-r1, p.y);\n    float a = atan(p.x, p.z); // polar angle between -pi and pi\n    cp *= Rot(a*0.5 + iTime*0.5);\n    cp = abs(cp.xy)-.8;\n    \n    float d = length(cp)-r2;\n    \n    cp *= Rot(a*1.25-iTime*1.0);\n    cp.xy = abs(cp.xy)-.235;\n\n    \n    float d2 = length(cp)-0.17;\n    d = min(d,d2);\n    \n    //cp = abs(cp.xy)-.1;\n    \n    //float d = length(cp)-r2;\n    \n    return d*0.6;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvec3 Bg(vec3 rd) {\n\tfloat k = rd.y*.5+.5;\n    \n    vec3 col = mix(vec3(.2, .1, .1), vec3(.2, .5, 1), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.01, 10, 0);\n    //ro.yz *= Rot(sin(iTime*.1)*3.1415/2.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\t\n    col += Bg(rd);\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float spec = pow(max(0., r.y), 30.);\n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol = mix(Bg(r), vec3(dif), .5)+spec;\n        //col = vec3(spec);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjXRK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[352, 352, 371, 371, 437], [439, 439, 461, 461, 555], [557, 557, 586, 586, 667], [669, 669, 700, 700, 771], [773, 773, 796, 796, 1237], [1239, 1239, 1273, 1273, 1484], [1486, 1486, 1510, 1510, 1700], [1702, 1702, 1752, 1752, 1943], [1946, 1946, 1964, 1964, 2068], [2070, 2070, 2127, 2127, 2872]]}
{"id": "fljSzV", "name": "box and sphere", "author": "jorge2017a1", "description": "box and sphere", "tags": ["boxandsphere"], "likes": 6, "viewed": 244, "published": 3, "date": "1628109650", "time_retrieved": "2024-07-30T19:07:37.643166", "image_code": "//Referencia Iq funciones\n//por jorge2017a1-\n//---4/ago/2021\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   // res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n\n    p.y-=10.0;\n    float tr=iTime*0.5;\n    p= rotate_y( p, tr);\n    mObj.rot=p;\n    float sds1= sdSphere( p, 5.0 );\n    \n    float sdb1= sdBoxFrame( p, vec3(5.0), 0.25 );\n    p= rotate_y( p, tr);\n    float sdb2= sdBoxFrame( p, vec3(6.0), 0.35 );\n    p= rotate_z( p, tr);\n    \n    float sdb3= sdBoxFrame( p, vec3(9.0), 0.45 );\n    p= rotate_x( p, tr);\n    float sdb4= sdBoxFrame( p, vec3(12.0), 0.5 );\n    \n    res =opU3(res, vec3(sds1,100.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sdb2,2.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sdb3,3.0,MATERIAL_NO)); \n     res =opU3(res, vec3(sdb4,4.0,MATERIAL_NO)); \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n    return lin;\n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { \n        vec3 p2=mObj.rot;\n        vec3 col=tex3D(iChannel0, p2/32., nor); return col*2.0; \n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,10.0,-33.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    //col = linear2srgb(col);\n   col = (exposureToneMapping(2.0, col)+ linear2srgb(col))/2.0;\n   \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n    vec3 rot;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljSzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[522, 522, 558, 558, 579], [580, 580, 612, 612, 696], [698, 763, 797, 797, 893], [894, 894, 928, 928, 1019], [1020, 1020, 1054, 1054, 1145], [1187, 1187, 1232, 1232, 1514], [1516, 1556, 1581, 1581, 2443], [2445, 2496, 2520, 2520, 2682], [2684, 2684, 2733, 2733, 3364], [3366, 3420, 3456, 3456, 3701], [3702, 3757, 3784, 3784, 3801], [3803, 3803, 3839, 3839, 3931], [3932, 3932, 3978, 3978, 4103], [4105, 4105, 4179, 4179, 5737], [5738, 5793, 5842, 5842, 6126], [6127, 6161, 6241, 6241, 6364], [6365, 6406, 6438, 6438, 6635], [6637, 6685, 6713, 6713, 6901], [6904, 6955, 7002, 7002, 7246], [7248, 7300, 7393, 7393, 7881], [7884, 7884, 7915, 7915, 8505], [8507, 8556, 8582, 8582, 8692], [8694, 8694, 8752, 8752, 8804], [8806, 8855, 8912, 8912, 9527]]}
{"id": "Nt2XRV", "name": "FractalPractice01", "author": "lambmeow", "description": "fractal", "tags": ["fractal", "sdf"], "likes": 0, "viewed": 199, "published": 3, "date": "1628107380", "time_retrieved": "2024-07-30T19:07:38.654462", "image_code": "#define time iTime\n#define resolution iResolution\nfloat c  =0.;\n\nmat2 rot(float f)\n{\n\tfloat s = sin(f), c = cos(f);\n\treturn mat2(c, -s , s, c);\n}\nfloat scene(vec3 p)\n{\n\t\n    for( int i = 0; i<10; ++i){\n        float t = time*.2;\n        p = abs(p -.2);\n        p.xy *= rot(t + c);\n\t\t\n        c -= .1;\n\t}\n\t\n\tfloat thing = max(dot(p , normalize(vec3(45., 0.,-524.))), length(p) - 2.);\n\t\n\treturn max(thing, p.y);\n}\n\n\nvec3 calcnorm(vec3 value)\n{\n    vec3 n = vec3(0);\n    if(length(n - value) == 0.)\n    \treturn vec3(0);\n    for(int i = 0; i < 4; i++)\n    {\n        vec3 eps = 0.001 * (vec3(9 >> i&1, i >> 1 & 1, i & 1) * 2. - 1.);\n        n += eps * scene(value + eps);\n    }\n    return normalize(n);\n}\n\n\nvec4 rc(vec3 ro, vec3 rd)\n{\n\tfloat len = 0.;\n\tfloat closest = 100.;\n\tfor(int i = 0; i < 255; i ++)\n\t{\n\t\tfloat dist = scene(ro + rd * len);\n\t\t\n\t\tclosest = min(closest, dist/.01);\n\t\tif(dist < 0.001)\n\t\t\treturn vec4(ro + rd * len,closest);\n\t\t\n\t\tlen += dist;\n\t\t\n\t\tif(len  > 100. ) \n\t\t\tbreak;\n\t}\n\t\n\treturn vec4(ro + rd * len,closest);\n}\n\nmat3 cam(vec3 pos, vec3 la, vec3 up)\n{\n\tvec3 ww = normalize(la - pos);\n\tvec3 vv = normalize(up);\n\tvec3 uu = normalize(cross(ww, vv));\n\treturn mat3(ww, uu ,vv);\n} \n\n\nvec3 pallete( vec3 pos)\n{\n\tfloat len = length(pos) / 15.;\n\t\n\treturn mix(1.- vec3 (0., 0.5, 0.7), 1.-vec3(1., 0.,10.), len)/100.; \n}\nvec3 color(vec4 pos)\n{\n\tvec3 lightcolor = vec3( 1, 1, 1), lightpos = vec3(0, 4, -4);\n\tvec3 norm = calcnorm(pos.xyz);\n\t\n\treturn pallete(pos.xyz)- (1./(1. + (pos.w * 0.3))) * vec3(0,1,1);\n}\n\nvoid mainImage(out vec4 fc , in vec2 uv)\n{\n\tvec2 r = resolution.xy, u = ((2.*uv) - r)/r.y;\n\t\n\tvec3 ro = vec3(0., 0., -4.);\n\n\tvec3 rd = normalize(vec3(u, 2.0));\n\t\n\n\t\n\tfc = vec4(color(rc(ro,rd) ), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 84, 84, 145], [146, 146, 167, 167, 411], [414, 414, 441, 441, 699], [702, 702, 729, 729, 1032], [1034, 1034, 1072, 1072, 1195], [1199, 1199, 1224, 1224, 1330], [1331, 1331, 1353, 1353, 1518], [1520, 1520, 1562, 1562, 1721]]}
{"id": "7lBXWh", "name": "Torii Gate In Water", "author": "intrakits", "description": "Still a work in progress.\nMy attempt at making some cool japanese torii gates.\nI wanted to improve my skills at making water and reflections.\nI need to figure out how to make the sky and lighting better. Those r still weak points for me.", "tags": ["water", "ocean", "japan", "gate", "tori"], "likes": 8, "viewed": 285, "published": 3, "date": "1628099930", "time_retrieved": "2024-07-30T19:07:39.853257", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 200.\n#define SURFACE_DIST 0.01\n#define AA 1\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat sam = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * sam;\n\t\taccum += sam;\n\t}\n\n\treturn value/accum;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat getDisp(vec2 uv){\n\n    vec2 p = 0.5 - 0.5*sin(vec2(1.01,1.71) );\n    p = vec2(1.0, 1.0);\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = iqnoise(24.0*uv, p.x, p.y);\n\t\n\treturn f;\n}\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\nvec2 torii(vec3 p){\nvec2 uv = vec2(atan(p.x,p.z)/(3.14159*100.),p.y/17.);\n    float off = texture(iChannel1,uv).r*.4;\n    \n    //vec2 uv2 = vec2(atan(p.x,p.z)/(3.14159),p.y);\n    vec2 uv2 = p.xy/2.;\n    float off2 = texture(iChannel1,uv2).r*.06;\n   \n    float legHeight = 15.;\n    float legPos = 5.2;\n    float footingPos = 5.;\n    float legDist = -40.;\n    float angle = 1.5;\n    float legTaper = 1.-p.y*.04;\n    \n    vec2 leg = vec2(sdCylinder(p-vec3(-legPos,0,legDist), vec3(0,0,0), vec3(angle,legHeight,0), legTaper),2.);\n    vec2 footing = vec2(sdCylinder(p-vec3(-footingPos,0,legDist), vec3(0,0,0), vec3(0,3,0), 1.3-p.y*.05),3.);  \n    footing.x -=off2+off;\n    leg = colMin(leg, footing);\n    //leg.x-=off;\n    //leg.x-=off2;\n    vec2 res = leg;\n    \n    leg = vec2(sdCylinder(p-vec3(legPos,0,legDist), vec3(0,0,0), vec3(-angle,legHeight,0), legTaper),2.);\n    footing = vec2(sdCylinder(p-vec3(footingPos,0,legDist), vec3(0,0,0), vec3(0,3,0), 1.3-p.y*.05),3.);\n    footing.x -=off2+off;\n    leg = colMin(leg, footing);\n    //leg.x-=off;\n   // leg.x-=off2;\n    res = colMin(leg, res);\n    \n    vec2 beam = vec2(dBox(p-vec3(0,13,-40), vec3(8,.3,.1)),2.);\n    res = colMin(beam,res);\n    \n    vec2 curveBot = vec2(dBox(p-vec3(0,pow(2.,abs(p.x)*.15)+13.5,-40), vec3(8,.3,1)),2.);\n    res = colMin(curveBot,res);\n    vec2 curveTop = vec2(dBox(p-vec3(0,pow(2.,abs(p.x)*.15)+14.3,-40), vec3(9,.5,1.5)),3.);\n    curveTop.x-=off2*2.;\n    res = colMin(curveTop,res);\n    vec3 rotP = p;\n    rotP-=vec3(0,13.5,-40);\n    //rotP.xz *= Rot(iTime);\n    //rotP.xy *= Rot(iTime);\n    rotP.zy *= Rot(3.5);\n    vec2 kanban = vec2(dBox(rotP,vec3(1,2,.4)),4.);\n    res = colMin(res, kanban);\n   // sdCylinder(vec3 p, vec3 a, vec3 b, float r) \n    vec2 rope =vec2(sdCylinder(p-vec3(0,11.-sin(p.x/2.+3.1415/2.)*2.,-39.5), vec3(-4., 0,0),vec3(4., 0,0), .3) ,5.);\n    res = colMin(res, rope);\n    return res;\n}\nvec2 GetDist(vec3 p){\n    float wave = 0.0;\n\t\n    wave = noise( p.xz/5.+iTime*.6 );\n\n\twave = 0.5 + 0.5*wave;\n    \n    float wave2 = 0.0;\n\t\n    wave2 = noise( p.xz/5.-vec2(0,iTime*.5) );\n\n\twave2 = 0.5 + 0.5*wave2;\n    float off = wave+wave2;\n   // float off =sin(5.*iTime+p.x)*.1+sin(3.*iTime+p.z)*.1;\n    //off*=sin(iTime+p.x*2.);\n    //off+=sin(7.*iTime+(length(p)-.4)*7.*smoothstep(7.,1.,length(p)-.4))*.01;\n    //float off = iqnoise(p.xz/5.+iTime, .9, .9);\n    \n    vec2 po = 0.5 - 0.5*cos(vec2(2.,1.3) );\n    \n\t//if( iMouse.w>0.001 ) p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy/iResolution.xy;\n\t\n\t//p = p*p*(3.0-2.0*p);\n\t//p = p*p*(3.0-2.0*p);\n\t//p = p*p*(3.0-2.0*p);\n\t\n\t//float off = voronoise( p.xz/10.+iTime, po.x, po.y );\n    vec3 rockP = p;\n    \n    rockP.z = mod(rockP.z, 10.0)-4.5;\n    vec3 ripPos = vec3(-4.5,0,0);\n    float rip1=sin(7.*iTime+(length(rockP-ripPos)-.4)*7.*smoothstep(4.,2.,length(rockP-ripPos)-.4))*.01;\n\n    float rip2=sin(3.*iTime+(length(rockP-ripPos)-.1)*7.*smoothstep(3.,2.,length(rockP-ripPos)-.4))*.01;\n    off+=rip1+rip2;\n    ripPos = vec3(4.5,0,0);\n    rip1=sin(7.*iTime+(length(rockP-ripPos)-.4)*7.*smoothstep(4.,2.,length(rockP-ripPos)-.4))*.01;\n\n    rip2=sin(3.*iTime+(length(rockP-ripPos)-.1)*7.*smoothstep(3.,2.,length(rockP-ripPos)-.4))*.01;\n    off+=rip1+rip2;\n    vec2 res = vec2(p.y-off,1.);\n    vec3 rotP = p;\n    \n    rotP.z = mod(rotP.z, 10.0)-44.; // 'fold space' every 2 units.\n    //rotP.xz*=Rot(6.6);\n    res = colMin(torii(rotP),res);\n    \n    //add rocks\n    rockP-=vec3(-100,0,0);\n    /*float off2 = texture(iChannel1,p.xz/40.).r*5.;\n    float off3 = texture(iChannel1,p.xz/100.).r*10.;\n    vec2 rocks = vec2(sdCylinder(rockP, vec3(0,0,0), vec3(0,1,0), 10.+mod(p.z/10.,10.)),7.);\n    rocks.x-=off2+off3;\n    res = colMin(res, rocks);\n    rockP-=vec3(-40,0,0);\n    */\n    //vec2 uv = vec2(atan(p.x,p.z)/(3.14159*3.),p.y/20.-off);\n    float off4 = texture(iChannel1,p.zy/20.).r;\n    vec2 rocks = vec2(sdCylinder(rockP, vec3(0,0,0), vec3(0,20,0), 10.+mod(p.z/10.,10.)),7.);\n    rocks.x-=off4;\n    \n    res = colMin(res, rocks);\n    //res = light;\n    return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    vec2 dO=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        \n        // get distance to seam\n        vec2 ds = GetDist(p);\n        //move origin to new point\n        \n        /*if(ds.y==7.){\n            dO+=ds.x*.4;\n        }\n        else{\n            dO+=ds.x*.7;\n        }*/\n         dO+=ds.x*.8;\n        if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(40,100,30.-iTime);\n    \n    //lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat DrawSquare (vec2 uv, float width, float height, float posX, float posY, float blur){\n    float w = length((uv.x + posX));\n    float h = length(uv.y + posY);\n    float col = smoothstep(width,width-blur, w);\n    col *= smoothstep(height,height-blur, h);\n    return col;\n}\nvec3 A (vec2 uv){\n    vec3 base =vec3(1)*DrawSquare (uv-vec2(0,0), .1-uv.y*.2, .2, 0., 0., .01);\n    vec3 mask =vec3(1)*DrawSquare (uv-vec2(0,.1), .05-uv.y*.2, .07, 0., 0., .01);\n    vec3 mask2 =vec3(1)*DrawSquare (uv-vec2(0,-.1), .05-uv.y*.2, .1, 0., 0., .01);\n    return base - mask - mask2;\n}\nvec3 X (vec2 uv){\n    vec3 slashR = vec3(1)*DrawSquare (uv-vec2(uv.y*.5,0), .04, .2, 0., 0., .01);\n    vec3 slashL = vec3(1)*DrawSquare (uv-vec2(-uv.y*.5,0), .04, .2, 0., 0., .01);\n    return slashR+slashL;\n}\nvec3 coneText(vec2 uv){\n    vec3 col = A(uv-vec2(-.3,0))+X(uv-vec2(0,0));\n    return col;\n}\nvec3 rad1(vec2 uv, vec3 col){\n    vec3 a = col*DrawSquare (uv-vec2(0.), .1, .03, 0., 0., .01);\n    vec3 b = col*DrawSquare (uv-vec2(0.,pow((-uv.x-.1),1.2)-.14), .1, .03, 0., 0., .01);\n    vec3 c = col*DrawSquare (uv-vec2(0.,-.17), .03, .1, 0., 0., .01);\n    vec3 d = col*DrawSquare (uv-vec2(0.,.05), .03, .06, 0., 0., .01);\n    vec3 e = col*DrawSquare (uv-vec2(0.056,-uv.x-.04), .04, .04, 0., 0., .01);\n    a=max(a,b);\n    a=max(a,c);\n    a=max(a,d);\n    a=max(a,e);\n    return a;\n}\n\nvec3 rad2(vec2 uv, vec3 col){\n    vec3 a = col*DrawSquare (uv-vec2(0.,-.08), .03, .19, 0., 0., .01);\n    vec3 b = col*DrawSquare (uv-vec2(0.1,-.06), .03, .1, 0., 0., .01);\n    vec3 c = col*DrawSquare (uv-vec2(-0.1,-.06), .03, .1, 0., 0., .01);\n    vec3 d = col*DrawSquare (uv-vec2(0,-.05), .1, .03, 0., 0., .01);\n    vec3 e = col*DrawSquare (uv-vec2(0,+.01), .1, .03, 0., 0., .01);\n    vec3 f = col*DrawSquare (uv-vec2(0,-.11), .1, .03, 0., 0., .01);\n    \n    a=max(a,b);\n    a=max(a,c);\n    a=max(a,d);\n    a=max(a,e);\n    a=max(a,f);\n    return a;\n}\n\nvec3 rad3(vec2 uv, vec3 col){\n    vec3 a = col*DrawSquare (uv-vec2(0.,-.08), .03, .19, 0., 0., .01);\n    vec3 b = col*DrawSquare (uv-vec2(0,-.25), .12, .03, 0., 0., .01);\n    vec3 c = col*DrawSquare (uv-vec2(0,-.05), .1, .03, 0., 0., .01);\n    \n    a=max(a,b);\n    a=max(a,c);\n    return a;\n}\n\nvec3 jin(vec2 uv, vec3 col){\n    return rad1(uv,col)+rad2(uv-vec2(0.25,0.),col);\n}\n\nvec3 ja(vec2 uv,vec3 col){\n    return rad1(uv,col)+rad3(uv-vec2(0.2,0.),col);\n}\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p)*2.;\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    //vec3 refl = texture(iChannel0, r).rgb;\n    vec3 refl = vec3(r.y*2.+.5)+vec3(0,.2,r.y+.5);\n    //refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    float fresnel = dot(n,-rd);\n    if(d.y == 1.){\n        col *= vec3(0,.7,1);\n        //col*=refl*.4;\n        col*=vec3(fresnel);\n        reflVal = 0.8;\n    }\n    else if(d.y==2.){\n       vec2 uv = vec2(atan(p.x,p.z)/(3.14159*100.),p.y/17.);\n       float off = texture(iChannel1,uv).r*.4;\n\n       //vec2 uv2 = vec2(atan(p.x,p.z)/(3.14159),p.y);\n       vec2 uv2 = p.xy/2.;\n       float off2 = texture(iChannel1,uv2).r*.06;\n\n       col *= vec3(1,0,0);\n       col = max(col, smoothstep(0.1,0.2,off2)*vec3(.5));\n       reflVal = 0.2;\n    }\n    else if(d.y==3.){\n        col *= vec3(0.2);\n        reflVal = 0.3;\n    }\n    else if(d.y==4.){\n      vec2 uv =p.xy;\n      col*=vec3(.3);\n      uv.y-=14.;\n      uv.x-=-.5;\n      vec3 gold = vec3(.855,.647,.125);\n      vec3 txt=(jin(uv*.3,gold)+ja((uv*.3)-vec2(0,-.4),gold));\n      col = max(txt*abs(n.y) + txt*abs(n.z) + txt*abs(n.x),col);\n      reflVal=0.3;\n    }\n    else if(d.y==5.){\n      col*=vec3(1.);\n      reflVal=0.;\n    }\n    else if(d.y==6.){\n      col*=vec3(1.,1,0);\n      col.xy*=sin(iTime*3.)*.5+.5;\n      reflVal=0.;\n    }\n    else if(d.y==7.){\n      col*=vec3(.8);\n      col = mix(col,smoothstep(4.,1.,p.y)*vec3(.5,1,0),.5);\n     // col.xy*=sin(iTime*3.)*.5+.5;\n      reflVal=0.;\n    }\n    else{\n        col=texture(iChannel0, rd).rgb;\n        col = vec3(rd.y*2.+.5)+vec3(0,.2,rd.y+.5);\n        reflVal =0.0;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    \n    float time = iTime*.5;\n    float exp1 = cos(time);\n    float exp22 = pow(sin(time)+1.5,exp1);\n    float rot = pow(sin(time)+1.3,abs(exp22));\n    vec3 ta = vec3( 15.-rot, 15, -iTime);\n    //float rot = pow(pow(sin(iTime)+1.,abs(pow(sin(iTime)+1.,cos(iTime)))));\n    vec3 ro = ta + vec3(.3+rot,.2+(sin(iTime*.2)*.3+.3), 1);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    \n    \n    float reflVal = 1.;\n    vec3 col = Render(ro,rd,reflVal);\n    vec3 bounce = .3*reflVal*Render(ro,rd,reflVal);\n    col += bounce;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 140, 140, 255], [257, 257, 283, 283, 762], [763, 763, 785, 785, 936], [938, 938, 986, 986, 1378], [1379, 1379, 1408, 1408, 1436], [1438, 1438, 1458, 1458, 1565], [1567, 1567, 1587, 1587, 1650], [1652, 1652, 1715, 1715, 2765], [2767, 2767, 2786, 2786, 2848], [2849, 2849, 2900, 2900, 3184], [3186, 3186, 3235, 3258, 3691], [3693, 3693, 3723, 3723, 3794], [3796, 3796, 3823, 3823, 3862], [3863, 3863, 3927, 3927, 4178], [4179, 4179, 4211, 4211, 4312], [4313, 4353, 4391, 4391, 4488], [4490, 4530, 4571, 4571, 4643], [4644, 4644, 4702, 4702, 4803], [4804, 4804, 4827, 4827, 5022], [5023, 5023, 5070, 5070, 5103], [5104, 5104, 5123, 5123, 6995], [6996, 6996, 7017, 7017, 9114], [9115, 9115, 9147, 9175, 9808], [9809, 9809, 9832, 9871, 10242], [10243, 10243, 10266, 10301, 11252], [11253, 11253, 11305, 11305, 11482], [11483, 11483, 11573, 11573, 11758], [11759, 11759, 11776, 11776, 12054], [12055, 12055, 12072, 12072, 12263], [12264, 12264, 12287, 12287, 12355], [12356, 12356, 12385, 12385, 12838], [12840, 12840, 12869, 12869, 13391], [13393, 13393, 13422, 13422, 13685], [13687, 13687, 13715, 13715, 13769], [13771, 13771, 13797, 13797, 13850], [13851, 13851, 13915, 13936, 15833]]}
{"id": "fljXzK", "name": "Distance to Flower", "author": "oneshade", "description": "Using a newton-raphson solver to get the distance to a flower shape (only works with 3-12 \"petals\" right now).", "tags": ["2d", "sdf", "flower", "distance", "iterative"], "likes": 18, "viewed": 211, "published": 3, "date": "1628098253", "time_retrieved": "2024-07-30T19:07:40.896468", "image_code": "vec3 dMul(in vec3 f, in vec3 g) { return vec3(f.x * g.x, f.y * g.x + f.x * g.y, f.z * g.x + 2.0 * f.y * g.y + f.x * g.z); }\nvec3 dCos(in vec3 f) { float co = cos(f.x), si = sin(f.x); return vec3(co, -si * f.y, -co * f.y * f.y - si * f.z); }\nvec3 dSin(in vec3 f) { float co = cos(f.x), si = sin(f.x); return vec3(si,  co * f.y, -si * f.y * f.y + co * f.z); }\n\n// c: radius\n// a: petal length (amplitude)\n// f: number of petals (frequency)\n#define PI 3.14159265359\nfloat sdFlower(in vec2 p, in float c, in float a, in float f) {\n    float ang = mod(atan(p.y, p.x) + PI / f, 2.0 * PI / f) - PI / f;\n    p = vec2(cos(ang), sin(ang)) * length(p);\n    p.y = abs(p.y);\n\n    float t = 0.5 * PI / f;\n    if (p.x < c - a && a < 0.5 * c) t *= 1.5;\n    if (p.x > c + a) t = f < 4.0 ? 0.25 : 0.1;\n\n    for (int n=0; n < 10; n++) { // 6 seems enough but 10 for extra precision\n        vec3 r = vec3(c, 0.0, 0.0) + a * dCos(f * vec3(t, 1.0, 0.0));\n        vec3 dx = dMul(dCos(vec3(t, 1.0, 0.0)), r) - vec3(p.x, 0.0, 0.0);\n        vec3 dy = dMul(dSin(vec3(t, 1.0, 0.0)), r) - vec3(p.y, 0.0, 0.0);\n        vec3 dist = dMul(dx, dx) + dMul(dy, dy);\n        t -= dist.y / dist.z;\n    }\n\n    float r = c + a * cos(f * ang);\n    return length(p - vec2(cos(t), sin(t)) * (c + a * cos(f * t))) * sign(dot(p, p) - r * r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 5.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 6.0; // Slight lag to maintain visibility\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(6.0, 3.0);\n\n    float c = mix(0.5, 1.5, 0.5 + 0.5 * cos(iTime * 0.25));\n    float a = (0.5 + 0.5 * cos(iTime)) * c;\n    float f = floor(mix(3.0, 12.0, 0.5 + 0.5 * sin(iTime * 0.25)));\n    float d = sdFlower(uv, c, a, f);\n    d *= 0.5; // Undo UV scaling and shrink the isolines a bit for visual purposes\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), smoothstep(0.015, 0.0, abs(d)));\n\n    //color = mix(color, vec3(1.0), smoothstep(0.015, 0.0, abs(uv.x - 0.5 * ab.x / sqrt(2.0)) - 0.02));\n    //color = digitIn(color, vec3(0.0, 1.0, 0.0), uv * 0.1, 100.0, ab.y / ab.x);\n\n    fragColor = vec4(color, 1.0);\n    //if (uv.y > tan(PI / f) * uv.x || uv.y < 0.0) fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 123], [124, 124, 146, 146, 240], [241, 241, 263, 263, 357], [463, 463, 526, 526, 1298], [1300, 1300, 1355, 1355, 2458]]}
{"id": "sljXzy", "name": "circular xor", "author": "masterlee", "description": "circular XOR pattern from mouse position with smooth transition", "tags": ["xor"], "likes": 1, "viewed": 229, "published": 3, "date": "1628087670", "time_retrieved": "2024-07-30T19:07:41.830969", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d1=clamp(2.0*sin(distance(fragCoord.xy,iMouse.xy)/10.),-1.0,1.0);\n    float d2=clamp(2.0*sin(distance(fragCoord.xy,abs(iMouse.zw))/10.),-1.0,1.0);\n    float f=d1*d2*.5;    \n    fragColor = vec4(.5-f,.5+f,.5-f,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 284]]}
{"id": "slSXzV", "name": "Happy Chinese Valentine!", "author": "letian", "description": "Happy Chinese Valentine!", "tags": ["basedonotherscreation"], "likes": 6, "viewed": 265, "published": 3, "date": "1628074475", "time_retrieved": "2024-07-30T19:07:42.847252", "image_code": "#define SHADERTOY\n\n// -- Uniforms -----------------------------------------------------------------\n\n#ifndef SHADERTOY\nuniform vec3 iResolution;\nuniform vec3 iMouse;\nuniform float iTime;\nuniform sampler2D iChannel0;\n#endif\n\n// -- Constants ----------------------------------------------------------------\n\n// Camera constants\n\nconst float kFOV = 0.785398;                           // Camera field of view \n\n// RayMarching constants\n\nconst int kMaxSteps = 100;                              // Max number of raymarching steps\nconst float kMaxDistance = 55.0;                       // Max raymarching distance\nconst float kBias = 0.01;                              // Bias offset for normal estimation\nconst float kNoHit = -1.0;                             // No intersection distance.\n\n// Scene constants.\nconst vec3 kSkyColor = vec3(0.5, 0.12, 0.5);          // Night sky color.\nconst vec3 kSkyHorzColor = vec3(0.4, 0.2, 0.87);       // Night sky horizon color.\n\nconst vec3 kMoonDir = vec3(-0.18443, 0.3688, -0.9221); // Moon direction.\nconst vec3 kMoonColor = vec3(1.0, 1.0, 0.8);           // Moon color.\nconst vec3 kMoonSkyByColor = vec3(0.9, 0.6, 1);      // Moon glow color.\nconst float kMoonCosRange = 0.999;                     // Moon cosine range.\n\n// Material constants.\nconst float kMaterialNone = 0.0;\nconst float kMaterialHeart = 1.0;\nconst float kMaterialWater = 2.0;\n\n// Other constants\n\nconst vec3 kOnes = vec3(1.0, -1.0, 0.0);               // Helper vector with ones.\nconst float kPI = 3.14159265359;                       // PI\n\n// -- Global values ------------------------------------------------------------\n\nfloat gAnimTime;\n\nvec3  gHeartPos;\nfloat gHeartMorph;\nfloat gHeartColoring;\n\nfloat gWaveTime;\n\nfloat gMsgFadeInTime;\nfloat gFadeTime;\n\n\n// -- Structures ---------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct RayHit\n{\n    float time;\n    float material;\n};\n\nstruct DistanceSample\n{\n    float dist;\n    float stepRatio;\n    float material;\n};\n\n    \n// --- Math funcs --------------------------------------------------------------\n\n// Build quaternion from axis angle\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n    float theta = 0.5 * angle;\n    float sine = sin(theta);\n    return vec4(sin(theta) * axis, cos(theta));\n}\n\n// Builds the conjugate quaternion\nvec4 QuatConjugate(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\n// Rotates a vector around the quaternion\nvec3 QuatTransformVec(vec3 v, vec4 q)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\n// -- Noise funcs --------------------------------------------------------------\n\n// Hash noise function from I. Quilez\nfloat Hash(float p)\n{\n    float h = p * 127.1;\n    return fract(sin(h)*43758.5453123);\n}\n\n// Hash noise function from I. Quilez\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(127.1,311.7));    \n    return fract(sin(h)*43758.5453123);\n}\n\n// Modified Hash noise function for 3D hashing.\nfloat Hash(vec3 p)\n{\n    float h = dot(p, vec3(127.1, 311.7, 511.9));    \n    return fract(sin(h)*43758.5453123);\n}\n\n// 2D Perlin Noise\nfloat PerlinNoise(vec2 p)\n{    \n    vec2 i = floor(p);\n    vec2 f = fract(p);  \n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i + kOnes.zz), Hash(i + kOnes.xz), u.x);\n    float f01 = mix(Hash(i + kOnes.zx), Hash(i + kOnes.xx), u.x);\n    float f1 = mix(f00, f01, u.y);\n    \n    return 2.0 * f1 - 1.0;\n}\n\n// 3D Perlin Noise\nfloat PerlinNoise(vec3 p)\n{    \n    vec3 i = floor(p);\n    vec3 f = fract(p);  \n    vec3 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i + kOnes.zzz), Hash(i + kOnes.xzz), u.x);\n    float f01 = mix(Hash(i + kOnes.zxz), Hash(i + kOnes.xxz), u.x);\n    float f02 = mix(Hash(i + kOnes.zzx), Hash(i + kOnes.xzx), u.x);\n    float f03 = mix(Hash(i + kOnes.zxx), Hash(i + kOnes.xxx), u.x);\n    \n    float f10 = mix(f00, f01, u.y);\n    float f11 = mix(f02, f03, u.y);\n    \n    float f2 = mix(f10, f11, u.z);\n    \n    return 2.0 * f2 - 1.0;\n}\n\n// Fractional Brownian Motion from I. Quilez\n// https://iquilezles.org/articles/warp\n// In the end, it's a sum of Perlin Noise functions with increasing frequencies\n// and decreasing amplitudes. To enhance the noise, a rotation matrix is applied\n// at each step.\n\nconst mat2 FBM_M2 = mat2(0.84147, 0.54030, 0.54030, -0.84147);\nconst mat3 FBM_M3 = mat3(0.00, 0.90, 0.60, -0.90, 0.36, -0.48, -0.60, -0.48, 0.34 );\n\nfloat FBM(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*PerlinNoise(p); p = FBM_M2 * p * 2.02;\n    f += 0.2500*PerlinNoise(p); p = FBM_M2 * p * 2.03;\n    f += 0.1250*PerlinNoise(p); p = FBM_M2 * p * 2.01;\n    //f += 0.0625*PerlinNoise(p);\n    //return f/(0.9375);\n    return f/(0.8750);\n}\n\nfloat FBM(vec3 p)\n{\n    float f = 0.0;\n    f += 0.5000*PerlinNoise(p); p = FBM_M3 * p * 2.02;\n    f += 0.2500*PerlinNoise(p); p = FBM_M3 * p * 2.33;\n    f += 0.1250*PerlinNoise(p); p = FBM_M3 * p * 2.01;\n    f += 0.0625*PerlinNoise(p); \n    return f/(0.9175);\n}\n\n// -- Camera funcs -------------------------------------------------------------\n\nRay ViewportToRay(vec2 uv, vec3 offs, vec4 rot)\n{\n    Ray ray;\n    ray.direction = QuatTransformVec(normalize(vec3(uv * tan(kFOV * 0.5), -1.0)), rot);\n    ray.origin = offs;\n    \n    return ray;\n}\n\nRay ReflectRay(Ray ray, float d, vec3 n)\n{\n    ray.origin += ray.direction * d;\n    ray.direction = reflect(ray.direction, n);\n    return ray;\n}\n\nDistanceSample NewDistanceSample(float d, float s, float m)\n{\n    DistanceSample h;\n    h.dist = d;\n    h.stepRatio = s;\n    h.material = m;\n    return h;\n}\n\nRayHit NewRayHit(float t, float m)\n{\n    RayHit h;\n    h.time = t;\n    h.material = m;\n    return h;\n}\n\n// -- Water funcs --------------------------------------------------------------\n\n// Computes the height of a wave at the specified point\nfloat WaveDirectional(vec2 p, float wavelength, float speed, vec2 direction, float amplitude)\n{\n    float freq = 2.0 * kPI / wavelength;\n    float phase = speed * freq;\n    float theta = dot(direction, p);\n\n    return amplitude * pow(sin(theta * freq + gAnimTime * phase), 3.0);\n}\n\nfloat WavePunctual(vec2 p, float wavelength, float speed, vec2 perturb, float amplitude, float waveTime)\n{\n    float freq = 2.0 * kPI / wavelength;\n    float phase = speed * freq;\n    float dist = -length(p - perturb);\n    amplitude /= 1.0 + (0.3 * -dist) + (0.15 * waveTime * waveTime);\n\n    return amplitude * pow(sin(max(0.0, dist * freq + waveTime * phase)), 3.0);\n}\n\n// -- SDF funcs ----------------------------------------------------------------\n\n// Signed Distance Field of a point to a heart located at the origin. It works by computing\n// the SDF of a sphere whose space has been distorted by a polar function\nDistanceSample SDFHeart(vec3 p)\n{\n    // Apply noise to position when it's a drop.\n    if (gHeartMorph < 1.0)\n        p += 0.16 * FBM(p + vec3(0, gAnimTime * 2.5, 0)) * (1.0 - gHeartMorph);\n    \n    // Apply domain distortion for heart.\n    float a0 = atan(p.x, p.y);\n    float a1 = atan(p.x, p.z);\n    float b0 = abs(a0 / kPI);\n    float b1 = abs(a1);\n    float l = length(p.xy);\n    \n    // Constants computed with Octave:\n    // x = [   0; 0.35;  0.53;   1; ];\n    // y = [ 0.6;  1.0;  0.9; 1.2; ];\n    // K = polyfit(x, y, 3);\n    const vec4 K = vec4(6.34975, -9.8705, 4.39112, 0.4);\n    vec4 B = vec4(b0 * b0 * b0, b0 * b0, b0, 1.0);\n    \n    float d0 = dot(K, B);\n    d0 = mix(1.0, d0, smoothstep(0.0, 0.7, l));\n    float d1 = 1.0 - 0.5*abs(cos(a1));\n    \n    p.xy /= mix(1.0, d0, gHeartMorph);\n    p.z  /= mix(1.0, d1, gHeartMorph);\n    \n    // Increase size whenever the mouse is close.\n\tfloat mouseOverSize = 1.0+0.7*smoothstep(0.2, 0.0, length((iMouse.xy / iResolution.xy) - 0.5));\n\t\n    // Compute sphere's SDF\n    return NewDistanceSample(length(p) - 0.8 - 0.5 * gHeartMorph * mouseOverSize, 0.5, kMaterialHeart);\n}\n\n// Signed Distance Field of a point to the water plane located at the origin.\n// It's simply the distance to a plane distorted by the wave field.\nDistanceSample SDFWater(vec3 p)\n{\n    const float overallSpeed = 0.7;\n    float height = 0.0;\n    height -= FBM(vec3(p.xz * 0.5, 0.75 * gAnimTime)) * 0.05;\n    height += WavePunctual(p.xz, 12.0, 1.5, vec2(0.0, -12.0), 2.0, gWaveTime);\n    \n    return NewDistanceSample(p.y - 1.5 * height, 1.0, kMaterialWater);\n}\n\n// -- SDF CGS funcs ------------------------------------------------------------\n\nDistanceSample OpUnion(DistanceSample d1, DistanceSample d2)\n{\n    if (d1.dist < d2.dist) return d1; return d2;\n}\n\nDistanceSample OpSubstract(DistanceSample d1, DistanceSample d2)\n{\n    d2.dist = -d2.dist;\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistanceSample OpIntersect(DistanceSample d1, DistanceSample d2)\n{\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistanceSample OpSmoothMin(DistanceSample d1, DistanceSample d2, float k)\n{\n    float h = clamp(0.5+0.5*(d2.dist - d1.dist)/k, 0.0, 1.0);\n    \n    DistanceSample d;\n    d.dist = mix(d2.dist, d1.dist, h) - k * h * (1.0-h);\n    d.stepRatio = min(d2.stepRatio, d1.stepRatio);\n    d.material = mix(d2.material, d1.material, h);\n    \n    return d;\n}\n\n// -- Transform funcs ----------------------------------------------------------\n\nvec3 Tx(vec3 p, vec3 tx)\n{\n    return (p - tx);\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec4 q)\n{\n    p -= tx;\n    return QuatTransformVec(p, QuatConjugate(q));\n}\n\n// --- Scene funcs -------------------------------------------------------------\n\nDistanceSample Scene(vec3 position)\n{\n    // Evaluate scene distances.\n    DistanceSample d0 = SDFHeart(Tx(position, gHeartPos, QuatFromAxisAngle(vec3(0.,1.,0.), gAnimTime*1.7)));\n    DistanceSample d1 = SDFWater(Tx(position, vec3(0,-2,0)));\n    return OpSmoothMin(d0, d1, 0.8);\n}\n\nvec3 SceneNormal(vec3 position)\n{\n    vec2 offset = vec2(kBias, 0.0);\n    float d = Scene(position).dist;\n    \n    return normalize(vec3\n    (\n        Scene(position + offset.xyy).dist - d,\n        Scene(position + offset.yxy).dist - d,\n        Scene(position + offset.yyx).dist - d\n    ));\n}\n\nvec3 SkyColor(vec3 n)\n{\n    // Compute the sky color from hemisphere. \n    float h = 1.0 - pow(abs(n.y), 0.4);\n    vec3 color = mix(kSkyColor, kSkyHorzColor, h);\n    \n    // Add stars.\n    float s = pow(max(0.0, PerlinNoise(n * 4e2)), 18.0);\n    color.rgb += vec3(s, s, s);\n    \n    // Add moon and moon light.\n    float dotNM = dot(n, kMoonDir);\n    color = mix(color, kMoonColor, smoothstep(0.0, 0.0001, dotNM - kMoonCosRange));\n    color += kMoonSkyByColor * pow(max(0.0, dotNM), 100.0);\n    \n    return color;\n}\n\nRayHit Raymarch(Ray ray)\n{\n    float t = 0.0;\n    DistanceSample d;\n    \n    for (int i = 0; (i < kMaxSteps); i++)\n    {\n        d = Scene(ray.origin + ray.direction * t);\n        t += d.dist * d.stepRatio;\n        \n        if ((d.dist < 0.0) || (t >= kMaxDistance))\n            break;\n    }\n    \n    if (t < kMaxDistance)\n        return NewRayHit(t, d.material);\n    \n    return NewRayHit(kNoHit, kMaterialNone);\n}\n\nfloat SparkCircle(vec2 uv, vec2 center, float rad)\n{\n    float d = length(uv - center);\n    return smoothstep(rad, 0.0, d);\n}\n\nfloat SparkRect(vec2 uv, vec2 center, vec2 size, float ang)\n{\n    vec2 cs = vec2(cos(ang), sin(ang));\n    uv -= center;\n    uv = vec2(dot(uv, cs), dot(uv.yx * vec2(-1.0, 1.0), cs));\n    \n    vec2 x = smoothstep(size*0.5, vec2(0.0, 0.0), abs(uv));\n    return pow(x.x * x.y, 3.0);\n}\n\nfloat Spark(vec2 uv, vec2 center, float ang)\n{\n    float f = 0.0;\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang);\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang+radians(60.0));\n    f += SparkRect(uv, center, vec2(0.4, 0.008), ang+radians(120.0));\n    f += SparkCircle(uv, center, 0.01);\n    return f;\n} \n\nvec3 Colorize(Ray ray, RayHit hit)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);   \n    color.rgb = SkyColor(ray.direction);\n    \n    // If there was an intersection, compute normal and the hit surface color.\n    if (hit.material != kMaterialNone)\n    {\n        vec3 p = ray.direction * hit.time + ray.origin;\n        vec3 n = SceneNormal(p);\n        \n        color.rgb = mix(vec3(0.0, 0.0, 0.0), SkyColor(reflect(ray.direction, n)), 1.0 - pow(length(n.xz), 16.0));\n        \n        if (hit.material == kMaterialHeart)\n        {\n            color.rgb += gHeartColoring * vec3(0.4, 0, 0);\n        }\n        \n        //color.rgb = SceneNormal(p);//0.3 + 0.7*pow(max(0., Normal(p).z), 30.0);\n    }\n    \n    return color;\n}\n                        \n// --- Main --------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Setup globals.\n\tgAnimTime      = mod(1.5 * iTime, 20.0);\n\tgHeartPos      = vec3(0.0, -3.5 + 5.0 * smoothstep(1.0, 3.0, gAnimTime), -12.0);\n\tgHeartMorph    = smoothstep(2.5, 4.0, gAnimTime);\n\tgHeartColoring = smoothstep(4.0, 6.0, gAnimTime);\n\tgWaveTime      = max(0.0, gAnimTime - 0.8);\n\tgMsgFadeInTime = smoothstep(7.0, 9.0, gAnimTime);\n\tgFadeTime      = smoothstep(0.0, 1.0, gAnimTime) * smoothstep(20.0, 19.0, gAnimTime);\n\n    // Get uvs in [-1 1] range and correct them with the aspect ratio.\n    vec2 uv = 2.0*(fragCoord.xy / iResolution.xy)-1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Generate first ray and raymarch along scene.\n    Ray ray = ViewportToRay(uv, kOnes.zzz, QuatFromAxisAngle(vec3(1.0, 0.0, 0.0), radians(6.0)));\n    RayHit hit = Raymarch(ray);    \n\n    // Initialize background color.\n    vec3 color = Colorize(ray, hit);\n    \n    // Show sparks around the heart\n    for(int i = 0; i < 8; i++)\n    {\n        float t = max(0.0, (gAnimTime + (float(i)) * 0.2) - 6.0);\n        float s = floor(t / 0.4);\n        float sTime = fract(t / 0.4);\n        vec2 sPos = vec2(Hash(s * 61.0), Hash(s * 17.0));\n        sPos = 2.0 * sPos - 1.0;\n        sPos *= 0.15;\n        color.rgb += sin(sTime * kPI) * Spark(uv, sPos, 0.0) * vec3(1.0, 0.4, 0.4);\n    }\n    \n    // Show the valentine's message\n    /*\n    if (gMsgFadeInTime > 0.0)\n    {\n        vec2 texAspect = vec2(1.0, -4.0);\n        vec2 texUv = uv * texAspect;\n        texUv = clamp(texUv * 0.5 + 0.5, 0.0, 1.0);\n        \n        vec2 texMsg = texture(iChannel0, texUv).rg;\n        color.rgb += gMsgFadeInTime * (texMsg.y * vec3(0.4, 0.0, 0.0) + texMsg.xxx);        \n    }\n    */\n    \n    // Apply vignetting effect.\n    color.rgb -= color.rgb*0.2*dot(uv, uv);\n\n    fragColor = vec4(gFadeTime * color, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n    vec4 fragColor;\n    mainImage(fragColor, gl_FragCoord);\n    gl_FragColor = fragColor;\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2130, 2166, 2214, 2214, 2324], [2326, 2361, 2389, 2389, 2421], [2423, 2465, 2504, 2504, 2584], [2668, 2706, 2727, 2727, 2794], [2796, 2834, 2854, 2854, 2941], [2943, 2991, 3011, 3011, 3106], [3108, 3127, 3154, 3154, 3450], [3452, 3471, 3498, 3498, 4016], [4431, 4431, 4450, 4450, 4718], [4720, 4720, 4739, 4739, 4981], [5065, 5065, 5114, 5114, 5261], [5263, 5263, 5305, 5305, 5407], [5409, 5409, 5470, 5470, 5565], [5567, 5567, 5603, 5603, 5669], [5753, 5809, 5904, 5904, 6089], [6091, 6091, 6197, 6197, 6461], [6545, 6711, 6744, 6793, 7838], [7840, 7986, 8019, 8019, 8298], [8382, 8382, 8444, 8444, 8495], [8497, 8497, 8563, 8563, 8638], [8640, 8640, 8706, 8706, 8757], [8759, 8759, 8834, 8834, 9103], [9187, 9187, 9213, 9213, 9236], [9238, 9238, 9272, 9272, 9337], [9421, 9421, 9458, 9491, 9701], [9703, 9703, 9736, 9736, 9995], [9997, 9997, 10020, 10067, 10512], [10514, 10514, 10540, 10540, 10929], [10931, 10931, 10983, 10983, 11056], [11058, 11058, 11119, 11119, 11338], [11340, 11340, 11386, 11386, 11655], [11658, 11658, 11694, 11694, 12371], [12479, 12479, 12534, 12553, 14337]]}
{"id": "stSXzV", "name": "MN_StarField", "author": "MarekNijaki", "description": "This is shader displaying multiple stars layers, giving sence of animation (pass through them). \nYou can look around by holding left mouse button.\nShader was created based on video from 'The Art of Code' youtube channel.", "tags": ["stars", "starfield"], "likes": 5, "viewed": 426, "published": 3, "date": "1628071929", "time_retrieved": "2024-07-30T19:07:43.900436", "image_code": "// Shadertoy uses GLSL language.\n\n// UV.\n// Default 'UV'.\n// vec2 uv = fragCoord/iResolution.xy; \n\n// Time varying pixel color.\n// vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n// Default background colour.\n// Output to screen\n// fragColor = vec4(col,1.0);\n\n\n\n// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n\n// Global constant PI value.\nfloat PI = 3.1415;\n// Global constant for UV.\nvec2 UV;\n\n// Example how to check 'UV' coordinates values.\n// fragColor = vec4(vec3(0)+UV.x,1.0);\n// fragColor = vec4(vec3(0)+UV.y,1.0);\nvec2 GetUV_WithOriginInTheCenter(in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    // Multiply by '0.5' so 'UV' coordinates have their origin/pivot in the middle/center of the screen.\n    // 'UV' values will go from '-0.5' to '0' to '0.5'. \n    vec2 UV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    // Return value.\n    return UV;\n}\n\n// For 'numberOfGridTiles=3' 'UV' values will go from '-1.5' to '0' to '1.5'.\nvec2 SetGridTiles(vec2 UV, float numberOfGridTiles)\n{ \n    // Set tiles.\n    UV = UV * numberOfGridTiles;\n    // Return value.\n    return UV;\n}\n\n// Create grid ID's.\n// Can be visualised by 'col.rg +=  gridIDs;'.\n// Each cell will have diffrent colour.\nvec2 CreateGridIds(vec2 UV)\n{\n    // Get ID (truncate 'UV' coordinates numbers to only integer value, eg. '2.3' will give '2').\n    vec2 IDs = floor(UV);\n    // Return value.\n    return IDs;\n}\n\n// Create grid UV.\nvec2 CreateGridUV(vec2 UV)\n{\n    // WTF? not from -1.5 to 1.5 ???\n    // 'UV' goes from '-3' to '3', 'fract()' will return only fractual component of numbers. \n    // Each cell have values from '0' to '1'.\n    vec2 gridUV = fract(UV);\n    // Move origin of each cell from left bottom corner to middle of each cell.\n    // Each cell have values from '-0.5' to '0.5'.\n    gridUV = gridUV - 0.5;\n    // Return value.\n    return gridUV;\n}\n\n// Draw debug lines to show outline of the cells.\nvec3 DrawDebugCells(vec2 gridUV)\n{\n    // Create variable to store line colour.\n    vec3 col;\n    // Draw lines\n    if((gridUV.x > 0.49) || (gridUV.y > 0.49))\n      col.r = 1.0;\n    // Return value.\n    return col;\n}\n\n// Generate pseudo random value.\n// Can be Displayed by 'col = col + GeneratePseudoRandom_FromHash21(gridIDs);'\nfloat GeneratePseudoRandom_FromHash21(vec2 point)\n{\n    // Twist number so it will lok like random number.\n    point = fract(point * vec2(123.34, 456.21));\n    point = point + dot(point, point + 45.32);\n    // Get random value.\n    float randomVal = fract(point.x * point.y);\n    // Return value.\n    return randomVal;\n}\n\n// Randomize positions of grid 'UV' positions.\nvec2 RandomizeGridUVPositions(vec2 gridIDs, vec2 gridUV)\n{\n    // Get random value from '0' to '1'.\n    float randomOffsetX = GeneratePseudoRandom_FromHash21(gridIDs);\n    float randomOffsetY = fract(randomOffsetX * 34.0);\n    // Shift offset so shifted star will not go out of the cell completly (origin of the star was in '0.5, 0.5').\n    // Offsets will have values between '-0.5, -0.5' to '0.5, 0.5'.\n    randomOffsetX = randomOffsetX - 0.5;\n    randomOffsetY = randomOffsetY - 0.5;\n    // Randomize values of UV from '0' to '1' based od cells ID's.\n    gridUV = gridUV - vec2(randomOffsetX,randomOffsetY);    \n    // Return value.\n    return gridUV;\n}\n\n// Get distance to the center of 'UV'.\nfloat GetDistanceToTheCenter(vec2 UV)\n{\n    \n    // Origin is in the middle. \n    // 'length(UV)' will return distance for each pixel from UV to the middle.\n    // You can imagine this as a circle that is going from black to white (from middle to edges).\n    // For length value of '0' colour is black , for '1' colour is white.\n    float distanceToTheCenter = length(UV);\n    // Return value.\n    return distanceToTheCenter;\n}\n\n// Create smoothstep circle.\n// NOT USED BECAUSE: \n//   * In normal world, lighting fall off should go smoothly all the way to the screen edge.\n//   * 'smoothstep()' will have hard '0' or '1' values for areas outside of tresholds.\nfloat CreateSmoothstepWhiteCircle(vec2 UV, float lowerCutoff, float upperCutoff)\n{\n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    // Smooth out the circle.    \n    // 'smoothstep()' takes two cutoff/edges parameters, which determine the lower and higher threshold values for the curve. \n    // When 'In' is lower than 'lowerCutoff', the output is '0', and when 'In' is above 'upperCutoff', the output is '1'.\n    // 'smoothstep()' will return interpolates between 'lowerCutoff' and 'upperCutoff' in a similar way to Lerp. \n    // However, the interpolation will gradually speed up from the start and slow down toward the end. \n    // This is useful for creating natural-looking animation, fading and other transitions.\n    float darkCircle = smoothstep(lowerCutoff, upperCutoff, distanceToTheCenter);\n    float whiteCircle = 1.0 - darkCircle;\n    // Return value.\n    return whiteCircle;\n}\n\nfloat CreateSmoothWhiteCircle(vec2 UV, float minInnerCircleRadius)\n{\n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    \n    // Try not divide by 0?!!!\n    //if(distanceToTheCenter <> 0)\n    // 'clamp(x,min,max)' returns the value of 'x' constrained to the range 'min' to 'max'.\n    //whiteCircle = minInnerCircleRadius / clamp(distanceToTheCenter, -1.5, 1.5);\n    \n    // Create circle\n    float whiteCircle = minInnerCircleRadius / distanceToTheCenter;\n    // Return value.\n    return whiteCircle;\n}\n\n// Create cross/flares/rays.\nfloat CreateWhiteCross(vec2 UV, float crossIntensity)\n{    \n    // Gradient between '-0.5' to '0' to '0.5'.\n    float blackToWhiteGradientX = UV.x;\n    float blackToWhiteGradientY = UV.y;\n    // Gradient between '0.5' to '0' to '0.5'.\n    // This will look like vertical and horizontal black lines.\n    float whiteToBlackToWhiteGradientX = abs(blackToWhiteGradientX);\n    float whiteToBlackToWhiteGradientY = abs(blackToWhiteGradientY);\n    // Create cross/flare.\n    float blackCross = whiteToBlackToWhiteGradientX * whiteToBlackToWhiteGradientY; \n    // Set thickness/bluriness of cross/flare (higher value will result in clearer lines).\n    float crossSize = 1000.0;\n    blackCross = blackCross * crossSize;\n    // Clamp values between '0' and '1'.\n    blackCross = min(1.0, blackCross);\n    blackCross = max(0.0, blackCross);\n    // Create white cross.\n    float whiteCross = 1.0 - blackCross;\n    // Set intensity.\n    whiteCross = whiteCross * crossIntensity;\n    // Return value.\n    return whiteCross;\n}\n\n// Return rotation angle matrix.\n// 'PI' is aroung '3.1415'\n// '360' degrees is two 'PI' radians.\n// '180' degrees is 'PI' radians.\nmat2 RotationAngle(float angle)\n{\n    float sinus = sin(angle);\n    float cosinus = cos(angle);\n    return mat2(cosinus,-sinus,sinus,cosinus);\n}\n\n// Create star.\nvec3 CreateStars(vec2 gridIDs, vec2 UV, float starIntensity, float innerCircleRadius, float crossIntensity, \n                 float minRange, float maxRange, vec3 col)\n{\n    // Create circle.\n    float whiteStar = CreateSmoothWhiteCircle(UV, innerCircleRadius);\n        \n    // Applay first cross/flares/rays.\n    whiteStar = whiteStar + CreateWhiteCross(UV, crossIntensity);\n    // Rotate 'UV' around '45' degrees angle.\n    UV = UV * RotationAngle(PI / 4.0);\n    // Applay second cross/flares/rays.\n    whiteStar = whiteStar + CreateWhiteCross(UV, crossIntensity);\n    \n    // Get distance to the center of 'UV'.\n    float distanceToTheCenter = GetDistanceToTheCenter(UV); \n    // Cut star.\n    // Cut is needed, because in some cases, glow and flares could go out of the cell - for values bigger than '0.5'.\n    // That would be fine because neighbourhood cells will take care of drawing appropiate parts of star, but it can't go\n    // further - eg. 2 or more cells, because it would lead to artifacts.\n    minRange = clamp(minRange, 0.0, 0.5);\n    maxRange = clamp(maxRange, 0.0, 1.0);\n    whiteStar = whiteStar * smoothstep(maxRange, minRange, distanceToTheCenter); \n    \n    // Apply intensity.\n    whiteStar = whiteStar * starIntensity;\n    \n    \n    // Convert white star to star with colour.\n    vec3 star = vec3(whiteStar);\n    // Apply colour.    \n    star = star * col;\n    \n    // Return value.\n    return star;\n}\n\n// Create random colour.\nvec3 CreateRandomColour(vec2 gridIDs, float starIntensity)\n{\n    // Generate random value.\n    float randomVal = GeneratePseudoRandom_FromHash21(gridIDs);\n    // Rate of colour changes.\n    float colourChangeRate = 2.0;\n    \n    // Because small values are very close to each other, colour components will look almost the same.\n    // To avoid that we can multiply those components by some big number to disperse them all over 'sin()' method.\n    //float colourComponentsDispersionMagnifier = 1.0;\n    //vec3 col = sin(vec3(0.2, 0.3, 0.9) * randomVal * colourComponentsDispersionMagnifier) / 2.0 + 0.5;\n    \n    // Create random colour.\n    // 'sin(vec3(...))' will just do 'sin()' for each component separatly.\n    // '* iTime' will multiply 'sin()' outcomes over time value. \n    // Each colour component (RGB) will change with diffrent rates, because each have diffrent multiplication exponent (0.2, 0.3, 0.9). \n    // Colour components have values between '0.0' and '1.0'. 'Sin()' goes from '-1.0' to '1.0'.\n    // '/ 2.0' will result in values between '-0.5' and '0.5'.\n    // '+ 0.5' will result in values between '0.0' and '1.0', so appropiate for colour components.    \n    vec3 colour = sin(vec3(0.2, 0.3, 0.9) * randomVal * colourChangeRate * iTime) / 2.0 + 0.5;\n    \n    // Eliminate colours that we don't like (in this case remove most of green).\n    colour = colour * vec3(1.0, 0.3, 1.0);\n    // Set bigger stars more blue.\n    colour = colour * vec3(1.0, 1.0, 2.0 * starIntensity);\n    \n    // Return value.\n    return colour;\n}\n\n// Get mouse positon.\nvec2 GetMousePos()\n{\n  return (iMouse.xy - (iResolution.xy * 0.5)) / iResolution.y;\n}\n\n// Get mouse input.\nvec2 GetMouseInput()\n{\n  vec2 mousePos = GetMousePos();\n  return mousePos * 5.0;\n}\n\n// Create stars.\n// Also for each star draw parts of it that went out of the cell (neighbour cells will generate that star parts).\nvec3 CreateStarsWithNeighboursContributions(float densityOfStars, float layerRandomOffset, mat2 layerAngle)\n{\n    // Allow to look over star field (normal looking around).\n    //vec2 UVtmp = SetGridTiles(UV+GetMouseInput(), densityOfStars);\n    // Set grid tiles. \n    vec2 UVtmp = SetGridTiles(UV, densityOfStars);\n    // Allow to look over star field (paralax effect).\n    UVtmp = UVtmp + GetMouseInput();    \n    // Set rotation of layer.\n    UVtmp = UVtmp * layerAngle;\n    // Set random offset of layer.\n    UVtmp = UVtmp + layerRandomOffset;\n    // Create grid ID's.\n    vec2 gridIDs = CreateGridIds(UVtmp);\n    // Create grid 'UV'.\n    vec2 gridUV = CreateGridUV(UVtmp);    \n    // Create star variable.\n    vec3 stars;\n    // For each cell, add contributions from neighbourhood cells.\n    for(int x=-1; x<=1; x++)\n      for(int y=-1; y<=1; y++)\n      {\n        // Get neighbour offset.\n        vec2 offset = vec2(x,y);\n        // Compute offseted grid IDs and UV.\n        vec2 offsetedGridIDs = gridIDs+offset;\n        vec2 offsetedGridUV = gridUV-offset;\n        // Randomize grid 'UV' positions.\n        vec2 gridUV2 = RandomizeGridUVPositions(offsetedGridIDs, offsetedGridUV);\n        // Generate random star intensity (will also affect star size little bit).\n        float starIntensity = GeneratePseudoRandom_FromHash21(offsetedGridIDs);\n        starIntensity = max(0.5, starIntensity);\n        // Compute inner circle radius (below '0.01' stars become invisible).\n        // Big values make stars look like big glowy bulbs.\n        float innerCircleRadius = max(0.065, 0.065/densityOfStars);\n        // Compute star cross intensity (only stars with big intensity will have cross turn on).\n        float crossIntensity = smoothstep(0.8, 1.0, starIntensity);\n        crossIntensity = min(0.25, crossIntensity);        \n        // Set min and max range.\n        float minRange = 0.4; \n        float maxRange = 1.0;\n        // Create random colour.\n        vec3 col = CreateRandomColour(offsetedGridIDs, starIntensity);\n        // Create stars.\n        stars = stars + CreateStars(gridIDs, gridUV2, starIntensity, innerCircleRadius, crossIntensity, minRange, maxRange, col);\n      }    \n    // Draw debug cells.\n    //stars = stars + DrawDebugCells(gridUV);\n    // Return value.\n    return stars;\n}\n\n// Get fade factor, depending on layer depth.\nfloat GetFadeFactor(float depth)\n{\n    // This is only to show other way, how to achive similar result as smoothstep.\n    //if(depth > 0.9) \n    //{\n      // 0.9 * 10 => 9.0 => fract() => 0.0\n      // 0.91 * 10 => 9.1 => fract() => 0.1\n      // 0.92 * 10 => 9.2 => fract() => 0.2\n      // 0.99 * 10 => 9.9 => fract() => 0.9\n      //float interpolation = fract(depth*10.0);\n      // Fade out last part of animation (start will become more transparent whe they are very close to screen).\n      //fadeFactor = mix(fadeFactor, 0.0, fract(depth*10.0));\n    //}\n    \n    // Last part of depth should fade out again.\n    float fadeFactor = depth * smoothstep(1.0, 0.8, depth);\n    // Return value.\n    return fadeFactor;\n}\n\n// Create multiple layers of stars.\nvec3 CreateStarsLayers(float numOfLayers, float densityOfStars)\n{\n  // Caculate animation speed.\n  float passThroughAnimationSpeed = iTime * 0.1;\n  float rotateAnimationSpeed = iTime * 0.01;\n  // Stars layers.\n  vec3 starsLayers;\n  // Create layers of stars\n  for(float i=0.0; i<1.0; i += 1.0/numOfLayers)\n  {\n    // Depth of layer will change from small value to '1.0' over time. \n    // After it reach '1.0' depth will be shifted to small value and again start increasing.\n    float depth = fract(i+passThroughAnimationSpeed);\n    // Scale influence how many grid tiles is on given layer.\n    // To increase number of stars, scale must increase also.\n    // As for layers goes, each of them should have diffrent size of stars (from layers with low scale to high scale).\n    // Changing scale of each layer over time will give sense of passing through the stars.\n    float scale = mix(densityOfStars + numOfLayers, 0.5, depth);\n    // Compute layer random positon (so layers stars will not align into lines).\n    float layerRandomOffset = i * 453.23;\n    // Compute layer angle.\n    mat2 layerAngle = RotationAngle(PI * rotateAnimationSpeed);\n    // Layers that are far from screen (have low scale) should be fading from '0.0' to '1.0', as scale increase.\n    // This will prevent 'poping out' artifact when layers are shifted to the back (their scale is set to low number).\n    float fadeFactor = GetFadeFactor(depth);\n    // Create mulitple layers of stars.\n    starsLayers = starsLayers + CreateStarsWithNeighboursContributions(scale, layerRandomOffset, layerAngle) * fadeFactor;\n  }\n  // Return value.\n  return starsLayers;\n}\n\n\n// Main function.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Get UV with origin/pivot in the middle/center of the screen.\n    UV = GetUV_WithOriginInTheCenter(fragCoord);\n    // Create black colour.\n    vec3 col = vec3(0);\n    // Create stars layers.\n    col = col + CreateStarsLayers(7.0, 15.0);\n    // Output to screen.\n    fragColor = vec4(col,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[480, 607, 660, 873, 977], [979, 1057, 1110, 1129, 1200], [1202, 1310, 1339, 1437, 1502], [1504, 1523, 1551, 1728, 1957], [1959, 2009, 2043, 2088, 2225], [2227, 2339, 2390, 2445, 2659], [2661, 2708, 2766, 2807, 3364], [3366, 3405, 3444, 3733, 3832], [3834, 4065, 4147, 4190, 5015], [5017, 5017, 5085, 5128, 5575], [5577, 5606, 5661, 5713, 6617], [6619, 6751, 6784, 6784, 6895], [6897, 6913, 7082, 7104, 8340], [8342, 8367, 8427, 8457, 9909], [9911, 9933, 9953, 9953, 10018], [10020, 10040, 10062, 10062, 10122], [10124, 10255, 10364, 10519, 12563], [12565, 12611, 12645, 13220, 13326], [13328, 13364, 13429, 13460, 14994], [14997, 15015, 15072, 15144, 15377]]}
{"id": "slSXRV", "name": "Fire Gateway", "author": "scry", "description": "I wanted to make glowing strands of stuff, kinda did, learned how to get the effect I had in mind, also created an effect which I have no idea of its working(some of the color patterning that occurs)", "tags": ["3d", "fractal", "raymarch", "kifs"], "likes": 5, "viewed": 342, "published": 3, "date": "1628058339", "time_retrieved": "2024-07-30T19:07:44.856879", "image_code": "#define MAXD 100.\n#define SURF 0.01\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec4 map(vec3 p) {\n    \n    //float d = \n    float pd = 0.1;\n    float psz = floor(p.z);\n    p.xy *= r2d(psz+psz*09.5);\n    vec3 o = p;\n    p -= 5.;\n    p = (fract(p*pd)-0.5)/pd;\n    p = abs(p)-1.0;\n    //*/\n    for (int i=0;i<4;i++) {\n        //\n        p.xy = vec2(length(p.xy),atan(p.x,p.y));\n        p.xy = abs(p.xy)+0.3;\n        p.xy *= r2d(0.3);\n        p.xy = vec2(p.x*sin(p.y),p.x*cos(p.y));\n        p = abs(p)-sin(o.z*0.06+iTime*0.01)*2.;\n        p.xy *= r2d(o.z*0.02);\n    }\n    //float d = length(p)+0.1;\n    \n    float an = 3.14*0.75;\n    float d = sdCappedTorus(p,vec2(sin(an),cos(an)),1.,0.)+0.0;\n    d = max(d,-(length(o.xy)-0.4));\n    return vec4(p.xy,o.z,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd,float c) {\n    float dO = 0.;\n    float ii = 0.;\n    int steps = 60-int(c*20.);\n    for (int i=0;i<steps;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS*0.2;\n        ii += 0.1;\n        if (dO > MAXD || dS < SURF) {break;}\n    }\n    return vec2(dO,ii);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 1.- 2.*uv;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    //uv *= 0.1;\n    float c = length(uv);\n    //uv *= r2d(sin(c*8.+time)*0.01);\n    vec3 ro = vec3(0.,0.,-5.);\n    ro.z += iTime*0.6;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd,c);\n    //col = d.xxx*0.006;\n    vec3 p=map(ro+rd*d.x).rgb;\n    //col = sin(d.xxx*0.8+time)*0.5+0.5;\n    //col = d.xxx*0.001;\n    //col += 1.-d.xxx*0.007;\n    //col.r -= d.y;\n    //col = sin(d.yyy);\n    //col = sin(p.zzz*0.02)*0.5+0.5;\n    float pzn = p.z-ro.z;\n    //d.x = clamp(d.x*0.05,0.,1.);\n    col = hsv2rgb(vec3(p.y*0.04+p.z*0.004+d.x*0.01-0.05,1.-d.y*0.03,sin(p.z*0.2-ro.z*0.12)*0.6+0.4));\n    //col = hsv2rgb(vec3(p.z*0.05,sin(p.x*0.002-c*4)*0.5+0.5,sin(d.x*0.1-ro.z*0+c)*0.5+0.5));\n    //vec3 bak = texture(prevFrame,inData.v_texcoord).rgb;\n    if (d.x > MAXD+(c+0.5)) {\n        col *= 0.;\n    }\n    //col = fract(col*1.5+time*0.04);\n    //col = sin(col*6.);\n    //bak = fract(bak+col*0.01);\n    //col = mix(col,bak,0.93);\n    //col = hsv2rgb(vec3(d.x*0.009,d.x*0.005,d.x*0.1));\n    //col = hsv2rgb(vec3(d.x*0.0025,0.6,d.y*4.-19.5));\n    fragColor = vec4(col,1.);\n}\n\n    \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 56, 56, 105], [107, 166, 188, 188, 519], [523, 582, 604, 604, 773], [845, 893, 946, 946, 1005], [1006, 1006, 1076, 1076, 1210], [1212, 1212, 1230, 1252, 1889], [1891, 1891, 1926, 1926, 2201], [2202, 2202, 2259, 2259, 3588]]}
{"id": "7tBSRV", "name": "70s Petals", "author": "JennySchub", "description": "I like it a lot", "tags": ["flower", "petals", "70s"], "likes": 23, "viewed": 494, "published": 3, "date": "1628057289", "time_retrieved": "2024-07-30T19:07:45.628815", "image_code": "#define PI 3.141592653 \n#define countX 17.\n#define petalWidth .4\n#define AA 2.\n\nvec3 colMap(float v) {\n\n\tv=mod(v, PI+1.3)-.8;\t\n    return vec3(\n\t\tsin(sin(v-.6)),\n\t\tsin(sin(v)),\n\t\tsin(sin(v+.8))\n\t);\n\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    for(float aa=0.; aa<AA; aa++){\n        for(float bb=0.; bb<AA; bb++){\n\n            vec2 uv = (fragCoord + vec2(aa,bb)*1./AA)/iResolution.xy;\n\n\n            uv-=.5;\n            uv.y*=iResolution.y/iResolution.x;\n            uv*=2.;\n\n            float tim=-iTime*.1;\n            float posintim=sin(tim)*.5+.5;\n            float dst=length(uv);\n            vec2 tuv = vec2(0.,dst);\n            vec2 id = vec2(0.);\n            float zoomSpeed=tim*.4;\n            float angle1=(atan(uv.x,uv.y)/PI*.5+.5)+zoomSpeed + tim*.3;\n            float angle2=angle1-2.*zoomSpeed;\n            float add=pow(dst, posintim*.7+.1)*countX*petalWidth;\n            tuv.x=mod(angle1*countX+add, 1.);\n            tuv.y=mod(angle2*countX-add, 1.);\n            id.x=ceil(angle1*countX+add);\n            id.y=floor(angle2*countX-add);\n            float edgeDist = max(max(tuv.x, tuv.y), max(1.-tuv.x, 1.-tuv.y));\n            tuv-=.5;\n            tuv*=dst*3.;\n            float t=log(dst+1.6);\n            float v=abs(tuv.x+tuv.y)+pow(tuv.y-tuv.x, 2.);\n            v+=posintim *pow(edgeDist,25.);\n            vec3 col=vec3(smoothstep(t+.1,t,v) );\n            col*=colMap(abs(id.x-id.y)*.4);\n\n\n            fragColor += vec4(col/(AA*AA),1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 102, 102, 200], [203, 203, 260, 260, 1519]]}
{"id": "NlSXRV", "name": "Kerbal Kraken", "author": "Roninkoi", "description": "Deep Space Kraken as found on Bop in Kerbal Space Program [url]https://aliens.fandom.com/wiki/Deep_Space_Kraken[/url]\n\nOut of its element!", "tags": ["sea", "kraken", "kerbalspaceprogram"], "likes": 7, "viewed": 346, "published": 3, "date": "1628022227", "time_retrieved": "2024-07-30T19:07:46.468569", "image_code": "#define PI 3.14159265\n#define MAXIT 150\n#define EPSILON 0.05\n#define STEP 0.5\n\n#define minx4(a, b) ((a.x) < (b.x) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\n#define GROUNDCOL 1.\n#define KRAKENCOL 2.\n#define TENTACLECOL 3.\n#define BEAKCOL 4.\n#define EYECOL 5.\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n\nfloat beak(vec3 r, float a)\n{\n\tvec3 p = r;\n\tp.x *= 0.8;\n\tp.y *= 0.6;\n\t\n\tvec3 b1 = rotZ(PI/4. - 0.4 - abs(sin(t*3.)) * 0.9)*vec3(p.x - p.y * p.y * p.y, p.y, 0.);\n\tvec3 b2 = rotZ(PI/4. + 0.4 + abs(sin(t*3.)) * 0.9)*vec3(p.x + p.y * p.y * p.y, p.y, 0.);\n\t\n    return length(p) - a + max(-b1.x-b1.y + 0.12, 0.)*max(-b2.x-b2.y + 0.12, 0.)*10.;\n}\n\nfloat body(vec3 r, float a)\n{\n\tr.y -= abs(r.y)*0.33;\n    return length(r) - a;\n}\n\nfloat torus(vec3 r, vec3 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n\tr.y += sin(r.x * 0.1) * 2.;\n\tr.y += cos(r.z * 0.1) * 2.;\n\tr.y += (sin(r.x)) * 0.2;\n\tr.y += (sin(r.x) + cos(r.z * 0.5)) * 0.2;\n\t\n    return dot(r - o, n);\n}\n\nfloat tentacle(vec3 r, vec3 a, float tt)\n{\n\tfloat d = a.y - r.y;\n\tr.x += sin(r.x * 0.2 + r.y * 0.5 + tt) * d * 0.3;\n\tr.z += cos(r.z * 0.1 + r.y * 0.8 + tt) * d * 0.3;\n\ta.z = clamp(a.z - d * a.z / a.y / 2., 0., a.z);\n    \n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a.xy;\n\tp.x = abs(p.x) - a.z;\n\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n\n    return length(max(p + 0.1, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nvec3 matCol(vec4 o)\n{\n\tvec2 cc = o.zw;\n\t\n    if (o.y == GROUNDCOL) {\n\t    cc.x += cos(.3*t) * 2.;\n\t    cc.y += sin(.3*t) * 2.;\n        return normalize(vec3(0.8 + sin(cc.x + cc.y) * 0.05, 0.5 + sin(cc.x) * 0.1, 0.0));\n    }\n    \n    if (o.y == KRAKENCOL) {\n\t    float fade = cos(clamp(cc.y*1.2, 0., PI/2.));\n\t    vec3 top = normalize(vec3(0., 0.9, 0.)) * (sin(cc.x * 6.) * fade * 0.6 + 0.4);\n\t    float bfade = clamp(-cc.y+.3, 0., 1.);\n\t    vec3 bot = vec3(0.7, 0.3, 0.);\n\t    return top * (1.-bfade) + bot * bfade;\n    }\n    \n    if (o.y == TENTACLECOL) {\n\t    float fade = clamp(abs(cc.y), 0., PI/2.);\n\t    vec3 top = normalize(vec3(0., 0.9, 0.)) * ((fade) * 0.8) * 0.5;\n\t    return top;\n    }\n    \n    if (o.y == EYECOL) {\n\t    float fade = cos(clamp(cc.y*10., 0., PI/2.));\n\t    \n\t    float pupil = smoothstep(-0.6,-0.5, cc.y);\n\t    float lid = smoothstep(0.0,-0.2, cc.y);\n\t    vec3 top = vec3(1.2, 1.2, 0.) * (cos(cc.x * 6.) * fade * 0.6 + 0.4) + vec3(0.9, 1., 0.);\n\t    \n\t    return top * pupil * lid + vec3(0.2, 0.0, 0.2) * (1. - pupil) + vec3(0.5, 0.8, 0.) * (1.-lid);\n    }\n    \n    if (o.y == BEAKCOL) {\n\t    float fade = clamp(abs(sin(cc.y * cc.y)), 0., PI/2.);\n\t    vec3 top = normalize(vec3(1.7, 1., 0.8)) * (fade * 0.6 + 0.4);\n\t    return top * fade;\n    }\n    \n    return normalize(vec3(0.8, 0.2, 0.));\n}\n\nmat3 obj;\n\nvec4 kraken(vec3 r, float tt)\n{\n\tvec3 br = r * rotY(0.7) * rotX(-PI / 2.);\n\tbr *= rotY((sin(t) + t * 1.5) * 0.5);\n\tvec2 bc = vec2(atan(br.x, br.z), br.y / 3.);\n\t\n\tvec4 bd = vec4(\n\t\tbody(br, 3.), matCol(vec4(0., KRAKENCOL, bc))\n\t);\n\t\n\tvec4 td = vec4(1000., 0., 0., 0.);\n\tfor (int a = 0; a < 6; ++a) {\n\t\tfloat aa = float(a) - PI / 4.;\n\t\tfloat split = (floor(float(a) / 3.) * 2. - 1.) * 0.3;\n\t\ttd = minx4(td, \n            vec4(tentacle(br + 1.7 * vec3(cos(float(aa)) - split, 1.8, sin(float(aa))),\n                vec3(.01, 2., .6), tt * 0.5), \n            matCol(vec4(0., TENTACLECOL, bc))\n\t\t));\n\t}\n\t\n\tvec3 er = br + vec3(0., 2., -1.5);\n\tfloat eax = sin(t * 2.) * 0.4;\n\tfloat eaz = cos(t * 2.) * 0.4;\n\ter *= rotX(eax * sin(t * 0.71)) * rotZ(eaz * sin(t * 0.54));\n\tvec2 ec = vec2(atan(er.x, er.z), er.y);\n\tvec4 ed1 = vec4(\n\t\tsphere(er, 0.6), matCol(vec4(0., EYECOL, ec))\n\t);\n\ter = br + vec3(0., 2., 1.5);\n\ter *= rotX(-eax * cos(t * 0.32)) * rotZ(-eaz * sin(t * 0.76));\n\tec = vec2(atan(er.x, er.z), er.y);\n\tvec4 ed2 = vec4(\n\t\tsphere(er, 0.6), matCol(vec4(0., EYECOL, ec))\n\t);\n\tvec4 ed = minx4(ed1, ed2);\n\t\n\tvec3 kr = br + vec3(0., 2.3, 0.);\n\tvec4 kd = vec4(\n\t\tbeak(kr, 0.6), matCol(vec4(0., BEAKCOL, bc))\n\t);\n\t\n\treturn minx4(minx4(minx4(bd, td), ed), kd);\n}\n\nvec4 map(vec3 r)\n{\n\tfloat tt = t * 10. - sin(t) * 5.;\n\t\n\tr *= rotY(sin(t * 0.5));\n\t\n\tvec4 kd = kraken(r, tt);\n\t\n\tvec3 gr = r;\n\tgr.x += tt * 0.4;\n\tgr.z += tt;\n\tgr.y += 7.;\n\t\n\tvec4 gd = vec4(\n\t\tplane(gr, vec3(0., 0., 0.), vec3(0., 1., 0.)), matCol(vec4(0., GROUNDCOL, gr.xz))\n\t);\n\t\n\treturn minx4(gd, kd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    mat3 cam = rotY(-PI) * rotX(0.3);\n\n    vec3 ro = vec3(0., 2.0, -10.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n\n    vec3 bcol = vec3(0.2, 0.7, 0.8) * 1.1;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n\n    float sh = 1.;\n\n    float glow = 0.;\n\n    int ch = 1;\n\n    for (int i = 0; i < MAXIT; ++i) {\n        vec4 d = map(r);\n        float z = length(r - ro);\n\n        glow += exp(-d.x);\n\n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, d.yzw,\n                shade(normalize(r), rd));\n\t\t\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n\n        d.x *= 0.8 - 0.2 * hash(uv);\n        r += rd * d.x * STEP;\n\n        sh = (float(i) / float(MAXIT));\n    }\n\n    if (sh < 0.5)\n        col.rgb *= clamp(exp(-sh * 2.0 + 1.0), 0., 1.);\n\n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 299, 299, 401], [403, 403, 423, 423, 527], [529, 529, 549, 549, 651], [653, 653, 673, 673, 745], [757, 757, 788, 788, 816], [818, 818, 847, 847, 1158], [1160, 1160, 1189, 1189, 1240], [1242, 1242, 1271, 1271, 1345], [1347, 1347, 1384, 1384, 1541], [1543, 1543, 1585, 1585, 1890], [1892, 1892, 1919, 1919, 1986], [1988, 1988, 2018, 2018, 2073], [2075, 2075, 2117, 2117, 2157], [2159, 2159, 2180, 2180, 3477], [3490, 3490, 3521, 3521, 4743], [4745, 4745, 4763, 4763, 5049]]}
{"id": "stjSRy", "name": "Anti-aliased rectangle+rotation", "author": "modesty", "description": "anti-aliased shape", "tags": ["antialiasing"], "likes": 2, "viewed": 422, "published": 3, "date": "1628002124", "time_retrieved": "2024-07-30T19:07:47.218564", "image_code": "mat2 rotate2D(in float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co, -si, si, co);\n}\n\nfloat sdBox(in vec2 p, in vec2 size) {\n    p = abs(p) - size;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y)); // + min(0.0, max(p.x,p.y) to corrent\n                                                        // inretior distance which would otherwise\n                                                        // be zero\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float aaWidth = 8.0 / iResolution.y; // Pixel width in normalized coordinates (x2 to make it smoother);\n    \n    vec3 color = vec3(1.0);\n    \n    uv *= rotate2D(iTime);\n    \n    float box = sdBox(uv, vec2(0.3, 0.3));\n    box = max(box, -sdBox(uv, vec2(0.15, 0.1))); // \"carve\" out some of the interior \n    \n    // Use smoothstep(aa width, 0.0, distance) to smoothly blend onto the background\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(aaWidth, 0.0, box));\n    color = mix(color, vec3(0.0), smoothstep(aaWidth, 0.0, abs(box) - 0.001)); // edges\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 99], [101, 101, 139, 139, 426], [428, 428, 485, 485, 1156]]}
{"id": "7ljSzG", "name": "CMYK Halftoning", "author": "paniq", "description": "classical CMYK halftoning with patterns at different rotations", "tags": ["halftone", "cmyk"], "likes": 11, "viewed": 522, "published": 3, "date": "1627983952", "time_retrieved": "2024-07-30T19:07:48.101204", "image_code": "vec4 rgb_to_cmyk(vec3 col) {\n    float a = max(col.r, max(col.g, col.b));\n    return vec4((a - col.rgb) / a, 1.0 - a);\n}\n\nvec3 cmyk_to_rgb(vec4 col) {\n    float ik = 1.0 - col.w;\n    return (1.0 - col.rgb) * ik;\n}\n\nfloat ht(vec2 uv) {\n    uv = fract(uv);\n    return pow(length(uv - 0.5) / sqrt(0.5), 1.7);\n}\n\nvec2 rotate (vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(c*p.x + s*p.y, c*p.y - s*p.x);\n}\n\nvec4 cmyk_ht(vec2 uv) {\n    return vec4(\n        ht(rotate(uv, radians(15.0))),\n        ht(rotate(uv, radians(75.0))),\n        ht(rotate(uv, radians(0.0))),\n        ht(rotate(uv, radians(45.0))));\n}\n\nvec3 scene(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float s = iResolution.y / 10.0;\n    vec2 suv = uv * s;\n    vec4 htp = cmyk_ht(suv);\n\n    vec4 col = texture(iChannel0, uv * vec2(0.3333, 0.5) + 0.5) + 1.0/255.0;\n    vec4 cmyk = rgb_to_cmyk(col.rgb);\n    \n    cmyk = step(htp, cmyk);\n\n    return clamp(cmyk_to_rgb(cmyk), vec3(0.0), vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // supersample\n    const int N = 2;\n    float w = 0.0;\n    vec3 c = vec3(0.0);\n    for (int x = -N; x <= N; ++x) {\n        for (int y = -N; y <= N; ++y) {\n            c += scene(fragCoord + vec2(x,y)/(1.5*float(N)));\n            w += 1.0;\n        }\n    }\n    fragColor = vec4(c / w, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljSzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 120], [122, 122, 150, 150, 213], [215, 215, 234, 234, 307], [309, 309, 340, 340, 433], [435, 435, 458, 458, 633], [635, 635, 663, 663, 1060], [1062, 1062, 1119, 1138, 1414]]}
{"id": "7tjSRy", "name": "Subdividing Halftone Pattern", "author": "paniq", "description": "proof of concept for a halftone pattern that subdivides. the calculations here are eyeballed; a proper version would do an exact coverage to area mapping.", "tags": ["halftone", "pattern", "subdivision"], "likes": 10, "viewed": 517, "published": 3, "date": "1627983922", "time_retrieved": "2024-07-30T19:07:49.011770", "image_code": "\nfloat ht(vec3 uvw) {\n    vec2 uv = uvw.xy * 2.0;\n    vec2 subuv = fract(uv);\n    \n    vec2 fo = mod(uv - subuv,vec2(2.0))-0.5;\n\n    float n = pow(1.0-uvw.z, 2.0);\n\n    return length(subuv + fo*n - 0.5) / sqrt(0.5 + 1.5*pow(n,1.5));\n}\n\nvec2 rotate (vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(c*p.x + s*p.y, c*p.y - s*p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 n = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float s = iResolution.y / 50.0;\n    vec2 suv = rotate(uv,radians(25.0)) * s;\n\n#if 0\n    float w = 1.0 - length(uv);\n    float h = abs(dot(uv, normalize(vec2(1.0,1.0))))*1.5;\n#else\n    float w = n.y;\n    float h = n.x;\n#endif\n\n    w = clamp(w, 0.0, 1.0);\n    h = clamp(h, 0.0, 1.0);\n\n    float c = ht(vec3(suv,h));\n    \n    c = clamp((w - c)*10.0, 0.0, 1.0);\n\n    fragColor = vec4(vec3(pow(c,0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 21, 21, 234], [236, 236, 267, 267, 360], [362, 362, 419, 419, 968]]}
{"id": "7l2SzG", "name": "Flower - Moment of Inertia", "author": "oneshade", "description": "This was my first polar integration excercise (probably not a good choice). To set the anchor point, click, hold, then release on the anchor point.", "tags": ["2d", "flower", "physics", "inertia", "momentofinertia"], "likes": 13, "viewed": 193, "published": 3, "date": "1627981283", "time_retrieved": "2024-07-30T19:07:49.889423", "image_code": "// See https://www.desmos.com/calculator/yci98meozk\n\n// SDFs\nvec3 dMul(in vec3 f, in vec3 g) { return vec3(f.x * g.x, f.y * g.x + f.x * g.y, f.z * g.x + 2.0 * f.y * g.y + f.x * g.z); }\nvec3 dCos(in vec3 f) { float co = cos(f.x), si = sin(f.x); return vec3(co, -si * f.y, -co * f.y * f.y - si * f.z); }\nvec3 dSin(in vec3 f) { float co = cos(f.x), si = sin(f.x); return vec3(si,  co * f.y, -si * f.y * f.y + co * f.z); }\nfloat sdFlower(in vec2 p, in float c, in float a, in float f) {\n    float ang = mod(atan(p.y, p.x) + PI / f, 2.0 * PI / f) - PI / f;\n    p = vec2(cos(ang), sin(ang)) * length(p);\n    p.y = abs(p.y);\n\n    float t = 0.5 * PI / f;\n    if (p.x < c - a && a < 0.5 * c) t *= 1.5;\n    if (p.x > c + a) t = f < 4.0 ? 0.25 : 0.1;\n\n    for (int n=0; n < 10; n++) {\n        vec3 r = vec3(c, 0.0, 0.0) + a * dCos(f * vec3(t, 1.0, 0.0));\n        vec3 dx = dMul(dCos(vec3(t, 1.0, 0.0)), r) - vec3(p.x, 0.0, 0.0);\n        vec3 dy = dMul(dSin(vec3(t, 1.0, 0.0)), r) - vec3(p.y, 0.0, 0.0);\n        vec3 dist = dMul(dx, dx) + dMul(dy, dy);\n        t -= dist.y / dist.z;\n    }\n\n    float r = c + a * cos(f * ang);\n    return length(p - vec2(cos(t), sin(t)) * (c + a * cos(f * t))) * sign(dot(p, p) - r * r);\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n    float co = cos(ang), si = sin(ang);\n    mat2 rot = mat2(co, si, -si, co);\n\n    vec2 flowerUv = rot * (uv - AXIS) + AXIS;\n    float flower = sdFlower(flowerUv, RADIUS, AMP, FREQ);\n\n    drawSDF(flower, vec3(1.0, 0.0, 0.0));\n    if (dot(flowerUv, flowerUv) > 0.1) drawSDF(abs(flower), vec3(1.0, 0.8, 0.0)); // Conditional to avoid artifact in the middle\n    drawSDF(length(uv - AXIS) - 0.05, vec3(1.0, 0.8, 0.0));\n\n    float aspect = iResolution.x / iResolution.y;\n    color = digitIn(color, vec3(1.0), uv * 0.25 + vec2(0.45 * aspect, 0.45), 100.0, flowerInertia(RADIUS, AMP, FREQ, AXIS));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define PI 3.14159265359\n\n// Flower settings (AMP and FREQ control petals)\n#define RADIUS 1.0\n#define AMP 0.5\n#define FREQ 5.0\n#define AXIS (ivec2(iMouse.xy) == ivec2(0) ? vec2(-1.0, 0.6) : (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 4.0)\n#define DENSITY 0.1\n\n// Simulation settings\n#define FRICTION 0.98\n#define GRAVITY 0.2\n\n// cross3D(vec3(a.x, a.y, 0), vec3(b.x, b.y, 0))\n// Since the x and y components of the result are always zero\n// The z component is the only one of interest\nfloat cross2D(in vec2 a, in vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Centroid of a flower shape\nvec2 flowerCentroid(in float c, in float a, in float f) {\n    return a / (4.0 * PI) * vec2(sin((1.0 - f) * 2.0 * PI) / (1.0 - f) + sin((1.0 + f) * 2.0 * PI) / (1.0 + f), (1.0 - cos((1.0 - f) * 2.0 * PI)) / (1.0 - f) + (1.0 - cos((1.0 + f) * 2.0 * PI)) / (1.0 + f));\n}\n\n// Mass of a flower shape\nfloat flowerMass(in float c, in float a, in float f, in float density) {\n    float c2 = c * c, a2 = a * a;\n    return ((c2 + a2 / 2.0) * PI + (c * a * sin(2.0 * f * PI) + a2 / 8.0 * sin(4.0 * f * PI)) / f) * density;\n}\n\n/*\n// Moment of inertia of a flower shape about axis p\nfloat flowerInertia(in float c, in float a, in float f, in vec2 p) {\n    float c2 = c  * c,  a2 = a  * a;\n    float c3 = c2 * c,  a3 = a2 * a;\n    float c4 = c2 * c2, a4 = a2 * a2;\n\n    float I = (8.0 * c4 + 24.0 * c2 * a2 + 3.0 * a4) * PI / 16.0 + ((4.0 * c3 * a + 3.0 * c * a3) / 4.0 * sin(2.0 * f * PI) + (6.0 * c2 * a2 + a4) / 16.0 * sin(4.0 * f * PI) + c * a3 / 12.0 * sin(6.0 * f * PI) + a4 / 128.0 * sin(8.0 * f * PI)) / f;\n    I -= ((c2 * a + a3 / 4.0) * (       sin((1.0 - f) * 2.0 * PI)  / (1.0 - f) +        sin((1.0 + f) * 2.0 * PI)  / (1.0 + f)) + c * a2 / 2.0 * (       sin((1.0 - 2.0 * f) * 2.0 * PI)  / (1.0 - 2.0 * f) +        sin((1.0 + 2.0 * f) * 2.0 * PI)  / (1.0 + 2.0 * f)) + a3 / 12.0 * (       sin((1.0 - 3.0 * f) * 2.0 * PI)  / (1.0 - 3.0 * f) +        sin((1.0 + 3.0 * f) * 2.0 * PI)  / (1.0 + 3.0 * f))) * p.x;\n    I -= ((c2 * a + a3 / 4.0) * ((1.0 - cos((1.0 - f) * 2.0 * PI)) / (1.0 - f) + (1.0 - cos((1.0 + f) * 2.0 * PI)) / (1.0 + f)) + c * a2 / 2.0 * ((1.0 - cos((1.0 - 2.0 * f) * 2.0 * PI)) / (1.0 - 2.0 * f) + (1.0 - cos((1.0 + 2.0 * f) * 2.0 * PI)) / (1.0 + 2.0 * f)) + a3 / 12.0 * ((1.0 - cos((1.0 - 3.0 * f) * 2.0 * PI)) / (1.0 - 3.0 * f) + (1.0 - cos((1.0 + 3.0 * f) * 2.0 * PI)) / (1.0 + 3.0 * f))) * p.y;\n    I += ((c2 + a2 / 2.0) * PI + (c * a * sin(2.0 * f * PI) + a2 / 8.0 * sin(4.0 * f * PI)) / f) * dot(p, p);\n\n    return I;\n}\n*/\n\n// Moment of inertia of a flower shape about axis p\nfloat flowerInertia(in float c, in float a, in float f, in vec2 p) {\n    float c2 = c  * c, a2 = a  * a;\n    float c3 = c2 * c, a3 = a2 * a;\n    float c4 = c3 * c, a4 = a3 * a;\n\n    float I = (8.0 * c4 + 24.0 * c2 * a2 + 3.0 * a4) * PI / 16.0 + ((4.0 * c3 * a + 3.0 * c * a3) / 4.0 * sin(2.0 * f * PI) + (6.0 * c2 * a2 + a4) / 16.0 * sin(4.0 * f * PI) + c * a3 / 12.0 * sin(6.0 * f * PI) + a4 / 128.0 * sin(8.0 * f * PI)) / f;\n    I -= ((2.0 * c2 * a + a3 / 2.0) * f / (f * f - 1.0) * sin(2.0 * f * PI) + 2.0 * c * a2 * f / (4.0 * f * f - 1.0) * sin(4.0 * f * PI) + a3 / 6.0 * f / (9.0 * f * f - 1.0) * sin(6.0 * f * PI)) * p.x;\n    I -= ((2.0 * c2 * a + a3 / 2.0) / (1.0 - f * f) * (1.0 - cos(2.0 * f * PI)) + c * a2 / (1.0 - 4.0 * f * f) * (1.0 - cos(4.0 * f * PI)) + a3 / 6.0 / (1.0 - 9.0 * f * f) * (1.0 - cos(6.0 * f * PI))) * p.y;\n    I += ((c2 + a2 / 2.0) * PI + (c * a * sin(2.0 * f * PI) + a2 / 8.0 * sin(4.0 * f * PI)) / f) * dot(p, p);\n\n    return I;\n}\n\n// SPECIAL CASE OF INTEGER FREQUENCY (no weird half petals and whatnot)\n/*\nvec2 flowerCentroid(in float c, in float a, in float f) {\n    return vec2(0.0, 0.0);\n}\n\n// Mass of a flower shape\nfloat flowerMass(in float c, in float a, in float f, in float density) {\n    return (c * c + a * a / 2.0) * PI * density;\n}\n\n// Moment of inertia of a flower shape about axis p\nfloat flowerInertia(in float c, in float a, in float f, in vec2 p) {\n    float c2 = c  * c, a2 = a  * a;\n    float I = (8.0 * c2 * c2 + 24.0 * c2 * a2 + 3.0 * a2 * a2) * PI / 16.0;\n    I += (c2 + a2 / 2.0) * PI * dot(p, p);\n    return I;\n}*/\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM  2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "buffer_a_code": "void mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(0.0, 0.0, 0.0, 0.0);\n    addr -= 0.5;\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame > 0 && iAddr == ivec2(0) && iMouse.z < 0.5) {\n        data = texelFetch(iChannel0, ivec2(0), 0);\n\n        float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n        float co = cos(ang), si = sin(ang);\n        mat2 rot = mat2(co, si, -si, co);\n\n        vec2 centerOfMass = (flowerCentroid(RADIUS, AMP, FREQ) - AXIS) * rot;\n\n        vec2 force = vec2(0.0, -flowerMass(RADIUS, AMP, FREQ, DENSITY) * GRAVITY);\n        float torque = cross2D(-centerOfMass, force);\n\n        data.y += torque / flowerInertia(RADIUS, AMP, FREQ, AXIS);\n        data.y *= FRICTION;\n        data.x += data.y;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2SzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 61, 94, 94, 184], [185, 185, 207, 207, 301], [302, 302, 324, 324, 418], [419, 419, 482, 482, 1209], [1291, 1291, 1346, 1346, 2167]]}
{"id": "7ljXzG", "name": "Wave Cave", "author": "dr2", "description": "Wave pattern projected on cave walls", "tags": ["tunnel", "wave", "cave", "project"], "likes": 5, "viewed": 313, "published": 3, "date": "1627979235", "time_retrieved": "2024-07-30T19:07:50.774058", "image_code": "// \"Wave Cave\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Wave pattern (from \"Wave Room 2\") projected on cave walls (from \"Nautilus\" series)\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, gloPos;\nfloat tCur, dstFar, cvSize;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 TrkPath (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrkPath (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.5 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.01, -0.01);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dLim)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, h);\n    if (sh < 0.05 || d > dLim) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 t2;\n  float wFreq, wAmp, ht, tWav;\n  tWav = 0.2 * tCur;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t4 = (p.xyxy + tWav * vec2 (1., -1.).xxyy) * wFreq;\n    t4 += 2. * vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw)).xxyy - 1.;\n    t4 = abs (sin (t4));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t2 = 1. - sqrt (v4.xz * v4.yw);\n    t2 *= t2;\n    t2 *= t2;\n    ht += wAmp * dot (t2, t2);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 WaveNfH (vec2 p)\n{\n  vec3 v;\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  p *= 2.;\n  for (int j = VAR_ZERO; j < 3; j ++) v[j] = WaveHt (p + ((j == 0) ? e.yy : ((j == 1) ? e.xy : e.yx)));\n  return vec4 (normalize (vec3 (-0.2 * (v.x - v.yz), e.x)), v.x);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 hn4;\n  vec3 vn, col, bgCol, ltVec;\n  vec2 u;\n  float dstObj, wGlow, sh, atten, ltDist;\n  dstObj = ObjRay (ro, rd);\n  wGlow = mix ((0.9 + 0.1 * sin (8. * pi * tCur)) * pow (max (dot (rd, normalize (gloPos - ro)), 0.), 1024.),\n     0., smoothstep (-0.2, 0.2, length (gloPos - ro) - dstObj));\n  bgCol = vec3 (0., 0.1, 0.1);\n  col = bgCol;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    ltVec = ltPos - dstObj * rd;\n    ltDist = length (ltVec);\n    atten = (1. - smoothstep (0.1, 0.6, ltDist / dstFar)) / (1. + 0.002 * pow (ltDist, 1.5));\n    ltVec /= ltDist;\n    vn = ObjNf (ro);\n    u = vec2 (atan (vn.x, vn.z) + pi, tan (2. * atan (0.5 * asin (vn.y)))) / (2. * pi);\n    hn4 = mix (WaveNfH (u), WaveNfH (u - vec2 (1., 0.)), u.x);\n    vn = vn * DirToRMatT (normalize (hn4.xyz), vec3 (0., 1., 0.));\n    vn = VaryNf (16. * ro, vn, 0.2);\n    sh = ObjSShadow (ro, ltVec, ltDist);\n    col = mix (vec3 (0.3, 0.9, 0.7), vec3 (0.2, 0.6, 0.9), smoothstep (0.6, 0.7, hn4.w));\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, ltVec), 0.)) +\n       0.3 * step (0.95, sh) * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.45, 0.95, dstObj / dstFar)) * atten;\n  }\n  col += wGlow * vec3 (0.5, 0.5, 0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv;\n  float el, az, asp, zmFac, t, dVu;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = pi * mPtr.y;\n  }\n  cvSize = 7.;\n  tCur = mod (tCur, 1800.);\n  t = 3. * tCur;\n  dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n  ro = TrkPath (t + 3. * cvSize * dVu);\n  ro.x += 2. * (1. - abs (dVu));\n  ro.y = 2. + 2. * (1. - abs (dVu));\n  vd = TrkPath (t) - ro;\n  vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n  gloPos = TrkPath (t + 10. * cvSize);\n  zmFac = 1.5;\n  rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uv.x / (asp * zmFac))) * asp * zmFac,\n     uv.y, zmFac));\n  ltPos = vuMat * vec3 (0., 0.5, 0.);\n  dstFar = 50. * cvSize;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  float s;\n  vc = cross (vu, vd);\n  s = length (vc);\n  if (s > 0.) vc /= s;\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljXzG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[539, 539, 563, 563, 662], [664, 664, 686, 686, 943], [945, 945, 978, 978, 1182], [1184, 1184, 1205, 1205, 1458], [1460, 1460, 1509, 1509, 1760], [1762, 1762, 1785, 1785, 2345], [2347, 2347, 2370, 2370, 2596], [2598, 2598, 2633, 2633, 3906], [3908, 3908, 3964, 3964, 4978], [4980, 4980, 5016, 5016, 5145], [5147, 5147, 5183, 5183, 5389], [5391, 5391, 5448, 5448, 5531], [5533, 5533, 5563, 5563, 5676], [5710, 5710, 5734, 5734, 5846], [5848, 5848, 5873, 5873, 6059], [6061, 6061, 6090, 6090, 6302], [6304, 6304, 6343, 6343, 6600]]}
{"id": "sl2SzG", "name": "image pixel ", "author": "HanShaoqiu", "description": "pixel", "tags": ["pixel"], "likes": 4, "viewed": 266, "published": 3, "date": "1627977424", "time_retrieved": "2024-07-30T19:07:51.587882", "image_code": "#define row 80.0\n#define column 45.0\n\nvec3 Fetch(vec2 pos) {\n  float minScale = 0.0;\n  float maxScale = 10.0;\n  float factor = clamp(minScale,maxScale,iTime*0.1+0.1);\n  vec2 res = vec2(row, column)*factor;\n  pos=floor(pos*res)/res;\n  return texture(iChannel0,pos.xy,-16.0).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = Fetch(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2SzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 60, 60, 279], [281, 281, 338, 388, 545]]}
{"id": "fl2XDw", "name": "Pill Poppers", "author": "byt3_m3chanic", "description": "Playing with transitions between views - in an isometric/domain repetition way. needed to publish so I would stop playing with it and move to something new.", "tags": ["pillpoppers"], "likes": 12, "viewed": 309, "published": 3, "date": "1627975396", "time_retrieved": "2024-07-30T19:07:52.377770", "image_code": "/**\n\n    08/03/21 @byt3_m3chanic\n    Isometric tile pattern, playing with view\n    transitions - wanted something more than a hard\n    cut - came up with this wipe/slide.\n    \n    otherwise cheap refraction and a truchet design.\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n#define PI  3.14159265359\n#define MIN_DIST .0001\n\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\nvoid pmod(inout vec2 p, float rep) \n{\n    float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angle*.5;\n    a = mod(a,angle) - angle*.5;\n    p = vec2(cos(a),sin(a))*length(p);\n} \n//SDF's @iq\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat octa( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat cap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global\nmat2 r45,turn;\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time,tmod,xln=0.,ga1,ga2,ga3,ga4;\n\nconst vec2 sc = vec2(.15), hsc = .5/sc; \n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    \n    p.xy+=vec2(time,5.);\n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/sc;\n    vec3 q = vec3(r.x,p.y,r.y);\n\n    float rnd = hash21(id);\n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n\n    float hgt = 1.75;\n    vec3 fq = vec3(abs(q.x),q.y,abs(q.z));\n    float b3 =  cap(fq-vec3(hsc.x,hgt,hsc.x),.5,hgt);\n    if(b3<res.x) {\n        res = vec2(b3,4.);\n    \thit=p;\n        gto=vec3(0.,dir,rnd);\n    }\n\n    float rt = mod(floor(rnd*10.),4.)+2.;\n    vec3 qt =q-vec3(0,2.,0);\n    qt.yz*=rot(T*rnd);\n    \n    float t1 = torus(qt,vec2(1.56,.025));\n    vec3 qf = qt;\n    qf.xy*=turn;\n    float b1 = min(box(qf,vec3(.55)),t1);\n\n    qt.xz*=turn;\n    pmod(qt.xz,rt);\n    qt.x-=1.5;\n\n    float b2 = octa(qt,.5);\n    b2=max(b2,-t1);\n    b2=min(b1,b2);\n    if(b2<res.x) {\n        res = vec2(b2,2.);\n    \thit=qt;\n        gid=id;\n        gto=vec3(0.,dir,rnd);\n    }\n\n    float d9 = p.y;\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=p;\n        gto=vec3(0.,dir,rnd);\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n)\n{\n    n = normal(p,d,1.01);\n    vec3 lpos =  vec3(1,4,-1);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n\n    float shdw = 1.;\n    for( float t=.05; t < 14.; )\n    {\n        float h = map(p + l*t).x;\n        if( h<MIN_DIST ) { shdw = 0.; break; }\n        shdw = min(shdw, 18.*h/t);\n        t += h * .95;\n        if( shdw<MIN_DIST || t>32. ) break;\n    }\n    diff = mix(diff,diff*shdw,.4);\n\n    vec3 h = vec3(0.800,0.961,0.929);\n    \n    if(m==1.) {\n        hitPoint*=sc.xxx;\n        vec3 b = vec3(0.122,0.341,0.078);\n        vec3 w = vec3(0.329,0.627,0.545);\n        h = b;\n        vec2 grid_uv = fract(hitPoint.xz)-.5;\n        vec2 grid_id = sid;\n        float px = fwidth(hitPoint.x);\n\n        float rnd = sto.z;\n        float dir = sto.y;\n        if(rnd>.5) grid_uv.x*=-1.;\n\n        vec2 d2 = vec2(length(grid_uv-.5), length(grid_uv+.5));\n        vec2 gx = d2.x<d2.y? vec2(grid_uv-.5) : vec2(grid_uv+.5);\n        float blb = length(gx)-.5;\n        float curve =blb;\n        \n        curve=abs(abs(abs(abs(curve)-.05)-.05)-.025)-.0015;\n        curve = smoothstep(.011,.01,curve);\n        h=mix(h,vec3(0.792,0.894,0.929),curve);\n        \n        if(rnd<.5 ^^ dir>0.) blb*=-1.;\n        blb=smoothstep(.01,.011,blb);  \n        h=mix(h,w,1.-blb);\n\n        float cir2 = length(abs(grid_uv)-vec2(.5))-.16;\n        cir2 = smoothstep(.01,.011,abs(abs(abs(cir2)-.05)-.025)-.0025);\n        h=mix(h,vec3(0.792,0.894,0.929),1.-cir2);\n    }   \n\n    if(m==4.) {\n        h= vec3(0.584,0.894,0.525);\n    }\n\n    return (h*diff);\n}\n\nfloat zoom = 13.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    time = T;\n    r45 = rot(45.*PI/180.);\n    turn = rot(time*.75);\n    tmod = mod(time*.5, 10.);\n    float t1 = lsp(3.0, 5.0, tmod);\n    float t2 = lsp(8.0, 10.0, tmod);\n    ga1 = ((t1-t2)*2.2)-1.1;\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    //wipe\n    xln = ga1-(.025*sin(uv.y*25.+T*5.));\n    if(uv.x>xln) zoom *= .5;\n    \n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n    // use x in ry to mouse pan the scene..\n    //float x = M.xy == vec2(0) ? -.78539816339 : - (M.x/R.x * 4. - 2.) * PI *.5;\n    mat2 rx = rot(-0.78539816339);\n    mat2 ry = rot(time*.025);\n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = .725;\n    float k = 1.;\n    float d = 0.;\n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = ray.x * .725;\n        p += rd * d *k;\n        \n        if (d*d < 1e-6) {\n            hitPoint = hit;\n            sid = gid;\n            sto = gto;\n            \n            C+=render(p,rd,ro,d,ray.y,n)*atten;\n            if(m==1.)break;\n            \n            atten *= .65;\n            p += rd*.025;\n            k = sign(map(p).x);\n            \n            vec3 rr = vec3(0);\n            if(m==4.){\n                rd=reflect(-rd,n);\n                p+=n*.1;\n            }else{\n                float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 3.);\n                fresnel = mix(.01, .7, fresnel);\n                rr = refract(rd,n,.4);\n                rd=mix(rr,rd,1.-fresnel);\n     \n            }\n        } \n       \n        if(distance(p,rd)>125.) { break; }\n    }\n    \n    if(uv.x>xln && uv.x-.01<xln)C=vec3(1);\n    C = mix(C,C+.07,hash21(uv));\n    C = clamp(C,vec3(.03),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 383, 383, 438], [439, 439, 459, 459, 504], [505, 505, 529, 529, 587], [589, 589, 626, 626, 770], [772, 784, 813, 813, 900], [901, 901, 931, 931, 984], [985, 985, 1016, 1016, 1081], [1083, 1083, 1122, 1122, 1229], [1379, 1379, 1397, 1397, 2434], [2436, 2436, 2481, 2481, 2696], [4330, 4330, 4371, 4385, 6239]]}
{"id": "stjSRG", "name": "Tire tracks", "author": "jarble", "description": "This fractal looks like tire tracks in the sand.\n", "tags": ["procedural", "fractal", "terrain", "desert", "erosion"], "likes": 1, "viewed": 245, "published": 3, "date": "1627960742", "time_retrieved": "2024-07-30T19:07:53.242458", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of erosion\n#define OCTAVES 5\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = 5.;\n    uv *= factor;\n    //uv = uv.yx;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv.x *= factor;\n        uv += max(sin(uv*factor)/factor,cos(uv/factor)*factor);\n        value = min(value,sin((uv.x-uv.y-value))/factor);\n        uv.y /= factor;\n\n        uv= -uv.yx/(factor);\n        //factor /= 1.5;\n        value /= 1.5;\n    }\n    \n    return value+.5;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 512, 561, 967], [1041, 1041, 1079, 1079, 1139], [1141, 1141, 1174, 1174, 1394], [1396, 1396, 1434, 1434, 1661], [1663, 1663, 1701, 1701, 1925], [1927, 1927, 1956, 1956, 2051], [2053, 2053, 2090, 2090, 2149], [2152, 2220, 2239, 2239, 2278], [2280, 2280, 2300, 2300, 2376], [2378, 2378, 2397, 2397, 2436], [2438, 2438, 2495, 2495, 2730], [2732, 2732, 2767, 2767, 3161], [3163, 3163, 3217, 3217, 3883], [3886, 3886, 3938, 3938, 4373], [4375, 4375, 4432, 4432, 5623]]}
{"id": "fljXzy", "name": "basic tv", "author": "jorge2017a1", "description": "basic tv", "tags": ["basictv"], "likes": 7, "viewed": 205, "published": 3, "date": "1627958013", "time_retrieved": "2024-07-30T19:07:54.168981", "image_code": "\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+30.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    \n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist4,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist5,-1.0 ,8.0)); \n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n          p.y=p.y-5.0;\n   float sdb1= sdBox( p-vec3(0.0,15.0,10.0), vec3(20.0,15.0,0.5) );\n   float sdb2= sdBox( p-vec3(0.0,15.0,11.0), vec3(21.0,16.0,1.0) );\n   \n   res =opU3(res, vec3(sdb2,1.0,-1)); \n   res =opU3(res, vec3(sdb1,100.0,-1)); \n    \n    \n   float sdsp1= sdSphere( p-vec3(-10.0,0.0,0.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,201.0,-1)); \n   \n   //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 renderReflect(TObj Obj, vec3 ro, vec3 rd, vec3 col )\n{  vec3 p;\n   float t;\n   vec3 colobj;  vec3 n;\n \n  /////-----------REFLECT--------------\n    if (int( Obj.id_color) ==201)\n    { vec3 colref;\n      for(int i=0; i<2; ++i)\n      {  t=RayMarch(ro,rd, MAX_STEPS);\n         Obj=mObj;\n        \n     \n        \n        if( t<0.0 || t>MAX_DIST ) break;\n        p=ro+rd*t;\n        n=GetNormal(p);\n        //produce ondas de mar\n        //n=normalize(n+0.01*sin(10.0* p+2.0*iTime));\n        \n        rd=reflect(rd,n);\n        ro =p+rd * MIN_DIST * 3.;\n        \n        if (t<MAX_DIST)\n        colobj=GetColorYMaterial( p, n, ro, rd,  int( Obj.id_color), Obj.id_material)*2.0;\n        \n        colref=  Getluz( p,ro,rd, n, colobj ,light_pos1);\n        colref+= Getluz( p,ro,rd, n, colobj ,light_pos2);\n        \n       }\n     col+=colref/(float(REFLECT));\n   } \n   return col;\n} \n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        \n        col= result;\n    }\n    \n    col= renderReflect(Obj,  ro,  rd,  col );\n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,7.0+abs(15.0*sin(t)),-25.0);\n\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n  \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "buffer_a_code": "\n//https://www.shadertoy.com/view/stSSWW\n// Fractal 71_gaz\n// Created by gaz in 2021-07-30\n\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    O-=O;\n    vec3 r=iResolution,\n    p=vec3((C.xy-.5*r.xy)/r.y,0)-iTime*.05;\n    p=asin(sin(p*3.));\n    float s=1.,e;\n    for(int i=0;i<7;i++)\n        p=abs(p)-1.2,\n        s*=e=3./clamp(dot(p,p),.8,2.),\n        p=p*e-3.;\n        O.xyz+=mix(vec3(1),H(log(s)*.5),.7)*3e-3/abs(p.z/s);\n}\n\n\n", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[527, 527, 563, 563, 584], [585, 585, 617, 617, 701], [703, 787, 812, 812, 1920], [1922, 1973, 1997, 1997, 2159], [2161, 2161, 2210, 2210, 2877], [2879, 2966, 3002, 3002, 3247], [3248, 3303, 3330, 3330, 3347], [3349, 3349, 3385, 3385, 3477], [3478, 3478, 3524, 3524, 3649], [3651, 3651, 3725, 3725, 5324], [5325, 5380, 5429, 5429, 5672], [5673, 5707, 5787, 5787, 5910], [5953, 6001, 6029, 6029, 6217], [6220, 6271, 6318, 6318, 6557], [6559, 6611, 6704, 6704, 7129], [8008, 8008, 8039, 8039, 8633], [8635, 8684, 8710, 8710, 8820], [8822, 8822, 8880, 8880, 8932], [8934, 8983, 9040, 9040, 9649]]}
{"id": "ft2XzG", "name": "A Beach of sorts", "author": "Plento", "description": "This is the boot screen for your brain.", "tags": ["3d", "mouse", "raymarch"], "likes": 23, "viewed": 428, "published": 3, "date": "1627956465", "time_retrieved": "2024-07-30T19:07:55.140383", "image_code": "\n// Cole Peterson\n\n// This is the boot screen of your brain.\n\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\n\nmat2 rot(float a) {return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nfloat rbox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat box2d( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    float h = 0.5 - texture(iChannel1, rp.xz*.8).x * .065;\n    h += texture(iChannel1, rp.xz*2.3).x * .0088;\n   \n    d = rp.y + h;\n    d = min(rp.y + .49, d);\n    \n    rp.y -= .5;\n    vec3 b = vec3(3., 0., 2.);\n    vec3 id = floor(rp / b);\n    rp.y += cos(id.z*10. + id.x*33. + iTime)*.03;\n    vec3 ruv = mod(rp, b) - b*0.5;\n    \n    d = min(rbox(ruv, vec3(.3, .3, .3), .01), d);\n    \n    return d;\n}\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u - .5*R) / R.y;\n    vec3 rd = normalize(vec3(uv, 0.72));\n    vec3 rd2 = rd;\n    vec3 ro = vec3(0., -0.3, 0.);\n    \n    vec2 m = (iMouse.xy - .5*R) / R.y;\n    \n    rd.zy *= rot(.15);\n    \n    if(iMouse.z > 0.){\n        rd.zy *= rot(m.y*3.);\n        rd.zx *= rot(m.x*3.);\n    }\n    \n    rd.yz *= rot(-cos(iTime*3.)*.01);\n    ro.y += cos(iTime*3.)*.004;\n    ro.z += iTime*.1;\n    \n    float d = 0.0, t = 0.0, ns = 0.;\n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \n        if(d < 0.002 || t > 40.) break;\n        t += d * .75;\n        ns++;\n    }\n    \n    vec3 p = ro + rd*t;\n    \n    vec3 n = normal(p);\n    vec3 ref = reflect(n, rd);\n    vec3 lp = ro + vec3(.6, 0.5, 2.4);\n    vec3 ld = normalize(lp-p);\n    \n    float dif = max(dot(n, ld), .0);\n    float spec = pow(max(dot( reflect(-ld, n), -rd), 0.), 28.);\n    \n    vec3 objCol = vec3(0);\n    \n    vec3 rock = vec3(.8, .7, .6) * .97 * max(texture(iChannel1, p.xz*1.4).x, .4);\n    vec3 water = vec3(.7, .8, .9) * .8;\n    vec3 sky = vec3(.9, .97, .99);\n    float clouds = octnse(rd.xy, 28.38, 5) * .8;\n    \n    vec2 suv = mod(p.xz + vec2(0., 0.6), vec2(3., 2.)) - vec2(3., 2.)*.5;\n    float sdw = ss(0., .1, box2d(suv, vec2(.5, .5)));\n    \n    rock *= sdw;\n    \n    water += texture(iChannel0, ref).xyz;\n    water *= .8;\n    water *= sdw;\n    \n    vec2 auv = p.xz;\n    \n    auv.x += cos(iTime + auv.y*32.)*.01;\n    auv.y += sin(iTime + auv.x*32.)*.01;\n    auv += iTime*.01;\n    \n    water *= max(texture(iChannel2, auv*0.98).x, .2);\n    \n    float nt = .08, nt2 = -.35;\n    float blend = ss(-.4 - nt, -.405 - nt, p.y);\n    objCol = mix(rock, water, blend);\n    objCol = mix(vec3(1), objCol, ss(nt2 + .03, nt2, p.y));\n    \n    vec3 col = (objCol * dif) + vec3(.9, .8, .7)*spec*.4;\n\n    col = mix(vec3(.99, .97, .9) * clouds, col,  exp(-t*t*t*.08));\n   \n    col.r += .015;\n    \n    col *= ss(.4301, .43, abs(uv.y));\n    \n    col *= min(iTime * 0.6, 1.);\n    \n    f = vec4(col, 1.0);\n    //f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec2 hash22( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\nfloat gdns(vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = smoothstep(0., 1., f);\n    \n    vec2 a = hash22(i);\n    vec2 b = hash22( i + vec2(1.,0.));\n    vec2 c = hash22( i + vec2(.0,1.));\n    vec2 d = hash22( i + vec2(1));\n    \n    //rotAll(a, b, c, d);\n    \n    float nse = mix( mix( dot( a, f - vec2(0.0,0.0) ), \n                     dot( b, f - vec2(1.0,0.0) ), u.x),\n                mix( dot( c, f - vec2(0.0,1.0) ), \n                     dot( d, f - vec2(1) ), u.x), u.y);\n    return nse + 0.5;\n}\n\nfloat octnse(vec2 p, float t, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n        p.x+=t;\n     \tn += gdns(p) * a;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2XzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 149, 149, 195], [197, 197, 235, 235, 326], [328, 328, 364, 364, 444], [446, 446, 465, 465, 891], [894, 894, 921, 921, 1122], [1125, 1125, 1165, 1165, 3181]]}
{"id": "ft2Szy", "name": "many cylinders", "author": "jorge2017a1", "description": "many cylinders", "tags": ["manycylinders"], "likes": 9, "viewed": 216, "published": 3, "date": "1627955535", "time_retrieved": "2024-07-30T19:07:56.146693", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdCylinder( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n\nvec3 CilindroMario(vec3 p , float alto )\n{\n\tvec3 res= vec3(9999.0, -1.0,-1.0);  \n\n    float sdcA1= sdCylinderXZ( p, vec2(3.0,5.0+alto) );\n    float sdcA2= sdCylinderXZ( p, vec2(2.5,5.5+alto) );\n    \n    float sdcB1= sdCylinderXZ( p-vec3(0.0,5.0+alto,0.0), vec2(3.5,1.0) );\n    float sdcB2= sdCylinderXZ( p-vec3(0.0,5.0+alto,0.0), vec2(3.0,1.5) );\n    \n    \n    float difA= differenceSDF(sdcA1, sdcA2);\n    float difB= differenceSDF(sdcB1, sdcB2);\n    \n    res =opU3(res, vec3(difA,3.0,MATERIAL_NO));\n    res =opU3(res, vec3(difB,3.0,MATERIAL_NO));\n    return res;\n}    \n    \n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\tvec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n   \n    res =opU3(res, vec3(planeDist1,-1.0,10.0)); //inf\n    //res =opU3(res, vec3(planeDist1,-1.0,6.0)); //inf\n    \n   \n          p.y=p.y-5.0;\n     vec3 p1=p-vec3(0.0,0.0,0.0);\n    vec3 p2=p-vec3(0.0,0.0,10.0);\n    vec3 p3=p-vec3(10.0,0.0,20.0);\n    \n    p1.x= opRep1D( p1.x, 20.0 );\n    p2.x= opRep1D( p2.x, 10.0 );\n    p3.x= opRep1D( p3.x, 15.0 );\n    \n    vec3 c1= CilindroMario(p1,0.0 );\n    vec3 c2= CilindroMario(p2,5.0 );\n    vec3 c3= CilindroMario(p3,10.0 );\n    \n    res =opU3(res, c1);\n    res =opU3(res, c2);\n    res =opU3(res, c3);\n    \n    //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    \n    #define DISTANCE_BIAS 0.75\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n            {mObj.hitbln = true; minDist = abs(t); break;}\n        if(t>MAX_DIST)\n            {mObj.hitbln = false;    minDist = t;    break; } \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{   vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ vec3 l = normalize(lp - p);\n  vec3 r = reflect(-l, n);\n  float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n  return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{   vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    //float dist=distA;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n     float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n        {fshadow=GetShadow(p,lp);}\n    else\n        {fshadow=0.5;}\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n     lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n    //return lin*atten*(1.0/2.0);\n    \n}\n//----------------------------------------------------\n\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{  float intensity=1.0;\n     vec3 result;\n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{ vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n       \n    if (id_material==6.0)\n    {  float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n \n    if (id_material==10.0)\n    {\n     vec3 color;\n        float worldXMod16\t= mod( p.x*3.5, 16.0 );\n    \tfloat worldYMod16 \t= mod( p.z*3.5, 16.0 );\n        \n        SpriteBlock(color, worldXMod16, worldYMod16 );\n        return   color;\n    }\n    \n}\n\n//-------------------------------------------------\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{  \tvec3 colobj; \n    \n    if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p;\n  float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {   p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n           col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c));\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*5.0,500.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 10.0, 10.0 ); light_color2 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0+t,7.0+abs(8.0*sin(t*0.25)),-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n  \n    ///col = pow(col, vec3(0.6545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), \nvec3(0.302,0.545,1.000)\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n\nvoid SpriteBlock( inout vec3 color, float x, float y )\n{\n    // black\n    float idx = 1.0;\n    \n    // light orange\n    idx = x < y ? 3.0 : idx;\n    \n    // dark orange\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\n    idx = x == 15.0 - y ? 2.0 : idx;\n    \n    color = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\n{\n\tfloat idx = 0.0;\n    \n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\n\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\n\tcolor = idx == 2.0 ? colorB \t\t: color;\n\tcolor = idx == 3.0 ? colorC \t\t: color;\n}\n\n\n\nvoid SpriteHill( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    // dark green\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\n    \n    // black\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n}\n\n\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\n{\n    float offset = h * 16.0;\n\n    // light green\n\tfloat idx = 3.0;\n    \n    // dark green\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \n    \n    // black\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \n    \n    // transparent\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\n\nvoid SpriteGround( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2Szy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 516, 516, 611], [612, 612, 651, 651, 746], [747, 747, 786, 786, 881], [882, 882, 921, 921, 1016], [1018, 1062, 1109, 1109, 1136], [1137, 1137, 1180, 1180, 1207], [1208, 1208, 1256, 1256, 1284], [1285, 1323, 1359, 1359, 1404], [1447, 1447, 1489, 1489, 2012], [2023, 2063, 2088, 2088, 2838], [2840, 2891, 2915, 2915, 3077], [3079, 3079, 3128, 3128, 3795], [3796, 3850, 3886, 3886, 4131], [4132, 4187, 4214, 4214, 4231], [4233, 4233, 4269, 4269, 4361], [4362, 4362, 4408, 4408, 4533], [4535, 4535, 4609, 4609, 6234], [6291, 6291, 6371, 6371, 6494], [6495, 6536, 6568, 6568, 6765], [6767, 6818, 6865, 6865, 7475], [7477, 7529, 7622, 7622, 7963], [7966, 7966, 7997, 7997, 8592], [8594, 8643, 8669, 8669, 8779], [8781, 8781, 8839, 8839, 8891], [8893, 8942, 8999, 8999, 9650]]}
{"id": "fl2XRy", "name": "Dunes and canyons", "author": "jarble", "description": "Another fractal terrain. This one has many dry riverbeds.\nThis one isn't very realistic: my [url=https://www.shadertoy.com/view/NljXDK]\"Mountains and Plains\"[/url] shader is much better.", "tags": ["procedural", "fractal", "terrain", "river", "erosion"], "likes": 4, "viewed": 282, "published": 3, "date": "1627952609", "time_retrieved": "2024-07-30T19:07:56.966501", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of erosion\n#define OCTAVES 4\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = 5.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        uv += min(sin(uv*factor)/factor,cos(uv/factor)*factor);\n        value = min(value,sin((uv.x-uv.y-value))/factor);\n        uv= -uv/(factor);\n    }\n    \n    return value+.5;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 0.05;\n    #endif\n    \n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 512, 561, 850], [924, 924, 962, 962, 1022], [1024, 1024, 1057, 1057, 1277], [1279, 1279, 1317, 1317, 1544], [1546, 1546, 1584, 1584, 1808], [1810, 1810, 1839, 1839, 1934], [1936, 1936, 1973, 1973, 2032], [2035, 2103, 2122, 2122, 2161], [2163, 2163, 2183, 2183, 2259], [2261, 2261, 2280, 2280, 2319], [2321, 2321, 2378, 2378, 2613], [2615, 2615, 2650, 2650, 3044], [3046, 3046, 3100, 3100, 3766], [3769, 3769, 3821, 3821, 4256], [4258, 4258, 4315, 4315, 5506]]}
{"id": "fl2SzG", "name": "Eroded rivers and plains", "author": "jarble", "description": "The erosion here is totally fake, but it looks realistic enough.", "tags": ["procedural", "fractal", "terrain", "river", "erosion"], "likes": 4, "viewed": 276, "published": 3, "date": "1627941607", "time_retrieved": "2024-07-30T19:07:57.716496", "image_code": "#define PI 3.14159265359\n#define viewAngle (PI*0.6)\n#define distToScreen (0.5*max(iResolution.x, iResolution.y)/tan(0.5*viewAngle))\n#define maxDist 70.0\n#define maxStep 500\n#define nEPS 0.0125\n\n#define meanWaterLevel -0.5\n\n#define SKY 0.0\n#define WATER 1.0\n#define LAND 2.0\n\n// MODE 0 sticks the camera to the ground. Drag the mouse to explore.\n// MODE 1 makes the camera fly above the terrain\n#define MODE 1\n\n\n//increase this constant to increase the amount of erosion\n#define OCTAVES 5\n\nfloat fbm(in vec2 uv)\n{\n    //this function generates the terrain height\n    float value = 0.;\n    float factor = 3.;\n    uv *= factor;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        //uv = sin(uv/factor)*factor;\n        uv += min(sin(uv*factor)/factor,cos(uv/factor)*factor).yx;\n        value += sin((uv.x-uv.y-value))/factor;\n        \n        //uv += sin(dot(sin(uv/factor),sin(uv.yx/factor)));\n        uv= -uv/(factor);\n    }\n    \n    return value;\n}\n\n\nstruct MarchResult {\n    float dist;\n    vec3 pos;\n    float type;\n};\n\nfloat getElevation(vec2 uv, float d) {\n    float factor = 3.0;\n    return fbm(uv/factor)*factor;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nfloat getWaterLevel(vec2 p, float d) {\n    if (d<5.0) {\n    \tfloat t = iTime*1.0;\n    \tp*=7.0;\n    \tfloat w = 0.00025*smoothstep(0.0, 1.0, 0.5/(d+0.00001));\n    \treturn w*(sin(p.y*7.37+t*2.0) + sin(p.x*2.37+t)) + meanWaterLevel;\n    }\n\telse return meanWaterLevel;\n}\n\nvec3 getWaterNormal(vec3 p, float d) {\n    return normalize(vec3(\n        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),\n        2.0*nEPS,\n        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)\n    ));\n}\n\nvec3 rayToPixel(vec2 pixel) {\n    pixel -= 0.5*iResolution.xy;\n    return normalize(vec3(pixel.x, pixel.y, distToScreen));\n}\n\nfloat estDistToTrn(vec3 p, float d) {\n    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);\n}\n\n\n// TODO generate procedural textures for rocks and grass on the fly\nvec4 rock(vec3 p) {\n    return texture(iChannel0, p.xz);\n}\n\nvec4 grass(vec3 p) {\n    return mix(vec4(0.2, 0.4, 0.15, 1.0), texture(iChannel1, p.xz), 0.1);\n}\n\nvec4 snow(vec3 p) {\n    return vec4(0.9, 0.9, 0.9, 1.0);\n}\n\nvec4 fog(vec3 ray, float d, vec3 sunDir, vec4 material) {\n    float fogAmount = 1.0-exp(-d*0.035);\n    float sunAmount = pow(max(dot(ray, sunDir), 0.0), 90.0);\n    vec4 fogCol = mix(vec4(0.3, 0.7, 0.9, 1.0), vec4(1.0, 0.9, 0.7, 1.0), sunAmount);\n    return mix(material, fogCol, fogAmount);\n}\n\nvec4 terrain(vec3 p, vec3 sunDir) {\n    vec3 normal = getNormal(p, 0.0);\n\tvec3 abnormal = abs(normal);\t    \n\tvec4 grassRock = mix(grass(p), rock(p), smoothstep(0.0, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 snowRock = mix(snow(p), rock(p), smoothstep(0.75, 1.0, max(abnormal.x, abnormal.z)));\n   \tvec4 fragC = mix(grassRock, snowRock, smoothstep(0.5, 1.0, p.y));\n   \tfragC *= max(dot(sunDir, normal), 0.2);\n    return fragC;\n}\n\nMarchResult march(vec3 p0, vec3 ray, bool withWater) {\n    float type = SKY;\n    float d = 0.0;\n    int stp = 0;\n    vec3 p = p0;\n    while (type==SKY && d<(withWater?maxDist:maxDist*0.125) && (stp++<(withWater?maxStep:maxStep/3))) {\n        p = p0 + d*ray;\n        float waterLevel = withWater ? /*getWaterLevel(p.xz, d)*/ meanWaterLevel : -9999.9;\n        float stpSize = estDistToTrn(p,d) * (withWater?1.0:2.0);\n        // TODO fix this mess\n        if (p.y<=waterLevel) {\n            type = WATER;\n            d = (waterLevel-p0.y)/ray.y;\n            p = p0+d*ray;\n        }\n        else if (stpSize<d*0.001) type = LAND;\n        else d+= stpSize;\n    }\n    d = min(d, maxDist);\n    return MarchResult(d, p, type);\n}\n\n\nvec4 water(vec3 p, float d, vec3 ray, vec3 sunDir) {\n    vec3 normal = getWaterNormal(p, d);\n    vec3 ref = normalize(reflect(-sunDir, normal));\n    vec4 wc = vec4(0.2,0.55,0.8,1.0);\n    vec4 sc = vec4(0.9,0.9,0.7,1.0);\n    wc *= max(0.35, dot(sunDir, normal));\n    \n    MarchResult uwr = march(p, normalize(reflect(ray, normal)), false);\n    vec4 uwt = terrain(uwr.pos, sunDir);\n    wc = mix(wc, uwt, uwr.type*0.25);\n    \n    return mix(wc, sc, 0.85*pow(max(dot(ref, -ray),0.0),8.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n    float pitch = MODE==0 ? 0.0 : 0.2*sin(iTime*0.2);\n    float yaw = 0.0;\n    float roll = MODE==0 ? 0.0 : 0.1*sin(iTime*0.5);\n\n    vec3 ray = rayToPixel(fragCoord);\n    \n    mat3 tr = mat3(\n        cos(roll),  -sin(roll), 0.0,\n        sin(roll), cos(roll), 0.0,\n        0, 0, 1\n    ) \n    * mat3(\n        cos(yaw), 0.0, sin(yaw),\n        0.0, 1.0, 0.0,\n        -sin(yaw), 0.0, cos(yaw)\n    )\n    * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(pitch), -sin(pitch),\n        0.0, sin(pitch), cos(pitch)\n    )\n    ;\n    ray *= tr;\n    \n    \n    #if MODE\n    vec3 p0 = vec3(17.25, 2.0, 1.0*iTime);\n    #else\n    vec3 p0 = vec3(60.0*iMouse.x/iResolution.x, -0.25, 60.0*iMouse.y/iResolution.y);\n    #endif\n    p0.y = max(getElevation(p0.xz,0.0), getWaterLevel(p0.xz,0.0)) + 1.;\n\n    MarchResult res = march(p0, ray, true);\n    vec3 sunDir = normalize(vec3(0.2, 0.1, 0.15));\n    \n    fragColor = vec4(1.0);\n    if (res.dist<maxDist) {\n        if (res.type==WATER) {\n            fragColor = water(res.pos, res.dist, ray, sunDir);\n        } else if (res.type==LAND) {\n    \t\tfragColor = terrain(res.pos, sunDir);\n        }\n    }\n    \n    fragColor = fog(ray, res.dist, sunDir, fragColor);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2SzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 512, 561, 947], [1021, 1021, 1059, 1059, 1119], [1121, 1121, 1154, 1154, 1374], [1376, 1376, 1414, 1414, 1641], [1643, 1643, 1681, 1681, 1905], [1907, 1907, 1936, 1936, 2031], [2033, 2033, 2070, 2070, 2129], [2132, 2200, 2219, 2219, 2258], [2260, 2260, 2280, 2280, 2356], [2358, 2358, 2377, 2377, 2416], [2418, 2418, 2475, 2475, 2710], [2712, 2712, 2747, 2747, 3141], [3143, 3143, 3197, 3197, 3863], [3866, 3866, 3918, 3918, 4353], [4355, 4355, 4412, 4412, 5597]]}
{"id": "fl2SRG", "name": "pattern in colored grains jar (g", "author": "FabriceNeyret2", "description": "golfing the n=2 version of https://shadertoy.com/view/7tSXzG ( 369 chars )", "tags": ["patterns", "random", "2tweets", "hexagonal", "packing", "golf"], "likes": 8, "viewed": 427, "published": 3, "date": "1627932778", "time_retrieved": "2024-07-30T19:07:58.481450", "image_code": "// golfing 369 chars https://shadertoy.com/view/7tSXzG for n = 2\n\n\n// --- 216 with DjinnKahn's approach https://www.shadertoy.com/view/NtBSRV\n//   ( and quite cheaper )\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    float  s = 1.73;\n    U *= .2;\n                       // to tilted space\n    vec3 C = ceil( mat2x3( 2,1,-1, 0,s,s )/2.  * U );\n                                    // hex coords:  mat3x2(1,0,1,1,0,1)/3 *\n    vec2 H =  mat2(2,0,-1,s) * floor( (C.y + C.xz) / 3. ); // node center\n                                      \n    O  += .5 +    max( 1. - length( U - H ) , 0. )         // disc \n              * ( fract(sin(dot(H, vec2(13,79))) * 4e5) > .5 ? 2.5 : -2.5 ) -O;                                     // blend disc color ( = black or white )\n}                                                          // blend random disc color ( = black or white )\n/**/\n\n/* // --- 196 char : - 16 Xor  -4 Fab\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec3 C = ceil( mat2x3( 2,1,-1, 0, O += 1.73-O ) * U*.1 ) / 3.;\n    vec2 H =  mat2(2,0,-1,O) * floor( C.y + C.xz );\n    O  += .5 + max( 1. - length( U*.2 - H ), 0. )\n               / ( int( sin(H*13.+H.y*79.) * 4e5 )%2 < 1 ? .4 : -.4 ) - O;\n}                                  // use ( int() &2 ) < 1 on Windows  ( sign issue on % )\n/**/\n\n\n\n\n\n/* // --- 219 with my initial approach --------------------\n\nvoid mainImage( out vec4 O, vec2 U )\n{ \n    U *= mat2(.1,-.058,0,.115);            // to tilted space \n           \n    O += .5-O;                             // grey background\n    for(int i=0; i<4; i++) {\n       vec2 D = vec2(i%2,i/2);             // 4 tilted cell corners = hexa grid\n                                           // disc ( back to screen space )\n       O +=     max( 5. - length( (fract(U)-D) *mat2(10,5,0,8.7) ) , 0. ) \n            * ( step(.5, fract(sin(dot(ceil(U)+D, vec2(13,79))) * 4e5) ) - O );\n    }                                      // blend random disc color ( = black or white )\n\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2SRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 169, 207, 207, 757]]}
{"id": "7tBSzy", "name": "Coordinate transformations:rotat", "author": "modesty", "description": "If you have experience in Anti-aliasing, please, take a look at this shader: https://www.shadertoy.com/view/slBXRG\nmaybe you would be able to help with AA. ", "tags": ["rotation", "coordinatetransformation"], "likes": 3, "viewed": 242, "published": 3, "date": "1627927940", "time_retrieved": "2024-07-30T19:07:59.343147", "image_code": "// COORDINATE TRANSFORMATIONS: ROTATION\n// Lets to rotate the shapes.\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\nfloat coordinateGrid(vec2 r) {\n    vec3 axesCol = vec3(0.0, 0.0, 1.0);\n    vec3 gridCol = vec3(0.5);\n    float ret = 0.0;\n    \n    // Draw grid lines\n    const float tickWidth = 0.1;\n    for(float i=-2.0; i<2.0; i+=tickWidth) {\n        // 'i' is the line coordinate\n        ret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n        ret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n    }\n    \n    // Draw the axes\n    ret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n    ret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n    \n    return ret;\n}\n\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n    return 1.0 - smoothstep(radius-0.005, radius+0.005, length(r-center));\n}\n\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n    float ret;\n    float d = 0.005;\n    ret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n    ret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n    ret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n    ret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2(fragCoord.xy/iResolution.xy);\n    vec2 r = 2.0*vec2(fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    float xMax = iResolution.x/iResolution.y;\n    \n    vec3 bgCol = vec3(1.0);\n    vec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n    vec3 col2 = vec3(1.00, 0.329, 0.298);  // yellow\n    vec3 col3 = vec3(0.867, 0.910, 0.247); // red\n    \n    vec3 ret;\n    vec2 q;\n    float angle;\n    angle = 0.2*PI; // angle in radians(PI is 180 degrees);\n    \n    // q is the rotated coordinate system\n    q.x = cos(angle) * r.x + sin(angle) * r.y;\n    q.y = -sin(angle) * r.x + cos(angle) * r.y;\n    \n    ret = bgCol;\n    // draw the old and new coordinate system\n    \n    ret = mix(ret, col1, coordinateGrid(r) * 0.4);\n    ret = mix(ret, col2, coordinateGrid(q));\n    \n    // draw shapes in old coordinate system, r, and new coordinate system, q\n    ret = mix(ret, col1, disk(r, vec2(1.0, 0.0), 0.2));\n    ret = mix(ret, col2, disk(q, vec2(1.0, 0.0), 0.2));\n    ret = mix(ret, col1, rectangle(r, vec2(-0.8, 0.2), vec2(-0.5, 0.4)));\n    ret = mix(ret, col2, rectangle(q, vec2(-0.8, 0.2), vec2(-0.5, 0.4)));\n    // both circle are drawn at the same coordinate, (1,0),\n\t// in their respective coordinate systems. But they appear\n\t// on different locations of the screen\n\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 155, 155, 653], [655, 687, 734, 734, 811], [813, 847, 904, 904, 1201], [1203, 1203, 1260, 1260, 2596]]}
{"id": "7tSXzG", "name": "pattern in colored grains jar", "author": "FabriceNeyret2", "description": "studying the patterns in a jar containing spherical grains of N possible colors.", "tags": ["patterns", "random", "hexagonal", "packing"], "likes": 9, "viewed": 354, "published": 3, "date": "1627919956", "time_retrieved": "2024-07-30T19:08:00.234763", "image_code": "#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define H(p)     floor( fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) *n ) / n\n\n// --- adapted from DjinnKahn's algo https://www.shadertoy.com/view/NtBSRV\n// loopless + no 3-4 cases to consider \n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    float z = .2,  s = 1.73,                  // 1.73 = sqrt(3)\n          n = float(2+int(iTime)%3);          // n = 2,3,4\n    U *= z;\n    \n    vec3 T = mat2x3( 2,1,-1, 0,s,s )/2.  * U, // to tilted space\n         C = ceil(T);\n            \n    vec2 H = floor( (C.y + C.xz) / 3. );      // hex coords center\n                                              // disc once back to screen space\n    O =  smoothstep(z*.7,-z, length( U - mat2(2,0,-1,s) * H ) - 1. )\n       * hue( H(H) );                         // random node color\n}\n\n\n\n\n\n/* // --- my initial version:\n \nvoid mainImage( out vec4 O, vec2 U )\n{\n    float z = .1,   // 25./iResolution.y,\n          n = float(2+int(iTime)%3);   // n = 2,3,4\n    mat2 M = mat2(1,.5,0,.866);        // .866 = sqrt(3.)/2.\n    U *= z *  inverse(M);              // to tilted space\n\n                                       // disc at corner D once back to screen space\n#define D(D)   smoothstep(z*.7,-z, length( (fract(U)-D) *M ) -.5 ) \\\n             * hue( H(floor(U+D)) )    // random node color\n                // on some windows, floor(U)+D is buggy\n    O = D(0.) + D(vec2(1,0)) + D(vec2(0,1)) + D(1.); // 4 contrib discs per tilted cell\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 308, 308, 837]]}
{"id": "ft2SDh", "name": "Traditional Hex Truchet ", "author": "Pelegefen", "description": "_More options in the defines!_\nWas bored on my commute home, decided to try something which i havent seen yet\nA hexagonly tiled truchet (with the traditional pattern which was a bitch to do, and still isn't perfect. Help with the uv part will be welcome!", "tags": ["nyan", "interactive", "hexagon", "truchet", "cat", "hexagonal", "tilling", "traditional"], "likes": 6, "viewed": 254, "published": 3, "date": "1627918364", "time_retrieved": "2024-07-30T19:08:01.123387", "image_code": "\n\n//Made with love by Peleg Gefen <3\n\n///let's you see the tilling and rotations to each tile marked with color from black 0 - to whitish gray 2\n//#define Debug \n\n\n//Let's you toggle between constant and variable width - on by default\n#define Shrink\n\n#define ZOOM 5.\n\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rot120   = MROT(TAU/3.0);\n\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) \n  * 13758.5453);\n}\n\n\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    //distance to the diagonal line\n    float c = dot(p, normalize(vec2(1., 1.73)));\n\n    // distance to the vertical line\n    c = max(c, p.x);\n    //c += sin(iTime + 4000.) *5. +5.;\n    return c;\n  }\n\nvec4 hexCoords(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n    if(length(a) < length(b))\n      gv = a;\n    else\n      gv = b;\n\n    float y = .5 - hexDist(gv);\n    float x = atan(gv.x, gv.y);\n    vec2 id = uv - gv;\n    return vec4(x, y, id.x, id.y);\n\n}\n\nvec4 hexCoordsOffs(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n    if(length(a) < length(b))\n      gv = a;\n    else\n      gv = b;\n\n    float y = .5 - hexDist((gv - vec2(0., .5)));\n    y = abs(y + .25);\n    //y += .5 - hexDist((gv + vec2(0., .5)));\n    float x = atan(gv.x,gv.y);\n    \n    vec2 id = uv - gv;\n    return vec4(gv, id.x, id.y);\n\n}\n\nvec3 Truchet(vec2 uv, vec2 id, float width,vec2 seed, out float rotations){ //xy are UV, z is mask\n\n    \n    \n    // float checker = mod(id.x , 2.5);\n     \n     //Random Rotation\n     float h = hash(id + seed);\n     h *= 3.;\n     h = floor(h);\n     uv = rot(uv, (h *  (TAU / 3.)) );\n     \n     \n     \n     \n     \n     vec2 offs = vec2(.400,.7);\n     float a = length(uv + offs  );\n     float b = length(uv - offs );\n     vec2 cUv = uv + offs;\n        float aa = atan(cUv.x,cUv.y);\n        cUv = uv + offs;\n         float bb = atan(cUv.x,cUv.y);\n    \n      float c = smoothstep(.70001 + width,.7 + width, a); \n      c -= smoothstep(.70001 - width,.7- width, a); \n     \n     float d = smoothstep(.70001 + width,.7+ width, b); \n     d -= smoothstep(.70001 - width,.7- width, b); \n     \n     float l1 = length(uv.x - uv.y * .585 );//line gradiant\n     float w = width *1.25;\n     float l = smoothstep(w,w - .01,l1 );//line mask\n\n      float mask = (c + d + l );\n      \n       float s = length((uv.x +( width* .585)) - (uv.y + (width* .585)) * .585 );\n\n       //float x = ((aa * c) + (bb * d) + (((uv.x + uv.y)) * l));\n       \n       \n       float subMask = clamp( l-(c)-(d),0.0,1.);\n     //  mask = max(mask, subMask);\n              float x = (c+d+subMask) * length(uv);\n\n       float y = ((((1. - abs((a-(.705 - (w/2.)))/(w) -.5))) * c)// bottom \n      \n       + (((1. - abs((b-(.705- (w /2.)))/(w) -.5)))* d)// top\n        \n       \n       +clamp(min(l,subMask + w) * (1.- (s / (w))),0.0,1.));// stright line\n       \n             float m = min(mask,(subMask + c + d));\n\n      if(mod(id.x,2.) == 0.)x = .5-x /m;\n      \n      \n       rotations = h;\n       vec3 tUv = vec3(x,y,m);\n    tUv = clamp(tUv,0.,1.);\n    return tUv;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat iTime = iTime * .25;\n\tiTime += 800.;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)\n\t/iResolution.y;\n    \n    \n     vec4 col = vec4(0.);\n     vec2 uv1 = uv;\n     uv *= max(ZOOM,1.1) + sin(iTime);\n     //uv += 10.;\n     //uv *= (sin(iTime * .75)*1.5+1.5) + 3.;\n     uv += vec2(iTime *\t 2.1);\n\n     #ifdef Time_And_Zoom\n     iTime += iMouse.x * 10.;\n     uv *= iMouse.y * .007;\n     #else\n     uv -= (iMouse.xy / iResolution.xy) * 15. ;\n     #endif\n\n     uv = rot(uv , (3.1415 * .5));\n\n \n      vec4 uvid = hexCoords(uv);\n     vec4 uvidOf = hexCoordsOffs(uv);\n     vec4 uvidOf1 = hexCoordsOffs(uv - .25);\n\n    vec2 id = uvidOf.zw;\n        vec2 id1 = uvidOf1.zw;\n\n     vec2 huv = uvidOf.xy;\n     vec2 huv1 = uvidOf1.xy;\n\n       #ifdef Shrink\n       float width = clamp(0.25 * length(fragCoord.xy / iResolution.xy * .5),.005,.15 ); \n       #else\n        float width = .07;\n       #endif\n       float r1,r2,r3;\n       vec3 tUv = Truchet(huv,id,width,vec2(.1,.7),r1);\n       \n       vec4 htUv = hexCoordsOffs(fract(tUv.xy * 0.1));\n\n       vec3 tUv1 = Truchet(huv1 ,id1,width * .75,vec2(.4,.2) ,r2);\n       //col = vec4(tUv.z) * .3;\n       \n       \n       float mask = tUv.z;\n       \n       \n       \n       vec3 hUv = Truchet(htUv.xy ,htUv.zw,width,vec2(1.1,4.2) ,r3);\n       \n       vec4 hTruchet = texture(iChannel0,(hUv.yx ));\n\n       vec4 truchet1 = texture(iChannel0,(tUv.xy )+ vec2(-iTime,0.)) * mask * tUv.y;\n       \n       \n       vec4 truchet2 = texture(iChannel1, tUv1.xy+ vec2(-iTime,0.)) * tUv1.z* tUv1.y;\n       \n       \n       col += mix(truchet1  , truchet2 , (tUv.y + (tUv1.y - (tUv.y) ))*.5);\n       col = mix(col - hTruchet,col,sin(iTime)*.5+.5);\n       // col = vec4(0.);\n       // col.x = tUv.z;\n        \n      \n         #ifdef Debug\n \t float grid =( smoothstep(.01,.011,smoothstep(.0071,.007,uvid.y)));\n     col.r += grid * .3;\n        col += vec4(((r1 + 1.5) / 3.) * 1. - mask) * .3;\n     #endif\n     \n     \n\tfragColor = vec4( col);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2SDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[506, 506, 530, 530, 603], [606, 606, 633, 633, 708], [712, 712, 735, 735, 952], [954, 954, 979, 979, 1299], [1301, 1301, 1330, 1330, 1737], [1739, 1739, 1814, 1917, 3460], [3461, 3461, 3518, 3518, 5471]]}
{"id": "slBXRG", "name": "Rectangle A-A", "author": "modesty", "description": "t", "tags": ["aliasing", "antialiasing", "rectangle", "aa", "help"], "likes": 0, "viewed": 213, "published": 3, "date": "1627912419", "time_retrieved": "2024-07-30T19:08:02.197515", "image_code": "#define linearstep(edge0, edge1, x) clamp((x - (edge0)) / (edge1 - (edge0)), 0.0, 1.0)\n\nfloat box(in vec2 _st, in vec2 _size, vec2 aa, vec3 color, inout vec3 pixel){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size, _size+aa, _st);\n        uv *= smoothstep(_size, _size+aa, vec2(1.0)-_st);\n    float res = uv.x*uv.y;\n    if (res > 0.) {\n        pixel = color;   \n    }\n    return res;\n}\n\nfloat stationary(vec2 st, vec3 color, inout vec3 pixel) {\n    float res = 0.;\n    vec2 aa = vec2(0.01);\n    // top\n    res = max(res, box(st - vec2(0.0, 0.225), vec2(0.35, 0.150), aa, color, pixel));\n    // right\n    res = max(res, box(st - vec2(0.17, 0.0), vec2(0.2, 0.60), aa, color, pixel));\n    // bottom\n    res = max(res, box(st - vec2(0.0, -0.225), vec2(0.35, 0.150), aa, color, pixel));\n    // left\n    res = max(res, box(st - vec2(-0.17, 0.0), vec2(0.2, 0.60), aa, color, pixel));\n    if (res >0.) {\n        pixel = color;    \n    }\n\n    return res;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}      \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = 2. * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    // increase the value to receive smaller uv\n    float sizeNumber = 10.;\n    \n    uv *= vec2(sizeNumber);\n    \n    // rotation to see the issue with AA(anti-aliasing)\n    uv = rotate2d(iTime) * uv;\n    \n    uv += vec2(0.5);\n    \n    // some articles (ex: http://jeremt.github.io/pages/anti-aliased_shapes_in_glsl.html \n    // suggests to use fWidth function to get the scale, can't do it with this rectangle which has shadow \n    // and emtpiness inside\n    highp vec2 uvPixel = fwidth(uv);\n    \n    vec3 col = vec3(1.);\n    \n    float on = 0.0;\n    vec3 pixel = vec3(0.0);\n\n    vec2 stShadow = uv*0.7;\n    stShadow += 0.15;\n\n    on = max(on, stationary(stShadow, vec3(0.0), col));\n    on = max(on, stationary(uv, vec3(0.0, 1.0, 0.0), col));\n            \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 165, 165, 403], [405, 405, 462, 462, 965], [967, 967, 995, 995, 1081], [1089, 1089, 1146, 1146, 2045]]}
{"id": "7lSXRG", "name": "neon", "author": "calimops", "description": "neon", "tags": ["neon"], "likes": 3, "viewed": 261, "published": 3, "date": "1627911351", "time_retrieved": "2024-07-30T19:08:03.107083", "image_code": "const float top = 388.0;\nconst float left = 412.0;\nconst float right = 612.0;\nconst float bottom = 188.0;\n\nconst float tanEps = 0.0001;\n\nconst float lightFactor = 5.0;\n\nconst float delta = -1000.0;\n\nfloat scaledAtan (float d, float a, float b) {\n\n    d = abs(d);\n\n        if (d*d - a*b < tanEps) {\n    \n            return 3.141 / (2.0 * d);\n       \n        } else if (d < tanEps) {\n    \n            return -1.0 / a - 1.0 / b;\n    \n        } else {\n\n            return atan((d*(a+b)) / (d*d-a*b)) / d; \n    \n        }\n   \n\n}\n\nfloat squareStrength(vec4 size, vec2 point) {\n\n    float factor = 0.0;\n    \n    factor += scaledAtan(size.w - point.y, point.x - size.y, size.z - point.x);\n    factor += scaledAtan(point.y - size.x, point.x - size.y, size.z - point.x);\n    factor += scaledAtan(point.x - size.y, point.y - size.x, size.w - point.y);\n    factor += scaledAtan(size.z - point.x, point.y - size.x, size.w - point.y);\n    \n    return factor;\n\n}\n\nbool inSquare(vec4 size, vec2 point, float delta) {\n\n    if ((size.w-delta > point.y) && (point.y > size.x+delta) && (size.z-delta > point.x) && (point.x > size.y+delta)) {\n    \n        return true;\n    \n    }\n    \n    return false;\n\n}\n\nfloat circleStrength(float r, vec2 center, vec2 point) {\n\n    float r0 = distance(center, point);\n\n    return 6.283*r / abs(r*r - r0*r0);\n\n}\n\nbool inCircle(float r, vec2 center, vec2 point, float delta) {\n\n    if (distance(point, center) < r-delta) {\n    \n        return true;\n    \n    }\n    \n    return false;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    \n    float factor1 = 0.0;\n    \n    vec4 rect1 = vec4(188.0, 412.0, 612.0, 388.0);\n    \n    vec3 col1 = 0.5 + 0.5*cos(iTime+vec3(0,2,4));\n    \n    if (inSquare(rect1, uv, delta)) {\n    \n        factor1 = squareStrength(rect1, uv);\n    \n    }\n    \n    float factor2 = 0.0;\n    \n    vec3 col2 = 0.5 + 0.5*cos(iTime+vec3(2, 4, 0));\n    \n    if (inCircle(100.0, iMouse.xy, uv, delta)) {\n    \n        factor2 = circleStrength(100.0, iMouse.xy, uv);\n    \n    }\n    \n    float factor3 = 0.0;\n    \n    vec4 rect3 = vec4(88.0+70.0*cos(iTime), 312.0+70.0*sin(iTime), 512.0+70.0*sin(iTime), 288.0+ 70.0 * cos(iTime));\n    \n    vec3 col3 = 0.5 + 0.5*cos(iTime+vec3(4,0,2));\n    \n    if (inSquare(rect3, uv, delta)) {\n    \n        factor3 = squareStrength(rect3, uv);\n    \n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col1*factor1*lightFactor+vec3(0.5)*(1.0-factor1),1.0);\n    fragColor += vec4(col2*factor2*lightFactor+vec3(0.5)*(1.0-factor2),1.0);\n    fragColor += vec4(col3*factor3*lightFactor+vec3(0.5)*(1.0-factor3),1.0);\n    fragColor *= 0.5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 245, 245, 523], [525, 525, 570, 570, 947], [949, 949, 1000, 1000, 1184], [1186, 1186, 1242, 1242, 1326], [1328, 1328, 1390, 1390, 1499], [1501, 1501, 1558, 1608, 2686]]}
{"id": "NtBXRy", "name": "night sky1", "author": "HanShaoqiu", "description": "sky move moon", "tags": ["sky"], "likes": 4, "viewed": 243, "published": 3, "date": "1627899118", "time_retrieved": "2024-07-30T19:08:03.968779", "image_code": "\nfloat weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 TexCoords = uv;\n  vec2 tex_offset = 1.0 / iResolution.xy; // gets size of single texel\n  vec3 result = texture(iChannel0, TexCoords).rgb * weight[0]; // current fragment's contribution\n  \n  for(int i = 1; i < 5; ++i)\n  {\n      result += texture(iChannel0, TexCoords + vec2(tex_offset.x * float(i), 0.0)).rgb * weight[i];\n      result += texture(iChannel0, TexCoords - vec2(tex_offset.x * float(i), 0.0)).rgb * weight[i];\n  }\n \n  for(int i = 1; i < 5; ++i)\n  {\n      result += texture(iChannel0, TexCoords + vec2(0.0, tex_offset.y * float(i))).rgb * weight[i];\n      result += texture(iChannel0, TexCoords - vec2(0.0, tex_offset.y * float(i))).rgb * weight[i];\n  }\n    \n  //result = texture(iChannel0,uv).rgb;\n  fragColor = vec4(result,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat hash( float n )\n{\n  return fract( (1.0 + cos(n)) * 415.92653);\n}\n\nfloat noise2d( in vec2 x )\n{\n  float xhash = hash( x.x * 37.0 );\n  float yhash = hash( x.y * 57.0 );\n  return fract( xhash + yhash );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  // sky  \n  vec3 color = mix(vec3(0.), vec3(0.1, 0.2, 0.4), 1.0-uv.y );\n  \n  // draw stars\n  float fThreshhold = 0.995;\n  float StarVal = noise2d( uv );\n  if ( StarVal >= fThreshhold )\n  {\n    StarVal = pow( (StarVal - fThreshhold) / (1.0 - fThreshhold), 60.0 );\n    color += StarVal;\n  }\n  \n  vec3 skyColor = color;\n  // moon \n  vec3 moonColor = vec3(1.0,0.9,0.5);\n  float moonRadius = 50.0;\n\n  vec2 moonPosition = vec2(moonRadius);\n  //moonPosition.x += iTime*25.0;\n  vec2 circleCenter = vec2(iResolution.x*0.5, moonRadius);\n  //(x-circleCenter)*(x-circleCenter) + y*y = R*R\n  float R = iResolution.x*0.5-moonRadius;\n  float x = moonPosition.x*iTime;\n  float y = float(sqrt(R*R-(x-circleCenter.x)*(x-circleCenter.x)));\n  moonPosition.x = x;\n  moonPosition.y = y;\n  \n  float dis = distance(moonPosition,fragCoord);\n  float offset = 5.0;\n  \n  \n  if (dis < moonRadius) {\n      color = moonColor;\n  }  \n  \n  // phase \n  vec2 circlePos = moonPosition - vec2(moonRadius-20.0,-20.0);\n  float dis1 = distance(circlePos,fragCoord);\n  if (dis1 < moonRadius) {\n      color = skyColor;\n  }\n \n  \n  fragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 138, 138, 931]]}
{"id": "flSSRz", "name": "A sponza scene", "author": "moranzcw", "description": "sponza.", "tags": ["raymarching", "sdf", "ao"], "likes": 21, "viewed": 595, "published": 3, "date": "1627893326", "time_retrieved": "2024-07-30T19:08:04.909264", "image_code": "// A monster scene - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653;\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float MIN_T = 0.0;\nconst float MAX_T = 50.0;\n\nconst float K = 24.0; // for distance dunction soft shadows\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// hash by Hugo Elias\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n// ambient\nfloat ambient = 0.4;\n\n// dot light\nvec3 DOT_LIGHT_POS = vec3(0.0, 6.0, 0.0); // position\nvec3 DOT_LIGHT_INT = 2.0 * vec3(1.0, 1.0, 0.9); // intensity\n\n// direction light\nvec3 DIR_LIGHT_DIR = normalize(vec3(0.15, 1.8, -0.45)); // direction\nvec3 DIR_LIGHT_IRR = 3.5 * vec3(1.0, 1.0, 0.9); // irradiance\n\n\n/* -------------------------------------\n\n  SDF\n\n------------------------------------- */\n\n// SDF boolean\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//SDF functions by iq.\n//see https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat quadSDF( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinderSDF_X( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.zy),p.x)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinderSDF_Y( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinderSDF_Z( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.yx),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// scene\nfloat columns1(vec3 p)\n{\n    p = vec3(mod(p.x, 3.0)-1.5, p.y-1.0, mod(p.z, 3.0)-1.5);\n    float d = cylinderSDF_Y(p, 1.0, 0.25);\n    p += vec3(0.0, -1.0, 0.0);\n    d = unionSDF(d, boxSDF(p, vec3(0.3, 0.05, 0.3)));\n    return d;\n}\n\nfloat columns2(vec3 p)\n{\n    p = vec3(mod(p.x, 3.0)-1.5, p.y-4.0, mod(p.z, 3.0)-1.5);\n    float d = boxSDF(p, vec3(0.22, 0.15, 0.22));\n    p += vec3(0.0, -0.75, 0.0);\n    d = unionSDF(d, boxSDF(p, vec3(0.17, 0.75, 0.17)));\n    p += vec3(0.0, -0.75, 0.0);\n    d = unionSDF(d, boxSDF(p, vec3(0.3, 0.05, 0.3)));\n    return d;\n}\n\nfloat columns3(vec3 p)\n{\n    vec3 tp = vec3(mod(p.x+1.5, 3.0)-1.5, p.y-4.0, mod(p.z, 3.0)-1.5);\n    float d = boxSDF(tp, vec3(0.22, 0.15, 0.22));\n    tp += vec3(0.0, -0.75, 0.0);\n    d = unionSDF(d, cylinderSDF_Y(tp, 0.75, 0.17));\n    tp += vec3(0.0, -0.75, 0.0);\n    d = unionSDF(d, boxSDF(tp, vec3(0.3, 0.05, 0.3)));\n    \n    d = differenceSDF(d, boxSDF(p + vec3(-9.0, -5.0, 0.0), vec3(2.0, 4.0, 5.0)));\n    d = differenceSDF(d, boxSDF(p + vec3(9.0, -5.0, 0.0), vec3(2.0, 4.0, 5.0)));\n    return d;\n}\n\nfloat roof1(vec3 p)\n{\n    //\n    float box1 = boxSDF(p + vec3(0.0, -3.0, 0.0), vec3(100.0, 1.0, 20.0));\n    float box2 = boxSDF(p + vec3(0.0, -3.0, 0.0), vec3(7.25, 1.5, 1.25));\n    float roof = differenceSDF(box1, box2);\n    \n    //\n    float box3 = boxSDF(p + vec3(0.0, -4.0, -3.0), vec3(10.25, 0.6, 1.25));\n    float box4 = boxSDF(p + vec3(0.0, -4.0, 3.0), vec3(10.25, 0.6, 1.25));\n    roof = differenceSDF(roof, unionSDF(box3, box4));\n    \n    //\n    float box5 = boxSDF(p + vec3(9.0, -4.0, 0.0), vec3(1.25, 0.6, 2.0));\n    float box6 = boxSDF(p + vec3(-9.0, -4.0, 0.0), vec3(1.25, 0.6, 2.0));\n    roof = differenceSDF(roof, unionSDF(box5, box6));\n    \n    //\n    p = vec3(mod(p.x-1.5, 3.0) - 1.5, p.y, p.z);\n    float cylinderZ = cylinderSDF_Z(p + vec3(0.0, -2.0, 0.0), 100.0, 1.25);\n    float cylinderX = cylinderSDF_X(p + vec3(0.0, -2.0, 0.0), 100.0, 1.25);\n    return differenceSDF(roof, unionSDF(cylinderX, cylinderZ));\n}\n\nfloat roof2(vec3 p)\n{\n    //\n    float box1 = boxSDF(p + vec3(0.0, -7.5, 0.0), vec3(100.0, 2.0, 20.0));\n    float box2 = boxSDF(p + vec3(0.0, -7.5, 0.0), vec3(7.25, 2.5, 1.25));\n    float roof = differenceSDF(box1, box2);\n    \n    //\n    vec3 tp = vec3(mod(p.x-1.5, 3.0) - 1.5, p.y-5.5, mod(p.z-1.5, 3.0) - 1.5);\n    float cylinderZ = cylinderSDF_Z(tp, 100.0, 1.4);\n    float cylinderX = cylinderSDF_X(tp, 100.0, 1.25);\n    roof =  differenceSDF(roof, unionSDF(cylinderX, cylinderZ));\n    \n    //\n    float box3 = boxSDF(p + vec3(0.0, -7.5, 1.45), vec3(7.5, 2.0, 0.2));\n    float box4 = boxSDF(p + vec3(0.0, -7.5, -1.45), vec3(7.5, 2.0, 0.2));\n    float temp = unionSDF(box3, box4);\n    \n    //\n    tp = vec3(mod(p.x-1.5, 1.5)-1.5, p.y-5.5, p.z);\n    float cylinderZ1 = cylinderSDF_Z(tp + vec3(0.7, 0.0, 0.0), 100.0, 0.625);\n    temp =  differenceSDF(temp, cylinderZ1);\n\n    \n    return unionSDF(roof, temp);\n}\n\nfloat wall(vec3 p)\n{\n    float box1 = boxSDF(p + vec3(0.0, 0.0, 4.35), vec3(100.0, 9.5, 0.1));\n    float box2 = boxSDF(p + vec3(0.0, 0.0, -4.35), vec3(100.0, 9.5, 0.1));\n    float box3 = boxSDF(p + vec3(10.35, 0.0, 0.0), vec3(0.1, 9.5, 100.0));\n    float box4 = boxSDF(p + vec3(-10.35, 0.0, 0.0), vec3(0.1, 9.5, 100.0));\n    return unionSDF(unionSDF(box1, box2), unionSDF(box3, box4));\n}\n\nfloat ground(vec3 p)\n{\n    return quadSDF(p,vec3(100.0,0.0,100.0), vec3(100.0,0.0,-100.0),\n                     vec3(-100.0,0.0,-100.0), vec3(-100.0,0.0,100.0));\n}\n\n// scene\nfloat sceneSDF(vec3 p)\n{\n    float scene = MAX_T;\n    scene = unionSDF(scene, ground(p));\n    scene = unionSDF(scene, wall(p));\n    scene = unionSDF(scene, columns1(p));\n    scene = unionSDF(scene, roof1(p));\n    scene = unionSDF(scene, columns2(p));\n    scene = unionSDF(scene, columns3(p));\n    scene = unionSDF(scene, roof2(p));\n    \n    return scene;\n}\n\n/* -------------------------------------\n\n  Ray Marching\n\n------------------------------------- */\nfloat rayMarching(vec3 ro, vec3 rd, float start, float end) \n{\n    float t = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        float dist = sceneSDF(ro + t * rd);\n        if (dist < EPSILON * t) \n        {\n\t\t\treturn t;\n        }\n        t += dist;\n        if (t > end)\n        {\n            return t;\n        }\n    }\n    return t;\n}\n\n/* -------------------------------------\n\n  Visibility of the shading point to light source\n\n------------------------------------- */\nfloat visibility(vec3 ro, vec3 rd, float start, float end)\n{\n    float t = start;\n    vec3 p;\n    float dist;\n    float tempVisibility;\n    float visibility = 1.0;\n        \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        p = ro + t * rd;\n        dist = sceneSDF(p);\n        \n        tempVisibility = K * dist / t;\n        visibility = min(tempVisibility, visibility);\n        \n        if (dist < EPSILON) \n        {\n\t\t\treturn 0.0;\n        }\n        t += dist * (0.7 + frand() * 0.3); // dither\n        if (t >= end) \n        {\n            break;\n        }\n    }\n    return visibility;\n}\n\n\n/* -------------------------------------\n\n  Shading\n\n------------------------------------- */\n// normal\nvec3 surfaceNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// ambient occlusion\nfloat fakeAO(vec3 p, vec3 n)\n{\n    float ao = 0.0;\n    float weight = 10.0;\n    for(int i=0; i<8; i++)\n    {\n        float spacing = 0.01 + 0.02 * float(i*i);\n        vec3 sp = p + n * spacing;\n        float d = sceneSDF(sp);\n        ao += weight * (spacing - d);\n        weight *= 0.5;\n    }\n    return 1.0 - clamp(ao, 0.0, 1.0);\n}\n\nvec3 lambert(vec3 diffuseColor, vec3 p, vec3 n, vec3 l, vec3 irradiance)\n{\n    float dotLN = clamp(dot(l, n), 0.0, 1.0);\n    return irradiance * dotLN * diffuseColor;\n}\n\n// shade\nvec3 shade(vec3 p)\n{\n    vec3 n = surfaceNormal(p);\n    vec3 tn = abs(n); \n    vec3 tex = texture(iChannel0, p.zy).rgb * tn.x \n                + texture(iChannel0, p.xz).rgb * tn.y\n                + texture(iChannel0, p.xy).rgb * tn.z;\n\n    // ambient occlusion\n    vec3 color = (0.2 + 0.8 * fakeAO(p, n)) * ambient * tex;\n    \n    // dot light\n    vec3 tempDotLightDir = DOT_LIGHT_POS - p;\n    vec3 direction = normalize(tempDotLightDir);\n    float dist = length(tempDotLightDir);\n    vec3 irradiance = DOT_LIGHT_INT / dist;  // Linear attenuation may be better\n    \n    float v = visibility(p, direction, 10.0*EPSILON, dist);\n    color += v * lambert(tex, p, n, direction, irradiance);\n    \n    // direction light\n    v = visibility(p, DIR_LIGHT_DIR, 10.0*EPSILON, MAX_T);\n    color += v * lambert(tex, p, n, DIR_LIGHT_DIR, DIR_LIGHT_IRR);\n    \n    // fog\n    //color = mix(color, 0.5 * vec3(0.8, 0.77, 0.75), 1.0 - exp2(-0.25 * dist));\n    return color;\n}\n\n\n/* -------------------------------------\n\n  Camera\n\n------------------------------------- */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 cameraOrigin, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - cameraOrigin);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\n    DOT_LIGHT_POS = vec3(4.0 + 2.0*sin(0.5*iTime), 6.0, 0.0);\n    \n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // camera ray\n\tvec3 cameraRayDirInView = rayDirection(110.0, iResolution.xy, fragCoord);\n    \n    vec3 cameraPos = vec3(9.3, 2.7 - 2.2 * sin(0.3 * iTime), - 2.5 * sin(0.2 * iTime));\n    mat3 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 5.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 cameraRayDir = viewToWorld * cameraRayDirInView;\n    \n    // distance\n    float dist = rayMarching(cameraPos, cameraRayDir, MIN_T, MAX_T);\n    \n    // didn't hit\n    if (dist > MAX_T) \n    {\n        fragColor = vec4(.58, 0.77, 0.95, 0.0);\n\t\treturn;\n    }\n    \n    // hit point\n    vec3 p = cameraPos + dist * cameraRayDir;\n    \n    // shading\n    vec3 color = shade(p);\n    \n    fragColor = vec4(pow(color,vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSSRz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[423, 423, 444, 444, 456], [457, 457, 476, 476, 531], [532, 532, 551, 551, 583], [585, 607, 626, 626, 681], [1088, 1103, 1149, 1149, 1181], [1183, 1183, 1225, 1225, 1257], [1259, 1259, 1306, 1306, 1339], [1341, 1416, 1441, 1441, 1460], [1461, 1461, 1486, 1486, 1505], [1507, 1507, 1564, 1564, 2192], [2194, 2194, 2226, 2226, 2317], [2319, 2319, 2368, 2368, 2479], [2481, 2481, 2530, 2530, 2641], [2643, 2643, 2692, 2692, 2803], [2806, 2815, 2839, 2839, 3044], [3046, 3046, 3070, 3070, 3370], [3372, 3372, 3396, 3396, 3874], [3876, 3876, 3897, 3904, 4806], [4808, 4808, 4829, 4836, 5718], [5720, 5720, 5740, 5740, 6107], [6109, 6109, 6131, 6131, 6272], [6274, 6283, 6307, 6307, 6639], [6641, 6740, 6802, 6802, 7093], [7095, 7229, 7289, 7289, 7831], [7834, 7938, 7967, 7967, 8277], [8279, 8300, 8330, 8330, 8632], [8634, 8634, 8708, 8708, 8802], [8804, 8813, 8833, 8833, 9771], [9774, 9867, 9932, 9932, 10064], [10066, 10066, 10124, 10124, 10264], [10267, 10267, 10324, 10331, 11228]]}
{"id": "flSXzG", "name": "sky render", "author": "HanShaoqiu", "description": "simple sky", "tags": ["sky"], "likes": 0, "viewed": 235, "published": 3, "date": "1627890511", "time_retrieved": "2024-07-30T19:08:05.823819", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float speed = 0.3;\n    // sky\n    vec3 upSkyColor = vec3(0.25,0.5,1.0);\n    // floor \n    vec3 downSkyColor = vec3(1.0);\n    // sky Color\n    vec3 col = mix(downSkyColor,upSkyColor,uv.y);\n    vec2 pos = iResolution.xy*0.5 + vec2(0.0,100.0); \n    vec2 sun = pos;//sun position\n    vec3 sunColor = vec3(1.5,1.0,0.0);\n    float radius = 50.0;\n    float dis = distance(sun,fragCoord);\n    \n    float stepOffset = 90.0;\n    if ( dis < radius) {\n        col = sunColor;\n    } else if (dis > radius && dis < radius+stepOffset) {\n        float s = smoothstep(radius,radius+stepOffset,dis);\n        col = mix(sunColor,col,s);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 837]]}
{"id": "sl2XDm", "name": "Red Carpet", "author": "Plento", "description": "More playing with fractally stuff.", "tags": ["2d", "fractal"], "likes": 9, "viewed": 302, "published": 3, "date": "1627886460", "time_retrieved": "2024-07-30T19:08:07.083452", "image_code": "// Cole Peterson\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec4 plane(vec3 ro, vec3 rd, vec3 n){\n    float dem = dot(rd, n);\n    \n    if(dem > .01){\n     \tfloat num = dot(-ro, n);   \n        float t = num / dem;\n        return vec4(ro + rd*t, 1.);\n    }\n    else\n        return vec4(0);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy - .5*R) / R.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0., 1.6 , 0.);\n    ro.z += iTime*.75;\n    \n    vec3 rd = normalize(vec3(uv, 1. - dot(uv, uv) * -.65));\n    rd.zy *= rot(-.58);\n   \n    vec4 pln = plane(ro, rd, vec3(0., -1., 0.));\n    if(pln.w>0.){\n        float pd = length(pln.xyz-(ro));\n     \tcol += texture(iChannel0, pln.xz*vec2(0.08, 0.12)).xyz; \n        col *= exp(-pd*pd*pd*.0006);\n    }\n   \n    float val = 1.-exp(-pow(col.r * 1.8, 5.));\n    col *= (ss(3., -.7, abs(pln.x +cos(pln.z*.4)*.3) - val*1.3));\n    col *= ss(.8, .79, abs(uv.x));\n    //col *= ss(.441, .44, abs(uv.y));\n    f = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Cole Peterson\n\n#define R iResolution.xy\n\n#define ss(a, b, t) smoothstep(a, b, t)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 m = (iMouse.xy - .5*R) / R.y;\n    vec2 uv = .63*vec2(u - .5*R) / R.y;\n    \n    float r = .3, q = 0.0;\n    \n    if(iMouse.z > 0.)\n        r -= (m.y*.044);\n    \n    for(float i = 0.; i < 40.;i++){\n        uv = abs(uv);\n        uv *= 1.133;\n        uv *= rot(r + .647);\n        uv.x -= .2;\n        uv = fract(uv) - 0.5;\n        q += dot(uv, uv);\n    }\n    \n    vec3 col = .4+.2*cos(vec3(1., 2., 3.)*q*5. + vec3(1., 1.5, 3.));\n    col = pow(col*1.8, vec3(3.6));\n    col = 1.-exp(-col);\n    f = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2XDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 174, 174, 366], [368, 368, 408, 408, 1103]]}
{"id": "7l2XDm", "name": "Intersection Circle - Circle", "author": "Yusef28", "description": "Lot's of collecting constants, putting them in variables, and not trying to save the rainforest.\nYou can turn the samples up to 128 at the top if you have a very fast computer and want to see a higher quality image.", "tags": ["2d", "gi", "global", "illumination", "globalillumination", "pathtracing", "2dpathtracing", "illuminati"], "likes": 16, "viewed": 423, "published": 3, "date": "1627884030", "time_retrieved": "2024-07-30T19:08:08.113697", "image_code": "\n/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 28-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Circle-Circle Intersection                       //\n// Sources: https://www.analyzemath.com/CircleEq           //\n//                      /circle_intersection.html          //\n//                                                         //\n// The original: https://www.shadertoy.com/view/lldcDf     //\n//                                                         //\n// Listening to: satellites - Familiar Shorelines [Album]  //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n//before I get into it, here is the main inspiration for this\n//effect https://www.shadertoy.com/view/lldcDf\n//some of the code has been \"borrowed\" like the add function \n//used to add objects to the distance field without returning \n//anything. It's pretty sleak.\n\n//If you have every tryed getting into path tracing but\n//didn't enjoy the learning curve, 2d pathtracing is a grate\n//way to get something on the screen fast and gain some \n//understanding.\n//\n//\n//I had a few false starts with the intersection code in this one. \n//Then I didn't want to upload too many at once so I spaced things\n//out. In doing so I stumbled on a cooler idea and decided to \n//apply it to this shader before uploading it.\n\n//So other than a basic circle x circle intersection I \n//am also path tracing everything in 2 dimentions to calculate\n//global illumination. So what that means is for every pixel \n//I take samples out in many \"random\" direction.Where here\n//it is actually just rays shot out offset by uniform angles + \n//the angle is offset by a random number. So from every pixel we\n//ge tthe 360 degree view of where the other objects are.\n\n//To do that we use raymarching of a 2d map. \n\n//Not sure how coherent I am right now since it's pretty late.\n//\n\n//somthing new to try\n#define numSamples 68.\n\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      RayMarching Functions          //\n      //                                   //\n      /////////////////////////////////////\n      \n      \nfloat rnd(vec2 uv){\n    return fract(sin(dot(uv,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nvoid add(float dist, vec3 color, inout float endDist, inout vec3 endColor){\n    if(dist < endDist){\n        endDist = dist;\n        endColor = color;\n    }\n}\n\nvoid map(vec2 uv, inout float d, inout vec3 color){\n\n      ////////////////////////////////////////////\n      //                                       //\n////////     INTERSECTION CALCULATIONS       //\n      //                                   //\n      /////////////////////////////////////\n    \n    \n    //centers for two circles\n    vec2 center1 = vec2(-4.*cos(iTime*1.),-3.*sin(iTime*2.));\n    vec2 center2 = vec2(.8*sin(iTime),.5*cos(iTime));\n    \n    //radius for 2 circles\n    float c1 = 2.; //radius 1\n    float c2 = 3.; //radius 2\n    \n    //x and y for each circle separate for algebra\n    float h1 = center1.x;\n    float k1 = center1.y;\n    float h2 = center2.x;\n    float k2 = center2.y;\n    \n    //and here we go...\n    \n    //So in order to solve for our firss term we need\n    //to do a similar thing to what we do with line segments.\n    //we set the standard form circle equations to equal\n    //each other and then shift everything to one side leaving\n    //0 on the other. Then we do the subtraction and notice\n    //only the second order variable terms x^2 and y^2 will cancel\n    //The result is a line equation (which maybe have some significance).\n    \n    //I go a step further by laying all the constant like-terms\n    //from this step into variables since they are constants. \n    //That makes future steps way more manageble.\n    \n    //so after setting the equality, and subtracting, I will..\n    //Well I set the x term but I can't show that step because\n    //it still has the unknown of \"y\" so I'll just set up the constants\n    //so after isolating x we have\n    \n    float k3 = k1 - k2;\n    float h3 = h1 - h2;\n    float c3 = k1*k1 - (k2*k2) + h1*h1 - (h2*h2) - (c1*c1) + (c2*c2);\n    // x = y*w - u where....\n    float w = -(k3/h3);\n    float u = -c3/(2.*h3);\n    \n    //and I've already worked out a,b and c so I'll go ahead and...\n    float a = w*w + 1.;\n    float b = 2.*(w*h1 + w*u + k1);\n    float c = (u*u) + 2.*u*h1 + k1*k1 - (c1*c1) + h1*h1;\n    \n    /*float w = (-2.*(k1-k2))/(2.*(h1-h2));\n    float u = k1*k1 - (k2*k2) + h1*h1 - (h2*h2) - (c1*c1) + (c2*c2);\n    \n    //and I've already worked out a,b and c so I'll go ahead and...\n    float a = w*w + 1.;\n    float b = w*w*h1 - w*u - k1;\n    float c = -(u*u) - 2.*u*h1 + k1*k1 - (c1*c1) + h1*h1;\n    */\n    \n    //the discriminant\n    float disc = b*b - 4.*a*c;\n    \n    //the two roots (or one or none de0pending)\n    float y1 = (-b + sqrt(disc))/(2.*a); //<-- this right here!!!!\n    float y2 = (-b - sqrt(disc))/(2.*a); //<-- If you forget bracket on (2.*a)...\n                                         //you're gonna have a bad experience.\n                                         \n    \n    //Note:\n    //You can factor out the \"2.\" from the \"b\" initialization\n    //and then the \"4.\" from the discriminant along with the \"2.\"\n    //from each of y1 and y2. Deleting all these is akin to\n    //things canceling and you end up with the same result\n    \n    //so what we did was kind of snuck past getting x, \n    //we got out of that and went for y while only having x\n    //in terms of y. Then we got out qaudtradic variables and solved the \n    //quadratic for 0-2 roots which will bw our y1 and y2\n    //now we'll swing back around and get the x's using our x = yw - u\n    //formula.\n   \n    float x1 = y1*w + u;\n    float x2 = y2*w + u;\n    //ja just like that and now...\n    //calculate the intersection points\n    \n    //I had to calculate everything again and somehow still ended up\n    //missing a sign somewhere because the points have the wrong sign.\n    //so I flip the sign of the points and there it is.\n    //I know what I did! I calculated everything with:\n    // (x + h)^2 + (y + k)^2 = c^2\n    // it should have been -h and -k\n    // so flipping the sign of the coordinates at the end is the same\n    // as flipping the signs of the centers\n    vec2 intersectionPoint1 = -vec2(x1,y1);\n    vec2 intersectionPoint2 = -vec2(x2,y2);\n        \n        \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n    \n    //This time everything is happening in the distance\n    //estimation map so I use all the algebra above\n    //in the basic process of finding the closest object\n    \n    d = 1e9;\n    color = vec3(0.0);\n    float f;\n    \n    float radicalLine = -uv.x +(uv.y*w - u);//adjusted because of \n    //the sign error above\n    \n    \n    \n    //circle at center1\n    \n    f = abs(length(uv-center1)-c1);\n    add(f,vec3(0.8,0.3,0.7)/4., d, color);\n    \n    //circle at center2\n    //f = 1.-smoothstep(0.02,0.04,abs(length(uv-center2)-c2));\n    \n    if(length(uv-center1) > c1){\n    f = abs(length(uv-center2)-c2);\n    add(f,vec3(0.2,0.5,0.9)/3., d, color);\n    }\n    \n    if(disc >= 0.){\n    \n    //intersection pointss\n    f = abs(length(uv-intersectionPoint1)-0.12);\n    add(f,vec3(0.6,0.7,1.)*2., d, color);\n    f = abs(length(uv-intersectionPoint2)-0.12);\n    add(f,vec3(0.6,0.7,1.)*2., d, color);\n\n    \n    }\n    \n    f = abs(length(uv-vec2(7.,4.*sin(iTime)))-0.5);\n    add(f,vec3(1.,1.,0.7), d, color);\n    f = abs(length(uv+vec2(7.,4.*cos(iTime)))-0.5);\n    add(f,vec3(1.4,0.9,.5), d, color);\n\n}\n\nfloat trace(vec2 ro, vec2 rd, inout vec3 color, vec3 grid){\n    float t = 0.;\n    \n    for(float i = 0.;i<30.;i++){\n        \n        float d;\n        map(ro + rd*t, d, color);\n        //if(d<0.0001)return;\n        \n        //if(d>10.)break;\n        if(d <0.0001 || t > 10.) break;\n        \n            t += d;\n    }\n    \n    if(t > 10.)color = grid;//if no hit at this point, draw background grid\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIGN         //\n      //                                   //\n      /////////////////////////////////////\n      \n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.);\n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*43343.);\n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.3),lines.x);\n    col = mix(col,vec3(0.3),lines.y);\n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    //col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n    vec3 grid = col/2.;\n      //marching\n      \n    uv = (fragCoord-iResolution.xy*0.5)/iResolution.y*10.;\n    vec2 ro = uv;\n    vec2 rd;\n    vec3 tmpColor;\n    float t;\n    vec3 marchColor = vec3(0.);\n    \n    // Time varying pixel color\n    for(float i = 0.; i < numSamples; i++){\n        float angle = ( i + rnd( uv + float(i)) ) / numSamples*3.1415*2. ;\n        \n        rd = vec2(cos(angle),sin(angle));\n        //I give the grid design to the trace function\n        t = trace(ro, rd, tmpColor,grid);\n        marchColor += tmpColor;\n    }\n    \n\n    \n    \n    marchColor/=(numSamples);\n    col = marchColor*2.;//mix(col,marchColor,mask);\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    col = pow(col,vec3(0.75));\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2XDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2426, 2426, 2445, 2445, 2532], [2535, 2535, 2610, 2610, 2692], [2694, 2694, 2745, 3025, 7997], [7999, 7999, 8058, 8058, 8411], [8413, 8413, 8470, 8522, 11146]]}
{"id": "7ljXDw", "name": "Cubic Curve - Moment of Inertia", "author": "oneshade", "description": "More 2D physics stuff.", "tags": ["2d", "curve", "cubic", "physics", "inertia", "momentofinertia"], "likes": 9, "viewed": 146, "published": 3, "date": "1627865214", "time_retrieved": "2024-07-30T19:08:09.081110", "image_code": "// See https://www.desmos.com/calculator/l2bhsgghyw\n\n// SDFs\n// https://www.shadertoy.com/view/ft2GRD\nvec3 solveQuadratic(in float a, in float b, in float c) {\n    if (abs(a) < 1e-6) return vec3(-c / b, 0, 1);\n    float h = b * b - 4.0 * a * c;\n    if (h < 0.0) return vec3(0.0);\n    return vec3((vec2(-1.0, 1.0) * sqrt(h) - b) * 0.5 / a, 2.0);\n}\n\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float u = b / (3.0 * a);\n    vec3 roots;\n\n    float p = (c - b * u) / a;\n    float q = (d - (c - 2.0 * b * b / (9.0 * a)) * u) / a;\n\n    if (abs(p) < 1e-9) return vec4(cbrt(-q) - u, 0.0, 0.0, 1);\n    float h = 0.25 * q * q + p * p * p / 27.0;\n    if (h > 0.0) {\n        h = sqrt(h);\n        float o = -0.5 * q;\n        roots.x = cbrt(o - h) + cbrt(o + h) - u;\n        return vec4(roots, 1);\n    }\n\n    float m = sqrt(-p / 3.0);\n    roots.x = -2.0 * m * sin(asin(1.5 * q / (p * m)) / 3.0);\n\n    h = sqrt(-3.0 * roots.x * roots.x - 4.0 * p);\n    roots.yz = 0.5 * vec2(h - roots.x, -h - roots.x);\n    roots -= u;\n\n    return vec4(roots, 3);\n}\n\nfloat evalDist(in vec2 p, in float t, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    t = clamp(t, 0.0, 1.0);\n    vec2 toCurve = p - (((a * t + b) * t + c) * t + d);\n    return max(abs(toCurve.x), abs(toCurve.y));\n}\n\nfloat sdCubicCurve(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    vec2 dp = d - p;\n\n    vec4 minMax1 = solveCubic(a.x - a.y, b.x - b.y, c.x - c.y, dp.x - dp.y);\n    vec4 minMax2 = solveCubic(a.x + a.y, b.x + b.y, c.x + c.y, dp.x + dp.y);\n\n    vec3 minMax3 = solveQuadratic(3.0 * a.x, 2.0 * b.x, c.x);\n    vec3 minMax4 = solveQuadratic(3.0 * a.y, 2.0 * b.y, c.y);\n\n    float dist = evalDist(p, minMax1[0], a, b, c, d);\n    for (int n=1; n < int(minMax1.w); n++) dist = min(dist, evalDist(p, minMax1[n], a, b, c, d));\n    for (int n=0; n < int(minMax2.w); n++) dist = min(dist, evalDist(p, minMax2[n], a, b, c, d));\n    for (int n=0; n < int(minMax3.z); n++) dist = min(dist, evalDist(p, minMax3[n], a, b, c, d));\n    for (int n=0; n < int(minMax4.z); n++) dist = min(dist, evalDist(p, minMax4[n], a, b, c, d));\n\n    return dist;\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n    float co = cos(ang), si = sin(ang);\n    mat2 rot = mat2(co, si, -si, co);\n\n    float curve = sdCubicCurve(rot * uv, T3, T2, T1, T0);\n    drawSDF(curve - 0.01, vec3(1.0, 0.0, 0.0));\n    drawSDF(length(uv) - 0.05, vec3(1.0, 0.8, 0.0));\n\n    float aspect = iResolution.x / iResolution.y;\n    color = digitIn(color, vec3(1.0), uv * 0.25 + vec2(0.45 * aspect, 0.45), 100.0, cubicCurveInertia(T3, T2, T1, T0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define PI 3.14159265359\n\n// Curve settings\n#define T3 (vec2(2.759 + (iTime > 13.0 ? 0.1 * sin((iTime - 13.0) * 6.0) : 0.0), 0.379) * 3.0)\n#define T2 (vec2(-4.872, -2.151) * 3.0)\n#define T1 (vec2(2.487, 1.755) * 3.0)\n#define T0 vec2(0.0, 0.0)\n#define MASS 0.1\n\n// Simulation settings\n#define FRICTION 0.98\n#define GRAVITY 0.2\n\n// cross3D(vec3(a.x, a.y, 0), vec3(b.x, b.y, 0))\n// Since the x and y components of the result are always zero\n// The z component is the only one of interest\nfloat cross2D(in vec2 a, in vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Moment of inertia of a cubic curve with coefficients t3, t2, t1, and t0\nfloat cubicCurveInertia(in vec2 t3, in vec2 t2, in vec2 t1, in vec2 t0) {\n    return dot(t3, t3) / 7.0 + (dot(t2, t2) + 2.0 * dot(t1, t3)) / 5.0 +\n          (dot(t1, t1) + 2.0 * dot(t0, t2) + dot(t2, t3)) / 3.0 +\n          (dot(t1, t2) + dot(t0, t3)) / 2.0 + dot(t0, t1) + dot(t0, t0);\n}\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM  2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "buffer_a_code": "void mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(-PI / 4.0, 0.0, 0.0, 0.0);\n    addr -= 0.5;\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame > 0 && iAddr == ivec2(0)) {\n        data = texelFetch(iChannel0, ivec2(0), 0);\n\n        float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n        float co = cos(ang), si = sin(ang);\n        mat2 rot = mat2(co, si, -si, co);\n\n        vec2 centerOfMass = (T3 / 4.0 + T2 / 3.0 + T1 / 2.0 + T0) * rot;\n\n        vec2 force = vec2(0.0, -MASS * GRAVITY);\n        float torque = cross2D(-centerOfMass, force);\n\n        data.y += torque / cubicCurveInertia(T3, T2, T1, T0);\n        data.y *= FRICTION;\n        data.x += data.y;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljXDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 102, 159, 159, 346], [348, 348, 372, 372, 415], [416, 416, 481, 481, 1125], [1127, 1127, 1210, 1210, 1344], [1346, 1346, 1421, 1421, 2189], [2271, 2271, 2326, 2326, 2965]]}
{"id": "sl2XWw", "name": "Box - Moment of Inertia", "author": "oneshade", "description": "More 2D physics stuff.", "tags": ["2d", "box", "physics", "inertia", "momentofinertia"], "likes": 6, "viewed": 156, "published": 3, "date": "1627858626", "time_retrieved": "2024-07-30T19:08:10.162220", "image_code": "// See https://www.desmos.com/calculator/xl31e62ieb\n\n// SDFs\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n    float co = cos(ang), si = sin(ang);\n    mat2 rot = mat2(co, si, -si, co);\n\n    float box = sdBox(rot * uv + AXIS, AB * 0.5);\n    drawSDF(box, vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(box), vec3(1.0, 0.8, 0.0));\n    drawSDF(length(uv) - 0.05, vec3(1.0, 0.8, 0.0));\n\n    float aspect = iResolution.x / iResolution.y;\n    color = digitIn(color, vec3(1.0), uv * 0.25 + vec2(0.45 * aspect, 0.45), 100.0, boxInertia(AB, AXIS));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define PI 3.14159265359\n\n// Box settings\n#define AB (iTime > 12.0 ? vec2(2.5, 1.25) + 0.5 * sin(iTime - 12.0) : vec2(2.5, 1.25))\n#define AXIS vec2(-0.75, 0.25)\n#define DENSITY 0.1\n\n// Simulation settings\n#define FRICTION 0.98\n#define GRAVITY 0.2\n\n// cross3D(vec3(a.x, a.y, 0), vec3(b.x, b.y, 0))\n// Since the x and y components of the result are always zero\n// The z component is the only one of interest\nfloat cross2D(in vec2 a, in vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Mass of an box with uniform density\nfloat boxMass(in vec2 ab, in float density) {\n    return ab.x * ab.y * density;\n}\n\n// Moment of inertia of a box with dimensions ab about axis p\nfloat boxInertia(in vec2 ab, in vec2 p) {\n    return (dot(ab, ab) / 12.0 + dot(p, p)) * ab.x * ab.y;\n}\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM  2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "buffer_a_code": "void mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(-PI / 4.0, 0.0, 0.0, 0.0);\n    addr -= 0.5;\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame > 0 && iAddr == ivec2(0)) {\n        data = texelFetch(iChannel0, ivec2(0), 0);\n\n        float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n        float co = cos(ang), si = sin(ang);\n        mat2 rot = mat2(co, si, -si, co);\n\n        vec2 centerOfMass = -AXIS * rot;\n\n        vec2 force = vec2(0.0, -boxMass(AB, DENSITY) * GRAVITY);\n        float torque = cross2D(-centerOfMass, force);\n\n        data.y += torque / boxInertia(AB, AXIS);\n        data.y *= FRICTION;\n        data.x += data.y;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2XWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 61, 96, 96, 176], [258, 258, 313, 313, 966]]}
{"id": "7t2XWw", "name": "Ellipse - Moment of Inertia", "author": "oneshade", "description": "More 2D physics stuff.", "tags": ["2d", "physics", "ellipse", "inertia", "momentofinertia"], "likes": 9, "viewed": 160, "published": 3, "date": "1627856368", "time_retrieved": "2024-07-30T19:08:11.164540", "image_code": "// See https://www.desmos.com/calculator/7rpupvhbh9\n\n// SDFs\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    if (ab.y > ab.x) p = p.yx, ab = ab.yx;\n\n    vec2 pab = p * ab;\n    float s1 = ab.x * ab.x - ab.y * ab.y;\n    float s2 = length(pab);\n    float offs = atan(pab.x / pab.y);\n\n    float t = 1.1;\n    for (int n=0; n < 10; n++) {\n        float to = t + offs, t2 = 2.0 * t;\n        float y = 0.5 * s1 * sin(t2) + s2 * cos(to);\n        t -= y / (s1 * cos(t2) - s2 * sin(to));\n        if (abs(y) < 1e-7 * (s2 + s1)) break;\n    }\n\n    pab = p / ab;\n    return length(p - vec2(cos(t), sin(t)) * ab) * sign(dot(pab, pab) - 1.0);\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n    float co = cos(ang), si = sin(ang);\n    mat2 rot = mat2(co, si, -si, co);\n\n    float ellip = sdEllipse(rot * uv + AXIS, AB);\n    drawSDF(ellip, vec3(1.0, 0.0, 0.0));\n    drawSDF(abs(ellip), vec3(1.0, 0.8, 0.0));\n    drawSDF(length(uv) - 0.05, vec3(1.0, 0.8, 0.0));\n\n    float aspect = iResolution.x / iResolution.y;\n    color = digitIn(color, vec3(1.0), uv * 0.25 + vec2(0.45 * aspect, 0.45), 100.0, ellipseInertia(AB, AXIS));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Constants\n#define PI 3.14159265359\n\n// Ellipse settings\n#define AB (iTime > 12.0 ? vec2(1.75, 0.75) + 0.25 * sin(iTime - 12.0) : vec2(1.75, 0.75))\n#define AXIS vec2(-0.75, 0.25)\n#define DENSITY 0.1\n\n// Simulation settings\n#define FRICTION 0.98\n#define GRAVITY 0.2\n\n// cross3D(vec3(a.x, a.y, 0), vec3(b.x, b.y, 0))\n// Since the x and y components of the result are always zero\n// The z component is the only one of interest\nfloat cross2D(in vec2 a, in vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Mass of an ellipse with uniform density\nfloat ellipseMass(in vec2 ab, in float density) {\n    return PI * ab.x * ab.y * density;\n}\n\n// Moment of inertia of an ellipse with dimensions ab about axis p\nfloat ellipseInertia(in vec2 ab, in vec2 p) {\n    return (dot(ab, ab) / 4.0 + dot(p, p)) * PI * ab.x * ab.y;\n}\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM  2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}", "buffer_a_code": "void mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(-PI / 4.0, 0.0, 0.0, 0.0);\n    addr -= 0.5;\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame > 0 && iAddr == ivec2(0)) {\n        data = texelFetch(iChannel0, ivec2(0), 0);\n\n        float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n        float co = cos(ang), si = sin(ang);\n        mat2 rot = mat2(co, si, -si, co);\n\n        vec2 centerOfMass = -AXIS * rot;\n\n        vec2 force = vec2(0.0, -ellipseMass(AB, DENSITY) * GRAVITY);\n        float torque = cross2D(-centerOfMass, force);\n\n        data.y += torque / ellipseInertia(AB, AXIS);\n        data.y *= FRICTION;\n        data.x += data.y;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2XWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 61, 101, 101, 640], [722, 722, 777, 777, 1438]]}
{"id": "stjSWw", "name": "LookingGlass: Mountain & Lakes", "author": "xjorma", "description": "Shader for the tutorial:\nhttps://learn.lookingglassfactory.com/tutorials/making-holograms-with-shadertoy\n", "tags": ["terrain", "simulation", "tutorial", "water", "fluid", "glass", "liquid", "river", "lake", "looking", "mountain", "diorama", "lookingglass"], "likes": 0, "viewed": 486, "published": 3, "date": "1627844006", "time_retrieved": "2024-07-30T19:08:12.515926", "image_code": "// Created by David Gallardo - xjorma/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n#define GAMMA 1\n\nconst vec3 light = vec3(0.,4.,2.);\nconst float boxHeight = 0.45;\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    float h = texelFetch(iChannel0, p, 0).x;\n    float w = texelFetch(iChannel1, p, 0).x; \n    fragColor = vec4(h, w, w, 1.0);\n}*/\n\n\nvec2 getHeight(in vec3 p)\n{\n    p = (p + 1.0) * 0.5;\n    vec2 p2 = p.xz * vec2(float(textureSize)) / iResolution.xy;\n    p2 = min(p2, vec2(float(textureSize) - 0.5) / iResolution.xy);\n\t//float h = texture(iChannel0, p2).x;\n\t//float w = h + texture(iChannel1, p2).x;\n    vec2 h = texture(iChannel0, p2).xy;\n    h.y += h.x;\n\treturn h - boxHeight;\n} \n\nvec3 getNormal(in vec3 p, int comp)\n{\n    float d = 2.0 / float(textureSize);\n    float hMid = getHeight(p)[comp];\n    float hRight = getHeight(p + vec3(d, 0, 0))[comp];\n    float hTop = getHeight(p + vec3(0, 0, d))[comp];\n    return normalize(cross(vec3(0, hTop - hMid, d), vec3(d, hRight - hMid, 0)));\n}\n\nvec3 terrainColor(in vec3 p, in vec3 n, out float spec)\n{\n    spec = 0.1;\n    vec3 c = vec3(0.21, 0.50, 0.07);\n    float cliff = smoothstep(0.8, 0.3, n.y);\n    c = mix(c, vec3(0.25), cliff);\n    spec = mix(spec, 0.3, cliff);\n    float snow = smoothstep(0.05, 0.25, p.y) * smoothstep(0.5, 0.7, n.y);\n    c = mix(c, vec3(0.95, 0.95, 0.85), snow);\n    spec = mix(spec, 0.4, snow);\n    vec3 t = texture(iChannel1, p.xz * 5.0).xyz;\n    return mix(c, c * t, 0.75);\n}\n\nvec3 undergroundColor(float d)\n{\n    vec3 color[4] = vec3[](vec3(0.5, 0.45, 0.5), vec3(0.40, 0.35, 0.25), vec3(0.55, 0.50, 0.4), vec3(0.45, 0.30, 0.20));\n    d *= 6.0;\n    d = min(d, 3.0 - 0.001);\n    float fr = fract(d);\n    float fl = floor(d);\n    return mix(color[int(fl)], color[int(fl) + 1], fr);\n}\n\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    vec3 n;\n    vec2 ret = boxIntersection(ro, rd, vec3(1, boxHeight, 1), n);\n    if(ret.x > 0.0)\n    {\n        vec3 pi = ro + rd * ret.x;\n        // Find Terrain\n        vec3 tc;\n        vec3 tn;\n        float tt = ret.x;\n        vec2 h = getHeight(pi);\n        float spec;\n        if(pi.y < h.x)\n        {\n            tn = n;\n            tc = undergroundColor(h.x - pi.y);\n        }\n        else\n        {\n            for (int i = 0; i < 80; i++)\n            {\n                vec3 p = ro + rd * tt;\n                float h = p.y - getHeight(p).x;\n                if (h < 0.0002 || tt > ret.y)\n                    break;\n                tt += h * 0.4;\n            }\n            tn = getNormal(ro + rd * tt, 0);\n            tc = terrainColor(ro + rd * tt, tn, spec);\n        }\n        \n        {\n            vec3 lightDir = normalize(light - (ro + rd * tt));\n            tc = tc * (max( 0.0, dot(lightDir, tn)) + 0.3);\n            spec *= pow(max(0., dot(lightDir, reflect(rd, tn))), 10.0);\n            tc += spec;            \n        }\n        \n        if(tt > ret.y)\n        {\n            tc = backgroundColor;\n        }\n        \n        // Find Water\n        float wt = ret.x;\n        h = getHeight(pi);\n        vec3 waterNormal;\n        if(pi.y < h.y)\n        {\n            waterNormal = n;\n        }\n        else\n        {\n            for (int i = 0; i < 80; i++)\n            {\n                vec3 p = ro + rd * wt;\n                float h = p.y - getHeight(p).y;\n                if (h < 0.0002 || wt > min(tt, ret.y))\n                    break;\n                wt += h * 0.4;\n            }\n            waterNormal = getNormal(ro + rd * wt, 1);\n        }\n        \n        if(wt < ret.y)\n        {\n            float dist = (min(tt, ret.y) - wt);\n            vec3 p = waterNormal;\n            vec3 lightDir = normalize(light - (ro + rd * wt));\n                        \n            tc = applyFog( tc, vec3(0,0,0.4), dist * 15.0);\n\n            float spec = pow(max(0., dot(lightDir, reflect(rd, waterNormal))), 20.0);\n            tc += 0.5 * spec * smoothstep(0.0, 0.1, dist);\n        }\n\n        \n        return tc;\n    }\n   \n    return backgroundColor;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord, in vec3 _ro, in vec3 _rd )\n{\n\tvec3 tot = vec3(0.0);\n    \n    vec2 mouse = iMouse.xy;\n    if(length(mouse.xy) < 10.0)\n        mouse = iResolution.xy * 0.5;\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(mouse.x/iResolution.x-0.5) + radians(45.0);\n        float phi\t= radians(90.)*(mouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.0 * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        ro.y *= -1.0;\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca * normalize(vec3(p,1.5));        \n        \n        vec3 col = Render( ca * _ro, ca * _rd);\n        \n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n\n\n\nconst float\tsideAngle       = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize      = 3.0;\nconst float\taspectRatio     = 0.75;\nconst float quiltColumns\t= 8.0;\nconst float quiltRows\t\t= 6.0;\nconst float nearClip        = 5.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2\tcoord = fragCoord * vec2(quiltColumns,quiltRows) / iResolution.xy;\n\tvec2\tfract = fract(coord);\n\tvec2\tfloor = floor(coord);\n\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\n\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio, 0);\n\t\n\tvec4\tcolor;\n\tvec3 \tdirRay = normalize(screenPos-camPos);\n\tmainImage( color, fract*(iResolution.xy), screenPos - nearClip * dirRay, dirRay );\n\n    fragColor = color;\n}\n", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int textureSize = 400;\n// Render\nconst vec3 backgroundColor = vec3(0.2);\n// Terrain\nconst float transitionTime = 5.0;\nconst float transitionPercent = 0.3;\nconst int octaves = 7;\n// Water simulation\nconst float attenuation = 0.995;\nconst float strenght = 0.25;\nconst float minTotalFlow = 0.0001;\nconst float initialWaterLevel = 0.05;\n\nmat2 rot(in float ang) \n{\n   return mat2(\n\t\t\tcos(ang), -sin(ang),\n\t\t\tsin(ang),  cos(ang));\n}\n\n// hash from Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Box intersection by IQ https://iquilezles.org/articles/boxfunctions\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n// Fog by IQ https://iquilezles.org/articles/fog\n\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}", "buffer_a_code": "// compute Terrain and update water level 1st pass\n\n\nfloat boxNoise( in vec2 p, in float z )\n{\n    vec2 fl = floor(p);\n    vec2 fr = fract(p);\n    fr = smoothstep(0.0, 1.0, fr);    \n    float res = mix(mix( hash13(vec3(fl, z)),             hash13(vec3(fl + vec2(1,0), z)),fr.x),\n                    mix( hash13(vec3(fl + vec2(0,1), z)), hash13(vec3(fl + vec2(1,1), z)),fr.x),fr.y);\n    return res;\n}\n\nfloat Terrain( in vec2 p, in float z, in int octaveNum)\n{\n\tfloat a = 1.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < octaveNum; i++)\n\t{\n\t\tf += a * boxNoise(p, z);\n\t\ta *= 0.45;\n\t\tp = 2.0 * rot(radians(41.0)) * p;\n\t}\n\treturn f;\n}\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nvec4 readOutFlow(ivec2 p)\n{\n\tif(p.x < 0 || p.y < 0 || p.x >= textureSize || p.y >= textureSize)\n\t\treturn vec4(0);\n\treturn texelFetch(iChannel1, p, 0);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Outside ?\n    if( max(fragCoord.x, fragCoord.y) > float(textureSize) )\n        discard;\n           \n    // Terrain\n    vec2 uv = fragCoord / float(textureSize);\n    float t = iTime / transitionTime;\n    float terrainElevation = mix(Terrain(uv * 4.0, floor(t), octaves), Terrain(uv * 4.0, floor(t) + 1.0, octaves), smoothstep(1.0 - transitionPercent, 1.0, fract(t))) * 0.5;\n    \n    // Water\n    float waterDept = initialWaterLevel;\n    if(iFrame != 0)\n    {\n        ivec2 p = ivec2(fragCoord);\n        vec2 height = readHeight(p);\n        vec4 OutFlow = texelFetch(iChannel1, p, 0);\n        float totalOutFlow = OutFlow.x + OutFlow.y + OutFlow.z + OutFlow.w;\n        float totalInFlow = 0.0;\n        totalInFlow += readOutFlow(p  + ivec2( 1,  0)).z;\n        totalInFlow += readOutFlow(p  + ivec2( 0,  1)).w;\n        totalInFlow += readOutFlow(p  + ivec2(-1,  0)).x;\n        totalInFlow += readOutFlow(p  + ivec2( 0, -1)).y;\n        waterDept = height.y - totalOutFlow + totalInFlow;\n    }\n    fragColor = vec4(terrainElevation, waterDept, 0, 1);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Update Outflow 1st pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nfloat computeOutFlowDir(vec2 centerHeight, ivec2 pos)\n{\n\tvec2 dirHeight = readHeight(pos);\n\treturn max(0.0f, (centerHeight.x + centerHeight.y) - (dirHeight.x + dirHeight.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    // Init to zero at frame 0\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0);\n        return;\n    }    \n    \n    // Outside ?\n    if( max(p.x, p.y) > textureSize )\n        discard;\n        \n    \n   \tvec4 oOutFlow = texelFetch(iChannel1, p, 0);\n\tvec2 height = readHeight(p);\n\tvec4 nOutFlow;        \n\tnOutFlow.x = computeOutFlowDir(height, p + ivec2( 1,  0));\n\tnOutFlow.y = computeOutFlowDir(height, p + ivec2( 0,  1));\n\tnOutFlow.z = computeOutFlowDir(height, p + ivec2(-1,  0));\n\tnOutFlow.w = computeOutFlowDir(height, p + ivec2( 0, -1));\n\tnOutFlow = attenuation * oOutFlow + strenght * nOutFlow;\n\tfloat totalFlow = nOutFlow.x + nOutFlow.y + nOutFlow.z + nOutFlow.w;\n\tif(totalFlow > minTotalFlow)\n\t{\n\t\tif(height.y < totalFlow)\n\t\t{\n\t\t\tnOutFlow = nOutFlow * (height.y / totalFlow);\n\t\t}\n\t}\n\telse\n\t{\n\t\tnOutFlow = vec4(0);\n\t}\n\n\n    fragColor = nOutFlow;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// water level 2nd pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nvec4 readOutFlow(ivec2 p)\n{\n\tif(p.x < 0 || p.y < 0 || p.x >= textureSize || p.y >= textureSize)\n\t\treturn vec4(0);\n\treturn texelFetch(iChannel1, p, 0);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Outside ?\n    if( max(fragCoord.x, fragCoord.y) > float(textureSize) )\n        discard;\n           \n    // Water\n    ivec2 p = ivec2(fragCoord);\n    vec2 height = readHeight(p);\n    vec4 OutFlow = texelFetch(iChannel1, p, 0);\n    float totalOutFlow = OutFlow.x + OutFlow.y + OutFlow.z + OutFlow.w;\n    float totalInFlow = 0.0;\n    totalInFlow += readOutFlow(p  + ivec2( 1,  0)).z;\n    totalInFlow += readOutFlow(p  + ivec2( 0,  1)).w;\n    totalInFlow += readOutFlow(p  + ivec2(-1,  0)).x;\n    totalInFlow += readOutFlow(p  + ivec2( 0, -1)).y;\n    float waterDept = height.y - totalOutFlow + totalInFlow;\n\n    fragColor = vec4(height.x, waterDept, 0, 1);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Update Outflow 2nd pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nfloat computeOutFlowDir(vec2 centerHeight, ivec2 pos)\n{\n\tvec2 dirHeight = readHeight(pos);\n\treturn max(0.0f, (centerHeight.x + centerHeight.y) - (dirHeight.x + dirHeight.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    // Outside ?\n    if( max(p.x, p.y) > textureSize )\n        discard;\n        \n    \n   \tvec4 oOutFlow = texelFetch(iChannel1, p, 0);\n\tvec2 height = readHeight(p);\n\tvec4 nOutFlow;        \n\tnOutFlow.x = computeOutFlowDir(height, p + ivec2( 1,  0));\n\tnOutFlow.y = computeOutFlowDir(height, p + ivec2( 0,  1));\n\tnOutFlow.z = computeOutFlowDir(height, p + ivec2(-1,  0));\n\tnOutFlow.w = computeOutFlowDir(height, p + ivec2( 0, -1));\n\tnOutFlow = attenuation * oOutFlow + strenght * nOutFlow;\n\tfloat totalFlow = nOutFlow.x + nOutFlow.y + nOutFlow.z + nOutFlow.w;\n\tif(totalFlow > minTotalFlow)\n\t{\n\t\tif(height.y < totalFlow)\n\t\t{\n\t\t\tnOutFlow = nOutFlow * (height.y / totalFlow);\n\t\t}\n\t}\n\telse\n\t{\n\t\tnOutFlow = vec4(0);\n\t}\n\n\n    fragColor = nOutFlow;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjSWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[434, 434, 461, 461, 780], [783, 783, 820, 820, 1088], [1090, 1090, 1147, 1147, 1550], [1860, 1860, 1897, 1897, 4056], [4059, 4059, 4101, 4101, 4265], [4268, 4268, 4312, 4312, 4411]]}
{"id": "fl2XDm", "name": "hexagonal pipes sdf hack", "author": "cedric_h", "description": "looks 3d by virtue of the sdf", "tags": ["sdf", "hexagon"], "likes": 1, "viewed": 267, "published": 3, "date": "1627843508", "time_retrieved": "2024-07-30T19:08:13.405549", "image_code": "float sdHexagon(vec2 p, float r) {\n  /* -cos(PI/6), sin(PI/6), tan(PI/6) */\n  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n\n  /* rotate by 30 degrees for a pointy tipped hexagon */\n  p = vec2(dot(vec2(-k.x,k.y),p), dot(-k.yx, p));\n\n  /* fold space into first quadrant */ \n  p = abs(p);\n\n  /* reflect around pi/6 plane */\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n\n  /* take out the chunk of the shape we want */\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n  float d = sdHexagon(p, 0.5);\n\n  vec3 col = vec3(1.0 - smoothstep(0.0, 0.1, d));\n  // col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2XDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 75, 488], [490, 490, 547, 547, 787]]}
{"id": "7tSSDD", "name": "Mountains & Lakes", "author": "xjorma", "description": "Use the mouse to turn around!\nSuper fast even on my slow Pixel 2!\nWater simulation inspired by this:\nhttps://hal.inria.fr/inria-00402079/document\n", "tags": ["terrain", "simulation", "water", "fluid", "liquid", "river", "lake", "mountain", "diorama"], "likes": 113, "viewed": 3607, "published": 3, "date": "1627840518", "time_retrieved": "2024-07-30T19:08:14.381937", "image_code": "// Created by David Gallardo - xjorma/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n#define AA\n#define GAMMA 1\n\nconst vec3 light = vec3(0.,4.,2.);\nconst float boxHeight = 0.45;\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    float h = texelFetch(iChannel0, p, 0).x;\n    float w = texelFetch(iChannel1, p, 0).x; \n    fragColor = vec4(h, w, w, 1.0);\n}*/\n\n\nvec2 getHeight(in vec3 p)\n{\n    p = (p + 1.0) * 0.5;\n    vec2 p2 = p.xz * vec2(float(textureSize)) / iResolution.xy;\n    p2 = min(p2, vec2(float(textureSize) - 0.5) / iResolution.xy);\n    vec2 h = texture(iChannel0, p2).xy;\n    h.y += h.x;\n\treturn h - boxHeight;\n} \n\nvec3 getNormal(in vec3 p, int comp)\n{\n    float d = 2.0 / float(textureSize);\n    float hMid = getHeight(p)[comp];\n    float hRight = getHeight(p + vec3(d, 0, 0))[comp];\n    float hTop = getHeight(p + vec3(0, 0, d))[comp];\n    return normalize(cross(vec3(0, hTop - hMid, d), vec3(d, hRight - hMid, 0)));\n}\n\nvec3 terrainColor(in vec3 p, in vec3 n, out float spec)\n{\n    spec = 0.1;\n    vec3 c = vec3(0.21, 0.50, 0.07);\n    float cliff = smoothstep(0.8, 0.3, n.y);\n    c = mix(c, vec3(0.25), cliff);\n    spec = mix(spec, 0.3, cliff);\n    float snow = smoothstep(0.05, 0.25, p.y) * smoothstep(0.5, 0.7, n.y);\n    c = mix(c, vec3(0.95, 0.95, 0.85), snow);\n    spec = mix(spec, 0.4, snow);\n    vec3 t = texture(iChannel1, p.xz * 5.0).xyz;\n    return mix(c, c * t, 0.75);\n}\n\nvec3 undergroundColor(float d)\n{\n    vec3 color[4] = vec3[](vec3(0.5, 0.45, 0.5), vec3(0.40, 0.35, 0.25), vec3(0.55, 0.50, 0.4), vec3(0.45, 0.30, 0.20));\n    d *= 6.0;\n    d = min(d, 3.0 - 0.001);\n    float fr = fract(d);\n    float fl = floor(d);\n    return mix(color[int(fl)], color[int(fl) + 1], fr);\n}\n\n\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    vec3 n;\n    vec2 ret = boxIntersection(ro, rd, vec3(1, boxHeight, 1), n);\n    if(ret.x > 0.0)\n    {\n        vec3 pi = ro + rd * ret.x;\n        // Find Terrain\n        vec3 tc;\n        vec3 tn;\n        float tt = ret.x;\n        vec2 h = getHeight(pi);\n        float spec;\n        if(pi.y < h.x)\n        {\n            tn = n;\n            tc = undergroundColor(h.x - pi.y);\n        }\n        else\n        {\n            for (int i = 0; i < 80; i++)\n            {\n                vec3 p = ro + rd * tt;\n                float h = p.y - getHeight(p).x;\n                if (h < 0.0002 || tt > ret.y)\n                    break;\n                tt += h * 0.4;\n            }\n            tn = getNormal(ro + rd * tt, 0);\n            tc = terrainColor(ro + rd * tt, tn, spec);\n        }\n        \n        {\n            vec3 lightDir = normalize(light - (ro + rd * tt));\n            tc = tc * (max( 0.0, dot(lightDir, tn)) + 0.3);\n            spec *= pow(max(0., dot(lightDir, reflect(rd, tn))), 10.0);\n            tc += spec;            \n        }\n        \n        if(tt > ret.y)\n        {\n            tc = backgroundColor;\n        }\n        \n        // Find Water\n        float wt = ret.x;\n        h = getHeight(pi);\n        vec3 waterNormal;\n        if(pi.y < h.y)\n        {\n            waterNormal = n;\n        }\n        else\n        {\n            for (int i = 0; i < 80; i++)\n            {\n                vec3 p = ro + rd * wt;\n                float h = p.y - getHeight(p).y;\n                if (h < 0.0002 || wt > min(tt, ret.y))\n                    break;\n                wt += h * 0.4;\n            }\n            waterNormal = getNormal(ro + rd * wt, 1);\n        }\n        \n        if(wt < ret.y)\n        {\n            float dist = (min(tt, ret.y) - wt);\n            vec3 p = waterNormal;\n            vec3 lightDir = normalize(light - (ro + rd * wt));\n                        \n            tc = applyFog( tc, vec3(0,0,0.4), dist * 15.0);\n\n            float spec = pow(max(0., dot(lightDir, reflect(rd, waterNormal))), 20.0);\n            tc += 0.5 * spec * smoothstep(0.0, 0.1, dist);\n        }\n\n        \n        return tc;\n    }\n   \n    return backgroundColor;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n    \n    vec2 mouse = iMouse.xy;\n    if(length(mouse.xy) < 10.0)\n        mouse = iResolution.xy * 0.5;\n        \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(360.)*(mouse.x/iResolution.x-0.5) + iTime*.2;\n        float phi\t= radians(90.)*(mouse.y/iResolution.y-0.5)-1.;\n        vec3 ro = 2.0 * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        //vec3 ro = vec3(0.0,.2,4.0);\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = Render(ro, rd);\n        \n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = vignette(tot, fragCoord / iResolution.xy, 0.6);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int textureSize = 256;\n// Render\nconst vec3 backgroundColor = vec3(0.2);\n// Terrain\nconst float transitionTime = 5.0;\nconst float transitionPercent = 0.3;\nconst int octaves = 7;\n// Water simulation\nconst float attenuation = 0.995;\nconst float strenght = 0.25;\nconst float minTotalFlow = 0.0001;\nconst float initialWaterLevel = 0.05;\n\nmat2 rot(in float ang) \n{\n   return mat2(\n\t\t\tcos(ang), -sin(ang),\n\t\t\tsin(ang),  cos(ang));\n}\n\n// hash from Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Box intersection by IQ https://iquilezles.org/articles/boxfunctions\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n// Fog by IQ https://iquilezles.org/articles/fog\n\nvec3 applyFog( in vec3  rgb, vec3 fogColor, in float distance)\n{\n    float fogAmount = exp( -distance );\n    return mix( fogColor, rgb, fogAmount );\n}", "buffer_a_code": "// compute Terrain and update water level 1st pass\n\n\nfloat boxNoise( in vec2 p, in float z )\n{\n    vec2 fl = floor(p);\n    vec2 fr = fract(p);\n    fr = smoothstep(0.0, 1.0, fr);    \n    float res = mix(mix( hash13(vec3(fl, z)),             hash13(vec3(fl + vec2(1,0), z)),fr.x),\n                    mix( hash13(vec3(fl + vec2(0,1), z)), hash13(vec3(fl + vec2(1,1), z)),fr.x),fr.y);\n    return res;\n}\n\nfloat Terrain( in vec2 p, in float z, in int octaveNum)\n{\n\tfloat a = 1.0;\n\tfloat f = .0;\n\tfor (int i = 0; i < octaveNum; i++)\n\t{\n\t\tf += a * boxNoise(p, z);\n\t\ta *= 0.45;\n\t\tp = 2.0 * rot(radians(41.0)) * p;\n\t}\n\treturn f;\n}\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nvec4 readOutFlow(ivec2 p)\n{\n\tif(p.x < 0 || p.y < 0 || p.x >= textureSize || p.y >= textureSize)\n\t\treturn vec4(0);\n\treturn texelFetch(iChannel1, p, 0);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Outside ?\n    if( max(fragCoord.x, fragCoord.y) > float(textureSize) )\n        discard;\n           \n    // Terrain\n    vec2 uv = fragCoord / float(textureSize);\n    float t = iTime / transitionTime;\n    float terrainElevation = mix(Terrain(uv * 4.0, floor(t), octaves), Terrain(uv * 4.0, floor(t) + 1.0, octaves), smoothstep(1.0 - transitionPercent, 1.0, fract(t))) * 0.5;\n    \n    // Water\n    float waterDept = initialWaterLevel;\n    if(iFrame != 0)\n    {\n        ivec2 p = ivec2(fragCoord);\n        vec2 height = readHeight(p);\n        vec4 OutFlow = texelFetch(iChannel1, p, 0);\n        float totalOutFlow = OutFlow.x + OutFlow.y + OutFlow.z + OutFlow.w;\n        float totalInFlow = 0.0;\n        totalInFlow += readOutFlow(p  + ivec2( 1,  0)).z;\n        totalInFlow += readOutFlow(p  + ivec2( 0,  1)).w;\n        totalInFlow += readOutFlow(p  + ivec2(-1,  0)).x;\n        totalInFlow += readOutFlow(p  + ivec2( 0, -1)).y;\n        waterDept = height.y - totalOutFlow + totalInFlow;\n    }\n    fragColor = vec4(terrainElevation, waterDept, 0, 1);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Update Outflow 1st pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nfloat computeOutFlowDir(vec2 centerHeight, ivec2 pos)\n{\n\tvec2 dirHeight = readHeight(pos);\n\treturn max(0.0f, (centerHeight.x + centerHeight.y) - (dirHeight.x + dirHeight.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    // Init to zero at frame 0\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0);\n        return;\n    }    \n    \n    // Outside ?\n    if( max(p.x, p.y) > textureSize )\n        discard;\n        \n    \n   \tvec4 oOutFlow = texelFetch(iChannel1, p, 0);\n\tvec2 height = readHeight(p);\n\tvec4 nOutFlow;        \n\tnOutFlow.x = computeOutFlowDir(height, p + ivec2( 1,  0));\n\tnOutFlow.y = computeOutFlowDir(height, p + ivec2( 0,  1));\n\tnOutFlow.z = computeOutFlowDir(height, p + ivec2(-1,  0));\n\tnOutFlow.w = computeOutFlowDir(height, p + ivec2( 0, -1));\n\tnOutFlow = attenuation * oOutFlow + strenght * nOutFlow;\n\tfloat totalFlow = nOutFlow.x + nOutFlow.y + nOutFlow.z + nOutFlow.w;\n\tif(totalFlow > minTotalFlow)\n\t{\n\t\tif(height.y < totalFlow)\n\t\t{\n\t\t\tnOutFlow = nOutFlow * (height.y / totalFlow);\n\t\t}\n\t}\n\telse\n\t{\n\t\tnOutFlow = vec4(0);\n\t}\n\n\n    fragColor = nOutFlow;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// water level 2nd pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nvec4 readOutFlow(ivec2 p)\n{\n\tif(p.x < 0 || p.y < 0 || p.x >= textureSize || p.y >= textureSize)\n\t\treturn vec4(0);\n\treturn texelFetch(iChannel1, p, 0);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Outside ?\n    if( max(fragCoord.x, fragCoord.y) > float(textureSize) )\n        discard;\n           \n    // Water\n    ivec2 p = ivec2(fragCoord);\n    vec2 height = readHeight(p);\n    vec4 OutFlow = texelFetch(iChannel1, p, 0);\n    float totalOutFlow = OutFlow.x + OutFlow.y + OutFlow.z + OutFlow.w;\n    float totalInFlow = 0.0;\n    totalInFlow += readOutFlow(p  + ivec2( 1,  0)).z;\n    totalInFlow += readOutFlow(p  + ivec2( 0,  1)).w;\n    totalInFlow += readOutFlow(p  + ivec2(-1,  0)).x;\n    totalInFlow += readOutFlow(p  + ivec2( 0, -1)).y;\n    float waterDept = height.y - totalOutFlow + totalInFlow;\n\n    fragColor = vec4(height.x, waterDept, 0, 1);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Update Outflow 2nd pass\n\nvec2 readHeight(ivec2 p)\n{\n\tp = clamp(p, ivec2(0), ivec2(textureSize - 1));\n\treturn texelFetch(iChannel0, p, 0).xy;\n} \n\nfloat computeOutFlowDir(vec2 centerHeight, ivec2 pos)\n{\n\tvec2 dirHeight = readHeight(pos);\n\treturn max(0.0f, (centerHeight.x + centerHeight.y) - (dirHeight.x + dirHeight.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    \n    // Outside ?\n    if( max(p.x, p.y) > textureSize )\n        discard;\n        \n    \n   \tvec4 oOutFlow = texelFetch(iChannel1, p, 0);\n\tvec2 height = readHeight(p);\n\tvec4 nOutFlow;        \n\tnOutFlow.x = computeOutFlowDir(height, p + ivec2( 1,  0));\n\tnOutFlow.y = computeOutFlowDir(height, p + ivec2( 0,  1));\n\tnOutFlow.z = computeOutFlowDir(height, p + ivec2(-1,  0));\n\tnOutFlow.w = computeOutFlowDir(height, p + ivec2( 0, -1));\n\tnOutFlow = attenuation * oOutFlow + strenght * nOutFlow;\n\tfloat totalFlow = nOutFlow.x + nOutFlow.y + nOutFlow.z + nOutFlow.w;\n\tif(totalFlow > minTotalFlow)\n\t{\n\t\tif(height.y < totalFlow)\n\t\t{\n\t\t\tnOutFlow = nOutFlow * (height.y / totalFlow);\n\t\t}\n\t}\n\telse\n\t{\n\t\tnOutFlow = vec4(0);\n\t}\n\n\n    fragColor = nOutFlow;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSSDD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[434, 434, 461, 461, 698], [701, 701, 738, 738, 1006], [1008, 1008, 1065, 1065, 1468], [1778, 1778, 1815, 1815, 3974], [3977, 3977, 4019, 4019, 4183], [4186, 4186, 4230, 4230, 4329]]}
{"id": "slSSDm", "name": "Integration - sqrt(x^2+1)", "author": "oneshade", "description": "The integral of sqrt(x^2+1) is (asinh(x)+x*sqrt(x^2+1))/2\nHere is a geometrical interpretation. Note that integrating the square root of a quadratic also boils down to this integral (an example would be the arclength of a quadratic bezier curve).", "tags": ["geometry", "integration", "hyperbola", "righttriangle", "hyperbolicsector"], "likes": 11, "viewed": 185, "published": 3, "date": "1627837984", "time_retrieved": "2024-07-30T19:08:15.141905", "image_code": "// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel0, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\n\n// SDFs\nfloat sdDisk(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 8.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse.x = sin(iTime) + 2.0;\n\n    // Axes\n    drawSDF(abs(uv.x), vec3(0.0, 0.0, 1.0));\n    drawSDF(abs(uv.y), vec3(0.0, 0.0, 1.0));\n\n    // Point on hyperbola\n    vec2 p = vec2(mouse.x, sqrt(mouse.x * mouse.x + 1.0));\n\n    // Hyperbola\n    float y = sqrt(uv.x * uv.x + 1.0);\n    float dx = uv.x / sqrt(uv.x * uv.x + 1.0);\n\n    // Section\n    vec2 cen = 0.5 * p;\n    drawSDF(max((uv.y - y) / sqrt(1.0 + dx * dx), sdBox(uv - cen, abs(cen))), uv.y > p.y / p.x * uv.x ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0));\n\n    drawSDF(sdLine(uv, vec2(0.0, p.y), p) - 0.01, vec3(0.5, 0.0, 1.0));\n    drawSDF(sdLine(uv, vec2(p.x, 0.0), p) - 0.01, vec3(0.5, 0.0, 1.0));\n    drawSDF(sdLine(uv, vec2(0.0), p) - 0.01, vec3(0.5, 0.0, 1.0));\n\n    // Text \"u=sinh(a)\"\n    vec2 pos = vec2(0.5 * p.x - 1.0, p.y + 0.25);\n    drawChar(color, vec3(1.0), uv, pos, vec2(0.5), u);\n    drawChar(color, vec3(1.0), uv, pos + vec2(0.25, 0.0), vec2(0.5), EQUAL);\n    drawChar(color, vec3(1.0), uv, pos + vec2(0.5, 0.0), vec2(0.5), s);\n    drawChar(color, vec3(1.0), uv, pos + vec2(0.75, 0.0), vec2(0.5), i);\n    drawChar(color, vec3(1.0), uv, pos + vec2(1.0, 0.0), vec2(0.5), n);\n    drawChar(color, vec3(1.0), uv, pos + vec2(1.25, 0.0), vec2(0.5), h);\n    drawChar(color, vec3(1.0), uv, pos + vec2(1.5, 0.0), vec2(0.5), OPEN_PARENTHESIS);\n    drawChar(color, vec3(1.0), uv, pos + vec2(1.75, 0.0), vec2(0.5), a);\n    drawChar(color, vec3(1.0), uv, pos + vec2(2.0, 0.0), vec2(0.5), CLOSE_PARENTHESIS);\n\n    // Text \"v=cosh(a)\"\n    vec2 vu = vec2(-uv.y, uv.x); // Rotate 90 degrees\n    pos = vec2(-0.5 * p.y - 0.5 - 0.5, p.x + 0.25 * sign(p.x));\n    drawChar(color, vec3(1.0), vu, pos, vec2(0.5), v);\n    drawChar(color, vec3(1.0), vu, pos + vec2(0.25, 0.0), vec2(0.5), EQUAL);\n    drawChar(color, vec3(1.0), vu, pos + vec2(0.5, 0.0), vec2(0.5), c);\n    drawChar(color, vec3(1.0), vu, pos + vec2(0.75, 0.0), vec2(0.5), o);\n    drawChar(color, vec3(1.0), vu, pos + vec2(1.0, 0.0), vec2(0.5), s);\n    drawChar(color, vec3(1.0), vu, pos + vec2(1.25, 0.0), vec2(0.5), h);\n    drawChar(color, vec3(1.0), vu, pos + vec2(1.5, 0.0), vec2(0.5), OPEN_PARENTHESIS);\n    drawChar(color, vec3(1.0), vu, pos + vec2(1.75, 0.0), vec2(0.5), a);\n    drawChar(color, vec3(1.0), vu, pos + vec2(2.0, 0.0), vec2(0.5), CLOSE_PARENTHESIS);\n\n    // uv/2 (in triangle)\n    pos = vec2(2.0 * p.x, p.y) / 3.0 - vec2(0.25, 0.0);\n    drawChar(color, vec3(1.0), uv, pos, vec2(0.5), u);\n    drawChar(color, vec3(1.0), uv, pos + vec2(0.25, 0.0), vec2(0.5), v);\n    drawChar(color, vec3(1.0), uv, pos + vec2(0.5, 0.0), vec2(0.5), SLASH);\n    drawChar(color, vec3(1.0), uv, pos + vec2(0.75, 0.0), vec2(0.5), TWO);\n\n    // a/2 (in hyperbolic sector)\n    drawSDF(sdLine(uv * vec2(sign(p.x), 1.0), vec2(-1.0, 0.5), vec2(0.125, 0.5)), vec3(1.0));\n    if (p.x > 0.0) {\n        drawChar(color, vec3(1.0), uv, vec2(-1.75, 0.5), vec2(0.5), a);\n        drawChar(color, vec3(1.0), uv, vec2(-1.5, 0.5), vec2(0.5), SLASH);\n        drawChar(color, vec3(1.0), uv, vec2(-1.25, 0.5), vec2(0.5), TWO);\n    }\n\n    else {\n        drawChar(color, vec3(1.0), uv, vec2(1.25, 0.5), vec2(0.5), a);\n        drawChar(color, vec3(1.0), uv, vec2(1.5, 0.5), vec2(0.5), SLASH);\n        drawChar(color, vec3(1.0), uv, vec2(1.75, 0.5), vec2(0.5), TWO);\n    }\n\n    drawSDF(abs(uv.y - y) / sqrt(1.0 + dx * dx), vec3(1.0, 0.0, 0.0));\n    drawSDF(sdDisk(uv, p, 0.1), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int SPACE = 32;\nconst int Exclame = 33;\nconst int DOUBLE_QUOTE = 34;\nconst int HASHTAG = 35;\nconst int DOLLAR = 36;\nconst int PERCENT = 37;\nconst int AMPERSAND = 38;\nconst int SINGLE_QUOTE = 39;\nconst int OPEN_PARENTHESIS = 40;\nconst int CLOSE_PARENTHESIS = 41;\nconst int ASTERISK = 42;\nconst int PLUS = 43;\nconst int COMMA = 44;\nconst int HYPHEN = 45;\nconst int PERIOD = 46;\nconst int SLASH = 47;\nconst int ZERO = 48;\nconst int ONE = 49;\nconst int TWO = 50;\nconst int THREE = 51;\nconst int FOUR = 52;\nconst int FIVE = 53;\nconst int SIX = 54;\nconst int SEVEN = 55;\nconst int EIGHT = 56;\nconst int NINE = 57;\nconst int COLON = 58;\nconst int SEMICOLON = 59;\nconst int LESS_THAN = 60;\nconst int EQUAL = 61;\nconst int GREATER_THAN = 62;\nconst int QUESTION = 63;\nconst int AT = 64;\nconst int A = 65;\nconst int B = 66;\nconst int C = 67;\nconst int D = 68;\nconst int E = 69;\nconst int F = 70;\nconst int G = 71;\nconst int H = 72;\nconst int I = 73;\nconst int J = 74;\nconst int K = 75;\nconst int L = 76;\nconst int M = 77;\nconst int N = 78;\nconst int O = 79;\nconst int P = 80;\nconst int Q = 81;\nconst int R = 82;\nconst int S = 83;\nconst int T = 84;\nconst int U = 85;\nconst int V = 86;\nconst int W = 87;\nconst int X = 88;\nconst int Y = 89;\nconst int Z = 90;\nconst int OPEN_BRACKET = 91;\nconst int BACKSLASH = 92;\nconst int CLOSE_BRACKET = 93;\nconst int CIRCUMFLEX = 94;\nconst int a = 97;\nconst int b = 98;\nconst int c = 99;\nconst int d = 100;\nconst int e = 101;\nconst int f = 102;\nconst int g = 103;\nconst int h = 104;\nconst int i = 105;\nconst int j = 106;\nconst int k = 107;\nconst int l = 108;\nconst int m = 109;\nconst int n = 110;\nconst int o = 111;\nconst int p = 112;\nconst int q = 113;\nconst int r = 114;\nconst int s = 115;\nconst int t = 116;\nconst int u = 117;\nconst int v = 118;\nconst int w = 119;\nconst int x = 120;\nconst int y = 121;\nconst int z = 122;\nconst int OPEN_BRACE = 123;\nconst int PIPE = 124;\nconst int CLOSE_BRACE = 125;\nconst int TILDE = 126;", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 180, 283, 283, 548], [550, 558, 606, 606, 638], [640, 640, 675, 675, 755], [757, 757, 804, 804, 912], [914, 914, 969, 969, 4702]]}
{"id": "Nl2XWm", "name": "anti-aliased circles", "author": "modesty", "description": "Anti-aliased circles with linearstep/smoothstep/smootherstep", "tags": ["antialiased"], "likes": 0, "viewed": 311, "published": 3, "date": "1627835437", "time_retrieved": "2024-07-30T19:08:15.982657", "image_code": "#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\nfloat linearstep(float edge0, float edge1, float x) {\n    float t = (x - edge0)/(edge1-edge0);\n    \n    return clamp(t, 0., 1.);\n}\n\nfloat smootherstep(float edge0, float edge1, float x) {\n    float t = (x-edge0)/(edge1-edge0);\n    float t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n    \n    return clamp(t1, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = 2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    float xMax = iResolution.x/iResolution.y;\n    \n    vec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n    \n    vec3 pixel = bgCol;\n    float m;\n    \n    float radius = 0.4; // increase radius to see the effect better\n    if(r.x < -0.5*xMax) { // PART I\n        // no interpolation, yes aliasing\n        m = step(radius, length(r-vec2(-0.5*xMax-0.4, 0.0)));\n        \n        // if the distance from the center is smaller than radius,\n\t\t// then mix value is 0.0\n\t\t// otherwise the mix value is 1.0\n        pixel = mix(col1, bgCol, m);\n    } else if(r.x < -0.0*xMax) { // PART II \n       // linearstep (first order, linear interpolation)\n       \n       m = linearstep(radius - 0.005, radius + 0.005, length(r - vec2(-0.0*xMax-0.4, 0.0)));\n       \n       pixel = mix(col1, bgCol, m);\n    } else if(r.x < 0.5*xMax) { // PART III\n        // smoothstep (cubical interpolation)\n        \n        m = smoothstep(radius - 0.005, radius + 0.005, length(r - vec2(0.5*xMax-0.4, 0.0)));\n        \n        pixel = mix(col1, bgCol, m);\n    } else if(r.x < 1.0*xMax) { // PART IV\n        // smootherstep (sixth order interpolation) \n        \n        m = smootherstep(radius-0.005, radius + 0.005, length(r - vec2(1.0*xMax-0.4, 0.0)));\n        \n        pixel = mix(col1, bgCol, m);\n    }\n    \n    fragColor = vec4(pixel, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2XWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 107, 107, 184], [186, 186, 241, 241, 362], [364, 364, 421, 421, 1927]]}
{"id": "7t2SDR", "name": "Floled's Pathtracing 2.0", "author": "Floled", "description": "bruh", "tags": ["bruh"], "likes": 1, "viewed": 242, "published": 3, "date": "1627829993", "time_retrieved": "2024-07-30T19:08:16.729660", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    vec3 col = data.xyz / data.w; \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define INFINITY 1e9\n#define PI 3.1415926\n#define NUM_SAMPLES 16\n#define NUM_BOUNCES 8\n#define EPSILON 1e-8\nvec2 _Pixel;\nfloat _Seed = 0.0;\nfloat rand() {\n    float result = sin(_Seed / 100.0 * dot(_Pixel * cos(iTime * 53.35342), vec2(12.9898f, 78.233f))) * 43758.5453;\n    _Seed += 1.0;\n    return fract(result);\n}\nfloat rand2(vec2 v) {\n    float result = fract(sin(fract(iTime + v.x + v.y) * 54538.4375 * dot(v, vec2(12.9898, 78.233))) * 43758.5453);\n    return result;\n}\nfloat sdot(vec3 x, vec3 y) {\n    return clamp(dot(x, y), 0.0, 1.0);\n}\nvec3 randPointOnSphere(vec2 seed) {\n    vec2 uv = vec2(fract(rand2(seed)), fract(rand2(seed * 59.24234)));\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\nfloat smoothnessToPhongAlpha(float s)\n{\n    return pow(1000.0, s * s);\n}\nfloat energy(vec3 color)\n{\n    return (color.x + color.y + color.z) / 3.0;\n}\n\nstruct Material {\n    vec3 color;\n    float smoothness;\n    bool metallic;\n    bool emission;\n    float intensity;\n    float ior;\n};\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    vec3 energy;\n};\nstruct HitInfo {\n    vec3 pos;\n    vec3 direction;\n    vec3 normal;\n    float distance;\n    int materialID;\n};\nstruct Triangle {\n    vec3 vertex0;\n    vec3 vertex1;\n    vec3 vertex2;\n    int materialID;\n};\nconst int numTriangles = 14;\nTriangle triangles[numTriangles] = Triangle[numTriangles](\n    Triangle(\n        vec3(-10.0, 0.0, 10.0),\n        vec3(10.0, 0.0, 10.0),\n        vec3(10.0, 0.0, -10.0),\n        0\n    ),\n    Triangle(\n        vec3(-10.0, 0.0, 10.0),\n        vec3(10.0, 0.0, -10.0),\n        vec3(-10.0, 0.0, -10.0),\n        0\n    ),\n    Triangle(\n        vec3(10.0, 20.0, 10.0),\n        vec3(-10.0, 20.0, 10.0),\n        vec3(10.0, 20.0, -10.0),\n        0\n    ),\n    Triangle(\n        vec3(-10.0, 20.0, -10.0),\n        vec3(10.0, 20.0, -10.0),\n        vec3(-10.0, 20.0, 10.0),\n        0\n    ),\n    Triangle(\n        vec3(-10.0, 20.0, -10.0),\n        vec3(10.0, 0.0, -10.0),\n        vec3(10.0, 20.0, -10.0),\n        2\n    ),\n    Triangle(\n        vec3(10.0, 0.0, -10.0),\n        vec3(-10.0, 20.0, -10.0),\n        vec3(-10.0, 0.0, -10.0),\n        2\n    ),\n    Triangle(\n        vec3(-10.0, 20.0, 10.0),\n        vec3(10.0, 20.0, 10.0),\n        vec3(10.0, 0.0, 10.0),\n        1\n    ),\n    Triangle(\n        vec3(10.0, 0.0, 10.0),\n        vec3(-10.0, 0.0, 10.0),\n        vec3(-10.0, 20.0, 10.0),\n        1\n    ),\n    Triangle(\n        vec3(10.0, 20.0, 10.0),\n        vec3(10.0, 20.0, -10.0),\n        vec3(10.0, 0.0, 10.0),\n        0\n    ),\n    Triangle(\n        vec3(10.0, 0.0, 10.0),\n        vec3(10.0, 20.0, -10.0),\n        vec3(10.0, 0.0, -10.0),\n        0\n    ),\n    Triangle(\n        vec3(-10.0, 20.0, 10.0),\n        vec3(-10.0, 0.0, 10.0),\n        vec3(-10.0, 20.0, -10.0),\n        0\n    ),\n    Triangle(\n        vec3(-10.0, 0.0, 10.0),\n        vec3(-10.0, 0.0, -10.0),\n        vec3(-10.0, 20.0, -10.0),\n        0\n    ),\n    Triangle(\n        vec3(5.0, 19.5, 5.0),\n        vec3(-5.0, 19.5, 5.0),\n        vec3(5.0, 19.5, -5.0),\n        3\n    ),\n    Triangle(\n        vec3(-5.0, 19.5, -5.0),\n        vec3(5.0, 19.5, -5.0),\n        vec3(-5.0, 19.5, 5.0),\n        3\n    )\n);\nMaterial materials[4] = Material[4](\n    Material(vec3(1.0, 1.0, 1.0), 0.0, false, false, 0., 1.45),\n    Material(vec3(0.0, 1.0, 0.0), 0.0, false, false, 0., 1.45),\n    Material(vec3(1.0, 0.0, 0.0), 0.0, false, false, 0., 1.45),\n    Material(vec3(1.0, 1.0, 1.0), 0.0, false, true, 20., 1.45)\n);\nbool intersectTriangle(Ray ray, int triangleID, inout float t, inout float u, inout float v) {\n    Triangle triangle = triangles[triangleID];\n    vec3 edge1 = triangle.vertex1 - triangle.vertex0;\n    vec3 edge2 = triangle.vertex2 - triangle.vertex0;\n    vec3 pvec = cross(ray.direction, edge2);\n    float det = dot(edge1, pvec);\n    if (det < EPSILON)\n        return false;\n    float inv_det = 1.0 / det;\n    vec3 tvec = ray.origin - triangle.vertex0;\n    u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0)\n        return false;\n    vec3 qvec = cross(tvec, edge1);\n    v = dot(ray.direction, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0)\n        return false;\n    t = dot(edge2, qvec) * inv_det;\n    return true;\n}\nHitInfo trace(Ray ray) {\n    HitInfo rayHit = HitInfo(vec3(0.), ray.direction, vec3(0.), INFINITY, 0);\n    for (int i = 0; i < numTriangles; i++) {\n        float t, u, v;\n        if (intersectTriangle(ray, i, t, u, v)) {\n            if (t > 0.0 && t < rayHit.distance) {\n                rayHit.pos = ray.origin + ray.direction * t;\n                rayHit.normal = normalize(cross(triangles[i].vertex1 - triangles[i].vertex0, triangles[i].vertex2 - triangles[i].vertex0));\n                rayHit.distance = t;\n                rayHit.materialID = triangles[i].materialID;\n            }\n        }\n    }\n    return rayHit;\n}\nvec3 shade(inout Ray ray, HitInfo hitInfo) {\n    vec3 pos = hitInfo.pos;\n    vec3 dir = normalize(hitInfo.direction);\n    vec3 normal = normalize(hitInfo.normal);\n    if (hitInfo.distance < INFINITY) {\n        Material material = materials[hitInfo.materialID];\n        float ior = material.ior;\n        float f0 = pow((ior - 1.0), 2.0) / pow((ior + 1.0), 2.0);\n        float fresnel = f0 + (1.0 - f0) * pow((1.0 - dot(-dir, normal)), 5.0);\n        \n        vec3 diffuse = material.color;\n        ray.origin = pos + normal * 0.001;\n        vec3 reflectionAngle = reflect(ray.direction, normal);\n        float alpha = smoothnessToPhongAlpha(material.smoothness);\n        vec3 rand = randPointOnSphere(dir.xy / iResolution.xy);\n        ray.direction = rand * sign(dot(normal, rand));\n        vec3 specular = vec3(1.0) * (alpha + 2.0) * pow(sdot(ray.direction, reflectionAngle), alpha);\n        if (material.emission) {\n            ray.energy *= material.intensity;\n            return material.color;\n        }\n        if (material.metallic) {\n            ray.energy *= specular;\n            return vec3(0.0);\n        }\n        ray.energy *= mix(diffuse, specular, fresnel);\n        return vec3(0.0);\n    } else {\n        ray.energy *= 0.0;\n        return vec3(0.0);\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    _Pixel = fragCoord;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 translatedUV = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    translatedUV /= 1.2;\n    \n    vec4 data = texture(iChannel0, uv);\n    if (iMouse.z > 0.0) data = vec4(0.0);\n    \n    vec3 camUp = vec3(0, 1, 0);\n\tvec3 camLookat = vec3(0, 10, 0);\n\n    float mx = -iMouse.x / iResolution.x * PI * 2.0 - 0.7;\n\tfloat my = -iMouse.y / iResolution.y * 1.45 + 1.55;\n\tvec3 camPos = vec3(cos(my) * cos(mx), sin(my), cos(my) * sin(mx)) * (35.0);\n\n    if ((dot(iMouse.xy, vec2(1.0)) <= 8.0)) camPos = vec3(12.0, 5.0, 6.0);\n\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + translatedUV.x * sideNorm * (iResolution.x/iResolution.y) + translatedUV.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n    \n    float aspectRatio = iResolution.y / iResolution.x;\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        float offset = rand2(vec2(float(i) + iTime, float(i) * iTime)) / iResolution.x;\n        vec3 rayDirection = rayVec + offset;\n        rayDirection = normalize(rayDirection);\n        vec3 color;\n        Ray ray = Ray(camPos, rayDirection, vec3(1.0, 1.0, 1.0));\n        for (int j = 0; j < NUM_BOUNCES; j++) {\n            HitInfo tracedRay = trace(ray);\n            color += ray.energy * shade(ray, tracedRay);\n            if (ray.energy == vec3(0.0))\n                break;\n        }\n        data += vec4(color, 1.0);\n    }\n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2SDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 203]]}
{"id": "ft2XWw", "name": "The Fly", "author": "dean_the_coder", "description": "The Fly was one of the first 'horror' movies I saw (waaay too young...).\nI think the unsung hero in the movie is the fly itself. This is a tribute to that little performer.\nIf anyone has tips to speed up compile time they'd be most welcome!", "tags": ["3d", "raymarching", "glow", "movie", "cineshader"], "likes": 24, "viewed": 5954, "published": 3, "date": "1627821460", "time_retrieved": "2024-07-30T19:08:17.497607", "image_code": "// 'The Fly' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/ft2XWw\n//  YouTube HD: https://youtu.be/Vq-9sCiXFLo\n// YouTube 360: https://youtu.be/wJyUM3pxl7I\n//\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 1,642 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// The Fly was one of the first 'horror' movies I saw (waaay\n// too young...). An awesome movie!\n// I think the unsung hero in the movie is the fly itself.\n// This is a tribute to that little performer.\n//\n// Tricks to get the performance:\n// - As always, making use of abs() to reflect objects.\n//   (There's only one window pane, and one horizontal pipe\n//   on the wall - The others are mirrored.)\n// - There's only one point light. The extra whiteness inside\n//   the 'pod' is faked in the material code.\n// - I tend to avoid using Shadertoy's textures.\n//   This is partly due to performance, but mostly because I'm\n//   a bit of a purist and like the idea of 'everything you\n//   see is generated in real time'. Although using that wood\n//   texture is always very tempting! :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S01(a)\tsmoothstep(0., 1., a)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n\nfloat t,\n      g = 0.;\n\n#define HASH\tp = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\n\nvec4 h44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(h44(h), h44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\n#define minH(a)\tif (a.x < h.x) h = a\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.y -= clamp(p.y, 0., h);\n\treturn length(p) - r;\n}\n\nfloat tor(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nfloat link(vec3 p, float le, float r1, float r2) {\n\tvec3 q = vec3(p.x, max(abs(p.y) - le, 0.), p.z);\n\treturn length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nfloat pod(vec3 p, bool isDr, out float w) {\n\tfloat d, dr,\n\t      s = step(3.25, p.y),\n\t      a = atan(p.x, p.z);\n\tw = (max(0., p.y - 1.) + sat(1. - p.y)) * .25 + s * .1;\n\td = max(cap(p, 3.2, 1.5 - sqrt(w * w + .001)), -p.y);\n\tw = d;\n\tdr = p.y * .09 - 1.3 - p.z - S(2.3, 3.3, p.y) - S(.3, 1.5, abs(p.x));\n\tif (isDr) return max(d, -dr);\n\td -= .15 * sat(sin(p.y * 30.)) * (1. - s) * step(1., p.y) + sat(sin(a * 25.) * .1 * s) * step(p.y, 3.5);\n\treturn isDr ? max(w, -dr) : max(max(d, dr), dr);\n}\n\nvec2 map(vec3 p) {\n\tvec2 h = vec2(p.y, 2);\n\tfloat d, podd,\n\t      w = t * 4.;\n\tvec3 pp = vec3(cos(w) * cos(w * 1.3) * .5, 1.5 + sin(w * .5) * .5, -6. * (S(10., 5., t) + S(32., 40., t)));\n\tpp = mix(pp, vec3(0, .3, 0), sat(S(16., 20., t) - S(28., 32., t)));\n\tminH(vec2(length(p - pp) - .02, 1));\n\tminH(vec2(8. - p.z, 4));\n\tpp = p;\n\tpp.x++;\n\tpp.y -= 3.3;\n\td = max(min(abs(4.5 - pp.z) - .5, 18. - p.x), -box(pp, vec3(1.26, 2.12, 4.6)));\n\tpp.xy = abs(abs(pp.xy) - vec2(.64, 1.08)) - vec2(.32, .54);\n\td = max(d, -box(pp, vec3(.3, .5, 9)));\n\tminH(vec2(d, 3));\n\tpp = p - vec3(7, 1, 0);\n\tminH(vec2(cyl(pp - vec3(0, .3, 1.2), vec2(S01(2. - pp.y), .1) * .8), 5));\n\tw = .05 * step(p.y, 1.5);\n\td = box(pp, vec3(2. - w, .7, 1. - w));\n\tpp.x = abs(pp.x) - 1.5;\n\tpp.y += .7;\n\td = min(d, box(pp, vec3(.05, .2, .8)) - .1);\n\tminH(vec2(d, 8));\n\tpp = p.zxy;\n\tpp.x -= 4.1;\n\tpp.y -= 1.4;\n\td = length(pp.xy + vec2(.5, 5.1)) - .16 - .03 * step(abs(cos(pp.z)), .05);\n\tpp.z = abs(pp.z - .4) - .15;\n\td = min(d, link(pp, 4., .5, .1));\n\tp.z--;\n\tpp = p;\n\tw = S(15., 12., t) + S(23., 26., t);\n\tpp.x += pow(sin(w * 1.6), 4.);\n\tpp.z += S(.7, 0., abs(w * 1.7 - 1.) - .3) * .3;\n\tminH(vec2(pod(pp, true, w), 7));\n\td = min(d, pod(p, false, podd) * .9);\n\tw = .05 + abs(.01 * sin((p.y - abs(p.x)) * 36.));\n\tp.yz++;\n\td = min(min(d, link(p, .5, 1.5, w)), link(p, .5, 1.2, w));\n\tp.y -= 1.7;\n\tp.z -= .3;\n\td = max(min(d, max(max(tor(p, vec2(.9, .7)), -p.z), tor(p - vec3(0, -.7, 0), vec2(1)))), -podd - .06);\n\tminH(vec2(d, 6));\n\td = max(length(p.xz) - .4, abs(p.y + .6) - .01);\n\tminH(vec2(d, 0));\n\tw = 1.;\n\tif (t > 16.) {\n\t\tif (t < 19.) w = .001 + .02 * (.5 + .5 * sin(t * 6.));\n\t\telse if (t < 23.) w = step(fbm(vec3(1, 1, t * 10.)), .2);\n\t}\n\n\tg += .005 / (.1 + d * d * 1e2 * w);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).x;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\tfloat i, h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (i = Z0; i < 30.; i++) {\n\t\th = map(t * ld + p).x;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 18.) break;\n\t}\n\n\treturn sat(s);\n}\n\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).x / h; }\n\nfloat fog(vec3 v) { return exp(dot(v, v) * -.002) * S(12., 6., v.y); }\n\nvec3 lights(vec3 p, vec3 rd, float d, vec2 h) {\n\tif (h.y == 1.) return vec3(.01);\n\tvec3 ld = normalize(vec3(2, 4, -1) - p),\n\t     n = N(p, d),\n\t     c = vec3(.2);\n\tfloat lig,\n\t      hs = 0.,\n\t      gg = g;\n\tif (h.y == 3.) c -= n31(p * .8) * .06;\n\telse if (h.y == 6.) c = vec3(.5 - .18 * n31(p * 26.)) * .3 * (1. + 6. * step(length(p - vec3(0, 1.5, 2)), 1.7));\n\telse if (h.y == 2.) c = mix(vec3(.04, .02, .02), vec3(.06, .04, .02), n21(p.xz * vec2(2.3, 30)));\n\telse if (h.y == 0.) c = vec3(1.2);\n\telse if (h.y == 4.) {\n\t\tc = vec3(.1, .2, .3) * (.24 - rd.y) * .6 + .01;\n\t\ths++;\n\t}\n\telse if (h.y == 5.) c = vec3(.15, .01, .02);\n\n\tfloat ao = mix(ao(p, n, 1.), ao(p, n, 2.), .7),\n\t      l1 = sat(.1 + .9 * dot(ld, n)) * (.3 + .7 * sat(hs + shadow(p, ld))) * (.3 + .7 * ao),\n\t      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.),\n\t      fre = S(.7, 1., 1. + dot(rd, n)) * .5;\n\tlig = l1 + l2 * ao;\n\tg = gg;\n\treturn mix(lig * c * vec3(2, 1.6, 1.5), vec3(.01), fre);\n}\n\nvec4 march(inout vec3 p, vec3 rd, float s) {\n\tfloat i,\n\t      d = .01;\n\tg = 0.;\n\tvec2 h;\n\tfor (i = Z0; i < s; i++) {\n\t\th = map(p);\n\t\tif (abs(h.x) < .0015) break;\n\t\td += h.x;\n\t\tif (d > 25.) return vec4(0);\n\t\tp += h.x * rd;\n\t}\n\n\treturn vec4(g + lights(p, rd, d, h), h.y);\n}\n\nvec3 scene(vec3 rd) {\n\tvec3 p = vec3(0);\n\tp -= vec3(1, -2. + t * .0125, 5.5 - t / 40.);\n\tvec4 col = march(p, rd, 80.);\n\tcol.rgb *= fog(p);\n\tif (col.w >= 6.) {\n\t\tfloat lp = length(p);\n\t\tvec3 n = N(p, lp);\n\t\tif (col.w == 7.) {\n\t\t\trd = refract(rd, n, 1.);\n\t\t\tp -= n * .3;\n\t\t\tcol += march(p, rd, 32.) * fog(p);\n\t\t\tcol *= .5;\n\t\t\tn = N(p, lp);\n\t\t}\n\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\tcol += .1 * march(p, rd, 32.) * fog(p);\n\t}\n\n\treturn col.rgb;\n}\n\n#define rgba(col)\tvec4(pow(max(vec3(0), col), vec3(.45)) * sat(t), 0)\n\nvoid mainVR(out vec4 fragColor, vec2 fc, vec3 ro, vec3 rd) {\n\tt = mod(iTime, 40.);\n\trd.xz *= mat2(1, 0, 0, -1);\n\tfragColor = rgba(scene(rd));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 40.);\n\tvec2 q = fc.xy / R.xy,\n\t     uv = (fc - .5 * R.xy) / R.y;\n\tvec3 f = normalize(vec3(mix(.5, .33, S(1., 10., t)), 0, 1)),\n\t     r = normalize(cross(vec3(0, 1, 0), f)),\n         col = scene(normalize(f + r * uv.x + cross(f, r) * uv.y));\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2XWw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1599, 1599, 1618, 1618, 1863], [1865, 1865, 1884, 1884, 1910], [1912, 1912, 1931, 1931, 2063], [2103, 2103, 2130, 2130, 2217], [2219, 2219, 2247, 2247, 2347], [2349, 2349, 2386, 2386, 2438], [2440, 2440, 2467, 2467, 2535], [2537, 2537, 2587, 2587, 2690], [2692, 2692, 2735, 2735, 3184], [3186, 3186, 3204, 3204, 4932], [4934, 4934, 4959, 4959, 5178], [5180, 5180, 5211, 5211, 5402], [5404, 5404, 5439, 5439, 5470], [5472, 5472, 5491, 5491, 5542], [5544, 5544, 5591, 5591, 6551], [6553, 6553, 6597, 6597, 6824], [6826, 6826, 6847, 6847, 7272], [7345, 7345, 7405, 7405, 7488], [7490, 7490, 7535, 7535, 7888]]}
{"id": "7tSSWm", "name": "Box Fractal", "author": "scry", "description": "Drivers were messed up leading to any raymarching to become a glitched mess, finally fixed it and verified by writing this with the new  working driver :)", "tags": ["2d", "3d", "3d", "raymarch", "kifs"], "likes": 5, "viewed": 326, "published": 3, "date": "1627795485", "time_retrieved": "2024-07-30T19:08:18.346338", "image_code": "\n#define time (iTime+80.)\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec4 map(vec3 p) {\n    float rtime = time*0.1;\n    for(int i=0;i<5;i++){\n    p = abs(p)-0.2;\n    p.xz *= r2d(rtime);\n    p.yz *= r2d(rtime);\n    }\n    float d = sdBoxFrame(p,vec3(1.),0.05);\n    p.xz *= r2d((3.14159/180.)*45.);\n    p.yz *= r2d((3.14159/180.)*45.);\n    d = min(d,sdBoxFrame(p,vec3(1.),0.05));\n    //float d = length(p)-0.5;\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO,ii;\n    for (int i=0;i<250;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.13;\n        if (dO > 1000. || dS < 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * (fragCoord/iResolution.xy);\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x *= ar;\n    float rtime = time*0.1;\n    float size = sin(time*0.1)*0.5+0.5;\n    vec2 ouv = uv;\n    for (int i=0;i<30;i++) {\n        uv = abs(uv)-size*1.;\n        uv.xy *= r2d(rtime*0.4+2.1);\n    }\n    uv = mix(uv,ouv,sin(time*0.055)*0.5+0.5);\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,0.,-5.);\n    vec3 rd = normalize(vec3(uv,1.));\n    float rt = time*0.1;\n    ro.xy *= r2d(rt);\n    rd.xy *= r2d(rt);\n    ro.xz *= r2d(rt);\n    rd.xz *= r2d(rt);\n    vec2 d = RM(ro,rd);\n    col = vec3(d.x*0.05);\n    col.r += sin(col.r*100.)*0.2;\n    if (d.x > 999.) {\n        col = vec3(sin(d.y+3.4)*1.);\n    }\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 45, 45, 94], [96, 144, 189, 189, 471], [473, 473, 491, 491, 835], [837, 837, 864, 864, 1084], [1086, 1086, 1143, 1143, 1888]]}
{"id": "Nt2XWD", "name": "Joshua Tree", "author": "scry", "description": "What a trip!\n\n4K Video https://www.youtube.com/watch?v=Wf_WThID6tc", "tags": ["3d", "fractal", "sdf", "kifs", "trippy", "buffer"], "likes": 12, "viewed": 431, "published": 3, "date": "1627791720", "time_retrieved": "2024-07-30T19:08:19.340679", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 r2d(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//from iq's sdf page\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#define yheight 50.\n#define time iTime\nvec4 map(vec3 p, float z) {\n    //p.xz *= r2d(0.005);\n    vec3 o = p;\n    //p.xz *= r2d(0.004);\n    //p.zx *= r2d(mouse.x*10.);\n    //p.xy *= r2d(mouse.y*10.);\n    o = p;\n    p.xz *= r2d(0.01);\n    //p.y /= 0.02;\n    //p.y /= sin(time*0.51)*0.5+0.5;\n    float ts = 0.01;\n    //ts -= (sin(o.z*0.0001)*0.5+0.5)*0.001;\n    vec2 pq = floor(p.xz*ts*0.06);\n    p.xz *= r2d(-rand(pq)*200.);\n    //p.xz += (hash22(floor((p.xz*ts*0.5)))-0.5)*150.;\n    vec2 pi = floor((p.xz*ts)+0.); \n    float rp = rand(pi);\n    p.y -= (rp-0.5)*60.;\n    p.xz += (hash22(floor((p.xz*ts*0.25)))-0.5)*50.;\n    //p.xz *= r2d(rand(pq)*0.1);\n    //p.xz += (hash22(pi)-0.5)*80.;\n    //p.xz *= r2d(sin(p.z*0.1)*0.0002);\n    p.xz = (fract(p.xz*ts)-0.5)/ts;\n    //p.xz += sin(pi*903.232)*5;\n    //pi *= 1.;\n    \n    //p.xz *= r2d(sin(p.z*0.4));\n    //p.xz += (hash22(pi)-0.5)*80.;\n    p.xz *= r2d(rp*5590.);\n    p.xz *= r2d(p.y*rp*0.05);\n    //p.xz *= r2d(sin(sin(pi.x*1.682)+sin(pi.y*30.148)));\n    float pa = 0.5+rp*5.;\n    int ls = 2;\n    ls += int(rp*6.)-2;\n    ls = abs(ls)+1;\n    //ls = 2;\n    //p.xz += rp*5;\n    //p.y *= 1.5;\n    //p.z -= 1.5;\n    float r = time*0.02;\n    r += rp*2000.;\n    r = sin(r)*0.5+0.5;\n    r *= 0.1;\n    r += 0.12;\n    //r *= 1.56;\n    //r = sin(r);\n    p.y -= 9.;\n    p.y = clamp(p.y,0.,p.y+1.);\n    //p.y = clamp()\n    //p.y -= 9.;\n    //p.y = abs(p.y)-1.;\n    //p.y -= 1.;\n    //p.y = abs(p.y)-1.;\n    p.x = abs(p.x);\n    p.xy *= r2d(-r);\n    p.y = abs(p.y);\n    p.xy *= r2d(-r);\n    float cl = 4.6;\n    cl -= sin(rp*10.)*4.;\n    float tl = cl;\n    //\n    //p.xz *= r2d(sin(p.y*0.1)*02.9);\n    for (int l=0;l<ls;l++) {\n        p.xz *= r2d(sin(p.y*0.3)*0.5);\n        p.zx *= r2d((3.14*0.5)+rp);\n        p.y -= tl;\n        //tl *= 1.01;\n        p.x = abs(p.x);\n        p.xy *= r2d(-r);\n        p.y = abs(p.y);\n        p.xy *= r2d(-r);\n        //p.zx *= r2d(0.);\n    }\n    //p.z = abs(p.z);\n    //float d = length(p)-0.5;\n    float w = 0.7+rp;\n    //w -= rp/w;\n    float dm = 1.;\n    if (w < 0.2 || ls < 2 || cl < 1.7) {\n        w = -20.;\n        dm = 1.4;\n        //p *= 2000000.;\n        //cl = 0.;\n    }\n    //w += sin(p.y*0.5+time)*0.1+0.1;\n    //w *= 0.5;\n    //w = 0.9;\n    //w = w*w;\n    //w = 1.;\n    float d = sdCappedCylinder(p,w,cl)*0.5;\n    //d += 0.5;\n    float pp = d;\n    float fl = 20.;\n    float el = 5.;\n    //el += (sin(o.z*0.001)*0.5+0.5)*200;\n    d = min(d,length(o.y+el+fl)-fl)*dm;\n    d = max(d,-(length(vec2(o.x,o.y-yheight))-0.5));\n    //d = max(d,-(length(vec2(o.x,o.y-20.))-020.+(o.z-z)*0.2));\n    //o.z -= z;\n    //o.yz *= r2d(-0.4);\n    //d = max(d,-(length(o.y-50.)-(1.-(1./(time*0.1))))*50.);\n    //d = max(d,-(length(o.y-50.)-36.));\n    return vec4(pi,pp,d);\n}\n//vec2 vuv = inData.v_texcoord;\n#define MAXD 1920.\nvec2 RM(vec3 ro, vec3 rd, vec2 vuv) {\n    float dO = 0.;\n    float ii = 0.;\n    float it = 1.-(1./(time*0.005+1.02));\n    //float ad = map(ro+rd*dO).w;\n    int steps = 190;\n    \n    float vm = sin(vuv.y*3.14*1.2+6.4)*0.5+0.5;\n    steps = int(float(steps)*vm*1.3);\n    //steps = int(steps*(sin(vuv.y*3.14*1.5+5.5)*0.5+0.5)*.9);\n    for (int i=0;i<steps;i++) {\n        vec3 p = ro+rd*dO;\n        //p.xz *= r2d();\n        float dS = map(p,ro.z).w;\n        dO += dS*(1.-vm*0.5)*1.2;\n        //dO += dS/(1.-vuv.y*.6);\n        //dO += dS*it*1.8;\n        ii += 0.16;\n        if (dO > MAXD) {break;} \n        if (dS < 0.01) {\n            //ii += 10.;\n            //dO += 1.02;\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\n//vec3 RCam(vec3 ro, float r) {\n//    ro.xy *= r2d(r);\n//    rd.xy *= r2d(r);\n//    return vec4(ro,rd);\n//}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//void main(void)\n//{\n    vec2 uv = -1. + 2. *(fragCoord/iResolution.xy);\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    vec2 vuv = (fragCoord/iResolution.xy);\n    vec3 col = vec3(0.);\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv.x *= ar;\n    float c = length(uv);\n    //vec3 ro = vec3(0.,1.,-45.);\n    vec3 ro = vec3(0.,yheight,(time*20.)+10.);\n    vec2 dt = vec2(13.,40.);\n    //dt = mix(dt,vec2(1.),1.-(1./(time*time*0.001)));\n    vec3 rd = normalize(vec3(uv,1.));\n    //vec3 rd = normalize(vec3(uv,dt.x-c*dt.y));\n    float m = iMouse.x+iMouse.y;\n    vec2 tv = fragCoord/iResolution.xy;\n    //vec3 bak = texture(prevFrame,tv).rgb;\n    //m = 0.09;\n    //ro.yz *= r2d(m);\n    float cs = time*0.1;\n    rd.yz *= r2d(-0.4);\n    rd.xz *= r2d(-3.5);\n    ro.xz *= r2d(-3.5);\n    //rd.xz *= r2d(time*0.1);ro.xz *= r2d(2);\n    //rd.yz *= r2d(sin(cs)*0.25);\n    //ro.y += sin(cs-2.)*15.;\n    //rd.yz *= r2d((mouse.y-0.5)*2.);\n    //rd.xz *= r2d((mouse.x-0.5)*2.);\n    vec2 d = RM(ro,rd,vuv);\n    col = 1.-d.xxx*0.01;\n    vec3 p = ro+rd*d.x;\n    vec4 pp = map(p,ro.z);\n    vec3 lp = p-ro.xxz;\n    col = sin((pp).zzz*0.2+2.5);\n    col -= sin(d.y*0.8);\n    col = hsv2rgb(vec3(d.y*0.02-0.9,1.,1.-d.y*0.05));\n    //col = hsv2rgb(sin(p.xyy)*0.8);\n    if (lp.y < -1.9) {\n        \n        col -= floor((sin(p.xxx*0.1)+sin(p.zzz*0.1))+0.5)*0.06;\n        col += sin(sin(pp.z*0.31)/d.x*2000.)*0.2;\n        //col = mix(col,hsv2rgb(vec3(d.y,col.y,col.x)),0.1);\n    }\n    tv.y -= 1./R.y;\n    tv -= 0.5;\n    //tv.x *= 1.+sin(time)*0.01;\n    tv += 0.5;\n    //col += hsv2rgb(sin(p*0.1+time));\n    //tv.x += sin(uv.y*20+time*0.21+uv.x*20)*0.0001;\n    //tv -= 0.5;tv.xy *= r2d(sin(time*0.02)*0.01);tv += 0.5;\n    //tv.y -= ro.y*0.000009+tv.y*0.0002;\n    vec3 bak = texture(iChannel0,tv).rgb;\n    bak = rgb2hsv(bak);\n    bak = hsv2rgb(vec3(bak.r*1.01+0.001,bak.g*0.9999,mix(1.-d.y*0.04,bak.b,0.8)));\n    //bak = hsv2rgb(vec3(bak.r*1.02,bak.g*0.99,fract(bak.b+0.0025)));\n    if (d.x > MAXD) {\n        //col = vec3(0.2,0.35,0.6);\n        //col = bak;\n        //col = sin(col*20.9)-bak;\n        col = mix(bak,vec3(0.4,1.1,0.4),0.01);\n    }\n    //col = mix(clamp(col,0.,1.),bak,(1.-(d.x/MAXD)));\n    //col *= 0.\n    //col += d.yyy*0.1;\n    //col += sin(d.x*0.01);\n    //col.rg += sin(pp.xy*2);\n    //col = sin(d.xxx);\n    //col = (d.yyy-15.)*0.2;\n    fragColor = vec4(col,1.);\n}\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}*/\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2XWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 279]]}
{"id": "slBSWw", "name": "Inconvergent-style Volumetrics ", "author": "clepirelli", "description": "Volumetric light as described in this post by Inconvergent: https://inconvergent.net/2021/volumetric-light/", "tags": ["volumetrics", "ziggurat"], "likes": 7, "viewed": 444, "published": 3, "date": "1627783265", "time_retrieved": "2024-07-30T19:08:20.172455", "image_code": "const int sampleCount = 4;\n\nconst float cameraDistance = 2.;\nconst float cameraHeight = 3.0;\n\nRay getHitRay(vec2 uv)\n{\n    const vec3 cameraPosition = vec3(cameraDistance, cameraHeight, cameraDistance);\n    \n    float angle = 5.6;\n    vec3 pos = cameraPosition;\n    pos.x *= sin(angle);\n    pos.z *= cos(angle);\n    //camera calculations\n    vec3 target = vec3(.0);\n    vec3 rayOrigin = target + pos;\n    vec3 front = normalize(target-rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    vec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \t\n    return Ray(rayOrigin, rayDir);\n}\n\nvec3 lineSample(vec3 start, vec3 end, vec2 uv, int iteration)\n{\n    return mix(start, end, pseudorandScalar(uv+float(iteration)+sin(iTime), uv, iChannel0)); \n}\n\nfloat traceScene(Ray ray)\n{\n    const int boxAmount = 3;\n    Box boxes[boxAmount] = Box[boxAmount]\n    (\n        Box(vec3(.0, .2, .0), vec3(1.5, .2, 1.5))\n       ,Box(vec3(.0, .4, .0), vec3(1., .2, 1.))\n       ,Box(vec3(.0, .8, .0), vec3(.5, .2, .5))\n    );\n\n\n    float result = missValue;\n    for(int i = 0; i < boxAmount; i++)\n    {\n        result = min(result, boxIntersection(ray, boxes[i]).near);\n    }\n    \n    Box zobb = Box(vec3(-1.0, .2, .0), vec3(1.0, .5, .4));\n    const float rotation = 2.8;\n    result = min(result, zobbIntersection(ray, zobb, rotation).near);\n    \n    const Plane plane = Plane(vec3(.0), vec3(.0,1.,.0));\n    \n    return min(result, planeIntersection(ray, plane));\n}\n\nbool pathClear(vec3 start, vec3 end)\n{\n    vec3 delta = end-start;\n    float dist = length(delta);\n    vec3 direction = delta/dist;\n    float result = traceScene(Ray(start, direction));\n    return result < .0 || result > dist;\n}\n\nvec3 Image(vec2 uv)\n{\n    Ray currentRay = getHitRay(uv);\n    float dist = traceScene(currentRay);\n    vec3 hit = currentRay.origin + currentRay.direction * dist;\n    \n    vec3 lightPosition = vec3(sin(iTime*.3)*10.0, 2.0, cos(iTime*.3)*-10.0);\n    const float lightStrength = 1.; \n    \n    \n    float pixelValue = .0;\n    \n    for(int i = 0; i < sampleCount; i++)\n    {\n        vec3 randPosition = lineSample(currentRay.origin, hit, uv, i);\n        if(pathClear(randPosition, lightPosition))\n        {\n            vec3 delta = randPosition-lightPosition;\n            float lightDistSquared = dot(delta, delta);\n            pixelValue += dist / (1.0 + lightDistSquared);\n        } \n    }\n    \n    pixelValue *= lightStrength / float(sampleCount);\n    \n    return vec3(pixelValue, pixelValue, pixelValue);\n}\n\nMAIN_FUNCTION(Image)", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int aa = 2;\n\n\nstruct Box\n{\n    vec3 center;\n    vec3 halfDimensions;\n};\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct Plane\n{\n    vec3 point;\n    vec3 normal;\n};\n\nstruct BoxReturn\n{\n    float near;\n    float far;\n};\nconst float missValue = 100000000.0;\nconst BoxReturn boxReturnMiss = BoxReturn(missValue, missValue);\n\nBoxReturn boxIntersection(Ray ray, Box box)\n{\n    vec3 maximum = box.center + box.halfDimensions;\n    vec3 minimum = box.center - box.halfDimensions;\n    //from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-box-intersection\n    bool xSign = ray.direction.x >= 0.;\n    bool ySign = ray.direction.y >= 0.;\n    vec3 inverseDir = 1.0/ray.direction;\n    \n    float nearest = ((xSign ? minimum : maximum).x - ray.origin.x) * inverseDir.x; \n    float nextNearest = ((xSign ? maximum : minimum).x - ray.origin.x) * inverseDir.x; \n    float nearestY = ((ySign ? minimum : maximum).y - ray.origin.y) * inverseDir.y; \n    float nextNearestY = ((ySign ? maximum : minimum).y - ray.origin.y) * inverseDir.y; \n \n    if (nearest > nextNearestY || nearestY > nextNearest) \n        return boxReturnMiss;\n    \n    nearest = max(nearestY, nearest);\n    nextNearest = min(nextNearestY, nextNearest);\n    \n    bool zSign = ray.direction.z >= 0.;\n    float nearestZ = ((zSign ? minimum : maximum).z - ray.origin.z) * inverseDir.z;\n    float nextNearestZ = ((zSign ? maximum : minimum).z - ray.origin.z) * inverseDir.z; \n    \n    if ((nearest > nextNearestZ) || (nearestZ > nextNearest)) \n        return boxReturnMiss;\n    \n    nearest = max(nearest, nearestZ);\n    nextNearest = min(nextNearestZ, nextNearest);\n    \n    return BoxReturn(nearest, nextNearest);\n}\n\nvec3 rotateZ(vec3 v, float angle)\n{\n    mat3 rotation = mat3(\n        cos(angle), -sin(angle), .0,\n        sin(angle), cos(angle), .0,\n        .0, .0, 1.0\n    );\n    return v * rotation;\n}\n\nBoxReturn zobbIntersection(Ray ray, Box box, float zRotation)\n{\n    ray.origin -= box.center;\n    box.center = vec3(.0);\n    ray.origin = rotateZ(ray.origin, zRotation);\n    ray.direction = rotateZ(ray.direction, zRotation);\n    return boxIntersection(ray, box);\n}\n\nfloat planeIntersection(Ray ray, Plane plane)\n{\n    float denom = dot(plane.normal, ray.direction);\n    if (abs(denom) > 0.0001)\n    {\n        float result = dot(plane.point - ray.origin, plane.normal) / denom;\n        return result < .0 ? missValue : result;\n        \n    }\n    return missValue;\n}\n\nfloat pseudorandScalar(vec2 randseed, vec2 uv,  sampler2D tex)\n{\n    //blue noise with toroidal shifting\n\treturn fract(texture(tex, uv).x + fract(sin(dot(randseed, vec2(1.0,113.0)))*43758.5453123));\n}\n\nvec4 colorCorrect(vec3 color)\n{\n    vec3 x = max(vec3(.0), color-.004);\n    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    return vec4(min(retColor, 1.0), 1.0);\n}\n\n#define MAIN_FUNCTION(function) \\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\\n{\\\n    vec3 total = vec3(.0);\\\n    /*MSAA*/\\\n    for(int i = 0; i <aa;i++)\\\n    for(int j = 0; j <aa;j++)\\\n    {\\\n    \t/*offset the uv for MSAA*/\\\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\\\n    \tuv.x *= iResolution.x/iResolution.y;\\\n    \t\\\n        total+= function(uv);\\\n    }\\\n    total /= float(aa*aa);\\\n    \\\n    /*Output to screen*/\\\n    fragColor = colorCorrect(total);\\\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 118, 118, 652], [654, 654, 717, 717, 813], [815, 815, 842, 842, 1512], [1514, 1514, 1552, 1552, 1742], [1744, 1744, 1765, 1765, 2550]]}
{"id": "7tSSDh", "name": "Intersection Line - Circle ", "author": "Yusef28", "description": "Quadratic Formula", "tags": ["line", "intersection", "circle"], "likes": 5, "viewed": 346, "published": 3, "date": "1627781611", "time_retrieved": "2024-07-30T19:08:21.050109", "image_code": "/////////////////////////////////////////////////////////////\n//                                                         //\n// Author:Yusef28                                          //\n// Start Date: 26-07-2021                                  //\n// Status: On Going                                        //\n// Topic: Line-Circle Intersection                         //\n// Sources: Rudimentary Concept (Google/Wikipedia/Youtube) //\n// Listening to: Best Of Djent Instrumental Volume 1       //\n//                                                         // \n/////////////////////////////////////////////////////////////\n\n// Spent a few hours(yup) because I didn't realize I need brackets \n//in one part of the quadratic formula as I had expressed it.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////      BACKGROUND GRID DESIG          //\n      //                                   //\n      /////////////////////////////////////\n      \n    vec2 st = uv;//save the unscaled uv\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.1);\n    //center highlights\n    col = mix(col,vec3(0.16),1.0-length(uv/8.));\n    //dust \n    float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    //nice soft texture \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.25),pow(tex,2.));\n    //small grid lines\n    vec2 lines = fract(uv*5.);\n    lines = smoothstep(0.45,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.24),lines.x);\n    col = mix(col,vec3(0.24),lines.y);\n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.47,0.52,abs(lines-0.5));\n    col = mix(col,vec3(0.5),lines.x);\n    col = mix(col,vec3(0.5),lines.y);\n    //axis lines\n    lines = smoothstep(0.0,0.02,abs(uv));\n    col = mix(col,vec3(0.6),1.0-lines.x);\n    col = mix(col,vec3(0.6),1.-lines.y);\n    col = mix(col,vec3(0.1),step(0.1,specks)*0.2);\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////     INTERSECTION CALCULATIONS       //\n      //                                   //\n      /////////////////////////////////////\n    \n    //Line Variables using y = m1*x = b1\n    vec2 p1 = vec2(-0.4,-0.4);\n    vec2 p2 = vec2(0.7,0.9);\n    \n    \n    float m1 = sin(iTime)*2.;//line slope\n    \n    float b1 = cos(iTime+0.4)*2.5;\n    //line shift( y intercept)\n  \n    float r = 2.;//circle radius\n    \n\n    \n    //a b and c for the quadratic formula \n    //work out to this based on my algebraic manipulations\n    //starting with substituting y in the circle formula\n    //with the right hand side of the line equation y = m1*x+b1\n    float a = 1. + m1*m1;\n    float b = 2.*(-0. + (b1 - 0.)*m1);\n    float c = -0.*-0. + (b1 - 0.)*(b1 - 0.) - r*r;\n    \n    //the discriminant\n    float disc = b*b - 4.*a*c;\n    \n    //the two roots (or one or none de0pending)\n    float x1 = (-b + sqrt(disc))/(2.*a); //<-- this right here!!!!\n    float x2 = (-b - sqrt(disc))/(2.*a); //<-- If you forget bracket on (2.*a)...\n                                         //you're gonna have a bad experience.\n    \n    float y1 = m1*x1 + b1;\n    float y2 = m1*x2 + b1;\n    //calculate the intersection points\n    \n    vec2 intersectionPoint1 = vec2(x1,y1);\n    vec2 intersectionPoint2 = vec2(x2,y2);\n        \n      ////////////////////////////////////////////\n      //                                       //\n////////        DRAWING EVERYTHING           //\n      //                                   //\n      /////////////////////////////////////\n    \n    //line 1\n    float f;// = 1.0-smoothstep(0.02,0.06,abs(uv.x*m1 + b1 - uv.y));\n    f = 1.0-smoothstep(0.05,0.1,abs(uv.x*m1 + b1 - uv.y)/fwidth(uv.x*m1 + b1 - uv.y)/20.);\n    col = mix(col, vec3(1.,.2,0.5), f);\n    \n    //circle on origin with radius 1.\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv)-r));\n    col = mix(col, vec3(0.,0.7,1.), f);\n    \n    if(disc >= 0.){\n    //intersection point 1\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-intersectionPoint1)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-intersectionPoint1)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    //intersection point 2\n    f = 1.-smoothstep(0.02,0.04,abs(length(uv-intersectionPoint2)-0.15));\n    col = mix(col, vec3(1.,0.7,0.), f);\n    f = 1.-smoothstep(0.03,0.08,length(uv-intersectionPoint2)-0.015);\n    col = mix(col, vec3(1.,0.7,0.), f);\n    }\n    \n      ////////////////////////////////////////////\n      //                                       //\n////////          POST PROCESSING            //\n      //                                   //\n      /////////////////////////////////////\n        \n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[754, 754, 811, 863, 5265]]}
{"id": "stBSWw", "name": "SpaceEYE2", "author": "jj99", "description": "color", "tags": ["fbm"], "likes": 5, "viewed": 272, "published": 3, "date": "1627776768", "time_retrieved": "2024-07-30T19:08:21.864930", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    //return f/0.984375;\n    return f;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.09);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 n2 (vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd+iTime*.0125);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.85,.25);\n    vec3 col2 =  vec3(1.4,1.4,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return col;\n\n}\n#define PI 3.14159\n\n\nfloat vDrop(vec2 uv,float t)\n{\nuv.y *= 0.25;\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*2.2)+time*0.1)*3.5;\n\tss+=8.0;\n   \tvec2 coord = ss*position;\n    \n    coord.y *= 1.0+(sin(time*0.04+coord.x*.24)*0.3);\n    \n    coord*=rot(ss*0.04+time*0.017);\n    coord*=0.25;\n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.05;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\n    vec3 col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2))*0.08;\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*2.7+position.x*2.41+time*0.9)*0.5;\n\t\n    vec3 col2 = n2(fragCoord)*0.9;\n    \n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p);\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    float t = -time*0.04;\n    float drop = vDrop(p,t);\n    drop += vDrop(p,t+0.5);\n    drop*=d;\n    \n        col2+=(col*.965);\n    \n\tcol = mix(col,col2,nn);\n    col = mix(col,col*1.075,drop);\n    \n    col+=col*((d+dd)*0.28);\n    col *= d;\n    \n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 438], [440, 440, 459, 459, 732], [734, 734, 755, 755, 893], [895, 895, 916, 916, 984], [987, 987, 1008, 1008, 1215], [1218, 1238, 1260, 1260, 1657], [1659, 1672, 1702, 1702, 1975], [1977, 1977, 2003, 2003, 2720], [2742, 2742, 2772, 2772, 3234], [3237, 3237, 3294, 3294, 4679]]}
{"id": "7tSSWw", "name": "SpaceEYE", "author": "jj99", "description": "color please", "tags": ["fbm"], "likes": 4, "viewed": 218, "published": 3, "date": "1627776186", "time_retrieved": "2024-07-30T19:08:22.629885", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    //return f/0.984375;\n    return f;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.09);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 n2 (vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd+iTime*.0125);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.85,.25);\n    vec3 col2 =  vec3(1.4,1.4,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return col;\n\n}\n#define PI 3.14159\n\n\nfloat vDrop(vec2 uv,float t)\n{\nuv.y *= 0.25;\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*3.0)+time*0.1)*2.5;\n\tss+=8.0;\n   \tvec2 coord = ss*position;\n    coord*=rot(ss*0.04+time*0.037);\n    coord*=0.25;\n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.05;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\n    vec3 col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2))*0.08;\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*2.7+position.x*2.41+time*0.9)*0.5;\n\t\n    vec3 col2 = n2(fragCoord)*0.9;\n    \n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p);\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    float t = -time*0.014;\n    float drop = vDrop(p,t);\n    drop += vDrop(p,t+0.5);\n    drop*=d;\n    \n        col2+=(col*.565);\n    \n\tcol = mix(col,col2,nn);\n    col = mix(col,col*1.075,drop);\n    \n    col+=col*((d+dd)*0.28);\n    col *= d;\n    \n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSSWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 440], [442, 442, 461, 461, 734], [736, 736, 757, 757, 895], [897, 897, 918, 918, 986], [989, 989, 1010, 1010, 1217], [1220, 1240, 1262, 1262, 1659], [1661, 1674, 1704, 1704, 1977], [1979, 1979, 2005, 2005, 2722], [2744, 2744, 2774, 2774, 3236], [3239, 3239, 3296, 3296, 4619]]}
{"id": "NtSXWm", "name": "SmokeDMT", "author": "jj99", "description": "I smoked some drugs today", "tags": ["fbm"], "likes": 9, "viewed": 452, "published": 3, "date": "1627773417", "time_retrieved": "2024-07-30T19:08:23.552418", "image_code": "float hash( float n )\n{\n    return fract(sin(n)*758.5453)*2.;\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x); \n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*800.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x), mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n            mix(mix( hash(n+800.0), hash(n+801.0),f.x), mix( hash(n+857.0), hash(n+858.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    f += 0.50000*noise( p ); p = p*2.02+0.15;\n    f -= 0.25000*noise( p ); p = p*2.03+0.15;\n    f += 0.12500*noise( p ); p = p*2.01+0.15;\n    f += 0.06250*noise( p ); p = p*2.04+0.15;\n    f -= 0.03125*noise( p );\n    //return f/0.984375;\n    return f;\n}\n\nfloat cloud(vec3 p)\n{\n    p-=fbm(vec3(p.x,p.y,0.0)*0.5)*0.7;\n    \n    float a =0.0;\n    a-=fbm(p*3.0)*2.2-1.1;\n    if (a<0.0) a=0.0;\n    a=a*a;\n    return a;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.09);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nvec3 n2 (vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd+iTime*.0125);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.85,.25);\n    vec3 col2 =  vec3(1.4,1.4,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    return col;\n\n}\n#define PI 3.14159\n\n\nfloat vDrop(vec2 uv,float t)\n{\nuv.y *= 0.25;\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.3 +.7;\t\t\t// speed\n    float trail = mix(95.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*PI)*(s*5.0);\n    float d2 = sin(dx*PI);\n    return yv*(d2*d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 position = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\tfloat ss = sin(length(position*2.0)+time*0.125)*1.5;\n\tss+=7.0;\n   \tvec2 coord = ss*position;\n    coord*=rot(ss*0.04+time*0.037);\n    coord*=0.34;\n    coord+=fbm(sin(vec3(coord*8.0,time*0.001)))*0.05;\n    coord+=time*0.0171;\n    float q = cloud((vec3(coord*1.0,0.222)));\n    coord+=time*0.0171;\n    q += cloud((vec3(coord*0.6,0.722)));\n    coord+=time*0.0171;\n    q += cloud(vec3(coord*0.3,.722));\n    coord+=time*0.1171;\n    q += cloud((vec3(coord*0.1,0.722)));\n    \n    \n\tfloat vv1 = sin(time+ss+coord.x)*0.3;\n\tfloat vv2 = sin(time*0.9+ss+coord.y)*0.2;\n\n    vec3 col = vec3(1.7-vv2,1.7,1.7+vv1) + vec3(q*vec3(0.7+vv1,0.5,0.3+vv2*1.15));\n\tcol = pow(col,vec3(2.2))*0.08;\n\t\n\tfloat dd = length(col*.48)+vv1;\n\t\n\tfloat nn = 0.5+sin(ss*2.7+position.x*2.41+time*0.9)*0.5;\n\t\n    vec3 col2 = n2(fragCoord)*0.9;\n    \n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float d = length(p);\n\tp = vec2(atan(p.x, p.y) / PI, 2.5 / d);\n    float t = time*0.014;\n    float drop = vDrop(p,t);\n    drop += vDrop(p,t+0.5);\n    drop*=d;\n    \n        col2+=(col*.565);\n    \n\tcol = mix(col,col2,nn);\n    col = mix(col,col*1.075,drop);\n    \n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 63], [65, 65, 91, 91, 440], [442, 442, 461, 461, 734], [736, 736, 757, 757, 895], [897, 897, 918, 918, 986], [989, 989, 1010, 1010, 1217], [1220, 1240, 1262, 1262, 1659], [1661, 1674, 1704, 1704, 1977], [1979, 1979, 2005, 2005, 2722], [2744, 2744, 2774, 2774, 3236], [3239, 3239, 3296, 3296, 4573]]}
